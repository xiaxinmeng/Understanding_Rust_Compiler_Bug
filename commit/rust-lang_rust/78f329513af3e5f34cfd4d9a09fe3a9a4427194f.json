{"sha": "78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZjMyOTUxM2FmM2U1ZjM0Y2ZkNGQ5YTA5ZmUzYTlhNDQyNzE5NGY=", "commit": {"author": {"name": "Chase Albert", "email": "thaoeuns@gmail.com", "date": "2020-04-02T21:09:20Z"}, "committer": {"name": "Chase Albert", "email": "thaoeuns@gmail.com", "date": "2020-05-04T17:51:21Z"}, "message": "Check that shims are called with the correct number of arguments", "tree": {"sha": "cdb49227551fab7543214b63f441e3752f3b1f01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdb49227551fab7543214b63f441e3752f3b1f01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "html_url": "https://github.com/rust-lang/rust/commit/78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/comments", "author": {"login": "toc-the-younger", "id": 1740780, "node_id": "MDQ6VXNlcjE3NDA3ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1740780?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toc-the-younger", "html_url": "https://github.com/toc-the-younger", "followers_url": "https://api.github.com/users/toc-the-younger/followers", "following_url": "https://api.github.com/users/toc-the-younger/following{/other_user}", "gists_url": "https://api.github.com/users/toc-the-younger/gists{/gist_id}", "starred_url": "https://api.github.com/users/toc-the-younger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toc-the-younger/subscriptions", "organizations_url": "https://api.github.com/users/toc-the-younger/orgs", "repos_url": "https://api.github.com/users/toc-the-younger/repos", "events_url": "https://api.github.com/users/toc-the-younger/events{/privacy}", "received_events_url": "https://api.github.com/users/toc-the-younger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "toc-the-younger", "id": 1740780, "node_id": "MDQ6VXNlcjE3NDA3ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1740780?v=4", "gravatar_id": "", "url": "https://api.github.com/users/toc-the-younger", "html_url": "https://github.com/toc-the-younger", "followers_url": "https://api.github.com/users/toc-the-younger/followers", "following_url": "https://api.github.com/users/toc-the-younger/following{/other_user}", "gists_url": "https://api.github.com/users/toc-the-younger/gists{/gist_id}", "starred_url": "https://api.github.com/users/toc-the-younger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/toc-the-younger/subscriptions", "organizations_url": "https://api.github.com/users/toc-the-younger/orgs", "repos_url": "https://api.github.com/users/toc-the-younger/repos", "events_url": "https://api.github.com/users/toc-the-younger/events{/privacy}", "received_events_url": "https://api.github.com/users/toc-the-younger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a49234ebaff9a1fb3b79deaafd1ff606279cdee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a49234ebaff9a1fb3b79deaafd1ff606279cdee6", "html_url": "https://github.com/rust-lang/rust/commit/a49234ebaff9a1fb3b79deaafd1ff606279cdee6"}], "stats": {"total": 685, "additions": 445, "deletions": 240}, "files": [{"sha": "43a20d290c80fe843486a171d4793aa962dd54db", "filename": "src/helpers.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -1,4 +1,4 @@\n-use std::convert::TryFrom;\n+use std::convert::{TryFrom, TryInto};\n use std::mem;\n use std::num::NonZeroUsize;\n \n@@ -471,6 +471,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n+/// Check that the number of args is what we expect.\n+pub fn check_arg_count<'a, 'tcx, const N: usize>(args: &'a [OpTy<'tcx, Tag>]) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n+    where &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]> {\n+    if let Ok(ops) = args.try_into() {\n+        return Ok(ops);\n+    }\n+    throw_ub_format!(\"incorrect number of arguments, got {}, needed {}\", args.len(), N)\n+}\n+\n pub fn immty_from_int_checked<'tcx>(\n     int: impl Into<i128>,\n     layout: TyAndLayout<'tcx>,"}, {"sha": "e8cf507d35a0acb0edf30a39dff0c344e238f9b7", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -7,6 +7,9 @@\n #![warn(rust_2018_idioms)]\n #![allow(clippy::cast_lossless)]\n \n+#![allow(incomplete_features)]\n+#![feature(const_generics)]\n+\n extern crate rustc_apfloat;\n extern crate rustc_ast;\n #[macro_use] extern crate rustc_middle;"}, {"sha": "3c4a942b596fb2583efd35d70402893e21f1247f", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -1,6 +1,7 @@\n use rustc_middle::mir;\n \n use crate::*;\n+use helpers::check_arg_count;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Dlsym {\n@@ -35,8 +36,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         match dlsym {\n             GetEntropy => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let &[ptr, len] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 this.gen_random(ptr, len)?;\n                 this.write_null(dest)?;\n             }"}, {"sha": "643f76bfe37a1e67c933a6ba9f03cfc87dad26e9", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 55, "deletions": 36, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -11,6 +11,7 @@ use rustc_span::symbol::sym;\n use rustc_ast::attr;\n \n use crate::*;\n+use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -139,8 +140,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 | \"exit\"\n                 | \"ExitProcess\"\n                 => {\n+                    let &[code] = check_arg_count(args)?;\n                     // it's really u32 for ExitProcess, but we have to put it into the `Exit` variant anyway\n-                    let code = this.read_scalar(args[0])?.to_i32()?;\n+                    let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                 }\n                 _ => throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name),\n@@ -197,25 +199,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Standard C allocation\n             \"malloc\" => {\n-                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n+                let &[size] = check_arg_count(args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n-                let items = this.read_scalar(args[0])?.to_machine_usize(this)?;\n-                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let &[items, len] = check_arg_count(args)?;\n+                let items = this.read_scalar(items)?.to_machine_usize(this)?;\n+                let len = this.read_scalar(len)?.to_machine_usize(this)?;\n                 let size =\n                     items.checked_mul(len).ok_or_else(|| err_ub_format!(\"overflow during calloc size computation\"))?;\n                 let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"free\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let &[ptr] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n                 this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n-                let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let new_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let &[old_ptr, new_size] = check_arg_count(args)?;\n+                let old_ptr = this.read_scalar(old_ptr)?.not_undef()?;\n+                let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n@@ -224,8 +230,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // (Usually these would be forwarded to to `#[global_allocator]`; we instead implement a generic\n             // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n-                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let &[size, align] = check_arg_count(args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n                 let ptr = this.memory.allocate(\n                     Size::from_bytes(size),\n@@ -235,8 +242,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n-                let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n-                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let &[size, align] = check_arg_count(args)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(size, align)?;\n                 let ptr = this.memory.allocate(\n                     Size::from_bytes(size),\n@@ -248,9 +256,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[ptr, old_size, align] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 // No need to check old_size/align; we anyway check that they match the allocation.\n                 let ptr = this.force_ptr(ptr)?;\n                 this.memory.deallocate(\n@@ -260,12 +269,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                let old_size = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let align = this.read_scalar(args[2])?.to_machine_usize(this)?;\n-                let new_size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n+                let &[ptr, old_size, align, new_size] = check_arg_count(args)?;\n+                let ptr = this.force_ptr(this.read_scalar(ptr)?.not_undef()?)?;\n+                let old_size = this.read_scalar(old_size)?.to_machine_usize(this)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+                let new_size = this.read_scalar(new_size)?.to_machine_usize(this)?;\n                 Self::check_alloc_request(new_size, align)?;\n                 // No need to check old_size; we anyway check that they match the allocation.\n-                let ptr = this.force_ptr(this.read_scalar(args[0])?.not_undef()?)?;\n                 let align = Align::from_bytes(align).unwrap();\n                 let new_ptr = this.memory.reallocate(\n                     ptr,\n@@ -279,9 +289,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // C memory handling functions\n             \"memcmp\" => {\n-                let left = this.read_scalar(args[0])?.not_undef()?;\n-                let right = this.read_scalar(args[1])?.not_undef()?;\n-                let n = Size::from_bytes(this.read_scalar(args[2])?.to_machine_usize(this)?);\n+                let &[left, right, n] = check_arg_count(args)?;\n+                let left = this.read_scalar(left)?.not_undef()?;\n+                let right = this.read_scalar(right)?.not_undef()?;\n+                let n = Size::from_bytes(this.read_scalar(n)?.to_machine_usize(this)?);\n \n                 let result = {\n                     let left_bytes = this.memory.read_bytes(left, n)?;\n@@ -298,9 +309,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"memrchr\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[ptr, val, num] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let val = this.read_scalar(val)?.to_i32()? as u8;\n+                let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 if let Some(idx) = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -315,9 +327,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"memchr\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let val = this.read_scalar(args[1])?.to_i32()? as u8;\n-                let num = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[ptr, val, num] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let val = this.read_scalar(val)?.to_i32()? as u8;\n+                let num = this.read_scalar(num)?.to_machine_usize(this)?;\n                 let idx = this\n                     .memory\n                     .read_bytes(ptr, Size::from_bytes(num))?\n@@ -331,7 +344,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n             \"strlen\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let &[ptr] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n                 let n = this.memory.read_c_str(ptr)?.len();\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n             }\n@@ -345,8 +359,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asinf\"\n             | \"atanf\"\n             => {\n+                let &[f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match link_name {\n                     \"cbrtf\" => f.cbrt(),\n                     \"coshf\" => f.cosh(),\n@@ -363,11 +378,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n+                let &[f1, f2] = check_arg_count(args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n-                let f1 = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n-                let f2 = f32::from_bits(this.read_scalar(args[1])?.to_u32()?);\n+                let f1 = f32::from_bits(this.read_scalar(f1)?.to_u32()?);\n+                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n                 let n = match link_name {\n                     \"_hypotf\" | \"hypotf\" => f1.hypot(f2),\n                     \"atan2f\" => f1.atan2(f2),\n@@ -383,8 +399,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"asin\"\n             | \"atan\"\n             => {\n+                let &[f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match link_name {\n                     \"cbrt\" => f.cbrt(),\n                     \"cosh\" => f.cosh(),\n@@ -401,9 +418,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"hypot\"\n             | \"atan2\"\n             => {\n+                let &[f1, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f1 = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n-                let f2 = f64::from_bits(this.read_scalar(args[1])?.to_u64()?);\n+                let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n+                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n                 let n = match link_name {\n                     \"_hypot\" | \"hypot\" => f1.hypot(f2),\n                     \"atan2\" => f1.atan2(f2),\n@@ -415,9 +433,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n+                let &[x, exp] = check_arg_count(args)?;\n                 // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n-                let x = this.read_scalar(args[0])?.to_f64()?;\n-                let exp = this.read_scalar(args[1])?.to_i32()?;\n+                let x = this.read_scalar(x)?.to_f64()?;\n+                let exp = this.read_scalar(exp)?.to_i32()?;\n \n                 // Saturating cast to i16. Even those are outside the valid exponent range to\n                 // `scalbn` below will do its over/underflow handling."}, {"sha": "4c50d5ddc5b8c402728cbde578e37c616d915e77", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 101, "deletions": 59, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -6,6 +6,7 @@ use std::convert::TryFrom;\n use log::trace;\n \n use crate::*;\n+use helpers::check_arg_count;\n use rustc_middle::mir;\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n@@ -23,43 +24,51 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"getenv\" => {\n-                let result = this.getenv(args[0])?;\n+                let &[name] = check_arg_count(args)?;\n+                let result = this.getenv(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"unsetenv\" => {\n-                let result = this.unsetenv(args[0])?;\n+                let &[name] = check_arg_count(args)?;\n+                let result = this.unsetenv(name)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"setenv\" => {\n-                let result = this.setenv(args[0], args[1])?;\n+                let &[name, value, _overwrite] = check_arg_count(args)?;\n+                let result = this.setenv(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"getcwd\" => {\n-                let result = this.getcwd(args[0], args[1])?;\n+                let &[buf, size] = check_arg_count(args)?;\n+                let result = this.getcwd(buf, size)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"chdir\" => {\n-                let result = this.chdir(args[0])?;\n+                let &[path] = check_arg_count(args)?;\n+                let result = this.chdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"open\" | \"open64\" => {\n-                let result = this.open(args[0], args[1])?;\n+                let &[path, flag, _mode] = check_arg_count(args)?;\n+                let result = this.open(path, flag)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fcntl\" => {\n-                let result = this.fcntl(args[0], args[1], args.get(2).cloned())?;\n+                let result = this.fcntl(args);\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"read\" => {\n-                let result = this.read(args[0], args[1], args[2])?;\n+                let &[fd, buf, count] = check_arg_count(args)?;\n+                let result = this.read(fd, buf, count)?;\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"write\" => {\n-                let fd = this.read_scalar(args[0])?.to_i32()?;\n-                let buf = this.read_scalar(args[1])?.not_undef()?;\n-                let n = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[fd, buf, n] = check_arg_count(args)?;\n+                let fd = this.read_scalar(fd)?.to_i32()?;\n+                let buf = this.read_scalar(buf)?.not_undef()?;\n+                let n = this.read_scalar(n)?.to_machine_usize(this)?;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n@@ -84,46 +93,55 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Err(_) => -1,\n                     }\n                 } else {\n-                    this.write(args[0], args[1], args[2])?\n+                    let &[fd, buf, count] = check_arg_count(args)?;\n+                    this.write(fd, buf, count)?\n                 };\n                 // Now, `result` is the value we return back to the program.\n                 this.write_scalar(Scalar::from_machine_isize(result, this), dest)?;\n             }\n             \"unlink\" => {\n-                let result = this.unlink(args[0])?;\n+                let &[path] = check_arg_count(args)?;\n+                let result = this.unlink(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"symlink\" => {\n-                let result = this.symlink(args[0], args[1])?;\n+                let &[target, linkpath] = check_arg_count(args)?;\n+                let result = this.symlink(target, linkpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rename\" => {\n-                let result = this.rename(args[0], args[1])?;\n+                let &[oldpath, newpath] = check_arg_count(args)?;\n+                let result = this.rename(oldpath, newpath)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mkdir\" => {\n-                let result = this.mkdir(args[0], args[1])?;\n+                let &[path, mode] = check_arg_count(args)?;\n+                let result = this.mkdir(path, mode)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"rmdir\" => {\n-                let result = this.rmdir(args[0])?;\n+                let &[path] = check_arg_count(args)?;\n+                let result = this.rmdir(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"closedir\" => {\n-                let result = this.closedir(args[0])?;\n+                let &[dirp] = check_arg_count(args)?;\n+                let result = this.closedir(dirp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lseek\" | \"lseek64\" => {\n-                let result = this.lseek64(args[0], args[1], args[2])?;\n+                let &[fd, offset, whence] = check_arg_count(args)?;\n+                let result = this.lseek64(fd, offset, whence)?;\n                 // \"lseek\" is only used on macOS which is 64bit-only, so `i64` always works.\n                 this.write_scalar(Scalar::from_i64(result), dest)?;\n             }\n \n             // Allocation\n             \"posix_memalign\" => {\n-                let ret = this.deref_operand(args[0])?;\n-                let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[ret, align, size] = check_arg_count(args)?;\n+                let ret = this.deref_operand(ret)?;\n+                let align = this.read_scalar(align)?.to_machine_usize(this)?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 if !align.is_power_of_two() {\n                     throw_ub_format!(\"posix_memalign: alignment must be a power of two, but is {}\", align);\n@@ -150,8 +168,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Dynamic symbol loading\n             \"dlsym\" => {\n-                let _handle = this.read_scalar(args[0])?;\n-                let symbol = this.read_scalar(args[1])?.not_undef()?;\n+                let &[_handle, symbol] = check_arg_count(args)?;\n+                let _handle = this.read_scalar(_handle)?.not_undef()?;\n+                let symbol = this.read_scalar(symbol)?.not_undef()?;\n                 let symbol_name = this.memory.read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n@@ -165,7 +184,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Querying system information\n             \"sysconf\" => {\n-                let name = this.read_scalar(args[0])?.to_i32()?;\n+                let &[name] = check_arg_count(args)?;\n+                let name = this.read_scalar(name)?.to_i32()?;\n \n                 let sysconfs = &[\n                     (\"_SC_PAGESIZE\", Scalar::from_int(PAGE_SIZE, this.pointer_size())),\n@@ -188,17 +208,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Thread-local storage\n             \"pthread_key_create\" => {\n-                let key_place = this.deref_operand(args[0])?;\n+                let &[key, dtor] = check_arg_count(args)?;\n+                let key_place = this.deref_operand(key)?;\n+                let dtor = this.read_scalar(dtor)?.not_undef()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n-                let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n+                let dtor = match this.test_null(dtor)? {\n                     Some(dtor_ptr) => Some(this.memory.get_fn(dtor_ptr)?.as_instance()?),\n                     None => None,\n                 };\n \n                 // Figure out how large a pthread TLS key actually is.\n                 // To this end, deref the argument type. This is `libc::pthread_key_t`.\n-                let key_type = args[0].layout.ty\n+                let key_type = key.layout.ty\n                     .builtin_deref(true)\n                     .ok_or_else(|| err_ub_format!(\n                         \"wrong signature used for `pthread_key_create`: first argument must be a raw pointer.\"\n@@ -214,21 +236,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n             \"pthread_key_delete\" => {\n-                let key = this.force_bits(this.read_scalar(args[0])?.not_undef()?, args[0].layout.size)?;\n+                let &[key] = check_arg_count(args)?;\n+                let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n                 this.machine.tls.delete_tls_key(key)?;\n                 // Return success (0)\n                 this.write_null(dest)?;\n             }\n             \"pthread_getspecific\" => {\n-                let key = this.force_bits(this.read_scalar(args[0])?.not_undef()?, args[0].layout.size)?;\n+                let &[key] = check_arg_count(args)?;\n+                let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread()?;\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n-                let key = this.force_bits(this.read_scalar(args[0])?.not_undef()?, args[0].layout.size)?;\n+                let &[key, new_ptr] = check_arg_count(args)?;\n+                let key = this.force_bits(this.read_scalar(key)?.not_undef()?, key.layout.size)?;\n                 let active_thread = this.get_active_thread()?;\n-                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n+                let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n                 // Return success (`0`).\n@@ -237,101 +262,117 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Synchronization primitives\n             \"pthread_mutexattr_init\" => {\n-                let result = this.pthread_mutexattr_init(args[0])?;\n+                let &[attr] = check_arg_count(args)?;\n+                let result = this.pthread_mutexattr_init(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_settype\" => {\n-                let result = this.pthread_mutexattr_settype(args[0], args[1])?;\n+                let &[attr, kind] = check_arg_count(args)?;\n+                let result = this.pthread_mutexattr_settype(attr, kind)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutexattr_destroy\" => {\n-                let result = this.pthread_mutexattr_destroy(args[0])?;\n+                let &[attr] = check_arg_count(args)?;\n+                let result = this.pthread_mutexattr_destroy(attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_init\" => {\n-                let result = this.pthread_mutex_init(args[0], args[1])?;\n+                let &[mutex, attr] = check_arg_count(args)?;\n+                let result = this.pthread_mutex_init(mutex, attr)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_lock\" => {\n-                let result = this.pthread_mutex_lock(args[0])?;\n+                let &[mutex] = check_arg_count(args)?;\n+                let result = this.pthread_mutex_lock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_trylock\" => {\n-                let result = this.pthread_mutex_trylock(args[0])?;\n+                let &[mutex] = check_arg_count(args)?;\n+                let result = this.pthread_mutex_trylock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_unlock\" => {\n-                let result = this.pthread_mutex_unlock(args[0])?;\n+                let &[mutex] = check_arg_count(args)?;\n+                let result = this.pthread_mutex_unlock(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_mutex_destroy\" => {\n-                let result = this.pthread_mutex_destroy(args[0])?;\n+                let &[mutex] = check_arg_count(args)?;\n+                let result = this.pthread_mutex_destroy(mutex)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_rdlock\" => {\n-                let result = this.pthread_rwlock_rdlock(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_rdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_tryrdlock\" => {\n-                let result = this.pthread_rwlock_tryrdlock(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_tryrdlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_wrlock\" => {\n-                let result = this.pthread_rwlock_wrlock(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_wrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_trywrlock\" => {\n-                let result = this.pthread_rwlock_trywrlock(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_trywrlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_unlock\" => {\n-                let result = this.pthread_rwlock_unlock(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_unlock(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_rwlock_destroy\" => {\n-                let result = this.pthread_rwlock_destroy(args[0])?;\n+                let &[rwlock] = check_arg_count(args)?;\n+                let result = this.pthread_rwlock_destroy(rwlock)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Threading\n             \"pthread_create\" => {\n-                assert_eq!(args.len(), 4);\n-                let result = this.pthread_create(args[0], args[1], args[2], args[3])?;\n+                let &[thread, attr, start, arg] = check_arg_count(args)?;\n+                let result = this.pthread_create(thread, attr, start, arg)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_join\" => {\n-                assert_eq!(args.len(), 2);\n-                let result = this.pthread_join(args[0], args[1])?;\n+                let &[thread, retval] = check_arg_count(args)?;\n+                let result = this.pthread_join(thread, retval)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_detach\" => {\n-                assert_eq!(args.len(), 1);\n-                let result = this.pthread_detach(args[0])?;\n+                let &[thread] = check_arg_count(args)?;\n+                let result = this.pthread_detach(thread)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"pthread_self\" => {\n-                assert_eq!(args.len(), 0);\n+                let &[] = check_arg_count(args)?;\n                 this.pthread_self(dest)?;\n             }\n             \"sched_yield\" => {\n-                assert_eq!(args.len(), 0);\n+                let &[] = check_arg_count(args)?;\n                 let result = this.sched_yield()?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"isatty\" => {\n-                let _fd = this.read_scalar(args[0])?.to_i32()?;\n+                let &[_fd] = check_arg_count(args)?;\n+                let _fd = this.read_scalar(_fd)?.to_i32()?;\n                 // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n                 // FIXME: we just say nothing is a terminal.\n                 let enotty = this.eval_libc(\"ENOTTY\")?;\n                 this.set_last_error(enotty)?;\n                 this.write_null(dest)?;\n             }\n             \"pthread_atfork\" => {\n-                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n-                let _parent = this.read_scalar(args[1])?.not_undef()?;\n-                let _child = this.read_scalar(args[1])?.not_undef()?;\n+                let &[_prepare, _parent, _child] = check_arg_count(args)?;\n+                let _prepare = this.read_scalar(_prepare)?.not_undef()?;\n+                let _parent = this.read_scalar(_parent)?.not_undef()?;\n+                let _child = this.read_scalar(_child)?.not_undef()?;\n                 // We do not support forking, so there is nothing to do here.\n                 this.write_null(dest)?;\n             }\n@@ -351,7 +392,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_attr_getguardsize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n             => {\n-                let guard_size = this.deref_operand(args[1])?;\n+                let &[_attr, guard_size] = check_arg_count(args)?;\n+                let guard_size = this.deref_operand(guard_size)?;\n                 let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n                 this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), guard_size.into())?;\n "}, {"sha": "b0f4a45f1c011ed870b37fc2ed5245fac9fa45b2", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -1,4 +1,5 @@\n use crate::*;\n+use helpers::check_arg_count;\n use rustc_middle::mir;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -15,6 +16,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__errno_location\" => {\n+                let &[] = check_arg_count(args)?;\n                 let errno_place = this.machine.last_error.unwrap();\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n@@ -23,44 +25,51 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These symbols have different names on Linux and macOS, which is the only reason they are not\n             // in the `posix` module.\n             \"close\" => {\n-                let result = this.close(args[0])?;\n+                let &[fd] = check_arg_count(args)?;\n+                let result = this.close(fd)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir\" => {\n-                let result = this.opendir(args[0])?;\n+                let &[name] = check_arg_count(args)?;\n+                let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir64_r\" => {\n-                let result = this.linux_readdir64_r(args[0], args[1], args[2])?;\n+                let &[dirp, entry, result] = check_arg_count(args)?;\n+                let result = this.linux_readdir64_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate64\" => {\n-                let result = this.ftruncate64(args[0], args[1])?;\n+                let &[fd, length] = check_arg_count(args)?;\n+                let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             // Linux-only\n             \"posix_fadvise\" => {\n-                let _fd = this.read_scalar(args[0])?.to_i32()?;\n-                let _offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n-                let _len = this.read_scalar(args[2])?.to_machine_isize(this)?;\n-                let _advice = this.read_scalar(args[3])?.to_i32()?;\n+                let &[_fd, _offset, _len, _advice] = check_arg_count(args)?;\n+                let _fd = this.read_scalar(_fd)?.to_i32()?;\n+                let _offset = this.read_scalar(_offset)?.to_machine_isize(this)?;\n+                let _len = this.read_scalar(_len)?.to_machine_isize(this)?;\n+                let _advice = this.read_scalar(_advice)?.to_i32()?;\n                 // fadvise is only informational, we can ignore it.\n                 this.write_null(dest)?;\n             }\n \n             // Time related shims\n             \"clock_gettime\" => {\n                 // This is a POSIX function but it has only been tested on linux.\n-                let result = this.clock_gettime(args[0], args[1])?;\n+                let &[clk_id, tp] = check_arg_count(args)?;\n+                let result = this.clock_gettime(clk_id, tp)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Querying system information\n             \"pthread_attr_getstack\" => {\n                 // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n-                let _attr_place = this.deref_operand(args[0])?;\n-                let addr_place = this.deref_operand(args[1])?;\n-                let size_place = this.deref_operand(args[2])?;\n+                let &[_attr_place, addr_place, size_place] = check_arg_count(args)?;\n+                let _attr_place = this.deref_operand(_attr_place)?;\n+                let addr_place = this.deref_operand(addr_place)?;\n+                let size_place = this.deref_operand(size_place)?;\n \n                 this.write_scalar(\n                     Scalar::from_uint(STACK_ADDR, this.pointer_size()),\n@@ -77,8 +86,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Threading\n             \"prctl\" => {\n-                assert_eq!(args.len(), 5);\n-                let result = this.prctl(args[0], args[1], args[2], args[3], args[4])?;\n+                let &[option, arg2, arg3, arg4, arg5] = check_arg_count(args)?;\n+                let result = this.prctl(option, arg2, arg3, arg4, arg5)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n@@ -92,6 +101,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .eval_libc(\"SYS_statx\")?\n                     .to_machine_usize(this)?;\n \n+                if args.is_empty() {\n+                    throw_ub_format!(\"incorrect number of arguments, needed at least 1\");\n+                }\n                 match this.read_scalar(args[0])?.to_machine_usize(this)? {\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n@@ -103,7 +115,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // instead of using `stat`,`lstat` or `fstat` as on `macos`.\n                     id if id == sys_statx => {\n                         // The first argument is the syscall id, so skip over it.\n-                        let result = this.linux_statx(args[1], args[2], args[3], args[4], args[5])?;\n+                        let &[_, dirfd, pathname, flags, mask, statxbuf] = check_arg_count(args)?;\n+                        let result = this.linux_statx(dirfd, pathname, flags, mask, statxbuf)?;\n                         this.write_scalar(Scalar::from_machine_isize(result.into(), this), dest)?;\n                     }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n@@ -115,9 +128,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 getrandom(this, args, dest)?;\n             }\n             \"sched_getaffinity\" => {\n-                let _pid = this.read_scalar(args[0])?.to_i32()?;\n-                let _cpusetsize = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let _mask = this.deref_operand(args[2])?;\n+                let &[_pid, _cpusetsize, _mask] = check_arg_count(args)?;\n+                let _pid = this.read_scalar(_pid)?.to_i32()?;\n+                let _cpusetsize = this.read_scalar(_cpusetsize)?.to_machine_usize(this)?;\n+                let _mask = this.deref_operand(_mask)?;\n                 // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n                 let einval = this.eval_libc(\"EINVAL\")?;\n                 this.set_last_error(einval)?;\n@@ -143,12 +157,13 @@ fn getrandom<'tcx>(\n     args: &[OpTy<'tcx, Tag>],\n     dest: PlaceTy<'tcx, Tag>,\n ) -> InterpResult<'tcx> {\n-    let ptr = this.read_scalar(args[0])?.not_undef()?;\n-    let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+    let &[ptr, len, _flags] = check_arg_count(args)?;\n+    let ptr = this.read_scalar(ptr)?.not_undef()?;\n+    let len = this.read_scalar(len)?.to_machine_usize(this)?;\n \n     // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n     // neither of which have any effect on our current PRNG.\n-    let _flags = this.read_scalar(args[2])?.to_i32()?;\n+    let _flags = this.read_scalar(_flags)?.to_i32()?;\n \n     this.gen_random(ptr, len)?;\n     this.write_scalar(Scalar::from_machine_usize(len, this), dest)?;"}, {"sha": "e9fd3aa8ac81e3a38b4d1427063639c9ba0867bf", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -1,4 +1,5 @@\n use crate::*;\n+use helpers::check_arg_count;\n use rustc_middle::mir;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -15,85 +16,102 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // errno\n             \"__error\" => {\n+                let &[] = check_arg_count(args)?;\n                 let errno_place = this.machine.last_error.unwrap();\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n             \"close$NOCANCEL\" => {\n-                let result = this.close(args[0])?;\n+                let &[result] = check_arg_count(args)?;\n+                let result = this.close(result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"stat$INODE64\" => {\n-                let result = this.macos_stat(args[0], args[1])?;\n+                let &[path, buf] = check_arg_count(args)?;\n+                let result = this.macos_stat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"lstat$INODE64\" => {\n-                let result = this.macos_lstat(args[0], args[1])?;\n+                let &[path, buf] = check_arg_count(args)?;\n+                let result = this.macos_lstat(path, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"fstat$INODE64\" => {\n-                let result = this.macos_fstat(args[0], args[1])?;\n+                let &[fd, buf] = check_arg_count(args)?;\n+                let result = this.macos_fstat(fd, buf)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"opendir$INODE64\" => {\n-                let result = this.opendir(args[0])?;\n+                let &[name] = check_arg_count(args)?;\n+                let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"readdir_r$INODE64\" => {\n-                let result = this.macos_readdir_r(args[0], args[1], args[2])?;\n+                let &[dirp, entry, result] = check_arg_count(args)?;\n+                let result = this.macos_readdir_r(dirp, entry, result)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"ftruncate\" => {\n-                let result = this.ftruncate64(args[0], args[1])?;\n+                let &[fd, length] = check_arg_count(args)?;\n+                let result = this.ftruncate64(fd, length)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Environment related shims\n             \"_NSGetEnviron\" => {\n+                let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.env_vars.environ.unwrap().ptr, dest)?;\n             }\n \n             // Time related shims\n             \"gettimeofday\" => {\n-                let result = this.gettimeofday(args[0], args[1])?;\n+                let &[tv, tz] = check_arg_count(args)?;\n+                let result = this.gettimeofday(tv, tz)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"mach_absolute_time\" => {\n+                let &[] = check_arg_count(args)?;\n                 let result = this.mach_absolute_time()?;\n                 this.write_scalar(Scalar::from_u64(result), dest)?;\n             }\n \n             \"mach_timebase_info\" => {\n-                let result = this.mach_timebase_info(args[0])?;\n+                let &[info] = check_arg_count(args)?;\n+                let result = this.mach_timebase_info(info)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             },\n \n             // Access to command-line arguments\n             \"_NSGetArgc\" => {\n+                let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n             \"_NSGetArgv\" => {\n+                let &[] = check_arg_count(args)?;\n                 this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n             // Thread-local storage\n             \"_tlv_atexit\" => {\n-                let dtor = this.read_scalar(args[0])?.not_undef()?;\n+                let &[dtor, data] = check_arg_count(args)?;\n+                let dtor = this.read_scalar(dtor)?.not_undef()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n-                let data = this.read_scalar(args[1])?.not_undef()?;\n+                let data = this.read_scalar(data)?.not_undef()?;\n                 let active_thread = this.get_active_thread()?;\n                 this.machine.tls.set_macos_thread_dtor(active_thread, dtor, data)?;\n             }\n \n             // Querying system information\n             \"pthread_get_stackaddr_np\" => {\n-                let _thread = this.read_scalar(args[0])?.not_undef()?;\n+                let &[_thread] = check_arg_count(args)?;\n+                let _thread = this.read_scalar(_thread)?.not_undef()?;\n                 let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n-                let _thread = this.read_scalar(args[0])?.not_undef()?;\n+                let &[_thread] = check_arg_count(args)?;\n+                let _thread = this.read_scalar(_thread)?.not_undef()?;\n                 let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n@@ -108,7 +126,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // These shims are enabled only when the caller is in the standard library.\n             \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n                 // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n-                let addr = this.read_scalar(args[0])?.not_undef()?;\n+                let &[addr, _, _, _, _, _] = check_arg_count(args)?;\n+                let addr = this.read_scalar(addr)?.not_undef()?;\n                 this.write_scalar(addr, dest)?;\n             }\n "}, {"sha": "9edd20ddcab199010e2ce9b0e071bccad5a40142", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 89, "deletions": 38, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -4,6 +4,7 @@ use rustc_middle::mir;\n use rustc_target::abi::Size;\n \n use crate::*;\n+use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -23,42 +24,50 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n-                let result = this.GetEnvironmentVariableW(args[0], args[1], args[2])?;\n+                let &[name, buf, size] = check_arg_count(args)?;\n+                let result = this.GetEnvironmentVariableW(name, buf, size)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetEnvironmentVariableW\" => {\n-                let result = this.SetEnvironmentVariableW(args[0], args[1])?;\n+                let &[name, value] = check_arg_count(args)?;\n+                let result = this.SetEnvironmentVariableW(name, value)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetEnvironmentStringsW\" => {\n+                let &[] = check_arg_count(args)?;\n                 let result = this.GetEnvironmentStringsW()?;\n                 this.write_scalar(result, dest)?;\n             }\n             \"FreeEnvironmentStringsW\" => {\n-                let result = this.FreeEnvironmentStringsW(args[0])?;\n+                let &[env_block] = check_arg_count(args)?;\n+                let result = this.FreeEnvironmentStringsW(env_block)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"GetCurrentDirectoryW\" => {\n-                let result = this.GetCurrentDirectoryW(args[0], args[1])?;\n+                let &[size, buf] = check_arg_count(args)?;\n+                let result = this.GetCurrentDirectoryW(size, buf)?;\n                 this.write_scalar(Scalar::from_u32(result), dest)?;\n             }\n             \"SetCurrentDirectoryW\" => {\n-                let result = this.SetCurrentDirectoryW(args[0])?;\n+                let &[path] = check_arg_count(args)?;\n+                let result = this.SetCurrentDirectoryW(path)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // File related shims\n             \"GetStdHandle\" => {\n-                let which = this.read_scalar(args[0])?.to_i32()?;\n+                let &[which] = check_arg_count(args)?;\n+                let which = this.read_scalar(which)?.to_i32()?;\n                 // We just make this the identity function, so we know later in `WriteFile`\n                 // which one it is.\n                 this.write_scalar(Scalar::from_machine_isize(which.into(), this), dest)?;\n             }\n             \"WriteFile\" => {\n-                let handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let buf = this.read_scalar(args[1])?.not_undef()?;\n-                let n = this.read_scalar(args[2])?.to_u32()?;\n-                let written_place = this.deref_operand(args[3])?;\n+                let &[handle, buf, n, written_ptr, _overlapped] = check_arg_count(args)?;\n+                let handle = this.read_scalar(handle)?.to_machine_isize(this)?;\n+                let buf = this.read_scalar(buf)?.not_undef()?;\n+                let n = this.read_scalar(n)?.to_u32()?;\n+                let written_place = this.deref_operand(written_ptr)?;\n                 // Spec says to always write `0` first.\n                 this.write_null(written_place.into())?;\n                 let written = if handle == -11 || handle == -12 {\n@@ -88,41 +97,48 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Allocation\n             \"HeapAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let flags = this.read_scalar(args[1])?.to_u32()?;\n-                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let &[_handle, flags, size] = check_arg_count(args)?;\n+                let _handle = this.read_scalar(_handle)?.to_machine_isize(this)?;\n+                let flags = this.read_scalar(flags)?.to_u32()?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _flags = this.read_scalar(args[1])?.to_u32()?;\n-                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                let &[_handle, _flags, ptr] = check_arg_count(args)?;\n+                let _handle = this.read_scalar(_handle)?.to_machine_isize(this)?;\n+                let _flags = this.read_scalar(_flags)?.to_u32()?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n                 this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_i32(1), dest)?;\n             }\n             \"HeapReAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _flags = this.read_scalar(args[1])?.to_u32()?;\n-                let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                let size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n+                let &[_handle, _flags, ptr, size] = check_arg_count(args)?;\n+                let _handle = this.read_scalar(_handle)?.to_machine_isize(this)?;\n+                let _flags = this.read_scalar(_flags)?.to_u32()?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n             // errno\n             \"SetLastError\" => {\n-                this.set_last_error(this.read_scalar(args[0])?.not_undef()?)?;\n+                let &[error] = check_arg_count(args)?;\n+                let error = this.read_scalar(error)?.not_undef()?;\n+                this.set_last_error(error)?;\n             }\n             \"GetLastError\" => {\n+                let &[] = check_arg_count(args)?;\n                 let last_error = this.get_last_error()?;\n                 this.write_scalar(last_error, dest)?;\n             }\n \n             // Querying system information\n             \"GetSystemInfo\" => {\n-                let system_info = this.deref_operand(args[0])?;\n+                let &[system_info] = check_arg_count(args)?;\n+                let system_info = this.deref_operand(system_info)?;\n                 // Initialize with `0`.\n                 this.memory.write_bytes(\n                     system_info.ptr,\n@@ -139,19 +155,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n+                let &[] = check_arg_count(args)?;\n                 let key = this.machine.tls.create_tls_key(None, dest.layout.size)?;\n                 this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n             }\n             \"TlsGetValue\" => {\n-                let key = u128::from(this.read_scalar(args[0])?.to_u32()?);\n+                let &[key] = check_arg_count(args)?;\n+                let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread()?;\n                 let ptr = this.machine.tls.load_tls(key, active_thread, this)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n-                let key = u128::from(this.read_scalar(args[0])?.to_u32()?);\n+                let &[key, new_ptr] = check_arg_count(args)?;\n+                let key = u128::from(this.read_scalar(key)?.to_u32()?);\n                 let active_thread = this.get_active_thread()?;\n-                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n+                let new_ptr = this.read_scalar(new_ptr)?.not_undef()?;\n                 this.machine.tls.store_tls(key, active_thread, this.test_null(new_ptr)?)?;\n \n                 // Return success (`1`).\n@@ -160,6 +179,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Access to command-line arguments\n             \"GetCommandLineW\" => {\n+                let &[] = check_arg_count(args)?;\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n                     dest,\n@@ -168,42 +188,52 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Time related shims\n             \"GetSystemTimeAsFileTime\" => {\n-                this.GetSystemTimeAsFileTime(args[0])?;\n+                #[allow(non_snake_case)]\n+                let &[LPFILETIME] = check_arg_count(args)?;\n+                this.GetSystemTimeAsFileTime(LPFILETIME)?;\n             }\n             \"QueryPerformanceCounter\" => {\n-                let result = this.QueryPerformanceCounter(args[0])?;\n+                #[allow(non_snake_case)]\n+                let &[lpPerformanceCount] = check_arg_count(args)?;\n+                let result = this.QueryPerformanceCounter(lpPerformanceCount)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n             \"QueryPerformanceFrequency\" => {\n-                let result = this.QueryPerformanceFrequency(args[0])?;\n+                #[allow(non_snake_case)]\n+                let &[lpFrequency] = check_arg_count(args)?;\n+                let result = this.QueryPerformanceFrequency(lpFrequency)?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n             // Miscellaneous\n             \"SystemFunction036\" => {\n                 // The actual name of 'RtlGenRandom'\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let len = this.read_scalar(args[1])?.to_u32()?;\n+                let &[ptr, len] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let len = this.read_scalar(len)?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n             \"GetConsoleScreenBufferInfo\" => {\n                 // `term` needs this, so we fake it.\n-                let _console = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _buffer_info = this.deref_operand(args[1])?;\n+                let &[_console, _buffer_info] = check_arg_count(args)?;\n+                let _console = this.read_scalar(_console)?.to_machine_isize(this)?;\n+                let _buffer_info = this.deref_operand(_buffer_info)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n             \"GetConsoleMode\" => {\n                 // Windows \"isatty\" (in libtest) needs this, so we fake it.\n-                let _console = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _mode = this.deref_operand(args[1])?;\n+                let &[_console, _mode] = check_arg_count(args)?;\n+                let _console = this.read_scalar(_console)?.to_machine_isize(this)?;\n+                let _mode = this.deref_operand(_mode)?;\n                 // Indicate an error.\n                 // FIXME: we should set last_error, but to what?\n                 this.write_null(dest)?;\n             }\n             \"SwitchToThread\" => {\n+                let &[] = check_arg_count(args)?;\n                 // Note that once Miri supports concurrency, this will need to return a nonzero\n                 // value if this call does result in switching to another thread.\n                 this.write_null(dest)?;\n@@ -217,17 +247,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Incomplete shims that we \"stub out\" just to get pre-main initialization code to work.\n             // These shims are enabled only when the caller is in the standard library.\n             \"GetProcessHeap\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                let &[] = check_arg_count(args)?;\n                 // Just fake a HANDLE\n                 this.write_scalar(Scalar::from_machine_isize(1, this), dest)?;\n             }\n-            | \"GetModuleHandleW\"\n-            | \"GetProcAddress\"\n-            | \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            \"GetModuleHandleW\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n             => {\n-                // Pretend these do not exist / nothing happened, by returning zero.\n+                #[allow(non_snake_case)]\n+                let &[_lpModuleName] = check_arg_count(args)?;\n+                // Pretend this does not exist / nothing happened, by returning zero.\n+                this.write_null(dest)?;\n+            }\n+            \"GetProcAddress\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            => {\n+                #[allow(non_snake_case)]\n+                let &[_hModule, _lpProcName] = check_arg_count(args)?;\n+                // Pretend this does not exist / nothing happened, by returning zero.\n+                this.write_null(dest)?;\n+            }\n+            \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            => {\n+                #[allow(non_snake_case)]\n+                let &[_hConsoleOutput, _wAttribute] = check_arg_count(args)?;\n+                // Pretend these does not exist / nothing happened, by returning zero.\n                 this.write_null(dest)?;\n             }\n             \"AddVectoredExceptionHandler\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                #[allow(non_snake_case)]\n+                let &[_First, _Handler] = check_arg_count(args)?;\n                 // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n                 this.write_scalar(Scalar::from_machine_usize(1, this), dest)?;\n             }\n@@ -236,13 +283,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"LeaveCriticalSection\"\n             | \"DeleteCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n             => {\n+                #[allow(non_snake_case)]\n+                let &[_lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n                 // Nothing to do, not even a return value.\n                 // (Windows locks are reentrant, and we have only 1 thread,\n                 // so not doing any futher checks here is at least not incorrect.)\n             }\n             \"TryEnterCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n             => {\n+                #[allow(non_snake_case)]\n+                let &[_lpCriticalSection] = check_arg_count(args)?;\n                 assert_eq!(this.get_total_thread_count()?, 1, \"concurrency on Windows not supported\");\n                 // There is only one thread, so this always succeeds and returns TRUE\n                 this.write_scalar(Scalar::from_i32(1), dest)?;"}, {"sha": "b9bb0fadf1a4bf30a5d4fb752cf8f348d1aa236e", "filename": "src/shims/fs.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -10,7 +10,7 @@ use rustc_target::abi::{Align, LayoutOf, Size};\n \n use crate::stacked_borrows::Tag;\n use crate::*;\n-use helpers::{immty_from_int_checked, immty_from_uint_checked};\n+use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n@@ -322,16 +322,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn fcntl(\n         &mut self,\n-        fd_op: OpTy<'tcx, Tag>,\n-        cmd_op: OpTy<'tcx, Tag>,\n-        start_op: Option<OpTy<'tcx, Tag>>,\n+        args: &[OpTy<'tcx, Tag>],\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"fcntl\")?;\n \n-        let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let cmd = this.read_scalar(cmd_op)?.to_i32()?;\n+        let (fd, cmd, start) = if args.len() == 2 {\n+            let &[fd, cmd] = check_arg_count(args)?;\n+            (fd, cmd, None)\n+        } else {\n+            // If args.len() isn't 2 or 3 this will error appropriately.\n+            let &[fd, cmd, start] = check_arg_count(args)?;\n+            (fd, cmd, Some(start))\n+        };\n+        let fd = this.read_scalar(fd)?.to_i32()?;\n+        let cmd = this.read_scalar(cmd)?.to_i32()?;\n         // We only support getting the flags for a descriptor.\n         if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n@@ -353,12 +359,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             if fd < MIN_NORMAL_FILE_FD {\n                 throw_unsup_format!(\"duplicating file descriptors for stdin, stdout, or stderr is not supported\")\n             }\n-            let start_op = start_op.ok_or_else(|| {\n+            let start = start.ok_or_else(|| {\n                 err_unsup_format!(\n                     \"fcntl with command F_DUPFD or F_DUPFD_CLOEXEC requires a third argument\"\n                 )\n             })?;\n-            let start = this.read_scalar(start_op)?.to_i32()?;\n+            let start = this.read_scalar(start)?.to_i32()?;\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n                 Some(FileHandle { file, writable }) => (file.try_clone(), *writable),\n@@ -1064,7 +1070,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     fn ftruncate64(\n-        &mut self, fd_op: OpTy<'tcx, Tag>,\n+        &mut self,\n+        fd_op: OpTy<'tcx, Tag>,\n         length_op: OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();"}, {"sha": "a77443ef52247cf185a5faf67f7933fe55f8a388", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 88, "deletions": 55, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -7,6 +7,7 @@ use rustc_apfloat::{Float, Round};\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n use crate::*;\n+use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -45,16 +46,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"copy\"\n             | \"copy_nonoverlapping\"\n             => {\n+                let &[src, dest, count] = check_arg_count(args)?;\n                 let elem_ty = substs.type_at(0);\n                 let elem_layout = this.layout_of(elem_ty)?;\n-                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let elem_align = elem_layout.align.abi;\n \n                 let size = elem_layout.size.checked_mul(count, this)\n                     .ok_or_else(|| err_ub_format!(\"overflow computing total size of `{}`\", intrinsic_name))?;\n-                let src = this.read_scalar(args[0])?.not_undef()?;\n+                let src = this.read_scalar(src)?.not_undef()?;\n                 let src = this.memory.check_ptr_access(src, size, elem_align)?;\n-                let dest = this.read_scalar(args[1])?.not_undef()?;\n+                let dest = this.read_scalar(dest)?.not_undef()?;\n                 let dest = this.memory.check_ptr_access(dest, size, elem_align)?;\n \n                 if let (Some(src), Some(dest)) = (src, dest) {\n@@ -68,25 +70,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"move_val_init\" => {\n-                let place = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], place.into())?;\n+                let &[place, dest] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(dest, place.into())?;\n             }\n \n             \"volatile_load\" => {\n-                let place = this.deref_operand(args[0])?;\n+                let &[place] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n                 this.copy_op(place.into(), dest)?;\n             }\n             \"volatile_store\" => {\n-                let place = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], place.into())?;\n+                let &[place, dest] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                this.copy_op(dest, place.into())?;\n             }\n \n             \"write_bytes\" => {\n+                let &[ptr, val_byte, count] = check_arg_count(args)?;\n                 let ty = substs.type_at(0);\n                 let ty_layout = this.layout_of(ty)?;\n-                let val_byte = this.read_scalar(args[1])?.to_u8()?;\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let count = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let val_byte = this.read_scalar(val_byte)?.to_u8()?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let count = this.read_scalar(count)?.to_machine_usize(this)?;\n                 let byte_count = ty_layout.size.checked_mul(count, this)\n                     .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n                 this.memory\n@@ -95,8 +101,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Pointer arithmetic\n             \"arith_offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let &[ptr, offset] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let offset = this.read_scalar(offset)?.to_machine_isize(this)?;\n \n                 let pointee_ty = substs.type_at(0);\n                 let pointee_size = i64::try_from(this.layout_of(pointee_ty)?.size.bytes()).unwrap();\n@@ -105,8 +112,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(result_ptr, dest)?;\n             }\n             \"offset\" => {\n-                let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let &[ptr, offset] = check_arg_count(args)?;\n+                let ptr = this.read_scalar(ptr)?.not_undef()?;\n+                let offset = this.read_scalar(offset)?.to_machine_isize(this)?;\n                 let result_ptr = this.pointer_offset_inbounds(ptr, substs.type_at(0), offset)?;\n                 this.write_scalar(result_ptr, dest)?;\n             }\n@@ -127,8 +135,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf32\"\n             | \"roundf32\"\n             => {\n+                let &[f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f = match intrinsic_name {\n                     \"sinf32\" => f.sin(),\n                     \"fabsf32\" => f.abs(),\n@@ -163,8 +172,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"truncf64\"\n             | \"roundf64\"\n             => {\n+                let &[f] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f = match intrinsic_name {\n                     \"sinf64\" => f.sin(),\n                     \"fabsf64\" => f.abs(),\n@@ -191,8 +201,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"fdiv_fast\"\n             | \"frem_fast\"\n             => {\n-                let a = this.read_immediate(args[0])?;\n-                let b = this.read_immediate(args[1])?;\n+                let &[a, b] = check_arg_count(args)?;\n+                let a = this.read_immediate(a)?;\n+                let b = this.read_immediate(b)?;\n                 let op = match intrinsic_name {\n                     \"fadd_fast\" => mir::BinOp::Add,\n                     \"fsub_fast\" => mir::BinOp::Sub,\n@@ -209,8 +220,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"maxnumf32\"\n             | \"copysignf32\"\n             => {\n-                let a = this.read_scalar(args[0])?.to_f32()?;\n-                let b = this.read_scalar(args[1])?.to_f32()?;\n+                let &[a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f32()?;\n+                let b = this.read_scalar(b)?.to_f32()?;\n                 let res = match intrinsic_name {\n                     \"minnumf32\" => a.min(b),\n                     \"maxnumf32\" => a.max(b),\n@@ -225,8 +237,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"maxnumf64\"\n             | \"copysignf64\"\n             => {\n-                let a = this.read_scalar(args[0])?.to_f64()?;\n-                let b = this.read_scalar(args[1])?.to_f64()?;\n+                let &[a, b] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f64()?;\n+                let b = this.read_scalar(b)?.to_f64()?;\n                 let res = match intrinsic_name {\n                     \"minnumf64\" => a.min(b),\n                     \"maxnumf64\" => a.max(b),\n@@ -235,53 +248,60 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 this.write_scalar(Scalar::from_f64(res), dest)?;\n             }\n-            \n+\n             \"powf32\" => {\n+                let &[f, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n-                let f2 = f32::from_bits(this.read_scalar(args[1])?.to_u32()?);\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n                 this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"powf64\" => {\n+                let &[f, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n-                let f2 = f64::from_bits(this.read_scalar(args[1])?.to_u64()?);\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n                 this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n             }\n \n             \"fmaf32\" => {\n-                let a = this.read_scalar(args[0])?.to_f32()?;\n-                let b = this.read_scalar(args[1])?.to_f32()?;\n-                let c = this.read_scalar(args[2])?.to_f32()?;\n+                let &[a, b, c] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f32()?;\n+                let b = this.read_scalar(b)?.to_f32()?;\n+                let c = this.read_scalar(c)?.to_f32()?;\n                 let res = a.mul_add(b, c).value;\n                 this.write_scalar(Scalar::from_f32(res), dest)?;\n             }\n \n             \"fmaf64\" => {\n-                let a = this.read_scalar(args[0])?.to_f64()?;\n-                let b = this.read_scalar(args[1])?.to_f64()?;\n-                let c = this.read_scalar(args[2])?.to_f64()?;\n+                let &[a, b, c] = check_arg_count(args)?;\n+                let a = this.read_scalar(a)?.to_f64()?;\n+                let b = this.read_scalar(b)?.to_f64()?;\n+                let c = this.read_scalar(c)?.to_f64()?;\n                 let res = a.mul_add(b, c).value;\n                 this.write_scalar(Scalar::from_f64(res), dest)?;\n             }\n \n             \"powif32\" => {\n+                let &[f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n-                let i = this.read_scalar(args[1])?.to_i32()?;\n+                let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"powif64\" => {\n+                let &[f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n-                let f = f64::from_bits(this.read_scalar(args[0])?.to_u64()?);\n-                let i = this.read_scalar(args[1])?.to_i32()?;\n+                let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n+                let i = this.read_scalar(i)?.to_i32()?;\n                 this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n             }\n \n             \"float_to_int_unchecked\" => {\n-                let val = this.read_immediate(args[0])?;\n+                let &[val] = check_arg_count(args)?;\n+                let val = this.read_immediate(val)?;\n \n                 let res = match val.layout.ty.kind {\n                     ty::Float(FloatTy::F32) => {\n@@ -302,7 +322,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atomic_load_relaxed\"\n             | \"atomic_load_acq\"\n             => {\n-                let place = this.deref_operand(args[0])?;\n+                let &[place] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n                 let val = this.read_scalar(place.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n@@ -319,8 +340,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atomic_store_relaxed\"\n             | \"atomic_store_rel\"\n             => {\n-                let place = this.deref_operand(args[0])?;\n-                let val = this.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n+                let &[place, val] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                let val = this.read_scalar(val)?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n@@ -345,8 +367,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let place = this.deref_operand(args[0])?;\n-                let new = this.read_scalar(args[1])?;\n+                let &[place, new] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                let new = this.read_scalar(new)?;\n                 let old = this.read_scalar(place.into())?;\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n@@ -360,9 +383,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let place = this.deref_operand(args[0])?;\n-                let expect_old = this.read_immediate(args[1])?; // read as immediate for the sake of `binary_op()`\n-                let new = this.read_scalar(args[2])?;\n+                let &[place, expect_old, new] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n+                let expect_old = this.read_immediate(expect_old)?; // read as immediate for the sake of `binary_op()`\n+                let new = this.read_scalar(new)?;\n                 let old = this.read_immediate(place.into())?; // read as immediate for the sake of `binary_op()`\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n@@ -414,11 +438,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"atomic_xsub_acqrel\"\n             | \"atomic_xsub_relaxed\"\n             => {\n-                let place = this.deref_operand(args[0])?;\n+                let &[place, rhs] = check_arg_count(args)?;\n+                let place = this.deref_operand(place)?;\n                 if !place.layout.ty.is_integral() {\n                     bug!(\"Atomic arithmetic operations only work on integer types\");\n                 }\n-                let rhs = this.read_immediate(args[1])?;\n+                let rhs = this.read_immediate(rhs)?;\n                 let old = this.read_immediate(place.into())?;\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n@@ -447,6 +472,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"assert_inhabited\" |\n             \"assert_zero_valid\" |\n             \"assert_uninit_valid\" => {\n+                let &[] = check_arg_count(args)?;\n                 let ty = substs.type_at(0);\n                 let layout = this.layout_of(ty)?;\n                 // Abort here because the caller might not be panic safe.\n@@ -462,15 +488,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"min_align_of_val\" => {\n-                let mplace = this.deref_operand(args[0])?;\n+                let &[mplace] = check_arg_count(args)?;\n+                let mplace = this.deref_operand(mplace)?;\n                 let (_, align) = this\n                     .size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n                 this.write_scalar(Scalar::from_machine_usize(align.bytes(), this), dest)?;\n             }\n \n             \"size_of_val\" => {\n-                let mplace = this.deref_operand(args[0])?;\n+                let &[mplace] = check_arg_count(args)?;\n+                let mplace = this.deref_operand(mplace)?;\n                 let (size, _) = this\n                     .size_and_align_of_mplace(mplace)?\n                     .expect(\"size_of_val called on extern type\");\n@@ -479,25 +507,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             // Other\n             \"assume\" => {\n-                let cond = this.read_scalar(args[0])?.to_bool()?;\n+                let &[cond] = check_arg_count(args)?;\n+                let cond = this.read_scalar(cond)?.not_undef()?.to_bool()?;\n                 if !cond {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n             }\n \n-            \"exact_div\" =>\n-                this.exact_div(this.read_immediate(args[0])?, this.read_immediate(args[1])?, dest)?,\n+            \"exact_div\" => {\n+                let &[num, denom] = check_arg_count(args)?;\n+                this.exact_div(this.read_immediate(num)?, this.read_immediate(denom)?, dest)?;\n+            }\n \n             \"forget\" => {\n                 // We get an argument... and forget about it.\n+                let &[_] = check_arg_count(args)?;\n             }\n \n             #[rustfmt::skip]\n             | \"likely\"\n             | \"unlikely\"\n             => {\n                 // These just return their argument\n-                let b = this.read_immediate(args[0])?;\n+                let &[b] = check_arg_count(args)?;\n+                let b = this.read_immediate(b)?;\n                 this.write_immediate(*b, dest)?;\n             }\n "}, {"sha": "cd525e173ed70cecbf5426c17474f5cc13af78e8", "filename": "src/shims/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -17,6 +17,7 @@ use log::trace;\n use rustc_middle::{mir, ty};\n \n use crate::*;\n+use helpers::check_arg_count;\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -32,7 +33,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n-            this.align_offset(args[0], args[1], ret, unwind)?;\n+            let &[ptr, align] = check_arg_count(args)?;\n+            this.align_offset(ptr, align, ret, unwind)?;\n             return Ok(None);\n         }\n "}, {"sha": "43f90f1b04f73d33cd1b46d13c8427713d0daa29", "filename": "src/shims/panic.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f329513af3e5f34cfd4d9a09fe3a9a4427194f/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=78f329513af3e5f34cfd4d9a09fe3a9a4427194f", "patch": "@@ -17,6 +17,7 @@ use rustc_middle::{mir, ty};\n use rustc_target::spec::PanicStrategy;\n \n use crate::*;\n+use helpers::check_arg_count;\n \n /// Holds all of the relevant data for when unwinding hits a `try` frame.\n #[derive(Debug)]\n@@ -53,7 +54,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         trace!(\"miri_start_panic: {:?}\", this.frame().instance);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n-        let payload = this.read_scalar(args[0])?.not_undef()?;\n+        let &[payload] = check_arg_count(args)?;\n+        let payload = this.read_scalar(payload)?.not_undef()?;\n         assert!(\n             this.machine.panic_payload.is_none(),\n             \"the panic runtime should avoid double-panics\"\n@@ -86,9 +88,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // a pointer to `Box<dyn Any + Send + 'static>`.\n \n         // Get all the arguments.\n-        let try_fn = this.read_scalar(args[0])?.not_undef()?;\n-        let data = this.read_scalar(args[1])?.not_undef()?;\n-        let catch_fn = this.read_scalar(args[2])?.not_undef()?;\n+        let &[try_fn, data, catch_fn] = check_arg_count(args)?;\n+        let try_fn = this.read_scalar(try_fn)?.not_undef()?;\n+        let data = this.read_scalar(data)?.not_undef()?;\n+        let catch_fn = this.read_scalar(catch_fn)?.not_undef()?;\n \n         // Now we make a function call, and pass `data` as first and only argument.\n         let f_instance = this.memory.get_fn(try_fn)?.as_instance()?;"}]}