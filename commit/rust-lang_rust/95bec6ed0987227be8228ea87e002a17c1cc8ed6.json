{"sha": "95bec6ed0987227be8228ea87e002a17c1cc8ed6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YmVjNmVkMDk4NzIyN2JlODIyOGVhODdlMDAyYTE3YzFjYzhlZDY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-11-25T14:14:54Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-16T23:59:32Z"}, "message": "trigger unsized coercions keyed on Sized bounds\n\nThis PR causes unsized coercions to not be disabled by `$0: Unsize<dyn\nObject>` coercion obligations when we have an `$0: Sized` obligation\nsomewhere.\n\nNote that `X: Unsize<dyn Object>` obligations can't fail *as\nobligations* if `X: Sized` holds, so this still maintains some version\nof monotonicity (I think that an unsized coercion can't be converted to\nno coercion by unifying type variables).\n\nFixes #49593 (unblocking never_type).", "tree": {"sha": "56df163cb1f4eae922f76960e855003e1eed46fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56df163cb1f4eae922f76960e855003e1eed46fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95bec6ed0987227be8228ea87e002a17c1cc8ed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95bec6ed0987227be8228ea87e002a17c1cc8ed6", "html_url": "https://github.com/rust-lang/rust/commit/95bec6ed0987227be8228ea87e002a17c1cc8ed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95bec6ed0987227be8228ea87e002a17c1cc8ed6/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "html_url": "https://github.com/rust-lang/rust/commit/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0"}], "stats": {"total": 252, "additions": 197, "deletions": 55}, "files": [{"sha": "92e0a0a763d2306332f9eec641c7d16c43f71794", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -1253,6 +1253,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.inlined_shallow_resolve(typ)\n     }\n \n+    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n+        self.type_variables.borrow_mut().root_var(var)\n+    }\n+\n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "8971e1aa058ff71d5760422943831e689734d578", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 12, "deletions": 52, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -20,7 +20,7 @@ use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::Obligation;\n use rustc::traits::error_reporting::ArgKind;\n-use rustc::ty::{self, ToPolyTraitRef, Ty, GenericParamDefKind};\n+use rustc::ty::{self, Ty, GenericParamDefKind};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use std::cmp;\n@@ -222,6 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n+        let expected_vid = self.root_var(expected_vid);\n         let expected_sig = fulfillment_cx\n             .pending_obligations()\n             .iter()\n@@ -235,13 +236,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     let trait_ref = proj_predicate.to_poly_trait_ref(self.tcx);\n-                    self.self_type_matches_expected_vid(trait_ref, expected_vid)\n-                        .and_then(|_| {\n-                            self.deduce_sig_from_projection(\n-                                Some(obligation.cause.span),\n-                                proj_predicate\n-                            )\n-                        })\n+                    Some(()).filter(|()| {\n+                        self.self_type_matches_expected_vid(trait_ref, expected_vid)\n+                    }).and_then(|()| {\n+                        self.deduce_sig_from_projection(\n+                            Some(obligation.cause.span),\n+                            proj_predicate\n+                        )\n+                    })\n                 } else {\n                     None\n                 }\n@@ -252,34 +254,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind = fulfillment_cx\n-            .pending_obligations()\n-            .iter()\n-            .filter_map(|obligation| {\n-                let opt_trait_ref = match obligation.predicate {\n-                    ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n-                    ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n-                    ty::Predicate::Subtype(..) => None,\n-                    ty::Predicate::RegionOutlives(..) => None,\n-                    ty::Predicate::TypeOutlives(..) => None,\n-                    ty::Predicate::WellFormed(..) => None,\n-                    ty::Predicate::ObjectSafe(..) => None,\n-                    ty::Predicate::ConstEvaluatable(..) => None,\n-\n-                    // N.B., this predicate is created by breaking down a\n-                    // `ClosureType: FnFoo()` predicate, where\n-                    // `ClosureType` represents some `Closure`. It can't\n-                    // possibly be referring to the current closure,\n-                    // because we haven't produced the `Closure` for\n-                    // this closure yet; this is exactly why the other\n-                    // code is looking for a self type of a unresolved\n-                    // inference variable.\n-                    ty::Predicate::ClosureKind(..) => None,\n-                };\n-                opt_trait_ref\n-                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n-                    .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n-            })\n+        let expected_kind = self.obligations_for_self_ty(expected_vid)\n+            .filter_map(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             .fold(None, |best, cur| {\n                 Some(best.map_or(cur, |best| cmp::min(best, cur)))\n             });\n@@ -339,22 +315,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Some(ExpectedSig { cause_span, sig })\n     }\n \n-    fn self_type_matches_expected_vid(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-        expected_vid: ty::TyVid,\n-    ) -> Option<ty::PolyTraitRef<'tcx>> {\n-        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n-        debug!(\n-            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-            trait_ref, self_ty\n-        );\n-        match self_ty.sty {\n-            ty::Infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n-            _ => None,\n-        }\n-    }\n-\n     fn sig_of_closure(\n         &self,\n         expr_def_id: DefId,"}, {"sha": "6832a6d2b5687bc2e1804c494487471b8d7a0927", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -579,7 +579,33 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             };\n             match selcx.select(&obligation.with(trait_ref)) {\n                 // Uncertain or unimplemented.\n-                Ok(None) |\n+                Ok(None) => {\n+                    if trait_ref.def_id() == unsize_did {\n+                        let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                        let self_ty = trait_ref.skip_binder().self_ty();\n+                        let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n+                        debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);\n+                        match (&self_ty.sty, &unsize_ty.sty) {\n+                            (ty::Infer(ty::TyVar(v)),\n+                             ty::Dynamic(..)) if self.type_var_is_sized(*v) => {\n+                                debug!(\"coerce_unsized: have sized infer {:?}\", v);\n+                                coercion.obligations.push(obligation);\n+                                // `$0: Unsize<dyn Trait>` where we know that `$0: Sized`, try going\n+                                // for unsizing.\n+                            }\n+                            _ => {\n+                                // Some other case for `$0: Unsize<Something>`. Note that we\n+                                // hit this case even if `Something` is a sized type, so just\n+                                // don't do the coercion.\n+                                debug!(\"coerce_unsized: ambiguous unsize\");\n+                                return Err(TypeError::Mismatch);\n+                            }\n+                        }\n+                    } else {\n+                        debug!(\"coerce_unsized: early return - ambiguous\");\n+                        return Err(TypeError::Mismatch);\n+                    }\n+                }\n                 Err(traits::Unimplemented) => {\n                     debug!(\"coerce_unsized: early return - can't prove obligation\");\n                     return Err(TypeError::Mismatch);"}, {"sha": "e3770cee72ff762cae3486ebac2b8e652a80bc04", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -113,8 +113,8 @@ use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n                        UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate,\n-                RegionKind};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n+                ToPolyTraitRef, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n@@ -134,6 +134,7 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n use std::iter;\n+use std::vec;\n use std::mem::replace;\n use std::ops::{self, Deref};\n use std::slice;\n@@ -2731,6 +2732,97 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         method.sig.output()\n     }\n \n+    fn self_type_matches_expected_vid(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid,\n+    ) -> bool {\n+        let self_ty = self.shallow_resolve(trait_ref.self_ty());\n+        debug!(\n+            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?}, expected_vid={:?})\",\n+            trait_ref, self_ty, expected_vid\n+        );\n+        match self_ty.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                let root_vid = self.root_var(v);\n+                debug!(\"self_type_matches_expected_vid - root_vid={:?}\", root_vid);\n+                if root_vid == expected_vid {\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false\n+        }\n+    }\n+}\n+\n+/// FIXME: impl Trait why u give me lifetime errors?\n+pub struct ObligationMapper<'a, 'gcx, 'tcx>(&'a FnCtxt<'a, 'gcx, 'tcx>, ty::TyVid);\n+\n+impl<'a, 'gcx, 'tcx> FnOnce<(traits::PredicateObligation<'tcx>,)>\n+    for ObligationMapper<'a, 'gcx, 'tcx>\n+{\n+    type Output = Option<ty::PolyTraitRef<'tcx>>;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (traits::PredicateObligation<'tcx>,))\n+                                    -> Self::Output {\n+        self.call_mut(args)\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FnMut<(traits::PredicateObligation<'tcx>,)>\n+    for ObligationMapper<'a, 'gcx, 'tcx>\n+{\n+    extern \"rust-call\" fn call_mut(&mut self, args: (traits::PredicateObligation<'tcx>,))\n+                                   -> Self::Output {\n+        match args.0.predicate {\n+            ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.0.tcx)),\n+            ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+            ty::Predicate::Subtype(..) => None,\n+            ty::Predicate::RegionOutlives(..) => None,\n+            ty::Predicate::TypeOutlives(..) => None,\n+            ty::Predicate::WellFormed(..) => None,\n+            ty::Predicate::ObjectSafe(..) => None,\n+            ty::Predicate::ConstEvaluatable(..) => None,\n+            // N.B., this predicate is created by breaking down a\n+            // `ClosureType: FnFoo()` predicate, where\n+            // `ClosureType` represents some `Closure`. It can't\n+            // possibly be referring to the current closure,\n+            // because we haven't produced the `Closure` for\n+            // this closure yet; this is exactly why the other\n+            // code is looking for a self type of a unresolved\n+            // inference variable.\n+            ty::Predicate::ClosureKind(..) => None,\n+        }.filter(|tr| {\n+            self.0.self_type_matches_expected_vid(*tr, self.1)\n+        })\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    fn obligations_for_self_ty<'b>(&'b self, self_ty: ty::TyVid)\n+        -> iter::FilterMap<vec::IntoIter<traits::PredicateObligation<'tcx>>,\n+                           ObligationMapper<'b, 'gcx, 'tcx>>\n+    {\n+        let ty_var_root = self.root_var(self_ty);\n+        debug!(\"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n+               self_ty, ty_var_root,\n+               self.fulfillment_cx.borrow().pending_obligations());\n+\n+        self.fulfillment_cx\n+            .borrow()\n+            .pending_obligations()\n+            .into_iter()\n+            .filter_map(ObligationMapper(self, ty_var_root))\n+    }\n+\n+    fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n+        self.obligations_for_self_ty(self_ty).any(|tr| {\n+                Some(tr.def_id()) == self.tcx.lang_items().sized_trait()\n+        })\n+    }\n+\n     /// Generic function that factors out common logic from function calls,\n     /// method calls and overloaded operators.\n     fn check_argument_types(&self,"}, {"sha": "5ecf24c4a1036115e8c7cdfd315914d5edb91246", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -75,13 +75,15 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(exhaustive_patterns)]\n+#![feature(fn_traits)]\n #![feature(nll)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(never_type)]\n+#![feature(unboxed_closures)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "7cdc6c8c4a4c8ffd47e3891e35ad9284457ca19f", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95bec6ed0987227be8228ea87e002a17c1cc8ed6/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=95bec6ed0987227be8228ea87e002a17c1cc8ed6", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(never_type)]\n+#![allow(unreachable_code)]\n+\n+use std::error::Error;\n+use std::char::ParseCharError; /* some Error */\n+\n+fn raw_ptr_box<T>(t: T) -> *mut T {\n+    panic!()\n+}\n+\n+fn foo(x: !) -> Box<Error> {\n+    /* *mut $0 is coerced to *mut Error here */ Box::<_ /* ! */>::new(x)\n+}\n+\n+fn foo_raw_ptr(x: !) -> *mut Error {\n+    /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n+}\n+\n+fn no_coercion(d: *mut Error) -> *mut Error {\n+    /* an unsize coercion won't compile here, and it is indeed not used\n+       because there is nothing requiring the _ to be Sized */\n+    d as *mut _\n+}\n+\n+trait Xyz {}\n+struct S;\n+struct T;\n+impl Xyz for S {}\n+impl Xyz for T {}\n+\n+fn foo_no_never() {\n+    let mut x /* : Box<S> */ = None;\n+    let mut first_iter = false;\n+    loop {\n+        if !first_iter {\n+            let y: Box<Xyz>\n+                = /* Box<$0> is coerced to Box<Xyz> here */ Box::new(x.unwrap());\n+        }\n+\n+        x = Some(S);\n+        first_iter = true;\n+    }\n+}\n+\n+fn main() {\n+}"}]}