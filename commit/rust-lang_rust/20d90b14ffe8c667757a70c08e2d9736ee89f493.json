{"sha": "20d90b14ffe8c667757a70c08e2d9736ee89f493", "node_id": "C_kwDOAAsO6NoAKDIwZDkwYjE0ZmZlOGM2Njc3NTdhNzBjMDhlMmQ5NzM2ZWU4OWY0OTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-25T11:34:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-25T11:34:58Z"}, "message": "Auto merge of #103093 - rytheo:linked-list-alloc-api, r=Mark-Simulacrum\n\nAdd support for allocators in `LinkedList`\n\nAllows `LinkedList` to use a custom allocator", "tree": {"sha": "8d6637411ebea42f18b72061cc7bf540f9a9048f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d6637411ebea42f18b72061cc7bf540f9a9048f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20d90b14ffe8c667757a70c08e2d9736ee89f493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20d90b14ffe8c667757a70c08e2d9736ee89f493", "html_url": "https://github.com/rust-lang/rust/commit/20d90b14ffe8c667757a70c08e2d9736ee89f493", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20d90b14ffe8c667757a70c08e2d9736ee89f493/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "999e6e5afb71d0fa6b5f67440278129aca12c67d", "url": "https://api.github.com/repos/rust-lang/rust/commits/999e6e5afb71d0fa6b5f67440278129aca12c67d", "html_url": "https://github.com/rust-lang/rust/commit/999e6e5afb71d0fa6b5f67440278129aca12c67d"}, {"sha": "34136ab59859198eb32280a8826fd2b0abe441b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/34136ab59859198eb32280a8826fd2b0abe441b8", "html_url": "https://github.com/rust-lang/rust/commit/34136ab59859198eb32280a8826fd2b0abe441b8"}], "stats": {"total": 363, "additions": 226, "deletions": 137}, "files": [{"sha": "0cb7e82beb05770f09d250d9cbe53153fb945dc5", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 224, "deletions": 135, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/20d90b14ffe8c667757a70c08e2d9736ee89f493/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d90b14ffe8c667757a70c08e2d9736ee89f493/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=20d90b14ffe8c667757a70c08e2d9736ee89f493", "patch": "@@ -18,9 +18,10 @@ use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::PhantomData;\n use core::mem;\n-use core::ptr::NonNull;\n+use core::ptr::{NonNull, Unique};\n \n use super::SpecExtend;\n+use crate::alloc::{Allocator, Global};\n use crate::boxed::Box;\n \n #[cfg(test)]\n@@ -47,11 +48,15 @@ mod tests;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"LinkedList\")]\n #[rustc_insignificant_dtor]\n-pub struct LinkedList<T> {\n+pub struct LinkedList<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,\n     len: usize,\n-    marker: PhantomData<Box<Node<T>>>,\n+    alloc: A,\n+    marker: PhantomData<Box<Node<T>, A>>,\n }\n \n struct Node<T> {\n@@ -81,6 +86,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n                 head: self.head,\n                 tail: self.tail,\n                 len: self.len,\n+                alloc: Global,\n                 marker: PhantomData,\n             }))\n             .field(&self.len)\n@@ -117,6 +123,7 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n                 head: self.head,\n                 tail: self.tail,\n                 len: self.len,\n+                alloc: Global,\n                 marker: PhantomData,\n             }))\n             .field(&self.len)\n@@ -132,12 +139,15 @@ impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n /// [`into_iter`]: LinkedList::into_iter\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct IntoIter<T> {\n-    list: LinkedList<T>,\n+pub struct IntoIter<\n+    T,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n+    list: LinkedList<T, A>,\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for IntoIter<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\").field(&self.list).finish()\n     }\n@@ -148,22 +158,25 @@ impl<T> Node<T> {\n         Node { next: None, prev: None, element }\n     }\n \n-    fn into_element(self: Box<Self>) -> T {\n+    fn into_element<A: Allocator>(self: Box<Self, A>) -> T {\n         self.element\n     }\n }\n \n // private methods\n-impl<T> LinkedList<T> {\n+impl<T, A: Allocator> LinkedList<T, A> {\n     /// Adds the given node to the front of the list.\n+    ///\n+    /// # Safety\n+    /// `node` must point to a valid node that was boxed using the list's allocator.\n     #[inline]\n-    fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n+    unsafe fn push_front_node(&mut self, node: Unique<Node<T>>) {\n         // This method takes care not to create mutable references to whole nodes,\n         // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n-            node.next = self.head;\n-            node.prev = None;\n-            let node = Some(Box::leak(node).into());\n+            (*node.as_ptr()).next = self.head;\n+            (*node.as_ptr()).prev = None;\n+            let node = Some(NonNull::from(node));\n \n             match self.head {\n                 None => self.tail = node,\n@@ -178,11 +191,11 @@ impl<T> LinkedList<T> {\n \n     /// Removes and returns the node at the front of the list.\n     #[inline]\n-    fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n+    fn pop_front_node(&mut self) -> Option<Box<Node<T>, &A>> {\n         // This method takes care not to create mutable references to whole nodes,\n         // to maintain validity of aliasing pointers into `element`.\n         self.head.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_ptr());\n+            let node = Box::from_raw_in(node.as_ptr(), &self.alloc);\n             self.head = node.next;\n \n             match self.head {\n@@ -197,14 +210,17 @@ impl<T> LinkedList<T> {\n     }\n \n     /// Adds the given node to the back of the list.\n+    ///\n+    /// # Safety\n+    /// `node` must point to a valid node that was boxed using the list's allocator.\n     #[inline]\n-    fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n+    unsafe fn push_back_node(&mut self, node: Unique<Node<T>>) {\n         // This method takes care not to create mutable references to whole nodes,\n         // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n-            node.next = None;\n-            node.prev = self.tail;\n-            let node = Some(Box::leak(node).into());\n+            (*node.as_ptr()).next = None;\n+            (*node.as_ptr()).prev = self.tail;\n+            let node = Some(NonNull::from(node));\n \n             match self.tail {\n                 None => self.head = node,\n@@ -219,11 +235,11 @@ impl<T> LinkedList<T> {\n \n     /// Removes and returns the node at the back of the list.\n     #[inline]\n-    fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n+    fn pop_back_node(&mut self) -> Option<Box<Node<T>, &A>> {\n         // This method takes care not to create mutable references to whole nodes,\n         // to maintain validity of aliasing pointers into `element`.\n         self.tail.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_ptr());\n+            let node = Box::from_raw_in(node.as_ptr(), &self.alloc);\n             self.tail = node.prev;\n \n             match self.tail {\n@@ -321,7 +337,10 @@ impl<T> LinkedList<T> {\n         &mut self,\n         split_node: Option<NonNull<Node<T>>>,\n         at: usize,\n-    ) -> Self {\n+    ) -> Self\n+    where\n+        A: Clone,\n+    {\n         // The split node is the new head node of the second part\n         if let Some(mut split_node) = split_node {\n             let first_part_head;\n@@ -342,6 +361,7 @@ impl<T> LinkedList<T> {\n                 head: first_part_head,\n                 tail: first_part_tail,\n                 len: at,\n+                alloc: self.alloc.clone(),\n                 marker: PhantomData,\n             };\n \n@@ -351,7 +371,7 @@ impl<T> LinkedList<T> {\n \n             first_part\n         } else {\n-            mem::replace(self, LinkedList::new())\n+            mem::replace(self, LinkedList::new_in(self.alloc.clone()))\n         }\n     }\n \n@@ -360,7 +380,10 @@ impl<T> LinkedList<T> {\n         &mut self,\n         split_node: Option<NonNull<Node<T>>>,\n         at: usize,\n-    ) -> Self {\n+    ) -> Self\n+    where\n+        A: Clone,\n+    {\n         // The split node is the new tail node of the first part and owns\n         // the head of the second part.\n         if let Some(mut split_node) = split_node {\n@@ -382,6 +405,7 @@ impl<T> LinkedList<T> {\n                 head: second_part_head,\n                 tail: second_part_tail,\n                 len: self.len - at,\n+                alloc: self.alloc.clone(),\n                 marker: PhantomData,\n             };\n \n@@ -391,7 +415,7 @@ impl<T> LinkedList<T> {\n \n             second_part\n         } else {\n-            mem::replace(self, LinkedList::new())\n+            mem::replace(self, LinkedList::new_in(self.alloc.clone()))\n         }\n     }\n }\n@@ -420,7 +444,7 @@ impl<T> LinkedList<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use]\n     pub const fn new() -> Self {\n-        LinkedList { head: None, tail: None, len: 0, marker: PhantomData }\n+        LinkedList { head: None, tail: None, len: 0, alloc: Global, marker: PhantomData }\n     }\n \n     /// Moves all elements from `other` to the end of the list.\n@@ -471,7 +495,26 @@ impl<T> LinkedList<T> {\n             }\n         }\n     }\n+}\n \n+impl<T, A: Allocator> LinkedList<T, A> {\n+    /// Constructs an empty `LinkedList<T, A>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(allocator_api)]\n+    ///\n+    /// use std::alloc::System;\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let list: LinkedList<u32, _> = LinkedList::new_in(System);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub const fn new_in(alloc: A) -> Self {\n+        LinkedList { head: None, tail: None, len: 0, alloc, marker: PhantomData }\n+    }\n     /// Provides a forward iterator.\n     ///\n     /// # Examples\n@@ -532,7 +575,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn cursor_front(&self) -> Cursor<'_, T> {\n+    pub fn cursor_front(&self) -> Cursor<'_, T, A> {\n         Cursor { index: 0, current: self.head, list: self }\n     }\n \n@@ -542,7 +585,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n+    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T, A> {\n         CursorMut { index: 0, current: self.head, list: self }\n     }\n \n@@ -552,7 +595,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn cursor_back(&self) -> Cursor<'_, T> {\n+    pub fn cursor_back(&self) -> Cursor<'_, T, A> {\n         Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n     }\n \n@@ -562,7 +605,7 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n+    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T, A> {\n         CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n     }\n \n@@ -638,7 +681,15 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        *self = Self::new();\n+        // We need to drop the nodes while keeping self.alloc\n+        // We can do this by moving (head, tail, len) into a new list that borrows self.alloc\n+        drop(LinkedList {\n+            head: self.head.take(),\n+            tail: self.tail.take(),\n+            len: mem::take(&mut self.len),\n+            alloc: &self.alloc,\n+            marker: PhantomData,\n+        });\n     }\n \n     /// Returns `true` if the `LinkedList` contains an element equal to the\n@@ -790,7 +841,12 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_front(&mut self, elt: T) {\n-        self.push_front_node(Box::new(Node::new(elt)));\n+        let node = Box::new_in(Node::new(elt), &self.alloc);\n+        let node_ptr = Unique::from(Box::leak(node));\n+        // SAFETY: node_ptr is a unique pointer to a node we boxed with self.alloc\n+        unsafe {\n+            self.push_front_node(node_ptr);\n+        }\n     }\n \n     /// Removes the first element and returns it, or `None` if the list is\n@@ -833,7 +889,12 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push_back(&mut self, elt: T) {\n-        self.push_back_node(Box::new(Node::new(elt)));\n+        let node = Box::new_in(Node::new(elt), &self.alloc);\n+        let node_ptr = Unique::from(Box::leak(node));\n+        // SAFETY: node_ptr is a unique pointer to a node we boxed with self.alloc\n+        unsafe {\n+            self.push_back_node(node_ptr);\n+        }\n     }\n \n     /// Removes the last element from a list and returns it, or `None` if\n@@ -883,13 +944,16 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(split.pop_front(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn split_off(&mut self, at: usize) -> LinkedList<T> {\n+    pub fn split_off(&mut self, at: usize) -> LinkedList<T, A>\n+    where\n+        A: Clone,\n+    {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::take(self);\n+            return mem::replace(self, Self::new_in(self.alloc.clone()));\n         } else if at == len {\n-            return Self::new();\n+            return Self::new_in(self.alloc.clone());\n         }\n \n         // Below, we iterate towards the `i-1`th node, either from the start or the end,\n@@ -987,7 +1051,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F, A>\n     where\n         F: FnMut(&mut T) -> bool,\n     {\n@@ -1000,23 +1064,22 @@ impl<T> LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n+unsafe impl<#[may_dangle] T, A: Allocator> Drop for LinkedList<T, A> {\n     fn drop(&mut self) {\n-        struct DropGuard<'a, T>(&'a mut LinkedList<T>);\n+        struct DropGuard<'a, T, A: Allocator>(&'a mut LinkedList<T, A>);\n \n-        impl<'a, T> Drop for DropGuard<'a, T> {\n+        impl<'a, T, A: Allocator> Drop for DropGuard<'a, T, A> {\n             fn drop(&mut self) {\n                 // Continue the same loop we do below. This only runs when a destructor has\n                 // panicked. If another one panics this will abort.\n                 while self.0.pop_front_node().is_some() {}\n             }\n         }\n \n-        while let Some(node) = self.pop_front_node() {\n-            let guard = DropGuard(self);\n-            drop(node);\n-            mem::forget(guard);\n-        }\n+        // Wrap self so that if a destructor panics, we can try to keep looping\n+        let guard = DropGuard(self);\n+        while guard.0.pop_front_node().is_some() {}\n+        mem::forget(guard);\n     }\n }\n \n@@ -1159,22 +1222,26 @@ impl<T> Default for IterMut<'_, T> {\n ///\n /// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-pub struct Cursor<'a, T: 'a> {\n+pub struct Cursor<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     index: usize,\n     current: Option<NonNull<Node<T>>>,\n-    list: &'a LinkedList<T>,\n+    list: &'a LinkedList<T, A>,\n }\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-impl<T> Clone for Cursor<'_, T> {\n+impl<T, A: Allocator> Clone for Cursor<'_, T, A> {\n     fn clone(&self) -> Self {\n         let Cursor { index, current, list } = *self;\n         Cursor { index, current, list }\n     }\n }\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for Cursor<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Cursor\").field(&self.list).field(&self.index()).finish()\n     }\n@@ -1191,20 +1258,24 @@ impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n /// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n /// tail of the list.\n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-pub struct CursorMut<'a, T: 'a> {\n+pub struct CursorMut<\n+    'a,\n+    T: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> {\n     index: usize,\n     current: Option<NonNull<Node<T>>>,\n-    list: &'a mut LinkedList<T>,\n+    list: &'a mut LinkedList<T, A>,\n }\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for CursorMut<'_, T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"CursorMut\").field(&self.list).field(&self.index()).finish()\n     }\n }\n \n-impl<'a, T> Cursor<'a, T> {\n+impl<'a, T, A: Allocator> Cursor<'a, T, A> {\n     /// Returns the cursor position index within the `LinkedList`.\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n@@ -1321,7 +1392,7 @@ impl<'a, T> Cursor<'a, T> {\n     }\n }\n \n-impl<'a, T> CursorMut<'a, T> {\n+impl<'a, T, A: Allocator> CursorMut<'a, T, A> {\n     /// Returns the cursor position index within the `LinkedList`.\n     ///\n     /// This returns `None` if the cursor is currently pointing to the\n@@ -1426,22 +1497,67 @@ impl<'a, T> CursorMut<'a, T> {\n     /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n     #[must_use]\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn as_cursor(&self) -> Cursor<'_, T> {\n+    pub fn as_cursor(&self) -> Cursor<'_, T, A> {\n         Cursor { list: self.list, current: self.current, index: self.index }\n     }\n }\n \n // Now the list editing operations\n \n impl<'a, T> CursorMut<'a, T> {\n+    /// Inserts the elements from the given `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the start of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_after(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_before(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n+            self.index += splice_len;\n+        }\n+    }\n+}\n+\n+impl<'a, T, A: Allocator> CursorMut<'a, T, A> {\n     /// Inserts a new element into the `LinkedList` after the current one.\n     ///\n     /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n     /// inserted at the front of the `LinkedList`.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_after(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n+            let spliced_node = Box::leak(Box::new_in(Node::new(item), &self.list.alloc)).into();\n             let node_next = match self.current {\n                 None => self.list.head,\n                 Some(node) => node.as_ref().next,\n@@ -1461,7 +1577,7 @@ impl<'a, T> CursorMut<'a, T> {\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn insert_before(&mut self, item: T) {\n         unsafe {\n-            let spliced_node = Box::leak(Box::new(Node::new(item))).into();\n+            let spliced_node = Box::leak(Box::new_in(Node::new(item), &self.list.alloc)).into();\n             let node_prev = match self.current {\n                 None => self.list.tail,\n                 Some(node) => node.as_ref().prev,\n@@ -1497,7 +1613,10 @@ impl<'a, T> CursorMut<'a, T> {\n     /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n     /// is removed and `None` is returned.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T>> {\n+    pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T, A>>\n+    where\n+        A: Clone,\n+    {\n         let mut unlinked_node = self.current?;\n         unsafe {\n             self.current = unlinked_node.as_ref().next;\n@@ -1509,62 +1628,23 @@ impl<'a, T> CursorMut<'a, T> {\n                 head: Some(unlinked_node),\n                 tail: Some(unlinked_node),\n                 len: 1,\n+                alloc: self.list.alloc.clone(),\n                 marker: PhantomData,\n             })\n         }\n     }\n \n-    /// Inserts the elements from the given `LinkedList` after the current one.\n-    ///\n-    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n-    /// inserted at the start of the `LinkedList`.\n-    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn splice_after(&mut self, list: LinkedList<T>) {\n-        unsafe {\n-            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n-                Some(parts) => parts,\n-                _ => return,\n-            };\n-            let node_next = match self.current {\n-                None => self.list.head,\n-                Some(node) => node.as_ref().next,\n-            };\n-            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n-            if self.current.is_none() {\n-                // The \"ghost\" non-element's index has changed.\n-                self.index = self.list.len;\n-            }\n-        }\n-    }\n-\n-    /// Inserts the elements from the given `LinkedList` before the current one.\n-    ///\n-    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n-    /// inserted at the end of the `LinkedList`.\n-    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn splice_before(&mut self, list: LinkedList<T>) {\n-        unsafe {\n-            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n-                Some(parts) => parts,\n-                _ => return,\n-            };\n-            let node_prev = match self.current {\n-                None => self.list.tail,\n-                Some(node) => node.as_ref().prev,\n-            };\n-            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n-            self.index += splice_len;\n-        }\n-    }\n-\n     /// Splits the list into two after the current element. This will return a\n     /// new list consisting of everything after the cursor, with the original\n     /// list retaining everything before.\n     ///\n     /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n     /// of the `LinkedList` are moved.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn split_after(&mut self) -> LinkedList<T> {\n+    pub fn split_after(&mut self) -> LinkedList<T, A>\n+    where\n+        A: Clone,\n+    {\n         let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n         if self.index == self.list.len {\n             // The \"ghost\" non-element's index has changed to 0.\n@@ -1580,7 +1660,10 @@ impl<'a, T> CursorMut<'a, T> {\n     /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n     /// of the `LinkedList` are moved.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-    pub fn split_before(&mut self) -> LinkedList<T> {\n+    pub fn split_before(&mut self) -> LinkedList<T, A>\n+    where\n+        A: Clone,\n+    {\n         let split_off_idx = self.index;\n         self.index = 0;\n         unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n@@ -1722,19 +1805,23 @@ impl<'a, T> CursorMut<'a, T> {\n \n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-pub struct DrainFilter<'a, T: 'a, F: 'a>\n-where\n+pub struct DrainFilter<\n+    'a,\n+    T: 'a,\n+    F: 'a,\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")] A: Allocator = Global,\n+> where\n     F: FnMut(&mut T) -> bool,\n {\n-    list: &'a mut LinkedList<T>,\n+    list: &'a mut LinkedList<T, A>,\n     it: Option<NonNull<Node<T>>>,\n     pred: F,\n     idx: usize,\n     old_len: usize,\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F> Iterator for DrainFilter<'_, T, F>\n+impl<T, F, A: Allocator> Iterator for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n@@ -1763,16 +1850,16 @@ where\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<T, F> Drop for DrainFilter<'_, T, F>\n+impl<T, F, A: Allocator> Drop for DrainFilter<'_, T, F, A>\n where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        struct DropGuard<'r, 'a, T, F>(&'r mut DrainFilter<'a, T, F>)\n+        struct DropGuard<'r, 'a, T, F, A: Allocator>(&'r mut DrainFilter<'a, T, F, A>)\n         where\n             F: FnMut(&mut T) -> bool;\n \n-        impl<'r, 'a, T, F> Drop for DropGuard<'r, 'a, T, F>\n+        impl<'r, 'a, T, F, A: Allocator> Drop for DropGuard<'r, 'a, T, F, A>\n         where\n             F: FnMut(&mut T) -> bool,\n         {\n@@ -1800,7 +1887,7 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Iterator for IntoIter<T> {\n+impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     type Item = T;\n \n     #[inline]\n@@ -1815,18 +1902,18 @@ impl<T> Iterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> DoubleEndedIterator for IntoIter<T> {\n+impl<T, A: Allocator> DoubleEndedIterator for IntoIter<T, A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.list.pop_back()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {}\n+impl<T, A: Allocator> ExactSizeIterator for IntoIter<T, A> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for IntoIter<T> {}\n+impl<T, A: Allocator> FusedIterator for IntoIter<T, A> {}\n \n #[stable(feature = \"default_iters\", since = \"CURRENT_RUSTC_VERSION\")]\n impl<T> Default for IntoIter<T> {\n@@ -1852,19 +1939,19 @@ impl<T> FromIterator<T> for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> IntoIterator for LinkedList<T> {\n+impl<T, A: Allocator> IntoIterator for LinkedList<T, A> {\n     type Item = T;\n-    type IntoIter = IntoIter<T>;\n+    type IntoIter = IntoIter<T, A>;\n \n     /// Consumes the list into an iterator yielding elements by value.\n     #[inline]\n-    fn into_iter(self) -> IntoIter<T> {\n+    fn into_iter(self) -> IntoIter<T, A> {\n         IntoIter { list: self }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a LinkedList<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a LinkedList<T, A> {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n \n@@ -1874,7 +1961,7 @@ impl<'a, T> IntoIterator for &'a LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n+impl<'a, T, A: Allocator> IntoIterator for &'a mut LinkedList<T, A> {\n     type Item = &'a mut T;\n     type IntoIter = IterMut<'a, T>;\n \n@@ -1884,7 +1971,7 @@ impl<'a, T> IntoIterator for &'a mut LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Extend<T> for LinkedList<T> {\n+impl<T, A: Allocator> Extend<T> for LinkedList<T, A> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n@@ -1895,7 +1982,7 @@ impl<T> Extend<T> for LinkedList<T> {\n     }\n }\n \n-impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n+impl<I: IntoIterator, A: Allocator> SpecExtend<I> for LinkedList<I::Item, A> {\n     default fn spec_extend(&mut self, iter: I) {\n         iter.into_iter().for_each(move |elt| self.push_back(elt));\n     }\n@@ -1908,7 +1995,7 @@ impl<T> SpecExtend<LinkedList<T>> for LinkedList<T> {\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n-impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n+impl<'a, T: 'a + Copy, A: Allocator> Extend<&'a T> for LinkedList<T, A> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n@@ -1920,7 +2007,7 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for LinkedList<T> {\n+impl<T: PartialEq, A: Allocator> PartialEq for LinkedList<T, A> {\n     fn eq(&self, other: &Self) -> bool {\n         self.len() == other.len() && self.iter().eq(other)\n     }\n@@ -1931,27 +2018,29 @@ impl<T: PartialEq> PartialEq for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Eq> Eq for LinkedList<T> {}\n+impl<T: Eq, A: Allocator> Eq for LinkedList<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialOrd> PartialOrd for LinkedList<T> {\n+impl<T: PartialOrd, A: Allocator> PartialOrd for LinkedList<T, A> {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         self.iter().partial_cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Ord> Ord for LinkedList<T> {\n+impl<T: Ord, A: Allocator> Ord for LinkedList<T, A> {\n     #[inline]\n     fn cmp(&self, other: &Self) -> Ordering {\n         self.iter().cmp(other)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Clone> Clone for LinkedList<T> {\n+impl<T: Clone, A: Allocator + Clone> Clone for LinkedList<T, A> {\n     fn clone(&self) -> Self {\n-        self.iter().cloned().collect()\n+        let mut list = Self::new_in(self.alloc.clone());\n+        list.extend(self.iter().cloned());\n+        list\n     }\n \n     fn clone_from(&mut self, other: &Self) {\n@@ -1969,14 +2058,14 @@ impl<T: Clone> Clone for LinkedList<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n+impl<T: fmt::Debug, A: Allocator> fmt::Debug for LinkedList<T, A> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Hash> Hash for LinkedList<T> {\n+impl<T: Hash, A: Allocator> Hash for LinkedList<T, A> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         state.write_length_prefix(self.len());\n         for elt in self {\n@@ -2016,10 +2105,10 @@ fn assert_covariance() {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for LinkedList<T> {}\n+unsafe impl<T: Send, A: Allocator + Send> Send for LinkedList<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for LinkedList<T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for LinkedList<T, A> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n@@ -2034,13 +2123,13 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-unsafe impl<T: Sync> Send for Cursor<'_, T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Send for Cursor<'_, T, A> {}\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-unsafe impl<T: Sync> Sync for Cursor<'_, T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for Cursor<'_, T, A> {}\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-unsafe impl<T: Send> Send for CursorMut<'_, T> {}\n+unsafe impl<T: Send, A: Allocator + Send> Send for CursorMut<'_, T, A> {}\n \n #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n-unsafe impl<T: Sync> Sync for CursorMut<'_, T> {}\n+unsafe impl<T: Sync, A: Allocator + Sync> Sync for CursorMut<'_, T, A> {}"}, {"sha": "c7df7dc3cb3b73571c6f8a5b8f2ad75c085e4d9d", "filename": "tests/debuginfo/pretty-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20d90b14ffe8c667757a70c08e2d9736ee89f493/tests%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d90b14ffe8c667757a70c08e2d9736ee89f493/tests%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdebuginfo%2Fpretty-std.rs?ref=20d90b14ffe8c667757a70c08e2d9736ee89f493", "patch": "@@ -130,8 +130,8 @@\n // cdb-check:    [+0x000] __0              : \"IAMA optional string!\" [Type: alloc::string::String]\n \n // cdb-command: dx linkedlist\n-// cdb-check:linkedlist       : { len=0x2 } [Type: alloc::collections::linked_list::LinkedList<i32>]\n-// cdb-check:    [<Raw View>]     [Type: alloc::collections::linked_list::LinkedList<i32>]\n+// cdb-check:linkedlist       : { len=0x2 } [Type: alloc::collections::linked_list::LinkedList<i32,alloc::alloc::Global>]\n+// cdb-check:    [<Raw View>]     [Type: alloc::collections::linked_list::LinkedList<i32,alloc::alloc::Global>]\n // cdb-check:    [0x0]            : 128 [Type: int]\n // cdb-check:    [0x1]            : 42 [Type: int]\n "}]}