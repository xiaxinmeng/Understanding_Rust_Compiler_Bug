{"sha": "2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMDY1NzEyY2Y5NjMyODA5MzQwMGZkMGExYTBjNGUwZjNiMWQ1MWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T12:46:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T12:46:20Z"}, "message": "Auto merge of #59619 - alexcrichton:wasi-fs, r=fitzgen\n\nwasi: Implement more of the standard library\n\nThis commit fills out more of the `wasm32-unknown-wasi` target's standard library, notably the `std::fs` module and all of its internals. A few tweaks were made along the way to non-`fs` modules, but the last commit contains the bulk of the work which is to wire up all APIs to their equivalent on WASI targets instead of unconditionally returning \"unsupported\". After this some basic filesystem operations and such should all be working in WASI!", "tree": {"sha": "e7ebae65f154a8e73c6aaca5e1085b5f5ec7d87d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ebae65f154a8e73c6aaca5e1085b5f5ec7d87d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "html_url": "https://github.com/rust-lang/rust/commit/2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e43f99ce576152d4b2f7315d491c4210211228d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43f99ce576152d4b2f7315d491c4210211228d6", "html_url": "https://github.com/rust-lang/rust/commit/e43f99ce576152d4b2f7315d491c4210211228d6"}, {"sha": "61b487ca8be1d8667a82c1357dc2729cfe56186d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61b487ca8be1d8667a82c1357dc2729cfe56186d", "html_url": "https://github.com/rust-lang/rust/commit/61b487ca8be1d8667a82c1357dc2729cfe56186d"}], "stats": {"total": 1493, "additions": 1189, "deletions": 304}, "files": [{"sha": "29f4c78e27b48aeb21bf856e5c7ffbd5dddc8441", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -881,6 +881,10 @@ impl OpenOptions {\n     }\n }\n \n+impl AsInner<fs_imp::OpenOptions> for OpenOptions {\n+    fn as_inner(&self) -> &fs_imp::OpenOptions { &self.0 }\n+}\n+\n impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n     fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }\n }\n@@ -1104,6 +1108,10 @@ impl AsInner<fs_imp::FileAttr> for Metadata {\n     fn as_inner(&self) -> &fs_imp::FileAttr { &self.0 }\n }\n \n+impl FromInner<fs_imp::FileAttr> for Metadata {\n+    fn from_inner(attr: fs_imp::FileAttr) -> Metadata { Metadata(attr) }\n+}\n+\n impl Permissions {\n     /// Returns `true` if these permissions describe a readonly (unwritable) file.\n     ///"}, {"sha": "ebefbc942103c349ae1189279e2fa4b0d6c7121e", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -2,14 +2,17 @@ use crate::os::unix::prelude::*;\n \n use crate::ffi::{OsString, OsStr};\n use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, SeekFrom};\n+use crate::io::{self, Error, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sync::Arc;\n use crate::sys::fd::FileDesc;\n use crate::sys::time::SystemTime;\n use crate::sys::{cvt, syscall};\n use crate::sys_common::{AsInner, FromInner};\n \n+pub use crate::sys_common::fs::copy;\n+pub use crate::sys_common::fs::remove_dir_all;\n+\n pub struct File(FileDesc);\n \n #[derive(Clone)]\n@@ -392,27 +395,6 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        unlink(path)\n-    } else {\n-        remove_dir_all_recursive(path)\n-    }\n-}\n-\n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        if child.file_type()?.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n-        }\n-    }\n-    rmdir(path)\n-}\n-\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let fd = cvt(syscall::open(p.to_str().unwrap(),\n                                syscall::O_CLOEXEC | syscall::O_SYMLINK | syscall::O_RDONLY))?;\n@@ -455,19 +437,3 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let file = File(FileDesc::new(fd));\n     file.path()\n }\n-\n-pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::{File, set_permissions};\n-    if !from.is_file() {\n-        return Err(Error::new(ErrorKind::InvalidInput,\n-                              \"the source path is not an existing regular file\"))\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    set_permissions(to, perm)?;\n-    Ok(ret)\n-}"}, {"sha": "dc3dcb5817c05683f4b867488d268df0c992a9ed", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -36,6 +36,8 @@ use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n               target_os = \"fuchsia\")))]\n use libc::{readdir_r as readdir64_r};\n \n+pub use crate::sys_common::fs::remove_dir_all;\n+\n pub struct File(FileDesc);\n \n #[derive(Clone)]\n@@ -734,27 +736,6 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n     Ok(())\n }\n \n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() {\n-        unlink(path)\n-    } else {\n-        remove_dir_all_recursive(path)\n-    }\n-}\n-\n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        if child.file_type()?.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n-        }\n-    }\n-    rmdir(path)\n-}\n-\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let c_path = cstr(p)?;\n     let p = c_path.as_ptr();"}, {"sha": "9c8e59e4fb5e1e47a04c7ef1ecc2193a46c4057e", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -1,30 +1,15 @@\n-use crate::any::Any;\n use crate::ffi::CStr;\n+use crate::io;\n+use crate::sys::cvt_wasi;\n use crate::ffi::OsString;\n use crate::marker::PhantomData;\n use crate::os::wasi::ffi::OsStringExt;\n-use crate::ptr;\n use crate::vec;\n \n-static mut ARGC: isize = 0;\n-static mut ARGV: *const *const u8 = ptr::null();\n-\n-#[cfg(not(target_feature = \"atomics\"))]\n-pub unsafe fn args_lock() -> impl Any {\n-    // No need for a lock if we're single-threaded, but this function will need\n-    // to get implemented for multi-threaded scenarios\n-}\n-\n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    let _guard = args_lock();\n-    ARGC = argc;\n-    ARGV = argv;\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n }\n \n pub unsafe fn cleanup() {\n-    let _guard = args_lock();\n-    ARGC = 0;\n-    ARGV = ptr::null();\n }\n \n pub struct Args {\n@@ -34,18 +19,31 @@ pub struct Args {\n \n /// Returns the command line arguments\n pub fn args() -> Args {\n+    maybe_args().unwrap_or_else(|_| {\n+        Args {\n+            iter: Vec::new().into_iter(),\n+            _dont_send_or_sync_me: PhantomData\n+        }\n+    })\n+}\n+\n+fn maybe_args() -> io::Result<Args> {\n     unsafe {\n-        let _guard = args_lock();\n-        let args = (0..ARGC)\n-            .map(|i| {\n-                let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n-                OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-            })\n+        let (mut argc, mut argv_buf_size) = (0, 0);\n+        cvt_wasi(libc::__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n+\n+        let mut argc = vec![0 as *mut libc::c_char; argc];\n+        let mut argv_buf = vec![0; argv_buf_size];\n+        cvt_wasi(libc::__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n+\n+        let args = argc.into_iter()\n+            .map(|ptr| CStr::from_ptr(ptr).to_bytes().to_vec())\n+            .map(|bytes| OsString::from_vec(bytes))\n             .collect::<Vec<_>>();\n-        Args {\n+        Ok(Args {\n             iter: args.into_iter(),\n             _dont_send_or_sync_me: PhantomData,\n-        }\n+        })\n     }\n }\n "}, {"sha": "f71f316d1ba1088b8667d495bfe401f674badde7", "filename": "src/libstd/sys/wasi/ext/ffi.rs", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fffi.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -2,60 +2,5 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use crate::ffi::{OsStr, OsString};\n-use crate::mem;\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{FromInner, IntoInner, AsInner};\n-\n-/// WASI-specific extensions to [`OsString`].\n-///\n-/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait OsStringExt {\n-    /// Creates an `OsString` from a byte vector.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn from_vec(vec: Vec<u8>) -> Self;\n-\n-    /// Yields the underlying byte vector of this `OsString`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn into_vec(self) -> Vec<u8>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl OsStringExt for OsString {\n-    fn from_vec(vec: Vec<u8>) -> OsString {\n-        FromInner::from_inner(Buf { inner: vec })\n-    }\n-    fn into_vec(self) -> Vec<u8> {\n-        self.into_inner().inner\n-    }\n-}\n-\n-/// WASI-specific extensions to [`OsStr`].\n-///\n-/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait OsStrExt {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    /// Creates an [`OsStr`] from a byte slice.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n-    fn from_bytes(slice: &[u8]) -> &Self;\n-\n-    /// Gets the underlying byte view of the [`OsStr`] slice.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_bytes(&self) -> &[u8];\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl OsStrExt for OsStr {\n-    fn from_bytes(slice: &[u8]) -> &OsStr {\n-        unsafe { mem::transmute(slice) }\n-    }\n-    fn as_bytes(&self) -> &[u8] {\n-        &self.as_inner().inner\n-    }\n-}\n-\n+pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "53f415c78219eab2f3b713ef7d1443268afdebc4", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "added", "additions": 412, "deletions": 0, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -0,0 +1,412 @@\n+//! WASI-specific extensions to primitives in the `std::fs` module.\n+\n+#![unstable(feature = \"wasi_ext\", issue = \"0\")]\n+\n+use crate::fs::{self, File, Metadata, OpenOptions};\n+use crate::io::{self, IoVec, IoVecMut};\n+use crate::os::wasi::ffi::OsStrExt;\n+use crate::path::{Path, PathBuf};\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n+\n+/// WASI-specific extensions to [`File`].\n+///\n+/// [`File`]: ../../../../std/fs/struct.File.html\n+pub trait FileExt {\n+    /// Reads a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes read.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// Note that similar to [`File::read_vectored`], it is not an error to\n+    /// return with a short read.\n+    ///\n+    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n+    fn read_at(&self, bufs: &mut [IoVecMut<'_>], offset: u64) -> io::Result<usize>;\n+\n+    /// Writes a number of bytes starting from a given offset.\n+    ///\n+    /// Returns the number of bytes written.\n+    ///\n+    /// The offset is relative to the start of the file and thus independent\n+    /// from the current cursor.\n+    ///\n+    /// The current file cursor is not affected by this function.\n+    ///\n+    /// When writing beyond the end of the file, the file is appropriately\n+    /// extended and the intermediate bytes are initialized with the value 0.\n+    ///\n+    /// Note that similar to [`File::write_vectored`], it is not an error to return a\n+    /// short write.\n+    ///\n+    /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n+    fn write_at(&self, bufs: &[IoVec<'_>], offset: u64) -> io::Result<usize>;\n+\n+    /// Returns the current position within the file.\n+    ///\n+    /// This corresponds to the `__wasi_fd_tell` syscall and is similar to\n+    /// `seek` where you offset 0 bytes from the current position.\n+    fn tell(&self) -> io::Result<u64>;\n+\n+    /// Adjust the flags associated with this file.\n+    ///\n+    /// This corresponds to the `__wasi_fd_fdstat_set_flags` syscall.\n+    fn fdstat_set_flags(&self, flags: u16) -> io::Result<()>;\n+\n+    /// Adjust the rights associated with this file.\n+    ///\n+    /// This corresponds to the `__wasi_fd_fdstat_set_rights` syscall.\n+    fn fdstat_set_rights(&self, rights: u64, inheriting: u64) -> io::Result<()>;\n+\n+    /// Provide file advisory information on a file descriptor.\n+    ///\n+    /// This corresponds to the `__wasi_fd_advise` syscall.\n+    fn advise(&self, offset: u64, len: u64, advice: u8) -> io::Result<()>;\n+\n+    /// Force the allocation of space in a file.\n+    ///\n+    /// This corresponds to the `__wasi_fd_allocate` syscall.\n+    fn allocate(&self, offset: u64, len: u64) -> io::Result<()>;\n+\n+    /// Create a directory.\n+    ///\n+    /// This corresponds to the `__wasi_path_create_directory` syscall.\n+    fn create_directory<P: AsRef<Path>>(&self, dir: P) -> io::Result<()>;\n+\n+    /// Read the contents of a symbolic link.\n+    ///\n+    /// This corresponds to the `__wasi_path_readlink` syscall.\n+    fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf>;\n+\n+    /// Return the attributes of a file or directory.\n+    ///\n+    /// This corresponds to the `__wasi_path_filestat_get` syscall.\n+    fn metadata_at<P: AsRef<Path>>(&self, lookup_flags: u32, path: P) -> io::Result<Metadata>;\n+\n+    /// Unlink a file.\n+    ///\n+    /// This corresponds to the `__wasi_path_unlink_file` syscall.\n+    fn remove_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()>;\n+\n+    /// Remove a directory.\n+    ///\n+    /// This corresponds to the `__wasi_path_remove_directory` syscall.\n+    fn remove_directory<P: AsRef<Path>>(&self, path: P) -> io::Result<()>;\n+}\n+\n+// FIXME: bind __wasi_fd_fdstat_get - need to define a custom return type\n+// FIXME: bind __wasi_fd_readdir - can't return `ReadDir` since we only have entry name\n+// FIXME: bind __wasi_fd_filestat_set_times maybe? - on crates.io for unix\n+// FIXME: bind __wasi_path_filestat_set_times maybe? - on crates.io for unix\n+// FIXME: bind __wasi_poll_oneoff maybe? - probably should wait for I/O to settle\n+// FIXME: bind __wasi_random_get maybe? - on crates.io for unix\n+\n+impl FileExt for fs::File {\n+    fn read_at(&self, bufs: &mut [IoVecMut<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().fd().pread(bufs, offset)\n+    }\n+\n+    fn write_at(&self, bufs: &[IoVec<'_>], offset: u64) -> io::Result<usize> {\n+        self.as_inner().fd().pwrite(bufs, offset)\n+    }\n+\n+    fn tell(&self) -> io::Result<u64> {\n+        self.as_inner().fd().tell()\n+    }\n+\n+    fn fdstat_set_flags(&self, flags: u16) -> io::Result<()> {\n+        self.as_inner().fd().set_flags(flags)\n+    }\n+\n+    fn fdstat_set_rights(&self, rights: u64, inheriting: u64) -> io::Result<()> {\n+        self.as_inner().fd().set_rights(rights, inheriting)\n+    }\n+\n+    fn advise(&self, offset: u64, len: u64, advice: u8) -> io::Result<()> {\n+        self.as_inner().fd().advise(offset, len, advice)\n+    }\n+\n+    fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n+        self.as_inner().fd().allocate(offset, len)\n+    }\n+\n+    fn create_directory<P: AsRef<Path>>(&self, dir: P) -> io::Result<()> {\n+        self.as_inner()\n+            .fd()\n+            .create_directory(dir.as_ref().as_os_str().as_bytes())\n+    }\n+\n+    fn read_link<P: AsRef<Path>>(&self, path: P) -> io::Result<PathBuf> {\n+        self.as_inner().read_link(path.as_ref())\n+    }\n+\n+    fn metadata_at<P: AsRef<Path>>(&self, lookup_flags: u32, path: P) -> io::Result<Metadata> {\n+        let m = self.as_inner().metadata_at(lookup_flags, path.as_ref())?;\n+        Ok(FromInner::from_inner(m))\n+    }\n+\n+    fn remove_file<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        self.as_inner()\n+            .fd()\n+            .unlink_file(path.as_ref().as_os_str().as_bytes())\n+    }\n+\n+    fn remove_directory<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        self.as_inner()\n+            .fd()\n+            .remove_directory(path.as_ref().as_os_str().as_bytes())\n+    }\n+}\n+\n+/// WASI-specific extensions to [`fs::OpenOptions`].\n+///\n+/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n+pub trait OpenOptionsExt {\n+    /// Pass custom `dirflags` argument to `__wasi_path_open`.\n+    ///\n+    /// This option configures the `dirflags` argument to the\n+    /// `__wasi_path_open` syscall which `OpenOptions` will eventually call. The\n+    /// `dirflags` argument configures how the file is looked up, currently\n+    /// primarily affecting whether symlinks are followed or not.\n+    ///\n+    /// By default this value is `__WASI_LOOKUP_SYMLINK_FOLLOW`, or symlinks are\n+    /// followed. You can call this method with 0 to disable following symlinks\n+    fn lookup_flags(&mut self, flags: u32) -> &mut Self;\n+\n+    /// Indicates whether `OpenOptions` must open a directory or not.\n+    ///\n+    /// This method will configure whether the `__WASI_O_DIRECTORY` flag is\n+    /// passed when opening a file. When passed it will require that the opened\n+    /// path is a directory.\n+    ///\n+    /// This option is by default `false`\n+    fn directory(&mut self, dir: bool) -> &mut Self;\n+\n+    /// Indicates whether `__WASI_FDFLAG_DSYNC` is passed in the `fs_flags`\n+    /// field of `__wasi_path_open`.\n+    ///\n+    /// This option is by default `false`\n+    fn dsync(&mut self, dsync: bool) -> &mut Self;\n+\n+    /// Indicates whether `__WASI_FDFLAG_NONBLOCK` is passed in the `fs_flags`\n+    /// field of `__wasi_path_open`.\n+    ///\n+    /// This option is by default `false`\n+    fn nonblock(&mut self, nonblock: bool) -> &mut Self;\n+\n+    /// Indicates whether `__WASI_FDFLAG_RSYNC` is passed in the `fs_flags`\n+    /// field of `__wasi_path_open`.\n+    ///\n+    /// This option is by default `false`\n+    fn rsync(&mut self, rsync: bool) -> &mut Self;\n+\n+    /// Indicates whether `__WASI_FDFLAG_SYNC` is passed in the `fs_flags`\n+    /// field of `__wasi_path_open`.\n+    ///\n+    /// This option is by default `false`\n+    fn sync(&mut self, sync: bool) -> &mut Self;\n+\n+    /// Indicates the value that should be passed in for the `fs_rights_base`\n+    /// parameter of `__wasi_path_open`.\n+    ///\n+    /// This option defaults based on the `read` and `write` configuration of\n+    /// this `OpenOptions` builder. If this method is called, however, the\n+    /// exact mask passed in will be used instead.\n+    fn fs_rights_base(&mut self, rights: u64) -> &mut Self;\n+\n+    /// Indicates the value that should be passed in for the\n+    /// `fs_rights_inheriting` parameter of `__wasi_path_open`.\n+    ///\n+    /// The default for this option is the same value as what will be passed\n+    /// for the `fs_rights_base` parameter but if this method is called then\n+    /// the specified value will be used instead.\n+    fn fs_rights_inheriting(&mut self, rights: u64) -> &mut Self;\n+\n+    /// Open a file or directory.\n+    ///\n+    /// This corresponds to the `__wasi_path_open` syscall.\n+    fn open_at<P: AsRef<Path>>(&self, file: &File, path: P) -> io::Result<File>;\n+}\n+\n+impl OpenOptionsExt for OpenOptions {\n+    fn lookup_flags(&mut self, flags: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().lookup_flags(flags);\n+        self\n+    }\n+\n+    fn directory(&mut self, dir: bool) -> &mut OpenOptions {\n+        self.as_inner_mut().directory(dir);\n+        self\n+    }\n+\n+    fn dsync(&mut self, enabled: bool) -> &mut OpenOptions {\n+        self.as_inner_mut().dsync(enabled);\n+        self\n+    }\n+\n+    fn nonblock(&mut self, enabled: bool) -> &mut OpenOptions {\n+        self.as_inner_mut().nonblock(enabled);\n+        self\n+    }\n+\n+    fn rsync(&mut self, enabled: bool) -> &mut OpenOptions {\n+        self.as_inner_mut().rsync(enabled);\n+        self\n+    }\n+\n+    fn sync(&mut self, enabled: bool) -> &mut OpenOptions {\n+        self.as_inner_mut().sync(enabled);\n+        self\n+    }\n+\n+    fn fs_rights_base(&mut self, rights: u64) -> &mut OpenOptions {\n+        self.as_inner_mut().fs_rights_base(rights);\n+        self\n+    }\n+\n+    fn fs_rights_inheriting(&mut self, rights: u64) -> &mut OpenOptions {\n+        self.as_inner_mut().fs_rights_inheriting(rights);\n+        self\n+    }\n+\n+    fn open_at<P: AsRef<Path>>(&self, file: &File, path: P) -> io::Result<File> {\n+        let inner = file.as_inner().open_at(path.as_ref(), self.as_inner())?;\n+        Ok(File::from_inner(inner))\n+    }\n+}\n+\n+/// WASI-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+pub trait MetadataExt {\n+    /// Returns the `st_dev` field of the internal `__wasi_filestat_t`\n+    fn dev(&self) -> u64;\n+    /// Returns the `st_ino` field of the internal `__wasi_filestat_t`\n+    fn ino(&self) -> u64;\n+    /// Returns the `st_nlink` field of the internal `__wasi_filestat_t`\n+    fn nlink(&self) -> u32;\n+    /// Returns the `st_atim` field of the internal `__wasi_filestat_t`\n+    fn atim(&self) -> u64;\n+    /// Returns the `st_mtim` field of the internal `__wasi_filestat_t`\n+    fn mtim(&self) -> u64;\n+    /// Returns the `st_ctim` field of the internal `__wasi_filestat_t`\n+    fn ctim(&self) -> u64;\n+}\n+\n+impl MetadataExt for fs::Metadata {\n+    fn dev(&self) -> u64 {\n+        self.as_inner().as_wasi().st_dev\n+    }\n+    fn ino(&self) -> u64 {\n+        self.as_inner().as_wasi().st_ino\n+    }\n+    fn nlink(&self) -> u32 {\n+        self.as_inner().as_wasi().st_nlink\n+    }\n+    fn atim(&self) -> u64 {\n+        self.as_inner().as_wasi().st_atim\n+    }\n+    fn mtim(&self) -> u64 {\n+        self.as_inner().as_wasi().st_mtim\n+    }\n+    fn ctim(&self) -> u64 {\n+        self.as_inner().as_wasi().st_ctim\n+    }\n+}\n+\n+/// WASI-specific extensions for [`FileType`].\n+///\n+/// Adds support for special WASI file types such as block/character devices,\n+/// pipes, and sockets.\n+///\n+/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n+pub trait FileTypeExt {\n+    /// Returns `true` if this file type is a block device.\n+    fn is_block_device(&self) -> bool;\n+    /// Returns `true` if this file type is a character device.\n+    fn is_character_device(&self) -> bool;\n+    /// Returns `true` if this file type is a socket datagram.\n+    fn is_socket_dgram(&self) -> bool;\n+    /// Returns `true` if this file type is a socket stream.\n+    fn is_socket_stream(&self) -> bool;\n+}\n+\n+impl FileTypeExt for fs::FileType {\n+    fn is_block_device(&self) -> bool {\n+        self.as_inner().bits() == libc::__WASI_FILETYPE_BLOCK_DEVICE\n+    }\n+    fn is_character_device(&self) -> bool {\n+        self.as_inner().bits() == libc::__WASI_FILETYPE_CHARACTER_DEVICE\n+    }\n+    fn is_socket_dgram(&self) -> bool {\n+        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_DGRAM\n+    }\n+    fn is_socket_stream(&self) -> bool {\n+        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_STREAM\n+    }\n+}\n+\n+/// WASI-specific extension methods for [`fs::DirEntry`].\n+///\n+/// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n+pub trait DirEntryExt {\n+    /// Returns the underlying `d_ino` field of the `__wasi_dirent_t`\n+    fn ino(&self) -> u64;\n+}\n+\n+impl DirEntryExt for fs::DirEntry {\n+    fn ino(&self) -> u64 {\n+        self.as_inner().ino()\n+    }\n+}\n+\n+/// Create a hard link.\n+///\n+/// This corresponds to the `__wasi_path_link` syscall.\n+pub fn link<P: AsRef<Path>, U: AsRef<Path>>(\n+    old_fd: &File,\n+    old_flags: u32,\n+    old_path: P,\n+    new_fd: &File,\n+    new_path: U,\n+) -> io::Result<()> {\n+    old_fd.as_inner().fd().link(\n+        old_flags,\n+        old_path.as_ref().as_os_str().as_bytes(),\n+        new_fd.as_inner().fd(),\n+        new_path.as_ref().as_os_str().as_bytes(),\n+    )\n+}\n+\n+/// Rename a file or directory.\n+///\n+/// This corresponds to the `__wasi_path_rename` syscall.\n+pub fn rename<P: AsRef<Path>, U: AsRef<Path>>(\n+    old_fd: &File,\n+    old_path: P,\n+    new_fd: &File,\n+    new_path: U,\n+) -> io::Result<()> {\n+    old_fd.as_inner().fd().rename(\n+        old_path.as_ref().as_os_str().as_bytes(),\n+        new_fd.as_inner().fd(),\n+        new_path.as_ref().as_os_str().as_bytes(),\n+    )\n+}\n+\n+/// Create a symbolic link.\n+///\n+/// This corresponds to the `__wasi_path_symlink` syscall.\n+pub fn symlink<P: AsRef<Path>, U: AsRef<Path>>(\n+    old_path: P,\n+    fd: &File,\n+    new_path: U,\n+) -> io::Result<()> {\n+    fd.as_inner().fd().symlink(\n+        old_path.as_ref().as_os_str().as_bytes(),\n+        new_path.as_ref().as_os_str().as_bytes(),\n+    )\n+}"}, {"sha": "cf75a96d28c1ae3a53b6f7a85c078b95717ab905", "filename": "src/libstd/sys/wasi/ext/io.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -0,0 +1,87 @@\n+//! WASI-specific extensions to general I/O primitives\n+\n+#![unstable(feature = \"wasi_ext\", issue = \"0\")]\n+\n+use crate::fs;\n+use crate::io;\n+use crate::sys;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+\n+/// Raw file descriptors.\n+pub type RawFd = u32;\n+\n+/// A trait to extract the raw WASI file descriptor from an underlying\n+/// object.\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+pub trait FromRawFd {\n+    /// Constructs a new instance of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+pub trait IntoRawFd {\n+    /// Consumes this object, returning the raw underlying file descriptor.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    fn into_raw_fd(self) -> RawFd;\n+}\n+\n+impl AsRawFd for fs::File {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().fd().as_raw()\n+    }\n+}\n+\n+impl FromRawFd for fs::File {\n+    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n+        fs::File::from_inner(sys::fs::File::from_inner(fd))\n+    }\n+}\n+\n+impl IntoRawFd for fs::File {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_fd().into_raw()\n+    }\n+}\n+\n+impl AsRawFd for io::Stdin {\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDIN_FILENO as u32\n+    }\n+}\n+\n+impl AsRawFd for io::Stdout {\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDOUT_FILENO as u32\n+    }\n+}\n+\n+impl AsRawFd for io::Stderr {\n+    fn as_raw_fd(&self) -> RawFd {\n+        libc::STDERR_FILENO as u32\n+    }\n+}"}, {"sha": "1c24b244b8cd01ba7d6392dc30851c021118eed1", "filename": "src/libstd/sys/wasi/ext/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fmod.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -1,4 +1,6 @@\n pub mod ffi;\n+pub mod fs;\n+pub mod io;\n \n /// A prelude for conveniently writing platform-specific code.\n ///\n@@ -7,4 +9,10 @@ pub mod ffi;\n pub mod prelude {\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use crate::sys::ext::ffi::{OsStringExt, OsStrExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::fs::{FileExt, DirEntryExt, MetadataExt, OpenOptionsExt};\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::fs::FileTypeExt;\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use crate::sys::ext::io::{AsRawFd, IntoRawFd, FromRawFd};\n }"}, {"sha": "0b68b6f4d9c72b41ccb20c1ea72674ff40e3a507", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -6,6 +6,7 @@ use crate::net::Shutdown;\n use crate::sys::cvt_wasi;\n use libc::{self, c_char, c_void};\n \n+#[derive(Debug)]\n pub struct WasiFd {\n     fd: libc::__wasi_fd_t,\n }\n@@ -52,6 +53,16 @@ impl WasiFd {\n         WasiFd { fd }\n     }\n \n+    pub fn into_raw(self) -> libc::__wasi_fd_t {\n+        let ret = self.fd;\n+        mem::forget(self);\n+        ret\n+    }\n+\n+    pub fn as_raw(&self) -> libc::__wasi_fd_t {\n+        self.fd\n+    }\n+\n     pub fn datasync(&self) -> io::Result<()> {\n         cvt_wasi(unsafe { libc::__wasi_fd_datasync(self.fd) })\n     }\n@@ -123,7 +134,7 @@ impl WasiFd {\n         cvt_wasi(unsafe { libc::__wasi_fd_allocate(self.fd, offset, len) })\n     }\n \n-    pub fn crate_directory(&self, path: &[u8]) -> io::Result<()> {\n+    pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n         cvt_wasi(unsafe {\n             libc::__wasi_path_create_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n         })\n@@ -217,7 +228,9 @@ impl WasiFd {\n         })\n     }\n \n-    // FIXME: __wasi_fd_filestat_get\n+    pub fn filestat_get(&self, buf: *mut libc::__wasi_filestat_t) -> io::Result<()> {\n+        cvt_wasi(unsafe { libc::__wasi_fd_filestat_get(self.fd, buf) })\n+    }\n \n     pub fn filestat_set_times(\n         &self,\n@@ -232,7 +245,22 @@ impl WasiFd {\n         cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_size(self.fd, size) })\n     }\n \n-    // FIXME: __wasi_path_filestat_get\n+    pub fn path_filestat_get(\n+        &self,\n+        flags: LookupFlags,\n+        path: &[u8],\n+        buf: *mut libc::__wasi_filestat_t,\n+    ) -> io::Result<()> {\n+        cvt_wasi(unsafe {\n+            libc::__wasi_path_filestat_get(\n+                self.fd,\n+                flags,\n+                path.as_ptr() as *const c_char,\n+                path.len(),\n+                buf,\n+            )\n+        })\n+    }\n \n     pub fn path_filestat_set_times(\n         &self,"}, {"sha": "7b1c2bd79cc167cef5354084e35b6cff65532a48", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 540, "deletions": 142, "changes": 682, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -1,294 +1,692 @@\n-use crate::ffi::OsString;\n+use crate::collections::HashMap;\n+use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n-use crate::hash::{Hash, Hasher};\n-use crate::io::{self, SeekFrom};\n+use crate::io::{self, IoVec, IoVecMut, SeekFrom};\n+use crate::iter;\n+use crate::mem::{self, ManuallyDrop};\n+use crate::os::wasi::ffi::{OsStrExt, OsStringExt};\n use crate::path::{Path, PathBuf};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering::SeqCst};\n+use crate::sync::Arc;\n+use crate::sys::fd::{DirCookie, WasiFd};\n use crate::sys::time::SystemTime;\n-use crate::sys::{unsupported, Void};\n+use crate::sys::{cvt_wasi, unsupported};\n+use crate::sys_common::FromInner;\n \n-pub struct File(Void);\n+pub use crate::sys_common::fs::copy;\n+pub use crate::sys_common::fs::remove_dir_all;\n \n-pub struct FileAttr(Void);\n+pub struct File {\n+    fd: WasiFd,\n+}\n+\n+#[derive(Clone)]\n+pub struct FileAttr {\n+    meta: libc::__wasi_filestat_t,\n+}\n \n-pub struct ReadDir(Void);\n+pub struct ReadDir {\n+    inner: Arc<ReadDirInner>,\n+    cookie: Option<DirCookie>,\n+    buf: Vec<u8>,\n+    offset: usize,\n+    cap: usize,\n+}\n \n-pub struct DirEntry(Void);\n+struct ReadDirInner {\n+    root: PathBuf,\n+    dir: File,\n+}\n+\n+pub struct DirEntry {\n+    meta: libc::__wasi_dirent_t,\n+    name: Vec<u8>,\n+    inner: Arc<ReadDirInner>,\n+}\n \n-#[derive(Clone, Debug)]\n-pub struct OpenOptions { }\n+#[derive(Clone, Debug, Default)]\n+pub struct OpenOptions {\n+    read: bool,\n+    write: bool,\n+    dirflags: libc::__wasi_lookupflags_t,\n+    fdflags: libc::__wasi_fdflags_t,\n+    oflags: libc::__wasi_oflags_t,\n+    rights_base: Option<libc::__wasi_rights_t>,\n+    rights_inheriting: Option<libc::__wasi_rights_t>,\n+}\n \n-pub struct FilePermissions(Void);\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct FilePermissions {\n+    readonly: bool,\n+}\n \n-pub struct FileType(Void);\n+#[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]\n+pub struct FileType {\n+    bits: libc::__wasi_filetype_t,\n+}\n \n #[derive(Debug)]\n-pub struct DirBuilder { }\n+pub struct DirBuilder {}\n \n impl FileAttr {\n+    fn zero() -> FileAttr {\n+        FileAttr {\n+            meta: unsafe { mem::zeroed() },\n+        }\n+    }\n+\n     pub fn size(&self) -> u64 {\n-        match self.0 {}\n+        self.meta.st_size\n     }\n \n     pub fn perm(&self) -> FilePermissions {\n-        match self.0 {}\n+        // not currently implemented in wasi yet\n+        FilePermissions { readonly: false }\n     }\n \n     pub fn file_type(&self) -> FileType {\n-        match self.0 {}\n+        FileType {\n+            bits: self.meta.st_filetype,\n+        }\n     }\n \n     pub fn modified(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.st_mtim))\n     }\n \n     pub fn accessed(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.st_atim))\n     }\n \n     pub fn created(&self) -> io::Result<SystemTime> {\n-        match self.0 {}\n+        Ok(SystemTime::from_wasi_timestamp(self.meta.st_ctim))\n     }\n-}\n \n-impl Clone for FileAttr {\n-    fn clone(&self) -> FileAttr {\n-        match self.0 {}\n+    pub fn as_wasi(&self) -> &libc::__wasi_filestat_t {\n+        &self.meta\n     }\n }\n \n impl FilePermissions {\n     pub fn readonly(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn set_readonly(&mut self, _readonly: bool) {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FilePermissions {\n-    fn clone(&self) -> FilePermissions {\n-        match self.0 {}\n-    }\n-}\n-\n-impl PartialEq for FilePermissions {\n-    fn eq(&self, _other: &FilePermissions) -> bool {\n-        match self.0 {}\n+        self.readonly\n     }\n-}\n-\n-impl Eq for FilePermissions {\n-}\n \n-impl fmt::Debug for FilePermissions {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+    pub fn set_readonly(&mut self, readonly: bool) {\n+        self.readonly = readonly;\n     }\n }\n \n impl FileType {\n     pub fn is_dir(&self) -> bool {\n-        match self.0 {}\n+        self.bits == libc::__WASI_FILETYPE_DIRECTORY\n     }\n \n     pub fn is_file(&self) -> bool {\n-        match self.0 {}\n+        self.bits == libc::__WASI_FILETYPE_REGULAR_FILE\n     }\n \n     pub fn is_symlink(&self) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for FileType {\n-    fn clone(&self) -> FileType {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for FileType {}\n-\n-impl PartialEq for FileType {\n-    fn eq(&self, _other: &FileType) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for FileType {\n-}\n-\n-impl Hash for FileType {\n-    fn hash<H: Hasher>(&self, _h: &mut H) {\n-        match self.0 {}\n+        self.bits == libc::__WASI_FILETYPE_SYMBOLIC_LINK\n     }\n-}\n \n-impl fmt::Debug for FileType {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+    pub fn bits(&self) -> libc::__wasi_filetype_t {\n+        self.bits\n     }\n }\n \n impl fmt::Debug for ReadDir {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"ReadDir\").finish()\n     }\n }\n \n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        match self.0 {}\n+        loop {\n+            // If we've reached the capacity of our buffer then we need to read\n+            // some more from the OS, otherwise we pick up at our old offset.\n+            let offset = if self.offset == self.cap {\n+                let cookie = self.cookie.take()?;\n+                match self.inner.dir.fd.readdir(&mut self.buf, cookie) {\n+                    Ok(bytes) => self.cap = bytes,\n+                    Err(e) => return Some(Err(e)),\n+                }\n+                self.offset = 0;\n+                self.cookie = Some(cookie);\n+\n+                // If we didn't actually read anything, this is in theory the\n+                // end of the directory.\n+                if self.cap == 0 {\n+                    self.cookie = None;\n+                    return None;\n+                }\n+\n+                0\n+            } else {\n+                self.offset\n+            };\n+            let data = &self.buf[offset..self.cap];\n+\n+            // If we're not able to read a directory entry then that means it\n+            // must have been truncated at the end of the buffer, so reset our\n+            // offset so we can go back and reread into the buffer, picking up\n+            // where we last left off.\n+            let dirent_size = mem::size_of::<libc::__wasi_dirent_t>();\n+            if data.len() < dirent_size {\n+                assert!(self.cookie.is_some());\n+                assert!(self.buf.len() >= dirent_size);\n+                self.offset = self.cap;\n+                continue;\n+            }\n+            let (dirent, data) = data.split_at(dirent_size);\n+            let dirent =\n+                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const libc::__wasi_dirent_t) };\n+\n+            // If the file name was truncated, then we need to reinvoke\n+            // `readdir` so we truncate our buffer to start over and reread this\n+            // descriptor. Note that if our offset is 0 that means the file name\n+            // is massive and we need a bigger buffer.\n+            if data.len() < dirent.d_namlen as usize {\n+                if offset == 0 {\n+                    let amt_to_add = self.buf.capacity();\n+                    self.buf.extend(iter::repeat(0).take(amt_to_add));\n+                }\n+                assert!(self.cookie.is_some());\n+                self.offset = self.cap;\n+                continue;\n+            }\n+            self.cookie = Some(dirent.d_next);\n+            self.offset = offset + dirent_size + dirent.d_namlen as usize;\n+\n+            let name = &data[..(dirent.d_namlen as usize)];\n+\n+            // These names are skipped on all other platforms, so let's skip\n+            // them here too\n+            if name == b\".\" || name == b\"..\" {\n+                continue;\n+            }\n+\n+            return Some(Ok(DirEntry {\n+                meta: dirent,\n+                name: name.to_vec(),\n+                inner: self.inner.clone(),\n+            }));\n+        }\n     }\n }\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        match self.0 {}\n+        let name = OsStr::from_bytes(&self.name);\n+        self.inner.root.join(name)\n     }\n \n     pub fn file_name(&self) -> OsString {\n-        match self.0 {}\n+        OsString::from_vec(self.name.clone())\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n+        metadata_at(&self.inner.dir.fd, 0, OsStr::from_bytes(&self.name).as_ref())\n     }\n \n     pub fn file_type(&self) -> io::Result<FileType> {\n-        match self.0 {}\n+        Ok(FileType {\n+            bits: self.meta.d_type,\n+        })\n+    }\n+\n+    pub fn ino(&self) -> libc::__wasi_inode_t {\n+        self.meta.d_ino\n     }\n }\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n-        OpenOptions { }\n+        let mut base = OpenOptions::default();\n+        base.dirflags = libc::__WASI_LOOKUP_SYMLINK_FOLLOW;\n+        return base;\n+    }\n+\n+    pub fn read(&mut self, read: bool) {\n+        self.read = read;\n+    }\n+\n+    pub fn write(&mut self, write: bool) {\n+        self.write = write;\n+    }\n+\n+    pub fn truncate(&mut self, truncate: bool) {\n+        self.oflag(libc::__WASI_O_TRUNC, truncate);\n+    }\n+\n+    pub fn create(&mut self, create: bool) {\n+        self.oflag(libc::__WASI_O_CREAT, create);\n+    }\n+\n+    pub fn create_new(&mut self, create_new: bool) {\n+        self.oflag(libc::__WASI_O_EXCL, create_new);\n+        self.oflag(libc::__WASI_O_CREAT, create_new);\n+    }\n+\n+    pub fn directory(&mut self, directory: bool) {\n+        self.oflag(libc::__WASI_O_DIRECTORY, directory);\n+    }\n+\n+    fn oflag(&mut self, bit: libc::__wasi_oflags_t, set: bool) {\n+        if set {\n+            self.oflags |= bit;\n+        } else {\n+            self.oflags &= !bit;\n+        }\n+    }\n+\n+    pub fn append(&mut self, set: bool) {\n+        self.fdflag(libc::__WASI_FDFLAG_APPEND, set);\n+    }\n+\n+    pub fn dsync(&mut self, set: bool) {\n+        self.fdflag(libc::__WASI_FDFLAG_DSYNC, set);\n+    }\n+\n+    pub fn nonblock(&mut self, set: bool) {\n+        self.fdflag(libc::__WASI_FDFLAG_NONBLOCK, set);\n+    }\n+\n+    pub fn rsync(&mut self, set: bool) {\n+        self.fdflag(libc::__WASI_FDFLAG_RSYNC, set);\n+    }\n+\n+    pub fn sync(&mut self, set: bool) {\n+        self.fdflag(libc::__WASI_FDFLAG_SYNC, set);\n+    }\n+\n+    fn fdflag(&mut self, bit: libc::__wasi_fdflags_t, set: bool) {\n+        if set {\n+            self.fdflags |= bit;\n+        } else {\n+            self.fdflags &= !bit;\n+        }\n+    }\n+\n+    pub fn fs_rights_base(&mut self, rights: libc::__wasi_rights_t) {\n+        self.rights_base = Some(rights);\n+    }\n+\n+    pub fn fs_rights_inheriting(&mut self, rights: libc::__wasi_rights_t) {\n+        self.rights_inheriting = Some(rights);\n+    }\n+\n+    fn rights_base(&self) -> libc::__wasi_rights_t {\n+        if let Some(rights) = self.rights_base {\n+            return rights;\n+        }\n+\n+        // If rights haven't otherwise been specified try to pick a reasonable\n+        // set. This can always be overridden by users via extension traits, and\n+        // implementations may give us fewer rights silently than we ask for. So\n+        // given that, just look at `read` and `write` and bucket permissions\n+        // based on that.\n+        let mut base = 0;\n+        if self.read {\n+            base |= libc::__WASI_RIGHT_FD_READ;\n+            base |= libc::__WASI_RIGHT_FD_READDIR;\n+        }\n+        if self.write {\n+            base |= libc::__WASI_RIGHT_FD_WRITE;\n+            base |= libc::__WASI_RIGHT_FD_DATASYNC;\n+            base |= libc::__WASI_RIGHT_FD_ALLOCATE;\n+            base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_SIZE;\n+        }\n+\n+        // FIXME: some of these should probably be read-only or write-only...\n+        base |= libc::__WASI_RIGHT_FD_ADVISE;\n+        base |= libc::__WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n+        base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_TIMES;\n+        base |= libc::__WASI_RIGHT_FD_SEEK;\n+        base |= libc::__WASI_RIGHT_FD_SYNC;\n+        base |= libc::__WASI_RIGHT_FD_TELL;\n+        base |= libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY;\n+        base |= libc::__WASI_RIGHT_PATH_CREATE_FILE;\n+        base |= libc::__WASI_RIGHT_PATH_FILESTAT_GET;\n+        base |= libc::__WASI_RIGHT_PATH_LINK_SOURCE;\n+        base |= libc::__WASI_RIGHT_PATH_LINK_TARGET;\n+        base |= libc::__WASI_RIGHT_PATH_OPEN;\n+        base |= libc::__WASI_RIGHT_PATH_READLINK;\n+        base |= libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY;\n+        base |= libc::__WASI_RIGHT_PATH_RENAME_SOURCE;\n+        base |= libc::__WASI_RIGHT_PATH_RENAME_TARGET;\n+        base |= libc::__WASI_RIGHT_PATH_SYMLINK;\n+        base |= libc::__WASI_RIGHT_PATH_UNLINK_FILE;\n+        base |= libc::__WASI_RIGHT_POLL_FD_READWRITE;\n+\n+        return base;\n     }\n \n-    pub fn read(&mut self, _read: bool) { }\n-    pub fn write(&mut self, _write: bool) { }\n-    pub fn append(&mut self, _append: bool) { }\n-    pub fn truncate(&mut self, _truncate: bool) { }\n-    pub fn create(&mut self, _create: bool) { }\n-    pub fn create_new(&mut self, _create_new: bool) { }\n+    fn rights_inheriting(&self) -> libc::__wasi_rights_t {\n+        self.rights_inheriting.unwrap_or_else(|| self.rights_base())\n+    }\n+\n+    pub fn lookup_flags(&mut self, flags: libc::__wasi_lookupflags_t) {\n+        self.dirflags = flags;\n+    }\n }\n \n impl File {\n-    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n-        unsupported()\n+    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let (dir, file) = open_parent(path)?;\n+        open_at(&dir, file, opts)\n+    }\n+\n+    pub fn open_at(&self, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        open_at(&self.fd, path, opts)\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        match self.0 {}\n+        let mut ret = FileAttr::zero();\n+        self.fd.filestat_get(&mut ret.meta)?;\n+        Ok(ret)\n+    }\n+\n+    pub fn metadata_at(\n+        &self,\n+        flags: libc::__wasi_lookupflags_t,\n+        path: &Path,\n+    ) -> io::Result<FileAttr> {\n+        metadata_at(&self.fd, flags, path)\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        match self.0 {}\n+        self.fd.sync()\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        match self.0 {}\n+        self.fd.datasync()\n+    }\n+\n+    pub fn truncate(&self, size: u64) -> io::Result<()> {\n+        self.fd.filestat_set_size(size)\n     }\n \n-    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n-        match self.0 {}\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.read_vectored(&mut [IoVecMut::new(buf)])\n     }\n \n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn read_vectored(&self, bufs: &mut [IoVecMut<'_>]) -> io::Result<usize> {\n+        self.fd.read(bufs)\n     }\n \n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.write_vectored(&[IoVec::new(buf)])\n+    }\n+\n+    pub fn write_vectored(&self, bufs: &[IoVec<'_>]) -> io::Result<usize> {\n+        self.fd.write(bufs)\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n-        match self.0 {}\n+        Ok(())\n     }\n \n-    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n-        match self.0 {}\n+    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n+        self.fd.seek(pos)\n     }\n \n     pub fn duplicate(&self) -> io::Result<File> {\n-        match self.0 {}\n+        // https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-rationale.md#why-no-dup\n+        unsupported()\n     }\n \n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n-        match self.0 {}\n+        // Permissions haven't been fully figured out in wasi yet, so this is\n+        // likely temporary\n+        unsupported()\n     }\n \n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n+    pub fn fd(&self) -> &WasiFd {\n+        &self.fd\n     }\n-}\n \n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder { }\n+    pub fn into_fd(self) -> WasiFd {\n+        self.fd\n     }\n \n-    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n-        unsupported()\n+    pub fn read_link(&self, file: &Path) -> io::Result<PathBuf> {\n+        read_link(&self.fd, file)\n     }\n }\n \n-impl fmt::Debug for File {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n+impl FromInner<u32> for File {\n+    fn from_inner(fd: u32) -> File {\n+        unsafe {\n+            File {\n+                fd: WasiFd::from_raw(fd),\n+            }\n+        }\n     }\n }\n \n-pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n-    unsupported()\n-}\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {}\n+    }\n \n-pub fn unlink(_p: &Path) -> io::Result<()> {\n-    unsupported()\n+    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n+        let (dir, file) = open_parent(p)?;\n+        dir.create_directory(file.as_os_str().as_bytes())\n+    }\n }\n \n-pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+impl fmt::Debug for File {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"File\")\n+            .field(\"fd\", &self.fd.as_raw())\n+            .finish()\n+    }\n+}\n+\n+pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n+    let mut opts = OpenOptions::new();\n+    opts.directory(true);\n+    opts.read(true);\n+    let dir = File::open(p, &opts)?;\n+    Ok(ReadDir {\n+        cookie: Some(0),\n+        buf: vec![0; 128],\n+        offset: 0,\n+        cap: 0,\n+        inner: Arc::new(ReadDirInner {\n+            dir,\n+            root: p.to_path_buf(),\n+        }),\n+    })\n+}\n+\n+pub fn unlink(p: &Path) -> io::Result<()> {\n+    let (dir, file) = open_parent(p)?;\n+    dir.unlink_file(file.as_os_str().as_bytes())\n+}\n+\n+pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n+    let (old, old_file) = open_parent(old)?;\n+    let (new, new_file) = open_parent(new)?;\n+    old.rename(\n+        old_file.as_os_str().as_bytes(),\n+        &new,\n+        new_file.as_os_str().as_bytes(),\n+    )\n+}\n+\n+pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n+    // Permissions haven't been fully figured out in wasi yet, so this is\n+    // likely temporary\n     unsupported()\n }\n \n-pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    match perm.0 {}\n+pub fn rmdir(p: &Path) -> io::Result<()> {\n+    let (dir, file) = open_parent(p)?;\n+    dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n-pub fn rmdir(_p: &Path) -> io::Result<()> {\n-    unsupported()\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    let (dir, file) = open_parent(p)?;\n+    read_link(&dir, file)\n }\n \n-pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n-    unsupported()\n+fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n+    // Try to get a best effort initial capacity for the vector we're going to\n+    // fill. Note that if it's not a symlink we don't use a file to avoid\n+    // allocating gigabytes if you read_link a huge movie file by accident.\n+    // Additionally we add 1 to the initial size so if it doesn't change until\n+    // when we call `readlink` the returned length will be less than the\n+    // capacity, guaranteeing that we got all the data.\n+    let meta = metadata_at(fd, 0, file)?;\n+    let initial_size = if meta.file_type().is_symlink() {\n+        (meta.size() as usize).saturating_add(1)\n+    } else {\n+        1 // this'll fail in just a moment\n+    };\n+\n+    // Now that we have an initial guess of how big to make our buffer, call\n+    // `readlink` in a loop until it fails or reports it filled fewer bytes than\n+    // we asked for, indicating we got everything.\n+    let file = file.as_os_str().as_bytes();\n+    let mut destination = vec![0u8; initial_size];\n+    loop {\n+        let len = fd.readlink(file, &mut destination)?;\n+        if len < destination.len() {\n+            destination.truncate(len);\n+            destination.shrink_to_fit();\n+            return Ok(PathBuf::from(OsString::from_vec(destination)));\n+        }\n+        let amt_to_add = destination.len();\n+        destination.extend(iter::repeat(0).take(amt_to_add));\n+    }\n }\n \n-pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n-    unsupported()\n+pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n+    let (dst, dst_file) = open_parent(dst)?;\n+    dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n-pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n+pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n+    let (src, src_file) = open_parent(src)?;\n+    let (dst, dst_file) = open_parent(dst)?;\n+    src.link(\n+        libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n+        src_file.as_os_str().as_bytes(),\n+        &dst,\n+        dst_file.as_os_str().as_bytes(),\n+    )\n }\n \n-pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n-    unsupported()\n+pub fn stat(p: &Path) -> io::Result<FileAttr> {\n+    let (dir, file) = open_parent(p)?;\n+    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, file)\n }\n \n-pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n+pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n+    let (dir, file) = open_parent(p)?;\n+    metadata_at(&dir, 0, file)\n }\n \n-pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n-    unsupported()\n+fn metadata_at(\n+    fd: &WasiFd,\n+    flags: libc::__wasi_lookupflags_t,\n+    path: &Path,\n+) -> io::Result<FileAttr> {\n+    let mut ret = FileAttr::zero();\n+    fd.path_filestat_get(flags, path.as_os_str().as_bytes(), &mut ret.meta)?;\n+    Ok(ret)\n }\n \n pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    // This seems to not be in wasi's API yet, and we may need to end up\n+    // emulating it ourselves. For now just return an error.\n     unsupported()\n }\n \n-pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n-    unsupported()\n+fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+    let fd = fd.open(\n+        opts.dirflags,\n+        path.as_os_str().as_bytes(),\n+        opts.oflags,\n+        opts.rights_base(),\n+        opts.rights_inheriting(),\n+        opts.fdflags,\n+    )?;\n+    Ok(File { fd })\n+}\n+\n+// FIXME: we shouldn't implement this. It'd be much better to share this between\n+// libc (the wasi-sysroot) and Rust as the logic here is likely far more tricky\n+// than what we're executing below. For now this is a stopgap to enable this\n+// module, but we should add an official API in upstream wasi-libc which looks\n+// like this.\n+//\n+// In the meantime this is highly unlikely to be correct. It allows some basic\n+// testing but is not at all robust.\n+fn open_parent(p: &Path) -> io::Result<(&'static WasiFd, &Path)> {\n+    let map = preopened_map();\n+    for ancestor in p.ancestors() {\n+        if let Some(fd) = map.get(ancestor) {\n+            let tail = p.strip_prefix(ancestor).unwrap();\n+            let tail = if tail == Path::new(\"\") {\n+                \".\".as_ref()\n+            } else {\n+                tail\n+            };\n+            return Ok((fd, tail))\n+        }\n+    }\n+    let msg = format!(\"failed to find a preopened file descriptor to open {:?}\", p);\n+    return Err(io::Error::new(io::ErrorKind::Other, msg));\n+\n+    type Preopened = HashMap<PathBuf, ManuallyDrop<WasiFd>>;\n+    fn preopened_map() -> &'static Preopened {\n+        static PTR: AtomicPtr<Preopened> = AtomicPtr::new(ptr::null_mut());\n+        unsafe {\n+            let ptr = PTR.load(SeqCst);\n+            if !ptr.is_null() {\n+                return &*ptr;\n+            }\n+\n+            let mut map = Box::new(HashMap::new());\n+            for fd in 3.. {\n+                let mut buf = mem::zeroed();\n+                if cvt_wasi(libc::__wasi_fd_prestat_get(fd, &mut buf)).is_err() {\n+                    break;\n+                }\n+                if buf.pr_type != libc::__WASI_PREOPENTYPE_DIR {\n+                    continue;\n+                }\n+                let len = buf.u.dir.pr_name_len;\n+                let mut v = vec![0u8; len];\n+                let res = cvt_wasi(libc::__wasi_fd_prestat_dir_name(\n+                    fd,\n+                    v.as_mut_ptr() as *mut i8,\n+                    v.len(),\n+                ));\n+                if res.is_err() {\n+                    continue;\n+                }\n+                let path = PathBuf::from(OsString::from_vec(v));\n+                map.insert(path, ManuallyDrop::new(WasiFd::from_raw(fd)));\n+            }\n+            let ptr = Box::into_raw(map);\n+            match PTR.compare_exchange(ptr::null_mut(), ptr, SeqCst, SeqCst) {\n+                Ok(_) => &*ptr,\n+\n+                // If we lost the race for initialization clean up the map we\n+                // made and just use the one that's already there\n+                Err(other) => {\n+                    drop(Box::from_raw(ptr));\n+                    &*other\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "822ea02a11b8923d0fd7ada3b9aaceeceee827e2", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -27,8 +27,21 @@ pub fn errno() -> i32 {\n     unsafe { errno as i32 }\n }\n \n-pub fn error_string(_errno: i32) -> String {\n-    \"operation failed\".to_string()\n+pub fn error_string(errno: i32) -> String {\n+    extern {\n+        fn strerror_r(errnum: libc::c_int, buf: *mut libc::c_char,\n+                      buflen: libc::size_t) -> libc::c_int;\n+    }\n+\n+    let mut buf = [0 as libc::c_char; 1024];\n+\n+    let p = buf.as_mut_ptr();\n+    unsafe {\n+        if strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n+            panic!(\"strerror_r failure\");\n+        }\n+        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n+    }\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {"}, {"sha": "788b829f4bac99a02055fda444d5161b74f649d3", "filename": "src/libstd/sys/wasi/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fprocess.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -67,8 +67,8 @@ impl From<AnonPipe> for Stdio {\n }\n \n impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n+    fn from(_file: File) -> Stdio {\n+        panic!(\"unsupported\")\n     }\n }\n "}, {"sha": "192947886668f64457e2598cb3dd3eeaf42b2ee6", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -1,6 +1,7 @@\n-use crate::io;\n+use crate::io::{self, IoVec, IoVecMut};\n use crate::libc;\n-use crate::sys::cvt;\n+use crate::mem::ManuallyDrop;\n+use crate::sys::fd::WasiFd;\n \n pub struct Stdin;\n pub struct Stdout;\n@@ -12,10 +13,8 @@ impl Stdin {\n     }\n \n     pub fn read(&self, data: &mut [u8]) -> io::Result<usize> {\n-        let amt = cvt(unsafe {\n-            libc::read(libc::STDIN_FILENO, data.as_mut_ptr() as *mut _, data.len())\n-        })?;\n-        Ok(amt as usize)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+            .read(&mut [IoVecMut::new(data)])\n     }\n }\n \n@@ -25,10 +24,8 @@ impl Stdout {\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        let amt = cvt(unsafe {\n-            libc::write(libc::STDOUT_FILENO, data.as_ptr() as *const _, data.len())\n-        })?;\n-        Ok(amt as usize)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDOUT_FILENO as u32) })\n+            .write(&[IoVec::new(data)])\n     }\n \n     pub fn flush(&self) -> io::Result<()> {\n@@ -42,10 +39,8 @@ impl Stderr {\n     }\n \n     pub fn write(&self, data: &[u8]) -> io::Result<usize> {\n-        let amt = cvt(unsafe {\n-            libc::write(libc::STDERR_FILENO, data.as_ptr() as *const _, data.len())\n-        })?;\n-        Ok(amt as usize)\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDERR_FILENO as u32) })\n+            .write(&[IoVec::new(data)])\n     }\n \n     pub fn flush(&self) -> io::Result<()> {"}, {"sha": "3f14c80928c67a9e6ff4ebb8601e903fb0edf263", "filename": "src/libstd/sys/wasi/time.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -57,6 +57,10 @@ impl SystemTime {\n         SystemTime(current_time(libc::__WASI_CLOCK_REALTIME))\n     }\n \n+    pub fn from_wasi_timestamp(ts: libc::__wasi_timestamp_t) -> SystemTime {\n+        SystemTime(Duration::from_nanos(ts))\n+    }\n+\n     pub fn sub_time(&self, other: &SystemTime)\n                     -> Result<Duration, Duration> {\n         self.0.checked_sub(other.0).ok_or_else(|| other.0 - self.0)"}, {"sha": "7152fcd215c9aa2fb3b27f643e4b7ec0b8b41f85", "filename": "src/libstd/sys_common/fs.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys_common%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys_common%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Ffs.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -0,0 +1,41 @@\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::path::Path;\n+use crate::fs;\n+use crate::io::{self, Error, ErrorKind};\n+\n+pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    if !from.is_file() {\n+        return Err(Error::new(ErrorKind::InvalidInput,\n+                              \"the source path is not an existing regular file\"))\n+    }\n+\n+    let mut reader = fs::File::open(from)?;\n+    let mut writer = fs::File::create(to)?;\n+    let perm = reader.metadata()?.permissions();\n+\n+    let ret = io::copy(&mut reader, &mut writer)?;\n+    fs::set_permissions(to, perm)?;\n+    Ok(ret)\n+}\n+\n+pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n+    let filetype = fs::symlink_metadata(path)?.file_type();\n+    if filetype.is_symlink() {\n+        fs::remove_file(path)\n+    } else {\n+        remove_dir_all_recursive(path)\n+    }\n+}\n+\n+fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n+    for child in fs::read_dir(path)? {\n+        let child = child?;\n+        if child.file_type()?.is_dir() {\n+            remove_dir_all_recursive(&child.path())?;\n+        } else {\n+            fs::remove_file(&child.path())?;\n+        }\n+    }\n+    fs::remove_dir(path)\n+}"}, {"sha": "6260c3b77ff81227bf2c52b750f1e21801eca202", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d065712cf96328093400fd0a1a0c4e0f3b1d51c/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=2d065712cf96328093400fd0a1a0c4e0f3b1d51c", "patch": "@@ -61,6 +61,7 @@ pub mod util;\n pub mod wtf8;\n pub mod bytestring;\n pub mod process;\n+pub mod fs;\n \n cfg_if! {\n     if #[cfg(any(target_os = \"cloudabi\","}]}