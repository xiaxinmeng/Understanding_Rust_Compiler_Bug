{"sha": "6bca91af532d79abbced5b151cb4188ff8625c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiY2E5MWFmNTMyZDc5YWJiY2VkNWIxNTFjYjQxODhmZjg2MjVjMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T19:30:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-08T19:30:56Z"}, "message": "rename ra_analysis -> ra_ide_api", "tree": {"sha": "6f61b6358bb99925adf71ade2ecb12e38e4ef51f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f61b6358bb99925adf71ade2ecb12e38e4ef51f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bca91af532d79abbced5b151cb4188ff8625c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bca91af532d79abbced5b151cb4188ff8625c04", "html_url": "https://github.com/rust-lang/rust/commit/6bca91af532d79abbced5b151cb4188ff8625c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bca91af532d79abbced5b151cb4188ff8625c04/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "html_url": "https://github.com/rust-lang/rust/commit/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5"}], "stats": {"total": 4249, "additions": 0, "deletions": 4249}, "files": [{"sha": "3c08142795c3355f92a4fedff2ab0a00b016af71", "filename": "crates/ra_analysis/Cargo.toml", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2FCargo.toml?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,23 +0,0 @@\n-[package]\n-edition = \"2018\"\n-name = \"ra_analysis\"\n-version = \"0.1.0\"\n-authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n-\n-[dependencies]\n-itertools = \"0.8.0\"\n-log = \"0.4.5\"\n-relative-path = \"0.4.0\"\n-rayon = \"1.0.2\"\n-fst = \"0.3.1\"\n-salsa = \"0.9.1\"\n-rustc-hash = \"1.0\"\n-parking_lot = \"0.7.0\"\n-unicase = \"2.2.0\"\n-\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_ide_api_light = { path = \"../ra_ide_api_light\" }\n-ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_db = { path = \"../ra_db\" }\n-hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n-test_utils = { path = \"../test_utils\" }"}, {"sha": "27b760780ca8f91dc6431c6dba829a46118d9476", "filename": "crates/ra_analysis/src/call_info.rs", "status": "removed", "additions": 0, "deletions": 451, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcall_info.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,451 +0,0 @@\n-use std::cmp::{max, min};\n-\n-use ra_db::{SyntaxDatabase, Cancelable};\n-use ra_syntax::{\n-    AstNode, SyntaxNode, TextUnit, TextRange,\n-    SyntaxKind::FN_DEF,\n-    ast::{self, ArgListOwner, DocCommentsOwner},\n-    algo::find_node_at_offset,\n-};\n-\n-use crate::{FilePosition, CallInfo, db::RootDatabase};\n-\n-/// Computes parameter information for the given call expression.\n-pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n-    let file = db.source_file(position.file_id);\n-    let syntax = file.syntax();\n-\n-    // Find the calling expression and it's NameRef\n-    let calling_node = ctry!(FnCallNode::with_node(syntax, position.offset));\n-    let name_ref = ctry!(calling_node.name_ref());\n-\n-    // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n-    let file_symbols = db.index_resolve(name_ref)?;\n-    let symbol = ctry!(file_symbols.into_iter().find(|it| it.ptr.kind() == FN_DEF));\n-    let fn_file = db.source_file(symbol.file_id);\n-    let fn_def = symbol.ptr.resolve(&fn_file);\n-    let fn_def = ast::FnDef::cast(&fn_def).unwrap();\n-    let mut call_info = ctry!(CallInfo::new(fn_def));\n-    // If we have a calling expression let's find which argument we are on\n-    let num_params = call_info.parameters.len();\n-    let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n-\n-    if num_params == 1 {\n-        if !has_self {\n-            call_info.active_parameter = Some(0);\n-        }\n-    } else if num_params > 1 {\n-        // Count how many parameters into the call we are.\n-        // TODO: This is best effort for now and should be fixed at some point.\n-        // It may be better to see where we are in the arg_list and then check\n-        // where offset is in that list (or beyond).\n-        // Revisit this after we get documentation comments in.\n-        if let Some(ref arg_list) = calling_node.arg_list() {\n-            let start = arg_list.syntax().range().start();\n-\n-            let range_search = TextRange::from_to(start, position.offset);\n-            let mut commas: usize = arg_list\n-                .syntax()\n-                .text()\n-                .slice(range_search)\n-                .to_string()\n-                .matches(',')\n-                .count();\n-\n-            // If we have a method call eat the first param since it's just self.\n-            if has_self {\n-                commas += 1;\n-            }\n-\n-            call_info.active_parameter = Some(commas);\n-        }\n-    }\n-\n-    Ok(Some(call_info))\n-}\n-\n-enum FnCallNode<'a> {\n-    CallExpr(&'a ast::CallExpr),\n-    MethodCallExpr(&'a ast::MethodCallExpr),\n-}\n-\n-impl<'a> FnCallNode<'a> {\n-    pub fn with_node(syntax: &'a SyntaxNode, offset: TextUnit) -> Option<FnCallNode<'a>> {\n-        if let Some(expr) = find_node_at_offset::<ast::CallExpr>(syntax, offset) {\n-            return Some(FnCallNode::CallExpr(expr));\n-        }\n-        if let Some(expr) = find_node_at_offset::<ast::MethodCallExpr>(syntax, offset) {\n-            return Some(FnCallNode::MethodCallExpr(expr));\n-        }\n-        None\n-    }\n-\n-    pub fn name_ref(&self) -> Option<&'a ast::NameRef> {\n-        match *self {\n-            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()?.kind() {\n-                ast::ExprKind::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n-                _ => return None,\n-            }),\n-\n-            FnCallNode::MethodCallExpr(call_expr) => call_expr\n-                .syntax()\n-                .children()\n-                .filter_map(ast::NameRef::cast)\n-                .nth(0),\n-        }\n-    }\n-\n-    pub fn arg_list(&self) -> Option<&'a ast::ArgList> {\n-        match *self {\n-            FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n-        }\n-    }\n-}\n-\n-impl CallInfo {\n-    fn new(node: &ast::FnDef) -> Option<Self> {\n-        let mut doc = None;\n-\n-        // Strip the body out for the label.\n-        let mut label: String = if let Some(body) = node.body() {\n-            let body_range = body.syntax().range();\n-            let label: String = node\n-                .syntax()\n-                .children()\n-                .filter(|child| !child.range().is_subrange(&body_range))\n-                .map(|node| node.text().to_string())\n-                .collect();\n-            label\n-        } else {\n-            node.syntax().text().to_string()\n-        };\n-\n-        if let Some((comment_range, docs)) = extract_doc_comments(node) {\n-            let comment_range = comment_range\n-                .checked_sub(node.syntax().range().start())\n-                .unwrap();\n-            let start = comment_range.start().to_usize();\n-            let end = comment_range.end().to_usize();\n-\n-            // Remove the comment from the label\n-            label.replace_range(start..end, \"\");\n-\n-            // Massage markdown\n-            let mut processed_lines = Vec::new();\n-            let mut in_code_block = false;\n-            for line in docs.lines() {\n-                if line.starts_with(\"```\") {\n-                    in_code_block = !in_code_block;\n-                }\n-\n-                let line = if in_code_block && line.starts_with(\"```\") && !line.contains(\"rust\") {\n-                    \"```rust\".into()\n-                } else {\n-                    line.to_string()\n-                };\n-\n-                processed_lines.push(line);\n-            }\n-\n-            if !processed_lines.is_empty() {\n-                doc = Some(processed_lines.join(\"\\n\"));\n-            }\n-        }\n-\n-        Some(CallInfo {\n-            parameters: param_list(node),\n-            label: label.trim().to_owned(),\n-            doc,\n-            active_parameter: None,\n-        })\n-    }\n-}\n-\n-fn extract_doc_comments(node: &ast::FnDef) -> Option<(TextRange, String)> {\n-    if node.doc_comments().count() == 0 {\n-        return None;\n-    }\n-\n-    let comment_text = node.doc_comment_text();\n-\n-    let (begin, end) = node\n-        .doc_comments()\n-        .map(|comment| comment.syntax().range())\n-        .map(|range| (range.start().to_usize(), range.end().to_usize()))\n-        .fold((std::usize::MAX, std::usize::MIN), |acc, range| {\n-            (min(acc.0, range.0), max(acc.1, range.1))\n-        });\n-\n-    let range = TextRange::from_to(TextUnit::from_usize(begin), TextUnit::from_usize(end));\n-\n-    Some((range, comment_text))\n-}\n-\n-fn param_list(node: &ast::FnDef) -> Vec<String> {\n-    let mut res = vec![];\n-    if let Some(param_list) = node.param_list() {\n-        if let Some(self_param) = param_list.self_param() {\n-            res.push(self_param.syntax().text().to_string())\n-        }\n-\n-        // Maybe use param.pat here? See if we can just extract the name?\n-        //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-        res.extend(\n-            param_list\n-                .params()\n-                .filter_map(|p| p.pat())\n-                .map(|pat| pat.syntax().text().to_string()),\n-        );\n-    }\n-    res\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use crate::mock_analysis::single_file_with_position;\n-\n-    fn call_info(text: &str) -> CallInfo {\n-        let (analysis, position) = single_file_with_position(text);\n-        analysis.call_info(position).unwrap().unwrap()\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_first() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n-        assert_eq!(info.active_parameter, Some(0));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_two_args_second() {\n-        let info = call_info(\n-            r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec!(\"x\".to_string(), \"y\".to_string()));\n-        assert_eq!(info.active_parameter, Some(1));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_impl() {\n-        let info = call_info(\n-            r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#,\n-        );\n-\n-        assert_eq!(info.parameters, Vec::<String>::new());\n-        assert_eq!(info.active_parameter, None);\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_self() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec![\"&self\".to_string()]);\n-        assert_eq!(info.active_parameter, None);\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_for_method_with_arg() {\n-        let info = call_info(\n-            r#\"struct F;\n-impl F {\n-    pub fn new() -> F{\n-        F{}\n-    }\n-\n-    pub fn do_it(&self, x: i32) {}\n-}\n-\n-fn bar() {\n-    let f : F = F::new();\n-    f.do_it(<|>);\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec![\"&self\".to_string(), \"x\".to_string()]);\n-        assert_eq!(info.active_parameter, Some(1));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_simple() {\n-        let info = call_info(\n-            r#\"\n-/// test\n-// non-doc-comment\n-fn foo(j: u32) -> u32 {\n-    j\n-}\n-\n-fn bar() {\n-    let _ = foo(<|>);\n-}\n-\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec![\"j\".to_string()]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label, \"fn foo(j: u32) -> u32\".to_string());\n-        assert_eq!(info.doc, Some(\"test\".into()));\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs() {\n-        let info = call_info(\n-            r#\"\n-/// Adds one to the number given.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// let five = 5;\n-///\n-/// assert_eq!(6, my_crate::add_one(5));\n-/// ```\n-pub fn add_one(x: i32) -> i32 {\n-    x + 1\n-}\n-\n-pub fn do() {\n-    add_one(<|>\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-        assert_eq!(\n-            info.doc,\n-            Some(\n-                r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .into()\n-            )\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_impl() {\n-        let info = call_info(\n-            r#\"\n-struct addr;\n-impl addr {\n-    /// Adds one to the number given.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let five = 5;\n-    ///\n-    /// assert_eq!(6, my_crate::add_one(5));\n-    /// ```\n-    pub fn add_one(x: i32) -> i32 {\n-        x + 1\n-    }\n-}\n-\n-pub fn do_it() {\n-    addr {};\n-    addr::add_one(<|>);\n-}\"#,\n-        );\n-\n-        assert_eq!(info.parameters, vec![\"x\".to_string()]);\n-        assert_eq!(info.active_parameter, Some(0));\n-        assert_eq!(info.label, \"pub fn add_one(x: i32) -> i32\".to_string());\n-        assert_eq!(\n-            info.doc,\n-            Some(\n-                r#\"Adds one to the number given.\n-\n-# Examples\n-\n-```rust\n-let five = 5;\n-\n-assert_eq!(6, my_crate::add_one(5));\n-```\"#\n-                    .into()\n-            )\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fn_signature_with_docs_from_actix() {\n-        let info = call_info(\n-            r#\"\n-pub trait WriteHandler<E>\n-where\n-    Self: Actor,\n-    Self::Context: ActorContext,\n-{\n-    /// Method is called when writer emits error.\n-    ///\n-    /// If this method returns `ErrorAction::Continue` writer processing\n-    /// continues otherwise stream processing stops.\n-    fn error(&mut self, err: E, ctx: &mut Self::Context) -> Running {\n-        Running::Stop\n-    }\n-\n-    /// Method is called when writer finishes.\n-    ///\n-    /// By default this method stops actor's `Context`.\n-    fn finished(&mut self, ctx: &mut Self::Context) {\n-        ctx.stop()\n-    }\n-}\n-\n-pub fn foo() {\n-    WriteHandler r;\n-    r.finished(<|>);\n-}\n-\n-\"#,\n-        );\n-\n-        assert_eq!(\n-            info.parameters,\n-            vec![\"&mut self\".to_string(), \"ctx\".to_string()]\n-        );\n-        assert_eq!(info.active_parameter, Some(1));\n-        assert_eq!(\n-            info.doc,\n-            Some(\n-                r#\"Method is called when writer finishes.\n-\n-By default this method stops actor's `Context`.\"#\n-                    .into()\n-            )\n-        );\n-    }\n-\n-}"}, {"sha": "ce777a771e2e1a1c968b4a432311cca1b712d095", "filename": "crates/ra_analysis/src/completion.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,77 +0,0 @@\n-mod completion_item;\n-mod completion_context;\n-\n-mod complete_dot;\n-mod complete_fn_param;\n-mod complete_keyword;\n-mod complete_snippet;\n-mod complete_path;\n-mod complete_scope;\n-\n-use ra_db::SyntaxDatabase;\n-\n-use crate::{\n-    db,\n-    Cancelable, FilePosition,\n-    completion::{\n-        completion_item::{Completions, CompletionKind},\n-        completion_context::CompletionContext,\n-    },\n-};\n-\n-pub use crate::completion::completion_item::{CompletionItem, InsertText, CompletionItemKind};\n-\n-/// Main entry point for completion. We run completion as a two-phase process.\n-///\n-/// First, we look at the position and collect a so-called `CompletionContext.\n-/// This is a somewhat messy process, because, during completion, syntax tree is\n-/// incomplete and can look really weird.\n-///\n-/// Once the context is collected, we run a series of completion routines which\n-/// look at the context and produce completion items. One subtelty about this\n-/// phase is that completion engine should not filter by the substring which is\n-/// already present, it should give all possible variants for the identifier at\n-/// the caret. In other words, for\n-///\n-/// ```no-run\n-/// fn f() {\n-///     let foo = 92;\n-///     let _ = bar<|>\n-/// }\n-/// ```\n-///\n-/// `foo` *should* be present among the completion variants. Filtering by\n-/// identifier prefix/fuzzy match should be done higher in the stack, together\n-/// with ordering of completions (currently this is done by the client).\n-pub(crate) fn completions(\n-    db: &db::RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<Completions>> {\n-    let original_file = db.source_file(position.file_id);\n-    let ctx = ctry!(CompletionContext::new(db, &original_file, position)?);\n-\n-    let mut acc = Completions::default();\n-\n-    complete_fn_param::complete_fn_param(&mut acc, &ctx);\n-    complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n-    complete_keyword::complete_use_tree_keyword(&mut acc, &ctx);\n-    complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n-    complete_snippet::complete_item_snippet(&mut acc, &ctx);\n-    complete_path::complete_path(&mut acc, &ctx)?;\n-    complete_scope::complete_scope(&mut acc, &ctx)?;\n-    complete_dot::complete_dot(&mut acc, &ctx)?;\n-\n-    Ok(Some(acc))\n-}\n-\n-#[cfg(test)]\n-fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind) {\n-    use crate::mock_analysis::{single_file_with_position, analysis_and_position};\n-    let (analysis, position) = if code.contains(\"//-\") {\n-        analysis_and_position(code)\n-    } else {\n-        single_file_with_position(code)\n-    };\n-    let completions = completions(&analysis.db, position).unwrap().unwrap();\n-    completions.assert_match(expected_completions, kind);\n-}"}, {"sha": "5d4e60dc525c40c39ad415da5d2bd58b3c0e44f9", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,121 +0,0 @@\n-use hir::{Ty, Def};\n-\n-use crate::Cancelable;\n-use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem, CompletionItemKind};\n-\n-/// Complete dot accesses, i.e. fields or methods (currently only fields).\n-pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n-    let (function, receiver) = match (&ctx.function, ctx.dot_receiver) {\n-        (Some(function), Some(receiver)) => (function, receiver),\n-        _ => return Ok(()),\n-    };\n-    let infer_result = function.infer(ctx.db)?;\n-    let syntax_mapping = function.body_syntax_mapping(ctx.db)?;\n-    let expr = match syntax_mapping.node_expr(receiver) {\n-        Some(expr) => expr,\n-        None => return Ok(()),\n-    };\n-    let receiver_ty = infer_result[expr].clone();\n-    if !ctx.is_method_call {\n-        complete_fields(acc, ctx, receiver_ty)?;\n-    }\n-    Ok(())\n-}\n-\n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n-    for receiver in receiver.autoderef(ctx.db) {\n-        match receiver {\n-            Ty::Adt { def_id, .. } => {\n-                match def_id.resolve(ctx.db)? {\n-                    Def::Struct(s) => {\n-                        let variant_data = s.variant_data(ctx.db)?;\n-                        for field in variant_data.fields() {\n-                            CompletionItem::new(\n-                                CompletionKind::Reference,\n-                                field.name().to_string(),\n-                            )\n-                            .kind(CompletionItemKind::Field)\n-                            .add_to(acc);\n-                        }\n-                    }\n-                    // TODO unions\n-                    _ => {}\n-                }\n-            }\n-            Ty::Tuple(fields) => {\n-                for (i, _ty) in fields.iter().enumerate() {\n-                    CompletionItem::new(CompletionKind::Reference, i.to_string())\n-                        .kind(CompletionItemKind::Field)\n-                        .add_to(acc);\n-                }\n-            }\n-            _ => {}\n-        };\n-    }\n-    Ok(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::*;\n-\n-    fn check_ref_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Reference);\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion() {\n-        check_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            r#\"the_field\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_self() {\n-        check_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            impl A {\n-                fn foo(self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-            r#\"the_field\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_autoderef() {\n-        check_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            impl A {\n-                fn foo(&self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-            r#\"the_field\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_no_struct_field_completion_for_method_call() {\n-        check_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo(a: A) {\n-               a.<|>()\n-            }\n-            \",\n-            r#\"\"#,\n-        );\n-    }\n-}"}, {"sha": "c1739e47eab5f04673ce5db26bdb28b0ac6fcd1a", "filename": "crates/ra_analysis/src/completion/complete_fn_param.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,102 +0,0 @@\n-use ra_syntax::{\n-    algo::visit::{visitor_ctx, VisitorCtx},\n-    ast,\n-    AstNode,\n-};\n-use rustc_hash::FxHashMap;\n-\n-use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem};\n-\n-/// Complete repeated parametes, both name and type. For example, if all\n-/// functions in a file have a `spam: &mut Spam` parameter, a completion with\n-/// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n-/// suggested.\n-pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_param {\n-        return;\n-    }\n-\n-    let mut params = FxHashMap::default();\n-    for node in ctx.leaf.ancestors() {\n-        let _ = visitor_ctx(&mut params)\n-            .visit::<ast::SourceFile, _>(process)\n-            .visit::<ast::ItemList, _>(process)\n-            .accept(node);\n-    }\n-    params\n-        .into_iter()\n-        .filter_map(|(label, (count, param))| {\n-            let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 {\n-                None\n-            } else {\n-                Some((label, lookup))\n-            }\n-        })\n-        .for_each(|(label, lookup)| {\n-            CompletionItem::new(CompletionKind::Magic, label)\n-                .lookup_by(lookup)\n-                .add_to(acc)\n-        });\n-\n-    fn process<'a, N: ast::FnDefOwner>(\n-        node: &'a N,\n-        params: &mut FxHashMap<String, (u32, &'a ast::Param)>,\n-    ) {\n-        node.functions()\n-            .filter_map(|it| it.param_list())\n-            .flat_map(|it| it.params())\n-            .for_each(|param| {\n-                let text = param.syntax().text().to_string();\n-                params.entry(text).or_insert((0, param)).0 += 1;\n-            })\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::*;\n-\n-    fn check_magic_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Magic);\n-    }\n-\n-    #[test]\n-    fn test_param_completion_last_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_nth_param() {\n-        check_magic_completion(\n-            r\"\n-            fn foo(file_id: FileId) {}\n-            fn bar(file_id: FileId) {}\n-            fn baz(file<|>, x: i32) {}\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_param_completion_trait_param() {\n-        check_magic_completion(\n-            r\"\n-            pub(crate) trait SourceRoot {\n-                pub fn contains(&self, file_id: FileId) -> bool;\n-                pub fn module_map(&self) -> &ModuleMap;\n-                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n-                pub fn syntax(&self, file<|>)\n-            }\n-            \",\n-            r#\"file_id \"file_id: FileId\"\"#,\n-        );\n-    }\n-}"}, {"sha": "d350f06ceb60f2551cff11f6cb8932e040edc925", "filename": "crates/ra_analysis/src/completion/complete_keyword.rs", "status": "removed", "additions": 0, "deletions": 339, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,339 +0,0 @@\n-use ra_syntax::{\n-    algo::visit::{visitor, Visitor},\n-    AstNode,\n-    ast::{self, LoopBodyOwner},\n-    SyntaxKind::*, SyntaxNode,\n-};\n-\n-use crate::completion::{CompletionContext, CompletionItem, Completions, CompletionKind, CompletionItemKind};\n-\n-pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    // complete keyword \"crate\" in use stmt\n-    match (ctx.use_item_syntax.as_ref(), ctx.path_prefix.as_ref()) {\n-        (Some(_), None) => {\n-            CompletionItem::new(CompletionKind::Keyword, \"crate\")\n-                .kind(CompletionItemKind::Keyword)\n-                .lookup_by(\"crate\")\n-                .snippet(\"crate::\")\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .lookup_by(\"self\")\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, \"super\")\n-                .kind(CompletionItemKind::Keyword)\n-                .lookup_by(\"super\")\n-                .add_to(acc);\n-        }\n-        (Some(_), Some(_)) => {\n-            CompletionItem::new(CompletionKind::Keyword, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .lookup_by(\"self\")\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, \"super\")\n-                .kind(CompletionItemKind::Keyword)\n-                .lookup_by(\"super\")\n-                .add_to(acc);\n-        }\n-        _ => {}\n-    }\n-}\n-\n-fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n-    CompletionItem::new(CompletionKind::Keyword, kw)\n-        .kind(CompletionItemKind::Keyword)\n-        .snippet(snippet)\n-        .build()\n-}\n-\n-pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path {\n-        return;\n-    }\n-\n-    let fn_def = match ctx.function_syntax {\n-        Some(it) => it,\n-        None => return,\n-    };\n-    acc.add(keyword(\"if\", \"if $0 {}\"));\n-    acc.add(keyword(\"match\", \"match $0 {}\"));\n-    acc.add(keyword(\"while\", \"while $0 {}\"));\n-    acc.add(keyword(\"loop\", \"loop {$0}\"));\n-\n-    if ctx.after_if {\n-        acc.add(keyword(\"else\", \"else {$0}\"));\n-        acc.add(keyword(\"else if\", \"else if $0 {}\"));\n-    }\n-    if is_in_loop_body(ctx.leaf) {\n-        if ctx.can_be_stmt {\n-            acc.add(keyword(\"continue\", \"continue;\"));\n-            acc.add(keyword(\"break\", \"break;\"));\n-        } else {\n-            acc.add(keyword(\"continue\", \"continue\"));\n-            acc.add(keyword(\"break\", \"break\"));\n-        }\n-    }\n-    acc.add_all(complete_return(fn_def, ctx.can_be_stmt));\n-}\n-\n-fn is_in_loop_body(leaf: &SyntaxNode) -> bool {\n-    for node in leaf.ancestors() {\n-        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n-            break;\n-        }\n-        let loop_body = visitor()\n-            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n-            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n-            .accept(node);\n-        if let Some(Some(body)) = loop_body {\n-            if leaf.range().is_subrange(&body.syntax().range()) {\n-                return true;\n-            }\n-        }\n-    }\n-    false\n-}\n-\n-fn complete_return(fn_def: &ast::FnDef, can_be_stmt: bool) -> Option<CompletionItem> {\n-    let snip = match (can_be_stmt, fn_def.ret_type().is_some()) {\n-        (true, true) => \"return $0;\",\n-        (true, false) => \"return;\",\n-        (false, true) => \"return $0\",\n-        (false, false) => \"return\",\n-    };\n-    Some(keyword(\"return\", snip))\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-    fn check_keyword_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Keyword);\n-    }\n-\n-    #[test]\n-    fn completes_keywords_in_use_stmt() {\n-        check_keyword_completion(\n-            r\"\n-            use <|>\n-            \",\n-            r#\"\n-            crate \"crate\" \"crate::\"\n-            self \"self\"\n-            super \"super\"\n-            \"#,\n-        );\n-\n-        check_keyword_completion(\n-            r\"\n-            use a::<|>\n-            \",\n-            r#\"\n-            self \"self\"\n-            super \"super\"\n-            \"#,\n-        );\n-\n-        check_keyword_completion(\n-            r\"\n-            use a::{b, <|>}\n-            \",\n-            r#\"\n-            self \"self\"\n-            super \"super\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_various_keywords_in_function() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_else_after_if() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            else \"else {$0}\"\n-            else if \"else if $0 {}\"\n-            return \"return;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_add_semi_after_return_if_not_a_statement() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn last_return_in_block_has_semi() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                if condition {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                if condition {\n-                    <|>\n-                }\n-                let x = 92;\n-                x\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_break_and_continue_in_loops() {\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            continue \"continue;\"\n-            break \"break;\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-        // No completion: lambda isolates control flow\n-        check_keyword_completion(\n-            r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            return \"return $0;\"\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_semi_after_break_continue_in_expr() {\n-        check_keyword_completion(\n-            r\"\n-            fn f() {\n-                loop {\n-                    match () {\n-                        () => br<|>\n-                    }\n-                }\n-            }\n-            \",\n-            r#\"\n-            if \"if $0 {}\"\n-            match \"match $0 {}\"\n-            while \"while $0 {}\"\n-            loop \"loop {$0}\"\n-            continue \"continue\"\n-            break \"break\"\n-            return \"return\"\n-            \"#,\n-        )\n-    }\n-}"}, {"sha": "4723a65a6b0645f197233ab397b7001fce944fb7", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,128 +0,0 @@\n-use crate::{\n-    Cancelable,\n-    completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n-};\n-\n-pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n-    let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n-        (Some(path), Some(module)) => (path.clone(), module),\n-        _ => return Ok(()),\n-    };\n-    let def_id = match module.resolve_path(ctx.db, &path)?.take_types() {\n-        Some(it) => it,\n-        None => return Ok(()),\n-    };\n-    match def_id.resolve(ctx.db)? {\n-        hir::Def::Module(module) => {\n-            let module_scope = module.scope(ctx.db)?;\n-            module_scope.entries().for_each(|(name, res)| {\n-                CompletionItem::new(CompletionKind::Reference, name.to_string())\n-                    .from_resolution(ctx, res)\n-                    .add_to(acc)\n-            });\n-        }\n-        hir::Def::Enum(e) => e\n-            .variants(ctx.db)?\n-            .into_iter()\n-            .for_each(|(name, _variant)| {\n-                CompletionItem::new(CompletionKind::Reference, name.to_string())\n-                    .kind(CompletionItemKind::EnumVariant)\n-                    .add_to(acc)\n-            }),\n-        _ => return Ok(()),\n-    };\n-    Ok(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-\n-    fn check_reference_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Reference);\n-    }\n-\n-    #[test]\n-    fn completes_use_item_starting_with_self() {\n-        check_reference_completion(\n-            r\"\n-            use self::m::<|>;\n-\n-            mod m {\n-                struct Bar;\n-            }\n-            \",\n-            \"Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_use_item_starting_with_crate() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::Sp<|>\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_nested_use_tree() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::{Sp<|>};\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_deeply_nested_use_tree() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            pub mod bar {\n-                pub mod baz {\n-                    pub struct Spam;\n-                }\n-            }\n-            //- /foo.rs\n-            use crate::{bar::{baz::Sp<|>}};\n-            \",\n-            \"Spam\",\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_enum_variant() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            enum E { Foo, Bar(i32) }\n-            fn foo() { let _ = E::<|> }\n-            \",\n-            \"Foo;Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_render_function_parens_in_use_item() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod m { pub fn foo() {} }\n-            use crate::m::f<|>;\n-            \",\n-            \"foo\",\n-        )\n-    }\n-}"}, {"sha": "ee9052d3d5d558231fcdec776da826c4e2306ec2", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,192 +0,0 @@\n-use rustc_hash::FxHashSet;\n-use ra_syntax::TextUnit;\n-\n-use crate::{\n-    Cancelable,\n-    completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n-};\n-\n-pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n-    if !ctx.is_trivial_path {\n-        return Ok(());\n-    }\n-    let module = match &ctx.module {\n-        Some(it) => it,\n-        None => return Ok(()),\n-    };\n-    if let Some(function) = &ctx.function {\n-        let scopes = function.scopes(ctx.db)?;\n-        complete_fn(acc, &scopes, ctx.offset);\n-    }\n-\n-    let module_scope = module.scope(ctx.db)?;\n-    let (file_id, _) = module.defenition_source(ctx.db)?;\n-    module_scope\n-        .entries()\n-        .filter(|(_name, res)| {\n-            // Don't expose this item\n-            // FIXME: this penetrates through all kinds of abstractions,\n-            // we need to figura out the way to do it less ugly.\n-            match res.import {\n-                None => true,\n-                Some(import) => {\n-                    let range = import.range(ctx.db, file_id);\n-                    !range.is_subrange(&ctx.leaf.range())\n-                }\n-            }\n-        })\n-        .for_each(|(name, res)| {\n-            CompletionItem::new(CompletionKind::Reference, name.to_string())\n-                .from_resolution(ctx, res)\n-                .add_to(acc)\n-        });\n-    Ok(())\n-}\n-\n-fn complete_fn(acc: &mut Completions, scopes: &hir::ScopesWithSyntaxMapping, offset: TextUnit) {\n-    let mut shadowed = FxHashSet::default();\n-    scopes\n-        .scope_chain_for_offset(offset)\n-        .flat_map(|scope| scopes.scopes.entries(scope).iter())\n-        .filter(|entry| shadowed.insert(entry.name()))\n-        .for_each(|entry| {\n-            CompletionItem::new(CompletionKind::Reference, entry.name().to_string())\n-                .kind(CompletionItemKind::Binding)\n-                .add_to(acc)\n-        });\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-\n-    fn check_reference_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Reference);\n-    }\n-\n-    #[test]\n-    fn completes_bindings_from_let() {\n-        check_reference_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            r#\"y;x;quux \"quux($0)\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_bindings_from_if_let() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            r#\"b;a;quux \"quux()$0\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_bindings_from_for() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"x;quux \"quux()$0\"\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_module_items() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"quux \"quux()$0\";Foo;Baz\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_module_items_in_nested_modules() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            r#\"quux \"quux()$0\";Bar\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_return_type() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-            \",\n-            r#\"Foo;x \"x()$0\"\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn dont_show_both_completions_for_shadowing() {\n-        check_reference_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"bar;foo \"foo()$0\"\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn completes_self_in_methods() {\n-        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_function_calls() {\n-        check_reference_completion(\n-            r\"\n-            fn no_args() {}\n-            fn main() { no_<|> }\n-            \",\n-            r#\"no_args \"no_args()$0\"\n-               main \"main()$0\"\"#,\n-        );\n-        check_reference_completion(\n-            r\"\n-            fn with_args(x: i32, y: String) {}\n-            fn main() { with_<|> }\n-            \",\n-            r#\"main \"main()$0\"\n-               with_args \"with_args($0)\"\"#,\n-        );\n-    }\n-}"}, {"sha": "a495751dda02e4c4a3a2fab4f2481147437eca86", "filename": "crates/ra_analysis/src/completion/complete_snippet.rs", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,73 +0,0 @@\n-use crate::completion::{CompletionItem, Completions, CompletionKind, CompletionItemKind, CompletionContext, completion_item::Builder};\n-\n-fn snippet(label: &str, snippet: &str) -> Builder {\n-    CompletionItem::new(CompletionKind::Snippet, label)\n-        .snippet(snippet)\n-        .kind(CompletionItemKind::Snippet)\n-}\n-\n-pub(super) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !(ctx.is_trivial_path && ctx.function_syntax.is_some()) {\n-        return;\n-    }\n-    snippet(\"pd\", \"eprintln!(\\\"$0 = {:?}\\\", $0);\").add_to(acc);\n-    snippet(\"ppd\", \"eprintln!(\\\"$0 = {:#?}\\\", $0);\").add_to(acc);\n-}\n-\n-pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_new_item {\n-        return;\n-    }\n-    snippet(\n-        \"Test function\",\n-        \"\\\n-#[test]\n-fn ${1:feature}() {\n-    $0\n-}\",\n-    )\n-    .lookup_by(\"tfn\")\n-    .add_to(acc);\n-\n-    snippet(\"pub(crate)\", \"pub(crate) $0\").add_to(acc);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Snippet);\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_expressions() {\n-        check_snippet_completion(\n-            r\"fn foo(x: i32) { <|> }\",\n-            r##\"\n-            pd \"eprintln!(\\\"$0 = {:?}\\\", $0);\"\n-            ppd \"eprintln!(\\\"$0 = {:#?}\\\", $0);\"\n-            \"##,\n-        );\n-    }\n-\n-    #[test]\n-    fn completes_snippets_in_items() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n-        // );\n-        check_snippet_completion(\n-            r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n-            \",\n-            r##\"\n-            tfn \"Test function\" \"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\"\n-            pub(crate) \"pub(crate) $0\"\n-            \"##,\n-        );\n-    }\n-}"}, {"sha": "01786bb69e91d695ae855f7bd2ba158bd7b3dc7b", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,205 +0,0 @@\n-use ra_text_edit::AtomTextEdit;\n-use ra_syntax::{\n-    AstNode, SyntaxNode, SourceFile, TextUnit, TextRange,\n-    ast,\n-    algo::{find_leaf_at_offset, find_covering_node, find_node_at_offset},\n-    SyntaxKind::*,\n-};\n-use hir::source_binder;\n-\n-use crate::{db, FilePosition, Cancelable};\n-\n-/// `CompletionContext` is created early during completion to figure out, where\n-/// exactly is the cursor, syntax-wise.\n-#[derive(Debug)]\n-pub(super) struct CompletionContext<'a> {\n-    pub(super) db: &'a db::RootDatabase,\n-    pub(super) offset: TextUnit,\n-    pub(super) leaf: &'a SyntaxNode,\n-    pub(super) module: Option<hir::Module>,\n-    pub(super) function: Option<hir::Function>,\n-    pub(super) function_syntax: Option<&'a ast::FnDef>,\n-    pub(super) use_item_syntax: Option<&'a ast::UseItem>,\n-    pub(super) is_param: bool,\n-    /// A single-indent path, like `foo`.\n-    pub(super) is_trivial_path: bool,\n-    /// If not a trivial, path, the prefix (qualifier).\n-    pub(super) path_prefix: Option<hir::Path>,\n-    pub(super) after_if: bool,\n-    /// `true` if we are a statement or a last expr in the block.\n-    pub(super) can_be_stmt: bool,\n-    /// Something is typed at the \"top\" level, in module or impl/trait.\n-    pub(super) is_new_item: bool,\n-    /// The receiver if this is a field or method access, i.e. writing something.<|>\n-    pub(super) dot_receiver: Option<&'a ast::Expr>,\n-    /// If this is a method call in particular, i.e. the () are already there.\n-    pub(super) is_method_call: bool,\n-}\n-\n-impl<'a> CompletionContext<'a> {\n-    pub(super) fn new(\n-        db: &'a db::RootDatabase,\n-        original_file: &'a SourceFile,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<CompletionContext<'a>>> {\n-        let module = source_binder::module_from_position(db, position)?;\n-        let leaf =\n-            ctry!(find_leaf_at_offset(original_file.syntax(), position.offset).left_biased());\n-        let mut ctx = CompletionContext {\n-            db,\n-            leaf,\n-            offset: position.offset,\n-            module,\n-            function: None,\n-            function_syntax: None,\n-            use_item_syntax: None,\n-            is_param: false,\n-            is_trivial_path: false,\n-            path_prefix: None,\n-            after_if: false,\n-            can_be_stmt: false,\n-            is_new_item: false,\n-            dot_receiver: None,\n-            is_method_call: false,\n-        };\n-        ctx.fill(original_file, position.offset);\n-        Ok(Some(ctx))\n-    }\n-\n-    fn fill(&mut self, original_file: &'a SourceFile, offset: TextUnit) {\n-        // Insert a fake ident to get a valid parse tree. We will use this file\n-        // to determine context, though the original_file will be used for\n-        // actual completion.\n-        let file = {\n-            let edit = AtomTextEdit::insert(offset, \"intellijRulezz\".to_string());\n-            original_file.reparse(&edit)\n-        };\n-\n-        // First, let's try to complete a reference to some declaration.\n-        if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n-            // Special case, `trait T { fn foo(i_am_a_name_ref) {} }`.\n-            // See RFC#1685.\n-            if is_node::<ast::Param>(name_ref.syntax()) {\n-                self.is_param = true;\n-                return;\n-            }\n-            self.classify_name_ref(original_file, name_ref);\n-        }\n-\n-        // Otherwise, see if this is a declaration. We can use heuristics to\n-        // suggest declaration names, see `CompletionKind::Magic`.\n-        if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n-            if is_node::<ast::Param>(name.syntax()) {\n-                self.is_param = true;\n-                return;\n-            }\n-        }\n-    }\n-    fn classify_name_ref(&mut self, original_file: &'a SourceFile, name_ref: &ast::NameRef) {\n-        let name_range = name_ref.syntax().range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.range() == name_range)\n-            .last()\n-            .unwrap();\n-\n-        match top_node.parent().map(|it| it.kind()) {\n-            Some(SOURCE_FILE) | Some(ITEM_LIST) => {\n-                self.is_new_item = true;\n-                return;\n-            }\n-            _ => (),\n-        }\n-\n-        self.use_item_syntax = self.leaf.ancestors().find_map(ast::UseItem::cast);\n-\n-        self.function_syntax = self\n-            .leaf\n-            .ancestors()\n-            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-            .find_map(ast::FnDef::cast);\n-        match (&self.module, self.function_syntax) {\n-            (Some(module), Some(fn_def)) => {\n-                let function = source_binder::function_from_module(self.db, module, fn_def);\n-                self.function = Some(function);\n-            }\n-            _ => (),\n-        }\n-\n-        let parent = match name_ref.syntax().parent() {\n-            Some(it) => it,\n-            None => return,\n-        };\n-        if let Some(segment) = ast::PathSegment::cast(parent) {\n-            let path = segment.parent_path();\n-            if let Some(mut path) = hir::Path::from_ast(path) {\n-                if !path.is_ident() {\n-                    path.segments.pop().unwrap();\n-                    self.path_prefix = Some(path);\n-                    return;\n-                }\n-            }\n-            if path.qualifier().is_none() {\n-                self.is_trivial_path = true;\n-\n-                // Find either enclosing expr statement (thing with `;`) or a\n-                // block. If block, check that we are the last expr.\n-                self.can_be_stmt = name_ref\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(|node| {\n-                        if let Some(stmt) = ast::ExprStmt::cast(node) {\n-                            return Some(stmt.syntax().range() == name_ref.syntax().range());\n-                        }\n-                        if let Some(block) = ast::Block::cast(node) {\n-                            return Some(\n-                                block.expr().map(|e| e.syntax().range())\n-                                    == Some(name_ref.syntax().range()),\n-                            );\n-                        }\n-                        None\n-                    })\n-                    .unwrap_or(false);\n-\n-                if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) =\n-                        find_node_at_offset::<ast::IfExpr>(original_file.syntax(), off)\n-                    {\n-                        if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n-                            self.after_if = true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        if let Some(field_expr) = ast::FieldExpr::cast(parent) {\n-            // The receiver comes before the point of insertion of the fake\n-            // ident, so it should have the same range in the non-modified file\n-            self.dot_receiver = field_expr\n-                .expr()\n-                .map(|e| e.syntax().range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n-        }\n-        if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n-            // As above\n-            self.dot_receiver = method_call_expr\n-                .expr()\n-                .map(|e| e.syntax().range())\n-                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n-            self.is_method_call = true;\n-        }\n-    }\n-}\n-\n-fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<&N> {\n-    let node = find_covering_node(syntax, range);\n-    node.ancestors().find_map(N::cast)\n-}\n-\n-fn is_node<N: AstNode>(node: &SyntaxNode) -> bool {\n-    match node.ancestors().filter_map(N::cast).next() {\n-        None => false,\n-        Some(n) => n.syntax().range() == node.range(),\n-    }\n-}"}, {"sha": "a25b87beefee403b6f985c0f0114ee2d4e30af9a", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,244 +0,0 @@\n-use hir::PerNs;\n-\n-use crate::completion::CompletionContext;\n-\n-/// `CompletionItem` describes a single completion variant in the editor pop-up.\n-/// It is basically a POD with various properties. To construct a\n-/// `CompletionItem`, use `new` method and the `Builder` struct.\n-#[derive(Debug)]\n-pub struct CompletionItem {\n-    /// Used only internally in tests, to check only specific kind of\n-    /// completion.\n-    completion_kind: CompletionKind,\n-    label: String,\n-    lookup: Option<String>,\n-    snippet: Option<String>,\n-    kind: Option<CompletionItemKind>,\n-}\n-\n-pub enum InsertText {\n-    PlainText { text: String },\n-    Snippet { text: String },\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum CompletionItemKind {\n-    Snippet,\n-    Keyword,\n-    Module,\n-    Function,\n-    Struct,\n-    Enum,\n-    EnumVariant,\n-    Binding,\n-    Field,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) enum CompletionKind {\n-    /// Parser-based keyword completion.\n-    Keyword,\n-    /// Your usual \"complete all valid identifiers\".\n-    Reference,\n-    /// \"Secret sauce\" completions.\n-    Magic,\n-    Snippet,\n-}\n-\n-impl CompletionItem {\n-    pub(crate) fn new(completion_kind: CompletionKind, label: impl Into<String>) -> Builder {\n-        let label = label.into();\n-        Builder {\n-            completion_kind,\n-            label,\n-            lookup: None,\n-            snippet: None,\n-            kind: None,\n-        }\n-    }\n-    /// What user sees in pop-up in the UI.\n-    pub fn label(&self) -> &str {\n-        &self.label\n-    }\n-    /// What string is used for filtering.\n-    pub fn lookup(&self) -> &str {\n-        self.lookup\n-            .as_ref()\n-            .map(|it| it.as_str())\n-            .unwrap_or(self.label())\n-    }\n-    /// What is inserted.\n-    pub fn insert_text(&self) -> InsertText {\n-        match &self.snippet {\n-            None => InsertText::PlainText {\n-                text: self.label.clone(),\n-            },\n-            Some(it) => InsertText::Snippet { text: it.clone() },\n-        }\n-    }\n-\n-    pub fn kind(&self) -> Option<CompletionItemKind> {\n-        self.kind\n-    }\n-}\n-\n-/// A helper to make `CompletionItem`s.\n-#[must_use]\n-pub(crate) struct Builder {\n-    completion_kind: CompletionKind,\n-    label: String,\n-    lookup: Option<String>,\n-    snippet: Option<String>,\n-    kind: Option<CompletionItemKind>,\n-}\n-\n-impl Builder {\n-    pub(crate) fn add_to(self, acc: &mut Completions) {\n-        acc.add(self.build())\n-    }\n-\n-    pub(crate) fn build(self) -> CompletionItem {\n-        CompletionItem {\n-            label: self.label,\n-            lookup: self.lookup,\n-            snippet: self.snippet,\n-            kind: self.kind,\n-            completion_kind: self.completion_kind,\n-        }\n-    }\n-    pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n-        self.lookup = Some(lookup.into());\n-        self\n-    }\n-    pub(crate) fn snippet(mut self, snippet: impl Into<String>) -> Builder {\n-        self.snippet = Some(snippet.into());\n-        self\n-    }\n-    pub(crate) fn kind(mut self, kind: CompletionItemKind) -> Builder {\n-        self.kind = Some(kind);\n-        self\n-    }\n-    pub(super) fn from_resolution(\n-        mut self,\n-        ctx: &CompletionContext,\n-        resolution: &hir::Resolution,\n-    ) -> Builder {\n-        let resolved = resolution.def_id.and_then(|d| d.resolve(ctx.db).ok());\n-        let kind = match resolved {\n-            PerNs {\n-                types: Some(hir::Def::Module(..)),\n-                ..\n-            } => CompletionItemKind::Module,\n-            PerNs {\n-                types: Some(hir::Def::Struct(..)),\n-                ..\n-            } => CompletionItemKind::Struct,\n-            PerNs {\n-                types: Some(hir::Def::Enum(..)),\n-                ..\n-            } => CompletionItemKind::Enum,\n-            PerNs {\n-                values: Some(hir::Def::Function(function)),\n-                ..\n-            } => return self.from_function(ctx, function),\n-            _ => return self,\n-        };\n-        self.kind = Some(kind);\n-        self\n-    }\n-\n-    fn from_function(mut self, ctx: &CompletionContext, function: hir::Function) -> Builder {\n-        // If not an import, add parenthesis automatically.\n-        if ctx.use_item_syntax.is_none() {\n-            if function.signature(ctx.db).args().is_empty() {\n-                self.snippet = Some(format!(\"{}()$0\", self.label));\n-            } else {\n-                self.snippet = Some(format!(\"{}($0)\", self.label));\n-            }\n-        }\n-        self.kind = Some(CompletionItemKind::Function);\n-        self\n-    }\n-}\n-\n-impl Into<CompletionItem> for Builder {\n-    fn into(self) -> CompletionItem {\n-        self.build()\n-    }\n-}\n-\n-/// Represents an in-progress set of completions being built.\n-#[derive(Debug, Default)]\n-pub(crate) struct Completions {\n-    buf: Vec<CompletionItem>,\n-}\n-\n-impl Completions {\n-    pub(crate) fn add(&mut self, item: impl Into<CompletionItem>) {\n-        self.buf.push(item.into())\n-    }\n-    pub(crate) fn add_all<I>(&mut self, items: I)\n-    where\n-        I: IntoIterator,\n-        I::Item: Into<CompletionItem>,\n-    {\n-        items.into_iter().for_each(|item| self.add(item.into()))\n-    }\n-\n-    #[cfg(test)]\n-    pub(crate) fn assert_match(&self, expected: &str, kind: CompletionKind) {\n-        let expected = normalize(expected);\n-        let actual = self.debug_render(kind);\n-        test_utils::assert_eq_text!(expected.as_str(), actual.as_str(),);\n-\n-        /// Normalize the textual representation of `Completions`:\n-        /// replace `;` with newlines, normalize whitespace\n-        fn normalize(expected: &str) -> String {\n-            use ra_syntax::{tokenize, TextUnit, TextRange, SyntaxKind::SEMI};\n-            let mut res = String::new();\n-            for line in expected.trim().lines() {\n-                let line = line.trim();\n-                let mut start_offset: TextUnit = 0.into();\n-                // Yep, we use rust tokenize in completion tests :-)\n-                for token in tokenize(line) {\n-                    let range = TextRange::offset_len(start_offset, token.len);\n-                    start_offset += token.len;\n-                    if token.kind == SEMI {\n-                        res.push('\\n');\n-                    } else {\n-                        res.push_str(&line[range]);\n-                    }\n-                }\n-\n-                res.push('\\n');\n-            }\n-            res\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn debug_render(&self, kind: CompletionKind) -> String {\n-        let mut res = String::new();\n-        for c in self.buf.iter() {\n-            if c.completion_kind == kind {\n-                if let Some(lookup) = &c.lookup {\n-                    res.push_str(lookup);\n-                    res.push_str(&format!(\" {:?}\", c.label));\n-                } else {\n-                    res.push_str(&c.label);\n-                }\n-                if let Some(snippet) = &c.snippet {\n-                    res.push_str(&format!(\" {:?}\", snippet));\n-                }\n-                res.push('\\n');\n-            }\n-        }\n-        res\n-    }\n-}\n-\n-impl Into<Vec<CompletionItem>> for Completions {\n-    fn into(self) -> Vec<CompletionItem> {\n-        self.buf\n-    }\n-}"}, {"sha": "9d46609ecfd51bd324cf35b10e5e186a793f1547", "filename": "crates/ra_analysis/src/db.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,128 +0,0 @@\n-use std::{fmt, sync::Arc};\n-\n-use salsa::{self, Database};\n-use ra_db::{LocationIntener, BaseDatabase, FileId};\n-\n-use crate::{symbol_index, LineIndex};\n-\n-#[derive(Debug)]\n-pub(crate) struct RootDatabase {\n-    runtime: salsa::Runtime<RootDatabase>,\n-    id_maps: Arc<IdMaps>,\n-}\n-\n-#[derive(Default)]\n-struct IdMaps {\n-    defs: LocationIntener<hir::DefLoc, hir::DefId>,\n-    macros: LocationIntener<hir::MacroCallLoc, hir::MacroCallId>,\n-}\n-\n-impl fmt::Debug for IdMaps {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"IdMaps\")\n-            .field(\"n_defs\", &self.defs.len())\n-            .finish()\n-    }\n-}\n-\n-impl salsa::Database for RootDatabase {\n-    fn salsa_runtime(&self) -> &salsa::Runtime<RootDatabase> {\n-        &self.runtime\n-    }\n-}\n-\n-impl Default for RootDatabase {\n-    fn default() -> RootDatabase {\n-        let mut db = RootDatabase {\n-            runtime: salsa::Runtime::default(),\n-            id_maps: Default::default(),\n-        };\n-        db.query_mut(ra_db::CrateGraphQuery)\n-            .set((), Default::default());\n-        db.query_mut(ra_db::LocalRootsQuery)\n-            .set((), Default::default());\n-        db.query_mut(ra_db::LibraryRootsQuery)\n-            .set((), Default::default());\n-        db\n-    }\n-}\n-\n-impl salsa::ParallelDatabase for RootDatabase {\n-    fn snapshot(&self) -> salsa::Snapshot<RootDatabase> {\n-        salsa::Snapshot::new(RootDatabase {\n-            runtime: self.runtime.snapshot(self),\n-            id_maps: self.id_maps.clone(),\n-        })\n-    }\n-}\n-\n-impl BaseDatabase for RootDatabase {}\n-\n-impl AsRef<LocationIntener<hir::DefLoc, hir::DefId>> for RootDatabase {\n-    fn as_ref(&self) -> &LocationIntener<hir::DefLoc, hir::DefId> {\n-        &self.id_maps.defs\n-    }\n-}\n-\n-impl AsRef<LocationIntener<hir::MacroCallLoc, hir::MacroCallId>> for RootDatabase {\n-    fn as_ref(&self) -> &LocationIntener<hir::MacroCallLoc, hir::MacroCallId> {\n-        &self.id_maps.macros\n-    }\n-}\n-\n-salsa::query_group! {\n-    pub(crate) trait LineIndexDatabase: ra_db::FilesDatabase + BaseDatabase {\n-        fn line_index(file_id: FileId) -> Arc<LineIndex> {\n-            type LineIndexQuery;\n-        }\n-    }\n-}\n-\n-fn line_index(db: &impl ra_db::FilesDatabase, file_id: FileId) -> Arc<LineIndex> {\n-    let text = db.file_text(file_id);\n-    Arc::new(LineIndex::new(&*text))\n-}\n-\n-salsa::database_storage! {\n-    pub(crate) struct RootDatabaseStorage for RootDatabase {\n-        impl ra_db::FilesDatabase {\n-            fn file_text() for ra_db::FileTextQuery;\n-            fn file_relative_path() for ra_db::FileRelativePathQuery;\n-            fn file_source_root() for ra_db::FileSourceRootQuery;\n-            fn source_root() for ra_db::SourceRootQuery;\n-            fn local_roots() for ra_db::LocalRootsQuery;\n-            fn library_roots() for ra_db::LibraryRootsQuery;\n-            fn crate_graph() for ra_db::CrateGraphQuery;\n-        }\n-        impl ra_db::SyntaxDatabase {\n-            fn source_file() for ra_db::SourceFileQuery;\n-        }\n-        impl LineIndexDatabase {\n-            fn line_index() for LineIndexQuery;\n-        }\n-        impl symbol_index::SymbolsDatabase {\n-            fn file_symbols() for symbol_index::FileSymbolsQuery;\n-            fn library_symbols() for symbol_index::LibrarySymbolsQuery;\n-        }\n-        impl hir::db::HirDatabase {\n-            fn hir_source_file() for hir::db::HirSourceFileQuery;\n-            fn expand_macro_invocation() for hir::db::ExpandMacroCallQuery;\n-            fn module_tree() for hir::db::ModuleTreeQuery;\n-            fn fn_scopes() for hir::db::FnScopesQuery;\n-            fn file_items() for hir::db::SourceFileItemsQuery;\n-            fn file_item() for hir::db::FileItemQuery;\n-            fn input_module_items() for hir::db::InputModuleItemsQuery;\n-            fn item_map() for hir::db::ItemMapQuery;\n-            fn submodules() for hir::db::SubmodulesQuery;\n-            fn infer() for hir::db::InferQuery;\n-            fn type_for_def() for hir::db::TypeForDefQuery;\n-            fn type_for_field() for hir::db::TypeForFieldQuery;\n-            fn struct_data() for hir::db::StructDataQuery;\n-            fn enum_data() for hir::db::EnumDataQuery;\n-            fn impls_in_module() for hir::db::ImplsInModuleQuery;\n-            fn body_hir() for hir::db::BodyHirQuery;\n-            fn body_syntax_mapping() for hir::db::BodySyntaxMappingQuery;\n-            fn fn_signature() for hir::db::FnSignatureQuery;\n-        }\n-    }\n-}"}, {"sha": "c3c809c9fe3369c09af8d9ade57ad9e97821fc76", "filename": "crates/ra_analysis/src/extend_selection.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fextend_selection.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,56 +0,0 @@\n-use ra_db::SyntaxDatabase;\n-use ra_syntax::{\n-    SyntaxNode, AstNode, SourceFile,\n-    ast, algo::find_covering_node,\n-};\n-\n-use crate::{\n-    TextRange, FileRange,\n-    db::RootDatabase,\n-};\n-\n-pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n-    let source_file = db.source_file(frange.file_id);\n-    if let Some(range) = extend_selection_in_macro(db, &source_file, frange) {\n-        return range;\n-    }\n-    ra_ide_api_light::extend_selection(source_file.syntax(), frange.range).unwrap_or(frange.range)\n-}\n-\n-fn extend_selection_in_macro(\n-    _db: &RootDatabase,\n-    source_file: &SourceFile,\n-    frange: FileRange,\n-) -> Option<TextRange> {\n-    let macro_call = find_macro_call(source_file.syntax(), frange.range)?;\n-    let (off, exp) = hir::MacroDef::ast_expand(macro_call)?;\n-    let dst_range = exp.map_range_forward(frange.range - off)?;\n-    let dst_range = ra_ide_api_light::extend_selection(&exp.syntax(), dst_range)?;\n-    let src_range = exp.map_range_back(dst_range)? + off;\n-    Some(src_range)\n-}\n-\n-fn find_macro_call(node: &SyntaxNode, range: TextRange) -> Option<&ast::MacroCall> {\n-    find_covering_node(node, range)\n-        .ancestors()\n-        .find_map(ast::MacroCall::cast)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::mock_analysis::single_file_with_range;\n-    use test_utils::assert_eq_dbg;\n-\n-    #[test]\n-    fn extend_selection_inside_macros() {\n-        let (analysis, frange) = single_file_with_range(\n-            \"\n-            fn main() {\n-                ctry!(foo(|x| <|>x<|>));\n-            }\n-        \",\n-        );\n-        let r = analysis.extend_selection(frange);\n-        assert_eq_dbg(\"[51; 56)\", &r);\n-    }\n-}"}, {"sha": "fcd8d315e24ad53013ec6249d2b60cbd06f050be", "filename": "crates/ra_analysis/src/goto_defenition.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fgoto_defenition.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,139 +0,0 @@\n-use ra_db::{FileId, Cancelable, SyntaxDatabase};\n-use ra_syntax::{\n-    TextRange, AstNode, ast, SyntaxKind::{NAME, MODULE},\n-    algo::find_node_at_offset,\n-};\n-\n-use crate::{FilePosition, NavigationTarget, db::RootDatabase};\n-\n-pub(crate) fn goto_defenition(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<Vec<NavigationTarget>>> {\n-    let file = db.source_file(position.file_id);\n-    let syntax = file.syntax();\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-        return Ok(Some(reference_defenition(db, position.file_id, name_ref)?));\n-    }\n-    if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n-        return name_defenition(db, position.file_id, name);\n-    }\n-    Ok(None)\n-}\n-\n-pub(crate) fn reference_defenition(\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    name_ref: &ast::NameRef,\n-) -> Cancelable<Vec<NavigationTarget>> {\n-    if let Some(fn_descr) =\n-        hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n-    {\n-        let scope = fn_descr.scopes(db)?;\n-        // First try to resolve the symbol locally\n-        if let Some(entry) = scope.resolve_local_name(name_ref) {\n-            let nav = NavigationTarget {\n-                file_id,\n-                name: entry.name().to_string().into(),\n-                range: entry.ptr().range(),\n-                kind: NAME,\n-                ptr: None,\n-            };\n-            return Ok(vec![nav]);\n-        };\n-    }\n-    // If that fails try the index based approach.\n-    let navs = db\n-        .index_resolve(name_ref)?\n-        .into_iter()\n-        .map(NavigationTarget::from_symbol)\n-        .collect();\n-    Ok(navs)\n-}\n-\n-fn name_defenition(\n-    db: &RootDatabase,\n-    file_id: FileId,\n-    name: &ast::Name,\n-) -> Cancelable<Option<Vec<NavigationTarget>>> {\n-    if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n-        if module.has_semi() {\n-            if let Some(child_module) =\n-                hir::source_binder::module_from_declaration(db, file_id, module)?\n-            {\n-                let (file_id, _) = child_module.defenition_source(db)?;\n-                let name = match child_module.name(db)? {\n-                    Some(name) => name.to_string().into(),\n-                    None => \"\".into(),\n-                };\n-                let nav = NavigationTarget {\n-                    file_id,\n-                    name,\n-                    range: TextRange::offset_len(0.into(), 0.into()),\n-                    kind: MODULE,\n-                    ptr: None,\n-                };\n-                return Ok(Some(vec![nav]));\n-            }\n-        }\n-    }\n-    Ok(None)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use test_utils::assert_eq_dbg;\n-    use crate::mock_analysis::analysis_and_position;\n-\n-    #[test]\n-    fn goto_defenition_works_in_items() {\n-        let (analysis, pos) = analysis_and_position(\n-            \"\n-            //- /lib.rs\n-            struct Foo;\n-            enum E { X(Foo<|>) }\n-            \",\n-        );\n-\n-        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(1), name: \"Foo\",\n-                                   kind: STRUCT_DEF, range: [0; 11),\n-                                   ptr: Some(LocalSyntaxPtr { range: [0; 11), kind: STRUCT_DEF }) }]\"#,\n-            &symbols,\n-        );\n-    }\n-\n-    #[test]\n-    fn goto_defenition_works_for_module_declaration() {\n-        let (analysis, pos) = analysis_and_position(\n-            \"\n-            //- /lib.rs\n-            mod <|>foo;\n-            //- /foo.rs\n-            // empty\n-        \",\n-        );\n-\n-        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n-            &symbols,\n-        );\n-\n-        let (analysis, pos) = analysis_and_position(\n-            \"\n-            //- /lib.rs\n-            mod <|>foo;\n-            //- /foo/mod.rs\n-            // empty\n-        \",\n-        );\n-\n-        let symbols = analysis.goto_defenition(pos).unwrap().unwrap();\n-        assert_eq_dbg(\n-            r#\"[NavigationTarget { file_id: FileId(2), name: \"foo\", kind: MODULE, range: [0; 0), ptr: None }]\"#,\n-            &symbols,\n-        );\n-    }\n-}"}, {"sha": "475524ee1827549a44c6e490604e1bf607232d80", "filename": "crates/ra_analysis/src/hover.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,257 +0,0 @@\n-use ra_db::{Cancelable, SyntaxDatabase};\n-use ra_syntax::{\n-    AstNode, SyntaxNode, TreePtr,\n-    ast::{self, NameOwner},\n-    algo::{find_covering_node, find_node_at_offset, find_leaf_at_offset, visit::{visitor, Visitor}},\n-};\n-\n-use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n-\n-pub(crate) fn hover(\n-    db: &RootDatabase,\n-    position: FilePosition,\n-) -> Cancelable<Option<RangeInfo<String>>> {\n-    let file = db.source_file(position.file_id);\n-    let mut res = Vec::new();\n-\n-    let mut range = None;\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        let navs = crate::goto_defenition::reference_defenition(db, position.file_id, name_ref)?;\n-        for nav in navs {\n-            res.extend(doc_text_for(db, nav)?)\n-        }\n-        if !res.is_empty() {\n-            range = Some(name_ref.syntax().range())\n-        }\n-    }\n-    if range.is_none() {\n-        let node = find_leaf_at_offset(file.syntax(), position.offset).find_map(|leaf| {\n-            leaf.ancestors()\n-                .find(|n| ast::Expr::cast(*n).is_some() || ast::Pat::cast(*n).is_some())\n-        });\n-        let node = ctry!(node);\n-        let frange = FileRange {\n-            file_id: position.file_id,\n-            range: node.range(),\n-        };\n-        res.extend(type_of(db, frange)?);\n-        range = Some(node.range());\n-    };\n-\n-    let range = ctry!(range);\n-    if res.is_empty() {\n-        return Ok(None);\n-    }\n-    let res = RangeInfo::new(range, res.join(\"\\n\\n---\\n\"));\n-    Ok(Some(res))\n-}\n-\n-pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option<String>> {\n-    let file = db.source_file(frange.file_id);\n-    let syntax = file.syntax();\n-    let leaf_node = find_covering_node(syntax, frange.range);\n-    // if we picked identifier, expand to pattern/expression\n-    let node = leaf_node\n-        .ancestors()\n-        .take_while(|it| it.range() == leaf_node.range())\n-        .find(|&it| ast::Expr::cast(it).is_some() || ast::Pat::cast(it).is_some())\n-        .unwrap_or(leaf_node);\n-    let parent_fn = ctry!(node.ancestors().find_map(ast::FnDef::cast));\n-    let function = ctry!(hir::source_binder::function_from_source(\n-        db,\n-        frange.file_id,\n-        parent_fn\n-    )?);\n-    let infer = function.infer(db)?;\n-    let syntax_mapping = function.body_syntax_mapping(db)?;\n-    if let Some(expr) = ast::Expr::cast(node).and_then(|e| syntax_mapping.node_expr(e)) {\n-        Ok(Some(infer[expr].to_string()))\n-    } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| syntax_mapping.node_pat(p)) {\n-        Ok(Some(infer[pat].to_string()))\n-    } else {\n-        Ok(None)\n-    }\n-}\n-\n-// FIXME: this should not really use navigation target. Rather, approximatelly\n-// resovled symbol should return a `DefId`.\n-fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-    let result = match (nav.description(db), nav.docs(db)) {\n-        (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),\n-        (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n-        (None, Some(docs)) => Some(docs),\n-        _ => None,\n-    };\n-\n-    Ok(result)\n-}\n-\n-impl NavigationTarget {\n-    fn node(&self, db: &RootDatabase) -> Option<TreePtr<SyntaxNode>> {\n-        let source_file = db.source_file(self.file_id);\n-        let source_file = source_file.syntax();\n-        let node = source_file\n-            .descendants()\n-            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n-            .to_owned();\n-        Some(node)\n-    }\n-\n-    fn docs(&self, db: &RootDatabase) -> Option<String> {\n-        let node = self.node(db)?;\n-        fn doc_comments<N: ast::DocCommentsOwner>(node: &N) -> Option<String> {\n-            let comments = node.doc_comment_text();\n-            if comments.is_empty() {\n-                None\n-            } else {\n-                Some(comments)\n-            }\n-        }\n-\n-        visitor()\n-            .visit(doc_comments::<ast::FnDef>)\n-            .visit(doc_comments::<ast::StructDef>)\n-            .visit(doc_comments::<ast::EnumDef>)\n-            .visit(doc_comments::<ast::TraitDef>)\n-            .visit(doc_comments::<ast::Module>)\n-            .visit(doc_comments::<ast::TypeDef>)\n-            .visit(doc_comments::<ast::ConstDef>)\n-            .visit(doc_comments::<ast::StaticDef>)\n-            .accept(&node)?\n-    }\n-\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    fn description(&self, db: &RootDatabase) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        let node = self.node(db)?;\n-        // TODO: Refactor to be have less repetition\n-        visitor()\n-            .visit(|node: &ast::FnDef| {\n-                let mut string = \"fn \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::StructDef| {\n-                let mut string = \"struct \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::EnumDef| {\n-                let mut string = \"enum \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::TraitDef| {\n-                let mut string = \"trait \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::Module| {\n-                let mut string = \"mod \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::TypeDef| {\n-                let mut string = \"type \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::ConstDef| {\n-                let mut string = \"const \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: &ast::StaticDef| {\n-                let mut string = \"static \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .accept(&node)?\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::TextRange;\n-    use crate::mock_analysis::{single_file_with_position, single_file_with_range};\n-\n-    #[test]\n-    fn hover_shows_type_of_an_expression() {\n-        let (analysis, position) = single_file_with_position(\n-            \"\n-            pub fn foo() -> u32 { 1 }\n-\n-            fn main() {\n-                let foo_test = foo()<|>;\n-            }\n-            \",\n-        );\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(hover.range, TextRange::from_to(95.into(), 100.into()));\n-        assert_eq!(hover.info, \"u32\");\n-    }\n-\n-    #[test]\n-    fn hover_for_local_variable() {\n-        let (analysis, position) = single_file_with_position(\"fn func(foo: i32) { fo<|>o; }\");\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(hover.info, \"i32\");\n-    }\n-\n-    #[test]\n-    fn hover_for_local_variable_pat() {\n-        let (analysis, position) = single_file_with_position(\"fn func(fo<|>o: i32) {}\");\n-        let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(hover.info, \"i32\");\n-    }\n-\n-    #[test]\n-    fn test_type_of_for_function() {\n-        let (analysis, range) = single_file_with_range(\n-            \"\n-            pub fn foo() -> u32 { 1 };\n-\n-            fn main() {\n-                let foo_test = <|>foo()<|>;\n-            }\n-            \",\n-        );\n-\n-        let type_name = analysis.type_of(range).unwrap().unwrap();\n-        assert_eq!(\"u32\", &type_name);\n-    }\n-\n-    // FIXME: improve type_of to make this work\n-    #[test]\n-    fn test_type_of_for_expr_1() {\n-        let (analysis, range) = single_file_with_range(\n-            \"\n-            fn main() {\n-                let foo = <|>1 + foo_test<|>;\n-            }\n-            \",\n-        );\n-\n-        let type_name = analysis.type_of(range).unwrap().unwrap();\n-        assert_eq!(\"[unknown]\", &type_name);\n-    }\n-\n-    // FIXME: improve type_of to make this work\n-    #[test]\n-    fn test_type_of_for_expr_2() {\n-        let (analysis, range) = single_file_with_range(\n-            \"\n-            fn main() {\n-                let foo: usize = 1;\n-                let bar = <|>1 + foo_test<|>;\n-            }\n-            \",\n-        );\n-\n-        let type_name = analysis.type_of(range).unwrap().unwrap();\n-        assert_eq!(\"[unknown]\", &type_name);\n-    }\n-\n-}"}, {"sha": "7c60ab7d6f4ec1b0c65df96a08bb22440b8cd967", "filename": "crates/ra_analysis/src/imp.rs", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,309 +0,0 @@\n-use std::sync::Arc;\n-\n-use salsa::Database;\n-\n-use hir::{\n-    self, Problem, source_binder,\n-};\n-use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n-use ra_ide_api_light::{self, assists, LocalEdit, Severity};\n-use ra_syntax::{\n-    TextRange, AstNode, SourceFile,\n-    ast::{self, NameOwner},\n-    algo::find_node_at_offset,\n-    SyntaxKind::*,\n-};\n-\n-use crate::{\n-    AnalysisChange,\n-    Cancelable, NavigationTarget,\n-    CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n-    Query, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{LibrarySymbolsQuery, FileSymbol},\n-};\n-\n-impl db::RootDatabase {\n-    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n-        log::info!(\"apply_change {:?}\", change);\n-        // self.gc_syntax_trees();\n-        if !change.new_roots.is_empty() {\n-            let mut local_roots = Vec::clone(&self.local_roots());\n-            for (root_id, is_local) in change.new_roots {\n-                self.query_mut(ra_db::SourceRootQuery)\n-                    .set(root_id, Default::default());\n-                if is_local {\n-                    local_roots.push(root_id);\n-                }\n-            }\n-            self.query_mut(ra_db::LocalRootsQuery)\n-                .set((), Arc::new(local_roots));\n-        }\n-\n-        for (root_id, root_change) in change.roots_changed {\n-            self.apply_root_change(root_id, root_change);\n-        }\n-        for (file_id, text) in change.files_changed {\n-            self.query_mut(ra_db::FileTextQuery).set(file_id, text)\n-        }\n-        if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.library_roots());\n-            for library in change.libraries_added {\n-                libraries.push(library.root_id);\n-                self.query_mut(ra_db::SourceRootQuery)\n-                    .set(library.root_id, Default::default());\n-                self.query_mut(LibrarySymbolsQuery)\n-                    .set_constant(library.root_id, Arc::new(library.symbol_index));\n-                self.apply_root_change(library.root_id, library.root_change);\n-            }\n-            self.query_mut(ra_db::LibraryRootsQuery)\n-                .set((), Arc::new(libraries));\n-        }\n-        if let Some(crate_graph) = change.crate_graph {\n-            self.query_mut(ra_db::CrateGraphQuery)\n-                .set((), Arc::new(crate_graph))\n-        }\n-    }\n-\n-    fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n-        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n-        for add_file in root_change.added {\n-            self.query_mut(ra_db::FileTextQuery)\n-                .set(add_file.file_id, add_file.text);\n-            self.query_mut(ra_db::FileRelativePathQuery)\n-                .set(add_file.file_id, add_file.path.clone());\n-            self.query_mut(ra_db::FileSourceRootQuery)\n-                .set(add_file.file_id, root_id);\n-            source_root.files.insert(add_file.path, add_file.file_id);\n-        }\n-        for remove_file in root_change.removed {\n-            self.query_mut(ra_db::FileTextQuery)\n-                .set(remove_file.file_id, Default::default());\n-            source_root.files.remove(&remove_file.path);\n-        }\n-        self.query_mut(ra_db::SourceRootQuery)\n-            .set(root_id, Arc::new(source_root));\n-    }\n-\n-    #[allow(unused)]\n-    /// Ideally, we should call this function from time to time to collect heavy\n-    /// syntax trees. However, if we actually do that, everything is recomputed\n-    /// for some reason. Needs investigation.\n-    fn gc_syntax_trees(&mut self) {\n-        self.query(ra_db::SourceFileQuery)\n-            .sweep(salsa::SweepStrategy::default().discard_values());\n-        self.query(hir::db::SourceFileItemsQuery)\n-            .sweep(salsa::SweepStrategy::default().discard_values());\n-        self.query(hir::db::FileItemQuery)\n-            .sweep(salsa::SweepStrategy::default().discard_values());\n-    }\n-}\n-\n-impl db::RootDatabase {\n-    /// This returns `Vec` because a module may be included from several places. We\n-    /// don't handle this case yet though, so the Vec has length at most one.\n-    pub(crate) fn parent_module(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Vec<NavigationTarget>> {\n-        let module = match source_binder::module_from_position(self, position)? {\n-            None => return Ok(Vec::new()),\n-            Some(it) => it,\n-        };\n-        let (file_id, ast_module) = match module.declaration_source(self)? {\n-            None => return Ok(Vec::new()),\n-            Some(it) => it,\n-        };\n-        let name = ast_module.name().unwrap();\n-        Ok(vec![NavigationTarget {\n-            file_id,\n-            name: name.text().clone(),\n-            range: name.syntax().range(),\n-            kind: MODULE,\n-            ptr: None,\n-        }])\n-    }\n-    /// Returns `Vec` for the same reason as `parent_module`\n-    pub(crate) fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let module = match source_binder::module_from_file_id(self, file_id)? {\n-            Some(it) => it,\n-            None => return Ok(Vec::new()),\n-        };\n-        let krate = match module.krate(self)? {\n-            Some(it) => it,\n-            None => return Ok(Vec::new()),\n-        };\n-        Ok(vec![krate.crate_id()])\n-    }\n-    pub(crate) fn find_all_refs(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        let file = self.source_file(position.file_id);\n-        // Find the binding associated with the offset\n-        let (binding, descr) = match find_binding(self, &file, position)? {\n-            None => return Ok(Vec::new()),\n-            Some(it) => it,\n-        };\n-\n-        let mut ret = binding\n-            .name()\n-            .into_iter()\n-            .map(|name| (position.file_id, name.syntax().range()))\n-            .collect::<Vec<_>>();\n-        ret.extend(\n-            descr\n-                .scopes(self)?\n-                .find_all_refs(binding)\n-                .into_iter()\n-                .map(|ref_desc| (position.file_id, ref_desc.range)),\n-        );\n-\n-        return Ok(ret);\n-\n-        fn find_binding<'a>(\n-            db: &db::RootDatabase,\n-            source_file: &'a SourceFile,\n-            position: FilePosition,\n-        ) -> Cancelable<Option<(&'a ast::BindPat, hir::Function)>> {\n-            let syntax = source_file.syntax();\n-            if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n-                let descr = ctry!(source_binder::function_from_child_node(\n-                    db,\n-                    position.file_id,\n-                    binding.syntax(),\n-                )?);\n-                return Ok(Some((binding, descr)));\n-            };\n-            let name_ref = ctry!(find_node_at_offset::<ast::NameRef>(syntax, position.offset));\n-            let descr = ctry!(source_binder::function_from_child_node(\n-                db,\n-                position.file_id,\n-                name_ref.syntax(),\n-            )?);\n-            let scope = descr.scopes(db)?;\n-            let resolved = ctry!(scope.resolve_local_name(name_ref));\n-            let resolved = resolved.ptr().resolve(source_file);\n-            let binding = ctry!(find_node_at_offset::<ast::BindPat>(\n-                syntax,\n-                resolved.range().end()\n-            ));\n-            Ok(Some((binding, descr)))\n-        }\n-    }\n-\n-    pub(crate) fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let syntax = self.source_file(file_id);\n-\n-        let mut res = ra_ide_api_light::diagnostics(&syntax)\n-            .into_iter()\n-            .map(|d| Diagnostic {\n-                range: d.range,\n-                message: d.msg,\n-                severity: d.severity,\n-                fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n-            })\n-            .collect::<Vec<_>>();\n-        if let Some(m) = source_binder::module_from_file_id(self, file_id)? {\n-            for (name_node, problem) in m.problems(self)? {\n-                let source_root = self.file_source_root(file_id);\n-                let diag = match problem {\n-                    Problem::UnresolvedModule { candidate } => {\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            source_root,\n-                            path: candidate.clone(),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.range(),\n-                            message: \"unresolved module\".to_string(),\n-                            severity: Severity::Error,\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                    Problem::NotDirOwner { move_to, candidate } => {\n-                        let move_file = FileSystemEdit::MoveFile {\n-                            src: file_id,\n-                            dst_source_root: source_root,\n-                            dst_path: move_to.clone(),\n-                        };\n-                        let create_file = FileSystemEdit::CreateFile {\n-                            source_root,\n-                            path: move_to.join(candidate),\n-                        };\n-                        let fix = SourceChange {\n-                            label: \"move file and create module\".to_string(),\n-                            source_file_edits: Vec::new(),\n-                            file_system_edits: vec![move_file, create_file],\n-                            cursor_position: None,\n-                        };\n-                        Diagnostic {\n-                            range: name_node.range(),\n-                            message: \"can't declare module at this location\".to_string(),\n-                            severity: Severity::Error,\n-                            fix: Some(fix),\n-                        }\n-                    }\n-                };\n-                res.push(diag)\n-            }\n-        };\n-        Ok(res)\n-    }\n-\n-    pub(crate) fn assists(&self, frange: FileRange) -> Vec<SourceChange> {\n-        let file = self.source_file(frange.file_id);\n-        assists::assists(&file, frange.range)\n-            .into_iter()\n-            .map(|local_edit| SourceChange::from_local_edit(frange.file_id, local_edit))\n-            .collect()\n-    }\n-\n-    pub(crate) fn rename(\n-        &self,\n-        position: FilePosition,\n-        new_name: &str,\n-    ) -> Cancelable<Vec<SourceFileEdit>> {\n-        let res = self\n-            .find_all_refs(position)?\n-            .iter()\n-            .map(|(file_id, text_range)| SourceFileEdit {\n-                file_id: *file_id,\n-                edit: {\n-                    let mut builder = ra_text_edit::TextEditBuilder::default();\n-                    builder.replace(*text_range, new_name.into());\n-                    builder.finish()\n-                },\n-            })\n-            .collect::<Vec<_>>();\n-        Ok(res)\n-    }\n-    pub(crate) fn index_resolve(&self, name_ref: &ast::NameRef) -> Cancelable<Vec<FileSymbol>> {\n-        let name = name_ref.text();\n-        let mut query = Query::new(name.to_string());\n-        query.exact();\n-        query.limit(4);\n-        crate::symbol_index::world_symbols(self, query)\n-    }\n-}\n-\n-impl SourceChange {\n-    pub(crate) fn from_local_edit(file_id: FileId, edit: LocalEdit) -> SourceChange {\n-        let file_edit = SourceFileEdit {\n-            file_id,\n-            edit: edit.edit,\n-        };\n-        SourceChange {\n-            label: edit.label,\n-            source_file_edits: vec![file_edit],\n-            file_system_edits: vec![],\n-            cursor_position: edit\n-                .cursor_position\n-                .map(|offset| FilePosition { offset, file_id }),\n-        }\n-    }\n-}"}, {"sha": "183e3670691e7f6fa134a58820a8a3465967f015", "filename": "crates/ra_analysis/src/lib.rs", "status": "removed", "additions": 0, "deletions": 509, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,509 +0,0 @@\n-//! ra_analyzer crate provides \"ide-centric\" APIs for the rust-analyzer. What\n-//! powers this API are the `RootDatabase` struct, which defines a `salsa`\n-//! database, and the `ra_hir` crate, where majority of the analysis happens.\n-//! However, IDE specific bits of the analysis (most notably completion) happen\n-//! in this crate.\n-macro_rules! ctry {\n-    ($expr:expr) => {\n-        match $expr {\n-            None => return Ok(None),\n-            Some(it) => it,\n-        }\n-    };\n-}\n-\n-mod completion;\n-mod db;\n-mod goto_defenition;\n-mod imp;\n-pub mod mock_analysis;\n-mod runnables;\n-mod symbol_index;\n-\n-mod extend_selection;\n-mod hover;\n-mod call_info;\n-mod syntax_highlighting;\n-\n-use std::{fmt, sync::Arc};\n-\n-use ra_syntax::{SmolStr, SourceFile, TreePtr, SyntaxKind, TextRange, TextUnit};\n-use ra_text_edit::TextEdit;\n-use ra_db::{SyntaxDatabase, FilesDatabase, LocalSyntaxPtr};\n-use rayon::prelude::*;\n-use relative_path::RelativePathBuf;\n-use rustc_hash::FxHashMap;\n-use salsa::ParallelDatabase;\n-\n-use crate::{\n-    symbol_index::{FileSymbol, SymbolIndex},\n-    db::LineIndexDatabase,\n-};\n-\n-pub use crate::{\n-    completion::{CompletionItem, CompletionItemKind, InsertText},\n-    runnables::{Runnable, RunnableKind},\n-};\n-pub use ra_ide_api_light::{\n-    Fold, FoldKind, HighlightedRange, Severity, StructureNode,\n-    LineIndex, LineCol, translate_offset_with_edit,\n-};\n-pub use ra_db::{\n-    Cancelable, Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n-};\n-\n-#[derive(Default)]\n-pub struct AnalysisChange {\n-    new_roots: Vec<(SourceRootId, bool)>,\n-    roots_changed: FxHashMap<SourceRootId, RootChange>,\n-    files_changed: Vec<(FileId, Arc<String>)>,\n-    libraries_added: Vec<LibraryData>,\n-    crate_graph: Option<CrateGraph>,\n-}\n-\n-#[derive(Default)]\n-struct RootChange {\n-    added: Vec<AddFile>,\n-    removed: Vec<RemoveFile>,\n-}\n-\n-#[derive(Debug)]\n-struct AddFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-    text: Arc<String>,\n-}\n-\n-#[derive(Debug)]\n-struct RemoveFile {\n-    file_id: FileId,\n-    path: RelativePathBuf,\n-}\n-\n-impl fmt::Debug for AnalysisChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let mut d = fmt.debug_struct(\"AnalysisChange\");\n-        if !self.new_roots.is_empty() {\n-            d.field(\"new_roots\", &self.new_roots);\n-        }\n-        if !self.roots_changed.is_empty() {\n-            d.field(\"roots_changed\", &self.roots_changed);\n-        }\n-        if !self.files_changed.is_empty() {\n-            d.field(\"files_changed\", &self.files_changed.len());\n-        }\n-        if !self.libraries_added.is_empty() {\n-            d.field(\"libraries_added\", &self.libraries_added.len());\n-        }\n-        if !self.crate_graph.is_some() {\n-            d.field(\"crate_graph\", &self.crate_graph);\n-        }\n-        d.finish()\n-    }\n-}\n-\n-impl fmt::Debug for RootChange {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_struct(\"AnalysisChange\")\n-            .field(\"added\", &self.added.len())\n-            .field(\"removed\", &self.removed.len())\n-            .finish()\n-    }\n-}\n-\n-impl AnalysisChange {\n-    pub fn new() -> AnalysisChange {\n-        AnalysisChange::default()\n-    }\n-    pub fn add_root(&mut self, root_id: SourceRootId, is_local: bool) {\n-        self.new_roots.push((root_id, is_local));\n-    }\n-    pub fn add_file(\n-        &mut self,\n-        root_id: SourceRootId,\n-        file_id: FileId,\n-        path: RelativePathBuf,\n-        text: Arc<String>,\n-    ) {\n-        let file = AddFile {\n-            file_id,\n-            path,\n-            text,\n-        };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .added\n-            .push(file);\n-    }\n-    pub fn change_file(&mut self, file_id: FileId, new_text: Arc<String>) {\n-        self.files_changed.push((file_id, new_text))\n-    }\n-    pub fn remove_file(&mut self, root_id: SourceRootId, file_id: FileId, path: RelativePathBuf) {\n-        let file = RemoveFile { file_id, path };\n-        self.roots_changed\n-            .entry(root_id)\n-            .or_default()\n-            .removed\n-            .push(file);\n-    }\n-    pub fn add_library(&mut self, data: LibraryData) {\n-        self.libraries_added.push(data)\n-    }\n-    pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n-        self.crate_graph = Some(graph);\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct SourceChange {\n-    pub label: String,\n-    pub source_file_edits: Vec<SourceFileEdit>,\n-    pub file_system_edits: Vec<FileSystemEdit>,\n-    pub cursor_position: Option<FilePosition>,\n-}\n-\n-#[derive(Debug)]\n-pub struct SourceFileEdit {\n-    pub file_id: FileId,\n-    pub edit: TextEdit,\n-}\n-\n-#[derive(Debug)]\n-pub enum FileSystemEdit {\n-    CreateFile {\n-        source_root: SourceRootId,\n-        path: RelativePathBuf,\n-    },\n-    MoveFile {\n-        src: FileId,\n-        dst_source_root: SourceRootId,\n-        dst_path: RelativePathBuf,\n-    },\n-}\n-\n-#[derive(Debug)]\n-pub struct Diagnostic {\n-    pub message: String,\n-    pub range: TextRange,\n-    pub fix: Option<SourceChange>,\n-    pub severity: Severity,\n-}\n-\n-#[derive(Debug)]\n-pub struct Query {\n-    query: String,\n-    lowercased: String,\n-    only_types: bool,\n-    libs: bool,\n-    exact: bool,\n-    limit: usize,\n-}\n-\n-impl Query {\n-    pub fn new(query: String) -> Query {\n-        let lowercased = query.to_lowercase();\n-        Query {\n-            query,\n-            lowercased,\n-            only_types: false,\n-            libs: false,\n-            exact: false,\n-            limit: usize::max_value(),\n-        }\n-    }\n-    pub fn only_types(&mut self) {\n-        self.only_types = true;\n-    }\n-    pub fn libs(&mut self) {\n-        self.libs = true;\n-    }\n-    pub fn exact(&mut self) {\n-        self.exact = true;\n-    }\n-    pub fn limit(&mut self, limit: usize) {\n-        self.limit = limit\n-    }\n-}\n-\n-/// `NavigationTarget` represents and element in the editor's UI whihc you can\n-/// click on to navigate to a particular piece of code.\n-///\n-/// Typically, a `NavigationTarget` corresponds to some element in the source\n-/// code, like a function or a struct, but this is not strictly required.\n-#[derive(Debug, Clone)]\n-pub struct NavigationTarget {\n-    file_id: FileId,\n-    name: SmolStr,\n-    kind: SyntaxKind,\n-    range: TextRange,\n-    // Should be DefId ideally\n-    ptr: Option<LocalSyntaxPtr>,\n-}\n-\n-impl NavigationTarget {\n-    fn from_symbol(symbol: FileSymbol) -> NavigationTarget {\n-        NavigationTarget {\n-            file_id: symbol.file_id,\n-            name: symbol.name.clone(),\n-            kind: symbol.ptr.kind(),\n-            range: symbol.ptr.range(),\n-            ptr: Some(symbol.ptr.clone()),\n-        }\n-    }\n-    pub fn name(&self) -> &SmolStr {\n-        &self.name\n-    }\n-    pub fn kind(&self) -> SyntaxKind {\n-        self.kind\n-    }\n-    pub fn file_id(&self) -> FileId {\n-        self.file_id\n-    }\n-    pub fn range(&self) -> TextRange {\n-        self.range\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct RangeInfo<T> {\n-    pub range: TextRange,\n-    pub info: T,\n-}\n-\n-impl<T> RangeInfo<T> {\n-    fn new(range: TextRange, info: T) -> RangeInfo<T> {\n-        RangeInfo { range, info }\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct CallInfo {\n-    pub label: String,\n-    pub doc: Option<String>,\n-    pub parameters: Vec<String>,\n-    pub active_parameter: Option<usize>,\n-}\n-\n-/// `AnalysisHost` stores the current state of the world.\n-#[derive(Debug, Default)]\n-pub struct AnalysisHost {\n-    db: db::RootDatabase,\n-}\n-\n-impl AnalysisHost {\n-    /// Returns a snapshot of the current state, which you can query for\n-    /// semantic information.\n-    pub fn analysis(&self) -> Analysis {\n-        Analysis {\n-            db: self.db.snapshot(),\n-        }\n-    }\n-    /// Applies changes to the current state of the world. If there are\n-    /// outstanding snapshots, they will be canceled.\n-    pub fn apply_change(&mut self, change: AnalysisChange) {\n-        self.db.apply_change(change)\n-    }\n-}\n-\n-/// Analysis is a snapshot of a world state at a moment in time. It is the main\n-/// entry point for asking semantic information about the world. When the world\n-/// state is advanced using `AnalysisHost::apply_change` method, all existing\n-/// `Analysis` are canceled (most method return `Err(Canceled)`).\n-#[derive(Debug)]\n-pub struct Analysis {\n-    db: salsa::Snapshot<db::RootDatabase>,\n-}\n-\n-impl Analysis {\n-    /// Gets the text of the source file.\n-    pub fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        self.db.file_text(file_id)\n-    }\n-    /// Gets the syntax tree of the file.\n-    pub fn file_syntax(&self, file_id: FileId) -> TreePtr<SourceFile> {\n-        self.db.source_file(file_id).clone()\n-    }\n-    /// Gets the file's `LineIndex`: data structure to convert between absolute\n-    /// offsets and line/column representation.\n-    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.db.line_index(file_id)\n-    }\n-    /// Selects the next syntactic nodes encopasing the range.\n-    pub fn extend_selection(&self, frange: FileRange) -> TextRange {\n-        extend_selection::extend_selection(&self.db, frange)\n-    }\n-    /// Returns position of the mathcing brace (all types of braces are\n-    /// supported).\n-    pub fn matching_brace(&self, file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n-        ra_ide_api_light::matching_brace(file, offset)\n-    }\n-    /// Returns a syntax tree represented as `String`, for debug purposes.\n-    // FIXME: use a better name here.\n-    pub fn syntax_tree(&self, file_id: FileId) -> String {\n-        let file = self.db.source_file(file_id);\n-        ra_ide_api_light::syntax_tree(&file)\n-    }\n-    /// Returns an edit to remove all newlines in the range, cleaning up minor\n-    /// stuff like trailing commas.\n-    pub fn join_lines(&self, frange: FileRange) -> SourceChange {\n-        let file = self.db.source_file(frange.file_id);\n-        SourceChange::from_local_edit(\n-            frange.file_id,\n-            ra_ide_api_light::join_lines(&file, frange.range),\n-        )\n-    }\n-    /// Returns an edit which should be applied when opening a new line, fixing\n-    /// up minor stuff like continuing the comment.\n-    pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.db.source_file(position.file_id);\n-        let edit = ra_ide_api_light::on_enter(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n-    }\n-    /// Returns an edit which should be applied after `=` was typed. Primarily,\n-    /// this works when adding `let =`.\n-    // FIXME: use a snippet completion instead of this hack here.\n-    pub fn on_eq_typed(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.db.source_file(position.file_id);\n-        let edit = ra_ide_api_light::on_eq_typed(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n-    }\n-    /// Returns an edit which should be applied when a dot ('.') is typed on a blank line, indenting the line appropriately.\n-    pub fn on_dot_typed(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.db.source_file(position.file_id);\n-        let edit = ra_ide_api_light::on_dot_typed(&file, position.offset)?;\n-        Some(SourceChange::from_local_edit(position.file_id, edit))\n-    }\n-    /// Returns a tree representation of symbols in the file. Useful to draw a\n-    /// file outline.\n-    pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n-        let file = self.db.source_file(file_id);\n-        ra_ide_api_light::file_structure(&file)\n-    }\n-    /// Returns the set of folding ranges.\n-    pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n-        let file = self.db.source_file(file_id);\n-        ra_ide_api_light::folding_ranges(&file)\n-    }\n-    /// Fuzzy searches for a symbol.\n-    pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n-        let res = symbol_index::world_symbols(&*self.db, query)?\n-            .into_iter()\n-            .map(NavigationTarget::from_symbol)\n-            .collect();\n-        Ok(res)\n-    }\n-    pub fn goto_defenition(\n-        &self,\n-        position: FilePosition,\n-    ) -> Cancelable<Option<Vec<NavigationTarget>>> {\n-        goto_defenition::goto_defenition(&*self.db, position)\n-    }\n-    /// Finds all usages of the reference at point.\n-    pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        self.db.find_all_refs(position)\n-    }\n-    /// Returns a short text descrbing element at position.\n-    pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n-        hover::hover(&*self.db, position)\n-    }\n-    /// Computes parameter information for the given call expression.\n-    pub fn call_info(&self, position: FilePosition) -> Cancelable<Option<CallInfo>> {\n-        call_info::call_info(&*self.db, position)\n-    }\n-    /// Returns a `mod name;` declaration which created the current module.\n-    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        self.db.parent_module(position)\n-    }\n-    /// Returns crates this file belongs too.\n-    pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        self.db.crate_for(file_id)\n-    }\n-    /// Returns the root file of the given crate.\n-    pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n-        Ok(self.db.crate_graph().crate_root(crate_id))\n-    }\n-    /// Returns the set of possible targets to run for the current file.\n-    pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n-        runnables::runnables(&*self.db, file_id)\n-    }\n-    /// Computes syntax highlighting for the given file.\n-    pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n-        syntax_highlighting::highlight(&*self.db, file_id)\n-    }\n-    /// Computes completions at the given position.\n-    pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        let completions = completion::completions(&self.db, position)?;\n-        Ok(completions.map(|it| it.into()))\n-    }\n-    /// Computes assists (aks code actons aka intentions) for the given\n-    /// position.\n-    pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<SourceChange>> {\n-        Ok(self.db.assists(frange))\n-    }\n-    /// Computes the set of diagnostics for the given file.\n-    pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        self.db.diagnostics(file_id)\n-    }\n-    /// Computes the type of the expression at the given position.\n-    pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        hover::type_of(&*self.db, frange)\n-    }\n-    /// Returns the edit required to rename reference at the position to the new\n-    /// name.\n-    pub fn rename(\n-        &self,\n-        position: FilePosition,\n-        new_name: &str,\n-    ) -> Cancelable<Vec<SourceFileEdit>> {\n-        self.db.rename(position, new_name)\n-    }\n-}\n-\n-pub struct LibraryData {\n-    root_id: SourceRootId,\n-    root_change: RootChange,\n-    symbol_index: SymbolIndex,\n-}\n-\n-impl fmt::Debug for LibraryData {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"LibraryData\")\n-            .field(\"root_id\", &self.root_id)\n-            .field(\"root_change\", &self.root_change)\n-            .field(\"n_symbols\", &self.symbol_index.len())\n-            .finish()\n-    }\n-}\n-\n-impl LibraryData {\n-    pub fn prepare(\n-        root_id: SourceRootId,\n-        files: Vec<(FileId, RelativePathBuf, Arc<String>)>,\n-    ) -> LibraryData {\n-        let symbol_index = SymbolIndex::for_files(files.par_iter().map(|(file_id, _, text)| {\n-            let file = SourceFile::parse(text);\n-            (*file_id, file)\n-        }));\n-        let mut root_change = RootChange::default();\n-        root_change.added = files\n-            .into_iter()\n-            .map(|(file_id, path, text)| AddFile {\n-                file_id,\n-                path,\n-                text,\n-            })\n-            .collect();\n-        LibraryData {\n-            root_id,\n-            root_change,\n-            symbol_index,\n-        }\n-    }\n-}\n-\n-#[test]\n-fn analysis_is_send() {\n-    fn is_send<T: Send>() {}\n-    is_send::<Analysis>();\n-}"}, {"sha": "846c76cfe7ae2abf668b5ac26c86a918a8461588", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,135 +0,0 @@\n-use std::sync::Arc;\n-\n-use relative_path::RelativePathBuf;\n-use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n-use ra_db::mock::FileMap;\n-\n-use crate::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, FilePosition, FileRange, SourceRootId};\n-\n-/// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n-/// from a set of in-memory files.\n-#[derive(Debug, Default)]\n-pub struct MockAnalysis {\n-    files: Vec<(String, String)>,\n-}\n-\n-impl MockAnalysis {\n-    pub fn new() -> MockAnalysis {\n-        MockAnalysis::default()\n-    }\n-    /// Creates `MockAnalysis` using a fixture data in the following format:\n-    ///\n-    /// ```notrust\n-    /// //- /main.rs\n-    /// mod foo;\n-    /// fn main() {}\n-    ///\n-    /// //- /foo.rs\n-    /// struct Baz;\n-    /// ```\n-    pub fn with_files(fixture: &str) -> MockAnalysis {\n-        let mut res = MockAnalysis::new();\n-        for entry in parse_fixture(fixture) {\n-            res.add_file(&entry.meta, &entry.text);\n-        }\n-        res\n-    }\n-\n-    /// Same as `with_files`, but requires that a single file contains a `<|>` marker,\n-    /// whose position is also returned.\n-    pub fn with_files_and_position(fixture: &str) -> (MockAnalysis, FilePosition) {\n-        let mut position = None;\n-        let mut res = MockAnalysis::new();\n-        for entry in parse_fixture(fixture) {\n-            if entry.text.contains(CURSOR_MARKER) {\n-                assert!(\n-                    position.is_none(),\n-                    \"only one marker (<|>) per fixture is allowed\"\n-                );\n-                position = Some(res.add_file_with_position(&entry.meta, &entry.text));\n-            } else {\n-                res.add_file(&entry.meta, &entry.text);\n-            }\n-        }\n-        let position = position.expect(\"expected a marker (<|>)\");\n-        (res, position)\n-    }\n-\n-    pub fn add_file(&mut self, path: &str, text: &str) -> FileId {\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n-        file_id\n-    }\n-    pub fn add_file_with_position(&mut self, path: &str, text: &str) -> FilePosition {\n-        let (offset, text) = extract_offset(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n-        FilePosition { file_id, offset }\n-    }\n-    pub fn add_file_with_range(&mut self, path: &str, text: &str) -> FileRange {\n-        let (range, text) = extract_range(text);\n-        let file_id = FileId((self.files.len() + 1) as u32);\n-        self.files.push((path.to_string(), text.to_string()));\n-        FileRange { file_id, range }\n-    }\n-    pub fn id_of(&self, path: &str) -> FileId {\n-        let (idx, _) = self\n-            .files\n-            .iter()\n-            .enumerate()\n-            .find(|(_, (p, _text))| path == p)\n-            .expect(\"no file in this mock\");\n-        FileId(idx as u32 + 1)\n-    }\n-    pub fn analysis_host(self) -> AnalysisHost {\n-        let mut host = AnalysisHost::default();\n-        let mut file_map = FileMap::default();\n-        let source_root = SourceRootId(0);\n-        let mut change = AnalysisChange::new();\n-        change.add_root(source_root, true);\n-        let mut crate_graph = CrateGraph::default();\n-        for (path, contents) in self.files.into_iter() {\n-            assert!(path.starts_with('/'));\n-            let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-            let file_id = file_map.add(path.clone());\n-            if path == \"/lib.rs\" || path == \"/main.rs\" {\n-                crate_graph.add_crate_root(file_id);\n-            }\n-            change.add_file(source_root, file_id, path, Arc::new(contents));\n-        }\n-        change.set_crate_graph(crate_graph);\n-        // change.set_file_resolver(Arc::new(file_map));\n-        host.apply_change(change);\n-        host\n-    }\n-    pub fn analysis(self) -> Analysis {\n-        self.analysis_host().analysis()\n-    }\n-}\n-\n-/// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n-pub fn analysis_and_position(fixture: &str) -> (Analysis, FilePosition) {\n-    let (mock, position) = MockAnalysis::with_files_and_position(fixture);\n-    (mock.analysis(), position)\n-}\n-\n-/// Creates analysis for a single file.\n-pub fn single_file(code: &str) -> (Analysis, FileId) {\n-    let mut mock = MockAnalysis::new();\n-    let file_id = mock.add_file(\"/main.rs\", code);\n-    (mock.analysis(), file_id)\n-}\n-\n-/// Creates analysis for a single file, returns position marked with <|>.\n-pub fn single_file_with_position(code: &str) -> (Analysis, FilePosition) {\n-    let mut mock = MockAnalysis::new();\n-    let pos = mock.add_file_with_position(\"/main.rs\", code);\n-    (mock.analysis(), pos)\n-}\n-\n-/// Creates analysis for a single file, returns range marked with a pair of <|>.\n-pub fn single_file_with_range(code: &str) -> (Analysis, FileRange) {\n-    let mut mock = MockAnalysis::new();\n-    let pos = mock.add_file_with_range(\"/main.rs\", code);\n-    (mock.analysis(), pos)\n-}"}, {"sha": "98b1d2d5521170cc57d3ab4767d8da72a37500b3", "filename": "crates/ra_analysis/src/runnables.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Frunnables.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,89 +0,0 @@\n-use itertools::Itertools;\n-use ra_syntax::{\n-    TextRange, SyntaxNode,\n-    ast::{self, AstNode, NameOwner, ModuleItemOwner},\n-};\n-use ra_db::{Cancelable, SyntaxDatabase};\n-\n-use crate::{db::RootDatabase, FileId};\n-\n-#[derive(Debug)]\n-pub struct Runnable {\n-    pub range: TextRange,\n-    pub kind: RunnableKind,\n-}\n-\n-#[derive(Debug)]\n-pub enum RunnableKind {\n-    Test { name: String },\n-    TestMod { path: String },\n-    Bin,\n-}\n-\n-pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n-    let source_file = db.source_file(file_id);\n-    let res = source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(|i| runnable(db, file_id, i))\n-        .collect();\n-    Ok(res)\n-}\n-\n-fn runnable(db: &RootDatabase, file_id: FileId, item: &SyntaxNode) -> Option<Runnable> {\n-    if let Some(fn_def) = ast::FnDef::cast(item) {\n-        runnable_fn(fn_def)\n-    } else if let Some(m) = ast::Module::cast(item) {\n-        runnable_mod(db, file_id, m)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn runnable_fn(fn_def: &ast::FnDef) -> Option<Runnable> {\n-    let name = fn_def.name()?.text();\n-    let kind = if name == \"main\" {\n-        RunnableKind::Bin\n-    } else if fn_def.has_atom_attr(\"test\") {\n-        RunnableKind::Test {\n-            name: name.to_string(),\n-        }\n-    } else {\n-        return None;\n-    };\n-    Some(Runnable {\n-        range: fn_def.syntax().range(),\n-        kind,\n-    })\n-}\n-\n-fn runnable_mod(db: &RootDatabase, file_id: FileId, module: &ast::Module) -> Option<Runnable> {\n-    let has_test_function = module\n-        .item_list()?\n-        .items()\n-        .filter_map(|it| match it.kind() {\n-            ast::ModuleItemKind::FnDef(it) => Some(it),\n-            _ => None,\n-        })\n-        .any(|f| f.has_atom_attr(\"test\"));\n-    if !has_test_function {\n-        return None;\n-    }\n-    let range = module.syntax().range();\n-    let module =\n-        hir::source_binder::module_from_child_node(db, file_id, module.syntax()).ok()??;\n-\n-    // FIXME: thread cancellation instead of `.ok`ing\n-    let path = module\n-        .path_to_root(db)\n-        .ok()?\n-        .into_iter()\n-        .rev()\n-        .filter_map(|it| it.name(db).ok())\n-        .filter_map(|it| it)\n-        .join(\"::\");\n-    Some(Runnable {\n-        range,\n-        kind: RunnableKind::TestMod { path },\n-    })\n-}"}, {"sha": "8dd15b40e573b413f618dd4637e40d37160de90e", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "removed", "additions": 0, "deletions": 222, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,222 +0,0 @@\n-//! This module handles fuzzy-searching of functions, structs and other symbols\n-//! by name across the whole workspace and dependencies.\n-//!\n-//! It works by building an incrementally-updated text-search index of all\n-//! symbols. The backbone of the index is the **awesome** `fst` crate by\n-//! @BurntSushi.\n-//!\n-//! In a nutshell, you give a set of strings to the `fst`, and it builds a\n-//! finite state machine describing this set of strtings. The strings which\n-//! could fuzzy-match a pattern can also be described by a finite state machine.\n-//! What is freakingly cool is that you can now traverse both state machines in\n-//! lock-step to enumerate the strings which are both in the input set and\n-//! fuzz-match the query. Or, more formally, given two langauges described by\n-//! fsts, one can build an product fst which describes the intersection of the\n-//! languages.\n-//!\n-//! `fst` does not support cheap updating of the index, but it supports unioning\n-//! of state machines. So, to account for changing source code, we build an fst\n-//! for each library (which is assumed to never change) and an fst for each rust\n-//! file in the current workspace, and run a query aginst the union of all\n-//! thouse fsts.\n-use std::{\n-    cmp::Ordering,\n-    hash::{Hash, Hasher},\n-    sync::Arc,\n-};\n-\n-use fst::{self, Streamer};\n-use ra_syntax::{\n-    SyntaxNode, SourceFile, SmolStr, TreePtr, AstNode,\n-    algo::{visit::{visitor, Visitor}, find_covering_node},\n-    SyntaxKind::{self, *},\n-    ast::{self, NameOwner},\n-};\n-use ra_db::{SourceRootId, FilesDatabase, LocalSyntaxPtr};\n-use salsa::ParallelDatabase;\n-use rayon::prelude::*;\n-\n-use crate::{\n-    Cancelable, FileId, Query,\n-    db::RootDatabase,\n-};\n-\n-salsa::query_group! {\n-    pub(crate) trait SymbolsDatabase: hir::db::HirDatabase {\n-        fn file_symbols(file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n-            type FileSymbolsQuery;\n-        }\n-        fn library_symbols(id: SourceRootId) -> Arc<SymbolIndex> {\n-            type LibrarySymbolsQuery;\n-            storage input;\n-        }\n-    }\n-}\n-\n-fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n-    db.check_canceled()?;\n-    let source_file = db.source_file(file_id);\n-    let mut symbols = source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(to_symbol)\n-        .map(move |(name, ptr)| FileSymbol { name, ptr, file_id })\n-        .collect::<Vec<_>>();\n-\n-    for (name, text_range) in hir::source_binder::macro_symbols(db, file_id)? {\n-        let node = find_covering_node(source_file.syntax(), text_range);\n-        let ptr = LocalSyntaxPtr::new(node);\n-        symbols.push(FileSymbol { file_id, name, ptr })\n-    }\n-\n-    Ok(Arc::new(SymbolIndex::new(symbols)))\n-}\n-\n-pub(crate) fn world_symbols(db: &RootDatabase, query: Query) -> Cancelable<Vec<FileSymbol>> {\n-    /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-    struct Snap(salsa::Snapshot<RootDatabase>);\n-    impl Clone for Snap {\n-        fn clone(&self) -> Snap {\n-            Snap(self.0.snapshot())\n-        }\n-    }\n-\n-    let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n-        let snap = Snap(db.snapshot());\n-        db.library_roots()\n-            .par_iter()\n-            .map_with(snap, |db, &lib_id| db.0.library_symbols(lib_id))\n-            .collect()\n-    } else {\n-        let mut files = Vec::new();\n-        for &root in db.local_roots().iter() {\n-            let sr = db.source_root(root);\n-            files.extend(sr.files.values().map(|&it| it))\n-        }\n-\n-        let snap = Snap(db.snapshot());\n-        files\n-            .par_iter()\n-            .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-            .filter_map(|it| it.ok())\n-            .collect()\n-    };\n-    Ok(query.search(&buf))\n-}\n-\n-#[derive(Default, Debug)]\n-pub(crate) struct SymbolIndex {\n-    symbols: Vec<FileSymbol>,\n-    map: fst::Map,\n-}\n-\n-impl PartialEq for SymbolIndex {\n-    fn eq(&self, other: &SymbolIndex) -> bool {\n-        self.symbols == other.symbols\n-    }\n-}\n-\n-impl Eq for SymbolIndex {}\n-\n-impl Hash for SymbolIndex {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.symbols.hash(hasher)\n-    }\n-}\n-\n-impl SymbolIndex {\n-    fn new(mut symbols: Vec<FileSymbol>) -> SymbolIndex {\n-        fn cmp(s1: &FileSymbol, s2: &FileSymbol) -> Ordering {\n-            unicase::Ascii::new(s1.name.as_str()).cmp(&unicase::Ascii::new(s2.name.as_str()))\n-        }\n-        symbols.par_sort_by(cmp);\n-        symbols.dedup_by(|s1, s2| cmp(s1, s2) == Ordering::Equal);\n-        let names = symbols.iter().map(|it| it.name.as_str().to_lowercase());\n-        let map = fst::Map::from_iter(names.into_iter().zip(0u64..)).unwrap();\n-        SymbolIndex { symbols, map }\n-    }\n-\n-    pub(crate) fn len(&self) -> usize {\n-        self.symbols.len()\n-    }\n-\n-    pub(crate) fn for_files(\n-        files: impl ParallelIterator<Item = (FileId, TreePtr<SourceFile>)>,\n-    ) -> SymbolIndex {\n-        let symbols = files\n-            .flat_map(|(file_id, file)| {\n-                file.syntax()\n-                    .descendants()\n-                    .filter_map(to_symbol)\n-                    .map(move |(name, ptr)| FileSymbol { name, ptr, file_id })\n-                    .collect::<Vec<_>>()\n-            })\n-            .collect::<Vec<_>>();\n-        SymbolIndex::new(symbols)\n-    }\n-}\n-\n-impl Query {\n-    pub(crate) fn search(self, indices: &[Arc<SymbolIndex>]) -> Vec<FileSymbol> {\n-        let mut op = fst::map::OpBuilder::new();\n-        for file_symbols in indices.iter() {\n-            let automaton = fst::automaton::Subsequence::new(&self.lowercased);\n-            op = op.add(file_symbols.map.search(automaton))\n-        }\n-        let mut stream = op.union();\n-        let mut res = Vec::new();\n-        while let Some((_, indexed_values)) = stream.next() {\n-            if res.len() >= self.limit {\n-                break;\n-            }\n-            for indexed_value in indexed_values {\n-                let file_symbols = &indices[indexed_value.index];\n-                let idx = indexed_value.value as usize;\n-\n-                let symbol = &file_symbols.symbols[idx];\n-                if self.only_types && !is_type(symbol.ptr.kind()) {\n-                    continue;\n-                }\n-                if self.exact && symbol.name != self.query {\n-                    continue;\n-                }\n-                res.push(symbol.clone());\n-            }\n-        }\n-        res\n-    }\n-}\n-\n-fn is_type(kind: SyntaxKind) -> bool {\n-    match kind {\n-        STRUCT_DEF | ENUM_DEF | TRAIT_DEF | TYPE_DEF => true,\n-        _ => false,\n-    }\n-}\n-\n-/// The actual data that is stored in the index. It should be as compact as\n-/// possible.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct FileSymbol {\n-    pub(crate) file_id: FileId,\n-    pub(crate) name: SmolStr,\n-    pub(crate) ptr: LocalSyntaxPtr,\n-}\n-\n-fn to_symbol(node: &SyntaxNode) -> Option<(SmolStr, LocalSyntaxPtr)> {\n-    fn decl<N: NameOwner>(node: &N) -> Option<(SmolStr, LocalSyntaxPtr)> {\n-        let name = node.name()?.text().clone();\n-        let ptr = LocalSyntaxPtr::new(node.syntax());\n-        Some((name, ptr))\n-    }\n-    visitor()\n-        .visit(decl::<ast::FnDef>)\n-        .visit(decl::<ast::StructDef>)\n-        .visit(decl::<ast::EnumDef>)\n-        .visit(decl::<ast::TraitDef>)\n-        .visit(decl::<ast::Module>)\n-        .visit(decl::<ast::TypeDef>)\n-        .visit(decl::<ast::ConstDef>)\n-        .visit(decl::<ast::StaticDef>)\n-        .accept(node)?\n-}"}, {"sha": "cb19e9515a14f1e4ca34d136b79b073dd753afe7", "filename": "crates/ra_analysis/src/syntax_highlighting.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsyntax_highlighting.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,92 +0,0 @@\n-use ra_syntax::{ast, AstNode,};\n-use ra_db::SyntaxDatabase;\n-\n-use crate::{\n-    FileId, Cancelable, HighlightedRange,\n-    db::RootDatabase,\n-};\n-\n-pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n-    let source_file = db.source_file(file_id);\n-    let mut res = ra_ide_api_light::highlight(source_file.syntax());\n-    for macro_call in source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::MacroCall::cast)\n-    {\n-        if let Some((off, exp)) = hir::MacroDef::ast_expand(macro_call) {\n-            let mapped_ranges = ra_ide_api_light::highlight(&exp.syntax())\n-                .into_iter()\n-                .filter_map(|r| {\n-                    let mapped_range = exp.map_range_back(r.range)?;\n-                    let res = HighlightedRange {\n-                        range: mapped_range + off,\n-                        tag: r.tag,\n-                    };\n-                    Some(res)\n-                });\n-            res.extend(mapped_ranges);\n-        }\n-    }\n-    Ok(res)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::mock_analysis::single_file;\n-    use test_utils::assert_eq_dbg;\n-\n-    #[test]\n-    fn highlights_code_inside_macros() {\n-        let (analysis, file_id) = single_file(\n-            \"\n-            fn main() {\n-                ctry!({ let x = 92; x});\n-                vec![{ let x = 92; x}];\n-            }\n-            \",\n-        );\n-        let highlights = analysis.highlight(file_id).unwrap();\n-        assert_eq_dbg(\n-            r#\"[HighlightedRange { range: [13; 15), tag: \"keyword\" },\n-                HighlightedRange { range: [16; 20), tag: \"function\" },\n-                HighlightedRange { range: [41; 46), tag: \"macro\" },\n-                HighlightedRange { range: [49; 52), tag: \"keyword\" },\n-                HighlightedRange { range: [57; 59), tag: \"literal\" },\n-                HighlightedRange { range: [82; 86), tag: \"macro\" },\n-                HighlightedRange { range: [89; 92), tag: \"keyword\" },\n-                HighlightedRange { range: [97; 99), tag: \"literal\" },\n-                HighlightedRange { range: [49; 52), tag: \"keyword\" },\n-                HighlightedRange { range: [53; 54), tag: \"function\" },\n-                HighlightedRange { range: [57; 59), tag: \"literal\" },\n-                HighlightedRange { range: [61; 62), tag: \"text\" },\n-                HighlightedRange { range: [89; 92), tag: \"keyword\" },\n-                HighlightedRange { range: [93; 94), tag: \"function\" },\n-                HighlightedRange { range: [97; 99), tag: \"literal\" },\n-                HighlightedRange { range: [101; 102), tag: \"text\" }]\"#,\n-            &highlights,\n-        )\n-    }\n-\n-    // FIXME: this test is not really necessary: artifact of the inital hacky\n-    // macros implementation.\n-    #[test]\n-    fn highlight_query_group_macro() {\n-        let (analysis, file_id) = single_file(\n-            \"\n-            salsa::query_group! {\n-                pub trait HirDatabase: SyntaxDatabase {}\n-            }\n-            \",\n-        );\n-        let highlights = analysis.highlight(file_id).unwrap();\n-        assert_eq_dbg(\n-            r#\"[HighlightedRange { range: [20; 32), tag: \"macro\" },\n-                HighlightedRange { range: [13; 18), tag: \"text\" },\n-                HighlightedRange { range: [51; 54), tag: \"keyword\" },\n-                HighlightedRange { range: [55; 60), tag: \"keyword\" },\n-                HighlightedRange { range: [61; 72), tag: \"function\" }]\"#,\n-            &highlights,\n-        )\n-    }\n-}"}, {"sha": "2c0735cb50cf433d6f5c980f7fb9bc1725908172", "filename": "crates/ra_analysis/tests/test/main.rs", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Fmain.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,249 +0,0 @@\n-mod runnables;\n-\n-use ra_syntax::TextRange;\n-use test_utils::{assert_eq_dbg, assert_eq_text};\n-\n-use ra_analysis::{\n-    mock_analysis::{analysis_and_position, single_file, single_file_with_position, MockAnalysis},\n-    AnalysisChange, CrateGraph, FileId, Query\n-};\n-\n-#[test]\n-fn test_unresolved_module_diagnostic() {\n-    let (analysis, file_id) = single_file(\"mod foo;\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert_eq_dbg(\n-        r#\"[Diagnostic {\n-            message: \"unresolved module\",\n-            range: [4; 7),\n-            fix: Some(SourceChange {\n-                label: \"create module\",\n-                source_file_edits: [],\n-                file_system_edits: [CreateFile { source_root: SourceRootId(0), path: \"foo.rs\" }],\n-                cursor_position: None }),\n-                severity: Error }]\"#,\n-        &diagnostics,\n-    );\n-}\n-\n-// FIXME: move this test to hir\n-#[test]\n-fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n-    let (analysis, file_id) = single_file(\"mod foo {}\");\n-    let diagnostics = analysis.diagnostics(file_id).unwrap();\n-    assert_eq_dbg(r#\"[]\"#, &diagnostics);\n-}\n-\n-#[test]\n-fn test_resolve_parent_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        //- /foo.rs\n-        <|>// empty\n-    \",\n-    );\n-    let symbols = analysis.parent_module(pos).unwrap();\n-    assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), name: \"foo\", kind: MODULE, range: [4; 7), ptr: None }]\"#,\n-        &symbols,\n-    );\n-}\n-\n-#[test]\n-fn test_resolve_parent_module_for_inline() {\n-    let (analysis, pos) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo {\n-            mod bar {\n-                mod baz { <|> }\n-            }\n-        }\n-    \",\n-    );\n-    let symbols = analysis.parent_module(pos).unwrap();\n-    assert_eq_dbg(\n-        r#\"[NavigationTarget { file_id: FileId(1), name: \"baz\", kind: MODULE, range: [36; 39), ptr: None }]\"#,\n-        &symbols,\n-    );\n-}\n-\n-#[test]\n-fn test_resolve_crate_root() {\n-    let mock = MockAnalysis::with_files(\n-        \"\n-        //- /bar.rs\n-        mod foo;\n-        //- /bar/foo.rs\n-        // emtpy <|>\n-    \",\n-    );\n-    let root_file = mock.id_of(\"/bar.rs\");\n-    let mod_file = mock.id_of(\"/bar/foo.rs\");\n-    let mut host = mock.analysis_host();\n-    assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n-\n-    let mut crate_graph = CrateGraph::default();\n-    let crate_id = crate_graph.add_crate_root(root_file);\n-    let mut change = AnalysisChange::new();\n-    change.set_crate_graph(crate_graph);\n-    host.apply_change(change);\n-\n-    assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n-}\n-\n-fn get_all_refs(text: &str) -> Vec<(FileId, TextRange)> {\n-    let (analysis, position) = single_file_with_position(text);\n-    analysis.find_all_refs(position).unwrap()\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_local() {\n-    let code = r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 5);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_param_inside() {\n-    let code = r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-\n-#[test]\n-fn test_find_all_refs_for_fn_param() {\n-    let code = r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#;\n-\n-    let refs = get_all_refs(code);\n-    assert_eq!(refs.len(), 2);\n-}\n-#[test]\n-fn test_rename_for_local() {\n-    test_rename(\n-        r#\"\n-    fn main() {\n-        let mut i = 1;\n-        let j = 1;\n-        i = i<|> + j;\n-\n-        {\n-            i = 0;\n-        }\n-\n-        i = 5;\n-    }\"#,\n-        \"k\",\n-        r#\"\n-    fn main() {\n-        let mut k = 1;\n-        let j = 1;\n-        k = k + j;\n-\n-        {\n-            k = 0;\n-        }\n-\n-        k = 5;\n-    }\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_rename_for_param_inside() {\n-    test_rename(\n-        r#\"\n-    fn foo(i : u32) -> u32 {\n-        i<|>\n-    }\"#,\n-        \"j\",\n-        r#\"\n-    fn foo(j : u32) -> u32 {\n-        j\n-    }\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_rename_refs_for_fn_param() {\n-    test_rename(\n-        r#\"\n-    fn foo(i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-        \"new_name\",\n-        r#\"\n-    fn foo(new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-    );\n-}\n-\n-#[test]\n-fn test_rename_for_mut_param() {\n-    test_rename(\n-        r#\"\n-    fn foo(mut i<|> : u32) -> u32 {\n-        i\n-    }\"#,\n-        \"new_name\",\n-        r#\"\n-    fn foo(mut new_name : u32) -> u32 {\n-        new_name\n-    }\"#,\n-    );\n-}\n-\n-fn test_rename(text: &str, new_name: &str, expected: &str) {\n-    let (analysis, position) = single_file_with_position(text);\n-    let edits = analysis.rename(position, new_name).unwrap();\n-    let mut text_edit_bulder = ra_text_edit::TextEditBuilder::default();\n-    let mut file_id: Option<FileId> = None;\n-    for edit in edits {\n-        file_id = Some(edit.file_id);\n-        for atom in edit.edit.as_atoms() {\n-            text_edit_bulder.replace(atom.delete, atom.insert.clone());\n-        }\n-    }\n-    let result = text_edit_bulder\n-        .finish()\n-        .apply(&*analysis.file_text(file_id.unwrap()));\n-    assert_eq_text!(expected, &*result);\n-}\n-\n-#[test]\n-fn world_symbols_include_stuff_from_macros() {\n-    let (analysis, _) = single_file(\n-        \"\n-salsa::query_group! {\n-pub trait HirDatabase: SyntaxDatabase {}\n-}\n-    \",\n-    );\n-\n-    let mut symbols = analysis.symbol_search(Query::new(\"Hir\".into())).unwrap();\n-    let s = symbols.pop().unwrap();\n-    assert_eq!(s.name(), \"HirDatabase\");\n-    assert_eq!(s.range(), TextRange::from_to(33.into(), 44.into()));\n-}"}, {"sha": "e6e0afbc317c9222324f923a9e80df949a8faea6", "filename": "crates/ra_analysis/tests/test/runnables.rs", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Ftests%2Ftest%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5/crates%2Fra_analysis%2Ftests%2Ftest%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftest%2Frunnables.rs?ref=fa3c9ce3921b6a3f67222bf4f9b4efdf4f11c2a5", "patch": "@@ -1,109 +0,0 @@\n-use test_utils::assert_eq_dbg;\n-\n-use ra_analysis::mock_analysis::analysis_and_position;\n-\n-#[test]\n-fn test_runnables() {\n-    let (analysis, pos) = analysis_and_position(\n-        r#\"\n-        //- /lib.rs\n-        <|> //empty\n-        fn main() {}\n-\n-        #[test]\n-        fn test_foo() {}\n-\n-        #[test]\n-        #[ignore]\n-        fn test_foo() {}\n-        \"#,\n-    );\n-    let runnables = analysis.runnables(pos.file_id).unwrap();\n-    assert_eq_dbg(\n-        r#\"[Runnable { range: [1; 21), kind: Bin },\n-                Runnable { range: [22; 46), kind: Test { name: \"test_foo\" } },\n-                Runnable { range: [47; 81), kind: Test { name: \"test_foo\" } }]\"#,\n-        &runnables,\n-    )\n-}\n-\n-#[test]\n-fn test_runnables_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        r#\"\n-        //- /lib.rs\n-        <|> //empty\n-        mod test_mod {\n-            #[test]\n-            fn test_foo1() {}\n-        }\n-        \"#,\n-    );\n-    let runnables = analysis.runnables(pos.file_id).unwrap();\n-    assert_eq_dbg(\n-        r#\"[Runnable { range: [1; 59), kind: TestMod { path: \"test_mod\" } },\n-                Runnable { range: [28; 57), kind: Test { name: \"test_foo1\" } }]\"#,\n-        &runnables,\n-    )\n-}\n-\n-#[test]\n-fn test_runnables_one_depth_layer_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        r#\"\n-        //- /lib.rs\n-        <|> //empty\n-        mod foo {\n-            mod test_mod {\n-                #[test]\n-                fn test_foo1() {}\n-            }\n-        }\n-        \"#,\n-    );\n-    let runnables = analysis.runnables(pos.file_id).unwrap();\n-    assert_eq_dbg(\n-        r#\"[Runnable { range: [23; 85), kind: TestMod { path: \"foo::test_mod\" } },\n-                Runnable { range: [46; 79), kind: Test { name: \"test_foo1\" } }]\"#,\n-        &runnables,\n-    )\n-}\n-\n-#[test]\n-fn test_runnables_multiple_depth_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        r#\"\n-        //- /lib.rs\n-        <|> //empty\n-        mod foo {\n-            mod bar {\n-                mod test_mod {\n-                    #[test]\n-                    fn test_foo1() {}\n-                }\n-            }\n-        }\n-        \"#,\n-    );\n-    let runnables = analysis.runnables(pos.file_id).unwrap();\n-    assert_eq_dbg(\n-        r#\"[Runnable { range: [41; 115), kind: TestMod { path: \"foo::bar::test_mod\" } },\n-                Runnable { range: [68; 105), kind: Test { name: \"test_foo1\" } }]\"#,\n-        &runnables,\n-    )\n-}\n-\n-#[test]\n-fn test_runnables_no_test_function_in_module() {\n-    let (analysis, pos) = analysis_and_position(\n-        r#\"\n-        //- /lib.rs\n-        <|> //empty\n-        mod test_mod {\n-            fn foo1() {}\n-        }\n-        \"#,\n-    );\n-    let runnables = analysis.runnables(pos.file_id).unwrap();\n-    assert_eq_dbg(r#\"[]\"#, &runnables)\n-}"}]}