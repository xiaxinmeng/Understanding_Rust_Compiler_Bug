{"sha": "70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwY2FjNTkwMzFkNWMzMzk2MmExZjUzY2RjYTkzNTljMGRjZDFmOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-29T19:37:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-29T19:37:28Z"}, "message": "Auto merge of #51361 - oli-obk:sanity_check_consts, r=nikomatsakis\n\nDo a basic sanity check for all constant values\n\n## Motivation and high level overview\n\nThere has been some back and forth in this PR between @RalfJung and me in here about the motivation for this change and the stance it takes on unsafe coding guidelines.\n\nThe initial implementation ran its checks on every value read (so `*x`, `y = x`, ...). In unsafe code that isn't reasonable, because we might be invalidating invariants for a short time in order to build up a proper value.\n\nThe current implementation is a lint that runs its checks statics and constants. There is no need to check array lengths and enum variants, because it's a hard error to end up with anything but a number, and that one even has to have the required bits to be defined.\n\n## What checks are done?\n\n* Some type related checks\n    * `char` needs to be a correct unicode character as defined by `char::from_u32`\n    * A reference to a ZST must have the correct alignment (and be nonzero)\n    * A reference to anything is dereferenced and its value is checked\n* Layout checks use the information from `ty::Layout` to check\n    * all fields of structs\n    * all elements of arrays\n    * enum discriminants\n    * the fields of an enum variant (the variant is decided by the discriminant)\n    * whether any union field succeeds in being checked (if none match the memory pattern, the check fails)\n    * if the value is in the range described by the layout (e.g. for `NonZero*` types)\n\nChanging the layout of a type will thus automatically cause the checks to check for the new layout.\n\nfixes #51330\nfixes #51471\n\ncc @RalfJung\n\nr? @eddyb", "tree": {"sha": "b82966fac9da50136b4380be12bebb51f75b48e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b82966fac9da50136b4380be12bebb51f75b48e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "html_url": "https://github.com/rust-lang/rust/commit/70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75af9df71b9eea84f281cf7de72c3e3cc2b02222", "url": "https://api.github.com/repos/rust-lang/rust/commits/75af9df71b9eea84f281cf7de72c3e3cc2b02222", "html_url": "https://github.com/rust-lang/rust/commit/75af9df71b9eea84f281cf7de72c3e3cc2b02222"}, {"sha": "86e59ccf34214e33273af145df13a771607dc42e", "url": "https://api.github.com/repos/rust-lang/rust/commits/86e59ccf34214e33273af145df13a771607dc42e", "html_url": "https://github.com/rust-lang/rust/commit/86e59ccf34214e33273af145df13a771607dc42e"}], "stats": {"total": 1190, "additions": 1013, "deletions": 177}, "files": [{"sha": "89daa8e09c7d1327b0c4f813be1408430b245bb3", "filename": "src/Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -355,7 +355,7 @@ dependencies = [\n  \"cargo_metadata 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy-mini-macro-test 0.2.0\",\n  \"clippy_lints 0.0.212\",\n- \"compiletest_rs 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num-traits 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -461,7 +461,7 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.3.11\"\n+version = \"0.3.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1319,7 +1319,7 @@ dependencies = [\n  \"byteorder 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"compiletest_rs 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"compiletest_rs 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.5.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -3118,7 +3118,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum colored 1.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b0aa3473e85a3161b59845d6096b289bb577874cafeaf75ea1b1beaa6572c7fc\"\n \"checksum commoncrypto 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n \"checksum commoncrypto-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-\"checksum compiletest_rs 0.3.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"04cea0fe8b8aaca8143af607ad69076866c9f08b83c4b7faca0e993e5486831b\"\n+\"checksum compiletest_rs 0.3.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3064bc712922596dd5ab449fca9261d411893356581fe5297b96aa8f53bb1b8\"\n \"checksum core-foundation 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"286e0b41c3a20da26536c6000a280585d519fd07b3956b43aed8a79e9edce980\"\n \"checksum core-foundation 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cc3532ec724375c7cb7ff0a097b714fde180bb1f6ed2ab27cfcd99ffca873cd2\"\n \"checksum core-foundation-sys 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"716c271e8613ace48344f723b60b900a93150271e5be206212d052bbc0883efa\""}, {"sha": "8e71df3c34b0b42b998aeb7a8d24e477cda6249d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -73,6 +73,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(macro_at_most_once_rep)]\n #![feature(inclusive_range_methods)]\n+#![feature(crate_in_paths)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "1e9584bc55bdf0f05e1f044f0db2d7be4899c876", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         tcx: TyCtxtAt<'a, 'gcx, 'tcx>,\n         message: &str\n     ) {\n-        let err = self.struct_generic(tcx, message, None);\n+        let err = self.struct_error(tcx, message);\n         if let Some(mut err) = err {\n             err.emit();\n         }"}, {"sha": "81cc897232ab05da5b11bfc8f0885a56971a890b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -1599,7 +1599,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             // Potentially-fat pointers.\n             ty::TyRef(_, pointee, _) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < 2);\n+                assert!(i < this.fields.count());\n \n                 // Reuse the fat *T type as its own thin pointer data field.\n                 // This provides information about e.g. DST struct pointees\n@@ -1621,10 +1621,25 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 match tcx.struct_tail(pointee).sty {\n                     ty::TySlice(_) |\n                     ty::TyStr => tcx.types.usize,\n-                    ty::TyDynamic(..) => {\n-                        // FIXME(eddyb) use an usize/fn() array with\n-                        // the correct number of vtables slots.\n-                        tcx.mk_imm_ref(tcx.types.re_static, tcx.mk_nil())\n+                    ty::TyDynamic(data, _) => {\n+                        let trait_def_id = data.principal().unwrap().def_id();\n+                        let num_fns: u64 = crate::traits::supertrait_def_ids(tcx, trait_def_id)\n+                            .map(|trait_def_id| {\n+                                tcx.associated_items(trait_def_id)\n+                                    .filter(|item| item.kind == ty::AssociatedKind::Method)\n+                                    .count() as u64\n+                            })\n+                            .sum();\n+                        tcx.mk_imm_ref(\n+                            tcx.types.re_static,\n+                            tcx.mk_array(tcx.types.usize, 3 + num_fns),\n+                        )\n+                        /* FIXME use actual fn pointers\n+                        tcx.mk_tup(&[\n+                            tcx.mk_array(tcx.types.usize, 3),\n+                            tcx.mk_array(Option<fn()>),\n+                        ])\n+                        */\n                     }\n                     _ => bug!(\"TyLayout::field_type({:?}): not applicable\", this)\n                 }"}, {"sha": "7cb4f7d38609871bdcd81427191543ebdc2d5687", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 68, "deletions": 7, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -40,6 +40,7 @@ use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n \n use std::collections::HashSet;\n+use rustc::util::nodemap::FxHashSet;\n \n use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n@@ -1576,20 +1577,77 @@ impl LintPass for UnusedBrokenConst {\n     }\n }\n \n+fn validate_const<'a, 'tcx>(\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    constant: &ty::Const<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    gid: ::rustc::mir::interpret::GlobalId<'tcx>,\n+    what: &str,\n+) {\n+    let mut ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n+    let result = (|| {\n+        let val = ecx.const_to_value(constant.val)?;\n+        use rustc_target::abi::LayoutOf;\n+        let layout = ecx.layout_of(constant.ty)?;\n+        let place = ecx.allocate_place_for_value(val, layout, None)?;\n+        let ptr = place.to_ptr()?;\n+        let mut todo = vec![(ptr, layout.ty, String::new())];\n+        let mut seen = FxHashSet();\n+        seen.insert((ptr, layout.ty));\n+        while let Some((ptr, ty, path)) = todo.pop() {\n+            let layout = ecx.layout_of(ty)?;\n+            ecx.validate_ptr_target(\n+                ptr,\n+                layout.align,\n+                layout,\n+                path,\n+                &mut seen,\n+                &mut todo,\n+            )?;\n+        }\n+        Ok(())\n+    })();\n+    if let Err(err) = result {\n+        let (trace, span) = ecx.generate_stacktrace(None);\n+        let err = ::rustc::mir::interpret::ConstEvalErr {\n+            error: err,\n+            stacktrace: trace,\n+            span,\n+        };\n+        let err = err.struct_error(\n+            tcx.at(span),\n+            &format!(\"this {} likely exhibits undefined behavior\", what),\n+        );\n+        if let Some(mut err) = err {\n+            err.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n+                so this check might be overzealous. Please open an issue on the rust compiler \\\n+                repository if you believe it should not be considered undefined behavior\",\n+            );\n+            err.emit();\n+        }\n+    }\n+}\n+\n fn check_const(cx: &LateContext, body_id: hir::BodyId, what: &str) {\n     let def_id = cx.tcx.hir.body_owner_def_id(body_id);\n     let param_env = cx.tcx.param_env(def_id);\n     let cid = ::rustc::mir::interpret::GlobalId {\n         instance: ty::Instance::mono(cx.tcx, def_id),\n         promoted: None\n     };\n-    if let Err(err) = cx.tcx.const_eval(param_env.and(cid)) {\n-        let span = cx.tcx.def_span(def_id);\n-        err.report_as_lint(\n-            cx.tcx.at(span),\n-            &format!(\"this {} cannot be used\", what),\n-            cx.current_lint_root(),\n-        );\n+    match cx.tcx.const_eval(param_env.and(cid)) {\n+        Ok(val) => validate_const(cx.tcx, val, param_env, cid, what),\n+        Err(err) => {\n+            // errors for statics are already reported directly in the query\n+            if cx.tcx.is_static(def_id).is_none() {\n+                let span = cx.tcx.def_span(def_id);\n+                err.report_as_lint(\n+                    cx.tcx.at(span),\n+                    &format!(\"this {} cannot be used\", what),\n+                    cx.current_lint_root(),\n+                );\n+            }\n+        },\n     }\n }\n \n@@ -1610,6 +1668,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id, \"constant\");\n             },\n+            hir::ItemKind::Static(_, _, body_id) => {\n+                check_const(cx, body_id, \"static\");\n+            },\n             hir::ItemKind::Ty(ref ty, _) => hir::intravisit::walk_ty(\n                 &mut UnusedBrokenConstVisitor(cx),\n                 ty"}, {"sha": "873fef75bb9ebf666d41be4b0729fc6b9da0e067", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -5,7 +5,7 @@ use rustc::hir;\n use rustc::mir::interpret::{ConstEvalErr};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n-use rustc::ty::layout::{self, LayoutOf, Primitive};\n+use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout};\n use rustc::ty::subst::Subst;\n \n use syntax::ast::Mutability;\n@@ -16,7 +16,7 @@ use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n     Value, Scalar, AllocId, Allocation, ConstValue,\n };\n-use super::{Place, EvalContext, StackPopCleanup, ValTy, PlaceExtra, Memory, MemoryKind};\n+use super::{Place, EvalContext, StackPopCleanup, ValTy, Memory, MemoryKind};\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -63,7 +63,7 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n     ecx.with_fresh_body(|ecx| {\n         eval_body_using_ecx(ecx, cid, Some(mir), param_env)\n     })\n@@ -121,7 +121,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n@@ -137,7 +137,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, Ty<'tcx>)> {\n+) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -182,7 +182,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n         // point at the allocation\n         _ => Value::ByRef(ptr, layout.align),\n     };\n-    Ok((value, ptr, layout.ty))\n+    Ok((value, ptr, layout))\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n@@ -434,19 +434,7 @@ pub fn const_val_field<'a, 'tcx>(\n         let ty = value.ty;\n         let value = ecx.const_to_value(value.val)?;\n         let layout = ecx.layout_of(ty)?;\n-        let (ptr, align) = match value {\n-            Value::ByRef(ptr, align) => (ptr, align),\n-            Value::ScalarPair(..) | Value::Scalar(_) => {\n-                let ptr = ecx.alloc_ptr(ty)?.into();\n-                ecx.write_value_to_ptr(value, ptr, layout.align, ty)?;\n-                (ptr, layout.align)\n-            },\n-        };\n-        let place = Place::Ptr {\n-            ptr,\n-            align,\n-            extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n-        };\n+        let place = ecx.allocate_place_for_value(value, layout, variant)?;\n         let (place, layout) = ecx.place_field(place, field, layout)?;\n         let (ptr, align) = place.to_ptr_align();\n         let mut new_value = Value::ByRef(ptr, align);\n@@ -484,17 +472,17 @@ pub fn const_variant_index<'a, 'tcx>(\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let value = ecx.const_to_value(val.val)?;\n+    let layout = ecx.layout_of(val.ty)?;\n     let (ptr, align) = match value {\n         Value::ScalarPair(..) | Value::Scalar(_) => {\n-            let layout = ecx.layout_of(val.ty)?;\n             let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n             ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n             (ptr, layout.align)\n         },\n         Value::ByRef(ptr, align) => (ptr, align),\n     };\n     let place = Place::from_scalar_ptr(ptr, align);\n-    ecx.read_discriminant_as_variant_index(place, val.ty)\n+    ecx.read_discriminant_as_variant_index(place, layout)\n }\n \n pub fn const_value_to_allocation_provider<'a, 'tcx>(\n@@ -560,11 +548,11 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|(mut val, _, miri_ty)| {\n+    res.and_then(|(mut val, _, layout)| {\n         if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n-            val = ecx.try_read_by_ref(val, miri_ty)?;\n+            val = ecx.try_read_by_ref(val, layout.ty)?;\n         }\n-        Ok(value_to_const_value(&ecx, val, miri_ty))\n+        Ok(value_to_const_value(&ecx, val, layout.ty))\n     }).map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n         let err = ConstEvalErr {"}, {"sha": "c6c1a1d1ebb22b8e43c43f278c75204d8ea10fd8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 340, "deletions": 70, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -6,14 +6,14 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::mir;\n-use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf, TyLayout};\n+use rustc::ty::layout::{self, Size, Align, HasDataLayout, IntegerExt, LayoutOf, TyLayout, Primitive};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::mir::interpret::{\n-    FrameInfo, GlobalId, Value, Scalar,\n+    GlobalId, Value, Scalar, FrameInfo, AllocType,\n     EvalResult, EvalErrorKind, Pointer, ConstValue,\n };\n \n@@ -24,6 +24,31 @@ use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind,\n             Machine};\n \n+macro_rules! validation_failure{\n+    ($what:expr, $where:expr, $details:expr) => {{\n+        let where_ = if $where.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", $where)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}, but expected {}\",\n+            $what, where_, $details,\n+        )))\n+    }};\n+    ($what:expr, $where:expr) => {{\n+        let where_ = if $where.is_empty() {\n+            String::new()\n+        } else {\n+            format!(\" at {}\", $where)\n+        };\n+        err!(ValidationFailure(format!(\n+            \"encountered {}{}\",\n+            $what, where_,\n+        )))\n+    }};\n+}\n+\n pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n@@ -324,8 +349,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         r\n     }\n \n-    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        let layout = self.layout_of(ty)?;\n+    pub fn alloc_ptr(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Pointer> {\n         assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n \n         self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n@@ -776,8 +800,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             Discriminant(ref place) => {\n                 let ty = self.place_ty(place);\n+                let layout = self.layout_of(ty)?;\n                 let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant_value(place, ty)?;\n+                let discr_val = self.read_discriminant_value(place, layout)?;\n                 let defined = self.layout_of(dest_ty).unwrap().size.bits() as u8;\n                 self.write_scalar(dest, Scalar::Bits {\n                     bits: discr_val,\n@@ -843,56 +868,55 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     /// reads a tag and produces the corresponding variant index\n     pub fn read_discriminant_as_variant_index(\n-        &mut self,\n+        &self,\n         place: Place,\n-        ty: Ty<'tcx>,\n+        layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, usize> {\n-        let layout = self.layout_of(ty)?;\n         match layout.variants {\n             ty::layout::Variants::Single { index } => Ok(index),\n             ty::layout::Variants::Tagged { .. } => {\n-                let discr_val = self.read_discriminant_value(place, ty)?;\n-                ty\n+                let discr_val = self.read_discriminant_value(place, layout)?;\n+                layout\n+                    .ty\n                     .ty_adt_def()\n                     .expect(\"tagged layout for non adt\")\n                     .discriminants(self.tcx.tcx)\n                     .position(|var| var.val == discr_val)\n                     .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n             }\n             ty::layout::Variants::NicheFilling { .. } => {\n-                let discr_val = self.read_discriminant_value(place, ty)?;\n+                let discr_val = self.read_discriminant_value(place, layout)?;\n                 assert_eq!(discr_val as usize as u128, discr_val);\n                 Ok(discr_val as usize)\n             },\n         }\n     }\n \n     pub fn read_discriminant_value(\n-        &mut self,\n+        &self,\n         place: Place,\n-        ty: Ty<'tcx>,\n+        layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, u128> {\n-        let layout = self.layout_of(ty)?;\n         trace!(\"read_discriminant_value {:#?}\", layout);\n         if layout.abi == layout::Abi::Uninhabited {\n             return Ok(0);\n         }\n \n         match layout.variants {\n             layout::Variants::Single { index } => {\n-                let discr_val = ty.ty_adt_def().map_or(\n+                let discr_val = layout.ty.ty_adt_def().map_or(\n                     index as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n                 return Ok(discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n         }\n-\n-        let (discr_place, discr) = self.place_field(place, mir::Field::new(0), layout)?;\n-        trace!(\"discr place: {:?}, {:?}\", discr_place, discr);\n+        let discr_place_val = self.read_place(place)?;\n+        let (discr_val, discr) = self.read_field(discr_place_val, None, mir::Field::new(0), layout)?;\n+        trace!(\"discr value: {:?}, {:?}\", discr_val, discr);\n         let raw_discr = self.value_to_scalar(ValTy {\n-            value: self.read_place(discr_place)?,\n+            value: discr_val,\n             ty: discr.ty\n         })?;\n         let discr_val = match layout.variants {\n@@ -906,7 +930,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     let shift = 128 - discr.size.bits();\n                     let sexted = (i << shift) >> shift;\n                     // and then zeroing with the typeck discriminant type\n-                    let discr_ty = ty\n+                    let discr_ty = layout\n+                        .ty\n                         .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n                         .repr\n                         .discr_type();\n@@ -1023,6 +1048,27 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.tcx.const_eval(param_env.and(gid)).map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n+    pub fn allocate_place_for_value(\n+        &mut self,\n+        value: Value,\n+        layout: TyLayout<'tcx>,\n+        variant: Option<usize>,\n+    ) -> EvalResult<'tcx, Place> {\n+        let (ptr, align) = match value {\n+            Value::ByRef(ptr, align) => (ptr, align),\n+            Value::ScalarPair(..) | Value::Scalar(_) => {\n+                let ptr = self.alloc_ptr(layout)?.into();\n+                self.write_value_to_ptr(value, ptr, layout.align, layout.ty)?;\n+                (ptr, layout.align)\n+            },\n+        };\n+        Ok(Place::Ptr {\n+            ptr,\n+            align,\n+            extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n+        })\n+    }\n+\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n@@ -1039,7 +1085,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n-                        let ptr = self.alloc_ptr(ty)?;\n+                        let ptr = self.alloc_ptr(layout)?;\n                         self.stack[frame].locals[local] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         let place = Place::from_ptr(ptr, layout.align);\n@@ -1074,11 +1120,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         match self.follow_by_ref_value(value, ty)? {\n             Value::ByRef { .. } => bug!(\"follow_by_ref_value can't result in `ByRef`\"),\n \n-            Value::Scalar(scalar) => {\n-                // TODO: Do we really want insta-UB here?\n-                self.ensure_valid_value(scalar, ty)?;\n-                Ok(scalar)\n-            }\n+            Value::Scalar(scalar) => Ok(scalar),\n \n             Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n         }\n@@ -1165,8 +1207,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             if let Ok(Some(src_val)) = self.try_read_value(src_ptr, align, dest_ty) {\n                 write_dest(self, src_val)?;\n             } else {\n-                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n                 let layout = self.layout_of(dest_ty)?;\n+                let dest_ptr = self.alloc_ptr(layout)?.into();\n                 self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n                 write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n             }\n@@ -1221,18 +1263,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    fn ensure_valid_value(&self, val: Scalar, ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        match ty.sty {\n-            ty::TyBool => val.to_bool().map(|_| ()),\n-\n-            ty::TyChar if ::std::char::from_u32(val.to_bits(Size::from_bytes(4))? as u32).is_none() => {\n-                err!(InvalidChar(val.to_bits(Size::from_bytes(4))? as u32 as u128))\n-            }\n-\n-            _ => Ok(()),\n-        }\n-    }\n-\n     pub fn read_value(&self, ptr: Scalar, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         if let Some(val) = self.try_read_value(ptr, align, ty)? {\n             Ok(val)\n@@ -1270,47 +1300,223 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    pub fn validate_ptr_target(\n+    fn validate_scalar(\n         &self,\n-        ptr: Pointer,\n-        ptr_align: Align,\n-        ty: Ty<'tcx>\n+        value: Scalar,\n+        size: Size,\n+        scalar: &layout::Scalar,\n+        path: &str,\n+        ty: Ty,\n     ) -> EvalResult<'tcx> {\n+        trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n+        let (lo, hi) = scalar.valid_range.clone().into_inner();\n+\n+        let (bits, defined) = match value {\n+            Scalar::Bits { bits, defined } => (bits, defined),\n+            Scalar::Ptr(_) => {\n+                let ptr_size = self.memory.pointer_size();\n+                let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n+                return if lo > hi {\n+                    if lo - hi == 1 {\n+                        // no gap, all values are ok\n+                        Ok(())\n+                    } else if hi < ptr_max || lo > 1 {\n+                        let max = u128::max_value() >> (128 - size.bits());\n+                        validation_failure!(\n+                            \"pointer\",\n+                            path,\n+                            format!(\"something in the range {:?} or {:?}\", 0..=lo, hi..=max)\n+                        )\n+                    } else {\n+                        Ok(())\n+                    }\n+                } else if hi < ptr_max || lo > 1 {\n+                    validation_failure!(\n+                        \"pointer\",\n+                        path,\n+                        format!(\"something in the range {:?}\", scalar.valid_range)\n+                    )\n+                } else {\n+                    Ok(())\n+                };\n+            },\n+        };\n+\n+        // char gets a special treatment, because its number space is not contiguous so `TyLayout`\n+        // has no special checks for chars\n         match ty.sty {\n-            ty::TyBool => {\n-                self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(1))?.to_bool()?;\n-            }\n             ty::TyChar => {\n-                let c = self.memory.read_scalar(ptr, ptr_align, Size::from_bytes(4))?.to_bits(Size::from_bytes(4))? as u32;\n-                match ::std::char::from_u32(c) {\n-                    Some(..) => (),\n-                    None => return err!(InvalidChar(c as u128)),\n+                assert_eq!(size.bytes(), 4);\n+                if ::std::char::from_u32(bits as u32).is_none() {\n+                    return err!(InvalidChar(bits));\n                 }\n             }\n+            _ => {},\n+        }\n \n-            ty::TyFnPtr(_) => {\n-                self.memory.read_ptr_sized(ptr, ptr_align)?;\n-            },\n-            ty::TyRef(_, rty, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: rty, .. }) => {\n-                self.read_ptr(ptr, ptr_align, rty)?;\n+        use std::ops::RangeInclusive;\n+        let in_range = |bound: RangeInclusive<u128>| {\n+            defined as u64 >= size.bits() && bound.contains(&bits)\n+        };\n+        if lo > hi {\n+            if in_range(0..=hi) || in_range(lo..=u128::max_value()) {\n+                Ok(())\n+            } else if defined as u64 >= size.bits() {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?} or {:?}\", ..=hi, lo..)\n+                )\n+            } else {\n+                validation_failure!(\"undefined bytes\", path)\n             }\n+        } else {\n+            if in_range(scalar.valid_range.clone()) {\n+                Ok(())\n+            } else if defined as u64 >= size.bits() {\n+                validation_failure!(\n+                    bits,\n+                    path,\n+                    format!(\"something in the range {:?}\", scalar.valid_range)\n+                )\n+            } else {\n+                validation_failure!(\"undefined bytes\", path)\n+            }\n+        }\n+    }\n \n-            ty::TyAdt(def, _) => {\n-                if def.is_box() {\n-                    self.read_ptr(ptr, ptr_align, ty.boxed_ty())?;\n-                    return Ok(());\n-                }\n+    /// This function checks the memory where `ptr` points to.\n+    /// It will error if the bits at the destination do not match the ones described by the layout.\n+    pub fn validate_ptr_target(\n+        &self,\n+        ptr: Pointer,\n+        ptr_align: Align,\n+        mut layout: TyLayout<'tcx>,\n+        path: String,\n+        seen: &mut FxHashSet<(Pointer, Ty<'tcx>)>,\n+        todo: &mut Vec<(Pointer, Ty<'tcx>, String)>,\n+    ) -> EvalResult<'tcx> {\n+        self.memory.dump_alloc(ptr.alloc_id);\n+        trace!(\"validate_ptr_target: {:?}, {:#?}\", ptr, layout);\n \n-                if let layout::Abi::Scalar(ref scalar) = self.layout_of(ty)?.abi {\n-                    let size = scalar.value.size(self);\n-                    self.memory.read_scalar(ptr, ptr_align, size)?;\n+        let variant;\n+        match layout.variants {\n+            layout::Variants::NicheFilling { niche: ref tag, .. } |\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                let size = tag.value.size(self);\n+                let (tag_value, tag_layout) = self.read_field(\n+                    Value::ByRef(ptr.into(), ptr_align),\n+                    None,\n+                    mir::Field::new(0),\n+                    layout,\n+                )?;\n+                let tag_value = self.value_to_scalar(ValTy {\n+                    value: tag_value,\n+                    ty: tag_layout.ty,\n+                })?;\n+                let path = format!(\"{}.TAG\", path);\n+                self.validate_scalar(tag_value, size, tag, &path, tag_layout.ty)?;\n+                let variant_index = self.read_discriminant_as_variant_index(\n+                    Place::from_ptr(ptr, ptr_align),\n+                    layout,\n+                )?;\n+                variant = variant_index;\n+                layout = layout.for_variant(self, variant_index);\n+                trace!(\"variant layout: {:#?}\", layout);\n+            },\n+            layout::Variants::Single { index } => variant = index,\n+        }\n+        match layout.fields {\n+            // primitives are unions with zero fields\n+            layout::FieldPlacement::Union(0) => {\n+                match layout.abi {\n+                    // nothing to do, whatever the pointer points to, it is never going to be read\n+                    layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n+                    // check that the scalar is a valid pointer or that its bit range matches the\n+                    // expectation.\n+                    layout::Abi::Scalar(ref scalar) => {\n+                        let size = scalar.value.size(self);\n+                        let value = self.memory.read_scalar(ptr, ptr_align, size)?;\n+                        self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n+                        if scalar.value == Primitive::Pointer {\n+                            // ignore integer pointers, we can't reason about the final hardware\n+                            if let Scalar::Ptr(ptr) = value {\n+                                let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n+                                if let Some(AllocType::Static(did)) = alloc_kind {\n+                                    // statics from other crates are already checked\n+                                    // extern statics should not be validated as they have no body\n+                                    if !did.is_local() || self.tcx.is_foreign_item(did) {\n+                                        return Ok(());\n+                                    }\n+                                }\n+                                if let Some(tam) = layout.ty.builtin_deref(false) {\n+                                    // we have not encountered this pointer+layout combination before\n+                                    if seen.insert((ptr, tam.ty)) {\n+                                        todo.push((ptr, tam.ty, format!(\"(*{})\", path)))\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        Ok(())\n+                    },\n+                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", layout.abi),\n                 }\n             }\n-\n-            _ => (),\n+            layout::FieldPlacement::Union(_) => {\n+                // We can't check unions, their bits are allowed to be anything.\n+                // The fields don't need to correspond to any bit pattern of the union's fields.\n+                // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n+                Ok(())\n+            },\n+            layout::FieldPlacement::Array { stride, count } => {\n+                let elem_layout = layout.field(self, 0)?;\n+                for i in 0..count {\n+                    let mut path = path.clone();\n+                    self.write_field_name(&mut path, layout.ty, i as usize, variant).unwrap();\n+                    self.validate_ptr_target(ptr.offset(stride * i, self)?, ptr_align, elem_layout, path, seen, todo)?;\n+                }\n+                Ok(())\n+            },\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n+\n+                // check length field and vtable field\n+                match layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n+                    | Some(ty::TyStr)\n+                    | Some(ty::TySlice(_)) => {\n+                        let (len, len_layout) = self.read_field(\n+                            Value::ByRef(ptr.into(), ptr_align),\n+                            None,\n+                            mir::Field::new(1),\n+                            layout,\n+                        )?;\n+                        let len = self.value_to_scalar(ValTy { value: len, ty: len_layout.ty })?;\n+                        if len.to_bits(len_layout.size).is_err() {\n+                            return validation_failure!(\"length is not a valid integer\", path);\n+                        }\n+                    },\n+                    Some(ty::TyDynamic(..)) => {\n+                        let (vtable, vtable_layout) = self.read_field(\n+                            Value::ByRef(ptr.into(), ptr_align),\n+                            None,\n+                            mir::Field::new(1),\n+                            layout,\n+                        )?;\n+                        let vtable = self.value_to_scalar(ValTy { value: vtable, ty: vtable_layout.ty })?;\n+                        if vtable.to_ptr().is_err() {\n+                            return validation_failure!(\"vtable address is not a pointer\", path);\n+                        }\n+                    }\n+                    _ => {},\n+                }\n+                for (i, &offset) in offsets.iter().enumerate() {\n+                    let field_layout = layout.field(self, i)?;\n+                    let mut path = path.clone();\n+                    self.write_field_name(&mut path, layout.ty, i, variant).unwrap();\n+                    self.validate_ptr_target(ptr.offset(offset, self)?, ptr_align, field_layout, path, seen, todo)?;\n+                }\n+                Ok(())\n+            }\n         }\n-        Ok(())\n     }\n \n     pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n@@ -1333,9 +1539,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         let ptr = ptr.to_ptr()?;\n \n-        // Not the right place to do this\n-        //self.validate_ptr_target(ptr, ptr_align, ty)?;\n-\n         match layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n@@ -1623,6 +1826,73 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn truncate(&self, value: u128, ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         super::truncate(self.tcx.tcx, value, ty)\n     }\n+\n+    fn write_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n+        match ty.sty {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyFnPtr(_) |\n+            ty::TyNever |\n+            ty::TyFnDef(..) |\n+            ty::TyGeneratorWitness(..) |\n+            ty::TyForeign(..) |\n+            ty::TyDynamic(..) => {\n+                bug!(\"field_name({:?}): not applicable\", ty)\n+            }\n+\n+            // Potentially-fat pointers.\n+            ty::TyRef(_, pointee, _) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                assert!(i < 2);\n+\n+                // Reuse the fat *T type as its own thin pointer data field.\n+                // This provides information about e.g. DST struct pointees\n+                // (which may have no non-DST form), and will work as long\n+                // as the `Abi` or `FieldPlacement` is checked by users.\n+                if i == 0 {\n+                    return write!(s, \".data_ptr\");\n+                }\n+\n+                match self.tcx.struct_tail(pointee).sty {\n+                    ty::TySlice(_) |\n+                    ty::TyStr => write!(s, \".len\"),\n+                    ty::TyDynamic(..) => write!(s, \".vtable_ptr\"),\n+                    _ => bug!(\"field_name({:?}): not applicable\", ty)\n+                }\n+            }\n+\n+            // Arrays and slices.\n+            ty::TyArray(_, _) |\n+            ty::TySlice(_) |\n+            ty::TyStr => write!(s, \"[{}]\", i),\n+\n+            // generators and closures.\n+            ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n+                let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+                let freevar = self.tcx.with_freevars(node_id, |fv| fv[i]);\n+                write!(s, \".upvar({})\", self.tcx.hir.name(freevar.var_id()))\n+            }\n+\n+            ty::TyTuple(_) => write!(s, \".{}\", i),\n+\n+            // enums\n+            ty::TyAdt(def, ..) if def.is_enum() => {\n+                let variant = &def.variants[variant];\n+                write!(s, \".{}::{}\", variant.name, variant.fields[i].ident)\n+            }\n+\n+            // other ADTs.\n+            ty::TyAdt(def, _) => write!(s, \".{}\", def.non_enum_variant().fields[i].ident),\n+\n+            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n+            ty::TyInfer(_) | ty::TyError => {\n+                bug!(\"write_field_name: unexpected type `{}`\", ty)\n+            }\n+        }\n+    }\n }\n \n impl<'mir, 'tcx> Frame<'mir, 'tcx> {"}, {"sha": "2765feb23f1b906368b2578574e5742a211ae176", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -763,6 +763,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n+            // this inflates undefined bytes to the entire scalar, even if only a few bytes are undefined\n             return Ok(Scalar::undef().into());\n         }\n         // Now we do the actual reading"}, {"sha": "0c921f66198eb88d7538e9c0fdc1d56cb5700bd6", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -21,6 +21,7 @@ pub use self::memory::{Memory, MemoryKind, HasMemory};\n pub use self::const_eval::{\n     eval_promoted,\n     mk_borrowck_eval_cx,\n+    mk_eval_cx,\n     CompileTimeEvaluator,\n     const_value_to_allocation_provider,\n     const_eval_provider,"}, {"sha": "59bf2ae6c0fe7721ea6c264715d87d94d4ad68f3", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Reads a value from the place without going through the intermediate step of obtaining\n     /// a `miri::Place`\n     pub fn try_read_place(\n-        &mut self,\n+        &self,\n         place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n         use rustc::mir::Place::*;\n@@ -120,19 +120,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         base: Value,\n         variant: Option<usize>,\n         field: mir::Field,\n-        base_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        let mut base_layout = self.layout_of(base_ty)?;\n+        mut base_layout: TyLayout<'tcx>,\n+    ) -> EvalResult<'tcx, (Value, TyLayout<'tcx>)> {\n         if let Some(variant_index) = variant {\n             base_layout = base_layout.for_variant(self, variant_index);\n         }\n         let field_index = field.index();\n         let field = base_layout.field(self, field_index)?;\n         if field.size.bytes() == 0 {\n-            return Ok(ValTy {\n-                value: Value::Scalar(Scalar::undef()),\n-                ty: field.ty,\n-            });\n+            return Ok((\n+                Value::Scalar(Scalar::undef()),\n+                field,\n+            ));\n         }\n         let offset = base_layout.fields.offset(field_index);\n         let value = match base {\n@@ -151,16 +150,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 assert!(!field.is_unsized());\n                 Value::ByRef(ptr, align)\n             },\n-            Value::Scalar(val) => bug!(\"field access on non aggregate {:?}, {:?}\", val, base_ty),\n+            Value::Scalar(val) => bug!(\"field access on non aggregate {:#?}, {:#?}\", val, base_layout),\n         };\n-        Ok(ValTy {\n-            value,\n-            ty: field.ty,\n-        })\n+        Ok((value, field))\n     }\n \n     fn try_read_place_projection(\n-        &mut self,\n+        &self,\n         proj: &mir::PlaceProjection<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n         use rustc::mir::ProjectionElem::*;\n@@ -169,8 +165,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             None => return Ok(None),\n         };\n         let base_ty = self.place_ty(&proj.base);\n+        let base_layout = self.layout_of(base_ty)?;\n         match proj.elem {\n-            Field(field, _) => Ok(Some(self.read_field(base, None, field, base_ty)?.value)),\n+            Field(field, _) => Ok(Some(self.read_field(base, None, field, base_layout)?.0)),\n             // The NullablePointer cases should work fine, need to take care for normal enums\n             Downcast(..) |\n             Subslice { .. } |"}, {"sha": "56dd3f603b692f63e615b109b117e540c88b2fe8", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -351,8 +351,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 for (i, arg_local) in arg_locals.enumerate() {\n                                     let field = mir::Field::new(i);\n-                                    let valty = self.read_field(args[1].value, None, field, args[1].ty)?;\n+                                    let (value, layout) = self.read_field(args[1].value, None, field, layout)?;\n                                     let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n+                                    let valty = ValTy {\n+                                        value,\n+                                        ty: layout.ty,\n+                                    };\n                                     self.write_value(valty, dest)?;\n                                 }\n                             } else {"}, {"sha": "9902fe98cc011ecd2cb709478ed001ddceb70a0e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -65,7 +65,7 @@ impl MirPass for ConstProp {\n     }\n }\n \n-type Const<'tcx> = (Value, ty::Ty<'tcx>, Span);\n+type Const<'tcx> = (Value, TyLayout<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n@@ -258,7 +258,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n         match self.ecx.const_to_value(c.literal.val) {\n-            Ok(val) => Some((val, c.literal.ty, c.span)),\n+            Ok(val) => {\n+                let layout = self.tcx.layout_of(self.param_env.and(c.literal.ty)).ok()?;\n+                Some((val, layout, c.span))\n+            },\n             Err(error) => {\n                 let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n                 let err = ConstEvalErr {\n@@ -281,11 +284,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n-                    let (base, ty, span) = self.eval_place(&proj.base, source_info)?;\n+                    let (base, layout, span) = self.eval_place(&proj.base, source_info)?;\n                     let valty = self.use_ecx(source_info, |this| {\n-                        this.ecx.read_field(base, None, field, ty)\n+                        this.ecx.read_field(base, None, field, layout)\n                     })?;\n-                    Some((valty.value, valty.ty, span))\n+                    Some((valty.0, valty.1, span))\n                 },\n                 _ => None,\n             },\n@@ -325,14 +328,14 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n-        place_ty: ty::Ty<'tcx>,\n+        place_layout: TyLayout<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         let span = source_info.span;\n         match *rvalue {\n             // This branch exists for the sanity type check\n             Rvalue::Use(Operand::Constant(ref c)) => {\n-                assert_eq!(c.ty, place_ty);\n+                assert_eq!(c.ty, place_layout.ty);\n                 self.eval_constant(c, source_info)\n             },\n             Rvalue::Use(ref op) => {\n@@ -345,15 +348,15 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::Discriminant(..) => None,\n \n             Rvalue::Cast(kind, ref operand, _) => {\n-                let (value, ty, span) = self.eval_operand(operand, source_info)?;\n+                let (value, layout, span) = self.eval_operand(operand, source_info)?;\n                 self.use_ecx(source_info, |this| {\n-                    let dest_ptr = this.ecx.alloc_ptr(place_ty)?;\n-                    let place_align = this.ecx.layout_of(place_ty)?.align;\n+                    let dest_ptr = this.ecx.alloc_ptr(place_layout)?;\n+                    let place_align = place_layout.align;\n                     let dest = ::interpret::Place::from_ptr(dest_ptr, place_align);\n-                    this.ecx.cast(ValTy { value, ty }, kind, place_ty, dest)?;\n+                    this.ecx.cast(ValTy { value, ty: layout.ty }, kind, place_layout.ty, dest)?;\n                     Ok((\n                         Value::ByRef(dest_ptr.into(), place_align),\n-                        place_ty,\n+                        place_layout,\n                         span,\n                     ))\n                 })\n@@ -362,15 +365,14 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             // FIXME(oli-obk): evaluate static/constant slice lengths\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                let param_env = self.tcx.param_env(self.source.def_id);\n-                type_size_of(self.tcx, param_env, ty).map(|n| (\n+                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n                     Value::Scalar(Scalar::Bits {\n                         bits: n as u128,\n                         defined: self.tcx.data_layout.pointer_size.bits() as u8,\n                     }),\n-                    self.tcx.types.usize,\n+                    self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     span,\n-                ))\n+                )))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n                 let def_id = if self.tcx.is_closure(self.source.def_id) {\n@@ -386,10 +388,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n \n                 let val = self.eval_operand(arg, source_info)?;\n                 let prim = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1.ty })\n                 })?;\n-                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::Scalar(val), place_ty, span))\n+                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1.ty))?;\n+                Some((Value::Scalar(val), place_layout, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -407,7 +409,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: right.0, ty: right.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: right.0, ty: right.1.ty })\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let left_ty = left.ty(self.mir, self.tcx);\n@@ -417,7 +419,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         .unwrap()\n                         .size\n                         .bits();\n-                    let right_size = self.tcx.layout_of(self.param_env.and(right.1)).unwrap().size;\n+                    let right_size = right.1.size;\n                     if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n                         let source_scope_local_data = match self.mir.source_scope_local_data {\n                             ClearCrossCrate::Set(ref data) => data,\n@@ -439,11 +441,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: left.0, ty: left.1 })\n+                    this.ecx.value_to_scalar(ValTy { value: left.0, ty: left.1.ty })\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, left.1, r, right.1)\n+                    this.ecx.binary_op(op, l, left.1.ty, r, right.1.ty)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n@@ -458,7 +460,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     }\n                     Value::Scalar(val)\n                 };\n-                Some((val, place_ty, span))\n+                Some((val, place_layout, span))\n             },\n         }\n     }\n@@ -544,16 +546,18 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n     ) {\n         trace!(\"visit_statement: {:?}\", statement);\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n-            let place_ty = place\n+            let place_ty: ty::Ty<'tcx> = place\n                 .ty(&self.mir.local_decls, self.tcx)\n                 .to_ty(self.tcx);\n-            if let Some(value) = self.const_prop(rval, place_ty, statement.source_info) {\n-                if let Place::Local(local) = *place {\n-                    trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n-                    if self.can_const_prop[local] {\n-                        trace!(\"storing {:?} to {:?}\", value, local);\n-                        assert!(self.places[local].is_none());\n-                        self.places[local] = Some(value);\n+            if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n+                if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n+                    if let Place::Local(local) = *place {\n+                        trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n+                        if self.can_const_prop[local] {\n+                            trace!(\"storing {:?} to {:?}\", value, local);\n+                            assert!(self.places[local].is_none());\n+                            self.places[local] = Some(value);\n+                        }\n                     }\n                 }\n             }"}, {"sha": "dac4738e2b4bf15eef230ee33e18dda16df30481", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -634,6 +634,8 @@ impl Scalar {\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub enum FieldPlacement {\n     /// All fields start at no offset. The `usize` is the field count.\n+    ///\n+    /// In the case of primitives the number of fields is `0`.\n     Union(usize),\n \n     /// Array/vector-like placement, with all fields of identical types."}, {"sha": "09031508da1f709e6a2fee06854b163974a79169", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -120,13 +120,13 @@ pub fn unsafe_slice(_: &[UnsafeInner]) {\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull %arg0.0, {}* noalias nonnull readonly %arg0.1)\n+// CHECK: @trait_borrow({}* nonnull %arg0.0, [4 x [[USIZE]]]* noalias readonly dereferenceable({{.*}}) %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias nonnull, {}* noalias nonnull readonly)\n+// CHECK: @trait_box({}* noalias nonnull, [4 x [[USIZE]]]* noalias readonly dereferenceable({{.*}}))\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }"}, {"sha": "85ddf8d9493d5f573125a03ca30da77553ce2760", "filename": "src/test/compile-fail/issue-26548.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26548.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -11,12 +11,11 @@\n //~^^^^^^^^^^ ERROR cycle detected when computing layout of\n //~| NOTE ...which requires computing layout of\n //~| NOTE ...which again requires computing layout of\n-//~| NOTE cycle used when compile_codegen_unit\n \n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n struct S(Option<<S as Mirror>::It>);\n \n-fn main() {\n+fn main() { //~ NOTE cycle used when processing `main`\n     let _s = S(None);\n }"}, {"sha": "935e69d2e2230756b14880008919b91429ab449e", "filename": "src/test/compile-fail/union-ub-fat-ptr.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcompile-fail%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fcompile-fail%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion-ub-fat-ptr.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct SliceRepr {\n+    ptr: *const u8,\n+    len: usize,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct BadSliceRepr {\n+    ptr: *const u8,\n+    len: &'static u8,\n+}\n+\n+union SliceTransmute {\n+    repr: SliceRepr,\n+    bad: BadSliceRepr,\n+    slice: &'static [u8],\n+    str: &'static str,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct DynRepr {\n+    ptr: *const u8,\n+    vtable: *const u8,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct DynRepr2 {\n+    ptr: *const u8,\n+    vtable: *const u64,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+struct BadDynRepr {\n+    ptr: *const u8,\n+    vtable: usize,\n+}\n+\n+union DynTransmute {\n+    repr: DynRepr,\n+    repr2: DynRepr2,\n+    bad: BadDynRepr,\n+    rust: &'static Trait,\n+}\n+\n+trait Trait {}\n+\n+// OK\n+const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n+// should lint\n+const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+// bad\n+const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// OK\n+const A2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n+// should lint\n+const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+// bad\n+const C2: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// bad\n+const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad\n+const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad\n+const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {\n+}"}, {"sha": "81f6e7ddd2de233bf5a861cc111c441444a7ca22", "filename": "src/test/ui/const-eval/double_check.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+enum Foo {\n+    A = 5,\n+    B = 42,\n+}\n+enum Bar {\n+    C = 42,\n+    D = 99,\n+}\n+union Union {\n+    foo: &'static Foo,\n+    bar: &'static Bar,\n+    usize: &'static usize,\n+}\n+static BAR: usize = 42;\n+static FOO: (&Foo, &Bar) = unsafe {(\n+    Union { usize: &BAR }.foo,\n+    Union { usize: &BAR }.bar,\n+)};\n+\n+fn main() {}"}, {"sha": "b661ee92475e68e0561145f8f87b21a0b449eb4d", "filename": "src/test/ui/const-eval/double_check2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Foo {\n+    A = 5,\n+    B = 42,\n+}\n+enum Bar {\n+    C = 42,\n+    D = 99,\n+}\n+union Union {\n+    foo: &'static Foo,\n+    bar: &'static Bar,\n+    usize: &'static usize,\n+}\n+static BAR: usize = 5;\n+static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n+    Union { usize: &BAR }.foo,\n+    Union { usize: &BAR }.bar,\n+)};\n+\n+fn main() {}"}, {"sha": "2a0a674e237feafee0d0b595f3534ba12258af21", "filename": "src/test/ui/const-eval/double_check2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fdouble_check2.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,14 @@\n+error[E0080]: this static likely exhibits undefined behavior\n+  --> $DIR/double_check2.rs:25:1\n+   |\n+LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n+LL | |     Union { usize: &BAR }.foo,\n+LL | |     Union { usize: &BAR }.bar,\n+LL | | )};\n+   | |___^ type validation failed: encountered 5 at (*.1).TAG, but expected something in the range 42..=99\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e7ffbe81b9ae7469175c3d6ffaeda9d6aeb70e30", "filename": "src/test/ui/const-eval/index_out_of_bounds.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -11,7 +11,4 @@\n static FOO: i32 = [][0];\n //~^ ERROR E0080\n \n-fn main() {\n-    let array = [std::env::args().len()];\n-    array[1]; //~ ERROR index out of bounds\n-}\n+fn main() {}"}, {"sha": "a08d405d4494db82ea97bf89043fef4591e76186", "filename": "src/test/ui/const-eval/index_out_of_bounds.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -4,14 +4,6 @@ error[E0080]: could not evaluate static initializer\n LL | static FOO: i32 = [][0];\n    |                   ^^^^^ index out of bounds: the len is 0 but the index is 0\n \n-error: index out of bounds: the len is 1 but the index is 1\n-  --> $DIR/index_out_of_bounds.rs:16:5\n-   |\n-LL |     array[1]; //~ ERROR index out of bounds\n-   |     ^^^^^^^^\n-   |\n-   = note: #[deny(const_err)] on by default\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "7a7e2ef0b6b55cf821333272016a851457ef667b", "filename": "src/test/ui/const-eval/index_out_of_bounds_propagated.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let array = [std::env::args().len()];\n+    array[1]; //~ ERROR index out of bounds\n+}"}, {"sha": "97badc19c9498dbd66c06b59e566f46d97e16082", "filename": "src/test/ui/const-eval/index_out_of_bounds_propagated.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Findex_out_of_bounds_propagated.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,10 @@\n+error: index out of bounds: the len is 1 but the index is 1\n+  --> $DIR/index_out_of_bounds_propagated.rs:13:5\n+   |\n+LL |     array[1]; //~ ERROR index out of bounds\n+   |     ^^^^^^^^\n+   |\n+   = note: #[deny(const_err)] on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "8538dd14afed19292d3678d20279354fa02246ce", "filename": "src/test/ui/const-eval/ub-enum-ptr.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A = 0,\n+}\n+\n+union Foo {\n+    a: &'static u8,\n+    b: Enum,\n+}\n+\n+// A pointer is guaranteed non-null\n+const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {\n+}"}, {"sha": "4b7ccc25c6c014615bba5bd7b3c68a707a0b58a2", "filename": "src/test/ui/const-eval/ub-enum-ptr.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-enum-ptr.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum-ptr.rs:23:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .TAG, but expected something in the range 0..=0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "b405f766f913219875e6ccba5fc6ca8c467aefda", "filename": "src/test/ui/const-eval/ub-ptr-in-usize.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-ptr-in-usize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-ptr-in-usize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-ptr-in-usize.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+union Foo {\n+    a: &'static u8,\n+    b: usize,\n+}\n+\n+// a usize's value may be a pointer, that's fine\n+const PTR_AS_USIZE: usize = unsafe { Foo { a: &1 }.b};\n+\n+fn main() {\n+}"}, {"sha": "a5e341524bc7312b0911d0624f12112adb56cf1c", "filename": "src/test/ui/const-eval/ub-uninhabit.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+union Foo {\n+    a: u8,\n+    b: Bar,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum Bar {}\n+\n+const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {\n+}"}, {"sha": "623b98dc4531b797054f177d80704d035a9b4f4b", "filename": "src/test/ui/const-eval/ub-uninhabit.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-uninhabit.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-uninhabit.rs:19:1\n+   |\n+LL | const BAD_BAD_BAD: Bar = unsafe { Foo { a: 1 }.b};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a value of an uninhabited type\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "aaff2f233815baa590fe58d774232e3ccecc46e9", "filename": "src/test/ui/const-eval/ub-usize-in-ref.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-usize-in-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Fub-usize-in-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fub-usize-in-ref.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+union Foo {\n+    a: &'static u8,\n+    b: usize,\n+}\n+\n+// This might point to an invalid address, but that's the user's problem\n+const USIZE_AS_STATIC_REF: &'static u8 = unsafe { Foo { b: 1337 }.a};\n+\n+fn main() {\n+}"}, {"sha": "41981e1256791551bba81f345f8e89ba7e48c285", "filename": "src/test/ui/const-eval/union-const-eval-field.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+type Field1 = i32;\n+type Field2 = f32;\n+type Field3 = i64;\n+\n+union DummyUnion {\n+    field1: Field1,\n+    field2: Field2,\n+    field3: Field3,\n+}\n+\n+const FLOAT1_AS_I32: i32 = 1065353216;\n+const UNION: DummyUnion = DummyUnion { field1: FLOAT1_AS_I32 };\n+\n+const fn read_field1() -> Field1 {\n+    const FIELD1: Field1 = unsafe { UNION.field1 };\n+    FIELD1\n+}\n+\n+const fn read_field2() -> Field2 {\n+    const FIELD2: Field2 = unsafe { UNION.field2 };\n+    FIELD2\n+}\n+\n+const fn read_field3() -> Field3 {\n+    const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR exhibits undefined behavior\n+    FIELD3\n+}\n+\n+fn main() {\n+    assert_eq!(read_field1(), FLOAT1_AS_I32);\n+    assert_eq!(read_field2(), 1.0);\n+    assert_eq!(read_field3(), unsafe { UNION.field3 });\n+}"}, {"sha": "94896d6c22577b4b7109f997caf440414926c8e5", "filename": "src/test/ui/const-eval/union-const-eval-field.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-const-eval-field.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-const-eval-field.rs:37:5\n+   |\n+LL |     const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR exhibits undefined behavior\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "426710389eb2951e386426857e1eca1000bbca89", "filename": "src/test/ui/const-eval/union-ice.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+type Field1 = i32;\n+type Field3 = i64;\n+\n+union DummyUnion {\n+    field1: Field1,\n+    field3: Field3,\n+}\n+\n+const UNION: DummyUnion = DummyUnion { field1: 1065353216 };\n+\n+const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant likely exhibits undefined\n+\n+const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibits undefined behavior\n+    a: 42,\n+    b: unsafe { UNION.field3 },\n+};\n+\n+struct Struct {\n+    a: u8,\n+    b: Field3,\n+}\n+\n+const FIELD_PATH2: Struct2 = Struct2 { //~ ERROR this constant likely exhibits undefined behavior\n+    b: [\n+        21,\n+        unsafe { UNION.field3 },\n+        23,\n+        24,\n+    ],\n+    a: 42,\n+};\n+\n+struct Struct2 {\n+    b: [Field3; 4],\n+    a: u8,\n+}\n+\n+fn main() {\n+}"}, {"sha": "58e9033a071a1209a01b1caf041e14697cd55ab3", "filename": "src/test/ui/const-eval/union-ice.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ice.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,36 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ice.rs:23:1\n+   |\n+LL | const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR this constant likely exhibits undefined\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered undefined bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ice.rs:25:1\n+   |\n+LL | / const FIELD_PATH: Struct = Struct { //~ ERROR this constant likely exhibits undefined behavior\n+LL | |     a: 42,\n+LL | |     b: unsafe { UNION.field3 },\n+LL | | };\n+   | |__^ type validation failed: encountered undefined bytes at .b\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ice.rs:35:1\n+   |\n+LL | / const FIELD_PATH2: Struct2 = Struct2 { //~ ERROR this constant likely exhibits undefined behavior\n+LL | |     b: [\n+LL | |         21,\n+LL | |         unsafe { UNION.field3 },\n+...  |\n+LL | |     a: 42,\n+LL | | };\n+   | |__^ type validation failed: encountered undefined bytes at .b[1]\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "db36764c4a30693f280666512ff10a16a3fd991a", "filename": "src/test/ui/const-eval/union-ub.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.rs?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+union DummyUnion {\n+    u8: u8,\n+    bool: bool,\n+}\n+\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A,\n+    B,\n+    C,\n+}\n+\n+#[derive(Copy, Clone)]\n+union Foo {\n+    a: bool,\n+    b: Enum,\n+}\n+\n+union Bar {\n+    foo: Foo,\n+    u8: u8,\n+}\n+\n+// the value is not valid for bools\n+const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// The value is not valid for any union variant, but that's fine\n+// unions are just a convenient way to transmute bits around\n+const BAD_UNION: Foo = unsafe { Bar { u8: 42 }.foo };\n+\n+\n+fn main() {\n+}"}, {"sha": "2a04dae337b271616a5662179ee57f1d4aa39cda", "filename": "src/test/ui/const-eval/union-ub.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70cac59031d5c33962a1f53cdca9359c0dcd1f9f/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Funion-ub.stderr?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -0,0 +1,11 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub.rs:36:1\n+   |\n+LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "e6f1e15676c26fdc7c4713647fe007b26f361a8e", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=70cac59031d5c33962a1f53cdca9359c0dcd1f9f", "patch": "@@ -1 +1 @@\n-Subproject commit 911aedf736992e907d11cb494167f41f28d02368\n+Subproject commit e6f1e15676c26fdc7c4713647fe007b26f361a8e"}]}