{"sha": "b7d8c88b64843d05761576aa093a34a8bc176817", "node_id": "C_kwDOAAsO6NoAKGI3ZDhjODhiNjQ4NDNkMDU3NjE1NzZhYTA5M2EzNGE4YmMxNzY4MTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-01T11:13:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-01T11:13:49Z"}, "message": "Auto merge of #111036 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nr? `@ghost`", "tree": {"sha": "f1542a0a19b65d4a528e99661a4047efd2c031a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1542a0a19b65d4a528e99661a4047efd2c031a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7d8c88b64843d05761576aa093a34a8bc176817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7d8c88b64843d05761576aa093a34a8bc176817", "html_url": "https://github.com/rust-lang/rust/commit/b7d8c88b64843d05761576aa093a34a8bc176817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7d8c88b64843d05761576aa093a34a8bc176817/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b87ed9d0f18166a26aadb5289bac004e058b90f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b87ed9d0f18166a26aadb5289bac004e058b90f", "html_url": "https://github.com/rust-lang/rust/commit/4b87ed9d0f18166a26aadb5289bac004e058b90f"}, {"sha": "f4acc67434ce945a5b9e4b8973e5872b05774218", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4acc67434ce945a5b9e4b8973e5872b05774218", "html_url": "https://github.com/rust-lang/rust/commit/f4acc67434ce945a5b9e4b8973e5872b05774218"}], "stats": {"total": 1891, "additions": 1436, "deletions": 455}, "files": [{"sha": "d7806b5daa63a5f21b4579ea895661e6cbe6f7fc", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -5100,11 +5100,12 @@ checksum = \"9e79c4d996edb816c91e4308506774452e55e95c3c9de07b6729e17e15a5ef81\"\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.5.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n+checksum = \"3e10f5f88ce8c331a388deda1e6e2bd533c73ca89cc5f539a3df02ed35c8efba\"\n dependencies = [\n  \"bstr 1.3.0\",\n+ \"cargo-platform\",\n  \"cargo_metadata 0.15.3\",\n  \"color-eyre\",\n  \"colored\",\n@@ -5113,6 +5114,7 @@ dependencies = [\n  \"lazy_static\",\n  \"regex\",\n  \"rustc_version\",\n+ \"rustfix\",\n  \"serde\",\n  \"serde_json\",\n  \"tempfile\","}, {"sha": "10079ba85b6b3fb6449a5c6b6b8afb72f7742db1", "filename": "src/tools/miri/Cargo.lock", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.lock?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -26,6 +26,12 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.70\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7de8ce5e0f9f8d88245311066a578d72b7af3e7088f32783804676302df237e4\"\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.14\"\n@@ -292,9 +298,9 @@ dependencies = [\n \n [[package]]\n name = \"libffi-sys\"\n-version = \"2.2.1\"\n+version = \"2.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dc65067b78c0fc069771e8b9a9e02df71e08858bec92c1f101377c67b9dca7c7\"\n+checksum = \"f36115160c57e8529781b4183c2bb51fdc1f6d6d1ed345591d84be7703befb3c\"\n dependencies = [\n  \"cc\",\n ]\n@@ -570,6 +576,18 @@ dependencies = [\n  \"semver\",\n ]\n \n+[[package]]\n+name = \"rustfix\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ecd2853d9e26988467753bd9912c3a126f642d05d229a4b53f5752ee36c56481\"\n+dependencies = [\n+ \"anyhow\",\n+ \"log\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"ryu\"\n version = \"1.0.12\"\n@@ -744,11 +762,12 @@ dependencies = [\n \n [[package]]\n name = \"ui_test\"\n-version = \"0.5.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n+checksum = \"3e10f5f88ce8c331a388deda1e6e2bd533c73ca89cc5f539a3df02ed35c8efba\"\n dependencies = [\n  \"bstr\",\n+ \"cargo-platform\",\n  \"cargo_metadata\",\n  \"color-eyre\",\n  \"colored\",\n@@ -757,6 +776,7 @@ dependencies = [\n  \"lazy_static\",\n  \"regex\",\n  \"rustc_version\",\n+ \"rustfix\",\n  \"serde\",\n  \"serde_json\",\n  \"tempfile\","}, {"sha": "b962d0c10962f7be1e6c35eb23537b2657971fd6", "filename": "src/tools/miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCargo.toml?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -39,7 +39,7 @@ libloading = \"0.7\"\n \n [dev-dependencies]\n colored = \"2\"\n-ui_test = \"0.5\"\n+ui_test = \"0.6.2\"\n rustc_version = \"0.4\"\n # Features chosen to match those required by env_logger, to avoid rebuilds\n regex = { version = \"1.5.5\", default-features = false, features = [\"perf\", \"std\"] }"}, {"sha": "640a953dac9cbc9c4a187719bcd0302f68920f89", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -407,7 +407,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n   fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n   recurses, `scalar` (the default) means it only recurses for types where we would also emit\n-  `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n+  `noalias` annotations in the generated LLVM IR (types passed as individual scalars or pairs of\n   scalars). Setting this to `none` is **unsound**.\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to"}, {"sha": "85c9cdad7dfd21c52c73b2c87f8e44c4d7fc9db2", "filename": "src/tools/miri/cargo-miri/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -81,7 +81,7 @@ fn main() {\n         \"miri\" => phase_cargo_miri(args),\n         \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n         arg if arg == env::var(\"RUSTC\").unwrap() => {\n-            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // If the first arg is equal to the RUSTC env variable (which should be set at this\n             // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n             // behavior of having both RUSTC and RUSTC_WRAPPER set\n             // (see https://github.com/rust-lang/cargo/issues/10886)."}, {"sha": "4be970b398dca93bba6b9451ac2e91232ac45168", "filename": "src/tools/miri/miri", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -121,10 +121,10 @@ rustc-pull)\n     # Update rust-version file. As a separate commit, since making it part of\n     # the merge has confused the heck out of josh in the past.\n     echo \"$FETCH_COMMIT\" > rust-version\n-    git commit rust-version -m \"Preparing for merge from rustc\"\n+    git commit rust-version -m \"Preparing for merge from rustc\" || (echo \"FAILED to commit rust-version file, something went wrong\"; exit 1)\n     # Fetch given rustc commit and note down which one that was\n-    git fetch http://localhost:8000/rust-lang/rust.git@$FETCH_COMMIT$JOSH_FILTER.git\n-    git merge FETCH_HEAD --no-ff -m \"Merge from rustc\"\n+    git fetch http://localhost:8000/rust-lang/rust.git@$FETCH_COMMIT$JOSH_FILTER.git || (echo \"FAILED to fetch new commits, something went wrong\"; exit 1)\n+    git merge FETCH_HEAD --no-ff -m \"Merge from rustc\" || (echo \"FAILED to merge new commits, something went wrong\"; exit 1)\n     exit 0\n     ;;\n rustc-push)"}, {"sha": "d4bffe5f9454f5bffe724c6f9fcd94cd753b974a", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1 +1 @@\n-d4be8efc6296bace5b1e165f1b34d3c6da76aa8e\n+eb62877597000ccf8bb99ab131b5977344afdfa3"}, {"sha": "e4ca40570b7fe024905a98baa75b83a73ebb46e5", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -120,7 +120,7 @@ impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n     #[allow(rustc::potential_query_instability)] // rustc_codegen_ssa (where this code is copied from) also allows this lint\n     fn config(&mut self, config: &mut Config) {\n         if config.opts.prints.is_empty() && self.target_crate {\n-            // Queries overriden here affect the data stored in `rmeta` files of dependencies,\n+            // Queries overridden here affect the data stored in `rmeta` files of dependencies,\n             // which will be used later in non-`MIRI_BE_RUSTC` mode.\n             config.override_queries = Some(|_, local_providers, _| {\n                 // `exported_symbols` and `reachable_non_generics` provided by rustc always returns"}, {"sha": "ffc49eedb5a982091ec539be176f9ac822cb4769", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -238,7 +238,7 @@ pub enum BorrowTrackerMethod {\n }\n \n impl BorrowTrackerMethod {\n-    pub fn instanciate_global_state(self, config: &MiriConfig) -> GlobalState {\n+    pub fn instantiate_global_state(self, config: &MiriConfig) -> GlobalState {\n         RefCell::new(GlobalStateInner::new(\n             self,\n             config.tracked_pointer_tags.clone(),"}, {"sha": "c9674e0a2fe2c2a7795b765ade1fb94c1d477ba4", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -292,7 +292,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .rev()\n             .find_map(|event| {\n                 // First, look for a Creation event where the tag and the offset matches. This\n-                // ensrues that we pick the right Creation event when a retag isn't uniform due to\n+                // ensures that we pick the right Creation event when a retag isn't uniform due to\n                 // Freeze.\n                 let range = event.retag.range;\n                 if event.retag.new_tag == tag"}, {"sha": "4d7bbb643b89635e5724da3ba7245185d814fc99", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> Stack {\n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n                 // This is approximate. Nobody knows what happened, so forget everything.\n-                // The new thing is SRW anyway, so we cannot push it \"on top of the unkown part\"\n+                // The new thing is SRW anyway, so we cannot push it \"on top of the unknown part\"\n                 // (for all we know, it might join an SRW group inside the unknown).\n                 trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n                 self.set_unknown_bottom(global.next_ptr_tag);\n@@ -825,7 +825,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         Ok(Some(alloc_id))\n     }\n \n-    /// Retags an indidual pointer, returning the retagged version.\n+    /// Retags an individual pointer, returning the retagged version.\n     /// `kind` indicates what kind of reference is being created.\n     fn sb_retag_reference(\n         &mut self,"}, {"sha": "064dbe025af944b38a398c1699020fc2374e8614", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -51,7 +51,7 @@ impl Stack {\n         // Note that the algorithm below is based on considering the tag at read_idx - 1,\n         // so precisely considering the tag at index 0 for removal when we have an unknown\n         // bottom would complicate the implementation. The simplification of not considering\n-        // it does not have a significant impact on the degree to which the GC mititages\n+        // it does not have a significant impact on the degree to which the GC mitigates\n         // memory growth.\n         let mut read_idx = 1;\n         let mut write_idx = read_idx;"}, {"sha": "2c6d27ced0180df81e3d8768c6881be94712a68f", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "modified", "additions": 207, "deletions": 38, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,14 +1,90 @@\n-use rustc_data_structures::fx::FxHashMap;\n-\n use std::fmt;\n use std::ops::Range;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::{Span, SpanData};\n+use rustc_target::abi::Size;\n+\n use crate::borrow_tracker::tree_borrows::{\n-    err_tb_ub, perms::Permission, tree::LocationState, unimap::UniIndex,\n+    perms::{PermTransition, Permission},\n+    tree::LocationState,\n+    unimap::UniIndex,\n };\n use crate::borrow_tracker::{AccessKind, ProtectorKind};\n use crate::*;\n \n+/// Complete data for an event:\n+/// - `kind` is what happened to the permissions\n+/// - `access_kind` and `access_range` describe the access that caused the event\n+/// - `offset` allows filtering only the relevant events for a given memory location\n+/// (see how we perform the filtering in `History::extract_relevant`.\n+/// - `span` is the line of code in question\n+#[derive(Clone, Debug)]\n+pub struct Event {\n+    pub transition: PermTransition,\n+    pub access_kind: AccessKind,\n+    pub is_foreign: bool,\n+    pub access_range: AllocRange,\n+    pub offset: Size,\n+    pub span: Span,\n+}\n+\n+/// List of all events that affected a tag.\n+/// NOTE: not all of these events are relevant for a particular location,\n+/// the events should be filtered before the generation of diagnostics.\n+/// Available filtering methods include `History::forget` and `History::extract_relevant`.\n+#[derive(Clone, Debug)]\n+pub struct History {\n+    pub tag: BorTag,\n+    pub created: (Span, Permission),\n+    pub events: Vec<Event>,\n+}\n+\n+/// History formatted for use by `src/diagnostics.rs`.\n+///\n+/// NOTE: needs to be `Send` because of a bound on `MachineStopType`, hence\n+/// the use of `SpanData` rather than `Span`.\n+#[derive(Debug, Clone, Default)]\n+pub struct HistoryData {\n+    pub events: Vec<(Option<SpanData>, String)>, // includes creation\n+}\n+\n+impl History {\n+    /// Record an additional event to the history.\n+    pub fn push(&mut self, event: Event) {\n+        self.events.push(event);\n+    }\n+}\n+\n+impl HistoryData {\n+    // Format events from `new_history` into those recorded by `self`.\n+    //\n+    // NOTE: also converts `Span` to `SpanData`.\n+    pub fn extend(\n+        &mut self,\n+        new_history: History,\n+        tag_name: &'static str,\n+        show_initial_state: bool,\n+    ) {\n+        let History { tag, created, events } = new_history;\n+        let this = format!(\"the {tag_name} tag {tag:?}\");\n+        let msg_initial_state = format!(\", in the initial state {}\", created.1);\n+        let msg_creation = format!(\n+            \"{this} was created here{maybe_msg_initial_state}\",\n+            maybe_msg_initial_state = if show_initial_state { &msg_initial_state } else { \"\" },\n+        );\n+\n+        self.events.push((Some(created.0.data()), msg_creation));\n+        for &Event { transition, access_kind, is_foreign, access_range, span, offset: _ } in &events\n+        {\n+            // NOTE: `offset` is explicitly absent from the error message, it has no significance\n+            // to the user. The meaningful one is `access_range`.\n+            self.events.push((Some(span.data()), format!(\"{this} then transitioned {transition} due to a {rel} {access_kind} at offsets {access_range:?}\", rel = if is_foreign { \"foreign\" } else { \"child\" })));\n+            self.events.push((None, format!(\"this corresponds to {}\", transition.summary())));\n+        }\n+    }\n+}\n+\n /// Some information that is irrelevant for the algorithm but very\n /// convenient to know about a tag for debugging and testing.\n #[derive(Clone, Debug)]\n@@ -20,18 +96,29 @@ pub struct NodeDebugInfo {\n     /// pointer in the source code.\n     /// Helps match tag numbers to human-readable names.\n     pub name: Option<String>,\n+    /// Notable events in the history of this tag, used for\n+    /// diagnostics.\n+    ///\n+    /// NOTE: by virtue of being part of `NodeDebugInfo`,\n+    /// the history is automatically cleaned up by the GC.\n+    /// NOTE: this is `!Send`, it needs to be converted before displaying\n+    /// the actual diagnostics because `src/diagnostics.rs` requires `Send`.\n+    pub history: History,\n }\n+\n impl NodeDebugInfo {\n-    /// New node info with a name.\n-    pub fn new(tag: BorTag) -> Self {\n-        Self { tag, name: None }\n+    /// Information for a new node. By default it has no\n+    /// name and an empty history.\n+    pub fn new(tag: BorTag, initial: Permission, span: Span) -> Self {\n+        let history = History { tag, created: (span, initial), events: Vec::new() };\n+        Self { tag, name: None, history }\n     }\n \n     /// Add a name to the tag. If a same tag is associated to several pointers,\n     /// it can have several names which will be separated by commas.\n-    fn add_name(&mut self, name: &str) {\n+    pub fn add_name(&mut self, name: &str) {\n         if let Some(ref mut prev_name) = &mut self.name {\n-            prev_name.push(',');\n+            prev_name.push_str(\", \");\n             prev_name.push_str(name);\n         } else {\n             self.name = Some(String::from(name));\n@@ -42,7 +129,7 @@ impl NodeDebugInfo {\n impl fmt::Display for NodeDebugInfo {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         if let Some(ref name) = self.name {\n-            write!(f, \"{tag:?} (also named '{name}')\", tag = self.tag)\n+            write!(f, \"{tag:?} ({name})\", tag = self.tag)\n         } else {\n             write!(f, \"{tag:?}\", tag = self.tag)\n         }\n@@ -86,7 +173,7 @@ impl<'tcx> Tree {\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, PartialEq)]\n pub(super) enum TransitionError {\n     /// This access is not allowed because some parent tag has insufficient permissions.\n     /// For example, if a tag is `Frozen` and encounters a child write this will\n@@ -96,63 +183,145 @@ pub(super) enum TransitionError {\n     /// A protector was triggered due to an invalid transition that loses\n     /// too much permissions.\n     /// For example, if a protected tag goes from `Active` to `Frozen` due\n-    /// to a foreign write this will produce a `ProtectedTransition(Active, Frozen)`.\n+    /// to a foreign write this will produce a `ProtectedTransition(PermTransition(Active, Frozen))`.\n     /// This kind of error can only occur on foreign accesses.\n-    ProtectedTransition(Permission, Permission),\n+    ProtectedTransition(PermTransition),\n     /// Cannot deallocate because some tag in the allocation is strongly protected.\n     /// This kind of error can only occur on deallocations.\n     ProtectedDealloc,\n }\n \n+impl History {\n+    /// Keep only the tag and creation\n+    fn forget(&self) -> Self {\n+        History { events: Vec::new(), created: self.created, tag: self.tag }\n+    }\n+\n+    /// Reconstruct the history relevant to `error_offset` knowing that\n+    /// its permission followed `complete_transition`.\n+    ///\n+    /// Here's how we do this:\n+    /// - we know `full := complete_transition` the transition of the permission from\n+    /// its initialization to the state just before the error was caused,\n+    /// we want to find a chain of events that produces `full`\n+    /// - we decompose `full` into `pre o post` where\n+    /// `pre` is the best applicable transition from recorded events\n+    /// - we select the event that caused `pre` and iterate\n+    /// to find the chain of events that produces `full := post`\n+    ///\n+    /// To find the \"best applicable transition\" for full:\n+    /// - eliminate events that cannot be applied because their offset is too big\n+    /// - eliminate events that cannot be applied because their starting point is wrong\n+    /// - select the one that happened closest to the range of interest\n+    fn extract_relevant(&self, complete_transition: PermTransition, error_offset: Size) -> Self {\n+        let mut selected_events: Vec<Event> = Vec::new();\n+        let mut full = complete_transition;\n+        while !full.is_noop() {\n+            let (pre, post) = self\n+                .events\n+                .iter()\n+                .filter(|e| e.offset <= error_offset)\n+                .filter_map(|pre_canditate| {\n+                    full.apply_start(pre_canditate.transition)\n+                        .map(|post_canditate| (pre_canditate, post_canditate))\n+                })\n+                .max_by_key(|(pre_canditate, _post_candidate)| pre_canditate.offset)\n+                .unwrap();\n+            // If this occurs we will loop infinitely !\n+            // Make sure to only put non-noop transitions in `History`.\n+            assert!(!pre.transition.is_noop());\n+            full = post;\n+            selected_events.push(pre.clone());\n+        }\n+\n+        History { events: selected_events, created: self.created, tag: self.tag }\n+    }\n+}\n+\n /// Failures that can occur during the execution of Tree Borrows procedures.\n pub(super) struct TbError<'node> {\n     /// What failure occurred.\n     pub error_kind: TransitionError,\n+    /// The byte at which the conflict occured.\n+    pub error_offset: Size,\n     /// The tag on which the error was triggered.\n     /// On protector violations, this is the tag that was protected.\n     /// On accesses rejected due to insufficient permissions, this is the\n     /// tag that lacked those permissions.\n-    pub faulty_tag: &'node NodeDebugInfo,\n+    pub conflicting_info: &'node NodeDebugInfo,\n     /// Whether this was a Read or Write access. This field is ignored\n     /// when the error was triggered by a deallocation.\n     pub access_kind: AccessKind,\n     /// Which tag the access that caused this error was made through, i.e.\n     /// which tag was used to read/write/deallocate.\n-    pub tag_of_access: &'node NodeDebugInfo,\n+    pub accessed_info: &'node NodeDebugInfo,\n }\n \n impl TbError<'_> {\n     /// Produce a UB error.\n-    pub fn build<'tcx>(self) -> InterpErrorInfo<'tcx> {\n+    pub fn build<'tcx>(self) -> InterpError<'tcx> {\n         use TransitionError::*;\n-        err_tb_ub(match self.error_kind {\n+        let started_as = self.conflicting_info.history.created.1;\n+        let kind = self.access_kind;\n+        let accessed = self.accessed_info;\n+        let conflicting = self.conflicting_info;\n+        let accessed_is_conflicting = accessed.tag == conflicting.tag;\n+        let (pre_error, title, details, conflicting_tag_name) = match self.error_kind {\n             ChildAccessForbidden(perm) => {\n-                format!(\n-                    \"{kind} through {initial} is forbidden because it is a child of {current} which is {perm}.\",\n-                    kind=self.access_kind,\n-                    initial=self.tag_of_access,\n-                    current=self.faulty_tag,\n-                    perm=perm,\n-                )\n+                let conflicting_tag_name =\n+                    if accessed_is_conflicting { \"accessed\" } else { \"conflicting\" };\n+                let title = format!(\"{kind} through {accessed} is forbidden\");\n+                let mut details = Vec::new();\n+                if !accessed_is_conflicting {\n+                    details.push(format!(\n+                        \"the accessed tag {accessed} is a child of the conflicting tag {conflicting}\"\n+                    ));\n+                }\n+                details.push(format!(\n+                    \"the {conflicting_tag_name} tag {conflicting} has state {perm} which forbids child {kind}es\"\n+                ));\n+                (perm, title, details, conflicting_tag_name)\n             }\n-            ProtectedTransition(start, end) => {\n-                format!(\n-                    \"{kind} through {initial} is forbidden because it is a foreign tag for {current}, which would hence change from {start} to {end}, but {current} is protected\",\n-                    current=self.faulty_tag,\n-                    start=start,\n-                    end=end,\n-                    kind=self.access_kind,\n-                    initial=self.tag_of_access,\n-                )\n+            ProtectedTransition(transition) => {\n+                let conflicting_tag_name = \"protected\";\n+                let title = format!(\"{kind} through {accessed} is forbidden\");\n+                let details = vec![\n+                    format!(\n+                        \"the accessed tag {accessed} is foreign to the {conflicting_tag_name} tag {conflicting} (i.e., it is not a child)\"\n+                    ),\n+                    format!(\n+                        \"the access would cause the {conflicting_tag_name} tag {conflicting} to transition {transition}\"\n+                    ),\n+                    format!(\n+                        \"this is {loss}, which is not allowed for protected tags\",\n+                        loss = transition.summary(),\n+                    ),\n+                ];\n+                (transition.started(), title, details, conflicting_tag_name)\n             }\n             ProtectedDealloc => {\n-                format!(\n-                    \"the allocation of {initial} also contains {current} which is strongly protected, cannot deallocate\",\n-                    initial=self.tag_of_access,\n-                    current=self.faulty_tag,\n-                )\n+                let conflicting_tag_name = \"strongly protected\";\n+                let title = format!(\"deallocation through {accessed} is forbidden\");\n+                let details = vec![\n+                    format!(\n+                        \"the allocation of the accessed tag {accessed} also contains the {conflicting_tag_name} tag {conflicting}\"\n+                    ),\n+                    format!(\"the {conflicting_tag_name} tag {conflicting} disallows deallocations\"),\n+                ];\n+                (started_as, title, details, conflicting_tag_name)\n             }\n-        }).into()\n+        };\n+        let pre_transition = PermTransition::from(started_as, pre_error).unwrap();\n+        let mut history = HistoryData::default();\n+        if !accessed_is_conflicting {\n+            history.extend(self.accessed_info.history.forget(), \"accessed\", false);\n+        }\n+        history.extend(\n+            self.conflicting_info.history.extract_relevant(pre_transition, self.error_offset),\n+            conflicting_tag_name,\n+            true,\n+        );\n+        err_machine_stop!(TerminationInfo::TreeBorrowsUb { title, details, history })\n     }\n }\n "}, {"sha": "3361d212f2c0837bd6e9b8dbfbed83ad06aa838c", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/mod.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::{\n \n use crate::*;\n \n-mod diagnostics;\n+pub mod diagnostics;\n mod perms;\n mod tree;\n mod unimap;\n@@ -23,10 +23,6 @@ pub use tree::Tree;\n \n pub type AllocState = Tree;\n \n-pub fn err_tb_ub<'tcx>(msg: String) -> InterpError<'tcx> {\n-    err_machine_stop!(TerminationInfo::TreeBorrowsUb { msg })\n-}\n-\n impl<'tcx> Tree {\n     /// Create a new allocation, i.e. a new tree\n     pub fn new_allocation(\n@@ -37,7 +33,8 @@ impl<'tcx> Tree {\n         machine: &MiriMachine<'_, 'tcx>,\n     ) -> Self {\n         let tag = state.base_ptr_tag(id, machine); // Fresh tag for the root\n-        Tree::new(tag, size)\n+        let span = machine.current_span();\n+        Tree::new(tag, size, span)\n     }\n \n     /// Check that an access on the entire range is permitted, and update\n@@ -64,7 +61,8 @@ impl<'tcx> Tree {\n             ProvenanceExtra::Wildcard => return Ok(()),\n         };\n         let global = machine.borrow_tracker.as_ref().unwrap();\n-        self.perform_access(access_kind, tag, range, global)\n+        let span = machine.current_span();\n+        self.perform_access(access_kind, tag, range, global, span)\n     }\n \n     /// Check that this pointer has permission to deallocate this range.\n@@ -82,7 +80,8 @@ impl<'tcx> Tree {\n             ProvenanceExtra::Wildcard => return Ok(()),\n         };\n         let global = machine.borrow_tracker.as_ref().unwrap();\n-        self.dealloc(tag, range, global)\n+        let span = machine.current_span();\n+        self.dealloc(tag, range, global, span)\n     }\n \n     pub fn expose_tag(&mut self, _tag: BorTag) {\n@@ -265,25 +264,27 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 .insert(new_tag, protect);\n         }\n \n+        let span = this.machine.current_span();\n         let alloc_extra = this.get_alloc_extra(alloc_id)?;\n         let range = alloc_range(base_offset, ptr_size);\n         let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n \n         if new_perm.perform_read_access {\n             // Count this reborrow as a read access\n             let global = &this.machine.borrow_tracker.as_ref().unwrap();\n-            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global)?;\n+            let span = this.machine.current_span();\n+            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global, span)?;\n             if let Some(data_race) = alloc_extra.data_race.as_ref() {\n                 data_race.read(alloc_id, range, &this.machine)?;\n             }\n         }\n \n         // Record the parent-child pair in the tree.\n-        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range)?;\n+        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range, span)?;\n         Ok(Some((alloc_id, new_tag)))\n     }\n \n-    /// Retags an indidual pointer, returning the retagged version.\n+    /// Retags an individual pointer, returning the retagged version.\n     fn tb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,"}, {"sha": "7e3e587db7248e3a1e240bd5ba6583384526b5b1", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "modified", "additions": 136, "deletions": 64, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n use crate::borrow_tracker::tree_borrows::tree::AccessRelatedness;\n use crate::borrow_tracker::AccessKind;\n \n-/// The activation states of a pointer\n+/// The activation states of a pointer.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum PermissionPriv {\n     /// represents: a local reference that has not yet been written to;\n@@ -112,47 +112,14 @@ mod transition {\n     }\n }\n \n-impl PermissionPriv {\n-    /// Determines whether a transition that occured is compatible with the presence\n-    /// of a Protector. This is not included in the `transition` functions because\n-    /// it would distract from the few places where the transition is modified\n-    /// because of a protector, but not forbidden.\n-    fn protector_allows_transition(self, new: Self) -> bool {\n-        match (self, new) {\n-            _ if self == new => true,\n-            // It is always a protector violation to not be readable anymore\n-            (_, Disabled) => false,\n-            // In the case of a `Reserved` under a protector, both transitions\n-            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n-            // The first is standard (Child Write), the second is for Foreign Writes\n-            // on protected Reserved where we must ensure that the pointer is not\n-            // written to in the future.\n-            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n-            // This pointer should have stayed writeable for the whole function\n-            (Active, Frozen) => false,\n-            _ => unreachable!(\"Transition from {self:?} to {new:?} should never be possible\"),\n-        }\n-    }\n-}\n-\n /// Public interface to the state machine that controls read-write permissions.\n+/// This is the \"private `enum`\" pattern.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct Permission(PermissionPriv);\n \n-impl fmt::Display for Permission {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}\",\n-            match self.0 {\n-                PermissionPriv::Reserved { .. } => \"Reserved\",\n-                PermissionPriv::Active => \"Active\",\n-                PermissionPriv::Frozen => \"Frozen\",\n-                PermissionPriv::Disabled => \"Disabled\",\n-            }\n-        )\n-    }\n-}\n+/// Transition from one permission to the next.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct PermTransition(PermissionPriv, PermissionPriv);\n \n impl Permission {\n     /// Default initial permission of the root of a new tree.\n@@ -170,43 +137,148 @@ impl Permission {\n         Self(Frozen)\n     }\n \n-    /// Pretty-printing. Needs to be here and not in diagnostics.rs\n-    /// because `Self` is private.\n-    pub fn short_name(self) -> &'static str {\n-        // Make sure there are all of the same length as each other\n-        // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n-        // alignment will be incorrect.\n-        match self.0 {\n-            Reserved { ty_is_freeze: true } => \"Res\",\n-            Reserved { ty_is_freeze: false } => \"Re*\",\n-            Active => \"Act\",\n-            Frozen => \"Frz\",\n-            Disabled => \"Dis\",\n-        }\n+    /// Apply the transition to the inner PermissionPriv.\n+    pub fn perform_access(\n+        kind: AccessKind,\n+        rel_pos: AccessRelatedness,\n+        old_perm: Self,\n+        protected: bool,\n+    ) -> Option<PermTransition> {\n+        let old_state = old_perm.0;\n+        transition::perform_access(kind, rel_pos, old_state, protected)\n+            .map(|new_state| PermTransition(old_state, new_state))\n     }\n+}\n \n-    /// Check that there are no complaints from a possible protector.\n+impl PermTransition {\n+    /// All transitions created through normal means (using `perform_access`)\n+    /// should be possible, but the same is not guaranteed by construction of\n+    /// transitions inferred by diagnostics. This checks that a transition\n+    /// reconstructed by diagnostics is indeed one that could happen.\n+    fn is_possible(old: PermissionPriv, new: PermissionPriv) -> bool {\n+        old <= new\n+    }\n+\n+    pub fn from(old: Permission, new: Permission) -> Option<Self> {\n+        Self::is_possible(old.0, new.0).then_some(Self(old.0, new.0))\n+    }\n+\n+    pub fn is_noop(self) -> bool {\n+        self.0 == self.1\n+    }\n+\n+    /// Extract result of a transition (checks that the starting point matches).\n+    pub fn applied(self, starting_point: Permission) -> Option<Permission> {\n+        (starting_point.0 == self.0).then_some(Permission(self.1))\n+    }\n+\n+    /// Extract starting point of a transition\n+    pub fn started(self) -> Permission {\n+        Permission(self.0)\n+    }\n+\n+    /// Determines whether a transition that occured is compatible with the presence\n+    /// of a Protector. This is not included in the `transition` functions because\n+    /// it would distract from the few places where the transition is modified\n+    /// because of a protector, but not forbidden.\n     ///\n     /// Note: this is not in charge of checking that there *is* a protector,\n     /// it should be used as\n     /// ```\n     /// let no_protector_error = if is_protected(tag) {\n-    ///     old_perm.protector_allows_transition(new_perm)\n+    ///     transition.is_allowed_by_protector()\n     /// };\n     /// ```\n-    pub fn protector_allows_transition(self, new: Self) -> bool {\n-        self.0.protector_allows_transition(new.0)\n+    pub fn is_allowed_by_protector(&self) -> bool {\n+        let &Self(old, new) = self;\n+        assert!(Self::is_possible(old, new));\n+        match (old, new) {\n+            _ if old == new => true,\n+            // It is always a protector violation to not be readable anymore\n+            (_, Disabled) => false,\n+            // In the case of a `Reserved` under a protector, both transitions\n+            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n+            // The first is standard (Child Write), the second is for Foreign Writes\n+            // on protected Reserved where we must ensure that the pointer is not\n+            // written to in the future.\n+            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n+            // This pointer should have stayed writeable for the whole function\n+            (Active, Frozen) => false,\n+            _ => unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n+        }\n     }\n \n-    /// Apply the transition to the inner PermissionPriv.\n-    pub fn perform_access(\n-        kind: AccessKind,\n-        rel_pos: AccessRelatedness,\n-        old_perm: Self,\n-        protected: bool,\n-    ) -> Option<Self> {\n-        let old_state = old_perm.0;\n-        transition::perform_access(kind, rel_pos, old_state, protected).map(Self)\n+    /// Composition function: get the transition that can be added after `app` to\n+    /// produce `self`.\n+    pub fn apply_start(self, app: Self) -> Option<Self> {\n+        let new_start = app.applied(Permission(self.0))?;\n+        Self::from(new_start, Permission(self.1))\n+    }\n+}\n+\n+pub mod diagnostics {\n+    use super::*;\n+    impl fmt::Display for PermissionPriv {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(\n+                f,\n+                \"{}\",\n+                match self {\n+                    PermissionPriv::Reserved { .. } => \"Reserved\",\n+                    PermissionPriv::Active => \"Active\",\n+                    PermissionPriv::Frozen => \"Frozen\",\n+                    PermissionPriv::Disabled => \"Disabled\",\n+                }\n+            )\n+        }\n+    }\n+\n+    impl fmt::Display for PermTransition {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"from {} to {}\", self.0, self.1)\n+        }\n+    }\n+\n+    impl fmt::Display for Permission {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"{}\", self.0)\n+        }\n+    }\n+\n+    impl Permission {\n+        /// Abbreviated name of the permission (uniformly 3 letters for nice alignment).\n+        pub fn short_name(self) -> &'static str {\n+            // Make sure there are all of the same length as each other\n+            // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n+            // alignment will be incorrect.\n+            match self.0 {\n+                Reserved { ty_is_freeze: true } => \"Res\",\n+                Reserved { ty_is_freeze: false } => \"Re*\",\n+                Active => \"Act\",\n+                Frozen => \"Frz\",\n+                Disabled => \"Dis\",\n+            }\n+        }\n+    }\n+\n+    impl PermTransition {\n+        /// Readable explanation of the consequences of an event.\n+        /// Fits in the sentence \"This accessed caused {trans.summary()}\".\n+        ///\n+        /// Important: for the purposes of this explanation, `Reserved` is considered\n+        /// to have write permissions, because that's what the diagnostics care about\n+        /// (otherwise `Reserved -> Frozen` would be considered a noop).\n+        pub fn summary(&self) -> &'static str {\n+            assert!(Self::is_possible(self.0, self.1));\n+            match (self.0, self.1) {\n+                (_, Active) => \"an activation\",\n+                (_, Frozen) => \"a loss of write permissions\",\n+                (Frozen, Disabled) => \"a loss of read permissions\",\n+                (_, Disabled) => \"a loss of read and write permissions\",\n+                (old, new) =>\n+                    unreachable!(\"Transition from {old:?} to {new:?} should never be possible\"),\n+            }\n+        }\n     }\n }\n "}, {"sha": "6392f5101ad5f9a2ebb3bbc257d9bbe1ad541861", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 65, "deletions": 30, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -14,10 +14,11 @@ use smallvec::SmallVec;\n \n use rustc_const_eval::interpret::InterpResult;\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_span::Span;\n use rustc_target::abi::Size;\n \n use crate::borrow_tracker::tree_borrows::{\n-    diagnostics::{NodeDebugInfo, TbError, TransitionError},\n+    diagnostics::{self, NodeDebugInfo, TbError, TransitionError},\n     unimap::{UniEntry, UniIndex, UniKeyMap, UniValMap},\n     Permission,\n };\n@@ -34,7 +35,7 @@ pub(super) struct LocationState {\n     /// Before initialization we still apply some preemptive transitions on\n     /// `permission` to know what to do in case it ever gets initialized,\n     /// but these can never cause any immediate UB. There can however be UB\n-    /// the moment we attempt to initalize (i.e. child-access) because some\n+    /// the moment we attempt to initialize (i.e. child-access) because some\n     /// foreign access done between the creation and the initialization is\n     /// incompatible with child accesses.\n     initialized: bool,\n@@ -118,7 +119,7 @@ pub(super) struct Node {\n /// Data given to the transition function\n struct NodeAppArgs<'node> {\n     /// Node on which the transition is currently being applied\n-    node: &'node Node,\n+    node: &'node mut Node,\n     /// Mutable access to its permissions\n     perm: UniEntry<'node, LocationState>,\n     /// Relative position of the access\n@@ -131,14 +132,17 @@ struct ErrHandlerArgs<'node, InErr> {\n     /// Tag that triggered the error (not the tag that was accessed,\n     /// rather the parent tag that had insufficient permissions or the\n     /// non-parent tag that had a protector).\n-    faulty_tag: &'node NodeDebugInfo,\n+    conflicting_info: &'node NodeDebugInfo,\n+    /// Information about the tag that was accessed just before the\n+    /// error was triggered.\n+    accessed_info: &'node NodeDebugInfo,\n }\n /// Internal contents of `Tree` with the minimum of mutable access for\n /// the purposes of the tree traversal functions: the permissions (`perms`) can be\n /// updated but not the tree structure (`tag_mapping` and `nodes`)\n struct TreeVisitor<'tree> {\n     tag_mapping: &'tree UniKeyMap<BorTag>,\n-    nodes: &'tree UniValMap<Node>,\n+    nodes: &'tree mut UniValMap<Node>,\n     perms: &'tree mut UniValMap<LocationState>,\n }\n \n@@ -167,6 +171,7 @@ impl<'tree> TreeVisitor<'tree> {\n     ) -> Result<(), OutErr>\n where {\n         struct TreeVisitAux<NodeApp, ErrHandler> {\n+            accessed_tag: UniIndex,\n             f_propagate: NodeApp,\n             err_builder: ErrHandler,\n             stack: Vec<(UniIndex, AccessRelatedness)>,\n@@ -190,15 +195,21 @@ where {\n                 rel_pos: AccessRelatedness,\n             ) -> Result<(), OutErr> {\n                 // 1. apply the propagation function\n-                let node = this.nodes.get(tag).unwrap();\n+                let node = this.nodes.get_mut(tag).unwrap();\n                 let recurse =\n                     (self.f_propagate)(NodeAppArgs { node, perm: this.perms.entry(tag), rel_pos })\n                         .map_err(|error_kind| {\n                             (self.err_builder)(ErrHandlerArgs {\n                                 error_kind,\n-                                faulty_tag: &node.debug_info,\n+                                conflicting_info: &this.nodes.get(tag).unwrap().debug_info,\n+                                accessed_info: &this\n+                                    .nodes\n+                                    .get(self.accessed_tag)\n+                                    .unwrap()\n+                                    .debug_info,\n                             })\n                         })?;\n+                let node = this.nodes.get(tag).unwrap();\n                 // 2. add the children to the stack for future traversal\n                 if matches!(recurse, ContinueTraversal::Recurse) {\n                     let child_rel = rel_pos.for_child();\n@@ -214,7 +225,8 @@ where {\n         }\n \n         let start_idx = self.tag_mapping.get(&start).unwrap();\n-        let mut stack = TreeVisitAux { f_propagate, err_builder, stack: Vec::new() };\n+        let mut stack =\n+            TreeVisitAux { accessed_tag: start_idx, f_propagate, err_builder, stack: Vec::new() };\n         {\n             let mut path_ascend = Vec::new();\n             // First climb to the root while recording the path\n@@ -262,20 +274,23 @@ where {\n \n impl Tree {\n     /// Create a new tree, with only a root pointer.\n-    pub fn new(root_tag: BorTag, size: Size) -> Self {\n+    pub fn new(root_tag: BorTag, size: Size, span: Span) -> Self {\n         let root_perm = Permission::new_root();\n         let mut tag_mapping = UniKeyMap::default();\n         let root_idx = tag_mapping.insert(root_tag);\n         let nodes = {\n             let mut nodes = UniValMap::<Node>::default();\n+            let mut debug_info = NodeDebugInfo::new(root_tag, root_perm, span);\n+            // name the root so that all allocations contain one named pointer\n+            debug_info.add_name(\"root of the allocation\");\n             nodes.insert(\n                 root_idx,\n                 Node {\n                     tag: root_tag,\n                     parent: None,\n                     children: SmallVec::default(),\n                     default_initial_perm: root_perm,\n-                    debug_info: NodeDebugInfo::new(root_tag),\n+                    debug_info,\n                 },\n             );\n             nodes\n@@ -297,6 +312,7 @@ impl<'tcx> Tree {\n         new_tag: BorTag,\n         default_initial_perm: Permission,\n         range: AllocRange,\n+        span: Span,\n     ) -> InterpResult<'tcx> {\n         assert!(!self.tag_mapping.contains_key(&new_tag));\n         let idx = self.tag_mapping.insert(new_tag);\n@@ -309,7 +325,7 @@ impl<'tcx> Tree {\n                 parent: Some(parent_idx),\n                 children: SmallVec::default(),\n                 default_initial_perm,\n-                debug_info: NodeDebugInfo::new(new_tag),\n+                debug_info: NodeDebugInfo::new(new_tag, default_initial_perm, span),\n             },\n         );\n         // Register new_tag as a child of parent_tag\n@@ -330,11 +346,11 @@ impl<'tcx> Tree {\n         tag: BorTag,\n         range: AllocRange,\n         global: &GlobalState,\n+        span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        self.perform_access(AccessKind::Write, tag, range, global)?;\n-        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n-        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n-            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+        self.perform_access(AccessKind::Write, tag, range, global, span)?;\n+        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n                     |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n@@ -347,13 +363,14 @@ impl<'tcx> Tree {\n                             Ok(ContinueTraversal::Recurse)\n                         }\n                     },\n-                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n-                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpError<'tcx> {\n+                        let ErrHandlerArgs { error_kind, conflicting_info, accessed_info } = args;\n                         TbError {\n-                            faulty_tag,\n+                            conflicting_info,\n                             access_kind: AccessKind::Write,\n+                            error_offset: offset,\n                             error_kind,\n-                            tag_of_access: access_info,\n+                            accessed_info,\n                         }\n                         .build()\n                     },\n@@ -373,10 +390,10 @@ impl<'tcx> Tree {\n         tag: BorTag,\n         range: AllocRange,\n         global: &GlobalState,\n+        span: Span, // diagnostics\n     ) -> InterpResult<'tcx> {\n-        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n-        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n-            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+        for (offset, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &mut self.nodes, tag_mapping: &self.tag_mapping, perms }\n                 .traverse_parents_this_children_others(\n                     tag,\n                     |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n@@ -424,24 +441,42 @@ impl<'tcx> Tree {\n \n                         let old_perm = old_state.permission;\n                         let protected = global.borrow().protected_tags.contains_key(&node.tag);\n-                        let new_perm =\n+                        let transition =\n                             Permission::perform_access(access_kind, rel_pos, old_perm, protected)\n                                 .ok_or(TransitionError::ChildAccessForbidden(old_perm))?;\n                         if protected\n                             // Can't trigger Protector on uninitialized locations\n                             && old_state.initialized\n-                            && !old_perm.protector_allows_transition(new_perm)\n+                            && !transition.is_allowed_by_protector()\n                         {\n-                            return Err(TransitionError::ProtectedTransition(old_perm, new_perm));\n+                            return Err(TransitionError::ProtectedTransition(transition));\n+                        }\n+                        // Record the event as part of the history\n+                        if !transition.is_noop() {\n+                            node.debug_info.history.push(diagnostics::Event {\n+                                transition,\n+                                access_kind,\n+                                access_range: range,\n+                                is_foreign: rel_pos.is_foreign(),\n+                                offset,\n+                                span,\n+                            });\n+                            old_state.permission =\n+                                transition.applied(old_state.permission).unwrap();\n                         }\n-                        old_state.permission = new_perm;\n                         old_state.initialized |= !rel_pos.is_foreign();\n                         Ok(ContinueTraversal::Recurse)\n                     },\n-                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n-                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n-                        TbError { faulty_tag, access_kind, error_kind, tag_of_access: access_info }\n-                            .build()\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpError<'tcx> {\n+                        let ErrHandlerArgs { error_kind, conflicting_info, accessed_info } = args;\n+                        TbError {\n+                            conflicting_info,\n+                            access_kind,\n+                            error_offset: offset,\n+                            error_kind,\n+                            accessed_info,\n+                        }\n+                        .build()\n                     },\n                 )?;\n         }"}, {"sha": "13306b4809c33eca5183f69c4f8910df9706dd72", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1199,7 +1199,7 @@ pub struct GlobalState {\n \n     /// A flag to mark we are currently performing\n     /// a data race free action (such as atomic access)\n-    /// to supress the race detector\n+    /// to suppress the race detector\n     ongoing_action_data_race_free: Cell<bool>,\n \n     /// Mapping of a vector index to a known set of thread"}, {"sha": "1f57e8b2b0abd5b40dfc41e84acf73abcd8db7ff", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -151,7 +151,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         assert_eq!(\n             init_once.status,\n             InitOnceStatus::Uninitialized,\n-            \"begining already begun or complete init once\"\n+            \"beginning already begun or complete init once\"\n         );\n         init_once.status = InitOnceStatus::Begun;\n     }"}, {"sha": "89c009933bb03bf798c96bb70334bb5655c1250c", "filename": "src/tools/miri/src/concurrency/range_object_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -25,9 +25,9 @@ pub struct RangeObjectMap<T> {\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum AccessType {\n-    /// The access perfectly overlaps (same offset and range) with the exsiting allocation\n+    /// The access perfectly overlaps (same offset and range) with the existing allocation\n     PerfectlyOverlapping(Position),\n-    /// The access does not touch any exising allocation\n+    /// The access does not touch any existing allocation\n     Empty(Position),\n     /// The access overlaps with one or more existing allocations\n     ImperfectlyOverlapping(Range<Position>),\n@@ -115,7 +115,7 @@ impl<T> RangeObjectMap<T> {\n     // want to repeat the binary search on each time, so we ask the caller to supply Position\n     pub fn insert_at_pos(&mut self, pos: Position, range: AllocRange, data: T) {\n         self.v.insert(pos, Elem { range, data });\n-        // If we aren't the first element, then our start must be greater than the preivous element's end\n+        // If we aren't the first element, then our start must be greater than the previous element's end\n         if pos > 0 {\n             assert!(self.v[pos - 1].range.end() <= range.start);\n         }"}, {"sha": "f37a2fd2cd5b6d12638c730983de94de229f7eeb", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -143,7 +143,7 @@ struct Condvar {\n     waiters: VecDeque<CondvarWaiter>,\n     /// Tracks the happens-before relationship\n     /// between a cond-var signal and a cond-var\n-    /// wait during a non-suprious signal event.\n+    /// wait during a non-spurious signal event.\n     /// Contains the clock of the last thread to\n     /// perform a futex-signal.\n     data_race: VClock,\n@@ -373,7 +373,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 .expect(\"invariant violation: lock_count == 0 iff the thread is unlocked\");\n             if mutex.lock_count == 0 {\n                 mutex.owner = None;\n-                // The mutex is completely unlocked. Try transfering ownership\n+                // The mutex is completely unlocked. Try transferring ownership\n                 // to another thread.\n                 if let Some(data_race) = &this.machine.data_race {\n                     data_race.validate_lock_release("}, {"sha": "e9bbae4d50488ef0312f45502a41f11a628411db", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -272,9 +272,8 @@ impl Time {\n     fn get_wait_time(&self, clock: &Clock) -> Duration {\n         match self {\n             Time::Monotonic(instant) => instant.duration_since(clock.now()),\n-            Time::RealTime(time) => {\n-                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0))\n-            }\n+            Time::RealTime(time) =>\n+                time.duration_since(SystemTime::now()).unwrap_or(Duration::new(0, 0)),\n         }\n     }\n }\n@@ -823,7 +822,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Write the current thread-id, switch to the next thread later\n-        // to treat this write operation as occuring on the current thread.\n+        // to treat this write operation as occurring on the current thread.\n         if let Some(thread_info_place) = thread {\n             this.write_scalar(\n                 Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n@@ -832,7 +831,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Finally switch to new thread so that we can push the first stackframe.\n-        // After this all accesses will be treated as occuring in the new thread.\n+        // After this all accesses will be treated as occurring in the new thread.\n         let old_thread_id = this.set_active_thread(new_thread_id);\n \n         // Perform the function pointer load in the new thread frame."}, {"sha": "a6e67ef8699df42f41c1a809eb9186514e02f67e", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -212,16 +212,14 @@ impl PartialOrd for VClock {\n         for (l, r) in iter {\n             match order {\n                 Ordering::Equal => order = l.cmp(r),\n-                Ordering::Less => {\n+                Ordering::Less =>\n                     if l > r {\n                         return None;\n-                    }\n-                }\n-                Ordering::Greater => {\n+                    },\n+                Ordering::Greater =>\n                     if l < r {\n                         return None;\n-                    }\n-                }\n+                    },\n             }\n         }\n \n@@ -236,16 +234,18 @@ impl PartialOrd for VClock {\n             Ordering::Equal => Some(order),\n             // Right has at least 1 element > than the implicit 0,\n             // so the only valid values are Ordering::Less or None.\n-            Ordering::Less => match order {\n-                Ordering::Less | Ordering::Equal => Some(Ordering::Less),\n-                Ordering::Greater => None,\n-            },\n+            Ordering::Less =>\n+                match order {\n+                    Ordering::Less | Ordering::Equal => Some(Ordering::Less),\n+                    Ordering::Greater => None,\n+                },\n             // Left has at least 1 element > than the implicit 0,\n             // so the only valid values are Ordering::Greater or None.\n-            Ordering::Greater => match order {\n-                Ordering::Greater | Ordering::Equal => Some(Ordering::Greater),\n-                Ordering::Less => None,\n-            },\n+            Ordering::Greater =>\n+                match order {\n+                    Ordering::Greater | Ordering::Equal => Some(Ordering::Greater),\n+                    Ordering::Less => None,\n+                },\n         }\n     }\n "}, {"sha": "c1395468fee2ee5ab479772506790075d9f06eb6", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -24,16 +24,16 @@\n //! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n //!\n //! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n-//! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n+//! and fences accept, and is implementable (with operational semantics), please open a GitHub issue!\n //!\n //! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n //! Taming Release-Acquire Consistency by Ori Lahav et al. (<https://plv.mpi-sws.org/sra/paper.pdf>) or Promising Semantics noted above,\n //! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n //! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n //! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n //! Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is\n-//! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n-//! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n+//! used to make sure a value in a thread's view is not overwritten by a write that occurred earlier than the one in the existing view.\n+//! In our implementation, this is detected using read information attached to store elements, as there is no data structure representing reads.\n //!\n //! The C++ memory model is built around the notion of an 'atomic object', so it would be natural\n //! to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has\n@@ -48,7 +48,7 @@\n //! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n //! than the C++20 atomic API was intended to allow, such as non-atomically accessing\n //! a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation\n-//! (such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.\n+//! (such as accessing the top 16 bits of an AtomicU32). These scenarios are generally undiscussed in formalisations of C++ memory model.\n //! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n //! can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.\n //! A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.\n@@ -61,7 +61,7 @@\n //\n // 2. In the operational semantics, each store element keeps the timestamp of a thread when it loads from the store.\n // If the same thread loads from the same store element multiple times, then the timestamps at all loads are saved in a list of load elements.\n-// This is not necessary as later loads by the same thread will always have greater timetstamp values, so we only need to record the timestamp of the first\n+// This is not necessary as later loads by the same thread will always have greater timestamp values, so we only need to record the timestamp of the first\n // load by each thread. This optimisation is done in tsan11\n // (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.h#L35-L37)\n // and here.\n@@ -193,7 +193,7 @@ impl StoreBufferAlloc {\n                     buffers.remove_pos_range(pos_range);\n                 }\n                 AccessType::Empty(_) => {\n-                    // The range had no weak behaivours attached, do nothing\n+                    // The range had no weak behaviours attached, do nothing\n                 }\n             }\n         }\n@@ -336,7 +336,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         let mut found_sc = false;\n         // FIXME: we want an inclusive take_while (stops after a false predicate, but\n         // includes the element that gave the false), but such function doesn't yet\n-        // exist in the standard libary https://github.com/rust-lang/rust/issues/62208\n+        // exist in the standard library https://github.com/rust-lang/rust/issues/62208\n         // so we have to hack around it with keep_searching\n         let mut keep_searching = true;\n         let candidates = self"}, {"sha": "aeba0ea5a9524f66cee0015ba8a6c01e4a78b282", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -7,6 +7,7 @@ use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::borrow_tracker::stacked_borrows::diagnostics::TagHistory;\n+use crate::borrow_tracker::tree_borrows::diagnostics as tree_diagnostics;\n use crate::*;\n \n /// Details of premature program termination.\n@@ -23,8 +24,9 @@ pub enum TerminationInfo {\n         history: Option<TagHistory>,\n     },\n     TreeBorrowsUb {\n-        msg: String,\n-        // FIXME: incomplete\n+        title: String,\n+        details: Vec<String>,\n+        history: tree_diagnostics::HistoryData,\n     },\n     Int2PtrWithStrictProvenance,\n     Deadlock,\n@@ -65,7 +67,7 @@ impl fmt::Display for TerminationInfo {\n                     \"integer-to-pointer casts and `ptr::from_exposed_addr` are not supported with `-Zmiri-strict-provenance`\"\n                 ),\n             StackedBorrowsUb { msg, .. } => write!(f, \"{msg}\"),\n-            TreeBorrowsUb { msg } => write!(f, \"{msg}\"),\n+            TreeBorrowsUb { title, .. } => write!(f, \"{title}\"),\n             Deadlock => write!(f, \"the evaluated program deadlocked\"),\n             MultipleSymbolDefinitions { link_name, .. } =>\n                 write!(f, \"multiple definitions of symbol `{link_name}`\"),\n@@ -219,10 +221,16 @@ pub fn report_error<'tcx, 'mir>(\n                 }\n                 helps\n             },\n-            TreeBorrowsUb { .. } => {\n-                let helps = vec![\n-                    (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\")),\n+            TreeBorrowsUb { title: _, details, history } => {\n+                let mut helps = vec![\n+                    (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\"))\n                 ];\n+                for m in details {\n+                    helps.push((None, m.clone()));\n+                }\n+                for event in history.events.clone() {\n+                    helps.push(event);\n+                }\n                 helps\n             }\n             MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>"}, {"sha": "43d8f221ce3d20e631de05ff1756fac7acc45800", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -376,7 +376,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n \n             // Inlining of `DEFAULT` from\n             // https://github.com/rust-lang/rust/blob/master/compiler/rustc_session/src/config/sigpipe.rs.\n-            // Alaways using DEFAULT is okay since we don't support signals in Miri anyway.\n+            // Always using DEFAULT is okay since we don't support signals in Miri anyway.\n             let sigpipe = 2;\n \n             ecx.call_function(\n@@ -460,7 +460,7 @@ pub fn eval_entry<'tcx>(\n             return None;\n         }\n         // Check for memory leaks.\n-        info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n+        info!(\"Additional static roots: {:?}\", ecx.machine.static_roots);\n         let leaks = ecx.find_leaked_allocations(&ecx.machine.static_roots);\n         if !leaks.is_empty() {\n             report_leaks(&ecx, leaks);"}, {"sha": "a2b49e6f219d37216df75be725fa16883879b388", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -524,7 +524,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n             }\n \n-            // Make sure we visit aggregrates in increasing offset order.\n+            // Make sure we visit aggregates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n                 place: &MPlaceTy<'tcx, Provenance>,"}, {"sha": "4fd0af35304ec7f58359299dc187ca7a20db8c3d", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -77,7 +77,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n             Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n             Err(0) => None,\n             Err(pos) => {\n-                // This is the largest of the adresses smaller than `int`,\n+                // This is the largest of the addresses smaller than `int`,\n                 // i.e. the greatest lower bound (glb)\n                 let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n                 // This never overflows because `addr >= glb`"}, {"sha": "21c5a9c1b7029f56198fa38339d499ab5a682cae", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -32,8 +32,14 @@ use crate::{\n     *,\n };\n \n-/// The number of the available real-time signal with the lowest priority.\n-/// Dummy constant related to epoll, must be between 32 and 64.\n+/// First real-time signal.\n+/// `signal(7)` says this must be between 32 and 64 and specifies 34 or 35\n+/// as typical values.\n+pub const SIGRTMIN: i32 = 34;\n+\n+/// Last real-time signal.\n+/// `signal(7)` says it must be between 32 and 64 and specifies\n+/// `SIGRTMAX` - `SIGRTMIN` >= 8 (which is the value of `_POSIX_RTSIG_MAX`)\n pub const SIGRTMAX: i32 = 42;\n \n /// Extra data stored with each stack frame\n@@ -495,9 +501,9 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n+        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instantiate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n-        // Determinine page size, stack address, and stack size.\n+        // Determine page size, stack address, and stack size.\n         // These values are mostly meaningless, but the stack address is also where we start\n         // allocating physical integer addresses for all allocations.\n         let page_size = if let Some(page_size) = config.page_size {"}, {"sha": "44bca3796f9af63048eedbc70d87766d72c1d047", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -46,7 +46,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // This list should be kept in sync with the one from libstd.\n         let min_align = match this.tcx.sess.target.arch.as_ref() {\n             \"x86\" | \"arm\" | \"mips\" | \"powerpc\" | \"powerpc64\" | \"asmjs\" | \"wasm32\" => 8,\n-            \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" => 16,\n+            \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" | \"loongarch64\" => 16,\n             arch => bug!(\"unsupported target architecture for malloc: `{}`\", arch),\n         };\n         // Windows always aligns, even small allocations.\n@@ -744,6 +744,44 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     dest,\n                 )?;\n             }\n+            \"memcpy\" => {\n+                let [ptr_dest, ptr_src, n] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr_dest = this.read_pointer(ptr_dest)?;\n+                let ptr_src = this.read_pointer(ptr_src)?;\n+                let n = this.read_target_usize(n)?;\n+                this.mem_copy(\n+                    ptr_src,\n+                    Align::ONE,\n+                    ptr_dest,\n+                    Align::ONE,\n+                    Size::from_bytes(n),\n+                    true,\n+                )?;\n+                this.write_pointer(ptr_dest, dest)?;\n+            }\n+            \"strcpy\" => {\n+                let [ptr_dest, ptr_src] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let ptr_dest = this.read_pointer(ptr_dest)?;\n+                let ptr_src = this.read_pointer(ptr_src)?;\n+\n+                // We use `read_c_str` to determine the amount of data to copy,\n+                // and then use `mem_copy` for the actual copy. This means\n+                // pointer provenance is preserved by this implementation of `strcpy`.\n+                // That is probably overly cautious, but there also is no fundamental\n+                // reason to have `strcpy` destroy pointer provenance.\n+                let n = this.read_c_str(ptr_src)?.len().checked_add(1).unwrap();\n+                this.mem_copy(\n+                    ptr_src,\n+                    Align::ONE,\n+                    ptr_dest,\n+                    Align::ONE,\n+                    Size::from_bytes(n),\n+                    true,\n+                )?;\n+                this.write_pointer(ptr_dest, dest)?;\n+            }\n \n             // math functions (note that there are also intrinsics for some other functions)\n             #[rustfmt::skip]"}, {"sha": "d101f8d3111d08be1ee1b8355d18108c4ff31c8d", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -585,9 +585,9 @@ fn simd_element_to_bool(elem: ImmTy<'_, Provenance>) -> InterpResult<'_, bool> {\n     })\n }\n \n-fn simd_bitmask_index(idx: u32, vec_len: u32, endianess: Endian) -> u32 {\n+fn simd_bitmask_index(idx: u32, vec_len: u32, endianness: Endian) -> u32 {\n     assert!(idx < vec_len);\n-    match endianess {\n+    match endianness {\n         Endian::Little => idx,\n         #[allow(clippy::integer_arithmetic)] // idx < vec_len\n         Endian::Big => vec_len - 1 - idx, // reverse order of bits"}, {"sha": "6bc5b8f39d5f06b2a6dfff8f504dadd7387f8332", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -329,7 +329,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             match direction {\n                 PathConversion::HostToTarget => {\n                     // If this start withs a `\\`, we add `\\\\?` so it starts with `\\\\?\\` which is\n-                    // some magic path on Windos that *is* considered absolute.\n+                    // some magic path on Windows that *is* considered absolute.\n                     if converted.get(0).copied() == Some(b'\\\\') {\n                         converted.splice(0..0, b\"\\\\\\\\?\".iter().copied());\n                     }"}, {"sha": "2f24c00ce14b365c6067b63a4104ff6f975b1451", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -40,7 +40,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\"),\n                 ];\n                 // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n-                // never allowed to go backwards. We don't need to do any additonal monotonicity\n+                // never allowed to go backwards. We don't need to do any additional monotonicity\n                 // enforcement because std::time::Instant already guarantees that it is monotonic.\n                 relative_clocks = vec![\n                     this.eval_libc_i32(\"CLOCK_MONOTONIC\"),"}, {"sha": "685feeaf892f2812ec8aee93c5bda409c380a05f", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> TlsData<'tcx> {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n-            None => throw_ub_format!(\"removing a non-existig TLS key: {}\", key),\n+            None => throw_ub_format!(\"removing a nonexistent TLS key: {}\", key),\n         }\n     }\n \n@@ -175,7 +175,7 @@ impl<'tcx> TlsData<'tcx> {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n-        // We interpret the documentaion above (taken from POSIX) as saying that we need to iterate\n+        // We interpret the documentation above (taken from POSIX) as saying that we need to iterate\n         // over all keys and run each destructor at least once before running any destructor a 2nd\n         // time. That's why we have `key` to indicate how far we got in the current iteration. If we\n         // return `None`, `schedule_next_pthread_tls_dtor` will re-try with `ket` set to `None` to"}, {"sha": "abec782b4f0487888e06942b12ea4e6c5f92288e", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -11,6 +11,7 @@ use std::time::SystemTime;\n use log::trace;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TyCtxt;\n use rustc_target::abi::{Align, Size};\n \n use crate::shims::os_str::bytes_to_os_str;\n@@ -31,6 +32,7 @@ pub trait FileDescriptor: std::fmt::Debug + helpers::AsAny {\n         &mut self,\n         _communicate_allowed: bool,\n         _bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot read from {}\", self.name());\n     }\n@@ -39,6 +41,7 @@ pub trait FileDescriptor: std::fmt::Debug + helpers::AsAny {\n         &self,\n         _communicate_allowed: bool,\n         _bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         throw_unsup_format!(\"cannot write to {}\", self.name());\n     }\n@@ -79,6 +82,7 @@ impl FileDescriptor for FileHandle {\n         &mut self,\n         communicate_allowed: bool,\n         bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok(self.file.read(bytes))\n@@ -88,6 +92,7 @@ impl FileDescriptor for FileHandle {\n         &self,\n         communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         assert!(communicate_allowed, \"isolation should have prevented even opening a file\");\n         Ok((&mut &self.file).write(bytes))\n@@ -153,6 +158,7 @@ impl FileDescriptor for io::Stdin {\n         &mut self,\n         communicate_allowed: bool,\n         bytes: &mut [u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         if !communicate_allowed {\n             // We want isolation mode to be deterministic, so we have to disallow all reads, even stdin.\n@@ -184,6 +190,7 @@ impl FileDescriptor for io::Stdout {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         let result = Write::write(&mut { self }, bytes);\n@@ -220,6 +227,7 @@ impl FileDescriptor for io::Stderr {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We allow writing to stderr even with isolation enabled.\n         // No need to flush, stderr is not buffered.\n@@ -252,6 +260,7 @@ impl FileDescriptor for NullOutput {\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        _tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         // We just don't write anything, but report to the user that we did.\n         Ok(Ok(bytes.len()))\n@@ -756,8 +765,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let mut bytes = vec![0; usize::try_from(count).unwrap()];\n             // `File::read` never returns a value larger than `count`,\n             // so this cannot fail.\n-            let result =\n-                file_descriptor.read(communicate, &mut bytes)?.map(|c| i64::try_from(c).unwrap());\n+            let result = file_descriptor\n+                .read(communicate, &mut bytes, *this.tcx)?\n+                .map(|c| i64::try_from(c).unwrap());\n \n             match result {\n                 Ok(read_bytes) => {\n@@ -803,8 +813,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n             let bytes = this.read_bytes_ptr_strip_provenance(buf, Size::from_bytes(count))?;\n-            let result =\n-                file_descriptor.write(communicate, bytes)?.map(|c| i64::try_from(c).unwrap());\n+            let result = file_descriptor\n+                .write(communicate, bytes, *this.tcx)?\n+                .map(|c| i64::try_from(c).unwrap());\n             this.try_unwrap_io_result(result)\n         } else {\n             this.handle_not_found()\n@@ -1015,8 +1026,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let at_ampty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n-        let empty_path_flag = flags & at_ampty_path == at_ampty_path;\n+        let at_empty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n+        let empty_path_flag = flags & at_empty_path == at_empty_path;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n         // * interpreting `path` as a path relative to `dirfd` when the latter is `AT_FDCWD`, or\n@@ -1053,7 +1064,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(-1);\n         }\n \n-        // the `_mask_op` paramter specifies the file information that the caller requested.\n+        // the `_mask_op` parameter specifies the file information that the caller requested.\n         // However `statx` is allowed to return information that was not requested or to not\n         // return information that was requested. This `mask` represents the information we can\n         // actually provide for any target."}, {"sha": "3c263e4df9288bae88a0bf6205910d675b7b9028", "filename": "src/tools/miri/src/shims/unix/linux/fd.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -152,15 +152,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let _maxevents = this.read_scalar(maxevents)?.to_i32()?;\n         let _timeout = this.read_scalar(timeout)?.to_i32()?;\n \n-        let numevents = 0;\n         if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n             let _epfd = epfd\n                 .as_any_mut()\n                 .downcast_mut::<Epoll>()\n                 .ok_or_else(|| err_unsup_format!(\"non-epoll FD passed to `epoll_wait`\"))?;\n \n             // FIXME return number of events ready when scheme for marking events ready exists\n-            Ok(Scalar::from_i32(numevents))\n+            throw_unsup_format!(\"returning ready events from epoll_wait is not yet implemented\");\n         } else {\n             Ok(Scalar::from_i32(this.handle_not_found()?))\n         }"}, {"sha": "1f17ffb88c886973c82f0c0d67953daa94752934", "filename": "src/tools/miri/src/shims/unix/linux/fd/event.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,6 +1,8 @@\n use crate::shims::unix::fs::FileDescriptor;\n \n use rustc_const_eval::interpret::InterpResult;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_target::abi::Endian;\n \n use std::cell::Cell;\n use std::io;\n@@ -36,7 +38,7 @@ impl FileDescriptor for Event {\n     }\n \n     /// A write call adds the 8-byte integer value supplied in\n-    /// its buffer to the counter.  The maximum value that may be\n+    /// its buffer (in native endianess) to the counter.  The maximum value that may be\n     /// stored in the counter is the largest unsigned 64-bit value\n     /// minus 1 (i.e., 0xfffffffffffffffe).  If the addition would\n     /// cause the counter's value to exceed the maximum, then the\n@@ -47,17 +49,22 @@ impl FileDescriptor for Event {\n     /// A write fails with the error EINVAL if the size of the\n     /// supplied buffer is less than 8 bytes, or if an attempt is\n     /// made to write the value 0xffffffffffffffff.\n-    ///\n-    /// FIXME: use endianness\n     fn write<'tcx>(\n         &self,\n         _communicate_allowed: bool,\n         bytes: &[u8],\n+        tcx: TyCtxt<'tcx>,\n     ) -> InterpResult<'tcx, io::Result<usize>> {\n         let v1 = self.val.get();\n+        let bytes: [u8; 8] = bytes.try_into().unwrap(); // FIXME fail gracefully when this has the wrong size\n+        // Convert from target endianess to host endianess.\n+        let num = match tcx.sess.target.endian {\n+            Endian::Little => u64::from_le_bytes(bytes),\n+            Endian::Big => u64::from_be_bytes(bytes),\n+        };\n         // FIXME handle blocking when addition results in exceeding the max u64 value\n         // or fail with EAGAIN if the file descriptor is nonblocking.\n-        let v2 = v1.checked_add(u64::from_be_bytes(bytes.try_into().unwrap())).unwrap();\n+        let v2 = v1.checked_add(num).unwrap();\n         self.val.set(v2);\n         assert_eq!(8, bytes.len());\n         Ok(Ok(8))"}, {"sha": "4cb7ee8efca7c27beaf90a1a19eb133dec6b3cd0", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -2,6 +2,7 @@ use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n use crate::machine::SIGRTMAX;\n+use crate::machine::SIGRTMIN;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n use shims::unix::fs::EvalContextExt as _;\n@@ -74,6 +75,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.socketpair(domain, type_, protocol, sv)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"__libc_current_sigrtmin\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+\n+                this.write_scalar(Scalar::from_i32(SIGRTMIN), dest)?;\n+            }\n             \"__libc_current_sigrtmax\" => {\n                 let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n \n@@ -163,7 +169,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n                         this.write_scalar(Scalar::from_target_isize(result.into(), this), dest)?;\n                     }\n-                    // `futex` is used by some synchonization primitives.\n+                    // `futex` is used by some synchronization primitives.\n                     id if id == sys_futex => {\n                         futex(this, &args[1..], dest)?;\n                     }\n@@ -174,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n             }\n \n-            // Miscelanneous\n+            // Miscellaneous\n             \"getrandom\" => {\n                 let [ptr, len, flags] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "05feeac45b5c1ae60c0867723b99904b48d969c4", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -242,7 +242,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             //\n             // To distinguish these two cases in already constructed mutexes, we\n             // use the same trick as glibc: for the case when\n-            // `pthread_mutexattr_settype` is caled explicitly, we set the\n+            // `pthread_mutexattr_settype` is called explicitly, we set the\n             // `PTHREAD_MUTEX_NORMAL_FLAG` flag.\n             let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable"}, {"sha": "f72ba5cca7a02ea886b3cfce39cb9013343fe24a", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -96,7 +96,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 if byte_offset != 0 {\n                     throw_unsup_format!(\n-                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n+                        \"`NtWriteFile` `ByteOffset` parameter is non-null, which is unsupported\"\n                     );\n                 }\n "}, {"sha": "52deba9108c13b57ccf123b8f5b44a3268bbcc19", "filename": "src/tools/miri/tests/compiletest.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -2,7 +2,7 @@ use colored::*;\n use regex::bytes::Regex;\n use std::path::{Path, PathBuf};\n use std::{env, process::Command};\n-use ui_test::{color_eyre::Result, Config, Mode, OutputConflictHandling};\n+use ui_test::{color_eyre::Result, Config, Match, Mode, OutputConflictHandling};\n \n fn miri_path() -> PathBuf {\n     PathBuf::from(option_env!(\"MIRI\").unwrap_or(env!(\"CARGO_BIN_EXE_miri\")))\n@@ -52,14 +52,13 @@ fn run_tests(mode: Mode, path: &str, target: &str, with_dependencies: bool) -> R\n         mode,\n         program: miri_path(),\n         quiet: false,\n+        edition: Some(\"2018\".into()),\n         ..Config::default()\n     };\n \n     let in_rustc_test_suite = option_env!(\"RUSTC_STAGE\").is_some();\n \n     // Add some flags we always want.\n-    config.args.push(\"--edition\".into());\n-    config.args.push(\"2018\".into());\n     if in_rustc_test_suite {\n         // Less aggressive warnings to make the rustc toolstate management less painful.\n         // (We often get warnings when e.g. a feature gets stabilized or some lint gets added/improved.)\n@@ -100,12 +99,24 @@ fn run_tests(mode: Mode, path: &str, target: &str, with_dependencies: bool) -> R\n     };\n \n     // Handle command-line arguments.\n+    let mut after_dashdash = false;\n     config.path_filter.extend(std::env::args().skip(1).filter(|arg| {\n+        if after_dashdash {\n+            // Just propagate everything.\n+            return true;\n+        }\n         match &**arg {\n             \"--quiet\" => {\n                 config.quiet = true;\n                 false\n             }\n+            \"--\" => {\n+                after_dashdash = true;\n+                false\n+            }\n+            s if s.starts_with('-') => {\n+                panic!(\"unknown compiletest flag `{s}`\");\n+            }\n             _ => true,\n         }\n     }));\n@@ -129,8 +140,8 @@ fn run_tests(mode: Mode, path: &str, target: &str, with_dependencies: bool) -> R\n \n macro_rules! regexes {\n     ($name:ident: $($regex:expr => $replacement:expr,)*) => {lazy_static::lazy_static! {\n-        static ref $name: Vec<(Regex, &'static [u8])> = vec![\n-            $((Regex::new($regex).unwrap(), $replacement.as_bytes()),)*\n+        static ref $name: Vec<(Match, &'static [u8])> = vec![\n+            $((Regex::new($regex).unwrap().into(), $replacement.as_bytes()),)*\n         ];\n     }};\n }"}, {"sha": "e11d8937fe40449929e6e6776187743df89aee97", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison by 0\n+    // division by 0\n     unsafe { std::intrinsics::exact_div(2, 0) }; //~ ERROR: divisor of zero\n }"}, {"sha": "7914de403a7585fb275abb4d384daecbee718b76", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison with a remainder\n+    // division with a remainder\n     unsafe { std::intrinsics::exact_div(2u16, 3) }; //~ ERROR: 2_u16 cannot be divided by 3_u16 without remainder\n }"}, {"sha": "50ee538646578277d22d48b35f13fcbad4d371f7", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // signed divison with a remainder\n+    // signed division with a remainder\n     unsafe { std::intrinsics::exact_div(-19i8, 2) }; //~ ERROR: -19_i8 cannot be divided by 2_i8 without remainder\n }"}, {"sha": "48c55208238c43151dd529c62684c8bf166b9941", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison of MIN by -1\n+    // division of MIN by -1\n     unsafe { std::intrinsics::exact_div(i64::MIN, -1) }; //~ ERROR: overflow in signed remainder (dividing MIN by -1)\n }"}, {"sha": "c9501d90b3b144f46e89ad30f4c464d01bfa6164", "filename": "src/tools/miri/tests/fail/panic/double_panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,6 +1,8 @@\n //@error-pattern: the program aborted\n //@normalize-stderr-test: \"\\| +\\^+\" -> \"| ^\"\n //@normalize-stderr-test: \"unsafe \\{ libc::abort\\(\\) \\}|crate::intrinsics::abort\\(\\);\" -> \"ABORT();\"\n+//@normalize-stderr-test: \"\\n  +[0-9]+:[^\\n]+\" -> \"$1\"\n+//@normalize-stderr-test: \"\\n at [^\\n]+\" -> \"$1\"\n \n struct Foo;\n impl Drop for Foo {"}, {"sha": "5384f6f6716ff7292733aca22c520359c4efdca0", "filename": "src/tools/miri/tests/fail/panic/double_panic.stderr", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fpanic%2Fdouble_panic.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -2,70 +2,6 @@ thread 'main' panicked at 'first', $DIR/double_panic.rs:LL:CC\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n thread 'main' panicked at 'second', $DIR/double_panic.rs:LL:CC\n stack backtrace:\n-   0: std::backtrace_rs::backtrace::miri::trace_unsynchronized\n- at RUSTLIB/std/src/../../backtrace/src/backtrace/miri.rs:LL:CC\n-   1: std::backtrace_rs::backtrace::miri::trace\n- at RUSTLIB/std/src/../../backtrace/src/backtrace/miri.rs:LL:CC\n-   2: std::backtrace_rs::backtrace::trace_unsynchronized\n- at RUSTLIB/std/src/../../backtrace/src/backtrace/mod.rs:LL:CC\n-   3: std::sys_common::backtrace::_print_fmt\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   4: <std::sys_common::backtrace::_print::DisplayBacktrace as std::fmt::Display>::fmt\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   5: core::fmt::rt::Argument::fmt\n- at RUSTLIB/core/src/fmt/rt.rs:LL:CC\n-   6: std::fmt::write\n- at RUSTLIB/core/src/fmt/mod.rs:LL:CC\n-   7: <std::sys::PLATFORM::stdio::Stderr as std::io::Write>::write_fmt\n- at RUSTLIB/std/src/io/mod.rs:LL:CC\n-   8: std::sys_common::backtrace::_print\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-   9: std::sys_common::backtrace::print\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  10: std::panicking::default_hook::{closure#1}\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  11: std::panicking::default_hook\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  12: std::panicking::rust_panic_with_hook\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  13: std::rt::begin_panic::{closure#0}\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  14: std::sys_common::backtrace::__rust_end_short_backtrace\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  15: std::rt::begin_panic\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  16: <Foo as std::ops::Drop>::drop\n- at $DIR/double_panic.rs:LL:CC\n-  17: std::ptr::drop_in_place - shim(Some(Foo))\n- at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n-  18: main\n- at $DIR/double_panic.rs:LL:CC\n-  19: <fn() as std::ops::FnOnce<()>>::call_once - shim(fn())\n- at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  20: std::sys_common::backtrace::__rust_begin_short_backtrace\n- at RUSTLIB/std/src/sys_common/backtrace.rs:LL:CC\n-  21: std::rt::lang_start::{closure#0}\n- at RUSTLIB/std/src/rt.rs:LL:CC\n-  22: std::ops::function::impls::call_once\n- at RUSTLIB/core/src/ops/function.rs:LL:CC\n-  23: std::panicking::r#try::do_call\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  24: std::panicking::r#try\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  25: std::panic::catch_unwind\n- at RUSTLIB/std/src/panic.rs:LL:CC\n-  26: std::rt::lang_start_internal::{closure#2}\n- at RUSTLIB/std/src/rt.rs:LL:CC\n-  27: std::panicking::r#try::do_call\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  28: std::panicking::r#try\n- at RUSTLIB/std/src/panicking.rs:LL:CC\n-  29: std::panic::catch_unwind\n- at RUSTLIB/std/src/panic.rs:LL:CC\n-  30: std::rt::lang_start_internal\n- at RUSTLIB/std/src/rt.rs:LL:CC\n-  31: std::rt::lang_start\n- at RUSTLIB/std/src/rt.rs:LL:CC\n thread panicked while panicking. aborting.\n error: abnormal termination: the program aborted execution\n   --> RUSTLIB/std/src/sys/PLATFORM/mod.rs:LL:CC"}, {"sha": "9c0c974223b72361c40acfd65fafc2900f0f6e29", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n // A callee may not read the destination of our `&mut` without us noticing.\n-// Thise code got carefully checked to not introduce any reborrows\n+// This code got carefully checked to not introduce any reborrows\n // that are not explicit in the source. Let's hope the compiler does not break this later!\n \n use std::mem;"}, {"sha": "22ffa1b2711070db38f1f961d1a5b7284596cec2", "filename": "src/tools/miri/tests/fail/terminate-terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -12,14 +12,13 @@ impl Drop for Foo {\n \n #[inline(always)]\n fn has_cleanup() {\n-    //~^ ERROR: panic in a function that cannot unwind\n-    // FIXME(nbdd0121): The error should be reported at the call site.\n     let _f = Foo;\n     panic!();\n }\n \n extern \"C\" fn panic_abort() {\n     has_cleanup();\n+    //~^ ERROR: panic in a function that cannot unwind\n }\n \n fn main() {"}, {"sha": "8ce4bb7cbb5e987e1e25030428abacd2490c2077", "filename": "src/tools/miri/tests/fail/terminate-terminator.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fterminate-terminator.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -6,8 +6,6 @@ error: abnormal termination: panic in a function that cannot unwind\n   --> $DIR/terminate-terminator.rs:LL:CC\n    |\n LL | / fn has_cleanup() {\n-LL | |\n-LL | |     // FIXME(nbdd0121): The error should be reported at the call site.\n LL | |     let _f = Foo;\n LL | |     panic!();\n LL | | }"}, {"sha": "6fdfbc9913a114aa91d66687b99ddfefba66e4a4", "filename": "src/tools/miri/tests/fail/tokio/sleep.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,7 @@\n //@compile-flags: -Zmiri-permissive-provenance -Zmiri-backtrace=full\n //@only-target-x86_64-unknown-linux: support for tokio only on linux and x86\n+//@error-pattern: returning ready events from epoll_wait is not yet implemented\n+//@normalize-stderr-test: \" += note:.*\\n\" -> \"\"\n \n use tokio::time::{sleep, Duration, Instant};\n ", "previous_filename": "src/tools/miri/tests/pass-dep/tokio/sleep.rs"}, {"sha": "ac2a984ed514af0367da59688e7e037c41bb2399", "filename": "src/tools/miri/tests/fail/tokio/sleep.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftokio%2Fsleep.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,15 @@\n+error: unsupported operation: returning ready events from epoll_wait is not yet implemented\n+  --> CARGO_REGISTRY/.../epoll.rs:LL:CC\n+   |\n+LL | /         syscall!(epoll_wait(\n+LL | |             self.ep,\n+LL | |             events.as_mut_ptr(),\n+LL | |             events.capacity() as i32,\n+LL | |             timeout,\n+LL | |         ))\n+   | |__________^ returning ready events from epoll_wait is not yet implemented\n+   |\n+   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n+\n+error: aborting due to previous error\n+"}, {"sha": "bb601fc88352d6c23aedd4674584163b5dc44952", "filename": "src/tools/miri/tests/fail/tree-borrows/alternate-read-write.stderr", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,11 +1,35 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/alternate-read-write.rs:LL:CC\n    |\n LL |     *y += 1; // Failure\n-   |     ^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |     ^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let y = unsafe { &mut *(x as *mut u8) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let y = unsafe { &mut *(x as *mut u8) };\n+   |                      ^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     *y += 1; // Success\n+   |     ^^^^^^^\n+   = help: this corresponds to an activation\n+help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     let _val = *x;\n+   |                ^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/alternate-read-write.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "d9980e75d6051c694373f733540496c780e79ae4", "filename": "src/tools/miri/tests/fail/tree-borrows/error-range.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,27 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+use core::ptr::addr_of_mut;\n+\n+// Check that the diagnostics correctly report the exact range at fault\n+// and trim irrelevant events.\n+fn main() {\n+    unsafe {\n+        let data = &mut [0u8; 16];\n+\n+        // Create and activate a few bytes\n+        let rmut = &mut *addr_of_mut!(data[0..6]);\n+        rmut[3] += 1;\n+        rmut[4] += 1;\n+        rmut[5] += 1;\n+\n+        // Now make them lose some perms\n+        let _v = data[3];\n+        let _v = data[4];\n+        let _v = data[5];\n+        data[4] = 1;\n+        data[5] = 1;\n+\n+        // Final test\n+        rmut[5] += 1; //~ ERROR: /read access through .* is forbidden/\n+    }\n+}"}, {"sha": "bc829fd86d35094c50fe0a814fe1842caedd68f8", "filename": "src/tools/miri/tests/fail/tree-borrows/error-range.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ferror-range.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,44 @@\n+error: Undefined Behavior: read access through <TAG> is forbidden\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         rmut[5] += 1;\n+   |         ^^^^^^^^^^^^ read access through <TAG> is forbidden\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Disabled which forbids child read accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let rmut = &mut *addr_of_mut!(data[0..6]);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let rmut = &mut *addr_of_mut!(data[0..6]);\n+   |                                       ^^^^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         rmut[5] += 1;\n+   |         ^^^^^^^^^^^^\n+   = help: this corresponds to an activation\n+help: the conflicting tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         let _v = data[5];\n+   |                  ^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+help: the conflicting tag <TAG> then transitioned from Frozen to Disabled due to a foreign write access at offsets [0x5..0x6]\n+  --> $DIR/error-range.rs:LL:CC\n+   |\n+LL |         data[5] = 1;\n+   |         ^^^^^^^^^^^\n+   = help: this corresponds to a loss of read permissions\n+   = note: BACKTRACE (of the first span):\n+   = note: inside `main` at $DIR/error-range.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "79744964a8bccefedb44a963d6c495edcadd004a", "filename": "src/tools/miri/tests/fail/tree-borrows/fragile-data-race.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,11 +1,29 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/fragile-data-race.rs:LL:CC\n    |\n LL |     unsafe { *p = 1 };\n-   |              ^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |              ^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is a child of the conflicting tag <TAG>\n+   = help: the conflicting tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/fragile-data-race.rs:LL:CC\n+   |\n+LL | fn thread_1(x: &mut u8) -> SendPtr {\n+   |             ^\n+help: the conflicting tag <TAG> was created here, in the initial state Reserved\n+  --> RUSTLIB/std/src/panic.rs:LL:CC\n+   |\n+LL | pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n+   |                                                       ^\n+help: the conflicting tag <TAG> then transitioned from Reserved to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL |         crate::intrinsics::read_via_copy(src)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/fragile-data-race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "14696c704fc1b8e6beb10a1d6d2b64c89a44d7aa", "filename": "src/tools/miri/tests/fail/tree-borrows/outside-range.stderr", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,11 +1,24 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/outside-range.rs:LL:CC\n    |\n LL |     *y.add(3) = 42;\n-   |     ^^^^^^^^^^^^^^ write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+   |     ^^^^^^^^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> is foreign to the protected tag <TAG> (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL |         let raw = data.as_mut_ptr();\n+   |                   ^^^^^^^^^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL | unsafe fn stuff(x: &mut u8, y: *mut u8) {\n+   |                 ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `stuff` at $DIR/outside-range.rs:LL:CC\n note: inside `main`\n   --> $DIR/outside-range.rs:LL:CC"}, {"sha": "8c9c2f8f9656b2344a43e1583ac52c3731f30417", "filename": "src/tools/miri/tests/fail/tree-borrows/read-to-local.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,12 +1,31 @@\n-error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+error: Undefined Behavior: write access through <TAG> is forbidden\n   --> $DIR/read-to-local.rs:LL:CC\n    |\n LL |         *ptr = 0;\n-   |         ^^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |         ^^^^^^^^ write access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> has state Frozen which forbids child write accesses\n+help: the accessed tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         let mref = &mut root;\n+   |                    ^^^^^^^^^\n+help: the accessed tag <TAG> then transitioned from Reserved to Active due to a child write access at offsets [0x0..0x1]\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         *ptr = 0; // Write\n+   |         ^^^^^^^^\n+   = help: this corresponds to an activation\n+help: the accessed tag <TAG> then transitioned from Active to Frozen due to a foreign read access at offsets [0x0..0x1]\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         assert_eq!(root, 0); // Parent Read\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   = help: this corresponds to a loss of write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/read-to-local.rs:LL:CC\n+   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "b85793ff0633758e1225aef234cf3da3d5c0cb0e", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/cell-protected-write.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,20 +1,34 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Re*|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Re*|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y, callee:y, caller:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+error: Undefined Behavior: write access through <TAG> (y, callee:y, caller:y) is forbidden\n   --> $DIR/cell-protected-write.rs:LL:CC\n    |\n LL |             *y = 1;\n-   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |             ^^^^^^ write access through <TAG> (y, callee:y, caller:y) is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> (y, callee:y, caller:y) is foreign to the protected tag <TAG> (callee:x) (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> (callee:x) to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |         let y = (&mut *n).get();\n+   |                 ^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |         unsafe fn write_second(x: &mut UnsafeCell<u8>, y: *mut u8) {\n+   |                                ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main::write_second` at $DIR/cell-protected-write.rs:LL:CC\n note: inside `main`\n   --> $DIR/cell-protected-write.rs:LL:CC"}, {"sha": "5de7dc0c7c51fd79bd3fe2d46bfb298f8c7253ff", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/int-protected-write.stderr", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,20 +1,34 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=n>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=n>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y, callee:y, caller:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n-error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+error: Undefined Behavior: write access through <TAG> (y, callee:y, caller:y) is forbidden\n   --> $DIR/int-protected-write.rs:LL:CC\n    |\n LL |             *y = 0;\n-   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |             ^^^^^^ write access through <TAG> (y, callee:y, caller:y) is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> (y, callee:y, caller:y) is foreign to the protected tag <TAG> (callee:x) (i.e., it is not a child)\n+   = help: the access would cause the protected tag <TAG> (callee:x) to transition from Reserved to Disabled\n+   = help: this is a loss of read and write permissions, which is not allowed for protected tags\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |         let y = (&mut *n) as *mut _;\n+   |                 ^^^^^^^^^\n+help: the protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |         unsafe fn write_second(x: &mut u8, y: *mut u8) {\n+   |                                ^\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main::write_second` at $DIR/int-protected-write.rs:LL:CC\n note: inside `main`\n   --> $DIR/int-protected-write.rs:LL:CC"}, {"sha": "a68efea890cf7ee0c6dd2d842529d660f80efbc8", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,14 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+//@error-pattern: /deallocation through .* is forbidden/\n+\n+fn inner(x: &mut i32, f: fn(&mut i32)) {\n+    // `f` may mutate, but it may not deallocate!\n+    f(x)\n+}\n+\n+fn main() {\n+    inner(Box::leak(Box::new(0)), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "97088d5854cc9dd396f4d85f90a5c6b6e09eea64", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,49 @@\n+error: Undefined Behavior: deallocation through <TAG> is forbidden\n+  --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   |\n+LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocation through <TAG> is forbidden\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = help: the allocation of the accessed tag <TAG> also contains the strongly protected tag <TAG>\n+   = help: the strongly protected tag <TAG> disallows deallocations\n+help: the accessed tag <TAG> was created here\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |         drop(unsafe { Box::from_raw(raw) });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the strongly protected tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL | fn inner(x: &mut i32, f: fn(&mut i32)) {\n+   |          ^\n+   = note: BACKTRACE (of the first span):\n+   = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `alloc::alloc::box_free::<i32, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `std::ptr::drop_in_place::<std::boxed::Box<i32>> - shim(Some(std::boxed::Box<i32>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   = note: inside `std::mem::drop::<std::boxed::Box<i32>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n+note: inside closure\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |         drop(unsafe { Box::from_raw(raw) });\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `<[closure@$DIR/strongly-protected.rs:LL:CC] as std::ops::FnOnce<(&mut i32,)>>::call_once - shim` at RUSTLIB/core/src/ops/function.rs:LL:CC\n+note: inside `inner`\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL |     f(x)\n+   |     ^^^^\n+note: inside `main`\n+  --> $DIR/strongly-protected.rs:LL:CC\n+   |\n+LL | /     inner(Box::leak(Box::new(0)), |x| {\n+LL | |         let raw = x as *mut _;\n+LL | |         drop(unsafe { Box::from_raw(raw) });\n+LL | |     });\n+   | |______^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "f6285bdcf16d4fc49a7a17ce23a79c84361cfe50", "filename": "src/tools/miri/tests/fail/tree-borrows/write-during-2phase.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,11 +1,30 @@\n-error: Undefined Behavior: read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+error: Undefined Behavior: read access through <TAG> is forbidden\n   --> $DIR/write-during-2phase.rs:LL:CC\n    |\n LL |     fn add(&mut self, n: u64) -> u64 {\n-   |            ^^^^^^^^^ read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+   |            ^^^^^^^^^ read access through <TAG> is forbidden\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n-   = note: BACKTRACE:\n+   = help: the accessed tag <TAG> has state Disabled which forbids child read accesses\n+help: the accessed tag <TAG> was created here, in the initial state Reserved\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |       let _res = f.add(unsafe {\n+   |  ________________^\n+LL | |         let n = f.0;\n+LL | |         // This is the access at fault, but it's not immediately apparent because\n+LL | |         // the reference that got invalidated is not under a Protector.\n+LL | |         *inner = 42;\n+LL | |         n\n+LL | |     });\n+   | |______^\n+help: the accessed tag <TAG> then transitioned from Reserved to Disabled due to a foreign write access at offsets [0x0..0x8]\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |         *inner = 42;\n+   |         ^^^^^^^^^^^\n+   = help: this corresponds to a loss of read and write permissions\n+   = note: BACKTRACE (of the first span):\n    = note: inside `Foo::add` at $DIR/write-during-2phase.rs:LL:CC\n note: inside `main`\n   --> $DIR/write-during-2phase.rs:LL:CC"}, {"sha": "ed43e552506d9e632b80d83942709158c3fedc02", "filename": "src/tools/miri/tests/fail/unaligned_pointers/intptrcast_alignment_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,7 +1,7 @@\n //@compile-flags: -Zmiri-symbolic-alignment-check -Zmiri-permissive-provenance -Cdebug-assertions=no\n // With the symbolic alignment check, even with intptrcast and without\n // validation, we want to be *sure* to catch bugs that arise from pointers being\n-// insufficiently aligned. The only way to achieve that is not not let programs\n+// insufficiently aligned. The only way to achieve that is not to let programs\n // exploit integer information for alignment, so here we test that this is\n // indeed the case.\n //"}, {"sha": "4e79b6a99e9c678098f5f8b72ac4808a07270a4d", "filename": "src/tools/miri/tests/panic/oob_subslice.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,7 @@\n+// This once failed with \"unwinding past a stack frame that does not allow unwinding\",\n+// fixed by https://github.com/rust-lang/rust/issues/110233.\n+\n+fn main() {\n+    let x = [1, 2, 3, 4];\n+    let _val = &x[..=4];\n+}"}, {"sha": "4c6deaeccf615341659495a733550116a67d7255", "filename": "src/tools/miri/tests/panic/oob_subslice.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpanic%2Foob_subslice.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,2 @@\n+thread 'main' panicked at 'range end index 5 out of range for slice of length 4', $DIR/oob_subslice.rs:LL:CC\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}, {"sha": "ae874740f2bc301dac48113b47b2ab538e4d117c", "filename": "src/tools/miri/tests/pass-dep/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -14,7 +14,7 @@ static mut RECORD: usize = 0;\n static mut KEYS: [Key; 2] = [0; 2];\n static mut GLOBALS: [u64; 2] = [1, 0];\n \n-static mut CANNARY: *mut u64 = ptr::null_mut(); // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+static mut CANARY: *mut u64 = ptr::null_mut(); // this serves as a canary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n \n pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n@@ -33,7 +33,7 @@ pub fn record(r: usize) {\n }\n \n unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n-    assert!(CANNARY != ptr::null_mut()); // make sure we do not get run too often\n+    assert!(CANARY != ptr::null_mut()); // make sure we do not get run too often\n     let val = *ptr;\n \n     let which_key =\n@@ -45,15 +45,15 @@ unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n         set(KEYS[which_key], ptr as *mut _);\n     }\n \n-    // Check if the records matches what we expect. If yes, clear the cannary.\n-    // If the record is wrong, the cannary will never get cleared, leading to a leak -> test fails.\n+    // Check if the records matches what we expect. If yes, clear the canary.\n+    // If the record is wrong, the canary will never get cleared, leading to a leak -> test fails.\n     // If the record is incomplete (i.e., more dtor calls happen), the check at the beginning of this function will fail -> test fails.\n     // The correct sequence is: First key 0, then key 1, then key 0.\n     // Note that this relies on dtor order, which is not specified by POSIX, but seems to be\n     // consistent between Miri and Linux currently (as of Aug 2022).\n     if RECORD == 0_1_0 {\n-        drop(Box::from_raw(CANNARY));\n-        CANNARY = ptr::null_mut();\n+        drop(Box::from_raw(CANARY));\n+        CANARY = ptr::null_mut();\n     }\n }\n \n@@ -67,7 +67,7 @@ fn main() {\n             set(*key, global as *mut _ as *mut u8);\n         }\n \n-        // Initialize cannary\n-        CANNARY = Box::into_raw(Box::new(0u64));\n+        // Initialize canary\n+        CANARY = Box::into_raw(Box::new(0u64));\n     }\n }"}, {"sha": "fbdf27688a9c83331dec4eb3423aae418c975dd4", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -130,7 +130,7 @@ fn test_readlink() {\n     let mut large_buf = vec![0xFF; expected_path.len() + 1];\n     let res =\n         unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n-    // Check that the resovled path was properly written into the buf.\n+    // Check that the resolved path was properly written into the buf.\n     assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n     assert_eq!(large_buf.last(), Some(&0xFF));\n     assert_eq!(res, large_buf.len() as isize - 1);"}, {"sha": "82ef59427ae837822d052338f4b39050463079db", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -90,7 +90,7 @@ fn test_posix_realpath_errors() {\n     use std::ffi::CString;\n     use std::io::ErrorKind;\n \n-    // Test non-existent path returns an error.\n+    // Test nonexistent path returns an error.\n     let c_path = CString::new(\"./nothing_to_see_here\").expect(\"CString::new failed\");\n     let r = unsafe { libc::realpath(c_path.as_ptr(), std::ptr::null_mut()) };\n     assert!(r.is_null());\n@@ -302,6 +302,101 @@ fn test_posix_mkstemp() {\n     }\n }\n \n+fn test_memcpy() {\n+    unsafe {\n+        let src = [1i8, 2, 3];\n+        let dest = libc::calloc(3, 1);\n+        libc::memcpy(dest, src.as_ptr() as *const libc::c_void, 3);\n+        let slc = std::slice::from_raw_parts(dest as *const i8, 3);\n+        assert_eq!(*slc, [1i8, 2, 3]);\n+        libc::free(dest);\n+    }\n+\n+    unsafe {\n+        let src = [1i8, 2, 3];\n+        let dest = libc::calloc(4, 1);\n+        libc::memcpy(dest, src.as_ptr() as *const libc::c_void, 3);\n+        let slc = std::slice::from_raw_parts(dest as *const i8, 4);\n+        assert_eq!(*slc, [1i8, 2, 3, 0]);\n+        libc::free(dest);\n+    }\n+\n+    unsafe {\n+        let src = 123_i32;\n+        let mut dest = 0_i32;\n+        libc::memcpy(\n+            &mut dest as *mut i32 as *mut libc::c_void,\n+            &src as *const i32 as *const libc::c_void,\n+            std::mem::size_of::<i32>(),\n+        );\n+        assert_eq!(dest, src);\n+    }\n+\n+    unsafe {\n+        let src = Some(123);\n+        let mut dest: Option<i32> = None;\n+        libc::memcpy(\n+            &mut dest as *mut Option<i32> as *mut libc::c_void,\n+            &src as *const Option<i32> as *const libc::c_void,\n+            std::mem::size_of::<Option<i32>>(),\n+        );\n+        assert_eq!(dest, src);\n+    }\n+\n+    unsafe {\n+        let src = &123;\n+        let mut dest = &42;\n+        libc::memcpy(\n+            &mut dest as *mut &'static i32 as *mut libc::c_void,\n+            &src as *const &'static i32 as *const libc::c_void,\n+            std::mem::size_of::<&'static i32>(),\n+        );\n+        assert_eq!(*dest, 123);\n+    }\n+}\n+\n+fn test_strcpy() {\n+    use std::ffi::{CStr, CString};\n+\n+    // case: src_size equals dest_size\n+    unsafe {\n+        let src = CString::new(\"rust\").unwrap();\n+        let size = src.as_bytes_with_nul().len();\n+        let dest = libc::malloc(size);\n+        libc::strcpy(dest as *mut libc::c_char, src.as_ptr());\n+        assert_eq!(CStr::from_ptr(dest as *const libc::c_char), src.as_ref());\n+        libc::free(dest);\n+    }\n+\n+    // case: src_size is less than dest_size\n+    unsafe {\n+        let src = CString::new(\"rust\").unwrap();\n+        let size = src.as_bytes_with_nul().len();\n+        let dest = libc::malloc(size + 1);\n+        libc::strcpy(dest as *mut libc::c_char, src.as_ptr());\n+        assert_eq!(CStr::from_ptr(dest as *const libc::c_char), src.as_ref());\n+        libc::free(dest);\n+    }\n+}\n+\n+#[cfg(target_os = \"linux\")]\n+fn test_sigrt() {\n+    let min = libc::SIGRTMIN();\n+    let max = libc::SIGRTMAX();\n+\n+    // \"The Linux kernel supports a range of 33 different real-time\n+    // signals, numbered 32 to 64\"\n+    assert!(min >= 32);\n+    assert!(max >= 32);\n+    assert!(min <= 64);\n+    assert!(max <= 64);\n+\n+    // \"POSIX.1-2001 requires that an implementation support at least\n+    // _POSIX_RTSIG_MAX (8) real-time signals.\"\n+    assert!(min < max);\n+    assert!(max - min >= 8)\n+}\n+\n fn main() {\n     test_posix_gettimeofday();\n     test_posix_mkstemp();\n@@ -315,9 +410,13 @@ fn main() {\n     test_isatty();\n     test_clocks();\n \n+    test_memcpy();\n+    test_strcpy();\n+\n     #[cfg(target_os = \"linux\")]\n     {\n         test_posix_fadvise();\n         test_sync_file_range();\n+        test_sigrt();\n     }\n }"}, {"sha": "769a7a7d3849df8fe36892528ed82ce15328b9d5", "filename": "src/tools/miri/tests/pass-dep/tokio/tokio_mvp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio%2Ftokio_mvp.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,5 +1,5 @@\n // Need to disable preemption to stay on the supported MVP codepath in mio.\n-//@compile-flags: -Zmiri-permissive-provenance\n+//@compile-flags: -Zmiri-permissive-provenance -Zmiri-preemption-rate=0\n //@only-target-x86_64-unknown-linux: support for tokio exists only on linux and x86\n \n #[tokio::main]"}, {"sha": "3a531eede67fae11c85dd3888aa787cd477a4a81", "filename": "src/tools/miri/tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -10,7 +10,7 @@\n // the RNG and never observed in our tests.\n //\n // To mitigate this, each test is ran enough times such that the chance\n-// of spurious success is very low. These tests never supriously fail.\n+// of spurious success is very low. These tests never spuriously fail.\n \n // Test cases and their consistent outcomes are from\n // http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/"}, {"sha": "6be13b155f41001f3380082bbdb1c5a6b2e93562", "filename": "src/tools/miri/tests/pass/dyn-arbitrary-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -93,7 +93,7 @@ fn pointers_and_wrappers() {\n \n     trait Trait {\n         // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n-        // without unsized_locals), but wrappers arond `Self` currently are not.\n+        // without unsized_locals), but wrappers around `Self` currently are not.\n         // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n         // fn wrapper(self: Wrapper<Self>) -> i32;\n         fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;"}, {"sha": "9a40c322b366e22bb40b7d01bfe4121ff173a24a", "filename": "src/tools/miri/tests/pass/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -19,7 +19,7 @@ unsafe impl GlobalAlloc for Allocator {\n \n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         if layout.size() == 123 {\n-            println!(\"Dellocated!\")\n+            println!(\"Deallocated!\")\n         }\n \n         System.dealloc(ptr, layout)"}, {"sha": "30c61946407c92271044bc03a6c644cec5a4a8e0", "filename": "src/tools/miri/tests/pass/global_allocator.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,2 +1,2 @@\n Allocated!\n-Dellocated!\n+Deallocated!"}, {"sha": "6b971c5217b7b326f2b335816521d8ffa7c32c1f", "filename": "src/tools/miri/tests/pass/issues/issue-29746.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -7,7 +7,7 @@ macro_rules! zip {\n     };\n \n     // Intermediate steps to build the zipped expression, the match pattern, and\n-    //  and the output tuple of the closure, using macro hygene to repeatedly\n+    //  and the output tuple of the closure, using macro hygiene to repeatedly\n     //  introduce new variables named 'x'.\n     ([$a:expr, $($rest:expr),*], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n         zip!([$($rest),*], $zip.zip($a), ($pat,x), [$($flat),*, x])"}, {"sha": "0b06167aec21190b922f19cf02a6862aaab1dfa3", "filename": "src/tools/miri/tests/pass/packed_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -36,7 +36,7 @@ fn test_basic() {\n     let b = x.b;\n     assert_eq!(a, 42);\n     assert_eq!(b, 99);\n-    assert_eq!(&x.fill, &0); // `fill` just requirs 1-byte-align, so this is fine\n+    assert_eq!(&x.fill, &0); // `fill` just requires 1-byte-align, so this is fine\n     // can't do `assert_eq!(x.a, 42)`, because `assert_eq!` takes a reference\n     assert_eq!({ x.a }, 42);\n     assert_eq!({ x.b }, 99);"}, {"sha": "92b275b00327dc0bf29cc1113ea532a11198c4ea", "filename": "src/tools/miri/tests/pass/ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -63,7 +63,7 @@ fn ptr_arith_offset_overflow() {\n     let v = [1i16, 2];\n     let x = &mut ptr::null(); // going through memory as there are more sanity checks along that path\n     *x = v.as_ptr().wrapping_offset(1); // ptr to the 2nd element\n-    // Adding 2*isize::max and then 1 is like substracting 1\n+    // Adding 2*isize::max and then 1 is like subtracting 1\n     *x = x.wrapping_offset(isize::MAX);\n     *x = x.wrapping_offset(isize::MAX);\n     *x = x.wrapping_offset(1);"}, {"sha": "8f1ef1b75cfc4c1a11bce14874c6f6f5a2d0a169", "filename": "src/tools/miri/tests/pass/rfc1623.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -58,7 +58,7 @@ fn main() {\n     STATIC_SIMPLE_FN(x);\n     CONST_SIMPLE_FN(x);\n \n-    STATIC_BAZ(BYTES); // neees static lifetime\n+    STATIC_BAZ(BYTES); // needs static lifetime\n     CONST_BAZ(BYTES);\n \n     // make sure this works with different lifetimes"}, {"sha": "af245aa89aa36b1a732ab621c29a1a3fb0851085", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -365,7 +365,7 @@ fn test_directory() {\n \n     // Deleting the directory should succeed.\n     remove_dir(&dir_path).unwrap();\n-    // Reading the metadata of a non-existent directory should fail with a \"not found\" error.\n+    // Reading the metadata of a nonexistent directory should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, check_metadata(&[], &dir_path).unwrap_err().kind());\n \n     // To test remove_dir_all, re-create the directory with a file and a directory in it."}, {"sha": "9e604f9abb83a535d1b60909a7a62721d8077ef7", "filename": "src/tools/miri/tests/pass/stacked-borrows/int-to-ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fint-to-ptr.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -23,17 +23,17 @@ fn example(variant: bool) {\n         let mut c = 42u32;\n \n         let x_unique1 = &mut c;\n-        // [..., Unique(1)]\n+        // stack: [..., Unique(1)]\n \n         let x_raw2 = x_unique1 as *mut u32;\n         let x_raw2_addr = x_raw2.expose_addr();\n-        // [..., Unique(1), SharedRW(2)]\n+        // stack: [..., Unique(1), SharedRW(2)]\n \n         let x_unique3 = &mut *x_raw2;\n-        // [.., Unique(1), SharedRW(2), Unique(3)]\n+        // stack: [.., Unique(1), SharedRW(2), Unique(3)]\n \n         assert_eq!(not_so_innocent(x_unique3), x_raw2_addr);\n-        // [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n+        // stack: [.., Unique(1), SharedRW(2), Unique(3), ..., SharedRW(4)]\n \n         // Do an int2ptr cast. This can pick tag 2 or 4 (the two previously exposed tags).\n         // 4 is the \"obvious\" choice (topmost tag, what we used to do with untagged pointers)."}, {"sha": "d7d7d1f97d6e5e924b91b094dfd5d53922d25223", "filename": "src/tools/miri/tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -90,7 +90,7 @@ fn mut_raw_mut() {\n         assert_eq!(unsafe { *xraw }, 4);\n         assert_eq!(*xref1, 4);\n         assert_eq!(unsafe { *xraw }, 4);\n-        // we cannot use xref2; see `compile-fail/stacked-borows/illegal_read4.rs`\n+        // we cannot use xref2; see `compile-fail/stacked-borrows/illegal_read4.rs`\n     }\n     assert_eq!(x, 4);\n }\n@@ -104,7 +104,7 @@ fn partially_invalidate_mut() {\n     assert_eq!(*data, (1, 1));\n }\n \n-// Make sure that we can handle the situation where a loaction is frozen when being dropped.\n+// Make sure that we can handle the situation where a location is frozen when being dropped.\n fn drop_after_sharing() {\n     let x = String::from(\"hello!\");\n     let _len = x.len();\n@@ -224,7 +224,7 @@ fn wide_raw_ptr_in_tuple() {\n fn not_unpin_not_protected() {\n     // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n     // don't add protectors. (We could, but until we have a better idea for where we want to go with\n-    // the self-referntial-generator situation, it does not seem worth the potential trouble.)\n+    // the self-referential-generator situation, it does not seem worth the potential trouble.)\n     use std::marker::PhantomPinned;\n \n     pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "72cdbe7ed5d6baa6cbc80532fb5834b17999d6a2", "filename": "src/tools/miri/tests/pass/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -29,7 +29,7 @@ fn unique_aliasing() {\n     // This is a regression test for the aliasing rules of a `Unique<T>` pointer.\n     // At the time of writing this test case, Miri does not treat `Unique<T>`\n     // pointers as a special case, these are treated like any other raw pointer.\n-    // However, there are existing Github issues which may lead to `Unique<T>`\n+    // However, there are existing GitHub issues which may lead to `Unique<T>`\n     // becoming a special case through asserting unique ownership over the pointee:\n     // - https://github.com/rust-lang/unsafe-code-guidelines/issues/258\n     // - https://github.com/rust-lang/unsafe-code-guidelines/issues/262"}, {"sha": "1eab4685a35f5c06d8bc56f552399fd5c4e4c8b8", "filename": "src/tools/miri/tests/pass/tree-borrows/cell-alternate-writes.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,10 +1,12 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=data, x, y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=data, x, y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "c20da1a593fc028f72cbf24dcd405362bd76fe53", "filename": "src/tools/miri/tests/pass/tree-borrows/end-of-protector.stderr", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,32 +1,36 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=x>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|        \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|          \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|          \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|            \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-| Dis|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Dis|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Dis|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Dis|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Dis|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Dis|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "8c3779fe1f7f71fb0a1803dd41acd6d2503f9f49", "filename": "src/tools/miri/tests/pass/tree-borrows/formatting.stderr", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,29 +1,31 @@\n-\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1..  2.. 10.. 11..100..101..1000..1001..1024\n-| Res| Act| Res| Act| Res| Act|  Res|  Act|  Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n-|----| Act|----|?Dis|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[1]>\n-|----|----|----| Act|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[10]>\n-|----|----|----|----|----| Frz| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[100]>\n-|----|----|----|----|----|----| ----|  Act| ----|      \u2514\u2500\u2500\u2500\u2500<TAG=data[1000]>\n-\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+| Act| Act| Act| Act| Act| Act|  Act|  Act|  Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res| Act| Res| Act| Res| Act|  Res|  Act|  Res|      \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+|----| Act|----|?Dis|----|?Dis| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[1]>\n+|----|----|----| Act|----|?Dis| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[10]>\n+|----|----|----|----|----| Frz| ----| ?Dis| ----|        \u251c\u2500\u2500\u2500\u2500<TAG=data[100]>\n+|----|----|----|----|----|----| ----|  Act| ----|        \u2514\u2500\u2500\u2500\u2500<TAG=data[1000]>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Frz|    \u2514\u2500\u252c\u2500\u2500<TAG=x>\n-| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xa>\n-| Frz|      \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xaa>\n-| Frz|      \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xab>\n-| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xb>\n-| Frz|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=xba>\n-| Frz|      \u2502   \u2514\u2500\u252c\u2500\u2500<TAG=xbaa>\n-| Frz|      \u2502     \u2514\u2500\u252c\u2500\u2500<TAG=xbaaa>\n-| Frz|      \u2502       \u2514\u2500\u2500\u2500\u2500<TAG=xbaaaa>\n-| Frz|      \u2514\u2500\u252c\u2500\u2500<TAG=xc>\n-| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xca>\n-| Frz|        \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xcaa>\n-| Frz|        \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xcab>\n-| Frz|        \u2514\u2500\u252c\u2500\u2500<TAG=xcb>\n-| Frz|          \u251c\u2500\u2500\u2500\u2500<TAG=xcba>\n-| Frz|          \u2514\u2500\u2500\u2500\u2500<TAG=xcbb>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Frz|      \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xa>\n+| Frz|        \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xaa>\n+| Frz|        \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xab>\n+| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xb>\n+| Frz|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=xba>\n+| Frz|        \u2502   \u2514\u2500\u252c\u2500\u2500<TAG=xbaa>\n+| Frz|        \u2502     \u2514\u2500\u252c\u2500\u2500<TAG=xbaaa>\n+| Frz|        \u2502       \u2514\u2500\u2500\u2500\u2500<TAG=xbaaaa>\n+| Frz|        \u2514\u2500\u252c\u2500\u2500<TAG=xc>\n+| Frz|          \u251c\u2500\u252c\u2500\u2500<TAG=xca>\n+| Frz|          \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xcaa>\n+| Frz|          \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xcab>\n+| Frz|          \u2514\u2500\u252c\u2500\u2500<TAG=xcb>\n+| Frz|            \u251c\u2500\u2500\u2500\u2500<TAG=xcba>\n+| Frz|            \u2514\u2500\u2500\u2500\u2500<TAG=xcbb>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "4daf06c777e9a990b7c258e48b96889200221307", "filename": "src/tools/miri/tests/pass/tree-borrows/read-only-from-mut.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b87ed9d0f18166a26aadb5289bac004e058b90f/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b87ed9d0f18166a26aadb5289bac004e058b90f/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs?ref=4b87ed9d0f18166a26aadb5289bac004e058b90f", "patch": "@@ -1,14 +0,0 @@\n-//@compile-flags: -Zmiri-tree-borrows\n-\n-// Tree Borrows has no issue with several mutable references existing\n-// at the same time, as long as they are used only immutably.\n-// I.e. multiple Reserved can coexist.\n-pub fn main() {\n-    unsafe {\n-        let base = &mut 42u64;\n-        let r1 = &mut *(base as *mut u64);\n-        let r2 = &mut *(base as *mut u64);\n-        let _l = *r1;\n-        let _l = *r2;\n-    }\n-}"}, {"sha": "8c4323b2f7fa75e5da7f607043e1a44b8e95d811", "filename": "src/tools/miri/tests/pass/tree-borrows/reborrow-is-read.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,13 +1,15 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=x>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n-| Frz|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Frz|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "afb917002221e14cf11a541690c530de783d5cda", "filename": "src/tools/miri/tests/pass/tree-borrows/reserved.stderr", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -2,51 +2,57 @@\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y, caller:y, callee:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [interior mut] Foreign Read: Re* -> Re*\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  8\n-| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Re*|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Re*|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [interior mut] Foreign Write: Re* -> Re*\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  8\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [protected] Foreign Read: Res -> Frz\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n-| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n-| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|        \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|        \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y, caller:y, callee:y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [] Foreign Read: Res -> Res\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Res|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n [] Foreign Write: Res -> Dis\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n Warning: this tree is indicative only. Some tags may have been hidden.\n 0..  1\n-| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n-| Dis|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n-| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=root of the allocation>\n+| Act|      \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Dis|        \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|        \u2514\u2500\u2500\u2500\u2500<TAG=y>\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "aa6f7078890e966345ad99b00b8221639b72ed95", "filename": "src/tools/miri/tests/pass/tree-borrows/tree-borrows.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftree-borrows.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -0,0 +1,280 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+#![feature(allocator_api)]\n+\n+use std::mem;\n+use std::ptr;\n+\n+fn main() {\n+    aliasing_read_only_mutable_refs();\n+    string_as_mut_ptr();\n+\n+    // Stacked Borrows tests\n+    read_does_not_invalidate1();\n+    read_does_not_invalidate2();\n+    mut_raw_then_mut_shr();\n+    mut_shr_then_mut_raw();\n+    mut_raw_mut();\n+    partially_invalidate_mut();\n+    drop_after_sharing();\n+    direct_mut_to_const_raw();\n+    two_raw();\n+    shr_and_raw();\n+    disjoint_mutable_subborrows();\n+    raw_ref_to_part();\n+    array_casts();\n+    mut_below_shr();\n+    wide_raw_ptr_in_tuple();\n+    not_unpin_not_protected();\n+}\n+\n+// Tree Borrows has no issue with several mutable references existing\n+// at the same time, as long as they are used only immutably.\n+// I.e. multiple Reserved can coexist.\n+pub fn aliasing_read_only_mutable_refs() {\n+    unsafe {\n+        let base = &mut 42u64;\n+        let r1 = &mut *(base as *mut u64);\n+        let r2 = &mut *(base as *mut u64);\n+        let _l = *r1;\n+        let _l = *r2;\n+    }\n+}\n+\n+pub fn string_as_mut_ptr() {\n+    // This errors in Stacked Borrows since as_mut_ptr restricts the provenance,\n+    // but with Tree Borrows it should work.\n+    unsafe {\n+        let mut s = String::from(\"hello\");\n+        s.reserve(1); // make the `str` that `s` derefs to not cover the entire `s`.\n+\n+        // Prevent automatically dropping the String's data\n+        let mut s = mem::ManuallyDrop::new(s);\n+\n+        let ptr = s.as_mut_ptr();\n+        let len = s.len();\n+        let capacity = s.capacity();\n+\n+        let s = String::from_raw_parts(ptr, len, capacity);\n+\n+        assert_eq!(String::from(\"hello\"), s);\n+    }\n+}\n+\n+// ----- The tests below were taken from Stacked Borrows ----\n+\n+// Make sure that reading from an `&mut` does, like reborrowing to `&`,\n+// NOT invalidate other reborrows.\n+fn read_does_not_invalidate1() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let ret = unsafe { &(*xraw).1 };\n+        let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n+        ret\n+    }\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+// Same as above, but this time we first create a raw, then read from `&mut`\n+// and then freeze from the raw.\n+fn read_does_not_invalidate2() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let _val = x.1; // we just read, this does NOT invalidate the raw reborrow.\n+        let ret = unsafe { &(*xraw).1 };\n+        ret\n+    }\n+    assert_eq!(*foo(&mut (1, 2)), 2);\n+}\n+\n+// Escape a mut to raw, then share the same mut and use the share, then the raw.\n+// That should work.\n+fn mut_raw_then_mut_shr() {\n+    let mut x = 2;\n+    let xref = &mut x;\n+    let xraw = &mut *xref as *mut _;\n+    let xshr = &*xref;\n+    assert_eq!(*xshr, 2);\n+    unsafe {\n+        *xraw = 4;\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+// Create first a shared reference and then a raw pointer from a `&mut`\n+// should permit mutation through that raw pointer.\n+fn mut_shr_then_mut_raw() {\n+    let xref = &mut 2;\n+    let _xshr = &*xref;\n+    let xraw = xref as *mut _;\n+    unsafe {\n+        *xraw = 3;\n+    }\n+    assert_eq!(*xref, 3);\n+}\n+\n+// Ensure that if we derive from a mut a raw, and then from that a mut,\n+// and then read through the original mut, that does not invalidate the raw.\n+// This shows that the read-exception for `&mut` applies even if the `Shr` item\n+// on the stack is not at the top.\n+fn mut_raw_mut() {\n+    let mut x = 2;\n+    {\n+        let xref1 = &mut x;\n+        let xraw = xref1 as *mut _;\n+        let _xref2 = unsafe { &mut *xraw };\n+        let _val = *xref1;\n+        unsafe {\n+            *xraw = 4;\n+        }\n+        // we can now use both xraw and xref1, for reading\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        assert_eq!(*xref1, 4);\n+        assert_eq!(unsafe { *xraw }, 4);\n+        // we cannot use xref2; see `compile-fail/stacked-borrows/illegal_read4.rs`\n+    }\n+    assert_eq!(x, 4);\n+}\n+\n+fn partially_invalidate_mut() {\n+    let data = &mut (0u8, 0u8);\n+    let reborrow = &mut *data as *mut (u8, u8);\n+    let shard = unsafe { &mut (*reborrow).0 };\n+    data.1 += 1; // the deref overlaps with `shard`, but that is ok; the access does not overlap.\n+    *shard += 1; // so we can still use `shard`.\n+    assert_eq!(*data, (1, 1));\n+}\n+\n+// Make sure that we can handle the situation where a location is frozen when being dropped.\n+fn drop_after_sharing() {\n+    let x = String::from(\"hello!\");\n+    let _len = x.len();\n+}\n+\n+// Make sure that coercing &mut T to *const T produces a writeable pointer.\n+fn direct_mut_to_const_raw() {\n+    // TODO: This is currently disabled, waiting on a decision on <https://github.com/rust-lang/rust/issues/56604>\n+    /*let x = &mut 0;\n+    let y: *const i32 = x;\n+    unsafe { *(y as *mut i32) = 1; }\n+    assert_eq!(*x, 1);\n+    */\n+}\n+\n+// Make sure that we can create two raw pointers from a mutable reference and use them both.\n+fn two_raw() {\n+    unsafe {\n+        let x = &mut 0;\n+        let y1 = x as *mut _;\n+        let y2 = x as *mut _;\n+        *y1 += 2;\n+        *y2 += 1;\n+    }\n+}\n+\n+// Make sure that creating a *mut does not invalidate existing shared references.\n+fn shr_and_raw() {\n+    unsafe {\n+        let x = &mut 0;\n+        let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+        let y2 = x as *mut _;\n+        let _val = *y1;\n+        *y2 += 1;\n+    }\n+}\n+\n+fn disjoint_mutable_subborrows() {\n+    struct Foo {\n+        a: String,\n+        b: Vec<u32>,\n+    }\n+\n+    unsafe fn borrow_field_a<'a>(this: *mut Foo) -> &'a mut String {\n+        &mut (*this).a\n+    }\n+\n+    unsafe fn borrow_field_b<'a>(this: *mut Foo) -> &'a mut Vec<u32> {\n+        &mut (*this).b\n+    }\n+\n+    let mut foo = Foo { a: \"hello\".into(), b: vec![0, 1, 2] };\n+\n+    let ptr = &mut foo as *mut Foo;\n+\n+    let a = unsafe { borrow_field_a(ptr) };\n+    let b = unsafe { borrow_field_b(ptr) };\n+    b.push(4);\n+    a.push_str(\" world\");\n+    assert_eq!(format!(\"{:?} {:?}\", a, b), r#\"\"hello world\" [0, 1, 2, 4]\"#);\n+}\n+\n+fn raw_ref_to_part() {\n+    struct Part {\n+        _lame: i32,\n+    }\n+\n+    #[repr(C)]\n+    struct Whole {\n+        part: Part,\n+        extra: i32,\n+    }\n+\n+    let it = Box::new(Whole { part: Part { _lame: 0 }, extra: 42 });\n+    let whole = ptr::addr_of_mut!(*Box::leak(it));\n+    let part = unsafe { ptr::addr_of_mut!((*whole).part) };\n+    let typed = unsafe { &mut *(part as *mut Whole) };\n+    assert!(typed.extra == 42);\n+    drop(unsafe { Box::from_raw(whole) });\n+}\n+\n+/// When casting an array reference to a raw element ptr, that should cover the whole array.\n+fn array_casts() {\n+    let mut x: [usize; 2] = [0, 0];\n+    let p = &mut x as *mut usize;\n+    unsafe {\n+        *p.add(1) = 1;\n+    }\n+\n+    let x: [usize; 2] = [0, 1];\n+    let p = &x as *const usize;\n+    assert_eq!(unsafe { *p.add(1) }, 1);\n+}\n+\n+/// Transmuting &&i32 to &&mut i32 is fine.\n+fn mut_below_shr() {\n+    let x = 0;\n+    let y = &x;\n+    let p = unsafe { core::mem::transmute::<&&i32, &&mut i32>(&y) };\n+    let r = &**p;\n+    let _val = *r;\n+}\n+\n+fn wide_raw_ptr_in_tuple() {\n+    let mut x: Box<dyn std::any::Any> = Box::new(\"ouch\");\n+    let r = &mut *x as *mut dyn std::any::Any;\n+    // This triggers the visitor-based recursive retagging. It is *not* supposed to retag raw\n+    // pointers, but then the visitor might recurse into the \"fields\" of a wide raw pointer and\n+    // finds a reference (to a vtable) there that it wants to retag... and that would be Wrong.\n+    let pair = (r, &0);\n+    let r = unsafe { &mut *pair.0 };\n+    // Make sure the fn ptr part of the vtable is still fine.\n+    r.type_id();\n+}\n+\n+fn not_unpin_not_protected() {\n+    // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n+    // don't add protectors. (We could, but until we have a better idea for where we want to go with\n+    // the self-referential-generator situation, it does not seem worth the potential trouble.)\n+    use std::marker::PhantomPinned;\n+\n+    pub struct NotUnpin(i32, PhantomPinned);\n+\n+    fn inner(x: &mut NotUnpin, f: fn(&mut NotUnpin)) {\n+        // `f` may mutate, but it may not deallocate!\n+        f(x)\n+    }\n+\n+    inner(Box::leak(Box::new(NotUnpin(0, PhantomPinned))), |x| {\n+        let raw = x as *mut _;\n+        drop(unsafe { Box::from_raw(raw) });\n+    });\n+}"}, {"sha": "94df730808066aab85971a2ebdff4d37a15774a8", "filename": "src/tools/miri/tests/pass/weak_memory/extra_cpp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,6 +1,6 @@\n //@compile-flags: -Zmiri-ignore-leaks\n \n-// Tests operations not perfomable through C++'s atomic API\n+// Tests operations not performable through C++'s atomic API\n // but doable in safe (at least sound) Rust.\n \n #![feature(atomic_from_mut)]"}, {"sha": "48b15191b38b0fc1229ee09704e9c459831325ba", "filename": "src/tools/miri/tests/pass/weak_memory/extra_cpp_unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7d8c88b64843d05761576aa093a34a8bc176817/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=b7d8c88b64843d05761576aa093a34a8bc176817", "patch": "@@ -1,6 +1,6 @@\n //@compile-flags: -Zmiri-ignore-leaks\n \n-// Tests operations not perfomable through C++'s atomic API\n+// Tests operations not performable through C++'s atomic API\n // but doable in unsafe Rust which we think *should* be fine.\n // Nonetheless they may be determined as inconsistent with the\n // memory model in the future."}]}