{"sha": "609a9e69e1c1def4d570cfb3c31640200ef738c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwOWE5ZTY5ZTFjMWRlZjRkNTcwY2ZiM2MzMTY0MDIwMGVmNzM4Yzk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-05-23T16:39:00Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-05-24T00:57:06Z"}, "message": "cleanup warnings from libextra", "tree": {"sha": "4b429895df4cc024f0e3608bfb433614cb7d57cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b429895df4cc024f0e3608bfb433614cb7d57cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/609a9e69e1c1def4d570cfb3c31640200ef738c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/609a9e69e1c1def4d570cfb3c31640200ef738c9", "html_url": "https://github.com/rust-lang/rust/commit/609a9e69e1c1def4d570cfb3c31640200ef738c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/609a9e69e1c1def4d570cfb3c31640200ef738c9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc970c13f476ef086066a47829185ac83645c61f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc970c13f476ef086066a47829185ac83645c61f", "html_url": "https://github.com/rust-lang/rust/commit/dc970c13f476ef086066a47829185ac83645c61f"}], "stats": {"total": 934, "additions": 460, "deletions": 474}, "files": [{"sha": "41584710a41714b517b6c8e7ab669d29983d2961", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -12,10 +12,6 @@\n \n use core::prelude::*;\n \n-use core::old_iter;\n-use core::str;\n-use core::vec;\n-\n pub trait ToBase64 {\n     fn to_base64(&self) -> ~str;\n }\n@@ -242,12 +238,12 @@ mod tests {\n \n     #[test]\n     fn test_from_base64() {\n-        assert_eq!((~\"\").from_base64(), str::to_bytes(~\"\"));\n-        assert!((~\"Zg==\").from_base64() == str::to_bytes(~\"f\"));\n-        assert_eq!((~\"Zm8=\").from_base64(), str::to_bytes(~\"fo\"));\n-        assert_eq!((~\"Zm9v\").from_base64(), str::to_bytes(~\"foo\"));\n-        assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(~\"foob\"));\n-        assert_eq!((~\"Zm9vYmE=\").from_base64(), str::to_bytes(~\"fooba\"))\n-        assert_eq!((~\"Zm9vYmFy\").from_base64(), str::to_bytes(~\"foobar\"));\n+        assert_eq!((~\"\").from_base64(), str::to_bytes(\"\"));\n+        assert!((~\"Zg==\").from_base64() == str::to_bytes(\"f\"));\n+        assert_eq!((~\"Zm8=\").from_base64(), str::to_bytes(\"fo\"));\n+        assert_eq!((~\"Zm9v\").from_base64(), str::to_bytes(\"foo\"));\n+        assert!((~\"Zm9vYg==\").from_base64() == str::to_bytes(\"foob\"));\n+        assert_eq!((~\"Zm9vYmE=\").from_base64(), str::to_bytes(\"fooba\"))\n+        assert_eq!((~\"Zm9vYmFy\").from_base64(), str::to_bytes(\"foobar\"));\n     }\n }"}, {"sha": "1262e90518db3f5904f8fd80561c25d3c80e9b03", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -10,8 +10,6 @@\n \n use core::prelude::*;\n \n-use core::vec::from_elem;\n-\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n     bits: uint\n@@ -257,7 +255,7 @@ pub impl Bitv {\n             let nelems = nbits/uint::bits +\n                          if nbits % uint::bits == 0 {0} else {1};\n             let elem = if init {!0} else {0};\n-            let s = from_elem(nelems, elem);\n+            let s = vec::from_elem(nelems, elem);\n             Big(~BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n@@ -502,7 +500,7 @@ impl Clone for Bitv {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let mut st = from_elem(self.nbits / uint::bits + 1, 0);\n+            let mut st = vec::from_elem(self.nbits / uint::bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: st})}\n@@ -872,17 +870,14 @@ mod tests {\n \n     #[test]\n     fn test_0_elements() {\n-        let mut act;\n-        let exp;\n-        act = Bitv::new(0u, false);\n-        exp = vec::from_elem::<uint>(0u, 0u);\n+        let act = Bitv::new(0u, false);\n+        let exp = vec::from_elem::<uint>(0u, 0u);\n         assert!(act.eq_vec(exp));\n     }\n \n     #[test]\n     fn test_1_element() {\n-        let mut act;\n-        act = Bitv::new(1u, false);\n+        let mut act = Bitv::new(1u, false);\n         assert!(act.eq_vec(~[0u]));\n         act = Bitv::new(1u, true);\n         assert!(act.eq_vec(~[1u]));\n@@ -1488,7 +1483,7 @@ mod tests {\n     #[bench]\n     fn bench_bitv_big_union(b: &mut BenchHarness) {\n         let mut b1 = Bitv::new(bench_bits, false);\n-        let mut b2 = Bitv::new(bench_bits, false);\n+        let b2 = Bitv::new(bench_bits, false);\n         do b.iter {\n             b1.union(&b2);\n         }"}, {"sha": "d3da13dde987a05aef4e548487a8bf2a69450593", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -540,13 +540,13 @@ mod tests {\n \n     #[test]\n     fn test_dlist_concat() {\n-        let a = from_vec(~[1,2]);\n-        let b = from_vec(~[3,4]);\n-        let c = from_vec(~[5,6]);\n-        let d = from_vec(~[7,8]);\n-        let ab = from_vec(~[a,b]);\n-        let cd = from_vec(~[c,d]);\n-        let abcd = concat(concat(from_vec(~[ab,cd])));\n+        let a = from_vec([1,2]);\n+        let b = from_vec([3,4]);\n+        let c = from_vec([5,6]);\n+        let d = from_vec([7,8]);\n+        let ab = from_vec([a,b]);\n+        let cd = from_vec([c,d]);\n+        let abcd = concat(concat(from_vec([ab,cd])));\n         abcd.assert_consistent(); assert_eq!(abcd.len(), 8);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 1);\n         abcd.assert_consistent(); assert_eq!(abcd.pop().get(), 2);\n@@ -560,8 +560,8 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_append() {\n-        let a = from_vec(~[1,2,3]);\n-        let b = from_vec(~[4,5,6]);\n+        let a = from_vec([1,2,3]);\n+        let b = from_vec([4,5,6]);\n         a.append(b);\n         assert_eq!(a.len(), 6);\n         assert_eq!(b.len(), 0);\n@@ -576,7 +576,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_append_empty() {\n-        let a = from_vec(~[1,2,3]);\n+        let a = from_vec([1,2,3]);\n         let b = DList::<int>();\n         a.append(b);\n         assert_eq!(a.len(), 3);\n@@ -590,7 +590,7 @@ mod tests {\n     #[test]\n     fn test_dlist_append_to_empty() {\n         let a = DList::<int>();\n-        let b = from_vec(~[4,5,6]);\n+        let b = from_vec([4,5,6]);\n         a.append(b);\n         assert_eq!(a.len(), 3);\n         assert_eq!(b.len(), 0);\n@@ -626,8 +626,8 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_prepend() {\n-        let a = from_vec(~[1,2,3]);\n-        let b = from_vec(~[4,5,6]);\n+        let a = from_vec([1,2,3]);\n+        let b = from_vec([4,5,6]);\n         b.prepend(a);\n         assert_eq!(a.len(), 0);\n         assert_eq!(b.len(), 6);\n@@ -642,7 +642,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_reverse() {\n-        let a = from_vec(~[5,4,3,2,1]);\n+        let a = from_vec([5,4,3,2,1]);\n         a.reverse();\n         assert_eq!(a.len(), 5);\n         a.assert_consistent(); assert_eq!(a.pop().get(), 1);\n@@ -661,7 +661,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_each_node() {\n-        let a = from_vec(~[1,2,4,5]);\n+        let a = from_vec([1,2,4,5]);\n         for a.each_node |nobe| {\n             if nobe.data > 3 {\n                 a.insert_before(3, nobe);\n@@ -678,28 +678,28 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_clear() {\n-        let a = from_vec(~[5,4,3,2,1]);\n+        let a = from_vec([5,4,3,2,1]);\n         a.clear();\n         assert_eq!(a.len(), 0);\n         a.assert_consistent();\n     }\n     #[test]\n     fn test_dlist_is_empty() {\n         let empty = DList::<int>();\n-        let full1 = from_vec(~[1,2,3]);\n+        let full1 = from_vec([1,2,3]);\n         assert!(empty.is_empty());\n         assert!(!full1.is_empty());\n     }\n     #[test]\n     fn test_dlist_head_tail() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.head(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.len(), 3);\n     }\n     #[test]\n     fn test_dlist_pop() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.pop().get(), 1);\n         assert_eq!(l.tail(), 3);\n         assert_eq!(l.head(), 2);\n@@ -712,7 +712,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_pop_tail() {\n-        let l = from_vec(~[1,2,3]);\n+        let l = from_vec([1,2,3]);\n         assert_eq!(l.pop_tail().get(), 3);\n         assert_eq!(l.tail(), 2);\n         assert_eq!(l.head(), 1);\n@@ -758,7 +758,7 @@ mod tests {\n     }\n     #[test]\n     fn test_dlist_break_early() {\n-        let l = from_vec(~[1,2,3,4,5]);\n+        let l = from_vec([1,2,3,4,5]);\n         let mut x = 0;\n         for l.each |i| {\n             x += 1;"}, {"sha": "42dde4ab890c82d54989a24571aafaa00712beb4", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -96,8 +96,6 @@ total line count).\n \n use core::prelude::*;\n \n-use core::io::ReaderUtil;\n-\n /**\n A summary of the internal state of a `FileInput` object. `line_num`\n and `line_num_file` represent the number of lines read in total and in\n@@ -407,7 +405,6 @@ pub fn input_vec_state(files: ~[Option<Path>],\n mod test {\n     use core::prelude::*;\n \n-    use core::io::WriterUtil;\n     use super::{FileInput, pathify, input_vec, input_vec_state};\n \n     fn make_file(path : &Path, contents: &[~str]) {\n@@ -441,7 +438,7 @@ mod test {\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n         for filenames.eachi |i, &filename| {\n-            make_file(filename.get_ref(), ~[fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(copy filenames);\n@@ -471,7 +468,7 @@ mod test {\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n         for filenames.eachi |i, &filename| {\n-            make_file(filename.get_ref(), ~[fmt!(\"%u\", i)]);\n+            make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n         let fi = FileInput::from_vec(filenames);\n@@ -533,9 +530,9 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-empty-files-%u.tmp\", i)),true);\n \n-        make_file(filenames[0].get_ref(), ~[~\"1\", ~\"2\"]);\n-        make_file(filenames[1].get_ref(), ~[]);\n-        make_file(filenames[2].get_ref(), ~[~\"3\", ~\"4\"]);\n+        make_file(filenames[0].get_ref(), [~\"1\", ~\"2\"]);\n+        make_file(filenames[1].get_ref(), []);\n+        make_file(filenames[2].get_ref(), [~\"3\", ~\"4\"]);\n \n         let mut count = 0;\n         for input_vec_state(copy filenames) |line, state| {\n@@ -580,7 +577,7 @@ mod test {\n             make_file(&filename.get(), contents);\n         }\n \n-        let mut in = FileInput::from_vec(filenames);\n+        let in = FileInput::from_vec(filenames);\n \n         // read once from 0\n         assert_eq!(in.read_line(), ~\"0 1\");"}, {"sha": "d184e67ab29f8d67ebc00905e87ac4dc8a5de598", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -16,12 +16,8 @@ Simple compression\n \n use core::prelude::*;\n \n-use core::libc::{c_void, size_t, c_int};\n use core::libc;\n-use core::vec;\n-\n-#[cfg(test)] use core::rand;\n-#[cfg(test)] use core::rand::RngUtil;\n+use core::libc::{c_void, size_t, c_int};\n \n pub mod rustrt {\n     use core::libc::{c_int, c_void, size_t};\n@@ -83,27 +79,34 @@ pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     }\n }\n \n-#[test]\n-#[allow(non_implicitly_copyable_typarams)]\n-fn test_flate_round_trip() {\n-    let mut r = rand::rng();\n-    let mut words = ~[];\n-    for 20.times {\n-        let range = r.gen_uint_range(1, 10);\n-        words.push(r.gen_bytes(range));\n-    }\n-    for 20.times {\n-        let mut in = ~[];\n-        for 2000.times {\n-            in.push_all(r.choose(words));\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use core::rand;\n+    use core::rand::RngUtil;\n+\n+    #[test]\n+    #[allow(non_implicitly_copyable_typarams)]\n+    fn test_flate_round_trip() {\n+        let mut r = rand::rng();\n+        let mut words = ~[];\n+        for 20.times {\n+            let range = r.gen_uint_range(1, 10);\n+            words.push(r.gen_bytes(range));\n+        }\n+        for 20.times {\n+            let mut in = ~[];\n+            for 2000.times {\n+                in.push_all(r.choose(words));\n+            }\n+            debug!(\"de/inflate of %u bytes of random word-sequences\",\n+                   in.len());\n+            let cmp = deflate_bytes(in);\n+            let out = inflate_bytes(cmp);\n+            debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n+                   in.len(), cmp.len(),\n+                   100.0 * ((cmp.len() as float) / (in.len() as float)));\n+            assert_eq!(in, out);\n         }\n-        debug!(\"de/inflate of %u bytes of random word-sequences\",\n-               in.len());\n-        let cmp = deflate_bytes(in);\n-        let out = inflate_bytes(cmp);\n-        debug!(\"%u bytes deflated to %u (%.1f%% size)\",\n-               in.len(), cmp.len(),\n-               100.0 * ((cmp.len() as float) / (in.len() as float)));\n-        assert_eq!(in, out);\n     }\n }"}, {"sha": "539d18cb0cd5bcb37ea4588c0b6f4f384eb5eb2a", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 126, "deletions": 129, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -681,12 +681,12 @@ mod tests {\n     #[test]\n     fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => { fail!(\"test_reqopt_long failed\"); }\n         }\n@@ -695,7 +695,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n@@ -706,7 +706,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -717,7 +717,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[reqopt(~\"test\")];\n+        let opts = ~[reqopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -728,12 +728,12 @@ mod tests {\n     #[test]\n     fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -742,7 +742,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionMissing_),\n@@ -753,7 +753,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -764,7 +764,7 @@ mod tests {\n     #[test]\n     fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[reqopt(~\"t\")];\n+        let opts = ~[reqopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -777,12 +777,12 @@ mod tests {\n     #[test]\n     fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -791,18 +791,18 @@ mod tests {\n     #[test]\n     fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -813,7 +813,7 @@ mod tests {\n     #[test]\n     fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optopt(~\"test\")];\n+        let opts = ~[optopt(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -824,12 +824,12 @@ mod tests {\n     #[test]\n     fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -838,18 +838,18 @@ mod tests {\n     #[test]\n     fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -860,7 +860,7 @@ mod tests {\n     #[test]\n     fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optopt(~\"t\")];\n+        let opts = ~[optopt(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -873,29 +873,29 @@ mod tests {\n     #[test]\n     fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => {\n@@ -909,7 +909,7 @@ mod tests {\n     #[test]\n     fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n-        let opts = ~[optflag(~\"test\")];\n+        let opts = ~[optflag(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -920,29 +920,29 @@ mod tests {\n     #[test]\n     fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n@@ -957,7 +957,7 @@ mod tests {\n     #[test]\n     fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n-        let opts = ~[optflag(~\"t\")];\n+        let opts = ~[optflag(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, OptionDuplicated_),\n@@ -969,11 +969,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 1);\n+            assert_eq!(opt_count(m, \"v\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -982,11 +982,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 2);\n+            assert_eq!(opt_count(m, \"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -995,11 +995,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n-        let opts = ~[optflagmulti(~\"v\")];\n+        let opts = ~[optflagmulti(\"v\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"v\"), 2);\n+            assert_eq!(opt_count(m, \"v\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1008,11 +1008,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n-        let opts = ~[optflagmulti(~\"verbose\")];\n+        let opts = ~[optflagmulti(\"verbose\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"verbose\"), 1);\n+            assert_eq!(opt_count(m, \"verbose\"), 1);\n           }\n           _ => fail!()\n         }\n@@ -1021,11 +1021,11 @@ mod tests {\n     #[test]\n     fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n-        let opts = ~[optflagmulti(~\"verbose\")];\n+        let opts = ~[optflagmulti(\"verbose\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert_eq!(opt_count(m, ~\"verbose\"), 2);\n+            assert_eq!(opt_count(m, \"verbose\"), 2);\n           }\n           _ => fail!()\n         }\n@@ -1035,12 +1035,12 @@ mod tests {\n     #[test]\n     fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"test\")));\n-            assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n+            assert!((opt_present(m, \"test\")));\n+            assert_eq!(opt_str(m, \"test\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1049,18 +1049,18 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"test\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"test\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -1071,13 +1071,13 @@ mod tests {\n     #[test]\n     fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-              assert!(opt_present(m, ~\"test\"));\n-              assert_eq!(opt_str(m, ~\"test\"), ~\"20\");\n-              let pair = opt_strs(m, ~\"test\");\n+              assert!(opt_present(m, \"test\"));\n+              assert_eq!(opt_str(m, \"test\"), ~\"20\");\n+              let pair = opt_strs(m, \"test\");\n               assert!(pair[0] == ~\"20\");\n               assert!(pair[1] == ~\"30\");\n           }\n@@ -1088,12 +1088,12 @@ mod tests {\n     #[test]\n     fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n           }\n           _ => fail!()\n         }\n@@ -1102,18 +1102,18 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n-          Ok(ref m) => assert!(!opt_present(m, ~\"t\")),\n+          Ok(ref m) => assert!(!opt_present(m, \"t\")),\n           _ => fail!()\n         }\n     }\n \n     #[test]\n     fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, ArgumentMissing_),\n@@ -1124,13 +1124,13 @@ mod tests {\n     #[test]\n     fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n-            assert!((opt_present(m, ~\"t\")));\n-            assert_eq!(opt_str(m, ~\"t\"), ~\"20\");\n-            let pair = opt_strs(m, ~\"t\");\n+            assert!((opt_present(m, \"t\")));\n+            assert_eq!(opt_str(m, \"t\"), ~\"20\");\n+            let pair = opt_strs(m, \"t\");\n             assert!(pair[0] == ~\"20\");\n             assert!(pair[1] == ~\"30\");\n           }\n@@ -1141,7 +1141,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n-        let opts = ~[optmulti(~\"t\")];\n+        let opts = ~[optmulti(\"t\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1152,7 +1152,7 @@ mod tests {\n     #[test]\n     fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n-        let opts = ~[optmulti(~\"test\")];\n+        let opts = ~[optmulti(\"test\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Err(copy f) => check_fail_type(f, UnrecognizedOption_),\n@@ -1167,26 +1167,26 @@ mod tests {\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n               ~\"-m\", ~\"50\", ~\"-n\", ~\"-A B\", ~\"-n\", ~\"-60 70\"];\n         let opts =\n-            ~[optopt(~\"s\"), optflag(~\"flag\"), reqopt(~\"long\"),\n-             optflag(~\"f\"), optmulti(~\"m\"), optmulti(~\"n\"),\n-             optopt(~\"notpresent\")];\n+            ~[optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n+             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n+             optopt(\"notpresent\")];\n         let rs = getopts(args, opts);\n         match rs {\n           Ok(ref m) => {\n             assert!(m.free[0] == ~\"prog\");\n             assert!(m.free[1] == ~\"free1\");\n-            assert_eq!(opt_str(m, ~\"s\"), ~\"20\");\n+            assert_eq!(opt_str(m, \"s\"), ~\"20\");\n             assert!(m.free[2] == ~\"free2\");\n-            assert!((opt_present(m, ~\"flag\")));\n-            assert_eq!(opt_str(m, ~\"long\"), ~\"30\");\n-            assert!((opt_present(m, ~\"f\")));\n-            let pair = opt_strs(m, ~\"m\");\n+            assert!((opt_present(m, \"flag\")));\n+            assert_eq!(opt_str(m, \"long\"), ~\"30\");\n+            assert!((opt_present(m, \"f\")));\n+            let pair = opt_strs(m, \"m\");\n             assert!(pair[0] == ~\"40\");\n             assert!(pair[1] == ~\"50\");\n-            let pair = opt_strs(m, ~\"n\");\n+            let pair = opt_strs(m, \"n\");\n             assert!(pair[0] == ~\"-A B\");\n             assert!(pair[1] == ~\"-60 70\");\n-            assert!((!opt_present(m, ~\"notpresent\")));\n+            assert!((!opt_present(m, \"notpresent\")));\n           }\n           _ => fail!()\n         }\n@@ -1195,43 +1195,43 @@ mod tests {\n     #[test]\n     fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n-        let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\"), optopt(~\"f\")];\n+        let opts = ~[optopt(\"e\"), optopt(\"encrypt\"), optopt(\"f\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, ~[~\"e\"]));\n-        assert!(opts_present(matches, ~[~\"encrypt\"]));\n-        assert!(opts_present(matches, ~[~\"encrypt\", ~\"e\"]));\n-        assert!(opts_present(matches, ~[~\"e\", ~\"encrypt\"]));\n-        assert!(!opts_present(matches, ~[~\"f\"]));\n-        assert!(!opts_present(matches, ~[~\"thing\"]));\n-        assert!(!opts_present(matches, ~[]));\n+        assert!(opts_present(matches, [~\"e\"]));\n+        assert!(opts_present(matches, [~\"encrypt\"]));\n+        assert!(opts_present(matches, [~\"encrypt\", ~\"e\"]));\n+        assert!(opts_present(matches, [~\"e\", ~\"encrypt\"]));\n+        assert!(!opts_present(matches, [~\"f\"]));\n+        assert!(!opts_present(matches, [~\"thing\"]));\n+        assert!(!opts_present(matches, []));\n \n-        assert_eq!(opts_str(matches, ~[~\"e\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"e\", ~\"encrypt\"]), ~\"foo\");\n-        assert_eq!(opts_str(matches, ~[~\"encrypt\", ~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"e\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"e\", ~\"encrypt\"]), ~\"foo\");\n+        assert_eq!(opts_str(matches, [~\"encrypt\", ~\"e\"]), ~\"foo\");\n     }\n \n     #[test]\n     fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n-        let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n+        let opts = ~[optmulti(\"L\"), optmulti(\"M\")];\n         let matches = &match getopts(args, opts) {\n           result::Ok(m) => m,\n           result::Err(_) => fail!()\n         };\n-        assert!(opts_present(matches, ~[~\"L\"]));\n-        assert_eq!(opts_str(matches, ~[~\"L\"]), ~\"foo\");\n-        assert!(opts_present(matches, ~[~\"M\"]));\n-        assert_eq!(opts_str(matches, ~[~\"M\"]), ~\".\");\n+        assert!(opts_present(matches, [~\"L\"]));\n+        assert_eq!(opts_str(matches, [~\"L\"]), ~\"foo\");\n+        assert!(opts_present(matches, [~\"M\"]));\n+        assert_eq!(opts_str(matches, [~\"M\"]), ~\".\");\n \n     }\n \n     #[test]\n     fn test_groups_reqopt() {\n-        let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n+        let opt = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n                         hint: ~\"VAL\",\n@@ -1242,7 +1242,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optopt() {\n-        let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n+        let opt = groups::optopt(\"a\", \"apple\", \"some apples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n                         hint: ~\"VAL\",\n@@ -1253,7 +1253,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflag() {\n-        let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n+        let opt = groups::optflag(\"k\", \"kiwi\", \"some kiwis\");\n         assert!(opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n                         hint: ~\"\",\n@@ -1264,8 +1264,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optflagopt() {\n-        let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n-                                       ~\"some pineapples\", ~\"VAL\");\n+        let opt = groups::optflagopt(\"p\", \"pineapple\", \"some pineapples\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"p\",\n                         long_name: ~\"pineapple\",\n                         hint: ~\"VAL\",\n@@ -1276,8 +1275,7 @@ mod tests {\n \n     #[test]\n     fn test_groups_optmulti() {\n-        let opt = groups::optmulti(~\"l\", ~\"lime\",\n-                                     ~\"some limes\", ~\"VAL\");\n+        let opt = groups::optmulti(\"l\", \"lime\", \"some limes\", \"VAL\");\n         assert!(opt == OptGroup { short_name: ~\"l\",\n                         long_name: ~\"lime\",\n                         hint: ~\"VAL\",\n@@ -1288,29 +1286,28 @@ mod tests {\n \n     #[test]\n     fn test_groups_long_to_short() {\n-        let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n-        let verbose = groups::reqopt(~\"b\", ~\"banana\",\n-                                       ~\"some bananas\", ~\"VAL\");\n+        let short = ~[reqopt(\"b\"), reqopt(\"banana\")];\n+        let verbose = groups::reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n \n         assert_eq!(groups::long_to_short(&verbose), short);\n     }\n \n     #[test]\n     fn test_groups_getopts() {\n         let short = ~[\n-            reqopt(~\"b\"), reqopt(~\"banana\"),\n-            optopt(~\"a\"), optopt(~\"apple\"),\n-            optflag(~\"k\"), optflagopt(~\"kiwi\"),\n-            optflagopt(~\"p\"),\n-            optmulti(~\"l\")\n+            reqopt(\"b\"), reqopt(\"banana\"),\n+            optopt(\"a\"), optopt(\"apple\"),\n+            optflag(\"k\"), optflagopt(\"kiwi\"),\n+            optflagopt(\"p\"),\n+            optmulti(\"l\")\n         ];\n \n         let verbose = ~[\n-            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n-            groups::optopt(~\"a\", ~\"apple\", ~\"Desc\", ~\"VAL\"),\n-            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n-            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n-            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            groups::optopt(\"a\", \"apple\", \"Desc\", \"VAL\"),\n+            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n+            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let sample_args = ~[~\"-k\", ~\"15\", ~\"--apple\", ~\"1\", ~\"k\",\n@@ -1324,12 +1321,12 @@ mod tests {\n     #[test]\n     fn test_groups_usage() {\n         let optgroups = ~[\n-            groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n-            groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n-                             ~\"Desc\", ~\"VAL\"),\n-            groups::optflag(~\"k\", ~\"kiwi\", ~\"Desc\"),\n-            groups::optflagopt(~\"p\", ~\"\", ~\"Desc\", ~\"VAL\"),\n-            groups::optmulti(~\"l\", ~\"\", ~\"Desc\", ~\"VAL\"),\n+            groups::reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n+            groups::optopt(\"a\", \"012345678901234567890123456789\",\n+                             \"Desc\", \"VAL\"),\n+            groups::optflag(\"k\", \"kiwi\", \"Desc\"),\n+            groups::optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n+            groups::optmulti(\"l\", \"\", \"Desc\", \"VAL\"),\n         ];\n \n         let expected =\n@@ -1345,7 +1342,7 @@ Options:\n \n \";\n \n-        let generated_usage = groups::usage(~\"Usage: fruits\", optgroups);\n+        let generated_usage = groups::usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", generated_usage);\n@@ -1358,10 +1355,10 @@ Options:\n         // lines wrap after 78: or rather descriptions wrap after 54\n \n         let optgroups = ~[\n-           groups::optflag(~\"k\", ~\"kiwi\",\n-           ~\"This is a long description which won't be wrapped..+..\"), // 54\n-           groups::optflag(~\"a\", ~\"apple\",\n-           ~\"This is a long description which _will_ be wrapped..+..\"), // 55\n+            groups::optflag(\"k\", \"kiwi\",\n+                \"This is a long description which won't be wrapped..+..\"), // 54\n+            groups::optflag(\"a\", \"apple\",\n+                \"This is a long description which _will_ be wrapped..+..\"), // 55\n         ];\n \n         let expected =\n@@ -1374,7 +1371,7 @@ Options:\n \n \";\n \n-        let usage = groups::usage(~\"Usage: fruits\", optgroups);\n+        let usage = groups::usage(\"Usage: fruits\", optgroups);\n \n         debug!(\"expected: <<%s>>\", expected);\n         debug!(\"generated: <<%s>>\", usage);"}, {"sha": "5ef0500d53ad54ec937039215a65ba56355ec674", "filename": "src/libextra/json.rs", "status": "modified", "additions": 124, "deletions": 124, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -1444,26 +1444,26 @@ mod tests {\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(to_str(&mk_object(~[])), ~\"{}\");\n-        assert_eq!(to_pretty_str(&mk_object(~[])), ~\"{}\");\n+        assert_eq!(to_str(&mk_object([])), ~\"{}\");\n+        assert_eq!(to_pretty_str(&mk_object([])), ~\"{}\");\n \n         assert_eq!(\n-            to_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            to_str(&mk_object([(~\"a\", Boolean(true))])),\n             ~\"{\\\"a\\\":true}\"\n         );\n         assert_eq!(\n-            to_pretty_str(&mk_object(~[(~\"a\", Boolean(true))])),\n+            to_pretty_str(&mk_object([(~\"a\", Boolean(true))])),\n             ~\"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\"\n         );\n \n         assert_eq!(\n-            to_str(&mk_object(~[\n+            to_str(&mk_object([\n                 (~\"b\", List(~[\n-                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object(~[(~\"d\", String(~\"\"))])\n+                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object([(~\"d\", String(~\"\"))])\n                 ]))\n             ])),\n             ~\"{\\\n@@ -1474,10 +1474,10 @@ mod tests {\n             }\"\n         );\n         assert_eq!(\n-            to_pretty_str(&mk_object(~[\n+            to_pretty_str(&mk_object([\n                 (~\"b\", List(~[\n-                    mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                    mk_object(~[(~\"d\", String(~\"\"))])\n+                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object([(~\"d\", String(~\"\"))])\n                 ]))\n             ])),\n             ~\"\\\n@@ -1493,11 +1493,11 @@ mod tests {\n             }\"\n         );\n \n-        let a = mk_object(~[\n+        let a = mk_object([\n             (~\"a\", Boolean(true)),\n             (~\"b\", List(~[\n-                mk_object(~[(~\"c\", String(~\"\\x0c\\r\"))]),\n-                mk_object(~[(~\"d\", String(~\"\"))])\n+                mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object([(~\"d\", String(~\"\"))])\n             ]))\n         ]);\n \n@@ -1582,299 +1582,299 @@ mod tests {\n \n     #[test]\n     fn test_trailing_characters() {\n-        assert_eq!(from_str(~\"nulla\"),\n+        assert_eq!(from_str(\"nulla\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"truea\"),\n+        assert_eq!(from_str(\"truea\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"falsea\"),\n+        assert_eq!(from_str(\"falsea\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"1a\"),\n+        assert_eq!(from_str(\"1a\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"[]a\"),\n+        assert_eq!(from_str(\"[]a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n-        assert_eq!(from_str(~\"{}a\"),\n+        assert_eq!(from_str(\"{}a\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"trailing characters\"}));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n-        assert_eq!(from_str(~\"n\"),\n+        assert_eq!(from_str(\"n\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"nul\"),\n+        assert_eq!(from_str(\"nul\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"t\"),\n+        assert_eq!(from_str(\"t\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"truz\"),\n+        assert_eq!(from_str(\"truz\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"f\"),\n+        assert_eq!(from_str(\"f\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"faz\"),\n+        assert_eq!(from_str(\"faz\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"null\"), Ok(Null));\n-        assert_eq!(from_str(~\"true\"), Ok(Boolean(true)));\n-        assert_eq!(from_str(~\"false\"), Ok(Boolean(false)));\n-        assert_eq!(from_str(~\" null \"), Ok(Null));\n-        assert_eq!(from_str(~\" true \"), Ok(Boolean(true)));\n-        assert_eq!(from_str(~\" false \"), Ok(Boolean(false)));\n+        assert_eq!(from_str(\"null\"), Ok(Null));\n+        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n+        assert_eq!(from_str(\" null \"), Ok(Null));\n+        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n     }\n \n     #[test]\n     fn test_decode_identifiers() {\n-        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let mut decoder = Decoder(from_str(\"null\").unwrap());\n         let v: () = Decodable::decode(&mut decoder);\n         assert_eq!(v, ());\n \n-        let mut decoder = Decoder(from_str(~\"true\").unwrap());\n+        let mut decoder = Decoder(from_str(\"true\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, true);\n \n-        let mut decoder = Decoder(from_str(~\"false\").unwrap());\n+        let mut decoder = Decoder(from_str(\"false\").unwrap());\n         let v: bool = Decodable::decode(&mut decoder);\n         assert_eq!(v, false);\n     }\n \n     #[test]\n     fn test_read_number() {\n-        assert_eq!(from_str(~\"+\"),\n+        assert_eq!(from_str(\"+\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\".\"),\n+        assert_eq!(from_str(\".\"),\n             Err(Error {line: 1u, col: 1u, msg: @~\"invalid syntax\"}));\n \n-        assert_eq!(from_str(~\"-\"),\n+        assert_eq!(from_str(\"-\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"00\"),\n+        assert_eq!(from_str(\"00\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1.\"),\n+        assert_eq!(from_str(\"1.\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1e\"),\n+        assert_eq!(from_str(\"1e\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"invalid number\"}));\n-        assert_eq!(from_str(~\"1e+\"),\n+        assert_eq!(from_str(\"1e+\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid number\"}));\n \n-        assert_eq!(from_str(~\"3\"), Ok(Number(3f)));\n-        assert_eq!(from_str(~\"3.1\"), Ok(Number(3.1f)));\n-        assert_eq!(from_str(~\"-1.2\"), Ok(Number(-1.2f)));\n-        assert_eq!(from_str(~\"0.4\"), Ok(Number(0.4f)));\n-        assert_eq!(from_str(~\"0.4e5\"), Ok(Number(0.4e5f)));\n-        assert_eq!(from_str(~\"0.4e+15\"), Ok(Number(0.4e15f)));\n-        assert_eq!(from_str(~\"0.4e-01\"), Ok(Number(0.4e-01f)));\n-        assert_eq!(from_str(~\" 3 \"), Ok(Number(3f)));\n+        assert_eq!(from_str(\"3\"), Ok(Number(3f)));\n+        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1f)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2f)));\n+        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4f)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5f)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15f)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01f)));\n+        assert_eq!(from_str(\" 3 \"), Ok(Number(3f)));\n     }\n \n     #[test]\n     fn test_decode_numbers() {\n-        let mut decoder = Decoder(from_str(~\"3\").unwrap());\n+        let mut decoder = Decoder(from_str(\"3\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3f);\n \n-        let mut decoder = Decoder(from_str(~\"3.1\").unwrap());\n+        let mut decoder = Decoder(from_str(\"3.1\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 3.1f);\n \n-        let mut decoder = Decoder(from_str(~\"-1.2\").unwrap());\n+        let mut decoder = Decoder(from_str(\"-1.2\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, -1.2f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e5\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e5\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e5f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e15\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e15\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e15f);\n \n-        let mut decoder = Decoder(from_str(~\"0.4e-01\").unwrap());\n+        let mut decoder = Decoder(from_str(\"0.4e-01\").unwrap());\n         let v: float = Decodable::decode(&mut decoder);\n         assert_eq!(v, 0.4e-01f);\n     }\n \n     #[test]\n     fn test_read_str() {\n-        assert_eq!(from_str(~\"\\\"\"),\n+        assert_eq!(from_str(\"\\\"\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing string\"\n         }));\n-        assert_eq!(from_str(~\"\\\"lol\"),\n+        assert_eq!(from_str(\"\\\"lol\"),\n             Err(Error {line: 1u, col: 5u, msg: @~\"EOF while parsing string\"\n         }));\n \n-        assert_eq!(from_str(~\"\\\"\\\"\"), Ok(String(~\"\")));\n-        assert_eq!(from_str(~\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(~\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n-        assert_eq!(from_str(~\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n-        assert_eq!(from_str(~\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n-        assert_eq!(from_str(~\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n-        assert_eq!(from_str(~\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n-        assert_eq!(from_str(~\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n-        assert_eq!(from_str(~\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n-        assert_eq!(from_str(~\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n     }\n \n     #[test]\n     fn test_decode_str() {\n-        let mut decoder = Decoder(from_str(~\"\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"foo\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"foo\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"foo\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\\"\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\b\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\b\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\x08\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\n\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\n\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\n\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\r\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\r\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\r\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\t\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\t\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\t\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\u12ab\");\n \n-        let mut decoder = Decoder(from_str(~\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n         let v: ~str = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n     #[test]\n     fn test_read_list() {\n-        assert_eq!(from_str(~\"[\"),\n+        assert_eq!(from_str(\"[\"),\n             Err(Error {line: 1u, col: 2u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"[1\"),\n+        assert_eq!(from_str(\"[1\"),\n             Err(Error {line: 1u, col: 3u, msg: @~\"EOF while parsing list\"}));\n-        assert_eq!(from_str(~\"[1,\"),\n+        assert_eq!(from_str(\"[1,\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"[1,]\"),\n+        assert_eq!(from_str(\"[1,]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"invalid syntax\"}));\n-        assert_eq!(from_str(~\"[6 7]\"),\n+        assert_eq!(from_str(\"[6 7]\"),\n             Err(Error {line: 1u, col: 4u, msg: @~\"expected `,` or `]`\"}));\n \n-        assert_eq!(from_str(~\"[]\"), Ok(List(~[])));\n-        assert_eq!(from_str(~\"[ ]\"), Ok(List(~[])));\n-        assert_eq!(from_str(~\"[true]\"), Ok(List(~[Boolean(true)])));\n-        assert_eq!(from_str(~\"[ false ]\"), Ok(List(~[Boolean(false)])));\n-        assert_eq!(from_str(~\"[null]\"), Ok(List(~[Null])));\n-        assert_eq!(from_str(~\"[3, 1]\"),\n+        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(\"[3, 1]\"),\n                      Ok(List(~[Number(3f), Number(1f)])));\n-        assert_eq!(from_str(~\"\\n[3, 2]\\n\"),\n+        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n                      Ok(List(~[Number(3f), Number(2f)])));\n-        assert_eq!(from_str(~\"[2, [4, 1]]\"),\n+        assert_eq!(from_str(\"[2, [4, 1]]\"),\n                Ok(List(~[Number(2f), List(~[Number(4f), Number(1f)])])));\n     }\n \n     #[test]\n     fn test_decode_list() {\n-        let mut decoder = Decoder(from_str(~\"[]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[]);\n \n-        let mut decoder = Decoder(from_str(~\"[null]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[null]\").unwrap());\n         let v: ~[()] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[()]);\n \n-        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(~\"[true]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[true]\").unwrap());\n         let v: ~[bool] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[true]);\n \n-        let mut decoder = Decoder(from_str(~\"[3, 1]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[3, 1]\").unwrap());\n         let v: ~[int] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[3, 1]);\n \n-        let mut decoder = Decoder(from_str(~\"[[3], [1, 2]]\").unwrap());\n+        let mut decoder = Decoder(from_str(\"[[3], [1, 2]]\").unwrap());\n         let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n \n     #[test]\n     fn test_read_object() {\n-        assert_eq!(from_str(~\"{\"),\n+        assert_eq!(from_str(\"{\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{ \"),\n+        assert_eq!(from_str(\"{ \"),\n             Err(Error {\n                 line: 1u,\n                 col: 3u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{1\"),\n+        assert_eq!(from_str(\"{1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 2u,\n                 msg: @~\"key must be a string\"}));\n-        assert_eq!(from_str(~\"{ \\\"a\\\"\"),\n+        assert_eq!(from_str(\"{ \\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\"\"),\n+        assert_eq!(from_str(\"{\\\"a\\\"\"),\n             Err(Error {\n                 line: 1u,\n                 col: 5u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\" \"),\n+        assert_eq!(from_str(\"{\\\"a\\\" \"),\n             Err(Error {\n                 line: 1u,\n                 col: 6u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        assert_eq!(from_str(~\"{\\\"a\\\" 1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"expected `:`\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":\"),\n             Err(Error {line: 1u, col: 6u, msg: @~\"EOF while parsing value\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1\"),\n             Err(Error {\n                 line: 1u,\n                 col: 7u,\n                 msg: @~\"EOF while parsing object\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1 1\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n             Err(Error {line: 1u, col: 8u, msg: @~\"expected `,` or `}`\"}));\n-        assert_eq!(from_str(~\"{\\\"a\\\":1,\"),\n+        assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n             Err(Error {\n                 line: 1u,\n                 col: 8u,\n                 msg: @~\"EOF while parsing object\"}));\n \n-        assert_eq!(result::unwrap(from_str(~\"{}\")), mk_object(~[]));\n-        assert_eq!(result::unwrap(from_str(~\"{\\\"a\\\": 3}\")),\n-                  mk_object(~[(~\"a\", Number(3.0f))]));\n+        assert_eq!(result::unwrap(from_str(\"{}\")), mk_object([]));\n+        assert_eq!(result::unwrap(from_str(\"{\\\"a\\\": 3}\")),\n+                  mk_object([(~\"a\", Number(3.0f))]));\n \n         assert_eq!(result::unwrap(from_str(\n-                ~\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n-                  mk_object(~[\n+                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n+                  mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n         assert_eq!(result::unwrap(\n-                      from_str(~\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n-                  mk_object(~[\n+                      from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n+                  mk_object([\n                       (~\"a\", Null),\n                       (~\"b\", Boolean(true))]));\n         assert_eq!(result::unwrap(from_str(\n-                ~\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n-                  mk_object(~[\n+                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n+                  mk_object([\n                       (~\"a\", Number(1.0)),\n                       (~\"b\", List(~[Boolean(true)]))\n                   ]));\n@@ -1887,13 +1887,13 @@ mod tests {\n                               ~\"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n                           ~\"]\" +\n                       ~\"}\")),\n-                  mk_object(~[\n+                  mk_object([\n                       (~\"a\", Number(1.0f)),\n                       (~\"b\", List(~[\n                           Boolean(true),\n                           String(~\"foo\\nbar\"),\n-                          mk_object(~[\n-                              (~\"c\", mk_object(~[(~\"d\", Null)]))\n+                          mk_object([\n+                              (~\"c\", mk_object([(~\"d\", Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -1920,23 +1920,23 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let mut decoder = Decoder(from_str(~\"null\").unwrap());\n+        let mut decoder = Decoder(from_str(\"null\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, None);\n \n-        let mut decoder = Decoder(from_str(~\"\\\"jodhpurs\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n         let value: Option<~str> = Decodable::decode(&mut decoder);\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n-        let mut decoder = Decoder(from_str(~\"\\\"Dog\\\"\").unwrap());\n+        let mut decoder = Decoder(from_str(\"\\\"Dog\\\"\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Dog);\n \n         let mut decoder =\n-            Decoder(from_str(~\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n+            Decoder(from_str(\"[\\\"Frog\\\",\\\"Henry\\\",349]\").unwrap());\n         let value: Animal = Decodable::decode(&mut decoder);\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n@@ -1953,7 +1953,7 @@ mod tests {\n \n     #[test]\n     fn test_multiline_errors() {\n-        assert_eq!(from_str(~\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n+        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n             Err(Error {\n                 line: 3u,\n                 col: 8u,"}, {"sha": "0cde57d5ad762aa6bc46d60170e46115e3a87e98", "filename": "src/libextra/list.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -184,9 +184,9 @@ mod tests {\n \n     #[test]\n     fn test_is_empty() {\n-        let empty : @list::List<int> = from_vec(~[]);\n-        let full1 = from_vec(~[1]);\n-        let full2 = from_vec(~['r', 'u']);\n+        let empty : @list::List<int> = from_vec([]);\n+        let full1 = from_vec([1]);\n+        let full2 = from_vec(['r', 'u']);\n \n         assert!(is_empty(empty));\n         assert!(!is_empty(full1));\n@@ -195,7 +195,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n \n         assert_eq!(head(l), 0);\n \n@@ -208,14 +208,14 @@ mod tests {\n \n     #[test]\n     fn test_from_vec_empty() {\n-        let empty : @list::List<int> = from_vec(~[]);\n+        let empty : @list::List<int> = from_vec([]);\n         assert_eq!(empty, @list::Nil::<int>);\n     }\n \n     #[test]\n     fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n-        let l = from_vec(~[0, 1, 2, 3, 4]);\n+        let l = from_vec([0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::foldl(0u, l, add), 10u);\n         assert_eq!(list::foldl(0u, empty, add), 0u);\n@@ -226,29 +226,29 @@ mod tests {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n-        let l = from_vec(~[1, 2, 3, 4]);\n+        let l = from_vec([1, 2, 3, 4]);\n         assert_eq!(list::foldl(0, l, sub), -10);\n     }\n \n     #[test]\n     fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         assert_eq!(list::find(l, match_), option::Some(2));\n     }\n \n     #[test]\n     fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::find(l, match_), option::None::<int>);\n         assert_eq!(list::find(empty, match_), option::None::<int>);\n     }\n \n     #[test]\n     fn test_has() {\n-        let l = from_vec(~[5, 8, 6]);\n+        let l = from_vec([5, 8, 6]);\n         let empty = @list::Nil::<int>;\n         assert!((list::has(l, 5)));\n         assert!((!list::has(l, 7)));\n@@ -258,15 +258,15 @@ mod tests {\n \n     #[test]\n     fn test_len() {\n-        let l = from_vec(~[0, 1, 2]);\n+        let l = from_vec([0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert_eq!(list::len(l), 3u);\n         assert_eq!(list::len(empty), 0u);\n     }\n \n     #[test]\n     fn test_append() {\n-        assert!(from_vec(~[1,2,3,4])\n-            == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4])));\n+        assert!(from_vec([1,2,3,4])\n+            == list::append(list::from_vec([1,2]), list::from_vec([3,4])));\n     }\n }"}, {"sha": "449774e4cbc16f00cfa79326975bb9f5f5300f01", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -127,17 +127,17 @@ pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {\n-    assert_eq!(md4_text(~\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    assert_eq!(md4_text(~\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    assert_eq!(md4_text(~\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n-    assert!(md4_text(~\"message digest\") ==\n+    assert_eq!(md4_text(\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n+    assert_eq!(md4_text(\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n+    assert_eq!(md4_text(\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n+    assert!(md4_text(\"message digest\") ==\n         ~\"d9130a8164549fe818874806e1c7014b\");\n-    assert!(md4_text(~\"abcdefghijklmnopqrstuvwxyz\") ==\n+    assert!(md4_text(\"abcdefghijklmnopqrstuvwxyz\") ==\n         ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n     assert!(md4_text(\n-        ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n+        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n         0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n-    assert!(md4_text(~\"1234567890123456789012345678901234567890123456789\\\n+    assert!(md4_text(\"1234567890123456789012345678901234567890123456789\\\n                      0123456789012345678901234567890\") ==\n         ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n }"}, {"sha": "70a8c3fb0cb8a1bcb0419bfa728e018557f67477", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -393,7 +393,7 @@ mod test {\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n-        match v4::try_parse_addr(~\"b4df00d\") {\n+        match v4::try_parse_addr(\"b4df00d\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n             assert!(true);\n@@ -406,7 +406,7 @@ mod test {\n     #[test]\n     #[ignore(target_os=\"win32\")]\n     fn test_ip_ipv6_bad_parse() {\n-        match v6::try_parse_addr(~\"::,~2234k;\") {\n+        match v6::try_parse_addr(\"::,~2234k;\") {\n           result::Err(ref err_info) => {\n             debug!(\"got error as expected %?\", err_info);\n             assert!(true);"}, {"sha": "ae1707c9922b81dcc460fc7065d1ef880852680c", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -1630,7 +1630,7 @@ mod test {\n         assert_eq!(net::ip::get_port(&sock.get_peer_addr()), 8887);\n \n         // Fulfill the protocol the test server expects\n-        let resp_bytes = str::to_bytes(~\"ping\");\n+        let resp_bytes = str::to_bytes(\"ping\");\n         tcp_write_single(&sock, resp_bytes);\n         debug!(\"message sent\");\n         sock.read(0u);"}, {"sha": "3b7c808c596eadb43a5c50713024791543f548c0", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -716,11 +716,11 @@ impl IterBytes for Url {\n \n #[test]\n fn test_split_char_first() {\n-    let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n+    let (u,v) = split_char_first(\"hello, sweet world\", ',');\n     assert_eq!(u, ~\"hello\");\n     assert_eq!(v, ~\" sweet world\");\n \n-    let (u,v) = split_char_first(~\"hello sweet world\", ',');\n+    let (u,v) = split_char_first(\"hello sweet world\", ',');\n     assert_eq!(u, ~\"hello sweet world\");\n     assert_eq!(v, ~\"\");\n }\n@@ -774,9 +774,9 @@ fn test_get_authority() {\n         \"//2001:0db8:85a3:0042:0000:8a2e:0370:7334:8000:00\").is_err());\n \n     // these parse as empty, because they don't start with '//'\n-    let (_, h, _, _) = get_authority(~\"user:pass@rust-lang\").unwrap();\n+    let (_, h, _, _) = get_authority(\"user:pass@rust-lang\").unwrap();\n     assert_eq!(h, ~\"\");\n-    let (_, h, _, _) = get_authority(~\"rust-lang.org\").unwrap();\n+    let (_, h, _, _) = get_authority(\"rust-lang.org\").unwrap();\n     assert_eq!(h, ~\"\");\n }\n \n@@ -788,12 +788,12 @@ fn test_get_path() {\n     let (p, r) = get_path(\"test@email.com#fragment\", false).unwrap();\n     assert_eq!(p, ~\"test@email.com\");\n     assert_eq!(r, ~\"#fragment\");\n-    let (p, r) = get_path(~\"/gen/:addr=?q=v\", false).unwrap();\n+    let (p, r) = get_path(\"/gen/:addr=?q=v\", false).unwrap();\n     assert_eq!(p, ~\"/gen/:addr=\");\n     assert_eq!(r, ~\"?q=v\");\n \n     //failure cases\n-    assert!(get_path(~\"something?q\", true).is_err());\n+    assert!(get_path(\"something?q\", true).is_err());\n }\n \n #[cfg(test)]\n@@ -1058,7 +1058,7 @@ mod tests {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*\n-        assert_eq!(decode_form_urlencoded(~[]).len(), 0);\n+        assert_eq!(decode_form_urlencoded([]).len(), 0);\n \n         let s = str::to_bytes(\"a=1&foo+bar=abc&foo+bar=12+%3D+34\");\n         let form = decode_form_urlencoded(s);"}, {"sha": "7ff8c25d95ff05eb1361cbba153f77929cb398a8", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -1156,12 +1156,12 @@ mod biguint_tests {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n             assert!(data == BigUint::from_slice(slice).data);\n         }\n-        check(~[1], ~[1]);\n-        check(~[0, 0, 0], ~[]);\n-        check(~[1, 2, 0, 0], ~[1, 2]);\n-        check(~[0, 0, 1, 2], ~[0, 0, 1, 2]);\n-        check(~[0, 0, 1, 2, 0, 0], ~[0, 0, 1, 2]);\n-        check(~[-1], ~[-1]);\n+        check([1], [1]);\n+        check([0, 0, 0], []);\n+        check([1, 2, 0, 0], [1, 2]);\n+        check([0, 0, 1, 2], [0, 0, 1, 2]);\n+        check([0, 0, 1, 2, 0, 0], [0, 0, 1, 2]);\n+        check([-1], [-1]);\n     }\n \n     #[test]\n@@ -1579,9 +1579,9 @@ mod biguint_tests {\n             }\n         }\n \n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"Z\", 10), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"_\", 2), None);\n-        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"-1\", 10), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"Z\", 10), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"_\", 2), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(\"-1\", 10), None);\n     }\n \n     #[test]"}, {"sha": "4b84e2aa8c931f42ba157a8adcd234a2fa2525cc", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -14,7 +14,6 @@ use core::prelude::*;\n \n use core::old_iter::BaseIter;\n use core::unstable::intrinsics::{move_val_init, init};\n-use core::unstable::intrinsics::uninit;\n use core::util::{replace, swap};\n \n pub struct PriorityQueue<T> {"}, {"sha": "7b38c031774d1e252e96e2a4129ff938005e83ff", "filename": "src/libextra/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -295,7 +295,7 @@ mod tests {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 {\n-                str::push_str(&mut rs, ~\"aaaaaaaaaa\");\n+                rs.push_str(\"aaaaaaaaaa\");\n                 i += 1;\n             }\n             return rs;"}, {"sha": "c56a02e03800a8a1eed26c37bb681fd9f9d31ce1", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -895,7 +895,7 @@ mod tests {\n     #[test]\n     fn test_merge_sort_mutable() {\n         pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let mut v1 = ~[3, 2, 1];\n+        let v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert_eq!(v2, ~[1, 2, 3]);\n     }"}, {"sha": "a23a547634242742da10dc510975147d42cb4721", "filename": "src/libextra/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -27,7 +27,6 @@ not required in or otherwise suitable for the core library.\n #[crate_type = \"lib\"];\n \n #[deny(non_camel_case_types)];\n-#[allow(unnecessary_allocation)];\n \n #[no_core];\n #[no_std];"}, {"sha": "ba2ee3c352ef5c23a9f2465b9394163f352dc41c", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -394,8 +394,8 @@ fn should_sort_failures_before_printing_them() {\n         print_failures(st);\n     };\n \n-    let apos = str::find_str(s, ~\"a\").get();\n-    let bpos = str::find_str(s, ~\"b\").get();\n+    let apos = str::find_str(s, \"a\").get();\n+    let bpos = str::find_str(s, \"b\").get();\n     assert!(apos < bpos);\n }\n "}, {"sha": "8a0d50ed52c710483cdcaf97d47f736e1208ce0a", "filename": "src/libextra/time.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -899,7 +899,7 @@ mod tests {\n     }\n \n     fn test_at_utc() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -920,7 +920,7 @@ mod tests {\n     }\n \n     fn test_at() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -948,7 +948,7 @@ mod tests {\n     }\n \n     fn test_to_timespec() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -959,7 +959,7 @@ mod tests {\n     }\n \n     fn test_conversions() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -975,10 +975,10 @@ mod tests {\n     }\n \n     fn test_strptime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n-        match strptime(~\"\", ~\"\") {\n+        match strptime(\"\", \"\") {\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 0_i32);\n             assert!(tm.tm_min == 0_i32);\n@@ -995,12 +995,12 @@ mod tests {\n           Err(_) => ()\n         }\n \n-        let format = ~\"%a %b %e %T %Y\";\n-        assert_eq!(strptime(~\"\", format), Err(~\"Invalid time\"));\n-        assert!(strptime(~\"Fri Feb 13 15:31:30\", format)\n+        let format = \"%a %b %e %T %Y\";\n+        assert_eq!(strptime(\"\", format), Err(~\"Invalid time\"));\n+        assert!(strptime(\"Fri Feb 13 15:31:30\", format)\n             == Err(~\"Invalid time\"));\n \n-        match strptime(~\"Fri Feb 13 15:31:30 2009\", format) {\n+        match strptime(\"Fri Feb 13 15:31:30 2009\", format) {\n           Err(copy e) => fail!(e),\n           Ok(ref tm) => {\n             assert!(tm.tm_sec == 30_i32);\n@@ -1034,7 +1034,7 @@ mod tests {\n             ~\"Friday\",\n             ~\"Saturday\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%A\"));\n+            assert!(test(*day, \"%A\"));\n         }\n \n         for [\n@@ -1046,7 +1046,7 @@ mod tests {\n             ~\"Fri\",\n             ~\"Sat\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%a\"));\n+            assert!(test(*day, \"%a\"));\n         }\n \n         for [\n@@ -1063,7 +1063,7 @@ mod tests {\n             ~\"November\",\n             ~\"December\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%B\"));\n+            assert!(test(*day, \"%B\"));\n         }\n \n         for [\n@@ -1080,60 +1080,60 @@ mod tests {\n             ~\"Nov\",\n             ~\"Dec\"\n         ].each |day| {\n-            assert!(test(*day, ~\"%b\"));\n+            assert!(test(*day, \"%b\"));\n         }\n \n-        assert!(test(~\"19\", ~\"%C\"));\n-        assert!(test(~\"Fri Feb 13 23:31:30 2009\", ~\"%c\"));\n-        assert!(test(~\"02/13/09\", ~\"%D\"));\n-        assert!(test(~\"03\", ~\"%d\"));\n-        assert!(test(~\"13\", ~\"%d\"));\n-        assert!(test(~\" 3\", ~\"%e\"));\n-        assert!(test(~\"13\", ~\"%e\"));\n-        assert!(test(~\"2009-02-13\", ~\"%F\"));\n-        assert!(test(~\"03\", ~\"%H\"));\n-        assert!(test(~\"13\", ~\"%H\"));\n-        assert!(test(~\"03\", ~\"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(~\"11\", ~\"%I\")); // FIXME (#2350): flesh out\n-        assert!(test(~\"044\", ~\"%j\"));\n-        assert!(test(~\" 3\", ~\"%k\"));\n-        assert!(test(~\"13\", ~\"%k\"));\n-        assert!(test(~\" 1\", ~\"%l\"));\n-        assert!(test(~\"11\", ~\"%l\"));\n-        assert!(test(~\"03\", ~\"%M\"));\n-        assert!(test(~\"13\", ~\"%M\"));\n-        assert!(test(~\"\\n\", ~\"%n\"));\n-        assert!(test(~\"am\", ~\"%P\"));\n-        assert!(test(~\"pm\", ~\"%P\"));\n-        assert!(test(~\"AM\", ~\"%p\"));\n-        assert!(test(~\"PM\", ~\"%p\"));\n-        assert!(test(~\"23:31\", ~\"%R\"));\n-        assert!(test(~\"11:31:30 AM\", ~\"%r\"));\n-        assert!(test(~\"11:31:30 PM\", ~\"%r\"));\n-        assert!(test(~\"03\", ~\"%S\"));\n-        assert!(test(~\"13\", ~\"%S\"));\n-        assert!(test(~\"15:31:30\", ~\"%T\"));\n-        assert!(test(~\"\\t\", ~\"%t\"));\n-        assert!(test(~\"1\", ~\"%u\"));\n-        assert!(test(~\"7\", ~\"%u\"));\n-        assert!(test(~\"13-Feb-2009\", ~\"%v\"));\n-        assert!(test(~\"0\", ~\"%w\"));\n-        assert!(test(~\"6\", ~\"%w\"));\n-        assert!(test(~\"2009\", ~\"%Y\"));\n-        assert!(test(~\"09\", ~\"%y\"));\n-        assert!(result::unwrap(strptime(~\"UTC\", ~\"%Z\")).tm_zone ==\n+        assert!(test(\"19\", \"%C\"));\n+        assert!(test(\"Fri Feb 13 23:31:30 2009\", \"%c\"));\n+        assert!(test(\"02/13/09\", \"%D\"));\n+        assert!(test(\"03\", \"%d\"));\n+        assert!(test(\"13\", \"%d\"));\n+        assert!(test(\" 3\", \"%e\"));\n+        assert!(test(\"13\", \"%e\"));\n+        assert!(test(\"2009-02-13\", \"%F\"));\n+        assert!(test(\"03\", \"%H\"));\n+        assert!(test(\"13\", \"%H\"));\n+        assert!(test(\"03\", \"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(\"11\", \"%I\")); // FIXME (#2350): flesh out\n+        assert!(test(\"044\", \"%j\"));\n+        assert!(test(\" 3\", \"%k\"));\n+        assert!(test(\"13\", \"%k\"));\n+        assert!(test(\" 1\", \"%l\"));\n+        assert!(test(\"11\", \"%l\"));\n+        assert!(test(\"03\", \"%M\"));\n+        assert!(test(\"13\", \"%M\"));\n+        assert!(test(\"\\n\", \"%n\"));\n+        assert!(test(\"am\", \"%P\"));\n+        assert!(test(\"pm\", \"%P\"));\n+        assert!(test(\"AM\", \"%p\"));\n+        assert!(test(\"PM\", \"%p\"));\n+        assert!(test(\"23:31\", \"%R\"));\n+        assert!(test(\"11:31:30 AM\", \"%r\"));\n+        assert!(test(\"11:31:30 PM\", \"%r\"));\n+        assert!(test(\"03\", \"%S\"));\n+        assert!(test(\"13\", \"%S\"));\n+        assert!(test(\"15:31:30\", \"%T\"));\n+        assert!(test(\"\\t\", \"%t\"));\n+        assert!(test(\"1\", \"%u\"));\n+        assert!(test(\"7\", \"%u\"));\n+        assert!(test(\"13-Feb-2009\", \"%v\"));\n+        assert!(test(\"0\", \"%w\"));\n+        assert!(test(\"6\", \"%w\"));\n+        assert!(test(\"2009\", \"%Y\"));\n+        assert!(test(\"09\", \"%y\"));\n+        assert!(result::unwrap(strptime(\"UTC\", \"%Z\")).tm_zone ==\n             ~\"UTC\");\n-        assert!(result::unwrap(strptime(~\"PST\", ~\"%Z\")).tm_zone ==\n+        assert!(result::unwrap(strptime(\"PST\", \"%Z\")).tm_zone ==\n             ~\"\");\n-        assert!(result::unwrap(strptime(~\"-0000\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(\"-0000\", \"%z\")).tm_gmtoff ==\n             0);\n-        assert!(result::unwrap(strptime(~\"-0800\", ~\"%z\")).tm_gmtoff ==\n+        assert!(result::unwrap(strptime(\"-0800\", \"%z\")).tm_gmtoff ==\n             0);\n-        assert!(test(~\"%\", ~\"%%\"));\n+        assert!(test(\"%\", \"%%\"));\n     }\n \n     fn test_ctime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n@@ -1147,60 +1147,60 @@ mod tests {\n     }\n \n     fn test_strftime() {\n-        os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n+        os::setenv(\"TZ\", \"America/Los_Angeles\");\n         tzset();\n \n         let time = ::time::Timespec::new(1234567890, 54321);\n         let utc = at_utc(time);\n         let local = at(time);\n \n-        assert_eq!(local.strftime(~\"\"), ~\"\");\n-        assert_eq!(local.strftime(~\"%A\"), ~\"Friday\");\n-        assert_eq!(local.strftime(~\"%a\"), ~\"Fri\");\n-        assert_eq!(local.strftime(~\"%B\"), ~\"February\");\n-        assert_eq!(local.strftime(~\"%b\"), ~\"Feb\");\n-        assert_eq!(local.strftime(~\"%C\"), ~\"20\");\n-        assert_eq!(local.strftime(~\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n-        assert_eq!(local.strftime(~\"%D\"), ~\"02/13/09\");\n-        assert_eq!(local.strftime(~\"%d\"), ~\"13\");\n-        assert_eq!(local.strftime(~\"%e\"), ~\"13\");\n-        assert_eq!(local.strftime(~\"%F\"), ~\"2009-02-13\");\n+        assert_eq!(local.strftime(\"\"), ~\"\");\n+        assert_eq!(local.strftime(\"%A\"), ~\"Friday\");\n+        assert_eq!(local.strftime(\"%a\"), ~\"Fri\");\n+        assert_eq!(local.strftime(\"%B\"), ~\"February\");\n+        assert_eq!(local.strftime(\"%b\"), ~\"Feb\");\n+        assert_eq!(local.strftime(\"%C\"), ~\"20\");\n+        assert_eq!(local.strftime(\"%c\"), ~\"Fri Feb 13 15:31:30 2009\");\n+        assert_eq!(local.strftime(\"%D\"), ~\"02/13/09\");\n+        assert_eq!(local.strftime(\"%d\"), ~\"13\");\n+        assert_eq!(local.strftime(\"%e\"), ~\"13\");\n+        assert_eq!(local.strftime(\"%F\"), ~\"2009-02-13\");\n         // assert!(local.strftime(\"%G\") == \"2009\");\n         // assert!(local.strftime(\"%g\") == \"09\");\n-        assert_eq!(local.strftime(~\"%H\"), ~\"15\");\n-        assert_eq!(local.strftime(~\"%I\"), ~\"03\");\n-        assert_eq!(local.strftime(~\"%j\"), ~\"044\");\n-        assert_eq!(local.strftime(~\"%k\"), ~\"15\");\n-        assert_eq!(local.strftime(~\"%l\"), ~\" 3\");\n-        assert_eq!(local.strftime(~\"%M\"), ~\"31\");\n-        assert_eq!(local.strftime(~\"%m\"), ~\"02\");\n-        assert_eq!(local.strftime(~\"%n\"), ~\"\\n\");\n-        assert_eq!(local.strftime(~\"%P\"), ~\"pm\");\n-        assert_eq!(local.strftime(~\"%p\"), ~\"PM\");\n-        assert_eq!(local.strftime(~\"%R\"), ~\"15:31\");\n-        assert_eq!(local.strftime(~\"%r\"), ~\"03:31:30 PM\");\n-        assert_eq!(local.strftime(~\"%S\"), ~\"30\");\n-        assert_eq!(local.strftime(~\"%s\"), ~\"1234567890\");\n-        assert_eq!(local.strftime(~\"%T\"), ~\"15:31:30\");\n-        assert_eq!(local.strftime(~\"%t\"), ~\"\\t\");\n+        assert_eq!(local.strftime(\"%H\"), ~\"15\");\n+        assert_eq!(local.strftime(\"%I\"), ~\"03\");\n+        assert_eq!(local.strftime(\"%j\"), ~\"044\");\n+        assert_eq!(local.strftime(\"%k\"), ~\"15\");\n+        assert_eq!(local.strftime(\"%l\"), ~\" 3\");\n+        assert_eq!(local.strftime(\"%M\"), ~\"31\");\n+        assert_eq!(local.strftime(\"%m\"), ~\"02\");\n+        assert_eq!(local.strftime(\"%n\"), ~\"\\n\");\n+        assert_eq!(local.strftime(\"%P\"), ~\"pm\");\n+        assert_eq!(local.strftime(\"%p\"), ~\"PM\");\n+        assert_eq!(local.strftime(\"%R\"), ~\"15:31\");\n+        assert_eq!(local.strftime(\"%r\"), ~\"03:31:30 PM\");\n+        assert_eq!(local.strftime(\"%S\"), ~\"30\");\n+        assert_eq!(local.strftime(\"%s\"), ~\"1234567890\");\n+        assert_eq!(local.strftime(\"%T\"), ~\"15:31:30\");\n+        assert_eq!(local.strftime(\"%t\"), ~\"\\t\");\n         // assert!(local.strftime(\"%U\") == \"06\");\n-        assert_eq!(local.strftime(~\"%u\"), ~\"5\");\n+        assert_eq!(local.strftime(\"%u\"), ~\"5\");\n         // assert!(local.strftime(\"%V\") == \"07\");\n-        assert_eq!(local.strftime(~\"%v\"), ~\"13-Feb-2009\");\n+        assert_eq!(local.strftime(\"%v\"), ~\"13-Feb-2009\");\n         // assert!(local.strftime(\"%W\") == \"06\");\n-        assert_eq!(local.strftime(~\"%w\"), ~\"5\");\n+        assert_eq!(local.strftime(\"%w\"), ~\"5\");\n         // handle \"%X\"\n         // handle \"%x\"\n-        assert_eq!(local.strftime(~\"%Y\"), ~\"2009\");\n-        assert_eq!(local.strftime(~\"%y\"), ~\"09\");\n+        assert_eq!(local.strftime(\"%Y\"), ~\"2009\");\n+        assert_eq!(local.strftime(\"%y\"), ~\"09\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation.\n-        let zone = local.strftime(~\"%Z\");\n+        let zone = local.strftime(\"%Z\");\n         assert!(zone == ~\"PST\" || zone == ~\"Pacific Standard Time\");\n \n-        assert_eq!(local.strftime(~\"%z\"), ~\"-0800\");\n-        assert_eq!(local.strftime(~\"%%\"), ~\"%\");\n+        assert_eq!(local.strftime(\"%z\"), ~\"-0800\");\n+        assert_eq!(local.strftime(\"%%\"), ~\"%\");\n \n         // FIXME (#2350): We should probably standardize on the timezone\n         // abbreviation."}, {"sha": "5551431b551fc0aa098decc50e93a38e8bbfd4ec", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609a9e69e1c1def4d570cfb3c31640200ef738c9/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=609a9e69e1c1def4d570cfb3c31640200ef738c9", "patch": "@@ -759,10 +759,10 @@ mod test_treemap {\n     fn u8_map() {\n         let mut m = TreeMap::new();\n \n-        let k1 = str::to_bytes(~\"foo\");\n-        let k2 = str::to_bytes(~\"bar\");\n-        let v1 = str::to_bytes(~\"baz\");\n-        let v2 = str::to_bytes(~\"foobar\");\n+        let k1 = str::to_bytes(\"foo\");\n+        let k2 = str::to_bytes(\"bar\");\n+        let v1 = str::to_bytes(\"baz\");\n+        let v2 = str::to_bytes(\"foobar\");\n \n         m.insert(copy k1, copy v1);\n         m.insert(copy k2, copy v2);"}]}