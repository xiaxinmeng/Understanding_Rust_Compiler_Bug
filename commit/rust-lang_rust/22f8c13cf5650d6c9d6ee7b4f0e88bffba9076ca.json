{"sha": "22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjhjMTNjZjU2NTBkNmM5ZDZlZTdiNGYwZTg4YmZmYmE5MDc2Y2E=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-02T02:46:10Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-22T13:13:06Z"}, "message": "Improve `implicit_return`\nBetter suggestions when returning macro calls.\nSuggest changeing all the break expressions in a loop, not just the final statement.\nDon't lint divergent functions.\nDon't suggest returning the result of any divergent fuction.", "tree": {"sha": "3169d2f267e7f8ec44edb317934ebd2dbb3bae97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3169d2f267e7f8ec44edb317934ebd2dbb3bae97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmCBdmoACgkQ2lnoZDo37QZWoQD/YVM2iTenbV5gpWt5LTiud62N\npMk88c+EGtepzSuGGqoBAK/NTpwUfoRQL3FXOdlMbXd1styZXRn15hgEjTV3gxsF\n=X80A\n-----END PGP SIGNATURE-----", "payload": "tree 3169d2f267e7f8ec44edb317934ebd2dbb3bae97\nparent 98e2b9f25b6db4b2680a3d388456d9f95cb28344\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617331570 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1619097186 -0400\n\nImprove `implicit_return`\nBetter suggestions when returning macro calls.\nSuggest changeing all the break expressions in a loop, not just the final statement.\nDon't lint divergent functions.\nDon't suggest returning the result of any divergent fuction.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "html_url": "https://github.com/rust-lang/rust/commit/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98e2b9f25b6db4b2680a3d388456d9f95cb28344", "url": "https://api.github.com/repos/rust-lang/rust/commits/98e2b9f25b6db4b2680a3d388456d9f95cb28344", "html_url": "https://github.com/rust-lang/rust/commit/98e2b9f25b6db4b2680a3d388456d9f95cb28344"}], "stats": {"total": 506, "additions": 366, "deletions": 140}, "files": [{"sha": "251a73618716fc304fddbce060277ecf828d0975", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 159, "deletions": 82, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -1,13 +1,15 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::match_panic_def_id;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n+    visitors::visit_break_exprs,\n+};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::{Span, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for missing return statements at the end of a block.\n@@ -39,109 +41,184 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n-static LINT_RETURN: &str = \"add `return` as shown\";\n-\n-fn lint(cx: &LateContext<'_>, outer_span: Span, inner_span: Span, msg: &str) {\n-    let outer_span = outer_span.source_callsite();\n-    let inner_span = inner_span.source_callsite();\n-\n-    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing `return` statement\", |diag| {\n-        if let Some(snippet) = snippet_opt(cx, inner_span) {\n-            diag.span_suggestion(\n-                outer_span,\n-                msg,\n-                format!(\"return {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n+fn lint_return(cx: &LateContext<'_>, span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_applicability(cx, span, \"..\", &mut app);\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        span,\n+        \"missing `return` statement\",\n+        \"add `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    );\n+}\n+\n+fn lint_break(cx: &LateContext<'_>, break_span: Span, expr_span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_context(cx, expr_span, break_span.ctxt(), \"..\", &mut app).0;\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        break_span,\n+        \"missing `return` statement\",\n+        \"change `break` to `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    )\n+}\n+\n+enum LintLocation {\n+    /// The lint was applied to a parent expression.\n+    Parent,\n+    /// The lint was applied to this expression, a child, or not applied.\n+    Inner,\n }\n+impl LintLocation {\n+    fn still_parent(self, b: bool) -> Self {\n+        if b { self } else { Self::Inner }\n+    }\n \n-fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    fn is_parent(&self) -> bool {\n+        matches!(*self, Self::Parent)\n+    }\n+}\n+\n+// Gets the call site if the span is in a child context. Otherwise returns `None`.\n+fn get_call_site(span: Span, ctxt: SyntaxContext) -> Option<Span> {\n+    (span.ctxt() != ctxt).then(|| walk_span_to_context(span, ctxt).unwrap_or(span))\n+}\n+\n+fn lint_implicit_returns(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    // The context of the function body.\n+    ctxt: SyntaxContext,\n+    // Whether the expression is from a macro expansion.\n+    call_site_span: Option<Span>,\n+) -> LintLocation {\n     match expr.kind {\n-        // loops could be using `break` instead of `return`\n-        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n-            if let Some(expr) = &block.expr {\n-                expr_match(cx, expr);\n-            }\n-            // only needed in the case of `break` with `;` at the end\n-            else if let Some(stmt) = block.stmts.last() {\n-                if_chain! {\n-                    if let StmtKind::Semi(expr, ..) = &stmt.kind;\n-                    // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., Some(break_expr)) = &expr.kind;\n-                    then {\n-                            lint(cx, expr.span, break_expr.span, LINT_BREAK);\n-                    }\n-                }\n-            }\n-        },\n-        // use `return` instead of `break`\n-        ExprKind::Break(.., break_expr) => {\n-            if let Some(break_expr) = break_expr {\n-                lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+        ExprKind::Block(\n+            Block {\n+                expr: Some(block_expr), ..\n+            },\n+            _,\n+        ) => lint_implicit_returns(\n+            cx,\n+            block_expr,\n+            ctxt,\n+            call_site_span.or_else(|| get_call_site(block_expr.span, ctxt)),\n+        )\n+        .still_parent(call_site_span.is_some()),\n+\n+        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+            // Both `then_expr` or `else_expr` are required to be blocks in the same context as the `if`. Don't\n+            // bother checking.\n+            let res = lint_implicit_returns(cx, then_expr, ctxt, call_site_span).still_parent(call_site_span.is_some());\n+            if res.is_parent() {\n+                // The return was added as a parent of this if expression.\n+                return res;\n             }\n+            lint_implicit_returns(cx, else_expr, ctxt, call_site_span).still_parent(call_site_span.is_some())\n         },\n-        ExprKind::If(.., if_expr, else_expr) => {\n-            expr_match(cx, if_expr);\n \n-            if let Some(else_expr) = else_expr {\n-                expr_match(cx, else_expr);\n+        ExprKind::Match(_, arms, _) => {\n+            for arm in arms {\n+                let res = lint_implicit_returns(\n+                    cx,\n+                    arm.body,\n+                    ctxt,\n+                    call_site_span.or_else(|| get_call_site(arm.body.span, ctxt)),\n+                )\n+                .still_parent(call_site_span.is_some());\n+                if res.is_parent() {\n+                    // The return was added as a parent of this match expression.\n+                    return res;\n+                }\n             }\n+            LintLocation::Inner\n         },\n-        ExprKind::Match(.., arms, source) => {\n-            let check_all_arms = match source {\n-                MatchSource::IfLetDesugar {\n-                    contains_else_clause: has_else,\n-                } => has_else,\n-                _ => true,\n-            };\n-\n-            if check_all_arms {\n-                for arm in arms {\n-                    expr_match(cx, arm.body);\n+\n+        ExprKind::Loop(block, ..) => {\n+            let mut add_return = false;\n+            visit_break_exprs(block, |break_expr, dest, sub_expr| {\n+                if dest.target_id.ok() == Some(expr.hir_id) {\n+                    if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n+                        lint_break(cx, break_expr.span, sub_expr.unwrap().span);\n+                    } else {\n+                        // the break expression is from a macro call, add a return to the loop\n+                        add_return = true;\n+                    }\n+                }\n+            });\n+            if add_return {\n+                #[allow(clippy::option_if_let_else)]\n+                if let Some(span) = call_site_span {\n+                    lint_return(cx, span);\n+                    LintLocation::Parent\n+                } else {\n+                    lint_return(cx, expr.span);\n+                    LintLocation::Inner\n                 }\n             } else {\n-                expr_match(cx, arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+                LintLocation::Inner\n             }\n         },\n-        // skip if it already has a return statement\n-        ExprKind::Ret(..) => (),\n-        // make sure it's not a call that panics\n-        ExprKind::Call(expr, ..) => {\n-            if_chain! {\n-                if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                if match_panic_def_id(cx, path_def_id);\n-                then { }\n-                else {\n-                    lint(cx, expr.span, expr.span, LINT_RETURN)\n-                }\n+\n+        // If expressions without an else clause, and blocks without a final expression can only be the final expression\n+        // if they are divergent, or return the unit type.\n+        ExprKind::If(_, _, None) | ExprKind::Block(Block { expr: None, .. }, _) | ExprKind::Ret(_) => {\n+            LintLocation::Inner\n+        },\n+\n+        // Any divergent expression doesn't need a return statement.\n+        ExprKind::MethodCall(..)\n+        | ExprKind::Call(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Index(..)\n+            if cx.typeck_results().expr_ty(expr).is_never() =>\n+        {\n+            LintLocation::Inner\n+        },\n+\n+        _ =>\n+        {\n+            #[allow(clippy::option_if_let_else)]\n+            if let Some(span) = call_site_span {\n+                lint_return(cx, span);\n+                LintLocation::Parent\n+            } else {\n+                lint_return(cx, expr.span);\n+                LintLocation::Inner\n             }\n         },\n-        // everything else is missing `return`\n-        _ => lint(cx, expr.span, expr.span, LINT_RETURN),\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        _: &'tcx FnDecl<'_>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         span: Span,\n         _: HirId,\n     ) {\n-        if span.from_expansion() {\n+        if (!matches!(kind, FnKind::Closure) && matches!(decl.output, FnRetTy::DefaultReturn(_)))\n+            || span.ctxt() != body.value.span.ctxt()\n+            || in_external_macro(cx.sess(), span)\n+        {\n             return;\n         }\n-        let body = cx.tcx.hir().body(body.id());\n-        if cx.typeck_results().expr_ty(&body.value).is_unit() {\n+\n+        let res_ty = cx.typeck_results().expr_ty(&body.value);\n+        if res_ty.is_unit() || res_ty.is_never() {\n             return;\n         }\n-        expr_match(cx, &body.value);\n+\n+        lint_implicit_returns(cx, &body.value, body.value.span.ctxt(), None);\n     }\n }"}, {"sha": "2e731c182ece9880305cfc9990f40c55ac5c6b4f", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -280,24 +280,33 @@ pub fn snippet_with_context(\n     default: &'a str,\n     applicability: &mut Applicability,\n ) -> (Cow<'a, str>, bool) {\n-    let outer_span = hygiene::walk_chain(span, outer);\n-    let (span, is_macro_call) = if outer_span.ctxt() == outer {\n-        (outer_span, span.ctxt() != outer)\n-    } else {\n-        // The span is from a macro argument, and the outer context is the macro using the argument\n-        if *applicability != Applicability::Unspecified {\n-            *applicability = Applicability::MaybeIncorrect;\n-        }\n-        // TODO: get the argument span.\n-        (span, false)\n-    };\n+    let (span, is_macro_call) = walk_span_to_context(span, outer).map_or_else(\n+        || {\n+            // The span is from a macro argument, and the outer context is the macro using the argument\n+            if *applicability != Applicability::Unspecified {\n+                *applicability = Applicability::MaybeIncorrect;\n+            }\n+            // TODO: get the argument span.\n+            (span, false)\n+        },\n+        |outer_span| (outer_span, span.ctxt() != outer),\n+    );\n \n     (\n         snippet_with_applicability(cx, span, default, applicability),\n         is_macro_call,\n     )\n }\n \n+/// Walks the span up to the target context, thereby returning the macro call site if the span is\n+/// inside a macro expansion, or the original span if it is not. Note this will return `None` in the\n+/// case of the span being in a macro expansion, but the target context is from expanding a macro\n+/// argument.\n+pub fn walk_span_to_context(span: Span, outer: SyntaxContext) -> Option<Span> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    (outer_span.ctxt() == outer).then(|| outer_span)\n+}\n+\n /// Removes block comments from the given `Vec` of lines.\n ///\n /// # Examples"}, {"sha": "d431bdf34eeeea2c62f0662f8ca562df16e35ac2", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -1,7 +1,7 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Body, Expr, HirId, Stmt};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Block, Body, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -188,3 +188,54 @@ impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n         NestedVisitorMap::OnlyBodies(self.hir)\n     }\n }\n+\n+pub trait Visitable<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V);\n+}\n+impl Visitable<'tcx> for &'tcx Expr<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_expr(self)\n+    }\n+}\n+impl Visitable<'tcx> for &'tcx Block<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_block(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Stmt<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_stmt(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Body<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_body(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_arm(self)\n+    }\n+}\n+\n+pub fn visit_break_exprs<'tcx>(\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n+) {\n+    struct V<F>(F);\n+    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>)> Visitor<'tcx> for V<F> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if let ExprKind::Break(dest, sub_expr) = e.kind {\n+                self.0(e, dest, sub_expr)\n+            }\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    node.visit(&mut V(f));\n+}"}, {"sha": "c0fc4b926a04b4d6931bc5e4ad903c7543f67280", "filename": "tests/ui/implicit_return.fixed", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.fixed?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +12,6 @@ fn test_end_of_fn() -> bool {\n     return true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { return true } else { return false }\n }\n@@ -25,22 +24,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         return true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +45,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +78,48 @@ fn test_return_macro() -> String {\n     return format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    return m!(true, false)\n+}\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            return true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                return false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n }\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    return loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n+}\n+\n+fn main() {}"}, {"sha": "737ffd5ddce1484e71a74963f4de050d18139659", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +12,6 @@ fn test_end_of_fn() -> bool {\n     true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { true } else { false }\n }\n@@ -25,22 +24,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         break true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +45,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +78,48 @@ fn test_return_macro() -> String {\n     format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    m!(true, false)\n }\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            break true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                break 'outer false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n+}\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n+}\n+\n+fn main() {}"}, {"sha": "632e30cbdc6e075c9b350a56762034d8e1871ad3", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 44, "deletions": 11, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=22f8c13cf5650d6c9d6ee7b4f0e88bffba9076ca", "patch": "@@ -7,64 +7,97 @@ LL |     true\n    = note: `-D clippy::implicit-return` implied by `-D warnings`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:17:15\n+  --> $DIR/implicit_return.rs:16:15\n    |\n LL |     if true { true } else { false }\n    |               ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:17:29\n+  --> $DIR/implicit_return.rs:16:29\n    |\n LL |     if true { true } else { false }\n    |                             ^^^^^ help: add `return` as shown: `return false`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:23:17\n+  --> $DIR/implicit_return.rs:22:17\n    |\n LL |         true => false,\n    |                 ^^^^^ help: add `return` as shown: `return false`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:24:20\n+  --> $DIR/implicit_return.rs:23:20\n    |\n LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:39:9\n+  --> $DIR/implicit_return.rs:36:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:47:13\n+  --> $DIR/implicit_return.rs:43:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:56:13\n+  --> $DIR/implicit_return.rs:51:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:74:18\n+  --> $DIR/implicit_return.rs:69:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:75:16\n+  --> $DIR/implicit_return.rs:70:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:83:5\n+  --> $DIR/implicit_return.rs:78:5\n    |\n LL |     format!(\"test {}\", \"test\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`\n \n-error: aborting due to 11 previous errors\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:87:5\n+   |\n+LL |     m!(true, false)\n+   |     ^^^^^^^^^^^^^^^ help: add `return` as shown: `return m!(true, false)`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:93:13\n+   |\n+LL |             break true;\n+   |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:98:17\n+   |\n+LL |                 break 'outer false;\n+   |                 ^^^^^^^^^^^^^^^^^^ help: change `break` to `return` as shown: `return false`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:113:5\n+   |\n+LL | /     loop {\n+LL | |         m!(true);\n+LL | |     }\n+   | |_____^\n+   |\n+help: add `return` as shown\n+   |\n+LL |     return loop {\n+LL |         m!(true);\n+LL |     }\n+   |\n+\n+error: aborting due to 15 previous errors\n "}]}