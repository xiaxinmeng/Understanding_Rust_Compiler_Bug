{"sha": "aa25f22f197682de3b18fc4c8ba068d1feda220f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMjVmMjJmMTk3NjgyZGUzYjE4ZmM0YzhiYTA2OGQxZmVkYTIyMGY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-05-02T18:23:07Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-02T19:16:29Z"}, "message": "Use different syntax for checks that matter to typestate\n\nThis giant commit changes the syntax of Rust to use \"assert\" for\n\"check\" expressions that didn't mean anything to the typestate\nsystem, and continue using \"check\" for checks that are used as\npart of typestate checking.\n\nMost of the changes are just replacing \"check\" with \"assert\" in test\ncases and rustc.", "tree": {"sha": "6d01f8fbb5680964fd9c53564c96aa58cb75d3d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d01f8fbb5680964fd9c53564c96aa58cb75d3d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa25f22f197682de3b18fc4c8ba068d1feda220f", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa25f22f197682de3b18fc4c8ba068d1feda220f", "html_url": "https://github.com/rust-lang/rust/commit/aa25f22f197682de3b18fc4c8ba068d1feda220f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa25f22f197682de3b18fc4c8ba068d1feda220f/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "870435caf55fe167862865bfe4196230ab7c1c6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/870435caf55fe167862865bfe4196230ab7c1c6b", "html_url": "https://github.com/rust-lang/rust/commit/870435caf55fe167862865bfe4196230ab7c1c6b"}], "stats": {"total": 2495, "additions": 1256, "deletions": 1239}, "files": [{"sha": "70e59be303912021ae58760a8eb71aee564a9ce1", "filename": "src/boot/fe/item.ml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -199,6 +199,14 @@ and parse_stmts_including_none (ps:pstate) : Ast.stmt array =\n           bump ps;\n           expect ps SEMI;\n           [| span ps apos (lexpos ps) Ast.STMT_cont |]\n+      | ASSERT ->\n+          bump ps;\n+          let (stmts, expr) =\n+             ctxt \"stmts: check value\" parse_expr ps\n+          in\n+              expect ps SEMI;\n+              spans ps stmts apos (Ast.STMT_check_expr expr)\n+(* leaving check as it is; adding assert as a synonym for the \"old\" check *)\n       | CHECK ->\n           bump ps;\n           begin"}, {"sha": "a65acba1a6f7668d855e0852e4dd77980261f5cd", "filename": "src/boot/fe/lexer.mll", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -92,6 +92,7 @@\n \n                 (\"type\", TYPE);\n                 (\"check\", CHECK);\n+                (\"assert\", ASSERT); \n                 (\"claim\", CLAIM);\n                 (\"prove\", PROVE);\n "}, {"sha": "27cb399b5516d72cfebd99931a89c0aeb0e312b5", "filename": "src/boot/fe/token.ml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -77,6 +77,7 @@ type token =\n   (* Type and type-state keywords *)\n   | TYPE\n   | CHECK\n+  | ASSERT\n   | CLAIM\n   | PROVE\n \n@@ -237,6 +238,7 @@ let rec string_of_tok t =\n     (* Type and type-state keywords *)\n     | TYPE       -> \"type\"\n     | CHECK      -> \"check\"\n+    | ASSERT     -> \"assert\"\n     | CLAIM      -> \"claim\"\n     | PROVE      -> \"prove\"\n "}, {"sha": "13b5739e8dfec4c372ac961e605c46408544ae56", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -283,7 +283,10 @@ tag expr_ {\n     expr_put(option.t[@expr], ann);\n     expr_be(@expr, ann);\n     expr_log(int, @expr, ann);\n-    expr_check_expr(@expr, ann);\n+/* just an assert, no significance to typestate */\n+    expr_assert(@expr, ann);\n+/* preds that typestate is aware of */\n+    expr_check(@expr, ann);\n     expr_port(ann);\n     expr_chan(@expr, ann);\n }"}, {"sha": "c8b31159444f7a1873ab91f317612eb9d225e12e", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -93,7 +93,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('c') { ret ty.mk_char(st.tcx); }\n         case ('s') { ret ty.mk_str(st.tcx); }\n         case ('t') {\n-            check(next(st) as char == '[');\n+            assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n             let vec[ty.t] params = vec();\n             while (peek(st) as char != ']') {\n@@ -108,7 +108,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('P') { ret ty.mk_port(st.tcx, parse_ty(st, sd)); }\n         case ('C') { ret ty.mk_chan(st.tcx, parse_ty(st, sd)); }\n         case ('T') {\n-            check(next(st) as char == '[');\n+            assert (next(st) as char == '[');\n             let vec[ty.mt] params = vec();\n             while (peek(st) as char != ']') {\n                 params += vec(parse_mt(st, sd));\n@@ -117,7 +117,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n             ret ty.mk_tup(st.tcx, params);\n         }\n         case ('R') {\n-            check(next(st) as char == '[');\n+            assert (next(st) as char == '[');\n             let vec[ty.field] fields = vec();\n             while (peek(st) as char != ']') {\n                 auto name = \"\";\n@@ -149,7 +149,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n             ret ty.mk_native_fn(st.tcx,abi,func._0,func._1);\n         }\n         case ('O') {\n-            check(next(st) as char == '[');\n+            assert (next(st) as char == '[');\n             let vec[ty.method] methods = vec();\n             while (peek(st) as char != ']') {\n                 auto proto;\n@@ -175,9 +175,9 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('Y') { ret ty.mk_type(st.tcx); }\n         case ('#') {\n             auto pos = parse_hex(st);\n-            check (next(st) as char == ':');\n+            assert (next(st) as char == ':');\n             auto len = parse_hex(st);\n-            check (next(st) as char == '#');\n+            assert (next(st) as char == '#');\n             alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n                 case (some[ty.t](?tt)) { ret tt; }\n                 case (none[ty.t]) {\n@@ -245,7 +245,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n-    check(next(st) as char == '[');\n+    assert (next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n     while (peek(st) as char != ']') {\n         auto mode = ast.val;"}, {"sha": "dabdee1c7389ab12a2a2a2ffe87a5538f1e1a745", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -127,6 +127,7 @@ fn keyword_table() -> std.map.hashmap[str, token.token] {\n \n     keywords.insert(\"type\", token.TYPE);\n     keywords.insert(\"check\", token.CHECK);\n+    keywords.insert(\"assert\", token.ASSERT);\n     keywords.insert(\"claim\", token.CLAIM);\n     keywords.insert(\"prove\", token.PROVE);\n \n@@ -528,7 +529,7 @@ fn scan_numeric_escape(reader rdr) -> char {\n \n     auto n_hex_digits = 0;\n \n-    check (rdr.curr() == '\\\\');\n+    assert (rdr.curr() == '\\\\');\n \n     alt (rdr.next()) {\n         case ('x') { n_hex_digits = 2; }"}, {"sha": "3e8ca85a830550069ed14a0e3fb2e7b1e7e33ef6", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -621,7 +621,7 @@ fn parse_path(parser p, greed g) -> ast.path {\n                 if (p.peek() == token.DOT) {\n                     if (g == GREEDY) {\n                         p.bump();\n-                        check (is_ident(p.peek()));\n+                        assert (is_ident(p.peek()));\n                     } else {\n                         more = false;\n                     }\n@@ -816,20 +816,23 @@ fn parse_bottom_expr(parser p) -> @ast.expr {\n             ex = ast.expr_log(0, e, ast.ann_none);\n         }\n \n-        case (token.CHECK) {\n+        case (token.ASSERT) {\n             p.bump();\n-            alt (p.peek()) {\n-                case (token.LPAREN) {\n-                    auto e = parse_expr(p);\n-                    auto hi = e.span.hi;\n-                    ex = ast.expr_check_expr(e, ast.ann_none);\n-                }\n-                case (_) {\n-                    p.get_session().unimpl(\"constraint-check stmt\");\n-                }\n-            }\n+            auto e = parse_expr(p);\n+            auto hi = e.span.hi;\n+            ex = ast.expr_assert(e, ast.ann_none);\n         }\n \n+        case (token.CHECK) {\n+            p.bump();\n+            /* Should be a predicate (pure boolean function) applied to \n+             arguments that are all either slot variables or literals.\n+            but the typechecker enforces that. */\n+            auto e = parse_expr(p);\n+            auto hi = e.span.hi;\n+            ex = ast.expr_check(e, ast.ann_none);\n+        } \n+\n         case (token.RET) {\n             p.bump();\n             alt (p.peek()) {\n@@ -937,7 +940,7 @@ fn expand_syntax_ext(parser p, ast.span sp,\n                      &ast.path path, vec[@ast.expr] args,\n                      option.t[str] body) -> ast.expr_ {\n \n-    check (_vec.len[ast.ident](path.node.idents) > 0u);\n+    assert (_vec.len[ast.ident](path.node.idents) > 0u);\n     auto extname = path.node.idents.(0);\n     if (_str.eq(extname, \"fmt\")) {\n         auto expanded = extfmt.expand_syntax_ext(args, body);\n@@ -1673,7 +1676,8 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n                 case (ast.expr_put(_,_))        { ret true; }\n                 case (ast.expr_be(_,_))         { ret true; }\n                 case (ast.expr_log(_,_,_))        { ret true; }\n-                case (ast.expr_check_expr(_,_)) { ret true; }\n+                case (ast.expr_check(_,_)) { ret true; }\n+                case (ast.expr_assert(_,_)) { ret true; }\n             }\n         }\n         // We should not be calling this on a cdir.\n@@ -2157,24 +2161,24 @@ fn parse_item(parser p) -> @ast.item {\n \n     alt (p.peek()) {\n         case (token.CONST) {\n-            check (lyr == ast.layer_value);\n+            assert (lyr == ast.layer_value);\n             ret parse_item_const(p);\n         }\n \n         case (token.FN) {\n-            check (lyr == ast.layer_value);\n+            assert (lyr == ast.layer_value);\n             ret parse_item_fn_or_iter(p);\n         }\n         case (token.ITER) {\n-            check (lyr == ast.layer_value);\n+            assert (lyr == ast.layer_value);\n             ret parse_item_fn_or_iter(p);\n         }\n         case (token.MOD) {\n-            check (lyr == ast.layer_value);\n+            assert (lyr == ast.layer_value);\n             ret parse_item_mod(p);\n         }\n         case (token.NATIVE) {\n-            check (lyr == ast.layer_value);\n+            assert (lyr == ast.layer_value);\n             ret parse_item_native_mod(p);\n         }\n         case (token.TYPE) {"}, {"sha": "594515f22141e7df67ef2df96d46840816be1ccc", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -89,6 +89,7 @@ tag token {\n \n     /* Type and type-state keywords */\n     TYPE;\n+    ASSERT;\n     CHECK;\n     CLAIM;\n     PROVE;\n@@ -258,6 +259,7 @@ fn to_str(token t) -> str {\n \n         /* Type and type-state keywords */\n         case (TYPE) { ret \"type\"; }\n+        case (ASSERT) { ret \"assert\"; }\n         case (CHECK) { ret \"check\"; }\n         case (CLAIM) { ret \"claim\"; }\n         case (PROVE) { ret \"prove\"; }"}, {"sha": "070174bad3c688364611f1dde4246d059281552f", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -861,46 +861,46 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n \n     /* Terminators */\n     fn RetVoid()  -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildRetVoid(B);\n     }\n \n     fn Ret(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildRet(B, V);\n     }\n \n     fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildAggregateRet(B,\n                                        _vec.buf[ValueRef](RetVals),\n                                        _vec.len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildBr(B, Dest);\n     }\n \n     fn CondBr(ValueRef If, BasicBlockRef Then,\n               BasicBlockRef Else) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildCondBr(B, If, Then, Else);\n     }\n \n     fn Switch(ValueRef V, BasicBlockRef Else, uint NumCases) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildSwitch(B, V, Else, NumCases);\n     }\n \n     fn IndirectBr(ValueRef Addr, uint NumDests) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n@@ -909,7 +909,7 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n               vec[ValueRef] Args,\n               BasicBlockRef Then,\n               BasicBlockRef Catch) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildInvoke(B, Fn,\n                                  _vec.buf[ValueRef](Args),\n@@ -919,353 +919,353 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     }\n \n     fn Unwind() -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildUnwind(B);\n     }\n \n     fn Unreachable() -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         *terminated = true;\n         ret llvm.LLVMBuildUnreachable(B);\n     }\n \n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNSWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNUWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNSWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNUWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildUDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildURem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildShl(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildLShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildAShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildAnd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildOr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildXor(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNSWNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNUWNeg(B, V, _str.buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFNeg(B, V, _str.buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildNot(B, V, _str.buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildMalloc(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildAlloca(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFree(B, PointerVal);\n     }\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildLoad(B, PointerVal, _str.buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildStore(B, Val, Ptr);\n     }\n \n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildGEP(B, Pointer,\n                               _vec.buf[ValueRef](Indices),\n                               _vec.len[ValueRef](Indices),\n                               _str.buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n                                       _vec.buf[ValueRef](Indices),\n                                       _vec.len[ValueRef](Indices),\n                                       _str.buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, _str.buf(\"\"));\n     }\n \n     fn GlobalString(sbuf Str) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildGlobalString(B, Str, _str.buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf Str) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildGlobalStringPtr(B, Str, _str.buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildZExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFPToUI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFPToSI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildUIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFPExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildCast(B, Op, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildPointerCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildIntCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFPCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         auto phi = llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n-        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n                              _vec.buf[ValueRef](vals),\n                              _vec.buf[BasicBlockRef](bbs),\n@@ -1276,23 +1276,23 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     fn AddIncomingToPhi(ValueRef phi,\n                         vec[ValueRef] vals,\n                         vec[BasicBlockRef] bbs) {\n-        check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n+        assert (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n                              _vec.buf[ValueRef](vals),\n                              _vec.buf[BasicBlockRef](bbs),\n                              _vec.len[ValueRef](vals));\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildCall(B, Fn,\n                                _vec.buf[ValueRef](Args),\n                                _vec.len[ValueRef](Args),\n                                _str.buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         auto v = llvm.LLVMBuildCall(B, Fn,\n                                     _vec.buf[ValueRef](Args),\n                                     _vec.len[ValueRef](Args),\n@@ -1302,65 +1302,65 @@ obj builder(BuilderRef B, @mutable bool terminated) {\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildSelect(B, If, Then, Else, _str.buf(\"\"));\n     }\n \n     fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildVAArg(B, List, Ty, _str.buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildExtractElement(B, VecVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n                                         _str.buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, _str.buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildExtractValue(B, AggVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, _str.buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildIsNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildIsNotNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n-        check (!*terminated);\n+        assert (!*terminated);\n         let BasicBlockRef BB = llvm.LLVMGetInsertBlock(B);\n         let ValueRef FN = llvm.LLVMGetBasicBlockParent(BB);\n         let ModuleRef M = llvm.LLVMGetGlobalParent(FN);\n         let ValueRef T = llvm.LLVMGetNamedFunction(M, _str.buf(\"llvm.trap\"));\n-        check (T as int != 0);\n+        assert (T as int != 0);\n         let vec[ValueRef] Args = vec();\n         ret llvm.LLVMBuildCall(B, T,\n                                _vec.buf[ValueRef](Args),\n@@ -1391,8 +1391,8 @@ state obj type_names(std.map.hashmap[TypeRef, str] type_names,\n                     std.map.hashmap[str, TypeRef] named_types) {\n \n     fn associate(str s, TypeRef t) {\n-        check (!named_types.contains_key(s));\n-        check (!type_names.contains_key(t));\n+        assert (!named_types.contains_key(s));\n+        assert (!type_names.contains_key(t));\n         type_names.insert(t, s);\n         named_types.insert(s, t);\n     }"}, {"sha": "e932fd9af497cc3b30943fbc953973872a2e17f1", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -196,7 +196,10 @@ type ast_fold[ENV] =\n          @expr e, ann a) -> @expr)                fold_expr_log,\n \n      (fn(&ENV e, &span sp,\n-         @expr e, ann a) -> @expr)                fold_expr_check_expr,\n+         @expr e, ann a) -> @expr)                fold_expr_check,\n+\n+     (fn(&ENV e, &span sp,\n+         @expr e, ann a) -> @expr)                fold_expr_assert,\n \n      (fn(&ENV e, &span sp,\n          ann a) -> @expr)                         fold_expr_port,\n@@ -796,10 +799,16 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             ret fld.fold_expr_log(env_, e.span, l, ee, t2);\n         }\n \n-        case (ast.expr_check_expr(?x, ?t)) {\n+        case (ast.expr_check(?x, ?t)) {\n             auto ee = fold_expr(env_, fld, x);\n             auto t2 = fld.fold_ann(env_, t);\n-            ret fld.fold_expr_check_expr(env_, e.span, ee, t2);\n+            ret fld.fold_expr_check(env_, e.span, ee, t2);\n+        }\n+\n+        case (ast.expr_assert(?x, ?t)) {\n+            auto ee = fold_expr(env_, fld, x);\n+            auto t2 = fld.fold_ann(env_, t);\n+            ret fld.fold_expr_assert(env_, e.span, ee, t2);\n         }\n \n         case (ast.expr_port(?t)) {\n@@ -1380,9 +1389,14 @@ fn identity_fold_expr_log[ENV](&ENV e, &span sp, int lvl, @expr x,\n     ret @respan(sp, ast.expr_log(lvl, x, a));\n }\n \n-fn identity_fold_expr_check_expr[ENV](&ENV e, &span sp, @expr x, ann a)\n+fn identity_fold_expr_check[ENV](&ENV e, &span sp, @expr x, ann a)\n+    -> @expr {\n+    ret @respan(sp, ast.expr_check(x, a));\n+}\n+\n+fn identity_fold_expr_assert[ENV](&ENV e, &span sp, @expr x, ann a)\n     -> @expr {\n-    ret @respan(sp, ast.expr_check_expr(x, a));\n+    ret @respan(sp, ast.expr_check(x, a));\n }\n \n fn identity_fold_expr_port[ENV](&ENV e, &span sp, ann a) -> @expr {\n@@ -1676,8 +1690,11 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_expr_put    = bind identity_fold_expr_put[ENV](_,_,_,_),\n          fold_expr_be     = bind identity_fold_expr_be[ENV](_,_,_,_),\n          fold_expr_log    = bind identity_fold_expr_log[ENV](_,_,_,_,_),\n-         fold_expr_check_expr\n-         = bind identity_fold_expr_check_expr[ENV](_,_,_,_),\n+         fold_expr_check\n+         = bind identity_fold_expr_check[ENV](_,_,_,_),\n+         fold_expr_assert\n+         = bind identity_fold_expr_assert[ENV](_,_,_,_),\n+              \n          fold_expr_port   = bind identity_fold_expr_port[ENV](_,_,_),\n          fold_expr_chan   = bind identity_fold_expr_chan[ENV](_,_,_,_),\n "}, {"sha": "bec6262847e3c1bd23bc10968ba25cfa5ee96f37", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -63,7 +63,7 @@ mod Encode {\n     );\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        check (! cx.use_abbrevs);\n+        assert (! cx.use_abbrevs);\n         auto sw = io.string_writer();\n         enc_ty(sw.get_writer(), cx, t);\n         ret sw.get_str();"}, {"sha": "c045413c2dba7ba0066e96869fd6c5e8a5d01078", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -662,7 +662,7 @@ fn fold_pat_tag(&env e, &span sp, ast.path p, vec[@ast.pat] args,\n fn fold_expr_path(&env e, &span sp, &ast.path p, &option.t[def] d,\n                   ann a) -> @ast.expr {\n     auto n_idents = _vec.len[ast.ident](p.node.idents);\n-    check (n_idents != 0u);\n+    assert (n_idents != 0u);\n \n     auto index = new_def_hash[def_wrap]();\n     auto d = find_final_def(e, index, sp, p.node.idents, ns_value,"}, {"sha": "9d4260d84dc9c9d8869b62023635b93602067537", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -592,7 +592,7 @@ fn type_of_explicit_args(@crate_ctxt cx, vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(cx.tcx, arg.ty)) {\n-            check (arg.mode == ast.alias);\n+            assert (arg.mode == ast.alias);\n             atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n             let TypeRef t;\n@@ -638,7 +638,7 @@ fn type_of_fn_full(@crate_ctxt cx,\n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n-            check (t as int != 0);\n+            assert (t as int != 0);\n             atys += vec(t);\n         }\n         case (_) {\n@@ -806,7 +806,7 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n         case (ty.ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n \n-    check (llty as int != 0);\n+    assert (llty as int != 0);\n     llvm.LLVMAddTypeName(cx.llmod,\n                          _str.buf(ty.ty_to_short_str(cx.tcx,\n                                                      cx.type_abbrevs, t)),\n@@ -1361,7 +1361,7 @@ fn dynamic_align_of(@block_ctxt cx, ty.t t) -> result {\n fn GEP_tup_like(@block_ctxt cx, ty.t t,\n                 ValueRef base, vec[int] ixs) -> result {\n \n-    check (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n+    assert (ty.type_is_tup_like(cx.fcx.lcx.ccx.tcx, t));\n \n     // It might be a static-known type. Handle this.\n \n@@ -1399,17 +1399,17 @@ fn GEP_tup_like(@block_ctxt cx, ty.t t,\n         // and the latter would only be meaningful if we supported non-0\n         // values for the 0th index (we don't).\n \n-        check (len > 1u);\n+        assert (len > 1u);\n \n         if (n == 0u) {\n             // Since we're starting from a value that's a pointer to a\n             // *single* structure, the first index (in GEP-ese) should just be\n             // 0, to yield the pointee.\n-            check (ixs.(n) == 0);\n+            assert (ixs.(n) == 0);\n             ret split_type(ccx, t, ixs, n+1u);\n         }\n \n-        check (n < len);\n+        assert (n < len);\n \n         let int ix = ixs.(n);\n         let vec[ty.t] prefix = vec();\n@@ -1603,8 +1603,8 @@ fn get_tydesc(&@block_ctxt cx, ty.t t, bool escapes) -> result {\n         let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n         auto tys = linearize_ty_params(cx, t);\n \n-        check (n_params == _vec.len[uint](tys._0));\n-        check (n_params == _vec.len[ValueRef](tys._1));\n+        assert (n_params == _vec.len[uint](tys._0));\n+        assert (n_params == _vec.len[ValueRef](tys._1));\n \n         auto root = get_static_tydesc(cx, t, tys._0).tydesc;\n \n@@ -2327,7 +2327,7 @@ fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n         ret creader.get_tag_variants(cx.sess, cx.tcx, id);\n     }\n \n-    check (cx.items.contains_key(id));\n+    assert (cx.items.contains_key(id));\n     alt (cx.items.get(id).node) {\n         case (ast.item_tag(_, ?variants, _, _, _)) {\n             let vec[variant_info] result = vec();\n@@ -3346,7 +3346,7 @@ fn join_results(@block_ctxt parent_cx,\n             // No incoming edges are live, so we're in dead-code-land.\n             // Arbitrarily pick the first dead edge, since the caller\n             // is just going to propagate it outward.\n-            check (_vec.len[result](ins) >= 1u);\n+            assert (_vec.len[result](ins) >= 1u);\n             ret ins.(0);\n         }\n \n@@ -3974,7 +3974,7 @@ fn lval_generic_fn(@block_ctxt cx,\n     auto lv;\n     if (cx.fcx.lcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n-        check (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n+        assert (cx.fcx.lcx.ccx.fn_pairs.contains_key(fn_id));\n         lv = lval_val(cx, cx.fcx.lcx.ccx.fn_pairs.get(fn_id));\n     } else {\n         // External reference.\n@@ -4017,7 +4017,7 @@ fn lookup_discriminant(@local_ctxt lcx, ast.def_id tid, ast.def_id vid)\n     alt (lcx.ccx.discrims.find(vid)) {\n         case (none[ValueRef]) {\n             // It's an external discriminant that we haven't seen yet.\n-            check (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n+            assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n             auto sym = creader.get_symbol(lcx.ccx.sess, vid);\n             auto gvar = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n                                            _str.buf(sym));\n@@ -4039,7 +4039,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 case (ast.def_arg(?did)) {\n                     alt (cx.fcx.llargs.find(did)) {\n                         case (none[ValueRef]) {\n-                            check (cx.fcx.llupvars.contains_key(did));\n+                            assert (cx.fcx.llupvars.contains_key(did));\n                             ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                         }\n                         case (some[ValueRef](?llval)) {\n@@ -4050,7 +4050,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 case (ast.def_local(?did)) {\n                     alt (cx.fcx.lllocals.find(did)) {\n                         case (none[ValueRef]) {\n-                            check (cx.fcx.llupvars.contains_key(did));\n+                            assert (cx.fcx.llupvars.contains_key(did));\n                             ret lval_mem(cx, cx.fcx.llupvars.get(did));\n                         }\n                         case (some[ValueRef](?llval)) {\n@@ -4059,11 +4059,11 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     }\n                 }\n                 case (ast.def_binding(?did)) {\n-                    check (cx.fcx.lllocals.contains_key(did));\n+                    assert (cx.fcx.lllocals.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.lllocals.get(did));\n                 }\n                 case (ast.def_obj_field(?did)) {\n-                    check (cx.fcx.llobjfields.contains_key(did));\n+                    assert (cx.fcx.llobjfields.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n@@ -4115,7 +4115,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_const(?did)) {\n                     // TODO: externals\n-                    check (cx.fcx.lcx.ccx.consts.contains_key(did));\n+                    assert (cx.fcx.lcx.ccx.consts.contains_key(did));\n                     ret lval_mem(cx, cx.fcx.lcx.ccx.consts.get(did));\n                 }\n                 case (ast.def_native_fn(?did)) {\n@@ -4254,7 +4254,7 @@ fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n             ret trans_index(cx, e.span, base, idx, ann);\n         }\n         case (ast.expr_unary(?unop, ?base, ?ann)) {\n-            check (unop == ast.deref);\n+            assert (unop == ast.deref);\n \n             auto sub = trans_expr(cx, base);\n             auto val = sub.bcx.build.GEP(sub.val,\n@@ -4418,7 +4418,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                     }\n                 } else if (ty.type_contains_params(cx.ccx.tcx,\n                                                    out_arg.ty)) {\n-                    check (out_arg.mode == ast.alias);\n+                    assert (out_arg.mode == ast.alias);\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n@@ -4431,7 +4431,7 @@ fn trans_bind_thunk(@local_ctxt cx,\n                 let ValueRef passed_arg = llvm.LLVMGetParam(llthunk, a);\n \n                 if (ty.type_contains_params(cx.ccx.tcx, out_arg.ty)) {\n-                    check (out_arg.mode == ast.alias);\n+                    assert (out_arg.mode == ast.alias);\n                     passed_arg = bcx.build.PointerCast(passed_arg,\n                                                        llout_arg_ty);\n                 }\n@@ -5121,7 +5121,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n         case (ast.expr_assign(?dst, ?src, ?ann)) {\n             auto lhs_res = trans_lval(cx, dst);\n-            check (lhs_res.is_mem);\n+            assert (lhs_res.is_mem);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -5132,7 +5132,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         case (ast.expr_assign_op(?op, ?dst, ?src, ?ann)) {\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             auto lhs_res = trans_lval(cx, dst);\n-            check (lhs_res.is_mem);\n+            assert (lhs_res.is_mem);\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             if (ty.type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n                 alt (op) {\n@@ -5189,7 +5189,11 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_log(lvl, cx, a);\n         }\n \n-        case (ast.expr_check_expr(?a, _)) {\n+        case (ast.expr_assert(?a, _)) {\n+            ret trans_check_expr(cx, a);\n+        }\n+\n+        case (ast.expr_check(?a, _)) {\n             ret trans_check_expr(cx, a);\n         }\n \n@@ -5510,7 +5514,7 @@ fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n \n fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n     // FIXME: This should be a typestate precondition\n-    check (ast.is_call_expr(e));\n+    assert (ast.is_call_expr(e));\n     // FIXME: Turn this into a real tail call once\n     // calling convention issues are settled\n     ret trans_ret(cx, some(e));\n@@ -5606,7 +5610,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     auto bcx = cx;\n     auto data = trans_lval(bcx, lhs);\n-    check (data.is_mem);\n+    assert (data.is_mem);\n     bcx = data.res.bcx;\n     auto unit_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n \n@@ -5638,7 +5642,7 @@ fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n fn init_local(@block_ctxt cx, @ast.local local) -> result {\n \n     // Make a note to drop this slot on the way out.\n-    check (cx.fcx.lllocals.contains_key(local.id));\n+    assert (cx.fcx.lllocals.contains_key(local.id));\n     auto llptr = cx.fcx.lllocals.get(local.id);\n     auto ty = node_ann_type(cx.fcx.lcx.ccx, local.ann);\n     auto bcx = cx;\n@@ -5754,7 +5758,7 @@ fn trans_block_cleanups(@block_ctxt cx,\n     auto bcx = cx;\n \n     if (cleanup_cx.kind == NON_SCOPE_BLOCK) {\n-        check (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n+        assert (_vec.len[cleanup](cleanup_cx.cleanups) == 0u);\n     }\n \n     auto i = _vec.len[cleanup](cleanup_cx.cleanups);\n@@ -5975,7 +5979,7 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n             auto i = 0u;\n             for (ast.ty_param tp in ty_params) {\n                 auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-                check (llarg as int != 0);\n+                assert (llarg as int != 0);\n                 cx.lltydescs += vec(llarg);\n                 arg_n += 1u;\n                 i += 1u;\n@@ -5985,14 +5989,14 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n \n     if (proto == ast.proto_iter) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-        check (llarg as int != 0);\n+        assert (llarg as int != 0);\n         cx.lliterbody = some[ValueRef](llarg);\n         arg_n += 1u;\n     }\n \n     for (ast.arg arg in args) {\n         auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n-        check (llarg as int != 0);\n+        assert (llarg as int != 0);\n         cx.llargs.insert(arg.id, llarg);\n         arg_n += 1u;\n     }\n@@ -6430,7 +6434,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n                            id=varg.id));\n     }\n \n-    check (cx.ccx.item_ids.contains_key(variant.node.id));\n+    assert (cx.ccx.item_ids.contains_key(variant.node.id));\n     let ValueRef llfndecl = cx.ccx.item_ids.get(variant.node.id);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n@@ -6697,7 +6701,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n             for each (uint i in _uint.range(0u, num_ty_param)) {\n                 auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n                 fcx.lltydescs += vec(llarg);\n-                check (llarg as int != 0);\n+                assert (llarg as int != 0);\n                 call_args += vec(vp2i(bcx, llarg));\n                 arg_n += 1u;\n             }\n@@ -6763,7 +6767,7 @@ fn decl_native_fn_and_pair(@crate_ctxt ccx,\n \n         for (ty.arg arg in args) {\n             auto llarg = llvm.LLVMGetParam(fcx.llfn, arg_n);\n-            check (llarg as int != 0);\n+            assert (llarg as int != 0);\n             push_arg(bcx, call_args, llarg, arg.ty, arg.mode);\n             if (arg.mode == ast.val) {\n                 drop_args += vec(tup(llarg, arg.ty));"}, {"sha": "220adcb1a23aa25f87dc9b47ec4e02eaaa140690", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 120, "deletions": 67, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -895,7 +895,7 @@ fn type_is_tup_like(ctxt cx, t ty) -> bool {\n }\n \n fn get_element_type(ctxt cx, t ty, uint i) -> t {\n-    check (type_is_tup_like(cx, ty));\n+    assert (type_is_tup_like(cx, ty));\n     alt (struct(cx, ty)) {\n         case (ty_tup(?mts)) {\n             ret mts.(i).ty;\n@@ -1785,50 +1785,117 @@ fn pat_ty(ctxt cx, @ast.pat pat) -> t {\n     fail;   // not reached\n }\n \n-fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n-    alt (expr.node) {\n-        case (ast.expr_vec(_, _, ?ann))       { ret some[ast.ann](ann); }\n-        case (ast.expr_tup(_, ?ann))          { ret some[ast.ann](ann); }\n-        case (ast.expr_rec(_, _, ?ann))       { ret some[ast.ann](ann); }\n-        case (ast.expr_bind(_, _, ?ann))      { ret some[ast.ann](ann); }\n-        case (ast.expr_call(_, _, ?ann))      { ret some[ast.ann](ann); }\n-        case (ast.expr_self_method(_, ?ann))  { ret some[ast.ann](ann); }\n-        case (ast.expr_spawn(_, _, _, _, ?ann))\n-                                              { ret some[ast.ann](ann); }\n-        case (ast.expr_binary(_, _, _, ?ann)) { ret some[ast.ann](ann); }\n-        case (ast.expr_unary(_, _, ?ann))     { ret some[ast.ann](ann); }\n-        case (ast.expr_lit(_, ?ann))          { ret some[ast.ann](ann); }\n-        case (ast.expr_cast(_, _, ?ann))      { ret some[ast.ann](ann); }\n-        case (ast.expr_if(_, _, _, ?ann))     { ret some[ast.ann](ann); }\n-        case (ast.expr_for(_, _, _, ?ann))    { ret some[ast.ann](ann); }\n-        case (ast.expr_for_each(_, _, _, ?ann))\n-                                              { ret some[ast.ann](ann); }\n-        case (ast.expr_while(_, _, ?ann))     { ret some[ast.ann](ann); }\n-        case (ast.expr_do_while(_, _, ?ann))  { ret some[ast.ann](ann); }\n-        case (ast.expr_alt(_, _, ?ann))       { ret some[ast.ann](ann); }\n-        case (ast.expr_block(_, ?ann))        { ret some[ast.ann](ann); }\n-        case (ast.expr_assign(_, _, ?ann))    { ret some[ast.ann](ann); }\n-        case (ast.expr_assign_op(_, _, _, ?ann))\n-                                              { ret some[ast.ann](ann); }\n-        case (ast.expr_field(_, _, ?ann))     { ret some[ast.ann](ann); }\n-        case (ast.expr_index(_, _, ?ann))     { ret some[ast.ann](ann); }\n-        case (ast.expr_path(_, _, ?ann))      { ret some[ast.ann](ann); }\n-        case (ast.expr_ext(_, _, _, _, ?ann)) { ret some[ast.ann](ann); }\n-        case (ast.expr_port(?ann))            { ret some[ast.ann](ann); }\n-        case (ast.expr_chan(_, ?ann))         { ret some[ast.ann](ann); }\n-        case (ast.expr_send(_, _, ?ann))      { ret some[ast.ann](ann); }\n-        case (ast.expr_recv(_, _, ?ann))      { ret some[ast.ann](ann); }\n-\n-        case (ast.expr_fail(_))               { ret none[ast.ann]; }\n-        case (ast.expr_break(_))              { ret none[ast.ann]; }\n-        case (ast.expr_cont(_))               { ret none[ast.ann]; }\n-        case (ast.expr_log(_,_,_))            { ret none[ast.ann]; }\n-        case (ast.expr_check_expr(_,_))       { ret none[ast.ann]; }\n-        case (ast.expr_ret(_,_))              { ret none[ast.ann]; }\n-        case (ast.expr_put(_,_))              { ret none[ast.ann]; }\n-        case (ast.expr_be(_,_))               { ret none[ast.ann]; }\n+fn expr_ann(&@ast.expr e) -> ast.ann {\n+    alt(e.node) {\n+        case (ast.expr_vec(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_tup(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_rec(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_call(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_bind(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_binary(_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_unary(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_lit(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_cast(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_if(_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_while(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_for(_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_for_each(_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_do_while(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_alt(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_block(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_assign(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_assign_op(_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_send(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_recv(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_field(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_index(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_path(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_ext(_,_,_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_fail(?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_ret(_,?a)) {\n+            ret a; \n+        }\n+        case (ast.expr_put(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_be(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_log(_,_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_assert(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_check(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_port(?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_chan(_,?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_break(?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_cont(?a)) {\n+            ret a;\n+        }\n+        case (ast.expr_self_method(_, ?a)) {\n+            ret a;\n+        }\n     }\n-    fail;\n }\n \n // Returns the type of an expression as a monotype.\n@@ -1838,35 +1905,21 @@ fn expr_ann(@ast.expr expr) -> option.t[ast.ann] {\n // instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(ctxt cx, @ast.expr expr) -> t {\n-    alt (expr_ann(expr)) {\n-        case (none[ast.ann])     { ret mk_nil(cx); }\n-        case (some[ast.ann](?a)) { ret ann_to_monotype(cx, a); }\n-    }\n+    { ret ann_to_monotype(cx, expr_ann(expr)); }\n }\n \n fn expr_ty_params_and_ty(ctxt cx, @ast.expr expr) -> tup(vec[t], t) {\n-    alt (expr_ann(expr)) {\n-        case (none[ast.ann]) {\n-            let vec[t] tps = vec();\n-            ret tup(tps, mk_nil(cx));\n-        }\n-        case (some[ast.ann](?a)) {\n-            ret tup(ann_to_type_params(a), ann_to_type(a));\n-        }\n-    }\n+    auto a = expr_ann(expr);\n+\n+    ret tup(ann_to_type_params(a), ann_to_type(a));\n }\n \n fn expr_has_ty_params(@ast.expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n-        case (none[ast.ann]) { fail; }\n-        case (some[ast.ann](?a)) {\n-            alt (a) {\n-                case (ast.ann_none) { fail; }\n-                case (ast.ann_type(_, ?tps_opt, _)) {\n-                    ret !option.is_none[vec[t]](tps_opt);\n-                }\n-            }\n+        case (ast.ann_none) { fail; }\n+        case (ast.ann_type(_, ?tps_opt, _)) {\n+            ret !option.is_none[vec[t]](tps_opt);\n         }\n     }\n }\n@@ -2233,7 +2286,7 @@ mod Unify {\n                         if (actual_n < vlen) {\n                             cx.types.(actual_n) += vec(expected);\n                         } else {\n-                            check (actual_n == vlen);\n+                            assert (actual_n == vlen);\n                             cx.types += vec(mutable vec(expected));\n                         }\n                     }\n@@ -2601,7 +2654,7 @@ mod Unify {\n                 if (expected_n < vlen) {\n                     cx.types.(expected_n) += vec(actual);\n                 } else {\n-                    check (expected_n == vlen);\n+                    assert (expected_n == vlen);\n                     cx.types += vec(mutable vec(actual));\n                 }\n                 ret ures_ok(expected);"}, {"sha": "094b7e1f0ee99cd72b8b1440a9d94e43bc730e5d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -110,7 +110,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n         -> ty_param_count_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n-            // check (fcx.locals.contains_key(id));\n+            // assert (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_local(?id)) {\n@@ -122,7 +122,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n             ret tup(0u, t);\n         }\n         case (ast.def_obj_field(?id)) {\n-            // check (fcx.locals.contains_key(id));\n+            // assert (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n@@ -142,7 +142,7 @@ fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n                                     fcx.ccx.type_cache, vid);\n         }\n         case (ast.def_binding(?id)) {\n-            // check (fcx.locals.contains_key(id));\n+            // assert (fcx.locals.contains_key(id));\n             ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n@@ -298,7 +298,7 @@ fn ast_ty_to_ty(ty.ctxt tcx, ty_getter getter, &@ast.ty ast_ty) -> ty.t {\n         }\n \n         case (ast.ty_path(?path, ?def)) {\n-            check (def != none[ast.def]);\n+            assert (def != none[ast.def]);\n             alt (option.get[ast.def](def)) {\n                 case (ast.def_ty(?id)) {\n                     typ = instantiate(tcx, getter, id, path.node.types);\n@@ -411,7 +411,7 @@ mod Collect {\n             ret creader.get_type(cx.sess, cx.tcx, id);\n         }\n \n-        // check (cx.id_to_ty_item.contains_key(id));\n+        // assert (cx.id_to_ty_item.contains_key(id));\n \n         auto it = cx.id_to_ty_item.get(id);\n         auto tpt;\n@@ -672,7 +672,7 @@ mod Collect {\n     fn fold_item_const(&@env e, &span sp, ast.ident i,\n                        @ast.ty t, @ast.expr ex,\n                        ast.def_id id, ast.ann a) -> @ast.item {\n-        // check (e.cx.type_cache.contains_key(id));\n+        // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -681,7 +681,7 @@ mod Collect {\n     fn fold_item_fn(&@env e, &span sp, ast.ident i,\n                     &ast._fn f, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        // check (e.cx.type_cache.contains_key(id));\n+        // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -690,7 +690,7 @@ mod Collect {\n     fn fold_native_item_fn(&@env e, &span sp, ast.ident i, option.t[str] ln,\n                            &ast.fn_decl d, vec[ast.ty_param] ty_params,\n                            ast.def_id id, ast.ann a) -> @ast.native_item {\n-        // check (e.cx.type_cache.contains_key(id));\n+        // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n                                        triv_ann(typ));\n@@ -721,7 +721,7 @@ mod Collect {\n     fn fold_item_obj(&@env e, &span sp, ast.ident i,\n                     &ast._obj ob, vec[ast.ty_param] ty_params,\n                     ast.obj_def_ids odid, ast.ann a) -> @ast.item {\n-        // check (e.cx.type_cache.contains_key(odid.ctor));\n+        // assert (e.cx.type_cache.contains_key(odid.ctor));\n         auto t = e.cx.type_cache.get(odid.ctor)._1;\n         let vec[method] meth_tys = get_ctor_obj_methods(e, t);\n         let vec[@ast.method] methods = vec();\n@@ -777,7 +777,7 @@ mod Collect {\n     fn fold_item_ty(&@env e, &span sp, ast.ident i,\n                     @ast.ty t, vec[ast.ty_param] ty_params,\n                     ast.def_id id, ast.ann a) -> @ast.item {\n-        // check (e.cx.type_cache.contains_key(id));\n+        // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n         ret @fold.respan[ast.item_](sp, item);\n@@ -1214,7 +1214,7 @@ mod Pushdown {\n                             case (none[@ast.expr]) {\n                                 auto i = 0u;\n                                 for (ast.field field_0 in fields_0) {\n-                                    check (_str.eq(field_0.ident,\n+                                    assert (_str.eq(field_0.ident,\n                                                    field_mts.(i).ident));\n                                     auto e_1 =\n                                         pushdown_expr(fcx,\n@@ -1409,7 +1409,8 @@ mod Pushdown {\n             case (ast.expr_ret(_,_)) { e_1 = e.node; }\n             case (ast.expr_put(_,_)) { e_1 = e.node; }\n             case (ast.expr_be(_,_))  { e_1 = e.node; }\n-            case (ast.expr_check_expr(_,_)) { e_1 = e.node; }\n+            case (ast.expr_check(_,_)) { e_1 = e.node; }\n+            case (ast.expr_assert(_,_)) { e_1 = e.node; }\n \n             case (ast.expr_port(?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n@@ -1839,7 +1840,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n-            check (defopt != none[ast.def]);\n+            assert (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n@@ -1939,7 +1940,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n         case (ast.expr_be(?e, _)) {\n             /* FIXME: prove instead of check */\n-            check (ast.is_call_expr(e));\n+            assert (ast.is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n             ret @fold.respan[ast.expr_](expr.span,\n@@ -1953,12 +1954,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                          plain_ann(fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_check_expr(?e, _)) {\n+        case (ast.expr_check(?e, _)) {\n+            /* FIXME */\n+        /* presumably, here is where we should check that e is\n+         actually a call to a predicate, where all the arguments\n+        are literals or slot variables? */\n             auto expr_t = check_expr(fcx, e);\n             Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n                           expr_ty(fcx.ccx.tcx, expr_t));\n             ret @fold.respan[ast.expr_]\n-                (expr.span, ast.expr_check_expr(expr_t,\n+                (expr.span, ast.expr_check(expr_t,\n+                                                plain_ann(fcx.ccx.tcx)));\n+        }\n+\n+        case (ast.expr_assert(?e, _)) {\n+            auto expr_t = check_expr(fcx, e);\n+            Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n+                          expr_ty(fcx.ccx.tcx, expr_t));\n+            ret @fold.respan[ast.expr_]\n+                (expr.span, ast.expr_assert(expr_t,\n                                                 plain_ann(fcx.ccx.tcx)));\n         }\n "}, {"sha": "e15c720a3d957e0a64d6e72d538fce35789ac203", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 152, "deletions": 254, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -55,7 +55,8 @@ import front.ast.expr_put;\n import front.ast.expr_port;\n import front.ast.expr_chan;\n import front.ast.expr_be;\n-import front.ast.expr_check_expr;\n+import front.ast.expr_check;\n+import front.ast.expr_assert;\n import front.ast.expr_cast;\n import front.ast.expr_for;\n import front.ast.expr_for_each;\n@@ -147,8 +148,7 @@ import util.typestate_ann.clone;\n import middle.ty;\n import middle.ty.ann_to_type;\n import middle.ty.arg;\n-import middle.ty.block_ty;\n-import middle.ty.expr_ty;\n+import middle.ty.expr_ann;\n import middle.ty.ty_to_str;\n \n import pretty.pprust.print_block;\n@@ -293,11 +293,11 @@ type fn_info      = std.map.hashmap[def_id, var_info];\n type fn_info_map = std.map.hashmap[def_id, fn_info];\n  \n fn bit_num(def_id v, fn_info m) -> uint {\n-  check (m.contains_key(v));\n+  assert (m.contains_key(v));\n   ret m.get(v)._0;\n }\n fn get_fn_info(fn_info_map fm, def_id did) -> fn_info {\n-    check (fm.contains_key(did));\n+    assert (fm.contains_key(did));\n     ret fm.get(did);\n }\n \n@@ -389,116 +389,6 @@ fn mk_f_to_fn_info(@ast.crate c) -> fn_info_map {\n   ret res;\n }\n /**** Helpers ****/\n-fn expr_ann(&expr e) -> ann {\n-  alt(e.node) {\n-    case (ast.expr_vec(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_tup(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_rec(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_call(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_bind(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_binary(_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_unary(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_lit(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_cast(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_if(_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_while(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_for(_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_for_each(_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_do_while(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_alt(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_block(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_assign(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_assign_op(_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_send(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_recv(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_field(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_index(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_path(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_ext(_,_,_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_fail(?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_ret(_,?a)) {\n-      ret a; \n-    }\n-    case (ast.expr_put(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_be(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_log(_,_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_check_expr(_,?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_port(?a)) {\n-      ret a;\n-    }\n-    case (ast.expr_chan(_,?a)) {\n-      ret a;\n-    }\n-    case (expr_break(?a)) {\n-        ret a;\n-    }\n-    case (expr_cont(?a)) {\n-        ret a;\n-    }\n-    case (expr_self_method(_, ?a)) {\n-        ret a;\n-    }\n-  }\n-}\n-\n fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   alt (a) {\n     case (ann_none)         { ret empty_ann(nv); }\n@@ -532,7 +422,7 @@ fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n           fail;\n       }\n       case (ann_type(_,_,?t)) {\n-          check (! is_none[@ts_ann](t));\n+          assert (! is_none[@ts_ann](t));\n           ret get[@ts_ann](t);\n       }\n   }\n@@ -557,7 +447,7 @@ fn stmt_to_ann(&stmt s) -> option.t[@ts_ann] {\n }\n \n /* fails if e has no annotation */\n-fn expr_states(&expr e) -> pre_and_post_state {\n+fn expr_states(@expr e) -> pre_and_post_state {\n   alt (expr_ann(e)) {\n     case (ann_none) {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n@@ -578,7 +468,7 @@ fn expr_states(&expr e) -> pre_and_post_state {\n }\n \n /* fails if e has no annotation */\n-fn expr_pp(&expr e) -> pre_and_post {\n+fn expr_pp(@expr e) -> pre_and_post {\n   alt (expr_ann(e)) {\n     case (ann_none) {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n@@ -664,19 +554,19 @@ fn stmt_states(&stmt s, uint nv) -> pre_and_post_state {\n }\n \n \n-fn expr_precond(&expr e) -> precond {\n+fn expr_precond(@expr e) -> precond {\n   ret (expr_pp(e)).precondition;\n }\n \n-fn expr_postcond(&expr e) -> postcond {\n+fn expr_postcond(@expr e) -> postcond {\n   ret (expr_pp(e)).postcondition;\n }\n \n-fn expr_prestate(&expr e) -> prestate {\n+fn expr_prestate(@expr e) -> prestate {\n   ret (expr_states(e)).prestate;\n }\n \n-fn expr_poststate(&expr e) -> poststate {\n+fn expr_poststate(@expr e) -> poststate {\n   ret (expr_states(e)).poststate;\n }\n \n@@ -737,7 +627,7 @@ fn seq_preconds(fn_info enclosing, vec[pre_and_post] pps) -> precond {\n \n   if (sz >= 1u) {\n     auto first   = pps.(0);\n-    check (pps_len(first) == num_vars);\n+    assert (pps_len(first) == num_vars);\n     let precond rest = seq_preconds(enclosing,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n@@ -797,7 +687,7 @@ fn intersect_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n }\n \n fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n-  check (len[postcond](pcs) > 0u);\n+  assert (len[postcond](pcs) > 0u);\n \n   ret intersect_postconds_go(bitv.clone(pcs.(0)), pcs);\n }\n@@ -826,7 +716,7 @@ fn find_pre_post_state_native_mod(&native_mod m) -> bool {\n  \n fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n     fn do_a_method(fn_info_map fm, &@method m) -> () {\n-        check(fm.contains_key(m.node.id));\n+        assert (fm.contains_key(m.node.id));\n         find_pre_post_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n@@ -836,7 +726,7 @@ fn find_pre_post_obj(&fn_info_map fm, _obj o) -> () {\n \n fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n     fn do_a_method(fn_info_map fm, &@method m) -> bool {\n-        check(fm.contains_key(m.node.id));\n+        assert (fm.contains_key(m.node.id));\n         ret find_pre_post_state_fn(fm, fm.get(m.node.id), m.node.meth);\n     }\n     auto f = bind do_a_method(fm,_);\n@@ -849,10 +739,10 @@ fn find_pre_post_state_obj(fn_info_map fm, _obj o) -> bool {\n fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n   alt (i.node) {\n     case (ast.item_const(?id, ?t, ?e, ?di, ?a)) {\n-        find_pre_post_expr(fm, enclosing, *e);\n+        find_pre_post_expr(fm, enclosing, e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      check (fm.contains_key(di));\n+      assert (fm.contains_key(di));\n       find_pre_post_fn(fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n@@ -883,14 +773,14 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n \n     fn do_one(fn_info_map fm, fn_info enclosing,\n               &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, *e);\n+        find_pre_post_expr(fm, enclosing, e);\n     }\n     auto f = bind do_one(fm, enclosing, _);\n \n     _vec.map[@expr, ()](f, args);\n \n     fn get_pp(&@expr e) -> pre_and_post {\n-        ret expr_pp(*e);\n+        ret expr_pp(e);\n     }\n     auto g = get_pp;\n     auto pps = _vec.map[@expr, pre_and_post](g, args);\n@@ -904,31 +794,31 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n \n fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n      &@expr index, &block body, &ann a) -> () {\n-    find_pre_post_expr(fm, enclosing, *index);\n+    find_pre_post_expr(fm, enclosing, index);\n     find_pre_post_block(fm, enclosing, body);\n     auto loop_precond = declare_var(enclosing, decl_lhs(d),\n-           seq_preconds(enclosing, vec(expr_pp(*index),\n-                                                   block_pp(body))));\n+           seq_preconds(enclosing, vec(expr_pp(index),\n+                                       block_pp(body))));\n     auto loop_postcond = intersect_postconds\n-        (vec(expr_postcond(*index), block_postcond(body)));\n+        (vec(expr_postcond(index), block_postcond(body)));\n     set_pre_and_post(a, rec(precondition=loop_precond,\n                             postcondition=loop_postcond));\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n+fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, @expr e) -> () {\n     auto num_local_vars = num_locals(enclosing);\n \n     fn do_rand_(fn_info_map fm, fn_info enclosing, &@expr e) -> () {\n-        find_pre_post_expr(fm, enclosing, *e);\n+        find_pre_post_expr(fm, enclosing, e);\n     }\n     fn pp_one(&@expr e) -> pre_and_post {\n-        ret expr_pp(*e);\n+        ret expr_pp(e);\n     }\n     \n         log(\"find_pre_post_expr (num_locals =\" +\n              uistr(num_local_vars) + \"):\");\n-        log_expr(e);\n+        log_expr(*e);\n     \n     alt (e.node) {\n         case (expr_call(?operator, ?operands, ?a)) {\n@@ -974,18 +864,18 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case(expr_log(_, ?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *arg);\n-            set_pre_and_post(a, expr_pp(*arg));\n+            find_pre_post_expr(fm, enclosing, arg);\n+            set_pre_and_post(a, expr_pp(arg));\n         }\n         case (expr_chan(?arg, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *arg);\n-            set_pre_and_post(a, expr_pp(*arg));\n+            find_pre_post_expr(fm, enclosing, arg);\n+            set_pre_and_post(a, expr_pp(arg));\n         }\n         case(expr_put(?opt, ?a)) {\n             alt (opt) {\n                 case (some[@expr](?arg)) {\n-                    find_pre_post_expr(fm, enclosing, *arg);\n-                    set_pre_and_post(a, expr_pp(*arg));\n+                    find_pre_post_expr(fm, enclosing, arg);\n+                    set_pre_and_post(a, expr_pp(arg));\n                 }\n                 case (none[@expr]) {\n                     set_pre_and_post(a, empty_pre_post(num_local_vars));\n@@ -1004,10 +894,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         case (expr_assign(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, *rhs);\n-                    set_pre_and_post(a, expr_pp(*rhs));\n+                    find_pre_post_expr(fm, enclosing, rhs);\n+                    set_pre_and_post(a, expr_pp(rhs));\n                     log(\"gen:\");\n-                    log_expr(e);\n+                    log_expr(*e);\n                     gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n@@ -1020,10 +910,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             alt (lhs.node) {\n                 case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n-                    find_pre_post_expr(fm, enclosing, *rhs);\n-                    set_pre_and_post(a, expr_pp(*rhs));\n+                    find_pre_post_expr(fm, enclosing, rhs);\n+                    set_pre_and_post(a, expr_pp(rhs));\n                     log(\"gen:\");\n-                    log_expr(e);\n+                    log_expr(*e);\n                     gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n@@ -1049,45 +939,45 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                           postcondition=false_postcond(num_local_vars)));\n                 }\n                 case (some[@expr](?ret_val)) {\n-                    find_pre_post_expr(fm, enclosing, *ret_val);\n+                    find_pre_post_expr(fm, enclosing, ret_val);\n                     let pre_and_post pp =\n-                        rec(precondition=expr_precond(*ret_val),\n+                        rec(precondition=expr_precond(ret_val),\n                             postcondition=false_postcond(num_local_vars));\n                     set_pre_and_post(a, pp);\n                 }\n             }\n         }\n         case (expr_be(?e, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *e);\n-            set_pre_and_post(a, rec(precondition=expr_prestate(*e),\n+            find_pre_post_expr(fm, enclosing, e);\n+            set_pre_and_post(a, rec(precondition=expr_prestate(e),\n                           postcondition=false_postcond(num_local_vars)));\n         }\n         case (expr_if(?antec, ?conseq, ?maybe_alt, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *antec);\n+            find_pre_post_expr(fm, enclosing, antec);\n             find_pre_post_block(fm, enclosing, conseq);\n             alt (maybe_alt) {\n                 case (none[@expr]) {\n                     auto precond_res = seq_preconds(enclosing,\n-                                                    vec(expr_pp(*antec),\n+                                                    vec(expr_pp(antec),\n                                                         block_pp(conseq)));\n                     set_pre_and_post(a, rec(precondition=precond_res,\n                                             postcondition=\n-                                            expr_poststate(*antec)));\n+                                            expr_poststate(antec)));\n                 }\n                 case (some[@expr](?altern)) {\n-                    find_pre_post_expr(fm, enclosing, *altern);\n+                    find_pre_post_expr(fm, enclosing, altern);\n                     auto precond_true_case =\n                         seq_preconds(enclosing,\n-                                     vec(expr_pp(*antec), block_pp(conseq)));\n+                                     vec(expr_pp(antec), block_pp(conseq)));\n                     auto postcond_true_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(*antec), block_postcond(conseq)));\n+                         vec(expr_postcond(antec), block_postcond(conseq)));\n                     auto precond_false_case = seq_preconds\n                         (enclosing,\n-                         vec(expr_pp(*antec), expr_pp(*altern)));\n+                         vec(expr_pp(antec), expr_pp(altern)));\n                     auto postcond_false_case = union_postconds\n                         (num_local_vars,\n-                         vec(expr_postcond(*antec), expr_postcond(*altern)));\n+                         vec(expr_postcond(antec), expr_postcond(altern)));\n                     auto precond_res = union_postconds\n                         (num_local_vars,\n                          vec(precond_true_case, precond_false_case));\n@@ -1107,31 +997,31 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_exprs(fm, enclosing, vec(l, r), a);\n         }\n         case (expr_unary(_,?operand,?a)) {\n-            find_pre_post_expr(fm, enclosing, *operand);\n-            set_pre_and_post(a, expr_pp(*operand));\n+            find_pre_post_expr(fm, enclosing, operand);\n+            set_pre_and_post(a, expr_pp(operand));\n         }\n         case (expr_cast(?operand, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *operand);\n-            set_pre_and_post(a, expr_pp(*operand));\n+            find_pre_post_expr(fm, enclosing, operand);\n+            set_pre_and_post(a, expr_pp(operand));\n         }\n         case (expr_while(?test, ?body, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *test);\n+            find_pre_post_expr(fm, enclosing, test);\n             find_pre_post_block(fm, enclosing, body);\n             set_pre_and_post(a,\n               rec(precondition=\n                   seq_preconds(enclosing,\n-                                 vec(expr_pp(*test), \n+                                 vec(expr_pp(test), \n                                      block_pp(body))),\n                   postcondition=\n-                  intersect_postconds(vec(expr_postcond(*test),\n+                  intersect_postconds(vec(expr_postcond(test),\n                                           block_postcond(body)))));\n         }\n         case (expr_do_while(?body, ?test, ?a)) {\n             find_pre_post_block(fm, enclosing, body);\n-            find_pre_post_expr(fm, enclosing, *test);\n+            find_pre_post_expr(fm, enclosing, test);\n    \n             auto loop_postcond = union_postconds(num_local_vars,\n-                            vec(block_postcond(body), expr_postcond(*test)));\n+                            vec(block_postcond(body), expr_postcond(test)));\n             /* conservative approximination: if the body\n                could break or cont, the test may never be executed */\n             if (has_nonlocal_exits(body)) {\n@@ -1141,7 +1031,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             set_pre_and_post(a, \n                              rec(precondition=seq_preconds(enclosing,\n                                              vec(block_pp(body),\n-                                                 expr_pp(*test))),\n+                                                 expr_pp(test))),\n                    postcondition=loop_postcond));\n         }\n         case (expr_for(?d, ?index, ?body, ?a)) {\n@@ -1154,7 +1044,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n         }\n         case (expr_alt(?e, ?alts, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *e);\n+            find_pre_post_expr(fm, enclosing, e);\n             fn do_an_alt(fn_info_map fm, fn_info enc, &arm an_alt)\n                 -> pre_and_post {\n                 find_pre_post_block(fm, enc, an_alt.block);\n@@ -1170,7 +1060,7 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n-            auto antec_pp = pp_clone(expr_pp(*e)); \n+            auto antec_pp = pp_clone(expr_pp(e)); \n             auto e_pp  = rec(precondition=empty_prestate(num_local_vars),\n                              postcondition=false_postcond(num_local_vars));\n             auto g = bind combine_pp(antec_pp, enclosing, _, _);\n@@ -1181,8 +1071,8 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             set_pre_and_post(a, alts_overall_pp);\n         }\n         case (expr_field(?operator, _, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *operator);\n-            set_pre_and_post(a, expr_pp(*operator));\n+            find_pre_post_expr(fm, enclosing, operator);\n+            set_pre_and_post(a, expr_pp(operator));\n         }\n         case (expr_fail(?a)) {\n             set_pre_and_post(a,\n@@ -1191,10 +1081,14 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                rec(precondition=empty_prestate(num_local_vars),\n                    postcondition=false_postcond(num_local_vars)));\n         }\n-        case (expr_check_expr(?p, ?a)) {\n+        case (expr_assert(?p, ?a)) {\n+            find_pre_post_expr(fm, enclosing, p);\n+            set_pre_and_post(a, expr_pp(p));\n+        }\n+        case (expr_check(?p, ?a)) {\n             /* will need to change when we support arbitrary predicates... */\n-            find_pre_post_expr(fm, enclosing, *p);\n-            set_pre_and_post(a, expr_pp(*p));\n+            find_pre_post_expr(fm, enclosing, p);\n+            set_pre_and_post(a, expr_pp(p));\n         }\n         case(expr_bind(?operator, ?maybe_args, ?a)) {\n             auto args = _vec.cat_options[@expr](maybe_args);\n@@ -1211,29 +1105,29 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case (expr_ext(_, _, _, ?expanded, ?a)) {\n-            find_pre_post_expr(fm, enclosing, *expanded);\n-            set_pre_and_post(a, expr_pp(*expanded));\n+            find_pre_post_expr(fm, enclosing, expanded);\n+            set_pre_and_post(a, expr_pp(expanded));\n         }\n     }\n }\n \n fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  check(enclosing.contains_key(id));\n+  assert (enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n   ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n }\n \n fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n    -> prestate {\n-    check(enclosing.contains_key(id));\n+    assert (enclosing.contains_key(id));\n     let uint i = (enclosing.get(id))._0;\n     auto res = clone(pre);\n     relax_prestate(i, res);\n     ret res;\n }\n \n fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n-  check(enclosing.contains_key(id));\n+  assert (enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n \n   ret set_in_poststate(i, (ann_to_ts_ann_fail_more(a)).states);\n@@ -1251,8 +1145,8 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n             case(ast.decl_local(?alocal)) {\n                 alt(alocal.init) {\n                     case(some[ast.initializer](?an_init)) {\n-                        find_pre_post_expr(fm, enclosing, *an_init.expr);\n-                        auto rhs_pp = expr_pp(*an_init.expr);\n+                        find_pre_post_expr(fm, enclosing, an_init.expr);\n+                        auto rhs_pp = expr_pp(an_init.expr);\n                         set_pre_and_post(alocal.ann, rhs_pp);\n \n                         /* Inherit ann from initializer, and add var being\n@@ -1281,8 +1175,8 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n         }\n     }\n     case(stmt_expr(?e,?a)) {\n-        find_pre_post_expr(fm, enclosing, *e);\n-        set_pre_and_post(a, expr_pp(*e));\n+        find_pre_post_expr(fm, enclosing, e);\n+        set_pre_and_post(a, expr_pp(e));\n     }    \n   }\n }\n@@ -1318,7 +1212,7 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     \n     _vec.map[@stmt, ()](do_one, b.node.stmts);\n     fn do_inner_(fn_info_map fm, fn_info i, &@expr e) -> () {\n-        find_pre_post_expr(fm, i, *e);\n+        find_pre_post_expr(fm, i, e);\n     }\n     auto do_inner = bind do_inner_(fm, enclosing, _);\n     option.map[@expr, ()](do_inner, b.node.expr);\n@@ -1331,7 +1225,7 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     auto f = get_pp_stmt;\n     pps += _vec.map[@stmt, pre_and_post](f, b.node.stmts);\n     fn get_pp_expr(&@expr e) -> pre_and_post {\n-        ret expr_pp(*e);\n+        ret expr_pp(e);\n     }\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n@@ -1363,7 +1257,7 @@ fn check_item_fn(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n     log(\"check_item_fn:\");\n     log_fn(f, i, ty_params);\n \n-  check (fm.contains_key(id));\n+  assert (fm.contains_key(id));\n   find_pre_post_fn(fm, fm.get(id), f);  \n \n   ret @respan(sp, ast.item_fn(i, f, ty_params, id, a));\n@@ -1377,7 +1271,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n               empty_prestate(num_locals(enclosing)), e);\n     }\n     case (ast.item_fn(?id, ?f, ?ps, ?di, ?a)) {\n-      check (fm.contains_key(di));\n+      assert (fm.contains_key(di));\n       ret find_pre_post_state_fn(fm, fm.get(di), f);\n     }\n     case (ast.item_mod(?id, ?m, ?di)) {\n@@ -1401,7 +1295,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n fn set_prestate_ann(@ann a, prestate pre) -> bool {\n   alt (*a) {\n     case (ann_type(_,_,?ts_a)) {\n-      check (! is_none[@ts_ann](ts_a));\n+      assert (! is_none[@ts_ann](ts_a));\n       ret set_prestate(get[@ts_ann](ts_a), pre);\n     }\n     case (ann_none) {\n@@ -1415,8 +1309,8 @@ fn set_prestate_ann(@ann a, prestate pre) -> bool {\n fn extend_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      check (! is_none[@ts_ann](ts_a));\n-      ret extend_prestate((*get[@ts_ann](ts_a)).states.prestate, pre);\n+      assert (! is_none[@ts_ann](ts_a));\n+      ret extend_prestate((get[@ts_ann](ts_a)).states.prestate, pre);\n     }\n     case (ann_none) {\n       log(\"set_prestate_ann: expected an ann_type here\");\n@@ -1428,8 +1322,8 @@ fn extend_prestate_ann(ann a, prestate pre) -> bool {\n fn set_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      check (! is_none[@ts_ann](ts_a));\n-      ret set_poststate(*get[@ts_ann](ts_a), post);\n+      assert (! is_none[@ts_ann](ts_a));\n+      ret set_poststate(get[@ts_ann](ts_a), post);\n     }\n     case (ann_none) {\n       log(\"set_poststate_ann: expected an ann_type here\");\n@@ -1441,7 +1335,7 @@ fn set_poststate_ann(ann a, poststate post) -> bool {\n fn extend_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n     case (ann_type(_,_,?ts_a)) {\n-      check (! is_none[@ts_ann](ts_a));\n+      assert (! is_none[@ts_ann](ts_a));\n       ret extend_poststate((*get[@ts_ann](ts_a)).states.poststate, post);\n     }\n     case (ann_none) {\n@@ -1454,7 +1348,7 @@ fn extend_poststate_ann(ann a, poststate post) -> bool {\n fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     alt (a) {\n         case (ann_type(_,_,?ts_a)) {\n-            check (! is_none[@ts_ann](ts_a));\n+            assert (! is_none[@ts_ann](ts_a));\n             auto t = *get[@ts_ann](ts_a);\n             /*  log(\"set_pre_and_post, old =\");\n             log_pp(t.conditions);\n@@ -1478,7 +1372,7 @@ fn seq_states(&fn_info_map fm, &fn_info enclosing,\n \n   for (@expr e in exprs) {\n     changed = find_pre_post_state_expr(fm, enclosing, post, e) || changed;\n-    post = expr_poststate(*e);\n+    post = expr_poststate(e);\n   }\n \n   ret tup(changed, post);\n@@ -1513,16 +1407,16 @@ fn find_pre_post_state_loop(fn_info_map fm, fn_info enclosing,\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n     changed = find_pre_post_state_block(fm, enclosing,\n-                expr_poststate(*index), body) || changed;\n-    auto res_p = intersect_postconds(vec(expr_poststate(*index),\n+                expr_poststate(index), body) || changed;\n+    auto res_p = intersect_postconds(vec(expr_poststate(index),\n                                          block_poststate(body)));\n   \n     changed = extend_poststate_ann(a, res_p) || changed;\n     ret changed;\n }\n \n fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n-                            &prestate pres, &@expr e) -> bool {\n+                            &prestate pres, @expr e) -> bool {\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n@@ -1540,20 +1434,20 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         || changed;\n       /* rands go left-to-right */\n       ret(find_pre_post_state_exprs(fm, enclosing,\n-                                    expr_poststate(*operator), a, operands)\n+                                    expr_poststate(operator), a, operands)\n           || changed);\n     }\n     case (expr_spawn(_, _, ?operator, ?operands, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operator);\n         ret(find_pre_post_state_exprs(fm, enclosing,\n-                 expr_poststate(*operator), a, operands)\n+                 expr_poststate(operator), a, operands)\n           || changed);\n     }\n     case (expr_bind(?operator, ?maybe_args, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n             || changed;\n         ret (find_pre_post_state_exprs(fm, enclosing,\n-          expr_poststate(*operator), a, cat_options[@expr](maybe_args))\n+          expr_poststate(operator), a, cat_options[@expr](maybe_args))\n             || changed);\n     }\n     case (expr_path(_,_,?a)) {\n@@ -1563,19 +1457,19 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         /* factor out the \"one exp\" pattern */\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_chan(?e, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_ext(_, _, _, ?expanded, ?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, expanded);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*expanded))\n+        changed = extend_poststate_ann(a, expr_poststate(expanded))\n            || changed;\n         ret changed;\n     }\n@@ -1584,7 +1478,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             case (some[@expr](?arg)) {\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, arg);\n                 changed = extend_prestate_ann(a, pres) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*arg))\n+                changed = extend_poststate_ann(a, expr_poststate(arg))\n                     || changed;\n                 ret changed;\n             }\n@@ -1611,7 +1505,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             case (some[@expr](?base)) {\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, base)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*base))\n+                changed = extend_poststate_ann(a, expr_poststate(base))\n                     || changed;\n             }\n         }\n@@ -1626,7 +1520,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = pure_exp(a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, d_id) || changed;\n             }\n@@ -1635,8 +1529,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(*lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                     expr_poststate(lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n                     || changed;\n             }\n         }\n@@ -1651,7 +1545,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = pure_exp(a_lhs, pres) || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, rhs)\n                     || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, d_id) || changed;\n             }\n@@ -1660,8 +1554,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(*lhs), rhs) || changed;\n-                changed = extend_poststate_ann(a, expr_poststate(*rhs))\n+                     expr_poststate(lhs), rhs) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(rhs))\n                     || changed;\n             }\n         }\n@@ -1691,17 +1585,17 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, antec)\n             || changed;\n         changed = find_pre_post_state_block(fm, enclosing,\n-          expr_poststate(*antec), conseq) || changed;\n+          expr_poststate(antec), conseq) || changed;\n         alt (maybe_alt) {\n             case (none[@expr]) {\n-                changed = extend_poststate_ann(a, expr_poststate(*antec))\n+                changed = extend_poststate_ann(a, expr_poststate(antec))\n                     || changed;\n             }\n             case (some[@expr](?altern)) {\n                 changed = find_pre_post_state_expr(fm, enclosing,\n-                   expr_poststate(*antec), altern) || changed;\n+                   expr_poststate(antec), altern) || changed;\n                 auto poststate_res = intersect_postconds\n-                    (vec(block_poststate(conseq), expr_poststate(*altern)));\n+                    (vec(block_poststate(conseq), expr_poststate(altern)));\n                 changed = extend_poststate_ann(a, poststate_res) || changed;\n             }\n         }\n@@ -1710,7 +1604,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         log(\"new prestate:\");\n         log_bitv(enclosing, pres);\n         log(\"new poststate:\");\n-        log_bitv(enclosing, expr_poststate(*e));\n+        log_bitv(enclosing, expr_poststate(e));\n \n         ret changed;\n     }\n@@ -1720,17 +1614,17 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(*l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n+                    enclosing, expr_poststate(l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n         ret changed;\n     }\n     case (expr_send(?l, ?r, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing, pres, l)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(*l), r) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n+                    enclosing, expr_poststate(l), r) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(r)) || changed;\n         ret changed;\n     }\n     case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n@@ -1739,8 +1633,8 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n                     || changed;\n         changed = find_pre_post_state_expr(fm,\n-                    enclosing, expr_poststate(*lhs), rhs) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*rhs)) || changed;\n+                    enclosing, expr_poststate(lhs), rhs) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(rhs)) || changed;\n         ret changed;\n     }\n     case (expr_while(?test, ?body, ?a)) {\n@@ -1756,9 +1650,9 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = find_pre_post_state_expr(fm, enclosing, pres, test)\n             || changed;\n         changed = find_pre_post_state_block(fm, \n-                   enclosing, expr_poststate(*test), body) || changed; \n+                   enclosing, expr_poststate(test), body) || changed; \n         changed = extend_poststate_ann(a,\n-                    intersect_postconds(vec(expr_poststate(*test),\n+                    intersect_postconds(vec(expr_poststate(test),\n                                         block_poststate(body)))) || changed;\n         ret changed;\n     }\n@@ -1777,7 +1671,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n             changed = set_poststate_ann(a, pres) || changed;\n         }\n         else {\n-            changed = extend_poststate_ann(a, expr_poststate(*test))\n+            changed = extend_poststate_ann(a, expr_poststate(test))\n               || changed;\n         }\n \n@@ -1793,14 +1687,14 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing,\n-                     expr_poststate(*e), sub) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*sub));\n+                     expr_poststate(e), sub) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(sub));\n         ret changed;\n     }\n     case (expr_alt(?e, ?alts, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-        auto e_post = expr_poststate(*e);\n+        auto e_post = expr_poststate(e);\n         auto a_post;\n         if (_vec.len[arm](alts) > 0u) {\n             a_post = false_postcond(num_local_vars);\n@@ -1821,22 +1715,22 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     case (expr_field(?e,_,?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(e)) || changed;\n         ret changed;\n     }\n     case (expr_unary(_,?operand,?a)) {\n         changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*operand))\n+        changed = extend_poststate_ann(a, expr_poststate(operand))\n           || changed;\n         ret changed;\n     }\n     case (expr_cast(?operand, _, ?a)) {\n            changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n           || changed;\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = extend_poststate_ann(a, expr_poststate(*operand))\n+        changed = extend_poststate_ann(a, expr_poststate(operand))\n           || changed;\n         ret changed;\n     }\n@@ -1845,14 +1739,15 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         /* if execution continues after fail, then everything is true! woo! */\n         changed = set_poststate_ann(a, false_postcond(num_local_vars))\n           || changed;\n-        /*        log_err(\"fail: poststate = \");\n-                  log_bitv(enclosing, expr_poststate(*e)); */\n         ret changed;\n     }\n-    case (expr_check_expr(?p, ?a)) {\n+    case (expr_assert(?p, ?a)) {\n+        ret pure_exp(a, pres);\n+    }\n+    case (expr_check(?p, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = find_pre_post_state_expr(fm, enclosing, pres, p) || changed;\n-        /* p is pure, so the poststate must be the same as the prestate */\n+        /* FIXME: update the postcondition to reflect that p holds */\n         changed = extend_poststate_ann(a, pres) || changed;\n         ret changed;\n     }\n@@ -1875,7 +1770,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, @stmt s) -> bool {\n   auto changed = false;\n   auto stmt_ann_ = stmt_to_ann(*s);\n-  check (!is_none[@ts_ann](stmt_ann_));\n+  assert (!is_none[@ts_ann](stmt_ann_));\n   auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n               log(\"*At beginning: stmt = \");\n               log_stmt(*s);\n@@ -1897,7 +1792,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n                 changed = find_pre_post_state_expr\n                     (fm, enclosing, pres, an_init.expr) || changed;\n                 changed = extend_poststate(stmt_ann.states.poststate,\n-                                           expr_poststate(*an_init.expr))\n+                                           expr_poststate(an_init.expr))\n                     || changed;\n                 changed = gen_poststate(enclosing, a, alocal.id) || changed;\n               log(\"Summary: stmt = \");\n@@ -1932,10 +1827,10 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n     }\n     case (stmt_expr(?e, _)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(*e))\n+      changed = extend_prestate(stmt_ann.states.prestate, expr_prestate(e))\n           || changed;\n       changed = extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(*e)) || changed;\n+                                 expr_poststate(e)) || changed;\n       /*\n                     log(\"Summary: stmt = \");\n               log_stmt(*s);\n@@ -1980,7 +1875,7 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n     case (none[@expr]) {}\n     case (some[@expr](?e)) {\n       changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n-      post = expr_poststate(*e);\n+      post = expr_poststate(e);\n     }\n   }\n \n@@ -2038,13 +1933,13 @@ fn fixed_point_states(fn_info_map fm, fn_info f_info,\n   }\n }\n \n-fn check_states_expr(fn_info enclosing, &expr e) -> () {\n+fn check_states_expr(fn_info enclosing, @expr e) -> () {\n   let precond prec    = expr_precond(e);\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n       log_err(\"check_states_expr: Unsatisfied precondition constraint for \");\n-      log_expr_err(e);\n+      log_expr_err(*e);\n       log_err(\"Precondition: \");\n       log_bitv_err(enclosing, prec);\n       log_err(\"Prestate: \");\n@@ -2093,7 +1988,7 @@ fn check_states_against_conditions(fn_info enclosing, &ast._fn f) -> () {\n  \n   _vec.map[@stmt, ()](do_one, f.body.node.stmts);\n   fn do_inner_(fn_info i, &@expr e) -> () {\n-    check_states_expr(i, *e);\n+    check_states_expr(i, e);\n   }\n   auto do_inner = bind do_inner_(enclosing, _);\n   option.map[@expr, ()](do_inner, f.body.node.expr);\n@@ -2116,7 +2011,7 @@ fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n                        ann a) -> @item {\n \n   /* Look up the var-to-bit-num map for this function */\n-  check(f_info_map.contains_key(id));\n+  assert (f_info_map.contains_key(id));\n   auto f_info = f_info_map.get(id);\n \n   check_fn_states(f_info_map, f_info, f);\n@@ -2126,7 +2021,7 @@ fn check_item_fn_state(&fn_info_map f_info_map, &span sp, ident i,\n }\n \n fn check_method_states(&fn_info_map f_info_map, @method m) -> () {\n-    check (f_info_map.contains_key(m.node.id));\n+    assert (f_info_map.contains_key(m.node.id));\n     auto f_info = f_info_map.get(m.node.id);\n     check_fn_states(f_info_map, f_info, m.node.meth);\n }\n@@ -2193,7 +2088,7 @@ fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n                 vec[ast.ty_param] ty_params, def_id id, ann a) -> @item {\n \n-    check(fm.contains_key(id));\n+    assert (fm.contains_key(id));\n     auto f_info = fm.get(id);\n \n     log(i + \" has \" + uistr(num_locals(f_info)) + \" local vars\");\n@@ -2413,8 +2308,11 @@ fn annotate_expr(&fn_info_map fm, &@expr e) -> @expr {\n         case (expr_log(?n, ?e, ?a)) {\n             e1 = expr_log(n, annotate_expr(fm, e), a);\n         }\n-        case (expr_check_expr(?e, ?a)) {\n-            e1 = expr_check_expr(annotate_expr(fm, e), a);\n+        case (expr_assert(?e, ?a)) {\n+            e1 = expr_assert(annotate_expr(fm, e), a);\n+        }\n+        case (expr_check(?e, ?a)) {\n+            e1 = expr_check(annotate_expr(fm, e), a);\n         }\n         case (expr_port(_)) { /* no change */ }\n         case (expr_chan(?e, ?a)) {"}, {"sha": "8a5d40dc563c40e537e9bbc3d781ae90cff5c41b", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -392,7 +392,10 @@ fn walk_expr(&ast_visitor v, @ast.expr e) {\n         case (ast.expr_log(_,?x, _)) {\n             walk_expr(v, x);\n         }\n-        case (ast.expr_check_expr(?x, _)) {\n+        case (ast.expr_check(?x, _)) {\n+            walk_expr(v, x);\n+        }\n+        case (ast.expr_assert(?x, _)) {\n             walk_expr(v, x);\n         }\n         case (ast.expr_port(_)) { }"}, {"sha": "7ef91ce89e4f92afe7f1646b12f516b37c8e0fd7", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -661,12 +661,18 @@ fn print_expr(ps s, &@ast.expr expr) {\n             }\n             print_expr(s, expr);\n         }\n-        case (ast.expr_check_expr(?expr,_)) {\n+        case (ast.expr_check(?expr,_)) {\n             wrd1(s, \"check\");\n             popen_h(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n+        case (ast.expr_assert(?expr,_)) {\n+            wrd1(s, \"assert\");\n+            popen_h(s);\n+            print_expr(s, expr);\n+            pclose(s);\n+        }\n         case (ast.expr_ext(?path, ?args, ?body, _, _)) {\n             wrd(s.s, \"#\");\n             print_path(s, path);"}, {"sha": "9e815b464849717ad7d41e0d6ae720e48b5680b3", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -85,7 +85,7 @@ fn intersect(&precond p1, &precond p2) -> bool {\n \n fn pps_len(&pre_and_post p) -> uint {\n   // gratuitous check\n-  check (p.precondition.nbits == p.postcondition.nbits);\n+  assert (p.precondition.nbits == p.postcondition.nbits);\n   ret p.precondition.nbits;\n }\n \n@@ -129,7 +129,7 @@ fn set_prestate(@ts_ann a, &prestate p) -> bool {\n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_poststate(&ts_ann a, &poststate p) -> bool {\n+fn set_poststate(@ts_ann a, &poststate p) -> bool {\n   ret bitv.copy(a.states.poststate, p);\n }\n "}, {"sha": "368fe21710ed7e84c0fb523185c32cda7ae480ef", "filename": "src/lib/Term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2FTerm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2FTerm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2FTerm.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -35,7 +35,7 @@ fn color_supported() -> bool {\n }\n \n fn set_color(io.buf_writer writer, u8 first_char, u8 color) {\n-    check (color < 16u8);\n+    assert (color < 16u8);\n \n     esc(writer);\n     if (color >= 8u8) {"}, {"sha": "1824d142dab793d437e92a7b95fcfea1930f94ca", "filename": "src/lib/_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -27,7 +27,7 @@ iter range(int lo, int hi) -> int {\n \n fn to_str(int n, uint radix) -> str\n {\n-    check (0u < radix && radix <= 16u);\n+    assert (0u < radix && radix <= 16u);\n     if (n < 0) {\n         ret \"-\" + _uint.to_str((-n) as uint, radix);\n     } else {"}, {"sha": "ed2027e1da29a4fc97be54037aa9d9edf1592203", "filename": "src/lib/_str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -218,14 +218,14 @@ fn utf8_char_width(u8 b) -> uint {\n fn char_range_at(str s, uint i) -> tup(char, uint) {\n     auto b0 = s.(i);\n     auto w = utf8_char_width(b0);\n-    check(w != 0u);\n+    assert (w != 0u);\n     if (w == 1u) {ret tup(b0 as char, i + 1u);}\n     auto val = 0u;\n     auto end = i + w;\n     i += 1u;\n     while (i < end) {\n         auto byte = s.(i);\n-        check(byte & 0xc0_u8 == tag_cont_u8);\n+        assert (byte & 0xc0_u8 == tag_cont_u8);\n         val <<= 6u;\n         val += (byte & 0x3f_u8) as uint;\n         i += 1u;\n@@ -247,11 +247,11 @@ fn char_len(str s) -> uint {\n     auto total = byte_len(s);\n     while (i < total) {\n         auto chsize = utf8_char_width(s.(i));\n-        check(chsize > 0u);\n+        assert (chsize > 0u);\n         len += 1u;\n         i += chsize;\n     }\n-    check(i == total);\n+    assert (i == total);\n     ret len;\n }\n \n@@ -274,7 +274,7 @@ fn push_char(&mutable str s, char ch) {\n fn pop_char(&mutable str s) -> char {\n     auto end = byte_len(s);\n     while (end > 0u && s.(end - 1u) & 0xc0_u8 == tag_cont_u8) {end -= 1u;}\n-    check(end > 0u);\n+    assert (end > 0u);\n     auto ch = char_at(s, end - 1u);\n     s = substr(s, 0u, end - 1u);\n     ret ch;\n@@ -404,15 +404,15 @@ fn slice(str s, uint begin, uint end) -> str {\n \n fn shift_byte(&mutable str s) -> u8 {\n     auto len = byte_len(s);\n-    check(len > 0u);\n+    assert (len > 0u);\n     auto b = s.(0);\n     s = substr(s, 1u, len - 1u);\n     ret b;\n }\n \n fn pop_byte(&mutable str s) -> u8 {\n     auto len = byte_len(s);\n-    check(len > 0u);\n+    assert (len > 0u);\n     auto b = s.(len - 1u);\n     s = substr(s, 0u, len - 1u);\n     ret b;"}, {"sha": "2d373cdd2babc778c886a6e9975d770c3b42beff", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -56,7 +56,7 @@ fn to_str(uint num, uint radix) -> str\n {\n     auto n = num;\n \n-    check (0u < radix && radix <= 16u);\n+    assert (0u < radix && radix <= 16u);\n     fn digit(uint n) -> char {\n         alt (n) {\n             case (0u) { ret '0'; }"}, {"sha": "4761a867494df125c366f42589c05e6218cc71ea", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -131,7 +131,7 @@ fn len_set[T](array[T] v, uint n) {\n }\n \n fn buf_off[T](array[T] v, uint offset) -> vbuf {\n-    check (offset < len[T](v));\n+     assert (offset < len[T](v));\n     ret rustrt.vec_buf[T](v, offset);\n }\n \n@@ -149,9 +149,10 @@ fn last[T](array[T] v) -> option.t[T] {\n }\n \n // Returns elements from [start..end) from v.\n+\n fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n-    check (start <= end);\n-    check (end <= len[T](v));\n+    assert (start <= end);\n+    assert (end <= len[T](v));\n     auto result = alloc[T](end - start);\n     let uint i = start;\n     while (i < end) {\n@@ -163,15 +164,15 @@ fn slice[T](array[T] v, uint start, uint end) -> vec[T] {\n \n fn shift[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n-    check(ln > 0u);\n+    assert (ln > 0u);\n     auto e = v.(0);\n     v = slice[T](v, 1u, ln);\n     ret e;\n }\n \n fn pop[T](&mutable array[T] v) -> T {\n     auto ln = len[T](v);\n-    check(ln > 0u);\n+    assert (ln > 0u);\n     ln -= 1u;\n     auto e = v.(ln);\n     v = slice[T](v, 0u, ln);"}, {"sha": "f52b016b7688339a7804bd42e70630a372031084", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -28,8 +28,8 @@ fn create(uint nbits, bool init) -> t {\n fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n     auto len = _vec.len[mutable uint](v1.storage);\n \n-    check (_vec.len[mutable uint](v0.storage) == len);\n-    check (v0.nbits == v1.nbits);\n+    assert (_vec.len[mutable uint](v0.storage) == len);\n+    assert (v0.nbits == v1.nbits);\n \n     auto changed = false;\n \n@@ -84,7 +84,7 @@ fn clone(t v) -> t {\n }\n \n fn get(&t v, uint i) -> bool {\n-    check (i < v.nbits);\n+    assert (i < v.nbits);\n \n     auto bits = uint_bits();\n \n@@ -129,7 +129,7 @@ fn difference(&t v0, &t v1) -> bool {\n }\n \n fn set(&t v, uint i, bool x) {\n-    check (i < v.nbits);\n+    assert (i < v.nbits);\n \n     auto bits = uint_bits();\n \n@@ -196,7 +196,7 @@ fn to_str(&t v) -> str {\n \n // FIXME: can we just use structural equality on to_vec?\n fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n-    check (v0.nbits == _vec.len[uint](v1));\n+    assert (v0.nbits == _vec.len[uint](v1));\n     auto len = v0.nbits;\n     auto i = 0u;\n     while (i < len) {"}, {"sha": "ee706ae7e7d1b427e5b03c99b4f5d77e7e3e10bd", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -28,7 +28,7 @@ fn create[T]() -> t[T] {\n      * elsewhere.\n      */\n     fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        check (nelts == _vec.len[cell[T]](elts));\n+        assert (nelts == _vec.len[cell[T]](elts));\n \n         fn fill[T](uint i, uint nelts, uint lo,\n                    vec[cell[T]] old) -> cell[T] {"}, {"sha": "9bad0f3311d8c59c0e39b18dbf4860b34d3d310f", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -99,7 +99,7 @@ fn doc_data(doc d) -> vec[u8] {\n \n fn be_uint_from_bytes(vec[u8] data, uint start, uint size) -> uint {\n     auto sz = size;\n-    check (sz <= 4u);\n+    assert (sz <= 4u);\n     auto val = 0u;\n     auto pos = start;\n     while (sz > 0u) {"}, {"sha": "e185ca3e8c25c3fcdd04db8068fa61fef1850f75", "filename": "src/lib/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -10,7 +10,7 @@ type path = str;\n \n fn dirname(path p) -> path {\n     auto sep = path_sep();\n-    check (_str.byte_len(sep) == 1u);\n+    assert (_str.byte_len(sep) == 1u);\n     let int i = _str.rindex(p, sep.(0));\n     if (i == -1) {\n         ret p;"}, {"sha": "7d59da30400860601d37308607a251d97450bfc5", "filename": "src/lib/io.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -72,7 +72,7 @@ state obj FILE_buf_reader(os.libc.FILE f, bool must_close) {\n         ret os.libc.feof(f) != 0;\n     }\n     fn seek(int offset, seek_style whence) {\n-        check (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n     fn tell() -> uint {\n         ret os.libc.ftell(f) as uint;\n@@ -101,14 +101,14 @@ state obj new_reader(buf_reader rdr) {\n         if (c0 == -1) {ret -1 as char;} // FIXME will this stay valid?\n         auto b0 = c0 as u8;\n         auto w = _str.utf8_char_width(b0);\n-        check(w > 0u);\n+        assert (w > 0u);\n         if (w == 1u) {ret b0 as char;}\n         auto val = 0u;\n         while (w > 1u) {\n             w -= 1u;\n             auto next = rdr.read_byte();\n-            check(next > -1);\n-            check(next & 0xc0 == 0x80);\n+            assert (next > -1);\n+            assert (next & 0xc0 == 0x80);\n             val <<= 6u;\n             val += (next & 0x3f) as uint;\n         }\n@@ -279,7 +279,7 @@ state obj FILE_writer(os.libc.FILE f, bool must_close) {\n     }\n \n     fn seek(int offset, seek_style whence) {\n-        check(os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n+        assert (os.libc.fseek(f, offset, convert_whence(whence)) == 0);\n     }\n \n     fn tell() -> uint {"}, {"sha": "d2a8ff97aafade29315959fd52bef4cb11eca001", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -66,7 +66,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    check(os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n+    assert (os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n@@ -76,7 +76,7 @@ fn fd_FILE(int fd) -> libc.FILE {\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    check(os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n+    assert (os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "a52b02c5658e507d9995f0695aabf9ba5fa2a882", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -63,7 +63,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    check(os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n+    assert (os.libc.pipe(_vec.buf[mutable int](fds)) == 0);\n     ret tup(fds.(0), fds.(1));\n }\n \n@@ -73,7 +73,7 @@ fn fd_FILE(int fd) -> libc.FILE {\n \n fn waitpid(int pid) -> int {\n     let vec[mutable int] status = vec(mutable 0);\n-    check(os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n+    assert (os.libc.waitpid(pid, _vec.buf[mutable int](status), 0) != -1);\n     ret status.(0);\n }\n "}, {"sha": "f4cf12d35f2990d139e23a6e801be43f70c33779", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ native \"rust\" mod rustrt {\n fn list_dir(str path) -> vec[str] {\n   // TODO ensure this is always closed\n   auto dir = os.libc.opendir(_str.buf(path));\n-  check (dir as uint != 0u);\n+  assert (dir as uint != 0u);\n   let vec[str] result = vec();\n   while (true) {\n     auto ent = os.libc.readdir(dir);"}, {"sha": "690489db345faf08f2b5cb7d9e0ffbb0edbad681", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -43,7 +43,7 @@ fn mk_sha1() -> sha1 {\n \n     fn add_input(&sha1state st, &vec[u8] msg) {\n         // FIXME: Should be typestate precondition\n-        check (!st.computed);\n+        assert (!st.computed);\n \n         for (u8 element in msg) {\n             st.msg_block.(st.msg_block_idx) = element;\n@@ -67,7 +67,7 @@ fn mk_sha1() -> sha1 {\n     fn process_msg_block(&sha1state st) {\n \n         // FIXME: Make precondition\n-        check (_vec.len[mutable u32](st.h) == digest_buf_len);\n+        assert (_vec.len[mutable u32](st.h) == digest_buf_len);\n \n         // Constants\n         auto k = vec(0x5A827999u32,\n@@ -192,7 +192,7 @@ fn mk_sha1() -> sha1 {\n      */\n     fn pad_msg(&sha1state st) {\n         // FIXME: Should be a precondition\n-        check (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n+        assert (_vec.len[mutable u8](st.msg_block) == msg_block_len);\n \n         /*\n          * Check to see if the current message block is too small to hold\n@@ -236,7 +236,7 @@ fn mk_sha1() -> sha1 {\n \n         fn reset() {\n             // FIXME: Should be typestate precondition\n-            check (_vec.len[mutable u32](st.h) == digest_buf_len);\n+            assert (_vec.len[mutable u32](st.h) == digest_buf_len);\n \n             st.len_low = 0u32;\n             st.len_high = 0u32;"}, {"sha": "1c6521e31f699a4d358770a57afe9843d5e508d3", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -53,7 +53,7 @@ fn dylib_filename(str base) -> str {\n \n fn pipe() -> tup(int, int) {\n     let vec[mutable int] fds = vec(mutable 0, 0);\n-    check(os.libc._pipe(_vec.buf[mutable int](fds), 1024u,\n+    assert (os.libc._pipe(_vec.buf[mutable int](fds), 1024u,\n                         libc_constants.O_BINARY()) == 0);\n     ret tup(fds.(0), fds.(1));\n }"}, {"sha": "c688a40426d563b0da60e5f223f2737bd9038b56", "filename": "src/test/run-fail/fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,5 +2,5 @@\n // error-pattern:1 == 2\n \n fn main() {\n-   check (1 == 2);\n+   assert (1 == 2);\n }"}, {"sha": "60e82200848a0c1f6bb2fb0c02b2929eba5e38eb", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,7 +4,7 @@\n // error-pattern:1 == 2\n \n fn child() {\n-  check (1 == 2);\n+  assert (1 == 2);\n }\n \n fn main() {"}, {"sha": "68b1e263d27fa279633ab04ca1edb250f6427a02", "filename": "src/test/run-fail/str-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,12 +6,12 @@\n fn main() {\n   let str s = \"hello\";\n   let int x = 0;\n-  check (s.(x) == (0x68 as u8));\n+  assert (s.(x) == (0x68 as u8));\n \n   // NB: at the moment a string always has a trailing NULL,\n   // so the largest index value on the string above is 5, not\n   // 4. Possibly change this.\n \n   // Bounds-check failure.\n-  check (s.(x + 6) == (0x0 as u8));\n+  assert (s.(x + 6) == (0x0 as u8));\n }"}, {"sha": "810feb39bcd9e502ed614514d86102303e5b6e3d", "filename": "src/test/run-fail/vec-overrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,7 +6,7 @@\n fn main() {\n   let vec[int] v = vec(10);\n   let int x = 0;\n-  check (v.(x) == 10);\n+  assert (v.(x) == 10);\n   // Bounds-check failure.\n-  check (v.(x + 2) == 20);\n+  assert (v.(x + 2) == 20);\n }"}, {"sha": "f1998da52932116df5fdf49480b5f01a432dc8aa", "filename": "src/test/run-fail/vec-underrun.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,7 +6,7 @@\n fn main() {\n   let vec[int] v = vec(10, 20);\n   let int x = 0;\n-  check (v.(x) == 10);\n+  assert (v.(x) == 10);\n   // Bounds-check failure.\n-  check (v.(x-1) == 20);\n+  assert (v.(x-1) == 20);\n }"}, {"sha": "b92ffd7481bda28a65a5b176e1ff0e0f50dcda52", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -21,12 +21,12 @@ fn foo(str s) {\n   }\n \n   log _str.refcount(s);\n-  check (_str.refcount(s) == const_refcount);\n+  assert (_str.refcount(s) == const_refcount);\n }\n \n fn main() {\n   let str s = \"hi\";     // ref up\n   foo(s);               // ref up then down\n   log _str.refcount(s);\n-  check (_str.refcount(s) == const_refcount);\n+  assert (_str.refcount(s) == const_refcount);\n }"}, {"sha": "bad74a2a3cefd13c7aeabf575de259bf4a2905c0", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -12,6 +12,6 @@ fn altlit(int f) -> int {\n }\n \n fn main() {\n-  check (altlit(10) == 20);\n-  check (altlit(11) == 22);\n+  assert (altlit(10) == 20);\n+  assert (altlit(11) == 22);\n }"}, {"sha": "bc0afcb5fec4873fc541f6c8c98878e305da5ba4", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -32,8 +32,8 @@ fn main() {\n   let color gray = rgb(127, 127, 127);\n   let color clear = rgba(50, 150, 250, 0);\n   let color red = hsl(0, 255, 255);\n-  check (process(gray) == 127);\n-  check (process(clear) == 0);\n-  check (process(red) == 255);\n+  assert (process(gray) == 127);\n+  assert (process(clear) == 0);\n+  assert (process(red) == 255);\n }\n "}, {"sha": "857eaa8e42a7dbbf6467fdc547cd518a77567a44", "filename": "src/test/run-pass/arith-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-0.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,5 +1,5 @@\n fn main() -> () {\n     let int a = 10;\n     log a;\n-    check (a * (a - 1) == 90);\n+    assert (a * (a - 1) == 90);\n }\n\\ No newline at end of file"}, {"sha": "55230e9e5dac58df2a560781f9fcb525da226c3c", "filename": "src/test/run-pass/arith-1.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,22 +1,22 @@\n fn main() -> () {\n     let int i32_a = 10;\n-    check(i32_a == 10);\n-    check(i32_a - 10 == 0);\n-    check(i32_a / 10 == 1);\n-    check(i32_a - 20 == -10);\n-    check(i32_a << 10 == 10240);\n-    check(i32_a << 16 == 655360);\n-    check(i32_a * 16 == 160);\n-    check(i32_a * i32_a * i32_a == 1000);\n-    check(i32_a * i32_a * i32_a * i32_a == 10000);\n-    check(((i32_a * i32_a) / i32_a) * i32_a == 100);\n-    check(i32_a * (i32_a - 1) << 2 + i32_a == 368640);\n+    assert (i32_a == 10);\n+    assert (i32_a - 10 == 0);\n+    assert (i32_a / 10 == 1);\n+    assert (i32_a - 20 == -10);\n+    assert (i32_a << 10 == 10240);\n+    assert (i32_a << 16 == 655360);\n+    assert (i32_a * 16 == 160);\n+    assert (i32_a * i32_a * i32_a == 1000);\n+    assert (i32_a * i32_a * i32_a * i32_a == 10000);\n+    assert (((i32_a * i32_a) / i32_a) * i32_a == 100);\n+    assert (i32_a * (i32_a - 1) << 2 + i32_a == 368640);\n \n     let int i32_b = 0x10101010;\n-    check(i32_b + 1 - 1 == i32_b);\n-    check(i32_b << 1 == i32_b << 1);\n-    check(i32_b >> 1 == i32_b >> 1);\n-    check((i32_b & (i32_b << 1)) == 0);\n+    assert (i32_b + 1 - 1 == i32_b);\n+    assert (i32_b << 1 == i32_b << 1);\n+    assert (i32_b >> 1 == i32_b >> 1);\n+    assert ((i32_b & (i32_b << 1)) == 0);\n     log ((i32_b | (i32_b << 1)));\n-    check((i32_b | (i32_b << 1)) == 0x30303030);\n+    assert ((i32_b | (i32_b << 1)) == 0x30303030);\n }\n\\ No newline at end of file"}, {"sha": "70892682b777db558eaded687d937a3fd4ce6f9f", "filename": "src/test/run-pass/arith-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,5 +1,5 @@\n fn main() -> () {\n     let int i32_c = 0x10101010;\n-    check (i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) == \n+    assert (i32_c + i32_c * 2 / 3 * 2 + (i32_c - 7 % 3) == \n            i32_c + (((i32_c * 2) / 3) * 2) + (i32_c - (7 % 3)));\n }\n\\ No newline at end of file"}, {"sha": "0e2818a3a45da0ffd2b85cf9043644ac3cdb7929", "filename": "src/test/run-pass/arith-unsigned.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farith-unsigned.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,24 +2,24 @@\n // Unsigned integer operations\n \n fn main() {\n-  check (0u8 < 255u8);\n-  check (0u8 <= 255u8);\n-  check (255u8 > 0u8);\n-  check (255u8 >= 0u8);\n-  check (250u8 / 10u8 == 25u8);\n-  check (255u8 % 10u8 == 5u8);\n-  check (0u16 < 60000u16);\n-  check (0u16 <= 60000u16);\n-  check (60000u16 > 0u16);\n-  check (60000u16 >= 0u16);\n-  check (60000u16 / 10u16 == 6000u16);\n-  check (60005u16 % 10u16 == 5u16);\n-  check (0u32 < 4000000000u32);\n-  check (0u32 <= 4000000000u32);\n-  check (4000000000u32 > 0u32);\n-  check (4000000000u32 >= 0u32);\n-  check (4000000000u32 / 10u32 == 400000000u32);\n-  check (4000000005u32 % 10u32 == 5u32);\n+  assert (0u8 < 255u8);\n+  assert (0u8 <= 255u8);\n+  assert (255u8 > 0u8);\n+  assert (255u8 >= 0u8);\n+  assert (250u8 / 10u8 == 25u8);\n+  assert (255u8 % 10u8 == 5u8);\n+  assert (0u16 < 60000u16);\n+  assert (0u16 <= 60000u16);\n+  assert (60000u16 > 0u16);\n+  assert (60000u16 >= 0u16);\n+  assert (60000u16 / 10u16 == 6000u16);\n+  assert (60005u16 % 10u16 == 5u16);\n+  assert (0u32 < 4000000000u32);\n+  assert (0u32 <= 4000000000u32);\n+  assert (4000000000u32 > 0u32);\n+  assert (4000000000u32 >= 0u32);\n+  assert (4000000000u32 / 10u32 == 400000000u32);\n+  assert (4000000005u32 % 10u32 == 5u32);\n \n   // 64-bit numbers have some flakiness yet. Not tested\n }"}, {"sha": "5df5456b773eed9454d8a78c79e419102898aa81", "filename": "src/test/run-pass/autoderef-full-lval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-full-lval.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,11 +8,11 @@ fn main() {\n   let clam b = rec(x=@10, y=@20);\n   let int z = a.x + b.y;\n   log z;\n-  check (z == 21);\n+  assert (z == 21);\n \n   let fish forty = tup(@40);\n   let fish two = tup(@2);\n   let int answer = forty._0 + two._0;\n   log answer;\n-  check (answer == 42);\n+  assert (answer == 42);\n }"}, {"sha": "f6f369185fc7a07ef289d58cb992138ccbea46c9", "filename": "src/test/run-pass/bind-exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-exterior.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,5 +4,5 @@ fn foo(@int a, @int b) -> int {\n \n fn main() {\n   auto f1 = bind foo(@10, @12);\n-  check(f1() == 22);\n+  assert (f1() == 22);\n }"}, {"sha": "ae994d1c7ab8115259dd0af8e07e90b93aac7986", "filename": "src/test/run-pass/bind-interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-interior.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,5 +7,5 @@ fn f(int n) -> int {\n fn main() {\n   let fn() -> int g = bind f(10);\n   let int i = g();\n-  check(i == 10);\n+  assert (i == 10);\n }"}, {"sha": "b5215f9ad68870488b3952934fb5faaf6ef4345e", "filename": "src/test/run-pass/bind-obj-ctor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   auto ctor1 = bind simple(_, 2);\n   auto obj1 = ctor0(2);\n   auto obj2 = ctor1(1);\n-  check (obj0.sum() == 3);\n-  check (obj1.sum() == 3);\n-  check (obj2.sum() == 3);\n+  assert (obj0.sum() == 3);\n+  assert (obj1.sum() == 3);\n+  assert (obj2.sum() == 3);\n }"}, {"sha": "7cafc50108d652c65d39b863950398bc081e0715", "filename": "src/test/run-pass/bind-thunk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-thunk.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,5 +7,5 @@ fn f() -> int {\n fn main() {\n   let fn() -> int g = bind f();\n   let int i = g();\n-  check(i == 42);\n+  assert (i == 42);\n }"}, {"sha": "e73f2b7ca3c8f95fcfa8c88fbe02c289575ef01d", "filename": "src/test/run-pass/bind-trivial.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-trivial.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,5 +7,5 @@ fn f(int n) -> int {\n fn main() {\n   let fn(int) -> int g = bind f(_);\n   let int i = g(42);\n-  check(i == 42);\n+  assert (i == 42);\n }"}, {"sha": "99324489186567b8618c6ec00cebd5a0f79fd85b", "filename": "src/test/run-pass/bitwise.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,14 +8,14 @@ fn main() {\n   a = a ^ b;\n   log a;\n   log b;\n-  check (b == 1);\n-  check (a == 2);\n+  assert (b == 1);\n+  assert (a == 2);\n \n-  check (~(0xf0) & 0xff == 0xf);\n-  check (0xf0 | 0xf == 0xff);\n-  check (0xf << 4 == 0xf0);\n-  check (0xf0 >> 4 == 0xf);\n-  check (-16 >>> 2 == -4);\n-  check (0b1010_1010 | 0b0101_0101 == 0xff);\n+  assert (~(0xf0) & 0xff == 0xf);\n+  assert (0xf0 | 0xf == 0xff);\n+  assert (0xf << 4 == 0xf0);\n+  assert (0xf0 >> 4 == 0xf);\n+  assert (-16 >>> 2 == -4);\n+  assert (0b1010_1010 | 0b0101_0101 == 0xff);\n }\n "}, {"sha": "337efc6f85f9703695db1afb7e0899d8551c5b9a", "filename": "src/test/run-pass/bool-not.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbool-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbool-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbool-not.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,14 +2,14 @@\n \n fn main() {\n   if (!false) {\n-    check (true);\n+    assert (true);\n   } else {\n-    check (false);\n+    assert (false);\n   }\n \n   if (!true) {\n-    check (false);\n+    assert (false);\n   } else {\n-    check (true);\n+    assert (true);\n   }\n }"}, {"sha": "8f23035dbd863fe54d367fe823639a71e0e7c59c", "filename": "src/test/run-pass/box-compare.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-compare.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,6 +1,6 @@\n // xfail-boot\n fn main() {\n-  check (@1 < @3);\n-  check (@@\"hello \" > @@\"hello\");\n-  check (@@@\"hello\" != @@@\"there\");\n+  assert (@1 < @3);\n+  assert (@@\"hello \" > @@\"hello\");\n+  assert (@@@\"hello\" != @@@\"there\");\n }\n\\ No newline at end of file"}, {"sha": "b1d5053360785532e913807e796dcc72778a11d7", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,5 +6,5 @@ fn main() {\n   let int foo = 17;\n   let box[int] bfoo = tup(@foo);\n   log \"see what's in our box\";\n-  check (unbox[int](bfoo) == foo);\n+  assert (unbox[int](bfoo) == foo);\n }"}, {"sha": "c105e80146cc96c5c1979a901f70351ba29f840c", "filename": "src/test/run-pass/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n   let @int x = @10;\n-  check ((*x) == 10);\n+  assert ((*x) == 10);\n }"}, {"sha": "5a63d9acb48c24acfe6633e38746fc3b097549f5", "filename": "src/test/run-pass/break.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbreak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fbreak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbreak.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,35 +6,35 @@ fn main() {\n     i += 1;\n     if (i == 10) { break; }\n   }\n-  check(i == 10);\n+  assert (i == 10);\n \n   do {\n     i += 1;\n     if (i == 20) { break; }\n   } while (i < 30);\n-  check(i == 20);\n+  assert (i == 20);\n \n   for (int x in vec(1, 2, 3, 4, 5, 6)) {\n     if (x == 3) { break; }\n-    check(x <= 3);\n+    assert (x <= 3);\n   }\n \n   i = 0;\n   while (i < 10) {\n     i += 1;\n     if (i % 2 == 0) { cont; }\n-    check(i % 2 != 0);\n+    assert (i % 2 != 0);\n   }\n \n   i = 0;\n   do {\n     i += 1;\n     if (i % 2 == 0) { cont; }\n-    check(i % 2 != 0);\n+    assert (i % 2 != 0);\n   } while (i < 10);\n \n   for (int x in vec(1, 2, 3, 4, 5, 6)) {\n     if (x % 2 == 0) { cont; }\n-    check(x % 2 != 0);\n+    assert (x % 2 != 0);\n   }\n }"}, {"sha": "ecc7ac12db1fcec752d4ce8a2494b0e0f6604481", "filename": "src/test/run-pass/cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,14 +3,14 @@\n \n fn main() {\n   let int i = 'Q' as int;\n-  check (i == 0x51);\n+  assert (i == 0x51);\n   let u32 u = i as u32;\n-  check (u == (0x51 as u32));\n-  check (u == ('Q' as u32));\n-  check ((i as u8) == ('Q' as u8));\n-  check (((i as u8) as i8) == (('Q' as u8) as i8));\n-  check ((0x51 as char) == 'Q');\n+  assert (u == (0x51 as u32));\n+  assert (u == ('Q' as u32));\n+  assert ((i as u8) == ('Q' as u8));\n+  assert (((i as u8) as i8) == (('Q' as u8) as i8));\n+  assert ((0x51 as char) == 'Q');\n \n-  check (true == (1 as bool));\n-  check ((0 as u32) == (false as u32));\n+  assert (true == (1 as bool));\n+  assert ((0 as u32) == (false as u32));\n }"}, {"sha": "a3ddae6c7cb90a019b6a5a2c23997a8273ccd14f", "filename": "src/test/run-pass/char.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,12 +1,12 @@\n fn main() {\n     let char c = 'x';\n     let char d = 'x';\n-    check(c == 'x');\n-    check('x' == c);\n-    check(c == c);\n-    check(c == d);\n-    check(d == c);\n-    check (d == 'x');\n-    check('x' == d);\n+    assert (c == 'x');\n+    assert ('x' == c);\n+    assert (c == c);\n+    assert (c == d);\n+    assert (d == c);\n+    assert (d == 'x');\n+    assert ('x' == d);\n }\n "}, {"sha": "99c319c26d0f3ac40a0f4095a0a477e8646bcd8c", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,8 +1,8 @@\n // xfail-boot\n // xfail-stage0\n fn f(@rec(int a, int b) x) {\n-  check (x.a == 10);\n-  check (x.b == 12);\n+  assert (x.a == 10);\n+  assert (x.b == 12);\n }\n \n fn main() {"}, {"sha": "ef93eee634964048f8270119e5884796d0a1625d", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,7 +8,7 @@ fn main() {\n   y <- p;\n   log \"received\";\n   log y;\n-  check (y == 10);\n+  assert (y == 10);\n }\n \n fn child(chan[int] c) {"}, {"sha": "36487aa83b53f72119c56e9dbe0ccdf58a2d849a", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,9 +6,9 @@ fn main() {\n \n   ch <| 10;\n   let int i <- po;\n-  check (i == 10);\n+  assert (i == 10);\n \n   ch <| 11;\n   auto j <- po;\n-  check (j == 11);\n+  assert (j == 11);\n }"}, {"sha": "32d4dae1fece8c1d3490a8848806275ada95dee6", "filename": "src/test/run-pass/deep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdeep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdeep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -10,5 +10,5 @@ fn f(int x) -> int {\n }\n \n fn main() {\n-  check (f(5000) == 5000);\n+  assert (f(5000) == 5000);\n }"}, {"sha": "00835d41c721073c043cceb8ac30ef1ceed8c460", "filename": "src/test/run-pass/div-mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiv-mod.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,15 +3,15 @@\n fn main() {\n   let int x = 15;\n   let int y = 5;\n-  check(x / 5 == 3);\n-  check(x / 4 == 3);\n-  check(x / 3 == 5);\n-  check(x / y == 3);\n-  check(15 / y == 3);\n+  assert (x / 5 == 3);\n+  assert (x / 4 == 3);\n+  assert (x / 3 == 5);\n+  assert (x / y == 3);\n+  assert (15 / y == 3);\n \n-  check(x % 5 == 0);\n-  check(x % 4 == 3);\n-  check(x % 3 == 0);\n-  check(x % y == 0);\n-  check(15 % y == 0);\n+  assert (x % 5 == 0);\n+  assert (x % 4 == 3);\n+  assert (x % 3 == 0);\n+  assert (x % y == 0);\n+  assert (15 % y == 0);\n }"}, {"sha": "edb25e16f73c402be39ba2901e9ce9a0cf2cae9d", "filename": "src/test/run-pass/else-if.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Felse-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Felse-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Felse-if.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,42 +1,42 @@\n fn main() {\n   if (1 == 2) {\n-    check(false);\n+    assert (false);\n   } else if (2 == 3) {\n-    check(false);\n+    assert (false);\n   } else if (3 == 4) {\n-    check(false);\n+    assert (false);\n   } else {\n-    check(true);\n+    assert (true);\n   }\n \n \n   if (1 == 2) {\n-    check(false);\n+    assert (false);\n   } else if (2 == 2) {\n-    check(true);\n+    assert (true);\n   }\n \n   if (1 == 2) {\n-    check(false);\n+    assert (false);\n   } else if (2 == 2) {\n     if (1 == 1) {\n-      check(true);\n+      assert (true);\n     } else {\n       if (2 == 1) {\n-        check(false);\n+        assert (false);\n       } else {\n-        check(false);\n+        assert (false);\n       }\n     }\n   }\n \n   if (1 == 2) {\n-    check(false);\n+    assert (false);\n   } else {\n     if (1 == 2) {\n-      check(false);\n+      assert (false);\n     } else {\n-      check(true);\n+      assert (true);\n     }\n   }\n }"}, {"sha": "e18611fa96ff7f706d8bc6f754c65593974db4c5", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn test_box() {\n       @100\n     }\n   };\n-  check (*res == 100);\n+  assert (*res == 100);\n }\n \n fn test_str() {\n@@ -18,7 +18,7 @@ fn test_str() {\n       \"happy\"\n     }\n   };\n-  check (res == \"happy\");\n+  assert (res == \"happy\");\n }\n \n fn main() {"}, {"sha": "a1367e81b8cf7b0084b6e12cd092ba1bd5cd2b40", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](@T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "469b8e7c6d9f3b86a895c18583924abef074c90c", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](&T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "0cd0177a2151354f1145aca2d6dc04ceba33eff3", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn test_generic[T](&T expected, &compare[T] eq) {\n       expected\n     }\n   };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "762303d53c17eac3ce7a9af8159dd0c79f71c254", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn test_rec() {\n       rec(i = 100)\n     }\n   };\n-  check (res == rec(i = 100));\n+  assert (res == rec(i = 100));\n }\n \n fn test_tag() {\n@@ -26,7 +26,7 @@ fn test_tag() {\n       sad\n     }\n   };\n-  check (res == happy);\n+  assert (res == happy);\n }\n \n fn main() {"}, {"sha": "52a01078762b1f0cc5dfcff9246ebd2e16ac441a", "filename": "src/test/run-pass/expr-alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -12,7 +12,7 @@ fn test_basic() {\n       false\n     }\n   };\n-  check (res);\n+  assert (res);\n \n   res = alt(false) {\n     case (true) {\n@@ -22,7 +22,7 @@ fn test_basic() {\n       true\n     }\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_inferrence() {\n@@ -34,7 +34,7 @@ fn test_inferrence() {\n       false\n     }\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_alt_as_alt_head() {\n@@ -47,7 +47,7 @@ fn test_alt_as_alt_head() {\n       true\n     }\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_alt_as_block_result() {\n@@ -66,7 +66,7 @@ fn test_alt_as_block_result() {\n       }\n     }\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn main() {"}, {"sha": "206c44afd3ae375420e5a988e55061a8f23862cb", "filename": "src/test/run-pass/expr-block-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     @100\n   };\n \n-  check (*x == 100);\n+  assert (*x == 100);\n }"}, {"sha": "a37d1cb0f8d6d308d5fdc3bd7f0df1a011e78c19", "filename": "src/test/run-pass/expr-block-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-fn.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,7 +6,7 @@ fn test_fn() {\n     ret 10;\n   }\n   let t res = { ten };\n-  check (res() == 10);\n+  assert (res() == 10);\n }\n \n fn main() {"}, {"sha": "82d54c175d0558fa8259eac2dd3aae8af0f2d419", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(@T t1, @T t2) -> bool;\n \n fn test_generic[T](@T expected, &compare[T] eq) {\n   let @T actual = { expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "c1c8260c6815186c7ab9ce732bcebd49125bf3d1", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &compare[T] eq) {\n   let T actual = { expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "d6061a6c84c80edb10fcd74a974afb9be789a982", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,7 +7,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &compare[T] eq) {\n   let T actual = { expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "1c03a6b0694af4e27c8fd62416541982c8954a98", "filename": "src/test/run-pass/expr-block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,12 +5,12 @@\n \n fn test_basic() {\n   let bool res = { true };\n-  check (res);\n+  assert (res);\n }\n \n fn test_rec() {\n   auto res = { rec(v1 = 10, v2 = 20) };\n-  check (res.v2 == 20);\n+  assert (res.v2 == 20);\n }\n \n fn test_filled_with_stuff() {\n@@ -21,7 +21,7 @@ fn test_filled_with_stuff() {\n     }\n     a\n   };\n-  check (res == 10);\n+  assert (res == 10);\n }\n \n fn main() {"}, {"sha": "d242d7448b7771c49668dd2f5980ca6ca8769819", "filename": "src/test/run-pass/expr-if-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,12 +5,12 @@\n \n fn test_box() {\n   auto res = if (true) { @100 } else { @101 };\n-  check (*res == 100);\n+  assert (*res == 100);\n }\n \n fn test_str() {\n   auto res = if (true) { \"happy\" } else { \"sad\" };\n-  check (res == \"happy\");\n+  assert (res == \"happy\");\n }\n \n fn main() {"}, {"sha": "d1d4c05dee93c70796137305f6bbf833311f3afe", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(@T t1, @T t2) -> bool;\n \n fn test_generic[T](@T expected, @T not_expected, &compare[T] eq) {\n   let @T actual = if (true) { expected } else { not_expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_box() {"}, {"sha": "a126b1c45a9c09228812ddcfda79094105ea6fc8", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &T not_expected, &compare[T] eq) {\n   let T actual = if (true) { expected } else { not_expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_vec() {"}, {"sha": "b86a7553d98939b2663e1778b18d3eeb93fcbf40", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,7 +7,7 @@ type compare[T] = fn(&T t1, &T t2) -> bool;\n \n fn test_generic[T](&T expected, &T not_expected, &compare[T] eq) {\n   let T actual = if (true) { expected } else { not_expected };\n-  check (eq(expected, actual));\n+  assert (eq(expected, actual));\n }\n \n fn test_bool() {"}, {"sha": "6d42c2241d57d53d7dd389f45762b4ba5a8c2c6e", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@\n \n fn test_rec() {\n   auto res = if (true) { rec(i = 100) } else { rec(i = 101) };\n-  check (res == rec(i = 100));\n+  assert (res == rec(i = 100));\n }\n \n fn test_tag() {\n@@ -15,7 +15,7 @@ fn test_tag() {\n   }\n \n   auto res = if (true) { happy } else { sad };\n-  check (res == happy);\n+  assert (res == happy);\n }\n \n fn main() {"}, {"sha": "67f56746de6bd0e991278f65673f076ac9896f42", "filename": "src/test/run-pass/expr-if.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexpr-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,12 +5,12 @@\n \n fn test_if() {\n   let bool res = if (true) { true } else { false };\n-  check (res);\n+  assert (res);\n }\n \n fn test_else() {\n   let bool res = if (false) { false } else { true };\n-  check (res);\n+  assert (res);\n }\n \n fn test_elseif1() {\n@@ -21,7 +21,7 @@ fn test_elseif1() {\n   } else {\n     false\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_elseif2() {\n@@ -32,7 +32,7 @@ fn test_elseif2() {\n   } else {\n     false\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_elseif3() {\n@@ -43,12 +43,12 @@ fn test_elseif3() {\n   } else {\n     true\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn test_inferrence() {\n   auto res = if (true) { true } else { false };\n-  check (res);\n+  assert (res);\n }\n \n fn test_if_as_if_condition() {\n@@ -57,14 +57,14 @@ fn test_if_as_if_condition() {\n   } else {\n     false\n   };\n-  check (res1);\n+  assert (res1);\n \n   auto res2 = if (if (true) { false } else { true }) {\n     false\n   } else {\n     true\n   };\n-  check (res2);\n+  assert (res2);\n }\n \n fn test_if_as_block_result() {\n@@ -77,7 +77,7 @@ fn test_if_as_block_result() {\n   } else {\n     false\n   };\n-  check (res);\n+  assert (res);\n }\n \n fn main() {"}, {"sha": "661effda38ac1fcac86e91ba4ea5fc0750eabb2c", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,16 +3,16 @@\n type point = rec(int x, int y, mutable int z);\n \n fn f(@point p) {\n-  check (p.z == 12);\n+  assert (p.z == 12);\n   p.z = 13;\n-  check (p.z == 13);\n+  assert (p.z == 13);\n }\n \n fn main() {\n   let point a = rec(x=10, y=11, mutable z=12);\n   let @point b = @a;\n-  check (b.z == 12);\n+  assert (b.z == 12);\n   f(b);\n-  check (a.z == 12);\n-  check (b.z == 13);\n+  assert (a.z == 12);\n+  assert (b.z == 13);\n }"}, {"sha": "577ee6a226eb75a58ebf1158a70de25fe932b763", "filename": "src/test/run-pass/fact.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -15,7 +15,7 @@ fn f(int x) -> int {\n   }\n }\n fn main () {\n-  check (f(5) == 120);\n+  assert (f(5) == 120);\n   // log \"all done\";\n }\n "}, {"sha": "e6136d2cf442120fb0812c3497f0d84378abf0c6", "filename": "src/test/run-pass/float2.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffloat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffloat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -12,13 +12,13 @@ fn main() {\n   auto j = 3.1e+9;\n   auto k = 3.2e-10;\n  \n-  check(a == b);\n-  check(c < b);\n-  check(c == d);\n-  check(e < g);\n-  check(f < h);\n-  check(g == 1000000.0f32);\n-  check(h == i);\n-  check(j > k);\n-  check(k < a);\n+  assert (a == b);\n+  assert (c < b);\n+  assert (c == d);\n+  assert (e < g);\n+  assert (f < h);\n+  assert (g == 1000000.0f32);\n+  assert (h == i);\n+  assert (j > k);\n+  assert (k < a);\n }\n\\ No newline at end of file"}, {"sha": "37f21c8f43a4ff25acbad1cf4d9bb825de7cf90c", "filename": "src/test/run-pass/floatlits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffloatlits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloatlits.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,9 +1,9 @@\n // xfail-boot\n fn main() {\n   auto f = 4.999999999999;\n-  check (f > 4.90);\n-  check (f < 5.0);\n+  assert (f > 4.90);\n+  assert (f < 5.0);\n   auto g = 4.90000000001e-10;\n-  check(g > 5e-11);\n-  check(g < 5e-9);\n+  assert (g > 5e-11);\n+  assert (g < 5e-9);\n }\n\\ No newline at end of file"}, {"sha": "33a376d529e6157ccf3eda5a77c43cf834a494f1", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -28,12 +28,12 @@ fn main() {\n         }\n     }\n \n-    check (a.(0) == 0);\n-    check (a.(1) == 1);\n-    check (a.(2) == 10);\n-    check (a.(3) == 11);\n-    check (a.(4) == 100);\n-    check (a.(5) == 101);\n-    check (a.(6) == 110);\n-    check (a.(7) == 111);\n+    assert (a.(0) == 0);\n+    assert (a.(1) == 1);\n+    assert (a.(2) == 10);\n+    assert (a.(3) == 11);\n+    assert (a.(4) == 100);\n+    assert (a.(5) == 101);\n+    assert (a.(6) == 110);\n+    assert (a.(7) == 111);\n }"}, {"sha": "9ba304c1463a47bf2b02003aeac893af888d6c37", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -16,8 +16,8 @@ fn main() {\n         }\n     }\n \n-    check (a.(0) == 0);\n-    check (a.(1) == 1);\n-    check (a.(2) == 10);\n-    check (a.(3) == 11);\n+    assert (a.(0) == 0);\n+    assert (a.(1) == 1);\n+    assert (a.(2) == 10);\n+    assert (a.(3) == 11);\n }"}, {"sha": "02dbef5d514b8e4585313fce5b23f23a13e47c95", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -14,9 +14,9 @@ fn main() {\n   for each (tup(int,int) p in pairs()) {\n       log p._0;\n       log p._1;\n-      check (p._0 + 10 == i);\n+      assert (p._0 + 10 == i);\n       i += 1;\n       j = p._1;\n     }\n-  check(j == 45);\n+  assert (j == 45);\n }\n\\ No newline at end of file"}, {"sha": "8f23d61d03dcae63ddc4dcb9f304ac38b85e8d94", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn main() {\n   }\n   log \"sum\";\n   log sum;\n-  check (sum == 45);\n+  assert (sum == 45);\n }\n \n iter first_ten() -> int {"}, {"sha": "5fa3837e6b3cbc700c820e153bc855047da1a0c7", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -13,7 +13,7 @@ fn main() {\n   let int a = direct(3); // direct\n   //let int b = ho(direct); // indirect unbound\n   let int c = ho(bind direct(_)); // indirect bound\n-  //check(a == b);\n-  //check(b == c);\n+  //assert (a == b);\n+  //assert (b == c);\n }\n "}, {"sha": "1d506dca26e8095292ccb54175bfde8f067fa505", "filename": "src/test/run-pass/fun-indirect-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,5 +7,5 @@ fn f() -> int {\n fn main() {\n   let fn() -> int g = f;\n   let int i = g();\n-  check(i == 42);\n+  assert (i == 42);\n }"}, {"sha": "ce3889fbb4c7620668a457b9372f585b832d0676", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   auto expected = @100;\n   auto actual = id[@int](expected);\n   log *actual;\n-  check (*expected == *actual);\n+  assert (*expected == *actual);\n }\n\\ No newline at end of file"}, {"sha": "f3a65edd549ce00951b69b09774557febe75fc0a", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ fn id[T](&T t) -> T {\n \n fn main() {\n   auto t = tup(1,2,3,4,5,6,7);\n-  check (t._5 == 6);\n+  assert (t._5 == 6);\n   auto f0 = bind id[tup(int,int,int,int,int,int,int)](t);\n-  check (f0()._5 == 6);\n+  assert (f0()._5 == 6);\n }"}, {"sha": "c65e061ad214ef0c668b2489f17e7fb0b3322eb7", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,7 +4,7 @@ fn id[T](&T t) -> T {\n \n fn main() {\n   auto t = tup(1,2,3,4,5,6,7);\n-  check (t._5 == 6);\n+  assert (t._5 == 6);\n   auto f1 = bind id[tup(int,int,int,int,int,int,int)](_);\n-  check (f1(t)._5 == 6);\n+  assert (f1(t)._5 == 6);\n }"}, {"sha": "76d5e3ab01b3bc68547bd0551c792771e1afc259", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,5 +4,5 @@ fn box[T](&tup(T,T,T) x) -> @tup(T,T,T) {\n \n fn main() {\n   let @tup(int,int,int) x = box[int](tup(1,2,3));\n-  check (x._1 == 2);\n+  assert (x._1 == 2);\n }\n\\ No newline at end of file"}, {"sha": "507d1c5fd8799bcf38f637fb1d8b134bd48a3d22", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -12,6 +12,6 @@ fn main() {\n   auto b = f[int](10);\n   log b._0;\n   log b._1;\n-  check (b._0 == 10);\n-  check (b._1 == 10);\n+  assert (b._0 == 10);\n+  assert (b._1 == 10);\n }"}, {"sha": "07eae9c1a4268f9f1ae7939140b7c1be09093151", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,6 +8,6 @@ fn main() {\n   let int foo = 17;\n   let tupbox[int] tbfoo = tuplift[int](foo);\n   let recbox[int] rbfoo = reclift[int](foo);\n-  check (tbfoo._0 == foo);\n-  check (rbfoo.x == foo);\n+  assert (tbfoo._0 == foo);\n+  assert (rbfoo.x == foo);\n }"}, {"sha": "9c795ec250c39776e189c9d989b5f55216736201", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,5 +9,5 @@ fn id[T](&T x) -> T {\n fn main() {\n   let int x = 42;\n   let int y = id(x);\n-  check (x == y);\n+  assert (x == y);\n }"}, {"sha": "4f93fef52c9cb169567678163c79950eeac5df05", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -17,16 +17,16 @@ fn main() {\n \n    y = id[int](x);\n    log y;\n-   check (x == y);\n+   assert (x == y);\n \n    b = id[char](a);\n    log b;\n-   check (a == b);\n+   assert (a == b);\n \n    q = id[triple](p);\n    x = p._2;\n    y = q._2;\n    log y;\n-   check (x == y);\n+   assert (x == y);\n \n }"}, {"sha": "cc549f6bd6efa348f7ef59a319e959017a544edc", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -11,7 +11,7 @@ fn main() {\n   log h.get()._0;\n   log h.get()._1;\n   log h.get()._2;\n-  check (h.get()._0 == (1 as u8));\n-  check (h.get()._1 == (2 as u8));\n-  check (h.get()._2 == (3 as u8));\n+  assert (h.get()._0 == (1 as u8));\n+  assert (h.get()._1 == (2 as u8));\n+  assert (h.get()._2 == (3 as u8));\n }"}, {"sha": "9879fa790b5571e57e162147ed2537247b8a8d7d", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -21,8 +21,8 @@ fn main() {\n   log b.get(0);\n   log b.get(1);\n   log b.get(2);\n-  check (b.get(0) == 1);\n-  check (b.get(1) == 2);\n-  check (b.get(2) == 3);\n+  assert (b.get(0) == 1);\n+  assert (b.get(1) == 2);\n+  assert (b.get(2) == 3);\n   b.take2(0);\n }"}, {"sha": "f29cfa00036fab7406797d25dced238d671a9b0f", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -10,7 +10,7 @@ fn altfoo[T](&foo[T] f) {\n       hit = true;\n     }\n   }\n-  check (hit);\n+  assert (hit);\n }\n \n fn main() {"}, {"sha": "46421e0a28c6be5be8e4fae52014ea5dee40b120", "filename": "src/test/run-pass/generic-tag-values.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-values.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn main() {\n   alt (nop) {\n     case (some[int](?n)) {\n       log n;\n-      check (n == 5);\n+      assert (n == 5);\n     }\n   }\n \n@@ -18,8 +18,8 @@ fn main() {\n     case (some[tup(int, int)](?t)) {\n       log t._0;\n       log t._1;\n-      check (t._0 == 17);\n-      check (t._1 == 42);\n+      assert (t._0 == 17);\n+      assert (t._1 == 42);\n     }\n   }\n }"}, {"sha": "2f697124625140ffaf0c6277e3d495fb5b97c363", "filename": "src/test/run-pass/generic-temporary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ fn mk() -> int {\n \n fn chk(&int a) {\n   log a;\n-  check (a == 1);\n+  assert (a == 1);\n }\n \n fn apply[T](fn() -> T produce, fn(&T) consume) {"}, {"sha": "d2edfd2e379b181a9e6f6c3fc12c0993537fcec3", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,6 +6,6 @@ fn get_third[T](&tup(T,T,T) t) -> T {\n \n fn main() {\n   log get_third(tup(1,2,3));\n-  check (get_third(tup(1,2,3)) == 3);\n-  check (get_third(tup(5u8,6u8,7u8)) == 7u8);\n+  assert (get_third(tup(1,2,3)) == 3);\n+  assert (get_third(tup(5u8,6u8,7u8)) == 7u8);\n }\n\\ No newline at end of file"}, {"sha": "9b5b5297f15cd68914453fc76c99e2739bcd0f26", "filename": "src/test/run-pass/generic-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,6 +1,6 @@\n type pair[T] = tup(T,T);\n fn main() {\n   let pair[int] x = tup(10,12);\n-  check (x._0 == 10);\n-  check (x._1 == 12);\n+  assert (x._0 == 10);\n+  assert (x._1 == 12);\n }"}, {"sha": "eb5e76fb292a6bc8d7b7f629cfd2423a0f9ca738", "filename": "src/test/run-pass/i32-sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi32-sub.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     let i32 x = -400_i32;\n     x = 0_i32 - x;\n-    check(x == 400_i32);\n+    assert (x == 400_i32);\n }\n "}, {"sha": "92ff04ea28453fe306cfcad98c8dd6b060d96be1", "filename": "src/test/run-pass/i8-incr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi8-incr.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,5 +5,5 @@ fn main() {\n   let i8 y = -12i8;\n   x = x + 1i8;\n   x = x - 1i8;\n-  check(x == y);\n+  assert (x == y);\n }"}, {"sha": "ee80786c18a41b7d9d912d33b8e38cc4886d68ce", "filename": "src/test/run-pass/integral-indexing.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintegral-indexing.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,19 +4,19 @@ fn main() {\n \n   let vec[int] v = vec(0, 1, 2, 3, 4, 5);\n   let str s = \"abcdef\";\n-  check (v.(3u) == 3);\n-  check (v.(3u8) == 3);\n-  check (v.(3i8) == 3);\n-  check (v.(3u32) == 3);\n-  check (v.(3i32) == 3);\n+  assert (v.(3u) == 3);\n+  assert (v.(3u8) == 3);\n+  assert (v.(3i8) == 3);\n+  assert (v.(3u32) == 3);\n+  assert (v.(3i32) == 3);\n \n   log v.(3u8);\n \n-  check (s.(3u) == 'd' as u8);\n-  check (s.(3u8) == 'd' as u8);\n-  check (s.(3i8) == 'd' as u8);\n-  check (s.(3u32) == 'd' as u8);\n-  check (s.(3i32) == 'd' as u8);\n+  assert (s.(3u) == 'd' as u8);\n+  assert (s.(3u8) == 'd' as u8);\n+  assert (s.(3i8) == 'd' as u8);\n+  assert (s.(3u32) == 'd' as u8);\n+  assert (s.(3i32) == 'd' as u8);\n \n   log s.(3u8);\n }\n\\ No newline at end of file"}, {"sha": "78bf94c33ab4775d70b7576c4502e99f494b089f", "filename": "src/test/run-pass/iter-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fiter-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fiter-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-range.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,5 +1,5 @@\n iter range(int a, int b) -> int {\n-  check (a < b);\n+  assert (a < b);\n \n   let int i = a;\n   while (i < b) {"}, {"sha": "7034efba2b6556f804fc900b9792759f03ffed23", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,22 +1,22 @@\n fn incr(& mutable int x) -> bool {\n   x += 1;\n-  check (false);\n+  assert (false);\n   ret false;\n }\n \n fn main() {\n \n   auto x = (1 == 2) || (3 == 3);\n-  check (x);\n+  assert (x);\n \n   let int y = 10;\n   log x || incr(y);\n-  check (y == 10);\n+  assert (y == 10);\n \n   if (true && x) {\n-    check (true);\n+    assert (true);\n   } else {\n-    check (false);\n+    assert (false);\n   }\n \n }\n\\ No newline at end of file"}, {"sha": "a91adaa15653a5db5f4499ab377d672846a72df2", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -10,13 +10,13 @@ fn main() {\n   y <- p;\n   log \"received 1\";\n   log y;\n-  check (y == 10);\n+  assert (y == 10);\n \n   spawn child(c);\n   y <- p;\n   log \"received 2\";\n   log y;\n-  check (y == 10);\n+  assert (y == 10);\n }\n \n fn child(chan[int] c) {"}, {"sha": "8f2d939005c78e6cd497ff0d145917ef349c478e", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,29 +9,29 @@ fn test_0_elements() {\n   act = bitv.create(0u, false);\n   exp = _vec.init_elt[uint](0u, 0u);\n   // FIXME: why can't I write vec[uint]()?\n-  check (bitv.eq_vec(act, exp));\n+  assert (bitv.eq_vec(act, exp));\n }\n \n fn test_1_element() {\n   auto act;\n \n   act = bitv.create(1u, false);\n-  check (bitv.eq_vec(act, vec(0u)));\n+  assert (bitv.eq_vec(act, vec(0u)));\n \n   act = bitv.create(1u, true);\n-  check (bitv.eq_vec(act, vec(1u)));\n+  assert (bitv.eq_vec(act, vec(1u)));\n }\n \n fn test_10_elements() {\n   auto act;\n \n   // all 0\n   act = bitv.create(10u, false);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(10u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n@@ -40,7 +40,7 @@ fn test_10_elements() {\n   bitv.set(act, 2u, true);\n   bitv.set(act, 3u, true);\n   bitv.set(act, 4u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n@@ -49,30 +49,30 @@ fn test_10_elements() {\n   bitv.set(act, 7u, true);\n   bitv.set(act, 8u, true);\n   bitv.set(act, 9u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n \n   // mixed\n   act = bitv.create(10u, false);\n   bitv.set(act, 0u, true);\n   bitv.set(act, 3u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 9u, true);\n-  check (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+  assert (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n fn test_31_elements() {\n   auto act;\n \n   // all 0\n   act = bitv.create(31u, false);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(31u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -87,7 +87,7 @@ fn test_31_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -102,7 +102,7 @@ fn test_31_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -116,7 +116,7 @@ fn test_31_elements() {\n   bitv.set(act, 28u, true);\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -126,7 +126,7 @@ fn test_31_elements() {\n   bitv.set(act, 3u, true);\n   bitv.set(act, 17u, true);\n   bitv.set(act, 30u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n@@ -137,14 +137,14 @@ fn test_32_elements() {\n \n   // all 0\n   act = bitv.create(32u, false);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n \n   // all 1\n   act = bitv.create(32u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -159,7 +159,7 @@ fn test_32_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -174,7 +174,7 @@ fn test_32_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n@@ -189,7 +189,7 @@ fn test_32_elements() {\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n@@ -200,7 +200,7 @@ fn test_32_elements() {\n   bitv.set(act, 17u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n@@ -211,15 +211,15 @@ fn test_33_elements() {\n \n   // all 0\n   act = bitv.create(33u, false);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u)));\n \n   // all 1\n   act = bitv.create(33u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n@@ -235,7 +235,7 @@ fn test_33_elements() {\n   bitv.set(act, 5u, true);\n   bitv.set(act, 6u, true);\n   bitv.set(act, 7u, true);\n-  check (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+  assert (bitv.eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n@@ -251,7 +251,7 @@ fn test_33_elements() {\n   bitv.set(act, 21u, true);\n   bitv.set(act, 22u, true);\n   bitv.set(act, 23u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n@@ -267,7 +267,7 @@ fn test_33_elements() {\n   bitv.set(act, 29u, true);\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n@@ -280,7 +280,7 @@ fn test_33_elements() {\n   bitv.set(act, 30u, true);\n   bitv.set(act, 31u, true);\n   bitv.set(act, 32u, true);\n-  check (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+  assert (bitv.eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,"}, {"sha": "62807251bd16044762029d1d03b7482fe4afd66d", "filename": "src/test/run-pass/lib-box.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-box.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,9 +4,9 @@ import std.Box;\n fn main() {\n     auto x = @3;\n     auto y = @3;\n-    check (Box.ptr_eq[int](x, x));\n-    check (Box.ptr_eq[int](y, y));\n-    check (!Box.ptr_eq[int](x, y));\n-    check (!Box.ptr_eq[int](y, x));\n+    assert (Box.ptr_eq[int](x, x));\n+    assert (Box.ptr_eq[int](y, y));\n+    assert (!Box.ptr_eq[int](x, y));\n+    assert (!Box.ptr_eq[int](y, x));\n }\n "}, {"sha": "405ab72be2037d3df16716e4b55d1ddf94d32d95", "filename": "src/test/run-pass/lib-deque.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-deque.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,125 +5,125 @@ import std.deque;\n \n fn test_simple() {\n   let deque.t[int] d = deque.create[int]();\n-  check (d.size() == 0u);\n+  assert (d.size() == 0u);\n   d.add_front(17);\n   d.add_front(42);\n   d.add_back(137);\n-  check (d.size() == 3u);\n+  assert (d.size() == 3u);\n   d.add_back(137);\n-  check (d.size() == 4u);\n+  assert (d.size() == 4u);\n \n   log d.peek_front();\n-  check (d.peek_front() == 42);\n+  assert (d.peek_front() == 42);\n \n   log d.peek_back();\n-  check (d.peek_back() == 137);\n+  assert (d.peek_back() == 137);\n \n   let int i = d.pop_front();\n   log i;\n-  check (i == 42);\n+  assert (i == 42);\n \n   i = d.pop_back();\n   log i;\n-  check (i == 137);\n+  assert (i == 137);\n \n   i = d.pop_back();\n   log i;\n-  check (i == 137);\n+  assert (i == 137);\n \n   i = d.pop_back();\n   log i;\n-  check (i == 17);\n+  assert (i == 17);\n \n-  check (d.size() == 0u);\n+  assert (d.size() == 0u);\n   d.add_back(3);\n-  check (d.size() == 1u);\n+  assert (d.size() == 1u);\n   d.add_front(2);\n-  check (d.size() == 2u);\n+  assert (d.size() == 2u);\n   d.add_back(4);\n-  check (d.size() == 3u);\n+  assert (d.size() == 3u);\n   d.add_front(1);\n-  check (d.size() == 4u);\n+  assert (d.size() == 4u);\n \n   log d.get(0);\n   log d.get(1);\n   log d.get(2);\n   log d.get(3);\n \n-  check (d.get(0) == 1);\n-  check (d.get(1) == 2);\n-  check (d.get(2) == 3);\n-  check (d.get(3) == 4);\n+  assert (d.get(0) == 1);\n+  assert (d.get(1) == 2);\n+  assert (d.get(2) == 3);\n+  assert (d.get(3) == 4);\n }\n \n fn test_boxes(@int a, @int b, @int c, @int d) {\n   let deque.t[@int] deq = deque.create[@int]();\n-  check (deq.size() == 0u);\n+  assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n   deq.add_back(c);\n-  check (deq.size() == 3u);\n+  assert (deq.size() == 3u);\n   deq.add_back(d);\n-  check (deq.size() == 4u);\n+  assert (deq.size() == 4u);\n \n-  check (deq.peek_front() == b);\n-  check (deq.peek_back() == d);\n+  assert (deq.peek_front() == b);\n+  assert (deq.peek_back() == d);\n \n-  check (deq.pop_front() == b);\n-  check (deq.pop_back() == d);\n-  check (deq.pop_back() == c);\n-  check (deq.pop_back() == a);\n+  assert (deq.pop_front() == b);\n+  assert (deq.pop_back() == d);\n+  assert (deq.pop_back() == c);\n+  assert (deq.pop_back() == a);\n \n-  check (deq.size() == 0u);\n+  assert (deq.size() == 0u);\n   deq.add_back(c);\n-  check (deq.size() == 1u);\n+  assert (deq.size() == 1u);\n   deq.add_front(b);\n-  check (deq.size() == 2u);\n+  assert (deq.size() == 2u);\n   deq.add_back(d);\n-  check (deq.size() == 3u);\n+  assert (deq.size() == 3u);\n   deq.add_front(a);\n-  check (deq.size() == 4u);\n+  assert (deq.size() == 4u);\n \n-  check (deq.get(0) == a);\n-  check (deq.get(1) == b);\n-  check (deq.get(2) == c);\n-  check (deq.get(3) == d);\n+  assert (deq.get(0) == a);\n+  assert (deq.get(1) == b);\n+  assert (deq.get(2) == c);\n+  assert (deq.get(3) == d);\n }\n \n type eqfn[T] = fn(&T a, &T b) -> bool;\n \n fn test_parameterized[T](eqfn[T] e, &T a, &T b, &T c, &T d) {\n   let deque.t[T] deq = deque.create[T]();\n-  check (deq.size() == 0u);\n+  assert (deq.size() == 0u);\n   deq.add_front(a);\n   deq.add_front(b);\n   deq.add_back(c);\n-  check (deq.size() == 3u);\n+  assert (deq.size() == 3u);\n   deq.add_back(d);\n-  check (deq.size() == 4u);\n+  assert (deq.size() == 4u);\n \n-  check (e(deq.peek_front(), b));\n-  check (e(deq.peek_back(), d));\n+  assert (e(deq.peek_front(), b));\n+  assert (e(deq.peek_back(), d));\n \n-  check (e(deq.pop_front(), b));\n-  check (e(deq.pop_back(), d));\n-  check (e(deq.pop_back(), c));\n-  check (e(deq.pop_back(), a));\n+  assert (e(deq.pop_front(), b));\n+  assert (e(deq.pop_back(), d));\n+  assert (e(deq.pop_back(), c));\n+  assert (e(deq.pop_back(), a));\n \n-  check (deq.size() == 0u);\n+  assert (deq.size() == 0u);\n   deq.add_back(c);\n-  check (deq.size() == 1u);\n+  assert (deq.size() == 1u);\n   deq.add_front(b);\n-  check (deq.size() == 2u);\n+  assert (deq.size() == 2u);\n   deq.add_back(d);\n-  check (deq.size() == 3u);\n+  assert (deq.size() == 3u);\n   deq.add_front(a);\n-  check (deq.size() == 4u);\n+  assert (deq.size() == 4u);\n \n-  check (e(deq.get(0), a));\n-  check (e(deq.get(1), b));\n-  check (e(deq.get(2), c));\n-  check (e(deq.get(3), d));\n+  assert (e(deq.get(0), a));\n+  assert (e(deq.get(1), b));\n+  assert (e(deq.get(2), c));\n+  assert (e(deq.get(3), d));\n }\n \n tag taggy {"}, {"sha": "e4e68351aabfc25a891e22e61fd3b287a6b50358", "filename": "src/test/run-pass/lib-int.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-int.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,22 +4,22 @@ import std._int;\n import std._str.eq;\n \n fn test_to_str() {\n-  check (eq(_int.to_str(0, 10u), \"0\"));\n-  check (eq(_int.to_str(1, 10u), \"1\"));\n-  check (eq(_int.to_str(-1, 10u), \"-1\"));\n-  check (eq(_int.to_str(255, 16u), \"ff\"));\n-  check (eq(_int.to_str(100, 10u), \"100\"));\n+  assert (eq(_int.to_str(0, 10u), \"0\"));\n+  assert (eq(_int.to_str(1, 10u), \"1\"));\n+  assert (eq(_int.to_str(-1, 10u), \"-1\"));\n+  assert (eq(_int.to_str(255, 16u), \"ff\"));\n+  assert (eq(_int.to_str(100, 10u), \"100\"));\n }\n \n fn test_pow() {\n-  check (_int.pow(0, 0u) == 1);\n-  check (_int.pow(0, 1u) == 0);\n-  check (_int.pow(0, 2u) == 0);\n-  check (_int.pow(-1, 0u) == -1);\n-  check (_int.pow(1, 0u) == 1);\n-  check (_int.pow(-3, 2u) == 9);\n-  check (_int.pow(-3, 3u) == -27);\n-  check (_int.pow(4, 9u) == 262144);\n+  assert (_int.pow(0, 0u) == 1);\n+  assert (_int.pow(0, 1u) == 0);\n+  assert (_int.pow(0, 2u) == 0);\n+  assert (_int.pow(-1, 0u) == -1);\n+  assert (_int.pow(1, 0u) == 1);\n+  assert (_int.pow(-3, 2u) == 9);\n+  assert (_int.pow(-3, 3u) == -27);\n+  assert (_int.pow(4, 9u) == 262144);\n }\n \n fn main() {"}, {"sha": "bcc2163cfd3fa314b70dfab40007a487d61e2dd6", "filename": "src/test/run-pass/lib-io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-io.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -20,7 +20,7 @@ fn test_simple(str tmpfilebase) {\n   let io.reader inp = io.file_reader(tmpfile);\n   let str frood2 = inp.read_c_str();\n   log frood2;\n-  check (_str.eq(frood, frood2));\n+  assert (_str.eq(frood, frood2));\n }\n \n fn main(vec[str] argv) {"}, {"sha": "abd2041e151318a37340bfcf7ddb2c3a243a8e69", "filename": "src/test/run-pass/lib-map.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-map.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -28,19 +28,19 @@ fn test_simple() {\n   let map.hashmap[uint, uint] hm_uu = map.mk_hashmap[uint, uint](hasher_uint,\n                                                                  eqer_uint);\n \n-  check (hm_uu.insert(10u, 12u));\n-  check (hm_uu.insert(11u, 13u));\n-  check (hm_uu.insert(12u, 14u));\n+  assert (hm_uu.insert(10u, 12u));\n+  assert (hm_uu.insert(11u, 13u));\n+  assert (hm_uu.insert(12u, 14u));\n \n-  check (hm_uu.get(11u) == 13u);\n-  check (hm_uu.get(12u) == 14u);\n-  check (hm_uu.get(10u) == 12u);\n+  assert (hm_uu.get(11u) == 13u);\n+  assert (hm_uu.get(12u) == 14u);\n+  assert (hm_uu.get(10u) == 12u);\n \n-  check (!hm_uu.insert(12u, 14u));\n-  check (hm_uu.get(12u) == 14u);\n+  assert (!hm_uu.insert(12u, 14u));\n+  assert (hm_uu.get(12u) == 14u);\n \n-  check (!hm_uu.insert(12u, 12u));\n-  check (hm_uu.get(12u) == 12u);\n+  assert (!hm_uu.insert(12u, 12u));\n+  assert (hm_uu.get(12u) == 12u);\n \n \n   let str ten = \"ten\";\n@@ -51,61 +51,61 @@ fn test_simple() {\n \n   let map.hashmap[str, uint] hm_su = map.mk_hashmap[str, uint](hasher_str,\n                                                                eqer_str);\n-  check (hm_su.insert(\"ten\", 12u));\n-  check (hm_su.insert(eleven, 13u));\n-  check (hm_su.insert(\"twelve\", 14u));\n+  assert (hm_su.insert(\"ten\", 12u));\n+  assert (hm_su.insert(eleven, 13u));\n+  assert (hm_su.insert(\"twelve\", 14u));\n \n-  check (hm_su.get(eleven) == 13u);\n+  assert (hm_su.get(eleven) == 13u);\n \n-  check (hm_su.get(\"eleven\") == 13u);\n-  check (hm_su.get(\"twelve\") == 14u);\n-  check (hm_su.get(\"ten\") == 12u);\n+  assert (hm_su.get(\"eleven\") == 13u);\n+  assert (hm_su.get(\"twelve\") == 14u);\n+  assert (hm_su.get(\"ten\") == 12u);\n \n-  check (!hm_su.insert(\"twelve\", 14u));\n-  check (hm_su.get(\"twelve\") == 14u);\n+  assert (!hm_su.insert(\"twelve\", 14u));\n+  assert (hm_su.get(\"twelve\") == 14u);\n \n-  check (!hm_su.insert(\"twelve\", 12u));\n-  check (hm_su.get(\"twelve\") == 12u);\n+  assert (!hm_su.insert(\"twelve\", 12u));\n+  assert (hm_su.get(\"twelve\") == 12u);\n \n \n   log \"uint -> str\";\n \n   let map.hashmap[uint, str] hm_us = map.mk_hashmap[uint, str](hasher_uint,\n                                                                eqer_uint);\n \n-  check (hm_us.insert(10u, \"twelve\"));\n-  check (hm_us.insert(11u, \"thirteen\"));\n-  check (hm_us.insert(12u, \"fourteen\"));\n+  assert (hm_us.insert(10u, \"twelve\"));\n+  assert (hm_us.insert(11u, \"thirteen\"));\n+  assert (hm_us.insert(12u, \"fourteen\"));\n \n-  check (_str.eq(hm_us.get(11u), \"thirteen\"));\n-  check (_str.eq(hm_us.get(12u), \"fourteen\"));\n-  check (_str.eq(hm_us.get(10u), \"twelve\"));\n+  assert (_str.eq(hm_us.get(11u), \"thirteen\"));\n+  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n+  assert (_str.eq(hm_us.get(10u), \"twelve\"));\n \n-  check (!hm_us.insert(12u, \"fourteen\"));\n-  check (_str.eq(hm_us.get(12u), \"fourteen\"));\n+  assert (!hm_us.insert(12u, \"fourteen\"));\n+  assert (_str.eq(hm_us.get(12u), \"fourteen\"));\n \n-  check (!hm_us.insert(12u, \"twelve\"));\n-  check (_str.eq(hm_us.get(12u), \"twelve\"));\n+  assert (!hm_us.insert(12u, \"twelve\"));\n+  assert (_str.eq(hm_us.get(12u), \"twelve\"));\n \n \n   log \"str -> str\";\n \n   let map.hashmap[str, str] hm_ss = map.mk_hashmap[str, str](hasher_str,\n                                                              eqer_str);\n \n-  check (hm_ss.insert(ten, \"twelve\"));\n-  check (hm_ss.insert(eleven, \"thirteen\"));\n-  check (hm_ss.insert(twelve, \"fourteen\"));\n+  assert (hm_ss.insert(ten, \"twelve\"));\n+  assert (hm_ss.insert(eleven, \"thirteen\"));\n+  assert (hm_ss.insert(twelve, \"fourteen\"));\n \n-  check (_str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-  check (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-  check (_str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n+  assert (_str.eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (_str.eq(hm_ss.get(\"ten\"), \"twelve\"));\n \n-  check (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-  check (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+  assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n+  assert (_str.eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n \n-  check (!hm_ss.insert(\"twelve\", \"twelve\"));\n-  check (_str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+  assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n+  assert (_str.eq(hm_ss.get(\"twelve\"), \"twelve\"));\n \n   log \"*** finished test_simple\";\n }\n@@ -135,7 +135,7 @@ fn test_growth() {\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n-    check (hm_uu.insert(i, i * i));\n+    assert (hm_uu.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 1u;\n@@ -147,12 +147,12 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm_uu.get(i), 10u);\n-    check (hm_uu.get(i) == i * i);\n+    assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n-  check (hm_uu.insert(num_to_insert, 17u));\n-  check (hm_uu.get(num_to_insert) == 17u);\n+  assert (hm_uu.insert(num_to_insert, 17u));\n+  assert (hm_uu.get(num_to_insert) == 17u);\n \n   log \"-----\";\n \n@@ -162,7 +162,7 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm_uu.get(i), 10u);\n-    check (hm_uu.get(i) == i * i);\n+    assert (hm_uu.get(i) == i * i);\n     i += 1u;\n   }\n \n@@ -176,7 +176,7 @@ fn test_growth() {\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    check (hm_ss.insert(_uint.to_str(i, 2u), _uint.to_str(i * i, 2u)));\n+    assert (hm_ss.insert(_uint.to_str(i, 2u), _uint.to_str(i * i, 2u)));\n     log \"inserting \\\"\" + _uint.to_str(i, 2u)\n       + \"\\\" -> \\\"\" + _uint.to_str(i * i, 2u) + \"\\\"\";\n     i += 1u;\n@@ -191,15 +191,15 @@ fn test_growth() {\n       + \"\\\") = \\\"\"\n       + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n \n-    check (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n+    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n                    _uint.to_str(i * i, 2u)));\n     i += 1u;\n   }\n \n-  check (hm_ss.insert(_uint.to_str(num_to_insert, 2u),\n+  assert (hm_ss.insert(_uint.to_str(num_to_insert, 2u),\n                       _uint.to_str(17u, 2u)));\n \n-  check (_str.eq(hm_ss.get(_uint.to_str(num_to_insert, 2u)),\n+  assert (_str.eq(hm_ss.get(_uint.to_str(num_to_insert, 2u)),\n                  _uint.to_str(17u, 2u)));\n \n   log \"-----\";\n@@ -210,7 +210,7 @@ fn test_growth() {\n   while (i < num_to_insert) {\n     log \"get(\\\"\" + _uint.to_str(i, 2u) + \"\\\") = \\\"\"\n       + hm_ss.get(_uint.to_str(i, 2u)) + \"\\\"\";\n-    check (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n+    assert (_str.eq(hm_ss.get(_uint.to_str(i, 2u)),\n                    _uint.to_str(i * i, 2u)));\n     i += 1u;\n   }\n@@ -230,23 +230,23 @@ fn test_removal() {\n     ret (u / 2u) * 2u;\n   }\n \n-  check (hash(0u) == hash(1u));\n-  check (hash(2u) == hash(3u));\n-  check (hash(0u) != hash(2u));\n+  assert (hash(0u) == hash(1u));\n+  assert (hash(2u) == hash(3u));\n+  assert (hash(0u) != hash(2u));\n \n   let map.hashfn[uint] hasher = hash;\n   let map.eqfn[uint] eqer = eq;\n   let map.hashmap[uint, uint] hm = map.mk_hashmap[uint, uint](hasher, eqer);\n \n   let uint i = 0u;\n   while (i < num_to_insert) {\n-    check (hm.insert(i, i * i));\n+    assert (hm.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 1u;\n   }\n \n-  check (hm.size() == num_to_insert);\n+  assert (hm.size() == num_to_insert);\n \n   log \"-----\";\n   log \"removing evens\";\n@@ -260,7 +260,7 @@ fn test_removal() {\n     let util.option[uint] v = hm.remove(i);\n     alt (v) {\n       case (util.some[uint](u)) {\n-        check (u == (i * i));\n+        assert (u == (i * i));\n       }\n       case (util.none[uint]()) { fail; }\n     }\n@@ -273,15 +273,15 @@ fn test_removal() {\n     i += 2u;\n   }\n \n-  check (hm.size() == (num_to_insert / 2u));\n+  assert (hm.size() == (num_to_insert / 2u));\n \n   log \"-----\";\n \n   i = 1u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    check (hm.get(i) == i * i);\n+    assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n \n@@ -296,29 +296,29 @@ fn test_removal() {\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    check (hm.get(i) == i * i);\n+    assert (hm.get(i) == i * i);\n     i += 2u;\n   }\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n-    check (hm.insert(i, i * i));\n+    assert (hm.insert(i, i * i));\n     log \"inserting \" + _uint.to_str(i, 10u)\n       + \" -> \" + _uint.to_str(i * i, 10u);\n     i += 2u;\n   }\n \n-  check (hm.size() == num_to_insert);\n+  assert (hm.size() == num_to_insert);\n \n   log \"-----\";\n \n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    check (hm.get(i) == i * i);\n+    assert (hm.get(i) == i * i);\n     i += 1u;\n   }\n \n@@ -329,13 +329,13 @@ fn test_removal() {\n \n   log \"-----\";\n \n-  check (hm.size() == num_to_insert);\n+  assert (hm.size() == num_to_insert);\n \n   i = 0u;\n   while (i < num_to_insert) {\n     log \"get(\" + _uint.to_str(i, 10u) + \") = \"\n       + _uint.to_str(hm.get(i), 10u);\n-    check (hm.get(i) == i * i);\n+    assert (hm.get(i) == i * i);\n     i += 1u;\n   }\n "}, {"sha": "7e8efb5eba745a6291d8b1f1bbd32e1425b731d5", "filename": "src/test/run-pass/lib-sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-sha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sha1.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -69,13 +69,13 @@ fn main() {\n     auto tests = fips_180_1_tests + wikipedia_tests;\n \n     fn check_vec_eq(vec[u8] v0, vec[u8] v1) {\n-        check (_vec.len[u8](v0) == _vec.len[u8](v1));\n+        assert (_vec.len[u8](v0) == _vec.len[u8](v1));\n         auto len = _vec.len[u8](v0);\n         auto i = 0u;\n         while (i < len) {\n             auto a = v0.(i);\n             auto b = v1.(i);\n-            check (a == b);\n+            assert (a == b);\n             i += 1u;\n         }\n     }"}, {"sha": "a342b24eb5662f87bcfe3a7049a2f35353a129cd", "filename": "src/test/run-pass/lib-sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-sort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-sort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-sort.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -10,7 +10,7 @@ fn check_sort(vec[int] v1, vec[int] v2) {\n   auto i = 0u;\n   while (i < len) {\n     log v3.(i);\n-    check (v3.(i) == v2.(i));\n+    assert (v3.(i) == v2.(i));\n     i += 1u;\n   }\n }"}, {"sha": "9b8c56bb75121bdd52e5f668970293b46202bc0d", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,8 +8,8 @@ fn main() {\n     auto s = \"hello\";\n     auto sb = _str.rustrt.str_buf(s);\n     auto s_cstr = _str.rustrt.str_from_cstr(sb);\n-    check (_str.eq(s_cstr, s));\n+    assert (_str.eq(s_cstr, s));\n     auto s_buf = _str.rustrt.str_from_buf(sb, 5u);\n-    check (_str.eq(s_buf, s));\n+    assert (_str.eq(s_buf, s));\n }\n "}, {"sha": "767177111b2b8a64b5c2caa4f263ea1db178c4df", "filename": "src/test/run-pass/lib-str.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,22 +2,22 @@ use std;\n import std._str;\n \n fn test_bytes_len() {\n-  check (_str.byte_len(\"\") == 0u);\n-  check (_str.byte_len(\"hello world\") == 11u);\n-  check (_str.byte_len(\"\\x63\") == 1u);\n-  check (_str.byte_len(\"\\xa2\") == 2u);\n-  check (_str.byte_len(\"\\u03c0\") == 2u);\n-  check (_str.byte_len(\"\\u2620\") == 3u);\n-  check (_str.byte_len(\"\\U0001d11e\") == 4u);\n+  assert (_str.byte_len(\"\") == 0u);\n+  assert (_str.byte_len(\"hello world\") == 11u);\n+  assert (_str.byte_len(\"\\x63\") == 1u);\n+  assert (_str.byte_len(\"\\xa2\") == 2u);\n+  assert (_str.byte_len(\"\\u03c0\") == 2u);\n+  assert (_str.byte_len(\"\\u2620\") == 3u);\n+  assert (_str.byte_len(\"\\U0001d11e\") == 4u);\n }\n \n fn test_index_and_rindex() {\n-  check(_str.index(\"hello\", 'e' as u8) == 1);\n-  check(_str.index(\"hello\", 'o' as u8) == 4);\n-  check(_str.index(\"hello\", 'z' as u8) == -1);\n-  check(_str.rindex(\"hello\", 'l' as u8) == 3);\n-  check(_str.rindex(\"hello\", 'h' as u8) == 0);\n-  check(_str.rindex(\"hello\", 'z' as u8) == -1);\n+  assert (_str.index(\"hello\", 'e' as u8) == 1);\n+  assert (_str.index(\"hello\", 'o' as u8) == 4);\n+  assert (_str.index(\"hello\", 'z' as u8) == -1);\n+  assert (_str.rindex(\"hello\", 'l' as u8) == 3);\n+  assert (_str.rindex(\"hello\", 'h' as u8) == 0);\n+  assert (_str.rindex(\"hello\", 'z' as u8) == -1);\n }\n \n fn test_split() {\n@@ -30,7 +30,7 @@ fn test_split() {\n       log z;\n     }\n     log \"comparing: \" + v.(i) + \" vs. \" + k;\n-    check(_str.eq(v.(i), k));\n+    assert (_str.eq(v.(i), k));\n   }\n   t(\"abc.hello.there\", '.', 0, \"abc\");\n   t(\"abc.hello.there\", '.', 1, \"hello\");\n@@ -46,7 +46,7 @@ fn test_find() {\n     let int j = _str.find(haystack,needle);\n     log \"searched for \" + needle;\n     log j;\n-    check (i == j);\n+    assert (i == j);\n   }\n   t(\"this is a simple\", \"is a\", 5);\n   t(\"this is a simple\", \"is z\", -1);\n@@ -57,7 +57,7 @@ fn test_find() {\n \n fn test_substr() {\n   fn t(&str a, &str b, int start) {\n-    check(_str.eq(_str.substr(a, start as uint,\n+    assert (_str.eq(_str.substr(a, start as uint,\n                               _str.byte_len(b)), b));\n   }\n \n@@ -68,7 +68,7 @@ fn test_substr() {\n \n fn test_concat() {\n   fn t(&vec[str] v, &str s) {\n-    check(_str.eq(_str.concat(v), s));\n+    assert (_str.eq(_str.concat(v), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \"youknowI'mnogood\");\n@@ -79,7 +79,7 @@ fn test_concat() {\n \n fn test_connect() {\n   fn t(&vec[str] v, &str sep, &str s) {\n-    check(_str.eq(_str.connect(v, sep), s));\n+    assert (_str.eq(_str.connect(v, sep), s));\n   }\n \n   t(vec(\"you\", \"know\", \"I'm\", \"no\", \"good\"), \" \", \"you know I'm no good\");\n@@ -95,7 +95,7 @@ fn test_to_upper() {\n   auto input = \"abcDEF\" + unicode + \"xyz:.;\";\n   auto expected = \"ABCDEF\" + unicode + \"XYZ:.;\";\n   auto actual = _str.to_upper(input);\n-  check (_str.eq(expected, actual));\n+  assert (_str.eq(expected, actual));\n }\n \n "}, {"sha": "64d39619f0b775500c13cb84c0cf289568bccc91", "filename": "src/test/run-pass/lib-uint.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-uint.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,44 +4,44 @@ use std;\n import std._uint;\n \n fn main() {\n-  check (_uint.next_power_of_two(0u) == 0u);\n-  check (_uint.next_power_of_two(1u) == 1u);\n-  check (_uint.next_power_of_two(2u) == 2u);\n-  check (_uint.next_power_of_two(3u) == 4u);\n-  check (_uint.next_power_of_two(4u) == 4u);\n-  check (_uint.next_power_of_two(5u) == 8u);\n-  check (_uint.next_power_of_two(6u) == 8u);\n-  check (_uint.next_power_of_two(7u) == 8u);\n-  check (_uint.next_power_of_two(8u) == 8u);\n-  check (_uint.next_power_of_two(9u) == 16u);\n-  check (_uint.next_power_of_two(10u) == 16u);\n-  check (_uint.next_power_of_two(11u) == 16u);\n-  check (_uint.next_power_of_two(12u) == 16u);\n-  check (_uint.next_power_of_two(13u) == 16u);\n-  check (_uint.next_power_of_two(14u) == 16u);\n-  check (_uint.next_power_of_two(15u) == 16u);\n-  check (_uint.next_power_of_two(16u) == 16u);\n-  check (_uint.next_power_of_two(17u) == 32u);\n-  check (_uint.next_power_of_two(18u) == 32u);\n-  check (_uint.next_power_of_two(19u) == 32u);\n-  check (_uint.next_power_of_two(20u) == 32u);\n-  check (_uint.next_power_of_two(21u) == 32u);\n-  check (_uint.next_power_of_two(22u) == 32u);\n-  check (_uint.next_power_of_two(23u) == 32u);\n-  check (_uint.next_power_of_two(24u) == 32u);\n-  check (_uint.next_power_of_two(25u) == 32u);\n-  check (_uint.next_power_of_two(26u) == 32u);\n-  check (_uint.next_power_of_two(27u) == 32u);\n-  check (_uint.next_power_of_two(28u) == 32u);\n-  check (_uint.next_power_of_two(29u) == 32u);\n-  check (_uint.next_power_of_two(30u) == 32u);\n-  check (_uint.next_power_of_two(31u) == 32u);\n-  check (_uint.next_power_of_two(32u) == 32u);\n-  check (_uint.next_power_of_two(33u) == 64u);\n-  check (_uint.next_power_of_two(34u) == 64u);\n-  check (_uint.next_power_of_two(35u) == 64u);\n-  check (_uint.next_power_of_two(36u) == 64u);\n-  check (_uint.next_power_of_two(37u) == 64u);\n-  check (_uint.next_power_of_two(38u) == 64u);\n-  check (_uint.next_power_of_two(39u) == 64u);\n+  assert (_uint.next_power_of_two(0u) == 0u);\n+  assert (_uint.next_power_of_two(1u) == 1u);\n+  assert (_uint.next_power_of_two(2u) == 2u);\n+  assert (_uint.next_power_of_two(3u) == 4u);\n+  assert (_uint.next_power_of_two(4u) == 4u);\n+  assert (_uint.next_power_of_two(5u) == 8u);\n+  assert (_uint.next_power_of_two(6u) == 8u);\n+  assert (_uint.next_power_of_two(7u) == 8u);\n+  assert (_uint.next_power_of_two(8u) == 8u);\n+  assert (_uint.next_power_of_two(9u) == 16u);\n+  assert (_uint.next_power_of_two(10u) == 16u);\n+  assert (_uint.next_power_of_two(11u) == 16u);\n+  assert (_uint.next_power_of_two(12u) == 16u);\n+  assert (_uint.next_power_of_two(13u) == 16u);\n+  assert (_uint.next_power_of_two(14u) == 16u);\n+  assert (_uint.next_power_of_two(15u) == 16u);\n+  assert (_uint.next_power_of_two(16u) == 16u);\n+  assert (_uint.next_power_of_two(17u) == 32u);\n+  assert (_uint.next_power_of_two(18u) == 32u);\n+  assert (_uint.next_power_of_two(19u) == 32u);\n+  assert (_uint.next_power_of_two(20u) == 32u);\n+  assert (_uint.next_power_of_two(21u) == 32u);\n+  assert (_uint.next_power_of_two(22u) == 32u);\n+  assert (_uint.next_power_of_two(23u) == 32u);\n+  assert (_uint.next_power_of_two(24u) == 32u);\n+  assert (_uint.next_power_of_two(25u) == 32u);\n+  assert (_uint.next_power_of_two(26u) == 32u);\n+  assert (_uint.next_power_of_two(27u) == 32u);\n+  assert (_uint.next_power_of_two(28u) == 32u);\n+  assert (_uint.next_power_of_two(29u) == 32u);\n+  assert (_uint.next_power_of_two(30u) == 32u);\n+  assert (_uint.next_power_of_two(31u) == 32u);\n+  assert (_uint.next_power_of_two(32u) == 32u);\n+  assert (_uint.next_power_of_two(33u) == 64u);\n+  assert (_uint.next_power_of_two(34u) == 64u);\n+  assert (_uint.next_power_of_two(35u) == 64u);\n+  assert (_uint.next_power_of_two(36u) == 64u);\n+  assert (_uint.next_power_of_two(37u) == 64u);\n+  assert (_uint.next_power_of_two(38u) == 64u);\n+  assert (_uint.next_power_of_two(39u) == 64u);\n }"}, {"sha": "3724d627b498441da73c78bfedd6e451b9d847d2", "filename": "src/test/run-pass/lib-vec-str-conversions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec-str-conversions.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -21,14 +21,14 @@ fn test_simple() {\n   let uint n1 = _str.byte_len(s1);\n   let uint n2 = _vec.len[u8](v);\n \n-  check (n1 == n2);\n+  assert (n1 == n2);\n \n   while (i < n1) {\n     let u8 a = s1.(i);\n     let u8 b = s2.(i);\n     log a;\n     log b;\n-    check (a == b);\n+    assert (a == b);\n     i += 1u;\n   }\n "}, {"sha": "51341039c691c6cb9cd8b244a640d25acee5551c", "filename": "src/test/run-pass/lib-vec.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flib-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-vec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,10 +2,10 @@ use std;\n \n fn test_init_elt() {\n   let vec[uint] v = std._vec.init_elt[uint](5u, 3u);\n-  check (std._vec.len[uint](v) == 3u);\n-  check (v.(0) == 5u);\n-  check (v.(1) == 5u);\n-  check (v.(2) == 5u);\n+  assert (std._vec.len[uint](v) == 3u);\n+  assert (v.(0) == 5u);\n+  assert (v.(1) == 5u);\n+  assert (v.(2) == 5u);\n }\n \n fn id(uint x) -> uint {\n@@ -14,20 +14,20 @@ fn id(uint x) -> uint {\n fn test_init_fn() {\n   let fn(uint)->uint op = id;\n   let vec[uint] v = std._vec.init_fn[uint](op, 5u);\n-  check (std._vec.len[uint](v) == 5u);\n-  check (v.(0) == 0u);\n-  check (v.(1) == 1u);\n-  check (v.(2) == 2u);\n-  check (v.(3) == 3u);\n-  check (v.(4) == 4u);\n+  assert (std._vec.len[uint](v) == 5u);\n+  assert (v.(0) == 0u);\n+  assert (v.(1) == 1u);\n+  assert (v.(2) == 2u);\n+  assert (v.(3) == 3u);\n+  assert (v.(4) == 4u);\n }\n \n fn test_slice() {\n   let vec[int] v = vec(1,2,3,4,5);\n   auto v2 = std._vec.slice[int](v, 2u, 4u);\n-  check (std._vec.len[int](v2) == 2u);\n-  check (v2.(0) == 3);\n-  check (v2.(1) == 4);\n+  assert (std._vec.len[int](v2) == 2u);\n+  assert (v2.(0) == 3);\n+  assert (v2.(1) == 4);\n }\n \n fn test_map() {\n@@ -37,7 +37,7 @@ fn test_map() {\n   let vec[int] s = std._vec.map[int, int](op, v);\n   let int i = 0;\n   while (i < 5) {\n-    check (v.(i) * v.(i) == s.(i));\n+    assert (v.(i) * v.(i) == s.(i));\n     i += 1;\n   }\n }\n@@ -51,7 +51,7 @@ fn test_map2() {\n \n   auto i = 0;\n   while (i < 5) {\n-    check (v0.(i) * v1.(i) == u.(i));\n+    assert (v0.(i) * v1.(i) == u.(i));\n     i += 1;\n   }\n }"}, {"sha": "c816f817225dd11fc0fcb9a2e75c0a3848dbd8cf", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,30 +6,30 @@ fn main() {\n     y += i;\n   }\n   log y;\n-  check (y == 6);\n+  assert (y == 6);\n \n   auto s = \"hello there\";\n   let int i = 0;\n   for (u8 c in s) {\n     if (i == 0) {\n-      check (c == ('h' as u8));\n+      assert (c == ('h' as u8));\n     }\n     if (i == 1) {\n-      check (c == ('e' as u8));\n+      assert (c == ('e' as u8));\n     }\n     if (i == 2) {\n-      check (c == ('l' as u8));\n+      assert (c == ('l' as u8));\n     }\n     if (i == 3) {\n-      check (c == ('l' as u8));\n+      assert (c == ('l' as u8));\n     }\n     if (i == 4) {\n-      check (c == ('o' as u8));\n+      assert (c == ('o' as u8));\n     }\n     // ...\n     i += 1;\n     log i;\n     log c;\n   }\n-  check(i == 11);\n+  assert (i == 11);\n }"}, {"sha": "5b67fdc64e07207c7c0b73a1be7cf3bcf0754228", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -19,5 +19,5 @@ fn main() {\n   let int y <- p;\n   log \"transmission complete\";\n   log y;\n-  check (y == 500);\n+  assert (y == 500);\n }"}, {"sha": "71d4dfe927d0fcb89a7eb579f44ab6ebc7cfa8ea", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -13,5 +13,5 @@ fn main() {\n   grow(v);\n   auto len = std._vec.len[int](v);\n   log len;\n-  check (len == (3 as uint));\n+  assert (len == (3 as uint));\n }"}, {"sha": "e9b7a972dfe264c210475e1c528293d9e8d43ac0", "filename": "src/test/run-pass/native-opaque-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,5 +3,5 @@ native mod libc {\n }\n \n fn main() {\n-  check (true);\n+  assert (true);\n }"}, {"sha": "28868548bbc272ca8342445bece8a924d8602d5d", "filename": "src/test/run-pass/obj-as.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-as.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -15,10 +15,10 @@ type small = obj {\n fn main() {\n \n   let big b = big();\n-  check (b.one() == 1);\n-  check (b.two() == 2);\n-  check (b.three() == 3);\n+  assert (b.one() == 1);\n+  assert (b.two() == 2);\n+  assert (b.three() == 3);\n \n   let small s = b as small;\n-  check (s.one() == 1);\n+  assert (s.one() == 1);\n }\n\\ No newline at end of file"}, {"sha": "f512e6ee86837fecf5e4a79aefefaf4bf8ba57f0", "filename": "src/test/run-pass/obj-dtor-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor-2.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -14,5 +14,5 @@ fn main() {\n   {\n     auto x = foo(mbox);\n   }\n-  check ((*mbox) == 11);\n+  assert ((*mbox) == 11);\n }\n\\ No newline at end of file"}, {"sha": "62e0de87ef42ea4b2636853606f181a1edf329e3", "filename": "src/test/run-pass/obj-dtor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -29,6 +29,6 @@ fn main() {\n   log \"parent waiting for shutdown\";\n   i <- p;\n   log \"received int\";\n-  check (i == 10);\n+  assert (i == 10);\n   log \"int is OK, child-dtor ran as expected\";\n }\n\\ No newline at end of file"}, {"sha": "208d0ded41ac054b29759022b8a45b0ecf4c3351", "filename": "src/test/run-pass/obj-self-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-self-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-self-3.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -19,11 +19,11 @@ fn main() {\n   let int i = 0;\n \n   i = a.m1(i);\n-  check (i == 1);\n+  assert (i == 1);\n   i = a.m2(i);\n-  check (i == 2);\n+  assert (i == 2);\n   i = a.m3(i);\n-  check (i == 4);\n+  assert (i == 4);\n }\n \n "}, {"sha": "b298f75f969f215a08bce398d014e70548c35325", "filename": "src/test/run-pass/obj-with-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,5 +7,5 @@ fn main() {\n   }\n   auto b = buf(vec(1 as u8, 2 as u8, 3 as u8));\n   log b.get(1);\n-  check (b.get(1) == (2 as u8));\n+  assert (b.get(1) == (2 as u8));\n }"}, {"sha": "0c905ab95e0aa5337709532dfc719cf5c5102b5a", "filename": "src/test/run-pass/opeq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fopeq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fopeq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fopeq.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,18 +5,18 @@ fn main() {\n \n   x *= 2;\n   log x;\n-  check (x == 2);\n+  assert (x == 2);\n \n   x += 3;\n   log x;\n-  check (x == 5);\n+  assert (x == 5);\n \n   x *= x;\n   log x;\n-  check (x == 25);\n+  assert (x == 25);\n \n   x /= 5;\n   log x;\n-  check (x == 5);\n+  assert (x == 5);\n }\n "}, {"sha": "403d7c2ed2caf0185aae921a8bbc63f03d05c16f", "filename": "src/test/run-pass/operator-associativity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-associativity.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,4 +1,4 @@\n // Testcase for issue #130, operator associativity.\n fn main() -> () {\n-  check ((3 * 5 / 2) == 7);\n+  assert ((3 * 5 / 2) == 7);\n }"}, {"sha": "57dcb3b2d077e93c57a0535279dd8a497b79f63f", "filename": "src/test/run-pass/readalias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Freadalias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Freadalias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freadalias.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,7 +3,7 @@\n type point = rec(int x, int y, int z);\n \n fn f(&point p) {\n-  check (p.z == 12);\n+  assert (p.z == 12);\n }\n \n fn main() {"}, {"sha": "ada02597572ec909de3ff24834f931cefd564db1", "filename": "src/test/run-pass/rec-extend.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-extend.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,12 +8,12 @@ fn main() {\n   let point right = rec(x=origin.x + 10 with origin);\n   let point up = rec(y=origin.y + 10 with origin);\n \n-  check(origin.x == 0);\n-  check(origin.y == 0);\n+  assert (origin.x == 0);\n+  assert (origin.y == 0);\n \n-  check(right.x == 10);\n-  check(right.y == 0);\n+  assert (right.x == 10);\n+  assert (right.y == 0);\n \n-  check(up.x == 0);\n-  check(up.y == 10);\n+  assert (up.x == 0);\n+  assert (up.y == 10);\n }"}, {"sha": "30db041706281ebe4e7268e8c4dc21197926479a", "filename": "src/test/run-pass/rec-tup.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-tup.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,22 +4,22 @@ type point = rec(int x, int y);\n type rect = tup(point, point);\n \n fn f(rect r, int x1, int y1, int x2, int y2) {\n-  check (r._0.x == x1);\n-  check (r._0.y == y1);\n-  check (r._1.x == x2);\n-  check (r._1.y == y2);\n+  assert (r._0.x == x1);\n+  assert (r._0.y == y1);\n+  assert (r._1.x == x2);\n+  assert (r._1.y == y2);\n }\n \n fn main() {\n   let rect r = tup( rec(x=10, y=20),\n                     rec(x=11, y=22) );\n-  check (r._0.x == 10);\n-  check (r._0.y == 20);\n-  check (r._1.x == 11);\n-  check (r._1.y == 22);\n+  assert (r._0.x == 10);\n+  assert (r._0.y == 20);\n+  assert (r._1.x == 11);\n+  assert (r._1.y == 22);\n   let rect r2 = r;\n   let int x = r2._0.x;\n-  check (x == 10);\n+  assert (x == 10);\n   f(r, 10, 20, 11, 22);\n   f(r2, 10, 20, 11, 22);\n }"}, {"sha": "7d295f6fb610c1e53fa6e35b51be139832272778", "filename": "src/test/run-pass/rec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,21 +3,21 @@\n type rect = rec(int x, int y, int w, int h);\n \n fn f(rect r, int x, int y, int w, int h) {\n-  check (r.x == x);\n-  check (r.y == y);\n-  check (r.w == w);\n-  check (r.h == h);\n+  assert (r.x == x);\n+  assert (r.y == y);\n+  assert (r.w == w);\n+  assert (r.h == h);\n }\n \n fn main() {\n   let rect r = rec(x=10, y=20, w=100, h=200);\n-  check (r.x == 10);\n-  check (r.y == 20);\n-  check (r.w == 100);\n-  check (r.h == 200);\n+  assert (r.x == 10);\n+  assert (r.y == 20);\n+  assert (r.w == 100);\n+  assert (r.h == 200);\n   let rect r2 = r;\n   let int x = r2.x;\n-  check (x == 10);\n+  assert (x == 10);\n   f(r, 10, 20, 100, 200);\n   f(r2, 10, 20, 100, 200);\n }"}, {"sha": "cd808ad733deb46908752ef22cea0d5b4cfe1994", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -74,9 +74,9 @@ fn test_rotate() {\n         mychan <| val;\n \n         auto x <- myport;\n-        check (x.val1 == i as u32);\n-        check (x.val2 == i as u32);\n-        check (x.val3 == i as u32);\n+        assert (x.val1 == i as u32);\n+        assert (x.val2 == i as u32);\n+        assert (x.val3 == i as u32);\n     }\n }\n \n@@ -96,9 +96,9 @@ fn test_rotate_grow() {\n \n         for each (uint i in _uint.range(0u, 10u)) {\n             auto x <- myport;\n-            check (x.val1 == i as u32);\n-            check (x.val2 == i as u32);\n-            check (x.val3 == i as u32);\n+            assert (x.val1 == i as u32);\n+            assert (x.val2 == i as u32);\n+            assert (x.val3 == i as u32);\n         }\n     }\n }"}, {"sha": "942e9e90d94dd37bad4d856a506c9ca991fdc854", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,16 +1,16 @@\n // xfail-boot\n fn main() {\n-  check (\"hello\" < \"hellr\");\n-  check (\"hello \" > \"hello\");\n-  check (\"hello\" != \"there\");\n+  assert (\"hello\" < \"hellr\");\n+  assert (\"hello \" > \"hello\");\n+  assert (\"hello\" != \"there\");\n \n-  check (vec(1,2,3,4) > vec(1,2,3));\n-  check (vec(1,2,3) < vec(1,2,3,4));\n-  check (vec(1,2,4,4) > vec(1,2,3,4));\n-  check (vec(1,2,3,4) < vec(1,2,4,4));\n-  check (vec(1,2,3) <= vec(1,2,3));\n-  check (vec(1,2,3) <= vec(1,2,3,3));\n-  check (vec(1,2,3,4) > vec(1,2,3));\n-  check (vec(1,2,3) == vec(1,2,3));\n-  check (vec(1,2,3) != vec(1,1,3));\n+  assert (vec(1,2,3,4) > vec(1,2,3));\n+  assert (vec(1,2,3) < vec(1,2,3,4));\n+  assert (vec(1,2,4,4) > vec(1,2,3,4));\n+  assert (vec(1,2,3,4) < vec(1,2,4,4));\n+  assert (vec(1,2,3) <= vec(1,2,3));\n+  assert (vec(1,2,3) <= vec(1,2,3,3));\n+  assert (vec(1,2,3,4) > vec(1,2,3));\n+  assert (vec(1,2,3) == vec(1,2,3));\n+  assert (vec(1,2,3) != vec(1,1,3));\n }"}, {"sha": "b0f0cf3b9693c70cdf71e02a0276a968c699ae51", "filename": "src/test/run-pass/stateful-obj.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstateful-obj.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -14,10 +14,10 @@ obj counter(mutable int x) {\n \n fn main() {\n   auto y = counter(0);\n-  check (y.hello() == 12345);\n+  assert (y.hello() == 12345);\n   log y.get();\n   y.incr();\n   y.incr();\n   log y.get();\n-  check (y.get() == 2);\n+  assert (y.get() == 2);\n }"}, {"sha": "abfbe938e223f0dd6b97c9efbcf650c6f8714480", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -7,7 +7,7 @@ fn test1() {\n   let str s = \"hello\";\n   s += \"world\";\n   log s;\n-  check(s.(9) == ('d' as u8));\n+  assert (s.(9) == ('d' as u8));\n }\n \n fn test2() {\n@@ -20,8 +20,8 @@ fn test2() {\n   log a;\n   log b;\n \n-  check (_str.eq(a, \"abcABCabc\"));\n-  check (_str.eq(b, \"ABCabcABC\"));\n+  assert (_str.eq(a, \"abcABCabc\"));\n+  assert (_str.eq(b, \"ABCabcABC\"));\n }\n \n fn main() {"}, {"sha": "a21fefbe23fd9dd0e16c3a4ff3dd29bc41f074c0", "filename": "src/test/run-pass/str-concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-concat.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,5 +5,5 @@ fn main() {\n   let str b = \"world\";\n   let str s = a + b;\n   log s;\n-  check(s.(9) == ('d' as u8));\n+  assert (s.(9) == ('d' as u8));\n }"}, {"sha": "55548da519c9f883c8fee4dd35ebc07529edaa4d", "filename": "src/test/run-pass/str-growth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-growth.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,14 +1,14 @@\n fn main() {\n     auto s = \"a\";\n     s += \"b\";\n-    check (s.(0) == ('a' as u8));\n-    check (s.(1) == ('b' as u8));\n+    assert (s.(0) == ('a' as u8));\n+    assert (s.(1) == ('b' as u8));\n \n     s += \"c\";\n     s += \"d\";\n-    check (s.(0) == ('a' as u8));\n-    check (s.(1) == ('b' as u8));\n-    check (s.(2) == ('c' as u8));\n-    check (s.(3) == ('d' as u8));\n+    assert (s.(0) == ('a' as u8));\n+    assert (s.(1) == ('b' as u8));\n+    assert (s.(2) == ('c' as u8));\n+    assert (s.(3) == ('d' as u8));\n }\n "}, {"sha": "e2f5abb292754ccade08447a4cb508e50f081828", "filename": "src/test/run-pass/str-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-idx.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,5 +3,5 @@ fn main() {\n   auto s = \"hello\";\n   let u8 c = s.(4);\n   log c;\n-  check (c == (0x6f as u8));\n+  assert (c == (0x6f as u8));\n }"}, {"sha": "15ddba8465f1bd16c491b868f89a2028370028ec", "filename": "src/test/run-pass/structured-compare-recursive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,6 +4,6 @@ tag taggy {\n }\n \n fn main() {\n-    check (bar <= bar);\n+    assert (bar <= bar);\n }\n "}, {"sha": "e677c3cb0bf878ece83f12773e1e2b66c7875411", "filename": "src/test/run-pass/structured-compare.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fstructured-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,15 +6,15 @@ tag foo {\n fn main() {\n   auto a = tup(1,2,3);\n   auto b = tup(1,2,3);\n-  check (a == b);\n-  check (a != tup(1,2,4));\n-  check (a < tup(1,2,4));\n-  check (a <= tup(1,2,4));\n-  check (tup(1,2,4) > a);\n-  check (tup(1,2,4) >= a);\n+  assert (a == b);\n+  assert (a != tup(1,2,4));\n+  assert (a < tup(1,2,4));\n+  assert (a <= tup(1,2,4));\n+  assert (tup(1,2,4) > a);\n+  assert (tup(1,2,4) >= a);\n   auto x = large;\n   auto y = small;\n-  check (x != y);\n-  check (x == large);\n-  check (x != small);\n+  assert (x != y);\n+  assert (x == large);\n+  assert (x != small);\n }\n\\ No newline at end of file"}, {"sha": "5248e782bec5b1c47528af8bbf402197ea27c085", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,7 +6,7 @@ import std._str;\n fn test(str actual, str expected) {\n   log actual;\n   log expected;\n-  check (_str.eq(actual, expected));\n+  assert (_str.eq(actual, expected));\n }\n \n fn main() {"}, {"sha": "695832b129dad9b9be838dba36943e7ff08f1014", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,7 +9,7 @@ fn f() {\n   auto x = red(1,2);\n   auto y = green;\n   // FIXME: needs structural equality test working.\n-  // check (x != y);\n+  // assert (x != y);\n }\n \n fn main() {"}, {"sha": "fec48a748c6fd39352a1f5723547eb03f1225f03", "filename": "src/test/run-pass/tail-cps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-cps.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,7 +1,7 @@\n // -*- rust -*-\n \n fn checktrue(bool res) -> bool {\n-  check(res);\n+  assert (res);\n   ret true;\n }\n "}, {"sha": "ac29bcad167929d4f0d69e44b191713ea7abff25", "filename": "src/test/run-pass/tail-direct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-direct.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -1,8 +1,8 @@\n // -*- rust -*-\n \n fn main() {\n-  check(even(42));\n-  check(odd(45));\n+  assert (even(42));\n+  assert (odd(45));\n }\n \n fn even(int n) -> bool {"}, {"sha": "54e37a34441071879053a8370a1b80424ab1496e", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -16,5 +16,5 @@ fn test05() {\n     let int value <- po;\n     value <- po;\n     value <- po;\n-    check(value == 30);\n+    assert (value == 30);\n }"}, {"sha": "9438f50ef4d44167a26e961c337f3fcb5f362d3b", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -14,9 +14,9 @@ fn test_rec() {\n   let r r1;\n   r1 <- po;\n \n-  check (r1.val0 == 0);\n-  check (r1.val1 == 1u8);\n-  check (r1.val2 == '2');\n+  assert (r1.val0 == 0);\n+  assert (r1.val1 == 1u8);\n+  assert (r1.val2 == '2');\n }\n \n fn test_vec() {\n@@ -29,9 +29,9 @@ fn test_vec() {\n   let vec[int] v1;\n   v1 <- po;\n \n-  check (v1.(0) == 0);\n-  check (v1.(1) == 1);\n-  check (v1.(2) == 2);\n+  assert (v1.(0) == 0);\n+  assert (v1.(1) == 1);\n+  assert (v1.(2) == 2);\n }\n \n fn test_str() {\n@@ -44,10 +44,10 @@ fn test_str() {\n   let str s1;\n   s1 <- po;\n \n-  check (s1.(0) as u8 == 't' as u8);\n-  check (s1.(1) as u8 == 'e' as u8);\n-  check (s1.(2) as u8 == 's' as u8);\n-  check (s1.(3) as u8 == 't' as u8);\n+  assert (s1.(0) as u8 == 't' as u8);\n+  assert (s1.(1) as u8 == 'e' as u8);\n+  assert (s1.(2) as u8 == 's' as u8);\n+  assert (s1.(3) as u8 == 't' as u8);\n }\n \n fn test_tup() {\n@@ -62,9 +62,9 @@ fn test_tup() {\n   let t t1;\n   t1 <- po;\n \n-  check (t0._0 == 0);\n-  check (t0._1 == 1u8);\n-  check (t0._2 == '2');\n+  assert (t0._0 == 0);\n+  assert (t0._1 == 1u8);\n+  assert (t0._2 == '2');\n }\n \n fn test_tag() {\n@@ -84,11 +84,11 @@ fn test_tag() {\n   let t t1;\n \n   t1 <- po;\n-  check (t1 == tag1);\n+  assert (t1 == tag1);\n   t1 <- po;\n-  check (t1 == tag2(10));\n+  assert (t1 == tag2(10));\n   t1 <- po;\n-  check (t1 == tag3(10, 11u8, 'A'));\n+  assert (t1 == tag3(10, 11u8, 'A'));\n }\n \n fn test_chan() {\n@@ -109,7 +109,7 @@ fn test_chan() {\n   let int i;\n   i <- po0;\n \n-  check (i == 10);\n+  assert (i == 10);\n }\n \n fn main() {"}, {"sha": "59c46c4c9dbbb170116748c6b933152c596ab623", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -58,7 +58,7 @@ fn test00(bool is_multithreaded) {\n     }\n     \n     log \"Completed: Final number is: \";\n-    // check (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) * \n+    // assert (sum == (((number_of_tasks * (number_of_tasks - 1)) / 2) * \n     //       number_of_messages));\n-    check (sum == 480);\n+    assert (sum == 480);\n }"}, {"sha": "3c4f3ab6ae04196ef4833c2733df443a694642fa", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -28,5 +28,5 @@ fn test00() {\n     r <- p; sum += r; log (r);\n     r <- p; sum += r; log (r);\n     \n-    check (sum == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);\n+    assert (sum == 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);\n }\n\\ No newline at end of file"}, {"sha": "324ce0eddc73d2efef3df2495e1c0f42ad37ba67", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -21,5 +21,5 @@ fn test00() {\n         i += 1;\n     }\n     \n-    check (sum == ((number_of_messages * (number_of_messages - 1)) / 2));\n+    assert (sum == ((number_of_messages * (number_of_messages - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "0f98ba5b00c783ee0292bf585be16a4c89b3450a", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    check (sum == 1998000);\n-    // check (sum == 4 * ((number_of_messages * \n+    assert (sum == 1998000);\n+    // assert (sum == 4 * ((number_of_messages * \n     //                   (number_of_messages - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "f9fbab88be30f7bdb905b16b1cbdfc03c6bb87c6", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -40,6 +40,6 @@ fn test00() {\n     join t2;\n     join t3;\n     \n-    check (sum == (((number_of_messages * 4) * \n+    assert (sum == (((number_of_messages * 4) * \n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "d115ac4004f59c832e9a141bfd152e56796aa939", "filename": "src/test/run-pass/task-comm-8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-8.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -41,6 +41,6 @@ fn test00() {\n     join t2;\n     join t3;\n     \n-    check (sum == (((number_of_messages * 4) * \n+    assert (sum == (((number_of_messages * 4) * \n                    ((number_of_messages * 4) - 1)) / 2));\n }\n\\ No newline at end of file"}, {"sha": "c1c8a3bd6f97852022a42440761fe7a5b1e7c291", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -29,5 +29,5 @@ fn test00() {\n             \n     join t0;\n     \n-    check (sum == (number_of_messages * (number_of_messages - 1)) / 2);\n+    assert (sum == (number_of_messages * (number_of_messages - 1)) / 2);\n }\n\\ No newline at end of file"}, {"sha": "de7de81af47ba46f2ceee488080efa05248dfddf", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -14,5 +14,5 @@ fn main() {\n   let () n;\n   n <- po;\n \n-  check (n == ());\n+  assert (n == ());\n }"}, {"sha": "d256ced90b180a0e9da3a28751f0b7288285f8ce", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -58,7 +58,7 @@ fn test00(bool is_multithreaded) {\n     }\n     \n     log \"Completed: Final number is: \";\n-    check (sum == number_of_messages * \n+    assert (sum == number_of_messages * \n            (number_of_tasks * number_of_tasks + number_of_tasks) / 2);\n }\n "}, {"sha": "b7670776bd1621772cf36195c4b65bf7341a4302", "filename": "src/test/run-pass/tup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftup.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,17 +3,17 @@\n type point = tup(int, int);\n \n fn f(point p, int x, int y) {\n-  check (p._0 == x);\n-  check (p._1 == y);\n+  assert (p._0 == x);\n+  assert (p._1 == y);\n }\n \n fn main() {\n   let point p = tup(10, 20);\n-  check (p._0 == 10);\n-  check (p._1 == 20);\n+  assert (p._0 == 10);\n+  assert (p._1 == 20);\n   let point p2 = p;\n   let int x = p2._0;\n-  check (x == 10);\n+  assert (x == 10);\n   f(p, 10, 20);\n   f(p2, 10, 20);\n }"}, {"sha": "1903cb76049b80e1bc4968db7b64e35eadc5116b", "filename": "src/test/run-pass/type-sizes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,17 +5,17 @@ import size_of = std.sys.rustrt.size_of;\n use std;\n \n fn main() {\n-  check (size_of[u8]() == (1 as uint));\n-  check (size_of[u32]() == (4 as uint));\n-  check (size_of[char]() == (4 as uint));\n-  check (size_of[i8]() == (1 as uint));\n-  check (size_of[i32]() == (4 as uint));\n-  check (size_of[tup(u8,i8)]() == (2 as uint));\n-  check (size_of[tup(u8,i8,u8)]() == (3 as uint));\n+  assert (size_of[u8]() == (1 as uint));\n+  assert (size_of[u32]() == (4 as uint));\n+  assert (size_of[char]() == (4 as uint));\n+  assert (size_of[i8]() == (1 as uint));\n+  assert (size_of[i32]() == (4 as uint));\n+  assert (size_of[tup(u8,i8)]() == (2 as uint));\n+  assert (size_of[tup(u8,i8,u8)]() == (3 as uint));\n   // Alignment causes padding before the char and the u32.\n-  check (size_of[tup(u8,i8,tup(char,u8),u32)]() == (16 as uint));\n-  check (size_of[int]() == size_of[uint]());\n-  check (size_of[tup(int,())]() == size_of[int]());\n-  check (size_of[tup(int,(),())]() == size_of[int]());\n-  check (size_of[int]() == size_of[rec(int x)]());\n+  assert (size_of[tup(u8,i8,tup(char,u8),u32)]() == (16 as uint));\n+  assert (size_of[int]() == size_of[uint]());\n+  assert (size_of[tup(int,())]() == size_of[int]());\n+  assert (size_of[tup(int,(),())]() == size_of[int]());\n+  assert (size_of[int]() == size_of[rec(int x)]());\n }"}, {"sha": "7e7b5026f27a8f7ee739b0e311517bcc9f2fca96", "filename": "src/test/run-pass/u32-decr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu32-decr.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     let u32 word = (200000u32);\n     word = word - (1u32);\n-    check(word == (199999u32));\n+    assert (word == (199999u32));\n }\n "}, {"sha": "992c61d5865b514c950636b008dbbd4d09a56bcd", "filename": "src/test/run-pass/u8-incr-decr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -8,5 +8,5 @@ fn main() {\n   let u8 y = 35u8;  // 0x23\n   x = x + (7u8);    // 0x7\n   y = y - (9u8);    // 0x9\n-  check(x == y);\n+  assert (x == y);\n }"}, {"sha": "7cc9488948e44b731b485a855a09780a0be745a7", "filename": "src/test/run-pass/u8-incr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ fn main() {\n   let u8 y = 12u8;\n   x = x + (1u8);\n   x = x - (1u8);\n-  check(x == y);\n+  assert (x == y);\n   // x = 14u8;\n   // x = x + 1u8;\n }"}, {"sha": "bf758a4931594babe3b81ac69ee27d765f65383b", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,14 +6,14 @@ fn main() {\n   let char y_diaeresis = '\u00ff'; // 0xff\n   let char pi = '\u03a0';          // 0x3a0\n \n-  check ((yen as int) == 0xa5);\n-  check ((c_cedilla as int) == 0xe7);\n-  check ((thorn as int) == 0xfe);\n-  check ((y_diaeresis as int) == 0xff);\n-  check ((pi as int) == 0x3a0);\n+  assert ((yen as int) == 0xa5);\n+  assert ((c_cedilla as int) == 0xe7);\n+  assert ((thorn as int) == 0xfe);\n+  assert ((y_diaeresis as int) == 0xff);\n+  assert ((pi as int) == 0x3a0);\n \n-  check ((pi as int) == ('\\u03a0' as int));\n-  check (('\\x0a' as int) == ('\\n' as int));\n+  assert ((pi as int) == ('\\u03a0' as int));\n+  assert (('\\x0a' as int) == ('\\n' as int));\n \n   let str bhutan = \"\u0f60\u0f56\u0fb2\u0f74\u0f42\u0f0b\u0f61\u0f74\u0f63\u0f0d\";\n   let str japan = \"\u65e5\u672c\";\n@@ -28,7 +28,7 @@ fn main() {\n   let str austria_e = \"\\u00d6sterreich\";\n \n   let char oo = '\u00d6';\n-  check ((oo as int) == 0xd6);\n+  assert ((oo as int) == 0xd6);\n \n   fn check_str_eq(str a, str b) {\n     let int i = 0;\n@@ -37,7 +37,7 @@ fn main() {\n       log ab;\n       let u8 bb = b.(i);\n       log bb;\n-      check(ab == bb);\n+      assert (ab == bb);\n       i += 1;\n     }\n   }"}, {"sha": "07eaca1927a69bde0613286d0d02d436f4e3ad4b", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,25 +9,25 @@ fn main() {\n   let vec[char] chs = vec('e', '\u00e9', '\u20ac', 0x10000 as char);\n   let str s = _str.from_chars(chs);\n \n-  check(_str.byte_len(s) == 10u);\n-  check(_str.char_len(s) == 4u);\n-  check(_vec.len[char](_str.to_chars(s)) == 4u);\n-  check(_str.eq(_str.from_chars(_str.to_chars(s)), s));\n-  check(_str.char_at(s, 0u) == 'e');\n-  check(_str.char_at(s, 1u) == '\u00e9');\n+  assert (_str.byte_len(s) == 10u);\n+  assert (_str.char_len(s) == 4u);\n+  assert (_vec.len[char](_str.to_chars(s)) == 4u);\n+  assert (_str.eq(_str.from_chars(_str.to_chars(s)), s));\n+  assert (_str.char_at(s, 0u) == 'e');\n+  assert (_str.char_at(s, 1u) == '\u00e9');\n \n-  check(_str.is_utf8(_str.bytes(s)));\n-  check(!_str.is_utf8(vec(0x80_u8)));\n-  check(!_str.is_utf8(vec(0xc0_u8)));\n-  check(!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n+  assert (_str.is_utf8(_str.bytes(s)));\n+  assert (!_str.is_utf8(vec(0x80_u8)));\n+  assert (!_str.is_utf8(vec(0xc0_u8)));\n+  assert (!_str.is_utf8(vec(0xc0_u8, 0x10_u8)));\n \n   auto stack = \"a\u00d7c\u20ac\";\n-  check(_str.pop_char(stack) == '\u20ac');\n-  check(_str.pop_char(stack) == 'c');\n+  assert (_str.pop_char(stack) == '\u20ac');\n+  assert (_str.pop_char(stack) == 'c');\n   _str.push_char(stack, 'u');\n-  check(_str.eq(stack, \"a\u00d7u\"));\n-  check(_str.shift_char(stack) == 'a');\n-  check(_str.shift_char(stack) == '\u00d7');\n+  assert (_str.eq(stack, \"a\u00d7u\"));\n+  assert (_str.shift_char(stack) == 'a');\n+  assert (_str.shift_char(stack) == '\u00d7');\n   _str.unshift_char(stack, '\u00df');\n-  check(_str.eq(stack, \"\u00dfu\"));\n+  assert (_str.eq(stack, \"\u00dfu\"));\n }"}, {"sha": "69db478841d41eb6720a9a2b40bf1b04bfef0c3c", "filename": "src/test/run-pass/vec-append.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -15,9 +15,9 @@ fn fast_growth() {\n   v += vec(6,7,8,9,0);\n \n   log v.(9);\n-  check(v.(0) == 1);\n-  check(v.(7) == 8);\n-  check(v.(9) == 0);\n+  assert (v.(0) == 1);\n+  assert (v.(7) == 8);\n+  assert (v.(9) == 0);\n }\n \n fn slow_growth() {\n@@ -26,7 +26,7 @@ fn slow_growth() {\n   v += vec(17);\n \n   log v.(0);\n-  check (v.(0) == 17);\n+  assert (v.(0) == 17);\n }\n \n fn slow_growth2_helper(str s) {   // ref up: s\n@@ -52,29 +52,29 @@ fn slow_growth2_helper(str s) {   // ref up: s\n     let acc a = acc(v);           // ref up: a, v\n \n     log _vec.refcount[str](v);\n-    check (_vec.refcount[str](v) == 2u);\n+    assert (_vec.refcount[str](v) == 2u);\n \n     a.add(s);                     // ref up: mumble, s.  ref down: v\n \n     log _vec.refcount[str](v);\n     log _str.refcount(s);\n     log _str.refcount(mumble);\n \n-    check (_vec.refcount[str](v) == 1u);\n-    check (_str.refcount(s) == const_refcount);\n-    check (_str.refcount(mumble) == const_refcount);\n+    assert (_vec.refcount[str](v) == 1u);\n+    assert (_str.refcount(s) == const_refcount);\n+    assert (_str.refcount(mumble) == const_refcount);\n \n     log v.(0);\n     log _vec.len[str](v);\n-    check (_str.eq(v.(0), mumble));\n-    check (_vec.len[str](v) == 1u);\n+    assert (_str.eq(v.(0), mumble));\n+    assert (_vec.len[str](v) == 1u);\n   }                               // ref down: a, mumble, s, v\n \n   log _str.refcount(s);\n   log _str.refcount(mumble);\n \n-  check (_str.refcount(s) == const_refcount);\n-  check (_str.refcount(mumble) == const_refcount);\n+  assert (_str.refcount(s) == const_refcount);\n+  assert (_str.refcount(mumble) == const_refcount);\n \n   log mumble;\n   log ss;\n@@ -84,7 +84,7 @@ fn slow_growth2() {\n   let str s = \"hi\";               // ref up: s\n   slow_growth2_helper(s);\n   log _str.refcount(s);\n-  check (_str.refcount(s) == const_refcount);\n+  assert (_str.refcount(s) == const_refcount);\n }\n \n fn main() {"}, {"sha": "09a95402e65f4d35101f21aaf81b34c3d0a7c2ec", "filename": "src/test/run-pass/vec-concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -5,7 +5,7 @@ fn main() {\n   let vec[int] b = vec(6,7,8,9,0);\n   let vec[int] v = a + b;\n   log v.(9);\n-  check(v.(0) == 1);\n-  check(v.(7) == 8);\n-  check(v.(9) == 0);\n+  assert (v.(0) == 1);\n+  assert (v.(7) == 8);\n+  assert (v.(9) == 0);\n }"}, {"sha": "b6976abd3a92e2178f0491f245a74ca0ad79fb11", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,10 +4,10 @@ fn main() {\n     v += vec(3);\n     v += vec(4);\n     v += vec(5);\n-    check (v.(0) == 1);\n-    check (v.(1) == 2);\n-    check (v.(2) == 3);\n-    check (v.(3) == 4);\n-    check (v.(4) == 5);\n+    assert (v.(0) == 1);\n+    assert (v.(1) == 2);\n+    assert (v.(2) == 3);\n+    assert (v.(3) == 4);\n+    assert (v.(4) == 5);\n }\n "}, {"sha": "45f28f9bff29e3bc687ae6727aae285b39e497ba", "filename": "src/test/run-pass/vec-ref-count.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-ref-count.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -6,7 +6,7 @@ fn main() {\n     log_err _vec.refcount[int](v);\n     log_err _vec.refcount[int](v);\n     log_err _vec.refcount[int](v);\n-    check (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n-    check (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n+    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n+    assert (_vec.refcount[int](v) == 1u || _vec.refcount[int](v) == 2u);\n }\n "}, {"sha": "c3042d0c03f843141b9e82900b2f397822848e0f", "filename": "src/test/run-pass/vec-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -4,6 +4,6 @@\n fn main() {\n   let vec[int] v = vec(1,2,3,4,5);\n   auto v2 = v.(1,2);\n-  check (v2.(0) == 2);\n-  check (v2.(1) == 3);\n+  assert (v2.(0) == 2);\n+  assert (v2.(1) == 3);\n }\n\\ No newline at end of file"}, {"sha": "138d0ff2880a0b2bd659748430155333fa1deba1", "filename": "src/test/run-pass/vec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -2,12 +2,12 @@\n \n fn main() {\n   let vec[int] v = vec(10, 20);\n-  check (v.(0) == 10);\n-  check (v.(1) == 20);\n+  assert (v.(0) == 10);\n+  assert (v.(1) == 20);\n   let int x = 0;\n-  check (v.(x) == 10);\n-  check (v.(x + 1) == 20);\n+  assert (v.(x) == 10);\n+  assert (v.(x + 1) == 20);\n   x = x + 1;\n-  check (v.(x) == 20);\n-  check (v.(x-1) == 10);\n+  assert (v.(x) == 20);\n+  assert (v.(x-1) == 10);\n }"}, {"sha": "2adaf24bbc389bbb7f0312d874c79da8e4a758f1", "filename": "src/test/run-pass/while-with-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-with-break.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -11,5 +11,5 @@ fn main() {\n       break; \n     }\n   }\n-  check(i == 95);\n+  assert (i == 95);\n }"}, {"sha": "c0ac1803ac73ff3761a45f904e0e7e3979ba41e1", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa25f22f197682de3b18fc4c8ba068d1feda220f/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=aa25f22f197682de3b18fc4c8ba068d1feda220f", "patch": "@@ -9,5 +9,5 @@ fn f(& mutable point p) {\n fn main() {\n   let point x = rec(x=10, y=11, mutable z=12);\n   f(x);\n-  check (x.z == 13);\n+  assert (x.z == 13);\n }"}]}