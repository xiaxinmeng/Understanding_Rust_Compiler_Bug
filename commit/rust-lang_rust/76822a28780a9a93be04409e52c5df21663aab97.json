{"sha": "76822a28780a9a93be04409e52c5df21663aab97", "node_id": "C_kwDOAAsO6NoAKDc2ODIyYTI4NzgwYTlhOTNiZTA0NDA5ZTUyYzVkZjIxNjYzYWFiOTc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T10:44:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-31T10:44:11Z"}, "message": "Auto merge of #99553 - ChrisDenton:lazy-compat-fn, r=Mark-Simulacrum\n\nRewrite Windows `compat_fn` macro\n\nThis allows using most delay loaded functions before the init code initializes them. It also only preloads a select few functions, rather than all functions.\n\nThis is optimized for the common case where a function is used after already being loaded (or failed to load). The only change in codegen at the call site is to use an atomic load instead of a plain load, which should have negligible or no impact.\n\nI've split the old `compat_fn` macro in two so as not to mix two different use cases. If/when Windows 7 support is dropped `compat_fn_optional` can be removed entirely.\n\nr? rust-lang/libs", "tree": {"sha": "7406e364a2ebce5311f085ba23ee7394bb5bd176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7406e364a2ebce5311f085ba23ee7394bb5bd176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76822a28780a9a93be04409e52c5df21663aab97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76822a28780a9a93be04409e52c5df21663aab97", "html_url": "https://github.com/rust-lang/rust/commit/76822a28780a9a93be04409e52c5df21663aab97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76822a28780a9a93be04409e52c5df21663aab97/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "482153bc208df5fc236cc0e1cddb24e93fcc332f", "url": "https://api.github.com/repos/rust-lang/rust/commits/482153bc208df5fc236cc0e1cddb24e93fcc332f", "html_url": "https://github.com/rust-lang/rust/commit/482153bc208df5fc236cc0e1cddb24e93fcc332f"}, {"sha": "698d4a86c647e4dd44eb83fc717d48153b82bd6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/698d4a86c647e4dd44eb83fc717d48153b82bd6c", "html_url": "https://github.com/rust-lang/rust/commit/698d4a86c647e4dd44eb83fc717d48153b82bd6c"}], "stats": {"total": 269, "additions": 205, "deletions": 64}, "files": [{"sha": "e9c20850420d28db44c9b1c45005289d754b93c5", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/76822a28780a9a93be04409e52c5df21663aab97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76822a28780a9a93be04409e52c5df21663aab97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=76822a28780a9a93be04409e52c5df21663aab97", "patch": "@@ -4,6 +4,7 @@\n #![cfg_attr(test, allow(dead_code))]\n #![unstable(issue = \"none\", feature = \"windows_c\")]\n \n+use crate::ffi::CStr;\n use crate::mem;\n use crate::os::raw::{c_char, c_int, c_long, c_longlong, c_uint, c_ulong, c_ushort};\n use crate::os::windows::io::{BorrowedHandle, HandleOrInvalid, HandleOrNull};\n@@ -1219,8 +1220,8 @@ extern \"system\" {\n \n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n-compat_fn! {\n-    \"kernel32\":\n+compat_fn_with_fallback! {\n+    pub static KERNEL32: &CStr = ansi_str!(\"kernel32\");\n \n     // >= Win10 1607\n     // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreaddescription\n@@ -1243,8 +1244,8 @@ compat_fn! {\n     }\n }\n \n-compat_fn! {\n-    \"api-ms-win-core-synch-l1-2-0\":\n+compat_fn_optional! {\n+    pub static SYNCH_API: &CStr = ansi_str!(\"api-ms-win-core-synch-l1-2-0\");\n \n     // >= Windows 8 / Server 2012\n     // https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitonaddress\n@@ -1253,17 +1254,13 @@ compat_fn! {\n         CompareAddress: LPVOID,\n         AddressSize: SIZE_T,\n         dwMilliseconds: DWORD\n-    ) -> BOOL {\n-        panic!(\"WaitOnAddress not available\")\n-    }\n-    pub fn WakeByAddressSingle(Address: LPVOID) -> () {\n-        // If this api is unavailable, there cannot be anything waiting, because\n-        // WaitOnAddress would've panicked. So it's fine to do nothing here.\n-    }\n+    ) -> BOOL;\n+    pub fn WakeByAddressSingle(Address: LPVOID) -> ();\n }\n \n-compat_fn! {\n-    \"ntdll\":\n+compat_fn_with_fallback! {\n+    pub static NTDLL: &CStr = ansi_str!(\"ntdll\");\n+\n     pub fn NtCreateFile(\n         FileHandle: *mut HANDLE,\n         DesiredAccess: ACCESS_MASK,"}, {"sha": "b4ffbdc960983bfb564269e8ed3195159f7cb057", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 195, "deletions": 51, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/76822a28780a9a93be04409e52c5df21663aab97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76822a28780a9a93be04409e52c5df21663aab97/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=76822a28780a9a93be04409e52c5df21663aab97", "patch": "@@ -49,81 +49,225 @@\n //! * call any Rust function or CRT function that touches any static\n //!   (global) state.\n \n-macro_rules! compat_fn {\n-    ($module:literal: $(\n+use crate::ffi::{c_void, CStr};\n+use crate::ptr::NonNull;\n+use crate::sys::c;\n+\n+/// Helper macro for creating CStrs from literals and symbol names.\n+macro_rules! ansi_str {\n+    (sym $ident:ident) => {{\n+        #[allow(unused_unsafe)]\n+        crate::sys::compat::const_cstr_from_bytes(concat!(stringify!($ident), \"\\0\").as_bytes())\n+    }};\n+    ($lit:literal) => {{ crate::sys::compat::const_cstr_from_bytes(concat!($lit, \"\\0\").as_bytes()) }};\n+}\n+\n+/// Creates a C string wrapper from a byte slice, in a constant context.\n+///\n+/// This is a utility function used by the [`ansi_str`] macro.\n+///\n+/// # Panics\n+///\n+/// Panics if the slice is not null terminated or contains nulls, except as the last item\n+pub(crate) const fn const_cstr_from_bytes(bytes: &'static [u8]) -> &'static CStr {\n+    if !matches!(bytes.last(), Some(&0)) {\n+        panic!(\"A CStr must be null terminated\");\n+    }\n+    let mut i = 0;\n+    // At this point `len()` is at least 1.\n+    while i < bytes.len() - 1 {\n+        if bytes[i] == 0 {\n+            panic!(\"A CStr must not have interior nulls\")\n+        }\n+        i += 1;\n+    }\n+    // SAFETY: The safety is ensured by the above checks.\n+    unsafe { crate::ffi::CStr::from_bytes_with_nul_unchecked(bytes) }\n+}\n+\n+#[used]\n+#[link_section = \".CRT$XCU\"]\n+static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n+\n+/// This is where the magic preloading of symbols happens.\n+///\n+/// Note that any functions included here will be unconditionally included in\n+/// the final binary, regardless of whether or not they're actually used.\n+///\n+/// Therefore, this is limited to `compat_fn_optional` functions which must be\n+/// preloaded and any functions which may be more time sensitive, even for the first call.\n+unsafe extern \"C\" fn init() {\n+    // There is no locking here. This code is executed before main() is entered, and\n+    // is guaranteed to be single-threaded.\n+    //\n+    // DO NOT do anything interesting or complicated in this function! DO NOT call\n+    // any Rust functions or CRT functions if those functions touch any global state,\n+    // because this function runs during global initialization. For example, DO NOT\n+    // do any dynamic allocation, don't call LoadLibrary, etc.\n+\n+    if let Some(synch) = Module::new(c::SYNCH_API) {\n+        // These are optional and so we must manually attempt to load them\n+        // before they can be used.\n+        c::WaitOnAddress::preload(synch);\n+        c::WakeByAddressSingle::preload(synch);\n+    }\n+\n+    if let Some(kernel32) = Module::new(c::KERNEL32) {\n+        // Preloading this means getting a precise time will be as fast as possible.\n+        c::GetSystemTimePreciseAsFileTime::preload(kernel32);\n+    }\n+}\n+\n+/// Represents a loaded module.\n+///\n+/// Note that the modules std depends on must not be unloaded.\n+/// Therefore a `Module` is always valid for the lifetime of std.\n+#[derive(Copy, Clone)]\n+pub(in crate::sys) struct Module(NonNull<c_void>);\n+impl Module {\n+    /// Try to get a handle to a loaded module.\n+    ///\n+    /// # SAFETY\n+    ///\n+    /// This should only be use for modules that exist for the lifetime of std\n+    /// (e.g. kernel32 and ntdll).\n+    pub unsafe fn new(name: &CStr) -> Option<Self> {\n+        // SAFETY: A CStr is always null terminated.\n+        let module = c::GetModuleHandleA(name.as_ptr());\n+        NonNull::new(module).map(Self)\n+    }\n+\n+    // Try to get the address of a function.\n+    pub fn proc_address(self, name: &CStr) -> Option<NonNull<c_void>> {\n+        // SAFETY:\n+        // `self.0` will always be a valid module.\n+        // A CStr is always null terminated.\n+        let proc = unsafe { c::GetProcAddress(self.0.as_ptr(), name.as_ptr()) };\n+        NonNull::new(proc)\n+    }\n+}\n+\n+/// Load a function or use a fallback implementation if that fails.\n+macro_rules! compat_fn_with_fallback {\n+    (pub static $module:ident: &CStr = $name:expr; $(\n         $(#[$meta:meta])*\n         pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $fallback_body:block\n-    )*) => ($(\n+    )*) => (\n+        pub static $module: &CStr = $name;\n+    $(\n         $(#[$meta])*\n         pub mod $symbol {\n             #[allow(unused_imports)]\n             use super::*;\n             use crate::mem;\n+            use crate::ffi::CStr;\n+            use crate::sync::atomic::{AtomicPtr, Ordering};\n+            use crate::sys::compat::Module;\n \n             type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n \n-            /// Points to the DLL import, or the fallback function.\n-            ///\n-            /// This static can be an ordinary, unsynchronized, mutable static because\n-            /// we guarantee that all of the writes finish during CRT initialization,\n-            /// and all of the reads occur after CRT initialization.\n-            static mut PTR: Option<F> = None;\n-\n-            /// This symbol is what allows the CRT to find the `init` function and call it.\n-            /// It is marked `#[used]` because otherwise Rust would assume that it was not\n-            /// used, and would remove it.\n-            #[used]\n-            #[link_section = \".CRT$XCU\"]\n-            static INIT_TABLE_ENTRY: unsafe extern \"C\" fn() = init;\n-\n-            unsafe extern \"C\" fn init() {\n-                PTR = get_f();\n+            /// `PTR` contains a function pointer to one of three functions.\n+            /// It starts with the `load` function.\n+            /// When that is called it attempts to load the requested symbol.\n+            /// If it succeeds, `PTR` is set to the address of that symbol.\n+            /// If it fails, then `PTR` is set to `fallback`.\n+            static PTR: AtomicPtr<c_void> = AtomicPtr::new(load as *mut _);\n+\n+            unsafe extern \"system\" fn load($($argname: $argtype),*) -> $rettype {\n+                let func = load_from_module(Module::new($module));\n+                func($($argname),*)\n             }\n \n-            unsafe extern \"C\" fn get_f() -> Option<F> {\n-                // There is no locking here. This code is executed before main() is entered, and\n-                // is guaranteed to be single-threaded.\n-                //\n-                // DO NOT do anything interesting or complicated in this function! DO NOT call\n-                // any Rust functions or CRT functions, if those functions touch any global state,\n-                // because this function runs during global initialization. For example, DO NOT\n-                // do any dynamic allocation, don't call LoadLibrary, etc.\n-                let module_name: *const u8 = concat!($module, \"\\0\").as_ptr();\n-                let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n-                let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n-                if !module_handle.is_null() {\n-                    let ptr = $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8);\n-                    if !ptr.is_null() {\n-                        // Transmute to the right function pointer type.\n-                        return Some(mem::transmute(ptr));\n+            fn load_from_module(module: Option<Module>) -> F {\n+                unsafe {\n+                    static symbol_name: &CStr = ansi_str!(sym $symbol);\n+                    if let Some(f) = module.and_then(|m| m.proc_address(symbol_name)) {\n+                        PTR.store(f.as_ptr(), Ordering::Relaxed);\n+                        mem::transmute(f)\n+                    } else {\n+                        PTR.store(fallback as *mut _, Ordering::Relaxed);\n+                        fallback\n                     }\n                 }\n-                return None;\n             }\n \n-            #[allow(dead_code)]\n+            #[allow(unused_variables)]\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype {\n+                $fallback_body\n+            }\n+\n+            #[allow(unused)]\n+            pub(in crate::sys) fn preload(module: Module) {\n+                load_from_module(Some(module));\n+            }\n+\n+            #[inline(always)]\n+            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n+                let func: F = mem::transmute(PTR.load(Ordering::Relaxed));\n+                func($($argname),*)\n+            }\n+        }\n+        $(#[$meta])*\n+        pub use $symbol::call as $symbol;\n+    )*)\n+}\n+\n+/// A function that either exists or doesn't.\n+///\n+/// NOTE: Optional functions must be preloaded in the `init` function above, or they will always be None.\n+macro_rules! compat_fn_optional {\n+    (pub static $module:ident: &CStr = $name:expr; $(\n+        $(#[$meta:meta])*\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty;\n+    )*) => (\n+        pub static $module: &CStr = $name;\n+    $(\n+        $(#[$meta])*\n+        pub mod $symbol {\n+            #[allow(unused_imports)]\n+            use super::*;\n+            use crate::mem;\n+            use crate::sync::atomic::{AtomicPtr, Ordering};\n+            use crate::sys::compat::Module;\n+            use crate::ptr::{self, NonNull};\n+\n+            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n+\n+            /// `PTR` will either be `null()` or set to the loaded function.\n+            static PTR: AtomicPtr<c_void> = AtomicPtr::new(ptr::null_mut());\n+\n+            /// Only allow access to the function if it has loaded successfully.\n             #[inline(always)]\n+            #[cfg(not(miri))]\n             pub fn option() -> Option<F> {\n                 unsafe {\n-                    if cfg!(miri) {\n-                        // Miri does not run `init`, so we just call `get_f` each time.\n-                        get_f()\n-                    } else {\n-                        PTR\n-                    }\n+                    NonNull::new(PTR.load(Ordering::Relaxed)).map(|f| mem::transmute(f))\n                 }\n             }\n \n-            #[allow(dead_code)]\n-            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n-                if let Some(ptr) = option() {\n-                    return ptr($($argname),*);\n+            // Miri does not understand the way we do preloading\n+            // therefore load the function here instead.\n+            #[cfg(miri)]\n+            pub fn option() -> Option<F> {\n+                let mut func = NonNull::new(PTR.load(Ordering::Relaxed));\n+                if func.is_none() {\n+                    Module::new($module).map(preload);\n+                    func = NonNull::new(PTR.load(Ordering::Relaxed));\n+                }\n+                unsafe {\n+                    func.map(|f| mem::transmute(f))\n                 }\n-                $fallback_body\n             }\n-        }\n \n-        $(#[$meta])*\n-        pub use $symbol::call as $symbol;\n+            #[allow(unused)]\n+            pub(in crate::sys) fn preload(module: Module) {\n+                unsafe {\n+                    let symbol_name = ansi_str!(sym $symbol);\n+                    if let Some(f) = module.proc_address(symbol_name) {\n+                        PTR.store(f.as_ptr(), Ordering::Relaxed);\n+                    }\n+                }\n+            }\n+        }\n     )*)\n }"}]}