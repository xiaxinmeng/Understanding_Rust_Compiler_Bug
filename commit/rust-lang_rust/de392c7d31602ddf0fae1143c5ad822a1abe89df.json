{"sha": "de392c7d31602ddf0fae1143c5ad822a1abe89df", "node_id": "C_kwDOAAsO6NoAKGRlMzkyYzdkMzE2MDJkZGYwZmFlMTE0M2M1YWQ4MjJhMWFiZTg5ZGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-11T21:55:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-11T21:55:58Z"}, "message": "Auto merge of #95944 - Dylan-DPC:rollup-idggkrh, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #95008 ([`let_chains`] Forbid `let` inside parentheses)\n - #95801 (Replace RwLock by a futex based one on Linux)\n - #95864 (Fix miscompilation of inline assembly with outputs in cases where we emit an invoke instead of call instruction.)\n - #95894 (Fix formatting error in pin.rs docs)\n - #95895 (Clarify str::from_utf8_unchecked's invariants)\n - #95901 (Remove duplicate aliases for `check codegen_{cranelift,gcc}` and fix `build codegen_gcc`)\n - #95927 (CI: do not compile libcore twice when performing LLVM PGO)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5e44c98e2051ad629f9674394ddc01c0beac6b98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e44c98e2051ad629f9674394ddc01c0beac6b98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de392c7d31602ddf0fae1143c5ad822a1abe89df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de392c7d31602ddf0fae1143c5ad822a1abe89df", "html_url": "https://github.com/rust-lang/rust/commit/de392c7d31602ddf0fae1143c5ad822a1abe89df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de392c7d31602ddf0fae1143c5ad822a1abe89df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ca44752a79dd414d9a0ccf7a74533a99080988", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ca44752a79dd414d9a0ccf7a74533a99080988", "html_url": "https://github.com/rust-lang/rust/commit/90ca44752a79dd414d9a0ccf7a74533a99080988"}, {"sha": "070e8ed18da9263f3b9aa0950accad7059778ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/070e8ed18da9263f3b9aa0950accad7059778ab7", "html_url": "https://github.com/rust-lang/rust/commit/070e8ed18da9263f3b9aa0950accad7059778ab7"}], "stats": {"total": 1606, "additions": 1104, "deletions": 502}, "files": [{"sha": "33727084ccf064f5d291934cc5bf062bcd0825fa", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -120,12 +120,21 @@ impl<'a> AstValidator<'a> {\n             let err = \"`let` expressions are not supported here\";\n             let mut diag = sess.struct_span_err(expr.span, err);\n             diag.note(\"only supported directly in conditions of `if` and `while` expressions\");\n-            diag.note(\"as well as when nested within `&&` and parentheses in those conditions\");\n-            if let ForbiddenLetReason::ForbiddenWithOr(span) = forbidden_let_reason {\n-                diag.span_note(\n-                    span,\n-                    \"`||` operators are not currently supported in let chain expressions\",\n-                );\n+            match forbidden_let_reason {\n+                ForbiddenLetReason::GenericForbidden => {}\n+                ForbiddenLetReason::NotSupportedOr(span) => {\n+                    diag.span_note(\n+                        span,\n+                        \"`||` operators are not supported in let chain expressions\",\n+                    );\n+                }\n+                ForbiddenLetReason::NotSupportedParentheses(span) => {\n+                    diag.span_note(\n+                        span,\n+                        \"`let`s wrapped in parentheses are not supported in a context with let \\\n+                        chains\",\n+                    );\n+                }\n             }\n             diag.emit();\n         } else {\n@@ -1009,9 +1018,9 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.with_let_management(Some(ForbiddenLetReason::GenericForbidden), |this, forbidden_let_reason| {\n             match &expr.kind {\n                 ExprKind::Binary(Spanned { node: BinOpKind::Or, span }, lhs, rhs) => {\n-                    let forbidden_let_reason = Some(ForbiddenLetReason::ForbiddenWithOr(*span));\n-                    this.with_let_management(forbidden_let_reason, |this, _| this.visit_expr(lhs));\n-                    this.with_let_management(forbidden_let_reason, |this, _| this.visit_expr(rhs));\n+                    let local_reason = Some(ForbiddenLetReason::NotSupportedOr(*span));\n+                    this.with_let_management(local_reason, |this, _| this.visit_expr(lhs));\n+                    this.with_let_management(local_reason, |this, _| this.visit_expr(rhs));\n                 }\n                 ExprKind::If(cond, then, opt_else) => {\n                     this.visit_block(then);\n@@ -1036,7 +1045,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         }\n                     }\n                 }\n-                ExprKind::Paren(_) | ExprKind::Binary(Spanned { node: BinOpKind::And, .. }, ..) => {\n+                ExprKind::Paren(local_expr) => {\n+                    fn has_let_expr(expr: &Expr) -> bool {\n+                        match expr.kind {\n+                            ExprKind::Binary(_, ref lhs, ref rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                            ExprKind::Let(..) => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    let local_reason = if has_let_expr(local_expr) {\n+                        Some(ForbiddenLetReason::NotSupportedParentheses(local_expr.span))\n+                    }\n+                    else {\n+                        forbidden_let_reason\n+                    };\n+                    this.with_let_management(local_reason, |this, _| this.visit_expr(local_expr));\n+                }\n+                ExprKind::Binary(Spanned { node: BinOpKind::And, .. }, ..) => {\n                     this.with_let_management(forbidden_let_reason, |this, _| visit::walk_expr(this, expr));\n                     return;\n                 }\n@@ -1810,8 +1835,13 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n /// Used to forbid `let` expressions in certain syntactic locations.\n #[derive(Clone, Copy)]\n enum ForbiddenLetReason {\n-    /// A let chain with the `||` operator\n-    ForbiddenWithOr(Span),\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n+    /// A let chain with the `||` operator\n+    NotSupportedOr(Span),\n+    /// A let chain with invalid parentheses\n+    ///\n+    /// For exemple, `let 1 = 1 && (expr && expr)` is allowed\n+    /// but `(let 1 = 1 && (let 1 = 1 && (let 1 = 1))) && let a = 1` is not\n+    NotSupportedParentheses(Span),\n }"}, {"sha": "91d132eb34350d762d8cd688fa2d8d78e6b7a302", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -290,6 +290,11 @@ impl<'ll, 'tcx> AsmBuilderMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n         }\n         attributes::apply_to_callsite(result, llvm::AttributePlace::Function, &{ attrs });\n \n+        // Switch to the 'normal' basic block if we did an `invoke` instead of a `call`\n+        if let Some((dest, _, _)) = dest_catch_funclet {\n+            self.switch_to_block(dest);\n+        }\n+\n         // Write results to outputs\n         for (idx, op) in operands.iter().enumerate() {\n             if let InlineAsmOperandRef::Out { reg, place: Some(place), .. }"}, {"sha": "720317b05e0802ce585811a1a7c78feb2d3b293a", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -175,7 +175,7 @@\n //! relies on pinning requires unsafe code, but be aware that deciding to make\n //! use of pinning in your type (for example by implementing some operation on\n //! <code>[Pin]<[&]Self></code> or <code>[Pin]<[&mut] Self></code>) has consequences for your\n-//! [`Drop`][Drop]implementation as well: if an element of your type could have been pinned,\n+//! [`Drop`][Drop] implementation as well: if an element of your type could have been pinned,\n //! you must treat [`Drop`][Drop] as implicitly taking <code>[Pin]<[&mut] Self></code>.\n //!\n //! For example, you could implement [`Drop`][Drop] as follows:"}, {"sha": "81b1db4ac6feda2a1290e767526ea5608078b6ca", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -144,11 +144,7 @@ pub const fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n ///\n /// # Safety\n ///\n-/// This function is unsafe because it does not check that the bytes passed to\n-/// it are valid UTF-8. If this constraint is violated, undefined behavior\n-/// results, as the rest of Rust assumes that [`&str`]s are valid UTF-8.\n-///\n-/// [`&str`]: str\n+/// The bytes passed in must be valid UTF-8.\n ///\n /// # Examples\n ///"}, {"sha": "b45d1c0149cb462cc4c8f867f1a6d282f52a5cfc", "filename": "library/std/src/sys/unix/futex.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffutex.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -7,6 +7,11 @@\n use crate::sync::atomic::AtomicI32;\n use crate::time::Duration;\n \n+/// Wait for a futex_wake operation to wake us.\n+///\n+/// Returns directly if the futex doesn't hold the expected value.\n+///\n+/// Returns false on timeout, and true in all other cases.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) -> bool {\n     use super::time::Timespec;\n@@ -68,18 +73,23 @@ pub fn futex_wait(futex: &AtomicI32, expected: i32, timeout: Option<Duration>) {\n     }\n }\n \n+/// Wake up one thread that's blocked on futex_wait on this futex.\n+///\n+/// Returns true if this actually woke up such a thread,\n+/// or false if no thread was waiting on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicI32) -> bool {\n     unsafe {\n         libc::syscall(\n             libc::SYS_futex,\n             futex as *const AtomicI32,\n             libc::FUTEX_WAKE | libc::FUTEX_PRIVATE_FLAG,\n             1,\n-        );\n+        ) > 0\n     }\n }\n \n+/// Wake up all threads that are waiting on futex_wait on this futex.\n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn futex_wake_all(futex: &AtomicI32) {\n     unsafe {\n@@ -93,12 +103,10 @@ pub fn futex_wake_all(futex: &AtomicI32) {\n }\n \n #[cfg(target_os = \"emscripten\")]\n-pub fn futex_wake(futex: &AtomicI32) {\n+pub fn futex_wake(futex: &AtomicI32) -> bool {\n     extern \"C\" {\n         fn emscripten_futex_wake(addr: *const AtomicI32, count: libc::c_int) -> libc::c_int;\n     }\n \n-    unsafe {\n-        emscripten_futex_wake(futex as *const AtomicI32, 1);\n-    }\n+    unsafe { emscripten_futex_wake(futex as *const AtomicI32, 1) > 0 }\n }"}, {"sha": "aa16da97e4c19c4937ef31675be81df80294990c", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -0,0 +1,313 @@\n+use crate::sync::atomic::{\n+    AtomicI32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+\n+pub type MovableRwLock = RwLock;\n+\n+pub struct RwLock {\n+    // The state consists of a 30-bit reader counter, a 'readers waiting' flag, and a 'writers waiting' flag.\n+    // Bits 0..30:\n+    //   0: Unlocked\n+    //   1..=0x3FFF_FFFE: Locked by N readers\n+    //   0x3FFF_FFFF: Write locked\n+    // Bit 30: Readers are waiting on this futex.\n+    // Bit 31: Writers are waiting on the writer_notify futex.\n+    state: AtomicI32,\n+    // The 'condition variable' to notify writers through.\n+    // Incremented on every signal.\n+    writer_notify: AtomicI32,\n+}\n+\n+const READ_LOCKED: i32 = 1;\n+const MASK: i32 = (1 << 30) - 1;\n+const WRITE_LOCKED: i32 = MASK;\n+const MAX_READERS: i32 = MASK - 1;\n+const READERS_WAITING: i32 = 1 << 30;\n+const WRITERS_WAITING: i32 = 1 << 31;\n+\n+fn is_unlocked(state: i32) -> bool {\n+    state & MASK == 0\n+}\n+\n+fn is_write_locked(state: i32) -> bool {\n+    state & MASK == WRITE_LOCKED\n+}\n+\n+fn has_readers_waiting(state: i32) -> bool {\n+    state & READERS_WAITING != 0\n+}\n+\n+fn has_writers_waiting(state: i32) -> bool {\n+    state & WRITERS_WAITING != 0\n+}\n+\n+fn is_read_lockable(state: i32) -> bool {\n+    // This also returns false if the counter could overflow if we tried to read lock it.\n+    //\n+    // We don't allow read-locking if there's readers waiting, even if the lock is unlocked\n+    // and there's no writers waiting. The only situation when this happens is after unlocking,\n+    // at which point the unlocking thread might be waking up writers, which have priority over readers.\n+    // The unlocking thread will clear the readers waiting bit and wake up readers, if necssary.\n+    state & MASK < MAX_READERS && !has_readers_waiting(state) && !has_writers_waiting(state)\n+}\n+\n+fn has_reached_max_readers(state: i32) -> bool {\n+    state & MASK == MAX_READERS\n+}\n+\n+impl RwLock {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| is_read_lockable(s).then(|| s + READ_LOCKED))\n+            .is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        let state = self.state.load(Relaxed);\n+        if !is_read_lockable(state)\n+            || self\n+                .state\n+                .compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n+                .is_err()\n+        {\n+            self.read_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let state = self.state.fetch_sub(READ_LOCKED, Release) - READ_LOCKED;\n+\n+        // It's impossible for a reader to be waiting on a read-locked RwLock,\n+        // except if there is also a writer waiting.\n+        debug_assert!(!has_readers_waiting(state) || has_writers_waiting(state));\n+\n+        // Wake up a writer if we were the last reader and there's a writer waiting.\n+        if is_unlocked(state) && has_writers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn read_contended(&self) {\n+        let mut state = self.spin_read();\n+\n+        loop {\n+            // If we can lock it, lock it.\n+            if is_read_lockable(state) {\n+                match self.state.compare_exchange_weak(state, state + READ_LOCKED, Acquire, Relaxed)\n+                {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Check for overflow.\n+            if has_reached_max_readers(state) {\n+                panic!(\"too many active read locks on RwLock\");\n+            }\n+\n+            // Make sure the readers waiting bit is set before we go to sleep.\n+            if !has_readers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.state, state | READERS_WAITING, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_read();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| is_unlocked(s).then(|| s + WRITE_LOCKED))\n+            .is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        if self.state.compare_exchange_weak(0, WRITE_LOCKED, Acquire, Relaxed).is_err() {\n+            self.write_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;\n+\n+        debug_assert!(is_unlocked(state));\n+\n+        if has_writers_waiting(state) || has_readers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn write_contended(&self) {\n+        let mut state = self.spin_write();\n+\n+        let mut other_writers_waiting = 0;\n+\n+        loop {\n+            // If it's unlocked, we try to lock it.\n+            if is_unlocked(state) {\n+                match self.state.compare_exchange_weak(\n+                    state,\n+                    state | WRITE_LOCKED | other_writers_waiting,\n+                    Acquire,\n+                    Relaxed,\n+                ) {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Set the waiting bit indicating that we're waiting on it.\n+            if !has_writers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | WRITERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Other writers might be waiting now too, so we should make sure\n+            // we keep that bit on once we manage lock it.\n+            other_writers_waiting = WRITERS_WAITING;\n+\n+            // Examine the notification counter before we check if `state` has changed,\n+            // to make sure we don't miss any notifications.\n+            let seq = self.writer_notify.load(Acquire);\n+\n+            // Don't go to sleep if the lock has become available,\n+            // or if the writers waiting bit is no longer set.\n+            let s = self.state.load(Relaxed);\n+            if is_unlocked(state) || !has_writers_waiting(s) {\n+                state = s;\n+                continue;\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.writer_notify, seq, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_write();\n+        }\n+    }\n+\n+    /// Wake up waiting threads after unlocking.\n+    ///\n+    /// If both are waiting, this will wake up only one writer, but will fall\n+    /// back to waking up readers if there was no writer to wake up.\n+    #[cold]\n+    fn wake_writer_or_readers(&self, mut state: i32) {\n+        assert!(is_unlocked(state));\n+\n+        // The readers waiting bit might be turned on at any point now,\n+        // since readers will block when there's anything waiting.\n+        // Writers will just lock the lock though, regardless of the waiting bits,\n+        // so we don't have to worry about the writer waiting bit.\n+        //\n+        // If the lock gets locked in the meantime, we don't have to do\n+        // anything, because then the thread that locked the lock will take\n+        // care of waking up waiters when it unlocks.\n+\n+        // If only writers are waiting, wake one of them up.\n+        if state == WRITERS_WAITING {\n+            match self.state.compare_exchange(state, 0, Relaxed, Relaxed) {\n+                Ok(_) => {\n+                    self.wake_writer();\n+                    return;\n+                }\n+                Err(s) => {\n+                    // Maybe some readers are now waiting too. So, continue to the next `if`.\n+                    state = s;\n+                }\n+            }\n+        }\n+\n+        // If both writers and readers are waiting, leave the readers waiting\n+        // and only wake up one writer.\n+        if state == READERS_WAITING + WRITERS_WAITING {\n+            if self.state.compare_exchange(state, READERS_WAITING, Relaxed, Relaxed).is_err() {\n+                // The lock got locked. Not our problem anymore.\n+                return;\n+            }\n+            if self.wake_writer() {\n+                return;\n+            }\n+            // No writers were actually blocked on futex_wait, so we continue\n+            // to wake up readers instead, since we can't be sure if we notified a writer.\n+            state = READERS_WAITING;\n+        }\n+\n+        // If readers are waiting, wake them all up.\n+        if state == READERS_WAITING {\n+            if self.state.compare_exchange(state, 0, Relaxed, Relaxed).is_ok() {\n+                futex_wake_all(&self.state);\n+            }\n+        }\n+    }\n+\n+    /// This wakes one writer and returns true if we woke up a writer that was\n+    /// blocked on futex_wait.\n+    ///\n+    /// If this returns false, it might still be the case that we notified a\n+    /// writer that was about to go to sleep.\n+    fn wake_writer(&self) -> bool {\n+        self.writer_notify.fetch_add(1, Release);\n+        futex_wake(&self.writer_notify)\n+    }\n+\n+    /// Spin for a while, but stop directly at the given condition.\n+    fn spin_until(&self, f: impl Fn(i32) -> bool) -> i32 {\n+        let mut spin = 100; // Chosen by fair dice roll.\n+        loop {\n+            let state = self.state.load(Relaxed);\n+            if f(state) || spin == 0 {\n+                return state;\n+            }\n+            crate::hint::spin_loop();\n+            spin -= 1;\n+        }\n+    }\n+\n+    fn spin_write(&self) -> i32 {\n+        // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n+        self.spin_until(|state| is_unlocked(state) || has_writers_waiting(state))\n+    }\n+\n+    fn spin_read(&self) -> i32 {\n+        // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n+        self.spin_until(|state| {\n+            !is_write_locked(state) || has_readers_waiting(state) || has_writers_waiting(state)\n+        })\n+    }\n+}"}, {"sha": "85afc939d2e897e7c9f0ecf1e1f8269f852d6591", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -4,13 +4,13 @@ cfg_if::cfg_if! {\n         target_os = \"android\",\n     ))] {\n         mod futex;\n+        mod futex_rwlock;\n         #[allow(dead_code)]\n         mod pthread_mutex; // Only used for PthreadMutexAttr, needed by pthread_remutex.\n         mod pthread_remutex; // FIXME: Implement this using a futex\n-        mod pthread_rwlock; // FIXME: Implement this using a futex\n         pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n         pub use pthread_remutex::ReentrantMutex;\n-        pub use pthread_rwlock::{RwLock, MovableRwLock};\n+        pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;\n         mod pthread_remutex;"}, {"sha": "432a6c34ed58415c934989acf542546a3cc13c4a", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -243,12 +243,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.paths(&[\n-            \"compiler/rustc_codegen_cranelift\",\n-            \"rustc_codegen_cranelift\",\n-            \"compiler/rustc_codegen_gcc\",\n-            \"rustc_codegen_gcc\",\n-        ])\n+        run.paths(&[\"compiler/rustc_codegen_cranelift\", \"compiler/rustc_codegen_gcc\"])\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "45991381dc0fe1d9a70b64062d40b78624326bce", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -795,7 +795,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"compiler/rustc_codegen_cranelift\")\n+        run.paths(&[\"compiler/rustc_codegen_cranelift\", \"compiler/rustc_codegen_gcc\"])\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "691d1282cf499ceae3f17bc288c0d44a77c83c23", "filename": "src/ci/pgo.sh", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fci%2Fpgo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Fci%2Fpgo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fpgo.sh?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -47,12 +47,6 @@ python3 ../x.py build --target=$PGO_HOST --host=$PGO_HOST \\\n     --stage 2 library/std \\\n     --llvm-profile-generate\n \n-# Profile libcore compilation in opt-level=0 and opt-level=3\n-RUSTC_BOOTSTRAP=1 ./build/$PGO_HOST/stage2/bin/rustc \\\n-    --edition=2021 --crate-type=lib ../library/core/src/lib.rs\n-RUSTC_BOOTSTRAP=1 ./build/$PGO_HOST/stage2/bin/rustc \\\n-    --edition=2021 --crate-type=lib -Copt-level=3 ../library/core/src/lib.rs\n-\n # Compile rustc perf\n cp -r /tmp/rustc-perf ./\n chown -R $(whoami): ./rustc-perf"}, {"sha": "bf4202764a7ec665ebdaa4ac97debda0a95b4b03", "filename": "src/test/codegen/asm-may_unwind.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasm-may_unwind.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -18,10 +18,23 @@ impl Drop for Foo {\n     }\n }\n \n-// CHECK-LABEL: @may_unwind\n+// CHECK-LABEL: @asm_may_unwind\n #[no_mangle]\n-pub unsafe fn may_unwind() {\n+pub unsafe fn asm_may_unwind() {\n     let _m = Foo;\n     // CHECK: invoke void asm sideeffect alignstack inteldialect unwind \"\"\n     asm!(\"\", options(may_unwind));\n }\n+\n+// CHECK-LABEL: @asm_with_result_may_unwind\n+#[no_mangle]\n+pub unsafe fn asm_with_result_may_unwind() -> u64 {\n+    let _m = Foo;\n+    let res: u64;\n+    // CHECK: [[RES:%[0-9]+]] = invoke i64 asm sideeffect alignstack inteldialect unwind\n+    // CHECK-NEXT: to label %[[NORMALBB:[a-b0-9]+]]\n+    asm!(\"mov {}, 1\", out(reg) res, options(may_unwind));\n+    // CHECK: [[NORMALBB]]:\n+    // CHECK: ret i64 [[RES:%[0-9]+]]\n+    res\n+}"}, {"sha": "1bd8b74240eacb81972422f2cdf9be59708b7b0c", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -25,6 +25,67 @@ use std::ops::Range;\n \n fn main() {}\n \n+fn _if() {\n+    if (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    if (((let 0 = 1))) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    if (let 0 = 1) && true {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    if true && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    if (let 0 = 1) && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+}\n+\n+fn _while() {\n+    while (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    while (((let 0 = 1))) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    while (let 0 = 1) && true {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    while true && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+\n+    while (let 0 = 1) && (let 0 = 1) {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+\n+    while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+}\n+\n+fn _macros() {\n+    macro_rules! use_expr {\n+        ($e:expr) => {\n+            if $e {}\n+            while $e {}\n+        }\n+    }\n+    use_expr!((let 0 = 1 && 0 == 0));\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    use_expr!((let 0 = 1));\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+}\n+\n fn nested_within_if_expr() {\n     if &let 0 = 0 {} //~ ERROR `let` expressions are not supported here\n     //~^ ERROR mismatched types\n@@ -234,3 +295,44 @@ fn inside_const_generic_arguments() {\n         //~| ERROR  expressions must be enclosed in braces\n     >::O == 5 {}\n }\n+\n+fn with_parenthesis() {\n+    let opt = Some(Some(1i32));\n+\n+    if (let Some(a) = opt && true) {\n+    //~^ ERROR `let` expressions are not supported here\n+    }\n+\n+    if (let Some(a) = opt) && true {\n+    //~^ ERROR `let` expressions are not supported here\n+    }\n+    if (let Some(a) = opt) && (let Some(b) = a) {\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    }\n+    if let Some(a) = opt && (true && true) {\n+    }\n+\n+    if (let Some(a) = opt && (let Some(b) = a)) && b == 1 {\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    }\n+    if (let Some(a) = opt && (let Some(b) = a)) && true {\n+    //~^ ERROR `let` expressions are not supported here\n+    //~| ERROR `let` expressions are not supported here\n+    }\n+    if (let Some(a) = opt && (true)) && true {\n+    //~^ ERROR `let` expressions are not supported here\n+    }\n+\n+    if (true && (true)) && let Some(a) = opt {\n+    }\n+    if (true) && let Some(a) = opt {\n+    }\n+    if true && let Some(a) = opt {\n+    }\n+\n+    let fun = || true;\n+    if let true = (true && fun()) && (true) {\n+    }\n+}"}, {"sha": "00da9d2605765c187873a4c52e2ffc0eb029b113", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 597, "deletions": 184, "changes": 781, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -1,5 +1,5 @@\n error: expressions must be enclosed in braces to be used as const generic arguments\n-  --> $DIR/disallowed-positions.rs:232:9\n+  --> $DIR/disallowed-positions.rs:293:9\n    |\n LL |         true && let 1 = 1\n    |         ^^^^^^^^^^^^^^^^^\n@@ -12,555 +12,968 @@ LL |         { true && let 1 = 1 }\n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:29:9\n    |\n+LL |     if (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:29:9\n+   |\n+LL |     if (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:32:11\n+   |\n+LL |     if (((let 0 = 1))) {}\n+   |           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:32:11\n+   |\n+LL |     if (((let 0 = 1))) {}\n+   |           ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:35:9\n+   |\n+LL |     if (let 0 = 1) && true {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:35:9\n+   |\n+LL |     if (let 0 = 1) && true {}\n+   |         ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:38:17\n+   |\n+LL |     if true && (let 0 = 1) {}\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:38:17\n+   |\n+LL |     if true && (let 0 = 1) {}\n+   |                 ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:41:9\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:41:9\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |         ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:41:24\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:41:24\n+   |\n+LL |     if (let 0 = 1) && (let 0 = 1) {}\n+   |                        ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:45:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:45:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:45:48\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:45:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:45:61\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                             ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:45:35\n+   |\n+LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:52:12\n+   |\n+LL |     while (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:52:12\n+   |\n+LL |     while (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:55:14\n+   |\n+LL |     while (((let 0 = 1))) {}\n+   |              ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:55:14\n+   |\n+LL |     while (((let 0 = 1))) {}\n+   |              ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:58:12\n+   |\n+LL |     while (let 0 = 1) && true {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:58:12\n+   |\n+LL |     while (let 0 = 1) && true {}\n+   |            ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:61:20\n+   |\n+LL |     while true && (let 0 = 1) {}\n+   |                    ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:61:20\n+   |\n+LL |     while true && (let 0 = 1) {}\n+   |                    ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:64:12\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:64:12\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |            ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:64:27\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |                           ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:64:27\n+   |\n+LL |     while (let 0 = 1) && (let 0 = 1) {}\n+   |                           ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:68:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:68:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:68:51\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                   ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:68:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:68:64\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                                                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:68:38\n+   |\n+LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:81:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:81:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:81:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:81:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:84:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:84:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:84:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:84:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:90:9\n+   |\n LL |     if &let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:32:9\n+  --> $DIR/disallowed-positions.rs:93:9\n    |\n LL |     if !let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:33:9\n+  --> $DIR/disallowed-positions.rs:94:9\n    |\n LL |     if *let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:35:9\n+  --> $DIR/disallowed-positions.rs:96:9\n    |\n LL |     if -let 0 = 0 {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:43:9\n+  --> $DIR/disallowed-positions.rs:104:9\n    |\n LL |     if (let 0 = 0)? {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:104:9\n+   |\n+LL |     if (let 0 = 0)? {}\n+   |         ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:47:16\n+  --> $DIR/disallowed-positions.rs:108:16\n    |\n LL |     if true || let 0 = 0 {}\n    |                ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:47:13\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:108:13\n    |\n LL |     if true || let 0 = 0 {}\n    |             ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:48:17\n+  --> $DIR/disallowed-positions.rs:109:17\n    |\n LL |     if (true || let 0 = 0) {}\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:48:14\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:109:14\n    |\n LL |     if (true || let 0 = 0) {}\n    |              ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:49:25\n+  --> $DIR/disallowed-positions.rs:110:25\n    |\n LL |     if true && (true || let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:49:22\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:110:22\n    |\n LL |     if true && (true || let 0 = 0) {}\n    |                      ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:50:25\n+  --> $DIR/disallowed-positions.rs:111:25\n    |\n LL |     if true || (true && let 0 = 0) {}\n    |                         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:50:13\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:111:17\n    |\n LL |     if true || (true && let 0 = 0) {}\n-   |             ^^\n+   |                 ^^^^^^^^^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:53:12\n+  --> $DIR/disallowed-positions.rs:114:12\n    |\n LL |     if x = let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:56:15\n+  --> $DIR/disallowed-positions.rs:117:15\n    |\n LL |     if true..(let 0 = 0) {}\n    |               ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:117:15\n+   |\n+LL |     if true..(let 0 = 0) {}\n+   |               ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:58:11\n+  --> $DIR/disallowed-positions.rs:119:11\n    |\n LL |     if ..(let 0 = 0) {}\n    |           ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:119:11\n+   |\n+LL |     if ..(let 0 = 0) {}\n+   |           ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:60:9\n+  --> $DIR/disallowed-positions.rs:121:9\n    |\n LL |     if (let 0 = 0).. {}\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:121:9\n+   |\n+LL |     if (let 0 = 0).. {}\n+   |         ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:64:8\n+  --> $DIR/disallowed-positions.rs:125:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:68:8\n+  --> $DIR/disallowed-positions.rs:129:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:75:8\n+  --> $DIR/disallowed-positions.rs:136:8\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:83:8\n+  --> $DIR/disallowed-positions.rs:144:8\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:89:19\n+  --> $DIR/disallowed-positions.rs:150:19\n    |\n LL |     if let true = let true = true {}\n    |                   ^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:93:12\n+  --> $DIR/disallowed-positions.rs:154:12\n    |\n LL |     while &let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:96:12\n+  --> $DIR/disallowed-positions.rs:157:12\n    |\n LL |     while !let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:97:12\n+  --> $DIR/disallowed-positions.rs:158:12\n    |\n LL |     while *let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:99:12\n+  --> $DIR/disallowed-positions.rs:160:12\n    |\n LL |     while -let 0 = 0 {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:107:12\n+  --> $DIR/disallowed-positions.rs:168:12\n    |\n LL |     while (let 0 = 0)? {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:168:12\n+   |\n+LL |     while (let 0 = 0)? {}\n+   |            ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:111:19\n+  --> $DIR/disallowed-positions.rs:172:19\n    |\n LL |     while true || let 0 = 0 {}\n    |                   ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:111:16\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:172:16\n    |\n LL |     while true || let 0 = 0 {}\n    |                ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:112:20\n+  --> $DIR/disallowed-positions.rs:173:20\n    |\n LL |     while (true || let 0 = 0) {}\n    |                    ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:112:17\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:173:17\n    |\n LL |     while (true || let 0 = 0) {}\n    |                 ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:113:28\n+  --> $DIR/disallowed-positions.rs:174:28\n    |\n LL |     while true && (true || let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:113:25\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:174:25\n    |\n LL |     while true && (true || let 0 = 0) {}\n    |                         ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:114:28\n+  --> $DIR/disallowed-positions.rs:175:28\n    |\n LL |     while true || (true && let 0 = 0) {}\n    |                            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:114:16\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:175:20\n    |\n LL |     while true || (true && let 0 = 0) {}\n-   |                ^^\n+   |                    ^^^^^^^^^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:117:15\n+  --> $DIR/disallowed-positions.rs:178:15\n    |\n LL |     while x = let 0 = 0 {}\n    |               ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:120:18\n+  --> $DIR/disallowed-positions.rs:181:18\n    |\n LL |     while true..(let 0 = 0) {}\n    |                  ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:181:18\n+   |\n+LL |     while true..(let 0 = 0) {}\n+   |                  ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:122:14\n+  --> $DIR/disallowed-positions.rs:183:14\n    |\n LL |     while ..(let 0 = 0) {}\n    |              ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:183:14\n+   |\n+LL |     while ..(let 0 = 0) {}\n+   |              ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:124:12\n+  --> $DIR/disallowed-positions.rs:185:12\n    |\n LL |     while (let 0 = 0).. {}\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:185:12\n+   |\n+LL |     while (let 0 = 0).. {}\n+   |            ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:128:11\n+  --> $DIR/disallowed-positions.rs:189:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:132:11\n+  --> $DIR/disallowed-positions.rs:193:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:139:11\n+  --> $DIR/disallowed-positions.rs:200:11\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:147:11\n+  --> $DIR/disallowed-positions.rs:208:11\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:153:22\n+  --> $DIR/disallowed-positions.rs:214:22\n    |\n LL |     while let true = let true = true {}\n    |                      ^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:167:6\n+  --> $DIR/disallowed-positions.rs:228:6\n    |\n LL |     &let 0 = 0;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:169:6\n+  --> $DIR/disallowed-positions.rs:230:6\n    |\n LL |     !let 0 = 0;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:170:6\n+  --> $DIR/disallowed-positions.rs:231:6\n    |\n LL |     *let 0 = 0;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:172:6\n+  --> $DIR/disallowed-positions.rs:233:6\n    |\n LL |     -let 0 = 0;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:180:6\n+  --> $DIR/disallowed-positions.rs:241:6\n    |\n LL |     (let 0 = 0)?;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:241:6\n+   |\n+LL |     (let 0 = 0)?;\n+   |      ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:184:13\n+  --> $DIR/disallowed-positions.rs:245:13\n    |\n LL |     true || let 0 = 0;\n    |             ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:184:10\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:245:10\n    |\n LL |     true || let 0 = 0;\n    |          ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:185:14\n+  --> $DIR/disallowed-positions.rs:246:14\n    |\n LL |     (true || let 0 = 0);\n    |              ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:185:11\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:246:11\n    |\n LL |     (true || let 0 = 0);\n    |           ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:186:22\n+  --> $DIR/disallowed-positions.rs:247:22\n    |\n LL |     true && (true || let 0 = 0);\n    |                      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n-note: `||` operators are not currently supported in let chain expressions\n-  --> $DIR/disallowed-positions.rs:186:19\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/disallowed-positions.rs:247:19\n    |\n LL |     true && (true || let 0 = 0);\n    |                   ^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:189:9\n+  --> $DIR/disallowed-positions.rs:250:9\n    |\n LL |     x = let 0 = 0;\n    |         ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:191:12\n+  --> $DIR/disallowed-positions.rs:252:12\n    |\n LL |     true..(let 0 = 0);\n    |            ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:252:12\n+   |\n+LL |     true..(let 0 = 0);\n+   |            ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:192:8\n+  --> $DIR/disallowed-positions.rs:253:8\n    |\n LL |     ..(let 0 = 0);\n    |        ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:253:8\n+   |\n+LL |     ..(let 0 = 0);\n+   |        ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:193:6\n+  --> $DIR/disallowed-positions.rs:254:6\n    |\n LL |     (let 0 = 0)..;\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:254:6\n+   |\n+LL |     (let 0 = 0)..;\n+   |      ^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:195:6\n+  --> $DIR/disallowed-positions.rs:256:6\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:199:6\n+  --> $DIR/disallowed-positions.rs:260:6\n    |\n LL |     (let true = let true = true);\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:260:6\n+   |\n+LL |     (let true = let true = true);\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:203:6\n+  --> $DIR/disallowed-positions.rs:264:6\n    |\n LL |     &let 0 = 0\n    |      ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:214:17\n+  --> $DIR/disallowed-positions.rs:275:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:218:17\n+  --> $DIR/disallowed-positions.rs:279:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:222:17\n+  --> $DIR/disallowed-positions.rs:283:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error: `let` expressions are not supported here\n-  --> $DIR/disallowed-positions.rs:232:17\n+  --> $DIR/disallowed-positions.rs:293:17\n    |\n LL |         true && let 1 = 1\n    |                 ^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:302:9\n+   |\n+LL |     if (let Some(a) = opt && true) {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:302:9\n+   |\n+LL |     if (let Some(a) = opt && true) {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:306:9\n+   |\n+LL |     if (let Some(a) = opt) && true {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:306:9\n+   |\n+LL |     if (let Some(a) = opt) && true {\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:309:9\n+   |\n+LL |     if (let Some(a) = opt) && (let Some(b) = a) {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:309:9\n+   |\n+LL |     if (let Some(a) = opt) && (let Some(b) = a) {\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:309:32\n+   |\n+LL |     if (let Some(a) = opt) && (let Some(b) = a) {\n+   |                                ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:309:32\n+   |\n+LL |     if (let Some(a) = opt) && (let Some(b) = a) {\n+   |                                ^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:316:9\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && b == 1 {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:316:9\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && b == 1 {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:316:31\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && b == 1 {\n+   |                               ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:316:31\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && b == 1 {\n+   |                               ^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:320:9\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && true {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:320:9\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && true {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:320:31\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && true {\n+   |                               ^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:320:31\n+   |\n+LL |     if (let Some(a) = opt && (let Some(b) = a)) && true {\n+   |                               ^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:324:9\n+   |\n+LL |     if (let Some(a) = opt && (true)) && true {\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/disallowed-positions.rs:324:9\n+   |\n+LL |     if (let Some(a) = opt && (true)) && true {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:29:8\n+  --> $DIR/disallowed-positions.rs:90:8\n    |\n LL |     if &let 0 = 0 {}\n    |        ^^^^^^^^^^ expected `bool`, found `&bool`\n@@ -572,27 +985,27 @@ LL +     if let 0 = 0 {}\n    | \n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:33:8\n+  --> $DIR/disallowed-positions.rs:94:8\n    |\n LL |     if *let 0 = 0 {}\n    |        ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:35:8\n+  --> $DIR/disallowed-positions.rs:96:8\n    |\n LL |     if -let 0 = 0 {}\n    |        ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:43:8\n+  --> $DIR/disallowed-positions.rs:104:8\n    |\n LL |     if (let 0 = 0)? {}\n    |        ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:43:19\n+  --> $DIR/disallowed-positions.rs:104:19\n    |\n LL | / fn nested_within_if_expr() {\n LL | |     if &let 0 = 0 {}\n@@ -609,7 +1022,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:53:8\n+  --> $DIR/disallowed-positions.rs:114:8\n    |\n LL |     if x = let 0 = 0 {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n@@ -620,7 +1033,7 @@ LL |     if x == let 0 = 0 {}\n    |          ~~\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:56:8\n+  --> $DIR/disallowed-positions.rs:117:8\n    |\n LL |     if true..(let 0 = 0) {}\n    |        ^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -629,7 +1042,7 @@ LL |     if true..(let 0 = 0) {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:58:8\n+  --> $DIR/disallowed-positions.rs:119:8\n    |\n LL |     if ..(let 0 = 0) {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found struct `RangeTo`\n@@ -638,7 +1051,7 @@ LL |     if ..(let 0 = 0) {}\n             found struct `RangeTo<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:60:8\n+  --> $DIR/disallowed-positions.rs:121:8\n    |\n LL |     if (let 0 = 0).. {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found struct `RangeFrom`\n@@ -647,7 +1060,7 @@ LL |     if (let 0 = 0).. {}\n             found struct `RangeFrom<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:64:12\n+  --> $DIR/disallowed-positions.rs:125:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -658,7 +1071,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:64:8\n+  --> $DIR/disallowed-positions.rs:125:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -667,7 +1080,7 @@ LL |     if let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:68:12\n+  --> $DIR/disallowed-positions.rs:129:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -678,7 +1091,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:68:8\n+  --> $DIR/disallowed-positions.rs:129:8\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -687,7 +1100,7 @@ LL |     if let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:75:12\n+  --> $DIR/disallowed-positions.rs:136:12\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `fn() -> bool`\n@@ -698,16 +1111,16 @@ LL |     if let Range { start: F, end } = F..|| true {}\n                   found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:75:41\n+  --> $DIR/disallowed-positions.rs:136:41\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |                                         ^^^^^^^ expected `bool`, found closure\n    |\n    = note: expected type `bool`\n-           found closure `[closure@$DIR/disallowed-positions.rs:75:41: 75:48]`\n+           found closure `[closure@$DIR/disallowed-positions.rs:136:41: 136:48]`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:75:8\n+  --> $DIR/disallowed-positions.rs:136:8\n    |\n LL |     if let Range { start: F, end } = F..|| true {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -716,7 +1129,7 @@ LL |     if let Range { start: F, end } = F..|| true {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:83:12\n+  --> $DIR/disallowed-positions.rs:144:12\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n@@ -727,7 +1140,7 @@ LL |     if let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:83:44\n+  --> $DIR/disallowed-positions.rs:144:44\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |                                            ^^^^^^^ expected `bool`, found `&&bool`\n@@ -739,7 +1152,7 @@ LL +     if let Range { start: true, end } = t..false {}\n    | \n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:83:8\n+  --> $DIR/disallowed-positions.rs:144:8\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -748,15 +1161,15 @@ LL |     if let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:39:20\n+  --> $DIR/disallowed-positions.rs:100:20\n    |\n LL |         if let 0 = 0? {}\n    |                    ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:93:11\n+  --> $DIR/disallowed-positions.rs:154:11\n    |\n LL |     while &let 0 = 0 {}\n    |           ^^^^^^^^^^ expected `bool`, found `&bool`\n@@ -768,27 +1181,27 @@ LL +     while let 0 = 0 {}\n    | \n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:97:11\n+  --> $DIR/disallowed-positions.rs:158:11\n    |\n LL |     while *let 0 = 0 {}\n    |           ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:99:11\n+  --> $DIR/disallowed-positions.rs:160:11\n    |\n LL |     while -let 0 = 0 {}\n    |           ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:107:11\n+  --> $DIR/disallowed-positions.rs:168:11\n    |\n LL |     while (let 0 = 0)? {}\n    |           ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:107:22\n+  --> $DIR/disallowed-positions.rs:168:22\n    |\n LL | / fn nested_within_while_expr() {\n LL | |     while &let 0 = 0 {}\n@@ -805,7 +1218,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:117:11\n+  --> $DIR/disallowed-positions.rs:178:11\n    |\n LL |     while x = let 0 = 0 {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found `()`\n@@ -816,7 +1229,7 @@ LL |     while x == let 0 = 0 {}\n    |             ~~\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:120:11\n+  --> $DIR/disallowed-positions.rs:181:11\n    |\n LL |     while true..(let 0 = 0) {}\n    |           ^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -825,7 +1238,7 @@ LL |     while true..(let 0 = 0) {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:122:11\n+  --> $DIR/disallowed-positions.rs:183:11\n    |\n LL |     while ..(let 0 = 0) {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found struct `RangeTo`\n@@ -834,7 +1247,7 @@ LL |     while ..(let 0 = 0) {}\n             found struct `RangeTo<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:124:11\n+  --> $DIR/disallowed-positions.rs:185:11\n    |\n LL |     while (let 0 = 0).. {}\n    |           ^^^^^^^^^^^^^ expected `bool`, found struct `RangeFrom`\n@@ -843,7 +1256,7 @@ LL |     while (let 0 = 0).. {}\n             found struct `RangeFrom<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:128:15\n+  --> $DIR/disallowed-positions.rs:189:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -854,7 +1267,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:128:11\n+  --> $DIR/disallowed-positions.rs:189:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -863,7 +1276,7 @@ LL |     while let Range { start: _, end: _ } = true..true && false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:132:15\n+  --> $DIR/disallowed-positions.rs:193:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -874,7 +1287,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:132:11\n+  --> $DIR/disallowed-positions.rs:193:11\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -883,7 +1296,7 @@ LL |     while let Range { start: _, end: _ } = true..true || false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:139:15\n+  --> $DIR/disallowed-positions.rs:200:15\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `fn() -> bool`\n@@ -894,16 +1307,16 @@ LL |     while let Range { start: F, end } = F..|| true {}\n                   found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:139:44\n+  --> $DIR/disallowed-positions.rs:200:44\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |                                            ^^^^^^^ expected `bool`, found closure\n    |\n    = note: expected type `bool`\n-           found closure `[closure@$DIR/disallowed-positions.rs:139:44: 139:51]`\n+           found closure `[closure@$DIR/disallowed-positions.rs:200:44: 200:51]`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:139:11\n+  --> $DIR/disallowed-positions.rs:200:11\n    |\n LL |     while let Range { start: F, end } = F..|| true {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -912,7 +1325,7 @@ LL |     while let Range { start: F, end } = F..|| true {}\n             found struct `std::ops::Range<bool>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:147:15\n+  --> $DIR/disallowed-positions.rs:208:15\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n@@ -923,7 +1336,7 @@ LL |     while let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:147:47\n+  --> $DIR/disallowed-positions.rs:208:47\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |                                               ^^^^^^^ expected `bool`, found `&&bool`\n@@ -935,7 +1348,7 @@ LL +     while let Range { start: true, end } = t..false {}\n    | \n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:147:11\n+  --> $DIR/disallowed-positions.rs:208:11\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found struct `std::ops::Range`\n@@ -944,35 +1357,35 @@ LL |     while let Range { start: true, end } = t..&&false {}\n             found struct `std::ops::Range<bool>`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:103:23\n+  --> $DIR/disallowed-positions.rs:164:23\n    |\n LL |         while let 0 = 0? {}\n    |                       ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n error[E0614]: type `bool` cannot be dereferenced\n-  --> $DIR/disallowed-positions.rs:170:5\n+  --> $DIR/disallowed-positions.rs:231:5\n    |\n LL |     *let 0 = 0;\n    |     ^^^^^^^^^^\n \n error[E0600]: cannot apply unary operator `-` to type `bool`\n-  --> $DIR/disallowed-positions.rs:172:5\n+  --> $DIR/disallowed-positions.rs:233:5\n    |\n LL |     -let 0 = 0;\n    |     ^^^^^^^^^^ cannot apply unary operator `-`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:180:5\n+  --> $DIR/disallowed-positions.rs:241:5\n    |\n LL |     (let 0 = 0)?;\n    |     ^^^^^^^^^^^^ the `?` operator cannot be applied to type `bool`\n    |\n    = help: the trait `Try` is not implemented for `bool`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n-  --> $DIR/disallowed-positions.rs:180:16\n+  --> $DIR/disallowed-positions.rs:241:16\n    |\n LL | / fn outside_if_and_while_expr() {\n LL | |     &let 0 = 0;\n@@ -989,7 +1402,7 @@ LL | | }\n    = help: the trait `FromResidual<_>` is not implemented for `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:195:10\n+  --> $DIR/disallowed-positions.rs:256:10\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n@@ -1000,7 +1413,7 @@ LL |     (let Range { start: _, end: _ } = true..true || false);\n             found struct `std::ops::Range<_>`\n \n error[E0308]: mismatched types\n-  --> $DIR/disallowed-positions.rs:203:5\n+  --> $DIR/disallowed-positions.rs:264:5\n    |\n LL | fn outside_if_and_while_expr() {\n    |                                - help: try adding a return type: `-> &bool`\n@@ -1009,14 +1422,14 @@ LL |     &let 0 = 0\n    |     ^^^^^^^^^^ expected `()`, found `&bool`\n \n error[E0277]: the `?` operator can only be applied to values that implement `Try`\n-  --> $DIR/disallowed-positions.rs:176:17\n+  --> $DIR/disallowed-positions.rs:237:17\n    |\n LL |         let 0 = 0?;\n    |                 ^^ the `?` operator cannot be applied to type `{integer}`\n    |\n    = help: the trait `Try` is not implemented for `{integer}`\n \n-error: aborting due to 103 previous errors\n+error: aborting due to 134 previous errors\n \n Some errors have detailed explanations: E0277, E0308, E0600, E0614.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "aebfc1a72b7aa34b6dd7467c1c1459e18544d0ee", "filename": "src/test/ui/rfc-2497-if-let-chains/ensure-that-let-else-does-not-interact-with-let-chains.stderr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -72,7 +72,6 @@ LL |     let Some(n) = opt && let another = n else {\n    |                          ^^^^^^^^^^^^^^^\n    |\n    = note: only supported directly in conditions of `if` and `while` expressions\n-   = note: as well as when nested within `&&` and parentheses in those conditions\n \n error[E0308]: mismatched types\n   --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:9:19"}, {"sha": "ac60bc7e57fd484c7074378c5287de5260d1f835", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.rs?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -11,71 +11,25 @@ use std::ops::Range;\n fn _if() {\n     if let 0 = 1 {} // Stable!\n \n-    if (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    if (((let 0 = 1))) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n     if true && let 0 = 1 {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     if let 0 = 1 && true {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n-    if (let 0 = 1) && true {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    if true && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    if (let 0 = 1) && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-\n-    if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-\n     if let Range { start: _, end: _ } = (true..true) && false {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n }\n \n fn _while() {\n     while let 0 = 1 {} // Stable!\n \n-    while (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    while (((let 0 = 1))) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n     while true && let 0 = 1 {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n     while let 0 = 1 && true {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n \n-    while (let 0 = 1) && true {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    while true && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-\n-    while (let 0 = 1) && (let 0 = 1) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-\n-    while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-    //~| ERROR `let` expressions in this position are unstable [E0658]\n-\n     while let Range { start: _, end: _ } = (true..true) && false {}\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n }\n@@ -92,10 +46,6 @@ fn _macros() {\n             while $e {}\n         }\n     }\n-    use_expr!((let 0 = 1 && 0 == 0));\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n-    use_expr!((let 0 = 1));\n-    //~^ ERROR `let` expressions in this position are unstable [E0658]\n     #[cfg(FALSE)] (let 0 = 1);\n     //~^ ERROR `let` expressions in this position are unstable [E0658]\n     use_expr!(let 0 = 1);"}, {"sha": "1eabee47c64ac3b5da2fdd0c9b8d3791aa3cffa5", "filename": "src/test/ui/rfc-2497-if-let-chains/feature-gate.stderr", "status": "modified", "additions": 10, "deletions": 226, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/de392c7d31602ddf0fae1143c5ad822a1abe89df/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Ffeature-gate.stderr?ref=de392c7d31602ddf0fae1143c5ad822a1abe89df", "patch": "@@ -1,5 +1,5 @@\n error: no rules expected the token `let`\n-  --> $DIR/feature-gate.rs:101:15\n+  --> $DIR/feature-gate.rs:51:15\n    |\n LL |     macro_rules! use_expr {\n    |     --------------------- when calling this macro\n@@ -8,25 +8,7 @@ LL |     use_expr!(let 0 = 1);\n    |               ^^^ no rules expected this token in macro call\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:14:9\n-   |\n-LL |     if (let 0 = 1) {}\n-   |         ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:17:11\n-   |\n-LL |     if (((let 0 = 1))) {}\n-   |           ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:20:16\n+  --> $DIR/feature-gate.rs:14:16\n    |\n LL |     if true && let 0 = 1 {}\n    |                ^^^^^^^^^\n@@ -35,7 +17,7 @@ LL |     if true && let 0 = 1 {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:23:8\n+  --> $DIR/feature-gate.rs:17:8\n    |\n LL |     if let 0 = 1 && true {}\n    |        ^^^^^^^^^\n@@ -44,88 +26,7 @@ LL |     if let 0 = 1 && true {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:26:9\n-   |\n-LL |     if (let 0 = 1) && true {}\n-   |         ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:29:17\n-   |\n-LL |     if true && (let 0 = 1) {}\n-   |                 ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:9\n-   |\n-LL |     if (let 0 = 1) && (let 0 = 1) {}\n-   |         ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:32:24\n-   |\n-LL |     if (let 0 = 1) && (let 0 = 1) {}\n-   |                        ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:36:8\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |        ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:36:21\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                     ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:36:35\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                   ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:36:48\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:36:61\n-   |\n-LL |     if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                             ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:43:8\n+  --> $DIR/feature-gate.rs:20:8\n    |\n LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -134,25 +35,7 @@ LL |     if let Range { start: _, end: _ } = (true..true) && false {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:50:12\n-   |\n-LL |     while (let 0 = 1) {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:53:14\n-   |\n-LL |     while (((let 0 = 1))) {}\n-   |              ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:56:19\n+  --> $DIR/feature-gate.rs:27:19\n    |\n LL |     while true && let 0 = 1 {}\n    |                   ^^^^^^^^^\n@@ -161,7 +44,7 @@ LL |     while true && let 0 = 1 {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:59:11\n+  --> $DIR/feature-gate.rs:30:11\n    |\n LL |     while let 0 = 1 && true {}\n    |           ^^^^^^^^^\n@@ -170,88 +53,7 @@ LL |     while let 0 = 1 && true {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:62:12\n-   |\n-LL |     while (let 0 = 1) && true {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:65:20\n-   |\n-LL |     while true && (let 0 = 1) {}\n-   |                    ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:68:12\n-   |\n-LL |     while (let 0 = 1) && (let 0 = 1) {}\n-   |            ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:68:27\n-   |\n-LL |     while (let 0 = 1) && (let 0 = 1) {}\n-   |                           ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:72:11\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |           ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:72:24\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                        ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:72:38\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                      ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:72:51\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                   ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:72:64\n-   |\n-LL |     while let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) {}\n-   |                                                                ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:79:11\n+  --> $DIR/feature-gate.rs:33:11\n    |\n LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -260,7 +62,7 @@ LL |     while let Range { start: _, end: _ } = (true..true) && false {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:99:20\n+  --> $DIR/feature-gate.rs:49:20\n    |\n LL |     #[cfg(FALSE)] (let 0 = 1);\n    |                    ^^^^^^^^^\n@@ -269,32 +71,14 @@ LL |     #[cfg(FALSE)] (let 0 = 1);\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:86:17\n+  --> $DIR/feature-gate.rs:40:17\n    |\n LL |     noop_expr!((let 0 = 1));\n    |                 ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:95:16\n-   |\n-LL |     use_expr!((let 0 = 1 && 0 == 0));\n-   |                ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:97:16\n-   |\n-LL |     use_expr!((let 0 = 1));\n-   |                ^^^^^^^^^\n-   |\n-   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n-   = help: add `#![feature(let_chains)]` to the crate attributes to enable\n-\n-error: aborting due to 33 previous errors\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}]}