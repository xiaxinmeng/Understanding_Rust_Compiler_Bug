{"sha": "df06a7e532a56916ec357506df1eed3a6d6435ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmMDZhN2U1MzJhNTY5MTZlYzM1NzUwNmRmMWVlZDNhNmQ2NDM1ZWE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-28T14:19:10Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-02T14:09:19Z"}, "message": "incr.comp.: Remove legacy dep-graph runtime.", "tree": {"sha": "a015be4f66b85b4768baa0092a412734218bb51e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a015be4f66b85b4768baa0092a412734218bb51e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df06a7e532a56916ec357506df1eed3a6d6435ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df06a7e532a56916ec357506df1eed3a6d6435ea", "html_url": "https://github.com/rust-lang/rust/commit/df06a7e532a56916ec357506df1eed3a6d6435ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df06a7e532a56916ec357506df1eed3a6d6435ea/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "171c0208570a7ec5caf3d3697706888c93c7650a", "url": "https://api.github.com/repos/rust-lang/rust/commits/171c0208570a7ec5caf3d3697706888c93c7650a", "html_url": "https://github.com/rust-lang/rust/commit/171c0208570a7ec5caf3d3697706888c93c7650a"}], "stats": {"total": 473, "additions": 87, "deletions": 386}, "files": [{"sha": "241bec39256de8255be072de1876304c356a1f62", "filename": "src/librustc/dep_graph/edges.rs", "status": "removed", "additions": 0, "deletions": 255, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/171c0208570a7ec5caf3d3697706888c93c7650a/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/171c0208570a7ec5caf3d3697706888c93c7650a/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=171c0208570a7ec5caf3d3697706888c93c7650a", "patch": "@@ -1,255 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ich::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::stable_hasher::StableHasher;\n-use std::env;\n-use std::hash::Hash;\n-use std::mem;\n-use super::{DepKind, DepNode};\n-use super::debug::EdgeFilter;\n-\n-pub(super) struct DepGraphEdges {\n-    nodes: Vec<DepNode>,\n-    indices: FxHashMap<DepNode, DepNodeIndex>,\n-    edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n-    task_stack: Vec<OpenTask>,\n-    forbidden_edge: Option<EdgeFilter>,\n-\n-    // A set to help assert that no two tasks use the same DepNode. This is a\n-    // temporary measure. Once we load the previous dep-graph as readonly, this\n-    // check will fall out of the graph implementation naturally.\n-    opened_once: FxHashSet<DepNode>,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub(super) struct DepNodeIndex {\n-    index: u32,\n-}\n-\n-impl DepNodeIndex {\n-\n-    pub const INVALID: DepNodeIndex = DepNodeIndex { index: ::std::u32::MAX };\n-\n-    fn new(v: usize) -> DepNodeIndex {\n-        assert!((v & 0xFFFF_FFFF) == v);\n-        DepNodeIndex { index: v as u32 }\n-    }\n-\n-    fn index(self) -> usize {\n-        self.index as usize\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-enum OpenTask {\n-    Regular {\n-        node: DepNode,\n-        reads: Vec<DepNode>,\n-        read_set: FxHashSet<DepNode>,\n-    },\n-    Anon {\n-        reads: Vec<DepNode>,\n-        read_set: FxHashSet<DepNode>,\n-    },\n-    Ignore,\n-}\n-\n-impl DepGraphEdges {\n-    pub fn new() -> DepGraphEdges {\n-        let forbidden_edge = if cfg!(debug_assertions) {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => {\n-                    match EdgeFilter::new(&s) {\n-                        Ok(f) => Some(f),\n-                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                    }\n-                }\n-                Err(_) => None,\n-            }\n-        } else {\n-            None\n-        };\n-\n-        DepGraphEdges {\n-            nodes: vec![],\n-            indices: FxHashMap(),\n-            edges: FxHashSet(),\n-            task_stack: Vec::new(),\n-            forbidden_edge,\n-            opened_once: FxHashSet(),\n-        }\n-    }\n-\n-    pub fn push_ignore(&mut self) {\n-        self.task_stack.push(OpenTask::Ignore);\n-    }\n-\n-    pub fn pop_ignore(&mut self) {\n-        let popped_node = self.task_stack.pop().unwrap();\n-        debug_assert_eq!(popped_node, OpenTask::Ignore);\n-    }\n-\n-    pub fn push_task(&mut self, key: DepNode) {\n-        if !self.opened_once.insert(key) {\n-            bug!(\"Re-opened node {:?}\", key)\n-        }\n-\n-        self.task_stack.push(OpenTask::Regular {\n-            node: key,\n-            reads: Vec::new(),\n-            read_set: FxHashSet(),\n-        });\n-    }\n-\n-    pub fn pop_task(&mut self, key: DepNode) -> DepNodeIndex {\n-        let popped_node = self.task_stack.pop().unwrap();\n-\n-        if let OpenTask::Regular {\n-            node,\n-            read_set: _,\n-            reads\n-        } = popped_node {\n-            debug_assert_eq!(node, key);\n-            debug_assert!(!node.kind.is_input() || reads.is_empty());\n-\n-            let target_id = self.get_or_create_node(node);\n-\n-            for read in reads.into_iter() {\n-                let source_id = self.get_or_create_node(read);\n-                self.edges.insert((source_id, target_id));\n-            }\n-\n-            target_id\n-        } else {\n-            bug!(\"pop_task() - Expected regular task to be popped\")\n-        }\n-    }\n-\n-    pub fn push_anon_task(&mut self) {\n-        self.task_stack.push(OpenTask::Anon {\n-            reads: Vec::new(),\n-            read_set: FxHashSet(),\n-        });\n-    }\n-\n-    pub fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndex {\n-        let popped_node = self.task_stack.pop().unwrap();\n-\n-        if let OpenTask::Anon {\n-            read_set: _,\n-            reads\n-        } = popped_node {\n-            let mut fingerprint = Fingerprint::zero();\n-            let mut hasher = StableHasher::new();\n-\n-            for read in reads.iter() {\n-                mem::discriminant(&read.kind).hash(&mut hasher);\n-\n-                // Fingerprint::combine() is faster than sending Fingerprint\n-                // through the StableHasher (at least as long as StableHasher\n-                // is so slow).\n-                fingerprint = fingerprint.combine(read.hash);\n-            }\n-\n-            fingerprint = fingerprint.combine(hasher.finish());\n-\n-            let target_dep_node = DepNode {\n-                kind,\n-                hash: fingerprint,\n-            };\n-\n-            if let Some(&index) = self.indices.get(&target_dep_node) {\n-                return index;\n-            }\n-\n-            let target_id = self.get_or_create_node(target_dep_node);\n-\n-            for read in reads.into_iter() {\n-                let source_id = self.get_or_create_node(read);\n-                self.edges.insert((source_id, target_id));\n-            }\n-\n-            target_id\n-        } else {\n-            bug!(\"pop_anon_task() - Expected anonymous task to be popped\")\n-        }\n-    }\n-\n-    /// Indicates that the current task `C` reads `v` by adding an\n-    /// edge from `v` to `C`. If there is no current task, has no\n-    /// effect. Note that *reading* from tracked state is harmless if\n-    /// you are not in a task; what is bad is *writing* to tracked\n-    /// state (and leaking data that you read into a tracked task).\n-    pub fn read(&mut self, source: DepNode) {\n-        match self.task_stack.last_mut() {\n-            Some(&mut OpenTask::Regular {\n-                node: target,\n-                ref mut reads,\n-                ref mut read_set,\n-            }) => {\n-                if read_set.insert(source) {\n-                    reads.push(source);\n-\n-                    if cfg!(debug_assertions) {\n-                        if let Some(ref forbidden_edge) = self.forbidden_edge {\n-                            if forbidden_edge.test(&source, &target) {\n-                                bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            Some(&mut OpenTask::Anon {\n-                ref mut reads,\n-                ref mut read_set,\n-            }) => {\n-                if read_set.insert(source) {\n-                    reads.push(source);\n-                }\n-            }\n-            Some(&mut OpenTask::Ignore) | None => {\n-                // ignore\n-            }\n-        }\n-    }\n-\n-    pub fn read_index(&mut self, source: DepNodeIndex) {\n-        let dep_node = self.nodes[source.index()];\n-        self.read(dep_node);\n-    }\n-\n-    #[inline]\n-    pub fn add_edge(&mut self, source: DepNode, target: DepNode) {\n-        let source = self.get_or_create_node(source);\n-        let target = self.get_or_create_node(target);\n-        self.edges.insert((source, target));\n-    }\n-\n-    pub fn add_node(&mut self, node: DepNode) -> DepNodeIndex {\n-        self.get_or_create_node(node)\n-    }\n-\n-    #[inline]\n-    fn get_or_create_node(&mut self, dep_node: DepNode) -> DepNodeIndex {\n-        let DepGraphEdges {\n-            ref mut indices,\n-            ref mut nodes,\n-            ..\n-        } = *self;\n-\n-        *indices.entry(dep_node).or_insert_with(|| {\n-            let next_id = nodes.len();\n-            nodes.push(dep_node);\n-            DepNodeIndex::new(next_id)\n-        })\n-     }\n-}"}, {"sha": "e7207ca6086750b51acb1735bfdeb79f17696f4b", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 78, "deletions": 117, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=df06a7e532a56916ec357506df1eed3a6d6435ea", "patch": "@@ -14,22 +14,22 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n+use std::env;\n use std::hash::Hash;\n use std::rc::Rc;\n use ty::TyCtxt;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n use ich::Fingerprint;\n \n+use super::debug::EdgeFilter;\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::safe::DepGraphSafe;\n-use super::edges::{self, DepGraphEdges};\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n use super::prev::PreviousDepGraph;\n \n-\n #[derive(Clone)]\n pub struct DepGraph {\n     data: Option<Rc<DepGraphData>>,\n@@ -44,20 +44,25 @@ pub struct DepGraph {\n     fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n }\n \n-/// As a temporary measure, while transitioning to the new DepGraph\n-/// implementation, we maintain the old and the new dep-graph encoding in\n-/// parallel, so a DepNodeIndex actually contains two indices, one for each\n-/// version.\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DepNodeIndex {\n-    legacy: edges::DepNodeIndex,\n-    new: DepNodeIndexNew,\n+    index: u32,\n+}\n+\n+impl Idx for DepNodeIndex {\n+    fn new(idx: usize) -> Self {\n+        assert!((idx & 0xFFFF_FFFF) == idx);\n+        DepNodeIndex { index: idx as u32 }\n+    }\n+    fn index(self) -> usize {\n+        self.index as usize\n+    }\n }\n \n impl DepNodeIndex {\n-    pub const INVALID: DepNodeIndex = DepNodeIndex {\n-        legacy: edges::DepNodeIndex::INVALID,\n-        new: DepNodeIndexNew::INVALID,\n+    const INVALID: DepNodeIndex = DepNodeIndex {\n+        index: ::std::u32::MAX,\n     };\n }\n \n@@ -77,10 +82,6 @@ impl DepNodeColor {\n }\n \n struct DepGraphData {\n-    /// The old, initial encoding of the dependency graph. This will soon go\n-    /// away.\n-    edges: RefCell<DepGraphEdges>,\n-\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n@@ -105,7 +106,7 @@ struct DepGraphData {\n     dep_node_debug: RefCell<FxHashMap<DepNode, String>>,\n \n     // Used for testing, only populated when -Zquery-dep-graph is specified.\n-    loaded_from_cache: RefCell<FxHashMap<DepNodeIndexNew, bool>>,\n+    loaded_from_cache: RefCell<FxHashMap<DepNodeIndex, bool>>,\n }\n \n impl DepGraph {\n@@ -115,7 +116,6 @@ impl DepGraph {\n             data: Some(Rc::new(DepGraphData {\n                 previous_work_products: RefCell::new(FxHashMap()),\n                 work_products: RefCell::new(FxHashMap()),\n-                edges: RefCell::new(DepGraphEdges::new()),\n                 dep_node_debug: RefCell::new(FxHashMap()),\n                 current: RefCell::new(CurrentDepGraph::new()),\n                 previous: prev_graph,\n@@ -155,8 +155,7 @@ impl DepGraph {\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> Option<raii::IgnoreTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges,\n-                                                            &data.current))\n+        self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.current))\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -205,7 +204,6 @@ impl DepGraph {\n         if let Some(ref data) = self.data {\n             debug_assert!(!data.colors.borrow().contains_key(&key));\n \n-            data.edges.borrow_mut().push_task(key);\n             data.current.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n@@ -223,8 +221,7 @@ impl DepGraph {\n                 profq_msg(ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let dep_node_index_legacy = data.edges.borrow_mut().pop_task(key);\n-            let dep_node_index_new = data.current.borrow_mut().pop_task(key);\n+            let dep_node_index = data.current.borrow_mut().pop_task(key);\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n@@ -239,20 +236,14 @@ impl DepGraph {\n             let prev_fingerprint = data.previous.fingerprint_of(&key);\n \n             let color = if Some(current_fingerprint) == prev_fingerprint {\n-                DepNodeColor::Green(DepNodeIndex {\n-                    legacy: dep_node_index_legacy,\n-                    new: dep_node_index_new,\n-                })\n+                DepNodeColor::Green(dep_node_index)\n             } else {\n                 DepNodeColor::Red\n             };\n \n             assert!(data.colors.borrow_mut().insert(key, color).is_none());\n \n-            (result, DepNodeIndex {\n-                legacy: dep_node_index_legacy,\n-                new: dep_node_index_new,\n-            })\n+            (result, dep_node_index)\n         } else {\n             if key.kind.fingerprint_needed_for_crate_hash() {\n                 let mut hcx = cx.create_stable_hashing_context();\n@@ -276,17 +267,12 @@ impl DepGraph {\n         where OP: FnOnce() -> R\n     {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().push_anon_task();\n             data.current.borrow_mut().push_anon_task();\n             let result = op();\n-            let dep_node_index_legacy = data.edges.borrow_mut().pop_anon_task(dep_kind);\n-            let dep_node_index_new = data.current\n-                                         .borrow_mut()\n-                                         .pop_anon_task(dep_kind);\n-            (result, DepNodeIndex {\n-                legacy: dep_node_index_legacy,\n-                new: dep_node_index_new,\n-            })\n+            let dep_node_index = data.current\n+                                     .borrow_mut()\n+                                     .pop_anon_task(dep_kind);\n+            (result, dep_node_index)\n         } else {\n             (op(), DepNodeIndex::INVALID)\n         }\n@@ -295,36 +281,22 @@ impl DepGraph {\n     #[inline]\n     pub fn read(&self, v: DepNode) {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().read(v);\n-\n             let mut current = data.current.borrow_mut();\n-            if let Some(&dep_node_index_new) = current.node_to_node_index.get(&v) {\n-                current.read_index(dep_node_index_new);\n+            if let Some(&dep_node_index) = current.node_to_node_index.get(&v) {\n+                current.read_index(dep_node_index);\n             } else {\n                 bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n             }\n         }\n     }\n \n     #[inline]\n-    pub fn read_index(&self, v: DepNodeIndex) {\n+    pub fn read_index(&self, dep_node_index: DepNodeIndex) {\n         if let Some(ref data) = self.data {\n-            data.edges.borrow_mut().read_index(v.legacy);\n-            data.current.borrow_mut().read_index(v.new);\n+            data.current.borrow_mut().read_index(dep_node_index);\n         }\n     }\n \n-    /// Only to be used during graph loading\n-    #[inline]\n-    pub fn add_edge_directly(&self, source: DepNode, target: DepNode) {\n-        self.data.as_ref().unwrap().edges.borrow_mut().add_edge(source, target);\n-    }\n-\n-    /// Only to be used during graph loading\n-    pub fn add_node_directly(&self, node: DepNode) {\n-        self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n-    }\n-\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n         self.fingerprints.borrow()[dep_node]\n     }\n@@ -567,18 +539,9 @@ impl DepGraph {\n \n         // ... allocating an entry for it in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph ...\n-        let node_index_new = data.current\n+        let dep_node_index = data.current\n                                  .borrow_mut()\n-                                 .alloc_node(*dep_node,\n-                                             current_deps.iter().map(|n| n.new).collect());\n-        let dep_node_index_legacy = {\n-            let mut legacy_graph = data.edges.borrow_mut();\n-            legacy_graph.push_task(*dep_node);\n-            for node_index in current_deps.into_iter().map(|n| n.legacy) {\n-                legacy_graph.read_index(node_index);\n-            }\n-            legacy_graph.pop_task(*dep_node)\n-        };\n+                                 .alloc_node(*dep_node, current_deps);\n \n         // ... copying the fingerprint from the previous graph too, so we don't\n         // have to recompute it ...\n@@ -588,24 +551,19 @@ impl DepGraph {\n                     .insert(*dep_node, fingerprint)\n                     .is_none());\n \n-        let node_index = DepNodeIndex {\n-            legacy: dep_node_index_legacy,\n-            new: node_index_new,\n-        };\n-\n         // ... and finally storing a \"Green\" entry in the color map.\n         assert!(data.colors\n                     .borrow_mut()\n-                    .insert(*dep_node, DepNodeColor::Green(node_index))\n+                    .insert(*dep_node, DepNodeColor::Green(dep_node_index))\n                     .is_none());\n \n         debug!(\"try_mark_green({:?}) - END - successfully marked as green\", dep_node.kind);\n-        Some(node_index)\n+        Some(dep_node_index)\n     }\n \n     // Used in various assertions\n     pub fn is_green(&self, dep_node_index: DepNodeIndex) -> bool {\n-        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index.new];\n+        let dep_node = self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index];\n         self.data.as_ref().unwrap().colors.borrow().get(&dep_node).map(|&color| {\n             match color {\n                 DepNodeColor::Red => false,\n@@ -614,17 +572,17 @@ impl DepGraph {\n         }).unwrap_or(false)\n     }\n \n-    pub fn mark_loaded_from_cache(&self, dep_node: DepNodeIndex, state: bool) {\n+    pub fn mark_loaded_from_cache(&self, dep_node_index: DepNodeIndex, state: bool) {\n         debug!(\"mark_loaded_from_cache({:?}, {})\",\n-               self.data.as_ref().unwrap().current.borrow().nodes[dep_node.new],\n+               self.data.as_ref().unwrap().current.borrow().nodes[dep_node_index],\n                state);\n \n         self.data\n             .as_ref()\n             .unwrap()\n             .loaded_from_cache\n             .borrow_mut()\n-            .insert(dep_node.new, state);\n+            .insert(dep_node_index, state);\n     }\n \n     pub fn was_loaded_from_cache(&self, dep_node: &DepNode) -> Option<bool> {\n@@ -673,13 +631,12 @@ pub struct WorkProduct {\n }\n \n pub(super) struct CurrentDepGraph {\n-    nodes: IndexVec<DepNodeIndexNew, DepNode>,\n-    edges: IndexVec<DepNodeIndexNew, Vec<DepNodeIndexNew>>,\n-    node_to_node_index: FxHashMap<DepNode, DepNodeIndexNew>,\n-\n+    nodes: IndexVec<DepNodeIndex, DepNode>,\n+    edges: IndexVec<DepNodeIndex, Vec<DepNodeIndex>>,\n+    node_to_node_index: FxHashMap<DepNode, DepNodeIndex>,\n     anon_id_seed: Fingerprint,\n-\n     task_stack: Vec<OpenTask>,\n+    forbidden_edge: Option<EdgeFilter>,\n }\n \n impl CurrentDepGraph {\n@@ -692,12 +649,27 @@ impl CurrentDepGraph {\n         let mut stable_hasher = StableHasher::new();\n         nanos.hash(&mut stable_hasher);\n \n+        let forbidden_edge = if cfg!(debug_assertions) {\n+            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+                Ok(s) => {\n+                    match EdgeFilter::new(&s) {\n+                        Ok(f) => Some(f),\n+                        Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    }\n+                }\n+                Err(_) => None,\n+            }\n+        } else {\n+            None\n+        };\n+\n         CurrentDepGraph {\n             nodes: IndexVec::new(),\n             edges: IndexVec::new(),\n             node_to_node_index: FxHashMap(),\n             anon_id_seed: stable_hasher.finish(),\n             task_stack: Vec::new(),\n+            forbidden_edge,\n         }\n     }\n \n@@ -718,7 +690,7 @@ impl CurrentDepGraph {\n         });\n     }\n \n-    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndexNew {\n+    pub(super) fn pop_task(&mut self, key: DepNode) -> DepNodeIndex {\n         let popped_node = self.task_stack.pop().unwrap();\n \n         if let OpenTask::Regular {\n@@ -740,7 +712,7 @@ impl CurrentDepGraph {\n         });\n     }\n \n-    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndexNew {\n+    fn pop_anon_task(&mut self, kind: DepKind) -> DepNodeIndex {\n         let popped_node = self.task_stack.pop().unwrap();\n \n         if let OpenTask::Anon {\n@@ -778,15 +750,26 @@ impl CurrentDepGraph {\n         }\n     }\n \n-    fn read_index(&mut self, source: DepNodeIndexNew) {\n+    fn read_index(&mut self, source: DepNodeIndex) {\n         match self.task_stack.last_mut() {\n             Some(&mut OpenTask::Regular {\n                 ref mut reads,\n                 ref mut read_set,\n-                node: _,\n+                node: ref target,\n             }) => {\n                 if read_set.insert(source) {\n                     reads.push(source);\n+\n+                    if cfg!(debug_assertions) {\n+                        if let Some(ref forbidden_edge) = self.forbidden_edge {\n+                            let source = self.nodes[source];\n+                            if forbidden_edge.test(&source, &target) {\n+                                bug!(\"forbidden edge {:?} -> {:?} created\",\n+                                     source,\n+                                     target)\n+                            }\n+                        }\n+                    }\n                 }\n             }\n             Some(&mut OpenTask::Anon {\n@@ -805,51 +788,29 @@ impl CurrentDepGraph {\n \n     fn alloc_node(&mut self,\n                   dep_node: DepNode,\n-                  edges: Vec<DepNodeIndexNew>)\n-                  -> DepNodeIndexNew {\n+                  edges: Vec<DepNodeIndex>)\n+                  -> DepNodeIndex {\n         debug_assert_eq!(self.edges.len(), self.nodes.len());\n         debug_assert_eq!(self.node_to_node_index.len(), self.nodes.len());\n         debug_assert!(!self.node_to_node_index.contains_key(&dep_node));\n-        let dep_node_index = DepNodeIndexNew::new(self.nodes.len());\n+        let dep_node_index = DepNodeIndex::new(self.nodes.len());\n         self.nodes.push(dep_node);\n         self.node_to_node_index.insert(dep_node, dep_node_index);\n         self.edges.push(edges);\n         dep_node_index\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub(super) struct DepNodeIndexNew {\n-    index: u32,\n-}\n-\n-impl Idx for DepNodeIndexNew {\n-    fn new(v: usize) -> DepNodeIndexNew {\n-        assert!((v & 0xFFFF_FFFF) == v);\n-        DepNodeIndexNew { index: v as u32 }\n-    }\n-\n-    fn index(self) -> usize {\n-        self.index as usize\n-    }\n-}\n-\n-impl DepNodeIndexNew {\n-    const INVALID: DepNodeIndexNew = DepNodeIndexNew {\n-        index: ::std::u32::MAX,\n-    };\n-}\n-\n #[derive(Clone, Debug, PartialEq)]\n enum OpenTask {\n     Regular {\n         node: DepNode,\n-        reads: Vec<DepNodeIndexNew>,\n-        read_set: FxHashSet<DepNodeIndexNew>,\n+        reads: Vec<DepNodeIndex>,\n+        read_set: FxHashSet<DepNodeIndex>,\n     },\n     Anon {\n-        reads: Vec<DepNodeIndexNew>,\n-        read_set: FxHashSet<DepNodeIndexNew>,\n+        reads: Vec<DepNodeIndex>,\n+        read_set: FxHashSet<DepNodeIndex>,\n     },\n     Ignore,\n }"}, {"sha": "8d2cf67684923118d1523916f843d9056d646fc2", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=df06a7e532a56916ec357506df1eed3a6d6435ea", "patch": "@@ -11,7 +11,6 @@\n pub mod debug;\n mod dep_node;\n mod dep_tracking_map;\n-mod edges;\n mod graph;\n mod prev;\n mod query;"}, {"sha": "5728bcc7d27710dbccc7cfa69e32a904bc79976e", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=df06a7e532a56916ec357506df1eed3a6d6435ea", "patch": "@@ -8,33 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::edges::DepGraphEdges;\n use super::graph::CurrentDepGraph;\n \n use std::cell::RefCell;\n \n pub struct IgnoreTask<'graph> {\n-    legacy_graph: &'graph RefCell<DepGraphEdges>,\n-    new_graph: &'graph RefCell<CurrentDepGraph>,\n+    graph: &'graph RefCell<CurrentDepGraph>,\n }\n \n impl<'graph> IgnoreTask<'graph> {\n-    pub(super) fn new(legacy_graph: &'graph RefCell<DepGraphEdges>,\n-                      new_graph: &'graph RefCell<CurrentDepGraph>)\n-                      -> IgnoreTask<'graph> {\n-        legacy_graph.borrow_mut().push_ignore();\n-        new_graph.borrow_mut().push_ignore();\n+    pub(super) fn new(graph: &'graph RefCell<CurrentDepGraph>) -> IgnoreTask<'graph> {\n+        graph.borrow_mut().push_ignore();\n         IgnoreTask {\n-            legacy_graph,\n-            new_graph,\n+            graph,\n         }\n     }\n }\n \n impl<'graph> Drop for IgnoreTask<'graph> {\n     fn drop(&mut self) {\n-        self.legacy_graph.borrow_mut().pop_ignore();\n-        self.new_graph.borrow_mut().pop_ignore();\n+        self.graph.borrow_mut().pop_ignore();\n     }\n }\n "}, {"sha": "7275a740e76f8e2abcfb53f400b98fbe7bd3defb", "filename": "src/librustc/dep_graph/serialized.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df06a7e532a56916ec357506df1eed3a6d6435ea/src%2Flibrustc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fserialized.rs?ref=df06a7e532a56916ec357506df1eed3a6d6435ea", "patch": "@@ -56,7 +56,10 @@ impl SerializedDepGraph {\n         }\n     }\n \n-    pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n+    #[inline]\n+    pub fn edge_targets_from(&self,\n+                             source: SerializedDepNodeIndex)\n+                             -> &[SerializedDepNodeIndex] {\n         let targets = self.edge_list_indices[source];\n         &self.edge_list_data[targets.0 as usize..targets.1 as usize]\n     }"}]}