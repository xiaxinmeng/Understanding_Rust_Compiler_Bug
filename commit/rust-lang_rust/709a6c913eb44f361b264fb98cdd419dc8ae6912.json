{"sha": "709a6c913eb44f361b264fb98cdd419dc8ae6912", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwOWE2YzkxM2ViNDRmMzYxYjI2NGZiOThjZGQ0MTlkYzhhZTY5MTI=", "commit": {"author": {"name": "Michael Watzko", "email": "michael@watzko.de", "date": "2021-08-10T17:22:06Z"}, "committer": {"name": "Michael Watzko", "email": "michael@watzko.de", "date": "2021-08-10T17:27:01Z"}, "message": "Add Saturating type (based on Wrapping type)", "tree": {"sha": "8e6d52b39851ba937cbee5aaa9ad8e1fd76c9d3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e6d52b39851ba937cbee5aaa9ad8e1fd76c9d3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/709a6c913eb44f361b264fb98cdd419dc8ae6912", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/709a6c913eb44f361b264fb98cdd419dc8ae6912", "html_url": "https://github.com/rust-lang/rust/commit/709a6c913eb44f361b264fb98cdd419dc8ae6912", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/709a6c913eb44f361b264fb98cdd419dc8ae6912/comments", "author": {"login": "kellerkindt", "id": 1133787, "node_id": "MDQ6VXNlcjExMzM3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1133787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kellerkindt", "html_url": "https://github.com/kellerkindt", "followers_url": "https://api.github.com/users/kellerkindt/followers", "following_url": "https://api.github.com/users/kellerkindt/following{/other_user}", "gists_url": "https://api.github.com/users/kellerkindt/gists{/gist_id}", "starred_url": "https://api.github.com/users/kellerkindt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kellerkindt/subscriptions", "organizations_url": "https://api.github.com/users/kellerkindt/orgs", "repos_url": "https://api.github.com/users/kellerkindt/repos", "events_url": "https://api.github.com/users/kellerkindt/events{/privacy}", "received_events_url": "https://api.github.com/users/kellerkindt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kellerkindt", "id": 1133787, "node_id": "MDQ6VXNlcjExMzM3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1133787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kellerkindt", "html_url": "https://github.com/kellerkindt", "followers_url": "https://api.github.com/users/kellerkindt/followers", "following_url": "https://api.github.com/users/kellerkindt/following{/other_user}", "gists_url": "https://api.github.com/users/kellerkindt/gists{/gist_id}", "starred_url": "https://api.github.com/users/kellerkindt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kellerkindt/subscriptions", "organizations_url": "https://api.github.com/users/kellerkindt/orgs", "repos_url": "https://api.github.com/users/kellerkindt/repos", "events_url": "https://api.github.com/users/kellerkindt/events{/privacy}", "received_events_url": "https://api.github.com/users/kellerkindt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae90dcf0207c57c3034f00b07048d63f8b2363c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae90dcf0207c57c3034f00b07048d63f8b2363c8", "html_url": "https://github.com/rust-lang/rust/commit/ae90dcf0207c57c3034f00b07048d63f8b2363c8"}], "stats": {"total": 821, "additions": 821, "deletions": 0}, "files": [{"sha": "09b7418bec0d9caf781d3946f598f7e8d401cb65", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=709a6c913eb44f361b264fb98cdd419dc8ae6912", "patch": "@@ -43,8 +43,12 @@ mod uint_macros; // import uint_impl!\n mod error;\n mod int_log10;\n mod nonzero;\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+mod saturating;\n mod wrapping;\n \n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+pub use saturating::Saturating;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use wrapping::Wrapping;\n "}, {"sha": "4f1937c68c7e2b9dfe1474d2b91e468766ab80ba", "filename": "library/core/src/num/saturating.rs", "status": "added", "additions": 814, "deletions": 0, "changes": 814, "blob_url": "https://github.com/rust-lang/rust/blob/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fsaturating.rs?ref=709a6c913eb44f361b264fb98cdd419dc8ae6912", "patch": "@@ -0,0 +1,814 @@\n+//! Definitions of `Saturating<T>`.\n+\n+use crate::fmt;\n+use crate::ops::{Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign};\n+use crate::ops::{BitXor, BitXorAssign, Div, DivAssign};\n+use crate::ops::{Mul, MulAssign, Neg, Not};\n+use crate::ops::{Sub, SubAssign};\n+\n+/// Provides intentionally-wrapped arithmetic on `T`.\n+///\n+/// Operations like `+` on `u32` values are intended to never overflow,\n+/// and in some debug configurations overflow is detected and results\n+/// in a panic. While most arithmetic falls into this category, some\n+/// code explicitly expects and relies upon modular arithmetic (e.g.,\n+/// hashing).\n+///\n+/// Saturating arithmetic can be achieved either through methods like\n+/// `saturating_add`, or through the `Saturating<T>` type, which says that\n+/// all standard arithmetic operations on the underlying value are\n+/// intended to have saturating semantics.\n+///\n+/// The underlying value can be retrieved through the `.0` index of the\n+/// `Saturating` tuple.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(saturating_int_impl)]\n+/// use std::num::Saturating;\n+///\n+/// let max = Saturating(u32::MAX);\n+/// let one = Saturating(1u32);\n+///\n+/// assert_eq!(u32::MAX, (max + one).0);\n+/// ```\n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+#[derive(PartialEq, Eq, PartialOrd, Ord, Clone, Copy, Default, Hash)]\n+#[repr(transparent)]\n+pub struct Saturating<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"saturating_display\", since = \"1.10.0\")]\n+impl<T: fmt::Display> fmt::Display for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"saturating_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::Binary> fmt::Binary for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"saturating_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::Octal> fmt::Octal for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"saturating_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::LowerHex> fmt::LowerHex for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[stable(feature = \"saturating_fmt\", since = \"1.11.0\")]\n+impl<T: fmt::UpperHex> fmt::UpperHex for Saturating<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! sh_impl_signed {\n+    ($t:ident, $f:ident) => {\n+\n+    };\n+}\n+\n+macro_rules! sh_impl_unsigned {\n+    ($t:ident, $f:ident) => {\n+\n+    };\n+}\n+\n+// FIXME (#23545): uncomment the remaining impls\n+macro_rules! sh_impl_all {\n+    ($($t:ident)*) => ($(\n+        //sh_impl_unsigned! { $t, u8 }\n+        //sh_impl_unsigned! { $t, u16 }\n+        //sh_impl_unsigned! { $t, u32 }\n+        //sh_impl_unsigned! { $t, u64 }\n+        //sh_impl_unsigned! { $t, u128 }\n+        sh_impl_unsigned! { $t, usize }\n+\n+        //sh_impl_signed! { $t, i8 }\n+        //sh_impl_signed! { $t, i16 }\n+        //sh_impl_signed! { $t, i32 }\n+        //sh_impl_signed! { $t, i64 }\n+        //sh_impl_signed! { $t, i128 }\n+        //sh_impl_signed! { $t, isize }\n+    )*)\n+}\n+\n+sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n+\n+// FIXME(30524): impl Op<T> for Saturating<T>, impl OpAssign<T> for Saturating<T>\n+macro_rules! saturating_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn add(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_add(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Add, add for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl AddAssign for Saturating<$t> {\n+            #[inline]\n+            fn add_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self + other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl AddAssign, add_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Sub for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn sub(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_sub(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Sub, sub for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl SubAssign for Saturating<$t> {\n+            #[inline]\n+            fn sub_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self - other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl SubAssign, sub_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Mul for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn mul(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0.saturating_mul(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Mul, mul for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl MulAssign for Saturating<$t> {\n+            #[inline]\n+            fn mul_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self * other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl MulAssign, mul_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"saturating_div\", since = \"1.3.0\")]\n+        impl Div for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn div(self, other: Saturating<$t>) -> Saturating<$t> {\n+                // saturating div is the default behavior?\n+                Saturating(self.0.div(other.0))\n+            }\n+        }\n+        forward_ref_binop! { impl Div, div for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl DivAssign for Saturating<$t> {\n+            #[inline]\n+            fn div_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self / other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl DivAssign, div_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Not for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn not(self) -> Saturating<$t> {\n+                Saturating(!self.0)\n+            }\n+        }\n+        forward_ref_unop! { impl Not, not for Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitXor for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitxor(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 ^ other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitXor, bitxor for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitXorAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self ^ other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitXorAssign, bitxor_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitOr for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitor(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 | other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitOr, bitor for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitOrAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitor_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self | other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitOrAssign, bitor_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl BitAnd for Saturating<$t> {\n+            type Output = Saturating<$t>;\n+\n+            #[inline]\n+            fn bitand(self, other: Saturating<$t>) -> Saturating<$t> {\n+                Saturating(self.0 & other.0)\n+            }\n+        }\n+        forward_ref_binop! { impl BitAnd, bitand for Saturating<$t>, Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+        #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n+        impl BitAndAssign for Saturating<$t> {\n+            #[inline]\n+            fn bitand_assign(&mut self, other: Saturating<$t>) {\n+                *self = *self & other;\n+            }\n+        }\n+        forward_ref_op_assign! { impl BitAndAssign, bitand_assign for Saturating<$t>, Saturating<$t> }\n+\n+        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n+        impl Neg for Saturating<$t> {\n+            type Output = Self;\n+            #[inline]\n+            fn neg(self) -> Self {\n+                Saturating(0) - self\n+            }\n+        }\n+        forward_ref_unop! { impl Neg, neg for Saturating<$t>,\n+                #[stable(feature = \"saturating_ref\", since = \"1.14.0\")] }\n+\n+    )*)\n+}\n+\n+saturating_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the smallest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::MIN, Saturating(\", stringify!($t), \"::MIN));\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const MIN: Self = Self(<$t>::MIN);\n+\n+            /// Returns the largest value that can be represented by this integer type.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::MAX, Saturating(\", stringify!($t), \"::MAX));\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const MAX: Self = Self(<$t>::MAX);\n+\n+            /// Returns the size of this integer type in bits.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(<Saturating<\", stringify!($t), \">>::BITS, \", stringify!($t), \"::BITS);\")]\n+            /// ```\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const BITS: u32 = <$t>::BITS;\n+\n+            /// Returns the number of ones in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0b01001100\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.count_ones(), 3);\n+            /// ```\n+            #[inline]\n+            #[doc(alias = \"popcount\")]\n+            #[doc(alias = \"popcnt\")]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn count_ones(self) -> u32 {\n+                self.0.count_ones()\n+            }\n+\n+            /// Returns the number of zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(!0\", stringify!($t), \").count_zeros(), 0);\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn count_zeros(self) -> u32 {\n+                self.0.count_zeros()\n+            }\n+\n+            /// Returns the number of trailing zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0b0101000\", stringify!($t), \");\")]\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn trailing_zeros(self) -> u32 {\n+                self.0.trailing_zeros()\n+            }\n+\n+            /// Shifts the bits to the left by a specified amount, `n`,\n+            /// saturating the truncated bits to the end of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as the `<<` shifting\n+            /// operator!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i64> = Saturating(0x0123456789ABCDEF);\n+            /// let m: Saturating<i64> = Saturating(-0x76543210FEDCBA99);\n+            ///\n+            /// assert_eq!(n.rotate_left(32), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n+                Saturating(self.0.rotate_left(n))\n+            }\n+\n+            /// Shifts the bits to the right by a specified amount, `n`,\n+            /// saturating the truncated bits to the beginning of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as the `>>` shifting\n+            /// operator!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i64> = Saturating(0x0123456789ABCDEF);\n+            /// let m: Saturating<i64> = Saturating(-0xFEDCBA987654322);\n+            ///\n+            /// assert_eq!(n.rotate_right(4), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n+                Saturating(self.0.rotate_right(n))\n+            }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n: Saturating<i16> = Saturating(0b0000000_01010101);\n+            /// assert_eq!(n, Saturating(85));\n+            ///\n+            /// let m = n.swap_bytes();\n+            ///\n+            /// assert_eq!(m, Saturating(0b01010101_00000000));\n+            /// assert_eq!(m, Saturating(21760));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn swap_bytes(self) -> Self {\n+                Saturating(self.0.swap_bytes())\n+            }\n+\n+            /// Reverses the bit pattern of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Please note that this example is shared between integer types.\n+            /// Which explains why `i16` is used here.\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// let n = Saturating(0b0000000_01010101i16);\n+            /// assert_eq!(n, Saturating(85));\n+            ///\n+            /// let m = n.reverse_bits();\n+            ///\n+            /// assert_eq!(m.0 as u16, 0b10101010_00000000);\n+            /// assert_eq!(m, Saturating(-22016));\n+            /// ```\n+            #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n+            #[rustc_const_stable(feature = \"const_reverse_bits\", since = \"1.37.0\")]\n+            #[inline]\n+            #[must_use]\n+            pub const fn reverse_bits(self) -> Self {\n+                Saturating(self.0.reverse_bits())\n+            }\n+\n+            /// Converts an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_be(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_be(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn from_be(x: Self) -> Self {\n+                Saturating(<$t>::from_be(x.0))\n+            }\n+\n+            /// Converts an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_le(n), n)\")]\n+            /// } else {\n+            #[doc = concat!(\"    assert_eq!(<Saturating<\", stringify!($t), \">>::from_le(n), n.swap_bytes())\")]\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn from_le(x: Self) -> Self {\n+                Saturating(<$t>::from_le(x.0))\n+            }\n+\n+            /// Converts `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn to_be(self) -> Self {\n+                Saturating(self.0.to_be())\n+            }\n+\n+            /// Converts `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(0x1A\", stringify!($t), \");\")]\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n)\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes())\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn to_le(self) -> Self {\n+                Saturating(self.0.to_le())\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(3\", stringify!($t), \").pow(4), Saturating(81));\")]\n+            /// ```\n+            ///\n+            /// Results that are too large are wrapped:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            /// assert_eq!(Saturating(3i8).pow(5), Saturating(127));\n+            /// assert_eq!(Saturating(3i8).pow(6), Saturating(127));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn pow(self, exp: u32) -> Self {\n+                Saturating(self.0.saturating_pow(exp))\n+            }\n+        }\n+    )*)\n+}\n+\n+saturating_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl_signed {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(\", stringify!($t), \"::MAX) / 4;\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 3);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Computes the absolute value of `self`, saturating around at\n+            /// the boundary of the type.\n+            ///\n+            /// The only case where such saturating can occur is when one takes the absolute value of the negative\n+            /// minimal value for the type this is a positive value that is too large to represent in the type. In\n+            /// such a case, this function returns `MIN` itself.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(100\", stringify!($t), \").abs(), Saturating(100));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(-100\", stringify!($t), \").abs(), Saturating(100));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(\", stringify!($t), \"::MIN).abs(), Saturating(\", stringify!($t), \"::MIN));\")]\n+            /// assert_eq!(Saturating(-128i8).abs().0 as u8, 128u8);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn abs(self) -> Saturating<$t> {\n+                Saturating(self.0.saturating_abs())\n+            }\n+\n+            /// Returns a number representing sign of `self`.\n+            ///\n+            ///  - `0` if the number is zero\n+            ///  - `1` if the number is positive\n+            ///  - `-1` if the number is negative\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert_eq!(Saturating(10\", stringify!($t), \").signum(), Saturating(1));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(0\", stringify!($t), \").signum(), Saturating(0));\")]\n+            #[doc = concat!(\"assert_eq!(Saturating(-10\", stringify!($t), \").signum(), Saturating(-1));\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn signum(self) -> Saturating<$t> {\n+                Saturating(self.0.signum())\n+            }\n+\n+            /// Returns `true` if `self` is positive and `false` if the number is zero or\n+            /// negative.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(10\", stringify!($t), \").is_positive());\")]\n+            #[doc = concat!(\"assert!(!Saturating(-10\", stringify!($t), \").is_positive());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn is_positive(self) -> bool {\n+                self.0.is_positive()\n+            }\n+\n+            /// Returns `true` if `self` is negative and `false` if the number is zero or\n+            /// positive.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(-10\", stringify!($t), \").is_negative());\")]\n+            #[doc = concat!(\"assert!(!Saturating(10\", stringify!($t), \").is_negative());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn is_negative(self) -> bool {\n+                self.0.is_negative()\n+            }\n+        }\n+    )*)\n+}\n+\n+saturating_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n+\n+macro_rules! saturating_int_impl_unsigned {\n+    ($($t:ty)*) => ($(\n+        impl Saturating<$t> {\n+            /// Returns the number of leading zeros in the binary representation of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"let n = Saturating(\", stringify!($t), \"::MAX) / 4;\")]\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 2);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub const fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Returns `true` if and only if `self == 2^k` for some `k`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(saturating_int_impl)]\n+            /// use std::num::Saturating;\n+            ///\n+            #[doc = concat!(\"assert!(Saturating(16\", stringify!($t), \").is_power_of_two());\")]\n+            #[doc = concat!(\"assert!(!Saturating(10\", stringify!($t), \").is_power_of_two());\")]\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+            pub fn is_power_of_two(self) -> bool {\n+                self.0.is_power_of_two()\n+            }\n+\n+        }\n+    )*)\n+}\n+\n+saturating_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }"}, {"sha": "818ca7df3e37a159de2335b072635ff4e1f80148", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=709a6c913eb44f361b264fb98cdd419dc8ae6912", "patch": "@@ -308,6 +308,7 @@\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(rustc_private)]\n+#![feature(saturating_int_impl)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]"}, {"sha": "46064bd2837705eafbc31999ff3b115e38e30f74", "filename": "library/std/src/num.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fstd%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/709a6c913eb44f361b264fb98cdd419dc8ae6912/library%2Fstd%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnum.rs?ref=709a6c913eb44f361b264fb98cdd419dc8ae6912", "patch": "@@ -12,6 +12,8 @@ mod tests;\n #[cfg(test)]\n mod benches;\n \n+#[unstable(feature = \"saturating_int_impl\", issue = \"87920\")]\n+pub use core::num::Saturating;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::num::Wrapping;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}