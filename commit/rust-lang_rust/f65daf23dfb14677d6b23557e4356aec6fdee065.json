{"sha": "f65daf23dfb14677d6b23557e4356aec6fdee065", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2NWRhZjIzZGZiMTQ2NzdkNmIyMzU1N2U0MzU2YWVjNmZkZWUwNjU=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T15:34:17Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-02-12T15:34:37Z"}, "message": "Revert source_analyzer changes", "tree": {"sha": "0ba873746a579ea02e15b459d25b38d612b560f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ba873746a579ea02e15b459d25b38d612b560f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f65daf23dfb14677d6b23557e4356aec6fdee065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f65daf23dfb14677d6b23557e4356aec6fdee065", "html_url": "https://github.com/rust-lang/rust/commit/f65daf23dfb14677d6b23557e4356aec6fdee065", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f65daf23dfb14677d6b23557e4356aec6fdee065/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afc1d18ff3e060a4107d7a17623a5e84f6c6c86e", "url": "https://api.github.com/repos/rust-lang/rust/commits/afc1d18ff3e060a4107d7a17623a5e84f6c6c86e", "html_url": "https://github.com/rust-lang/rust/commit/afc1d18ff3e060a4107d7a17623a5e84f6c6c86e"}], "stats": {"total": 61, "additions": 6, "deletions": 55}, "files": [{"sha": "a56b8ab0426110e43fda4071115f05c3070396a5", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f65daf23dfb14677d6b23557e4356aec6fdee065/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65daf23dfb14677d6b23557e4356aec6fdee065/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=f65daf23dfb14677d6b23557e4356aec6fdee065", "patch": "@@ -696,7 +696,6 @@ impl AssocItem {\n             AssocItem::TypeAlias(t) => t.module(db),\n         }\n     }\n-\n     pub fn container(self, db: &impl DefDatabase) -> AssocItemContainer {\n         let container = match self {\n             AssocItem::Function(it) => it.id.lookup(db).container,"}, {"sha": "bb9a35c5d1224de747bca1bf29fb4d52e0bb6c0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 6, "deletions": 54, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f65daf23dfb14677d6b23557e4356aec6fdee065/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65daf23dfb14677d6b23557e4356aec6fdee065/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=f65daf23dfb14677d6b23557e4356aec6fdee065", "patch": "@@ -20,19 +20,16 @@ use hir_def::{\n use hir_expand::{\n     hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n-use hir_ty::{\n-    method_resolution::{iterate_method_candidates, LookupMode},\n-    Canonical, InEnvironment, InferenceResult, TraitEnvironment,\n-};\n+use hir_ty::{InEnvironment, InferenceResult, TraitEnvironment};\n use ra_syntax::{\n     ast::{self, AstNode},\n     AstPtr, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextRange, TextUnit,\n };\n use rustc_hash::FxHashSet;\n \n use crate::{\n-    db::HirDatabase, Adt, AssocItem, Const, DefWithBody, EnumVariant, Function, Local, MacroDef,\n-    ModuleDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n+    db::HirDatabase, Adt, Const, DefWithBody, EnumVariant, Function, Local, MacroDef, Name, Path,\n+    ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n@@ -292,11 +289,9 @@ impl SourceAnalyzer {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n         if let Some(path_expr) = path.syntax().parent().and_then(ast::PathExpr::cast) {\n-            let path_resolution = self\n-                .resolve_as_full_path(path_expr.clone())\n-                .or_else(|| self.resolve_as_path_to_method(db, &path_expr));\n-            if path_resolution.is_some() {\n-                return path_resolution;\n+            let expr_id = self.expr_id(&path_expr.into())?;\n+            if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_expr(expr_id) {\n+                return Some(PathResolution::AssocItem(assoc.into()));\n             }\n         }\n         if let Some(path_pat) = path.syntax().parent().and_then(ast::PathPat::cast) {\n@@ -310,49 +305,6 @@ impl SourceAnalyzer {\n         self.resolve_hir_path(db, &hir_path)\n     }\n \n-    fn resolve_as_full_path(&self, path_expr: ast::PathExpr) -> Option<PathResolution> {\n-        let expr_id = self.expr_id(&path_expr.into())?;\n-        self.infer\n-            .as_ref()?\n-            .assoc_resolutions_for_expr(expr_id)\n-            .map(|assoc| PathResolution::AssocItem(assoc.into()))\n-    }\n-\n-    fn resolve_as_path_to_method(\n-        &self,\n-        db: &impl HirDatabase,\n-        path_expr: &ast::PathExpr,\n-    ) -> Option<PathResolution> {\n-        let full_path = path_expr.path()?;\n-        let path_to_method = full_path.qualifier()?;\n-        let method_name = full_path.segment()?.syntax().to_string();\n-        match self.resolve_path(db, &path_to_method)? {\n-            PathResolution::Def(ModuleDef::Adt(adt)) => {\n-                let ty = adt.ty(db);\n-                iterate_method_candidates(\n-                    &Canonical { value: ty.ty.value, num_vars: 0 },\n-                    db,\n-                    ty.ty.environment,\n-                    self.resolver.krate()?,\n-                    &self.resolver.traits_in_scope(db),\n-                    None,\n-                    LookupMode::Path,\n-                    |_, assoc_item_id| {\n-                        let assoc = assoc_item_id.into();\n-                        if let AssocItem::Function(function) = assoc {\n-                            if function.name(db).to_string() == method_name {\n-                                return Some(assoc);\n-                            }\n-                        }\n-                        None\n-                    },\n-                )\n-            }\n-            _ => None,\n-        }\n-        .map(PathResolution::AssocItem)\n-    }\n-\n     fn resolve_local_name(&self, name_ref: &ast::NameRef) -> Option<ScopeEntryWithSyntax> {\n         let name = name_ref.as_name();\n         let source_map = self.body_source_map.as_ref()?;"}]}