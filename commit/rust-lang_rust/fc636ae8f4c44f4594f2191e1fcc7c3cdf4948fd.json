{"sha": "fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNjM2YWU4ZjRjNDRmNDU5NGYyMTkxZTFmY2M3YzNjZGY0OTQ4ZmQ=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-07-15T23:39:32Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2014-09-02T13:59:07Z"}, "message": "std: Split hashmap.rs into modules", "tree": {"sha": "fab3234075a15d5a3e92f017ab10f185eb52ddd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fab3234075a15d5a3e92f017ab10f185eb52ddd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "html_url": "https://github.com/rust-lang/rust/commit/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650", "html_url": "https://github.com/rust-lang/rust/commit/9ddaaa4db02ec79f30e51c3e4f32baec8b0bb650"}], "stats": {"total": 5207, "additions": 2645, "deletions": 2562}, "files": [{"sha": "66d97ba044847c20735d8f4e9dff128313b71f15", "filename": "src/libstd/collections/hashmap/bench.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fbench.rs?ref=fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(test)]\n+\n+extern crate test;\n+use prelude::*;\n+\n+use self::test::Bencher;\n+use iter::{range_inclusive};\n+\n+#[bench]\n+fn new_drop(b : &mut Bencher) {\n+    use super::HashMap;\n+\n+    b.iter(|| {\n+        let m : HashMap<int, int> = HashMap::new();\n+        assert_eq!(m.len(), 0);\n+    })\n+}\n+\n+#[bench]\n+fn new_insert_drop(b : &mut Bencher) {\n+    use super::HashMap;\n+\n+    b.iter(|| {\n+        let mut m = HashMap::new();\n+        m.insert(0i, 0i);\n+        assert_eq!(m.len(), 1);\n+    })\n+}\n+\n+#[bench]\n+fn insert(b: &mut Bencher) {\n+    use super::HashMap;\n+\n+    let mut m = HashMap::new();\n+\n+    for i in range_inclusive(1i, 1000) {\n+        m.insert(i, i);\n+    }\n+\n+    let mut k = 1001;\n+\n+    b.iter(|| {\n+        m.insert(k, k);\n+        k += 1;\n+    });\n+}\n+\n+#[bench]\n+fn find_existing(b: &mut Bencher) {\n+    use super::HashMap;\n+\n+    let mut m = HashMap::new();\n+\n+    for i in range_inclusive(1i, 1000) {\n+        m.insert(i, i);\n+    }\n+\n+    b.iter(|| {\n+        for i in range_inclusive(1i, 1000) {\n+            m.contains_key(&i);\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn find_nonexisting(b: &mut Bencher) {\n+    use super::HashMap;\n+\n+    let mut m = HashMap::new();\n+\n+    for i in range_inclusive(1i, 1000) {\n+        m.insert(i, i);\n+    }\n+\n+    b.iter(|| {\n+        for i in range_inclusive(1001i, 2000) {\n+            m.contains_key(&i);\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn hashmap_as_queue(b: &mut Bencher) {\n+    use super::HashMap;\n+\n+    let mut m = HashMap::new();\n+\n+    for i in range_inclusive(1i, 1000) {\n+        m.insert(i, i);\n+    }\n+\n+    let mut k = 1i;\n+\n+    b.iter(|| {\n+        m.pop(&k);\n+        m.insert(k + 1000, k + 1000);\n+        k += 1;\n+    });\n+}\n+\n+#[bench]\n+fn find_pop_insert(b: &mut Bencher) {\n+    use super::HashMap;\n+\n+    let mut m = HashMap::new();\n+\n+    for i in range_inclusive(1i, 1000) {\n+        m.insert(i, i);\n+    }\n+\n+    let mut k = 1i;\n+\n+    b.iter(|| {\n+        m.find(&(k + 400));\n+        m.find(&(k + 2000));\n+        m.pop(&k);\n+        m.insert(k + 1000, k + 1000);\n+        k += 1;\n+    })\n+}"}, {"sha": "7a3779a91a080f42554c66d335e071b5ab423f65", "filename": "src/libstd/collections/hashmap/map.rs", "status": "renamed", "additions": 915, "deletions": 2562, "changes": 3477, "blob_url": "https://github.com/rust-lang/rust/blob/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmap.rs?ref=fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "previous_filename": "src/libstd/collections/hashmap.rs"}, {"sha": "f493e844526ee5c781e56030fc71aeb2d382771e", "filename": "src/libstd/collections/hashmap/mod.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fmod.rs?ref=fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unordered containers, implemented as hash-tables\n+\n+pub use self::map::HashMap;\n+pub use self::map::Entries;\n+pub use self::map::MoveEntries;\n+pub use self::map::Keys;\n+pub use self::map::Values;\n+pub use self::map::INITIAL_CAPACITY;\n+pub use self::set::HashSet;\n+pub use self::set::SetItems;\n+pub use self::set::SetMoveItems;\n+pub use self::set::SetAlgebraItems;\n+\n+mod bench;\n+mod map;\n+mod set;\n+mod table;"}, {"sha": "a1f71e333033f3c0a1d1e211247d56309b5fee56", "filename": "src/libstd/collections/hashmap/set.rs", "status": "added", "additions": 696, "deletions": 0, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Fset.rs?ref=fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "patch": "@@ -0,0 +1,696 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+use clone::Clone;\n+use cmp::{Eq, Equiv, PartialEq};\n+use collections::{Collection, Mutable, Set, MutableSet, Map, MutableMap};\n+use default::Default;\n+use fmt::Show;\n+use fmt;\n+use RandomSipHasher;\n+use hash::{Hash, Hasher};\n+use iter::{Iterator, FromIterator, FilterMap, Chain, Repeat, Zip, Extendable};\n+use iter;\n+use option::{Some, None};\n+use result::{Ok, Err};\n+\n+use super::{HashMap, Entries, MoveEntries, INITIAL_CAPACITY};\n+\n+/// HashSet iterator\n+pub type SetItems<'a, K> =\n+    iter::Map<'static, (&'a K, &'a ()), &'a K, Entries<'a, K, ()>>;\n+\n+/// HashSet move iterator\n+pub type SetMoveItems<K> =\n+    iter::Map<'static, (K, ()), K, MoveEntries<K, ()>>;\n+\n+/// An implementation of a hash set using the underlying representation of a\n+/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n+/// requires that the elements implement the `Eq` and `Hash` traits.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::HashSet;\n+/// // Type inference lets us omit an explicit type signature (which\n+/// // would be `HashSet<&str>` in this example).\n+/// let mut books = HashSet::new();\n+///\n+/// // Add some books.\n+/// books.insert(\"A Dance With Dragons\");\n+/// books.insert(\"To Kill a Mockingbird\");\n+/// books.insert(\"The Odyssey\");\n+/// books.insert(\"The Great Gatsby\");\n+///\n+/// // Check for a specific one.\n+/// if !books.contains(&(\"The Winds of Winter\")) {\n+///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n+///              books.len());\n+/// }\n+///\n+/// // Remove a book.\n+/// books.remove(&\"The Odyssey\");\n+///\n+/// // Iterate over everything.\n+/// for book in books.iter() {\n+///     println!(\"{}\", *book);\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `HashSet` with a custom type is to derive\n+/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n+/// future be implied by `Eq`.\n+///\n+/// ```\n+/// use std::collections::HashSet;\n+/// #[deriving(Hash, Eq, PartialEq, Show)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: uint,\n+/// }\n+///\n+/// let mut vikings = HashSet::new();\n+///\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9u });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4u });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8u });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for x in vikings.iter() {\n+///     println!(\"{}\", x);\n+/// }\n+/// ```\n+#[deriving(Clone)]\n+pub struct HashSet<T, H = RandomSipHasher> {\n+    map: HashMap<T, (), H>\n+}\n+\n+impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n+    /// Create an empty HashSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// ```\n+    #[inline]\n+    pub fn new() -> HashSet<T, RandomSipHasher> {\n+        HashSet::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty HashSet with space for at least `n` elements in\n+    /// the hash table.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n+    /// ```\n+    #[inline]\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n+        HashSet { map: HashMap::with_capacity(capacity) }\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+    /// Creates a new empty hash set which will use the given hasher to hash\n+    /// keys.\n+    ///\n+    /// The hash set is also created with the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_hasher(h);\n+    /// set.insert(2u);\n+    /// ```\n+    #[inline]\n+    pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n+        HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n+    }\n+\n+    /// Create an empty HashSet with space for at least `capacity`\n+    /// elements in the hash table, using `hasher` to hash the keys.\n+    ///\n+    /// Warning: `hasher` is normally randomly generated, and\n+    /// is designed to allow `HashSet`s to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::hash::sip::SipHasher;\n+    ///\n+    /// let h = SipHasher::new();\n+    /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n+    /// set.insert(1i);\n+    /// ```\n+    #[inline]\n+    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n+        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+    }\n+\n+    /// Reserve space for at least `n` elements in the hash table.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// set.reserve(10);\n+    /// ```\n+    pub fn reserve(&mut self, n: uint) {\n+        self.map.reserve(n)\n+    }\n+\n+    /// Returns true if the hash set contains a value equivalent to the\n+    /// given query value.\n+    ///\n+    /// # Example\n+    ///\n+    /// This is a slightly silly example where we define the number's\n+    /// parity as the equivilance class. It is important that the\n+    /// values hash the same, which is why we implement `Hash`.\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::hash::Hash;\n+    /// use std::hash::sip::SipState;\n+    ///\n+    /// #[deriving(Eq, PartialEq)]\n+    /// struct EvenOrOdd {\n+    ///     num: uint\n+    /// };\n+    ///\n+    /// impl Hash for EvenOrOdd {\n+    ///     fn hash(&self, state: &mut SipState) {\n+    ///         let parity = self.num % 2;\n+    ///         parity.hash(state);\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Equiv<EvenOrOdd> for EvenOrOdd {\n+    ///     fn equiv(&self, other: &EvenOrOdd) -> bool {\n+    ///         self.num % 2 == other.num % 2\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut set = HashSet::new();\n+    /// set.insert(EvenOrOdd { num: 3u });\n+    ///\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 3u }));\n+    /// assert!(set.contains_equiv(&EvenOrOdd { num: 5u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 4u }));\n+    /// assert!(!set.contains_equiv(&EvenOrOdd { num: 2u }));\n+    ///\n+    /// ```\n+    pub fn contains_equiv<Q: Hash<S> + Equiv<T>>(&self, value: &Q) -> bool {\n+      self.map.contains_key_equiv(value)\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// Iterator element type is &'a T.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\");\n+    /// set.insert(\"b\");\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    pub fn iter<'a>(&'a self) -> SetItems<'a, T> {\n+        self.map.keys()\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each value out\n+    /// of the set in arbitrary order. The set cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\".to_string());\n+    /// set.insert(\"b\".to_string());\n+    ///\n+    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n+    /// let v: Vec<String> = set.move_iter().collect();\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in v.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    pub fn move_iter(self) -> SetMoveItems<T> {\n+        self.map.move_iter().map(|(k, _)| k)\n+    }\n+\n+    /// Visit the values representing the difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1i].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n+        Repeat::new(other).zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if !other.contains(elt) { Some(elt) } else { None }\n+            })\n+    }\n+\n+    /// Visit the values representing the symmetric difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 4 in arbitrary order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> Chain<SetAlgebraItems<'a, T, H>, SetAlgebraItems<'a, T, H>> {\n+        self.difference(other).chain(other.difference(self))\n+    }\n+\n+    /// Visit the values representing the intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in arbitrary order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> SetAlgebraItems<'a, T, H> {\n+        Repeat::new(other).zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if other.contains(elt) { Some(elt) } else { None }\n+            })\n+    }\n+\n+    /// Visit the values representing the union.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1i, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4i, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// ```\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>)\n+        -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n+        self.iter().chain(other.difference(self))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n+    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|key| other.contains(key))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Collection for HashSet<T, H> {\n+    fn len(&self) -> uint { self.map.len() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n+    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n+\n+    fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| !other.contains(v))\n+    }\n+\n+    fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+        self.iter().all(|v| other.contains(v))\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n+    fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()) }\n+\n+    fn remove(&mut self, value: &T) -> bool { self.map.remove(value) }\n+}\n+\n+impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n+    fn from_iter<I: Iterator<T>>(iter: I) -> HashSet<T, H> {\n+        let (lower, _) = iter.size_hint();\n+        let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Extendable<T> for HashSet<T, H> {\n+    fn extend<I: Iterator<T>>(&mut self, mut iter: I) {\n+        for k in iter {\n+            self.insert(k);\n+        }\n+    }\n+}\n+\n+impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+    fn default() -> HashSet<T, H> {\n+        HashSet::with_hasher(Default::default())\n+    }\n+}\n+\n+// `Repeat` is used to feed the filter closure an explicit capture\n+// of a reference to the other set\n+/// Set operations iterator\n+pub type SetAlgebraItems<'a, T, H> =\n+    FilterMap<'static, (&'a HashSet<T, H>, &'a T), &'a T,\n+              Zip<Repeat<&'a HashSet<T, H>>, SetItems<'a, T>>>;\n+\n+#[cfg(test)]\n+mod test_set {\n+    use prelude::*;\n+\n+    use super::HashSet;\n+    use slice::ImmutablePartialEqSlice;\n+    use collections::Collection;\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = HashSet::new();\n+        let mut ys = HashSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5i));\n+        assert!(ys.insert(11i));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = HashSet::new();\n+        assert!(a.insert(0i));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = HashSet::new();\n+        assert!(b.insert(0i));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_iterate() {\n+        let mut a = HashSet::new();\n+        for i in range(0u, 32) {\n+            assert!(a.insert(i));\n+        }\n+        let mut observed: u32 = 0;\n+        for k in a.iter() {\n+            observed |= 1 << *k;\n+        }\n+        assert_eq!(observed, 0xFFFF_FFFF);\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(11i));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n+        assert!(a.insert(-5));\n+\n+        assert!(b.insert(2i));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(-9));\n+        assert!(b.insert(-42));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for x in a.intersection(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1i));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(3i));\n+        assert!(b.insert(9));\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11];\n+        for x in a.difference(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1i));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(-2i));\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+        assert!(b.insert(14));\n+        assert!(b.insert(22));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 5, 11, 14, 22];\n+        for x in a.symmetric_difference(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1i));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+        assert!(a.insert(16));\n+        assert!(a.insert(19));\n+        assert!(a.insert(24));\n+\n+        assert!(b.insert(-2i));\n+        assert!(b.insert(1));\n+        assert!(b.insert(5));\n+        assert!(b.insert(9));\n+        assert!(b.insert(13));\n+        assert!(b.insert(19));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+        for x in a.union(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [1i, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n+\n+        for x in xs.iter() {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let hs = {\n+            let mut hs = HashSet::new();\n+\n+            hs.insert('a');\n+            hs.insert('b');\n+\n+            hs\n+        };\n+\n+        let v = hs.move_iter().collect::<Vec<char>>();\n+        assert!(['a', 'b'] == v.as_slice() || ['b', 'a'] == v.as_slice());\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        // These constants once happened to expose a bug in insert().\n+        // I'm keeping them around to prevent a regression.\n+        let mut s1 = HashSet::new();\n+\n+        s1.insert(1i);\n+        s1.insert(2);\n+        s1.insert(3);\n+\n+        let mut s2 = HashSet::new();\n+\n+        s2.insert(1i);\n+        s2.insert(2);\n+\n+        assert!(s1 != s2);\n+\n+        s2.insert(3);\n+\n+        assert_eq!(s1, s2);\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set: HashSet<int> = HashSet::new();\n+        let empty: HashSet<int> = HashSet::new();\n+\n+        set.insert(1i);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{}\", set);\n+\n+        assert!(set_str == \"{1, 2}\".to_string() || set_str == \"{2, 1}\".to_string());\n+        assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n+    }\n+}"}, {"sha": "96d1a9ba2fbb534a441bb702392676fb768755ca", "filename": "src/libstd/collections/hashmap/table.rs", "status": "added", "additions": 877, "deletions": 0, "changes": 877, "blob_url": "https://github.com/rust-lang/rust/blob/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap%2Ftable.rs?ref=fc636ae8f4c44f4594f2191e1fcc7c3cdf4948fd", "patch": "@@ -0,0 +1,877 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+use clone::Clone;\n+use cmp;\n+use hash::{Hash, Hasher};\n+use iter::{Iterator, count};\n+use mem::{min_align_of, size_of};\n+use mem;\n+use num::{CheckedMul, is_power_of_two};\n+use ops::{Deref, DerefMut, Drop};\n+use option::{Some, None, Option};\n+use ptr::RawPtr;\n+use ptr::set_memory;\n+use ptr::write;\n+use ptr;\n+use rt::heap::{allocate, deallocate};\n+\n+static EMPTY_BUCKET: u64 = 0u64;\n+\n+/// The raw hashtable, providing safe-ish access to the unzipped and highly\n+/// optimized arrays of hashes, keys, and values.\n+///\n+/// This design uses less memory and is a lot faster than the naive\n+/// `Vec<Option<u64, K, V>>`, because we don't pay for the overhead of an\n+/// option on every element, and we get a generally more cache-aware design.\n+///\n+/// Key invariants of this structure:\n+///\n+///   - if hashes[i] == EMPTY_BUCKET, then keys[i] and vals[i] have\n+///     'undefined' contents. Don't read from them. This invariant is\n+///     enforced outside this module with the `EmptyIndex`, `FullIndex`,\n+///     and `SafeHash` types.\n+///\n+///   - An `EmptyIndex` is only constructed for a bucket at an index with\n+///     a hash of EMPTY_BUCKET.\n+///\n+///   - A `FullIndex` is only constructed for a bucket at an index with a\n+///     non-EMPTY_BUCKET hash.\n+///\n+///   - A `SafeHash` is only constructed for non-`EMPTY_BUCKET` hash. We get\n+///     around hashes of zero by changing them to 0x8000_0000_0000_0000,\n+///     which will likely map to the same bucket, while not being confused\n+///     with \"empty\".\n+///\n+///   - All three \"arrays represented by pointers\" are the same length:\n+///     `capacity`. This is set at creation and never changes. The arrays\n+///     are unzipped to save space (we don't have to pay for the padding\n+///     between odd sized elements, such as in a map from u64 to u8), and\n+///     be more cache aware (scanning through 8 hashes brings in 2 cache\n+///     lines, since they're all right beside each other).\n+///\n+/// You can kind of think of this module/data structure as a safe wrapper\n+/// around just the \"table\" part of the hashtable. It enforces some\n+/// invariants at the type level and employs some performance trickery,\n+/// but in general is just a tricked out `Vec<Option<u64, K, V>>`.\n+///\n+/// FIXME(cgaebel):\n+///\n+/// Feb 11, 2014: This hashtable was just implemented, and, hard as I tried,\n+/// isn't yet totally safe. There's a \"known exploit\" that you can create\n+/// multiple FullIndexes for a bucket, `take` one, and then still `take`\n+/// the other causing undefined behavior. Currently, there's no story\n+/// for how to protect against this statically. Therefore, there are asserts\n+/// on `take`, `get`, `get_mut`, and `put` which check the bucket state.\n+/// With time, and when we're confident this works correctly, they should\n+/// be removed. Also, the bounds check in `peek` is especially painful,\n+/// as that's called in the innermost loops of the hashtable and has the\n+/// potential to be a major performance drain. Remove this too.\n+///\n+/// Or, better than remove, only enable these checks for debug builds.\n+/// There's currently no \"debug-only\" asserts in rust, so if you're reading\n+/// this and going \"what? of course there are debug-only asserts!\", then\n+/// please make this use them!\n+#[unsafe_no_drop_flag]\n+pub struct RawTable<K, V> {\n+    capacity: uint,\n+    size:     uint,\n+    hashes:   *mut u64\n+}\n+\n+/// A bucket that holds a reference to the table\n+pub trait BucketWithTable<M> {\n+    /// A bucket that holds a reference to the table\n+    fn table<'a>(&'a self) -> &'a M;\n+\n+    /// Move out the reference to the table.\n+    fn into_table(self) -> M;\n+\n+    /// Get the raw index.\n+    fn index(&self) -> uint;\n+}\n+\n+struct RawBucket<K, V> {\n+    hash: *mut u64,\n+    key:  *mut K,\n+    val:  *mut V\n+}\n+\n+pub struct Bucket<K, V, M> {\n+    raw:   RawBucket<K, V>,\n+    idx:   uint,\n+    table: M\n+}\n+\n+pub struct EmptyBucket<K, V, M> {\n+    raw:   RawBucket<K, V>,\n+    idx:   uint,\n+    table: M\n+}\n+\n+pub struct FullBucket<K, V, M> {\n+    raw:   RawBucket<K, V>,\n+    idx:   uint,\n+    table: M\n+}\n+\n+pub type EmptyBucketImm<'table,K,V> = EmptyBucket<K, V, &'table RawTable<K,V>>;\n+pub type  FullBucketImm<'table,K,V> =  FullBucket<K, V, &'table RawTable<K,V>>;\n+\n+pub type EmptyBucketMut<'table,K,V> = EmptyBucket<K, V, &'table mut RawTable<K,V>>;\n+pub type  FullBucketMut<'table,K,V> =  FullBucket<K, V, &'table mut RawTable<K,V>>;\n+\n+struct GapThenFull<K, V, M> {\n+    gap: EmptyBucket<K, V, ()>,\n+    full: FullBucket<K, V, M>\n+}\n+\n+impl<K, V, M: Deref<RawTable<K,V>>> GapThenFull<K, V, M> {\n+    pub fn full<'a>(&'a self) -> &'a FullBucket<K, V, M> {\n+        &self.full\n+    }\n+\n+    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n+        unsafe {\n+            *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n+            mem::overwrite(self.gap.raw.key, ptr::read(self.full.raw.key as *const K));\n+            mem::overwrite(self.gap.raw.val, ptr::read(self.full.raw.val as *const V));\n+        }\n+\n+        let FullBucket { raw, idx, .. } = self.full;\n+\n+        match self.full.next().peek() {\n+            Empty(_) => None,\n+            Full(bucket) => {\n+                self.gap.raw = raw;\n+                self.gap.idx = idx;\n+\n+                self.full = bucket;\n+                self.full.idx &= self.full.table.capacity - 1;\n+\n+                Some(self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<K, V> RawPtr<u64> for RawBucket<K, V> {\n+    unsafe fn offset(self, count: int) -> RawBucket<K, V> {\n+        RawBucket {\n+            hash: self.hash.offset(count),\n+            key:  self.key.offset(count),\n+            val:  self.val.offset(count),\n+        }\n+    }\n+\n+    fn null() -> RawBucket<K, V> {\n+        RawBucket {\n+            hash: RawPtr::null(),\n+            key:  RawPtr::null(),\n+            val:  RawPtr::null()\n+        }\n+    }\n+\n+    fn is_null(&self) -> bool {\n+        self.hash.is_null()\n+    }\n+\n+    fn to_uint(&self) -> uint {\n+        self.hash.to_uint()\n+    }\n+\n+    unsafe fn to_option(&self) -> Option<&u64> {\n+        self.hash.to_option()\n+    }\n+}\n+\n+impl<K, V, M: Deref<RawTable<K,V>>> EmptyBucket<K, V, M> {\n+    pub fn next(self) -> Bucket<K, V, M> {\n+        let mut bucket = self.into_bucket();\n+        bucket.next();\n+        bucket\n+    }\n+\n+    pub fn into_bucket(self) -> Bucket<K, V, M> {\n+        Bucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self.table\n+        }\n+    }\n+\n+    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> {\n+        let gap = EmptyBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: ()\n+        };\n+\n+        match self.next().peek() {\n+            Empty(_) => None,\n+            Full(bucket) => {\n+                Some(GapThenFull {\n+                    gap: gap,\n+                    full: bucket\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<K, V, M: DerefMut<RawTable<K,V>>> EmptyBucket<K, V, M> {\n+    pub fn put(mut self, hash: SafeHash, key: K, value: V)\n+               -> FullBucket<K, V, M> {\n+        unsafe {\n+            *self.raw.hash = hash.inspect();\n+            write(self.raw.key, key);\n+            write(self.raw.val, value);\n+        }\n+\n+        self.table.size += 1;\n+\n+        FullBucket { raw: self.raw, idx: self.idx, table: self.table }\n+    }\n+}\n+\n+impl<K, V, M: Deref<RawTable<K,V>>> FullBucket<K, V, M> {\n+    pub fn next(self) -> Bucket<K, V, M> {\n+        let mut bucket = self.into_bucket();\n+        bucket.next();\n+        bucket\n+    }\n+\n+    pub fn into_bucket(self) -> Bucket<K, V, M> {\n+        Bucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self.table\n+        }\n+    }\n+\n+    pub fn distance(&self) -> uint {\n+        (self.idx - self.hash().inspect() as uint) & (self.table.capacity() - 1)\n+    }\n+\n+    pub fn hash(&self) -> SafeHash {\n+        unsafe {\n+            SafeHash {\n+                hash: *self.raw.hash\n+            }\n+        }\n+    }\n+\n+    pub fn read<'a>(&'a self) -> (&'a K, &'a V) {\n+        unsafe {\n+            (&*self.raw.key,\n+             &*self.raw.val)\n+        }\n+    }\n+\n+    pub fn into_refs(self) -> (&K, &V) {\n+        unsafe {\n+            // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+            (&*self.raw.key,\n+             &*self.raw.val)\n+        }\n+    }\n+}\n+\n+impl<K, V, M: DerefMut<RawTable<K,V>>> FullBucket<K, V, M> {\n+    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) {\n+        let key = self.raw.key as *const K;\n+        let val = self.raw.val as *const V;\n+\n+        self.table.size -= 1;\n+\n+        unsafe {\n+            *self.raw.hash = EMPTY_BUCKET;\n+            (\n+                EmptyBucket {\n+                    raw: self.raw,\n+                    idx: self.idx,\n+                    table: self.table\n+                },\n+                ptr::read(key),\n+                ptr::read(val)\n+            )\n+        }\n+    }\n+\n+    pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n+        unsafe {\n+            let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n+            let old_key  = ptr::replace(self.raw.key,  k);\n+            let old_val  = ptr::replace(self.raw.val,  v);\n+\n+            (old_hash, old_key, old_val)\n+        }\n+    }\n+\n+    pub fn read_mut<'a>(&'a self) -> (&'a mut K, &'a mut V) {\n+        unsafe {\n+            // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+            (&mut *self.raw.key,\n+             &mut *self.raw.val)\n+        }\n+    }\n+\n+    pub fn into_mut_refs(self) -> (&mut K, &mut V) {\n+        unsafe {\n+            // debug_assert!(*self.raw.hash != EMPTY_BUCKET);\n+            (&mut *self.raw.key,\n+             &mut *self.raw.val)\n+        }\n+    }\n+}\n+\n+impl<K, V, M: Deref<RawTable<K,V>>> Bucket<K, V, M> {\n+    pub fn new(table: M, hash: &SafeHash) -> Bucket<K, V, M> {\n+        let ib_index = (hash.inspect() as uint) & (table.capacity() - 1);\n+        Bucket {\n+            raw: unsafe {\n+               table.as_mut_ptrs().offset(ib_index as int)\n+            },\n+            idx: ib_index,\n+            table: table\n+        }\n+    }\n+\n+    pub fn at_index(table: M, ib_index: uint) -> Bucket<K, V, M> {\n+        let ib_index = ib_index & (table.capacity() - 1);\n+        Bucket {\n+            raw: unsafe {\n+               table.as_mut_ptrs().offset(ib_index as int)\n+            },\n+            idx: ib_index,\n+            table: table\n+        }\n+    }\n+\n+    pub fn first(table: M) -> Bucket<K, V, M> {\n+        Bucket {\n+            raw: table.as_mut_ptrs(),\n+            idx: 0,\n+            table: table\n+        }\n+    }\n+\n+    pub fn peek(self) -> BucketState<K, V, M> {\n+        match unsafe { *self.raw.hash } {\n+            EMPTY_BUCKET =>\n+                Empty(EmptyBucket {\n+                    raw: self.raw,\n+                    idx: self.idx,\n+                    table: self.table\n+                }),\n+            _ =>\n+                Full(FullBucket {\n+                    raw: self.raw,\n+                    idx: self.idx,\n+                    table: self.table\n+                })\n+        }\n+    }\n+\n+    pub fn next(&mut self) {\n+        self.idx += 1;\n+\n+        let dist = if self.idx == self.table.capacity() {\n+            -(self.table.capacity() as int - 1)\n+        } else {\n+            1i\n+        };\n+\n+        unsafe {\n+            self.raw = self.raw.offset(dist);\n+        }\n+    }\n+}\n+\n+impl<K, V, M> BucketWithTable<M> for FullBucket<K, V, M> {\n+    fn table<'a>(&'a self) -> &'a M {\n+        &self.table\n+    }\n+\n+    fn into_table(self) -> M {\n+        self.table\n+    }\n+\n+    fn index(&self) -> uint {\n+        self.idx\n+    }\n+}\n+\n+impl<K, V, M> BucketWithTable<M> for EmptyBucket<K, V, M> {\n+    fn table<'a>(&'a self) -> &'a M {\n+        &self.table\n+    }\n+\n+    fn into_table(self) -> M {\n+        self.table\n+    }\n+\n+    fn index(&self) -> uint {\n+        self.idx\n+    }\n+}\n+\n+impl<K, V, M> BucketWithTable<M> for Bucket<K, V, M> {\n+    fn table<'a>(&'a self) -> &'a M {\n+        &self.table\n+    }\n+\n+    fn into_table(self) -> M {\n+        self.table\n+    }\n+\n+    fn index(&self) -> uint {\n+        self.idx\n+    }\n+}\n+\n+impl<'table,K,V> Deref<RawTable<K,V>> for &'table RawTable<K,V> {\n+    fn deref<'a>(&'a self) -> &'a RawTable<K,V> {\n+        &**self\n+    }\n+}\n+\n+impl<'table,K,V> Deref<RawTable<K,V>> for &'table mut RawTable<K,V> {\n+    fn deref<'a>(&'a self) -> &'a RawTable<K,V> {\n+        &**self\n+    }\n+}\n+\n+impl<'table,K,V> DerefMut<RawTable<K,V>> for &'table mut RawTable<K,V> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut RawTable<K,V> {\n+        &mut **self\n+    }\n+}\n+\n+pub enum BucketState<K, V, M> {\n+    Empty(EmptyBucket<K, V, M>),\n+    Full(FullBucket<K, V, M>),\n+}\n+\n+/// A hash that is not zero, since we use a hash of zero to represent empty\n+/// buckets.\n+#[deriving(PartialEq)]\n+pub struct SafeHash {\n+    hash: u64,\n+}\n+\n+impl SafeHash {\n+    /// Peek at the hash value, which is guaranteed to be non-zero.\n+    #[inline(always)]\n+    pub fn inspect(&self) -> u64 { self.hash }\n+}\n+\n+/// We need to remove hashes of 0. That's reserved for empty buckets.\n+/// This function wraps up `hash_keyed` to be the only way outside this\n+/// module to generate a SafeHash.\n+pub fn make_hash<T: Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+    match hasher.hash(t) {\n+        // This constant is exceedingly likely to hash to the same\n+        // bucket, but it won't be counted as empty!\n+        EMPTY_BUCKET => SafeHash { hash: 0x8000_0000_0000_0000 },\n+        h            => SafeHash { hash: h },\n+    }\n+}\n+\n+fn round_up_to_next(unrounded: uint, target_alignment: uint) -> uint {\n+    assert!(is_power_of_two(target_alignment));\n+    (unrounded + target_alignment - 1) & !(target_alignment - 1)\n+}\n+\n+#[test]\n+fn test_rounding() {\n+    assert_eq!(round_up_to_next(0, 4), 0);\n+    assert_eq!(round_up_to_next(1, 4), 4);\n+    assert_eq!(round_up_to_next(2, 4), 4);\n+    assert_eq!(round_up_to_next(3, 4), 4);\n+    assert_eq!(round_up_to_next(4, 4), 4);\n+    assert_eq!(round_up_to_next(5, 4), 8);\n+}\n+\n+// Returns a tuple of (minimum required malloc alignment, hash_offset,\n+// key_offset, val_offset, array_size), from the start of a mallocated array.\n+fn calculate_offsets(\n+    hash_size: uint, hash_align: uint,\n+    keys_size: uint, keys_align: uint,\n+    vals_size: uint, vals_align: uint) -> (uint, uint, uint, uint, uint) {\n+\n+    let hash_offset   = 0;\n+    let end_of_hashes = hash_offset + hash_size;\n+\n+    let keys_offset   = round_up_to_next(end_of_hashes, keys_align);\n+    let end_of_keys   = keys_offset + keys_size;\n+\n+    let vals_offset   = round_up_to_next(end_of_keys, vals_align);\n+    let end_of_vals   = vals_offset + vals_size;\n+\n+    let min_align = cmp::max(hash_align, cmp::max(keys_align, vals_align));\n+\n+    (min_align, hash_offset, keys_offset, vals_offset, end_of_vals)\n+}\n+\n+#[test]\n+fn test_offset_calculation() {\n+    assert_eq!(calculate_offsets(128, 8, 15, 1, 4, 4 ), (8, 0, 128, 144, 148));\n+    assert_eq!(calculate_offsets(3,   1, 2,  1, 1, 1 ), (1, 0, 3,   5,   6));\n+    assert_eq!(calculate_offsets(6,   2, 12, 4, 24, 8), (8, 0, 8,   24,  48));\n+}\n+\n+impl<K, V> RawTable<K, V> {\n+\n+    /// Does not initialize the buckets. The caller should ensure they,\n+    /// at the very least, set every hash to EMPTY_BUCKET.\n+    unsafe fn new_uninitialized(capacity: uint) -> RawTable<K, V> {\n+        if capacity == 0 {\n+            return RawTable {\n+                size: 0,\n+                capacity: 0,\n+                hashes: 0 as *mut u64,\n+            };\n+        }\n+        let hashes_size = capacity.checked_mul(&size_of::<u64>())\n+                                  .expect(\"capacity overflow\");\n+        let keys_size = capacity.checked_mul(&size_of::< K >())\n+                                .expect(\"capacity overflow\");\n+        let vals_size = capacity.checked_mul(&size_of::< V >())\n+                                .expect(\"capacity overflow\");\n+\n+        // Allocating hashmaps is a little tricky. We need to allocate three\n+        // arrays, but since we know their sizes and alignments up front,\n+        // we just allocate a single array, and then have the subarrays\n+        // point into it.\n+        //\n+        // This is great in theory, but in practice getting the alignment\n+        // right is a little subtle. Therefore, calculating offsets has been\n+        // factored out into a different function.\n+        let (malloc_alignment, hash_offset, _, _, size) =\n+            calculate_offsets(\n+                hashes_size, min_align_of::<u64>(),\n+                keys_size,   min_align_of::< K >(),\n+                vals_size,   min_align_of::< V >());\n+\n+        let buffer = allocate(size, malloc_alignment);\n+\n+        let hashes = buffer.offset(hash_offset as int) as *mut u64;\n+\n+        RawTable {\n+            capacity: capacity,\n+            size:     0,\n+            hashes:   hashes,\n+        }\n+    }\n+\n+    fn as_mut_ptrs(&self) -> RawBucket<K, V> {\n+        let hashes_size = self.capacity * size_of::<u64>();\n+        let keys_size = self.capacity * size_of::<K>();\n+\n+        let keys_offset = (hashes_size + min_align_of::< K >() - 1) & !(min_align_of::< K >() - 1);\n+        let end_of_keys = keys_offset + keys_size;\n+\n+        let vals_offset = (end_of_keys + min_align_of::< V >() - 1) & !(min_align_of::< V >() - 1);\n+\n+        let buffer = self.hashes as *mut u8;\n+\n+        unsafe {\n+            RawBucket {\n+                hash: self.hashes,\n+                key:  buffer.offset(keys_offset as int) as *mut K,\n+                val:  buffer.offset(vals_offset as int) as *mut V\n+            }\n+        }\n+    }\n+\n+    /// Creates a new raw table from a given capacity. All buckets are\n+    /// initially empty.\n+    #[allow(experimental)]\n+    pub fn new(capacity: uint) -> RawTable<K, V> {\n+        unsafe {\n+            let ret = RawTable::new_uninitialized(capacity);\n+            set_memory(ret.hashes, 0u8, capacity);\n+            ret\n+        }\n+    }\n+\n+    /// The hashtable's capacity, similar to a vector's.\n+    pub fn capacity(&self) -> uint {\n+        self.capacity\n+    }\n+\n+    /// The number of elements ever `put` in the hashtable, minus the number\n+    /// of elements ever `take`n.\n+    pub fn size(&self) -> uint {\n+        self.size\n+    }\n+\n+    fn ptrs<'a>(&'a self) -> RawBuckets<'a, K, V> {\n+        RawBuckets {\n+            raw: self.as_mut_ptrs(),\n+            hashes_end: unsafe {\n+                self.hashes.offset(self.capacity as int)\n+            }\n+        }\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n+        Entries {\n+            iter: self.ptrs(),\n+            elems_left: self.size(),\n+        }\n+    }\n+\n+    pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n+        MutEntries {\n+            iter: self.ptrs(),\n+            elems_left: self.size(),\n+        }\n+    }\n+\n+    pub fn move_iter(self) -> MoveEntries<K, V> {\n+        MoveEntries {\n+            iter: self.ptrs(),\n+            table: self,\n+        }\n+    }\n+\n+    pub fn rev_move_buckets<'a>(&'a mut self) -> RevMoveBuckets<'a, K, V> {\n+        let raw_bucket = self.as_mut_ptrs();\n+        unsafe {\n+            RevMoveBuckets {\n+                raw: raw_bucket.offset(self.capacity as int),\n+                hashes_end: raw_bucket.hash,\n+                elems_left: self.size\n+            }\n+        }\n+    }\n+}\n+\n+pub struct RawBuckets<'a, K, V> {\n+    raw: RawBucket<K, V>,\n+    hashes_end: *mut u64\n+}\n+\n+impl<'a, K, V> Iterator<RawBucket<K, V>> for RawBuckets<'a, K, V> {\n+    fn next(&mut self) -> Option<RawBucket<K, V>> {\n+        while self.raw.hash != self.hashes_end {\n+            unsafe {\n+                let prev = ptr::replace(&mut self.raw, self.raw.offset(1));\n+                if *prev.hash != EMPTY_BUCKET {\n+                    return Some(prev);\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub struct RevMoveBuckets<'a, K, V> {\n+    raw: RawBucket<K, V>,\n+    hashes_end: *mut u64,\n+    elems_left: uint\n+}\n+\n+impl<'a, K, V> Iterator<(K, V)> for RevMoveBuckets<'a, K, V> {\n+    fn next(&mut self) -> Option<(K, V)> {\n+        if self.elems_left == 0 {\n+            return None;\n+        }\n+\n+        loop {\n+            debug_assert!(self.raw.hash != self.hashes_end);\n+\n+            unsafe {\n+                self.raw = self.raw.offset(-1);\n+\n+                if *self.raw.hash != EMPTY_BUCKET {\n+                    self.elems_left -= 1;\n+                    return Some((\n+                        ptr::read(self.raw.key as *const K),\n+                        ptr::read(self.raw.val as *const V)\n+                    ));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// `read_all_mut` casts a `*u64` to a `*SafeHash`. Since we statically\n+// ensure that a `FullIndex` points to an index with a non-zero hash,\n+// and a `SafeHash` is just a `u64` with a different name, this is\n+// safe.\n+//\n+// This test ensures that a `SafeHash` really IS the same size as a\n+// `u64`. If you need to change the size of `SafeHash` (and\n+// consequently made this test fail), `read_all_mut` needs to be\n+// modified to no longer assume this.\n+#[test]\n+fn can_alias_safehash_as_u64() {\n+    assert_eq!(size_of::<SafeHash>(), size_of::<u64>())\n+}\n+\n+/// Note: stage0-specific version that lacks bound.\n+#[cfg(stage0)]\n+pub struct Entries<'a, K, V> {\n+    iter: RawBuckets<'a, K, V>,\n+    elems_left: uint,\n+}\n+\n+/// Iterator over shared references to entries in a table.\n+#[cfg(not(stage0))]\n+pub struct Entries<'a, K: 'a, V: 'a> {\n+    iter: RawBuckets<'a, K, V>,\n+    elems_left: uint,\n+}\n+\n+/// Note: stage0-specific version that lacks bound.\n+#[cfg(stage0)]\n+pub struct MutEntries<'a, K, V> {\n+    iter: RawBuckets<'a, K, V>,\n+    elems_left: uint,\n+}\n+\n+/// Iterator over mutable references to entries in a table.\n+#[cfg(not(stage0))]\n+pub struct MutEntries<'a, K: 'a, V: 'a> {\n+    iter: RawBuckets<'a, K, V>,\n+    elems_left: uint,\n+}\n+\n+/// Iterator over the entries in a table, consuming the table.\n+pub struct MoveEntries<K, V> {\n+    table: RawTable<K, V>,\n+    iter: RawBuckets<'static, K, V>\n+}\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n+        self.iter.next().map(|bucket| {\n+            self.elems_left -= 1;\n+            unsafe {\n+                (&*bucket.key,\n+                 &*bucket.val)\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.elems_left, Some(self.elems_left))\n+    }\n+}\n+\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for MutEntries<'a, K, V> {\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.iter.next().map(|bucket| {\n+            self.elems_left -= 1;\n+            unsafe {\n+                (&*bucket.key,\n+                 &mut *bucket.val)\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (self.elems_left, Some(self.elems_left))\n+    }\n+}\n+\n+impl<K, V> Iterator<(SafeHash, K, V)> for MoveEntries<K, V> {\n+    fn next(&mut self) -> Option<(SafeHash, K, V)> {\n+        self.iter.next().map(|bucket| {\n+            self.table.size -= 1;\n+            unsafe {\n+                (\n+                    SafeHash {\n+                        hash: *bucket.hash,\n+                    },\n+                    ptr::read(bucket.key as *const K),\n+                    ptr::read(bucket.val as *const V)\n+                )\n+            }\n+        })\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let size = self.table.size();\n+        (size, Some(size))\n+    }\n+}\n+\n+impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n+    fn clone(&self) -> RawTable<K, V> {\n+        unsafe {\n+            let mut new_ht = RawTable::new_uninitialized(self.capacity());\n+\n+            {\n+                let cap = self.capacity();\n+                let mut new_buckets = Bucket::first(&mut new_ht);\n+                let mut buckets = Bucket::first(self);\n+                while buckets.index() != cap {\n+                    match buckets.peek() {\n+                        Full(full) => {\n+                            let (h, k, v) = {\n+                                let (k, v) = full.read();\n+                                (full.hash(), k.clone(), v.clone())\n+                            };\n+                            *new_buckets.raw.hash = h.inspect();\n+                            mem::overwrite(new_buckets.raw.key, k);\n+                            mem::overwrite(new_buckets.raw.val, v);\n+                        }\n+                        _  => {\n+                            *new_buckets.raw.hash = EMPTY_BUCKET;\n+                        }\n+                    }\n+                    new_buckets.next();\n+                    buckets.next();\n+                }\n+            }\n+\n+            new_ht.size = self.size();\n+\n+            new_ht\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for RawTable<K, V> {\n+    fn drop(&mut self) {\n+        if self.hashes.is_null() {\n+            return;\n+        }\n+        // This is in reverse because we're likely to have partially taken\n+        // some elements out with `.move_iter()` from the front.\n+        // Check if the size is 0, so we don't do a useless scan when\n+        // dropping empty tables such as on resize.\n+        // Avoid double free of elements already moved out.\n+        for _ in self.rev_move_buckets() {}\n+\n+        let hashes_size = self.capacity * size_of::<u64>();\n+        let keys_size = self.capacity * size_of::<K>();\n+        let vals_size = self.capacity * size_of::<V>();\n+        let (align, _, _, _, size) = calculate_offsets(hashes_size, min_align_of::<u64>(),\n+                                                       keys_size, min_align_of::<K>(),\n+                                                       vals_size, min_align_of::<V>());\n+\n+        unsafe {\n+            deallocate(self.hashes as *mut u8, size, align);\n+            // Remember how everything was allocated out of one buffer\n+            // during initialization? We only need one call to free here.\n+        }\n+\n+        self.hashes = RawPtr::null();\n+    }\n+}"}]}