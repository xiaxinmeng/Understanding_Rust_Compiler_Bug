{"sha": "c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYzk5NDYzNzIwZTc1OGQ1YWEwYmRjZWExOWRjNWIzZGQ2NzI5MmM=", "commit": {"author": {"name": "Joseph Crail", "email": "jbcrail@gmail.com", "date": "2014-06-09T04:00:52Z"}, "committer": {"name": "Joseph Crail", "email": "jbcrail@gmail.com", "date": "2014-06-10T15:24:17Z"}, "message": "Fix more misspelled comments and strings.", "tree": {"sha": "b6744e6d280594324f1f22fe8b76ccd03f7eedb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6744e6d280594324f1f22fe8b76ccd03f7eedb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "html_url": "https://github.com/rust-lang/rust/commit/c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/comments", "author": {"login": "jbcrail", "id": 6038, "node_id": "MDQ6VXNlcjYwMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/6038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbcrail", "html_url": "https://github.com/jbcrail", "followers_url": "https://api.github.com/users/jbcrail/followers", "following_url": "https://api.github.com/users/jbcrail/following{/other_user}", "gists_url": "https://api.github.com/users/jbcrail/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbcrail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbcrail/subscriptions", "organizations_url": "https://api.github.com/users/jbcrail/orgs", "repos_url": "https://api.github.com/users/jbcrail/repos", "events_url": "https://api.github.com/users/jbcrail/events{/privacy}", "received_events_url": "https://api.github.com/users/jbcrail/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbcrail", "id": 6038, "node_id": "MDQ6VXNlcjYwMzg=", "avatar_url": "https://avatars.githubusercontent.com/u/6038?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbcrail", "html_url": "https://github.com/jbcrail", "followers_url": "https://api.github.com/users/jbcrail/followers", "following_url": "https://api.github.com/users/jbcrail/following{/other_user}", "gists_url": "https://api.github.com/users/jbcrail/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbcrail/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbcrail/subscriptions", "organizations_url": "https://api.github.com/users/jbcrail/orgs", "repos_url": "https://api.github.com/users/jbcrail/repos", "events_url": "https://api.github.com/users/jbcrail/events{/privacy}", "received_events_url": "https://api.github.com/users/jbcrail/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ee6a8e8a564ec0134ebdc0869fab5e4bb28024c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee6a8e8a564ec0134ebdc0869fab5e4bb28024c", "html_url": "https://github.com/rust-lang/rust/commit/0ee6a8e8a564ec0134ebdc0869fab5e4bb28024c"}], "stats": {"total": 128, "additions": 64, "deletions": 64}, "files": [{"sha": "5f285010998c8054c9cea0f1c4d5103d6e0dd9c3", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -184,7 +184,7 @@ impl<T: Share + Send> Drop for Arc<T> {\n \n         // This fence is needed to prevent reordering of use of the data and\n         // deletion of the data. Because it is marked `Release`, the\n-        // decreasing of the reference count sychronizes with this `Acquire`\n+        // decreasing of the reference count synchronizes with this `Acquire`\n         // fence. This means that use of the data happens before decreasing\n         // the refernce count, which happens before this fence, which\n         // happens before the deletion of the data."}, {"sha": "91fd183d8c3ac76c03403bc684773d4405e2b67f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -539,7 +539,7 @@ impl<'a> Formatter<'a> {\n     }\n \n     /// Runs a callback, emitting the correct padding either before or\n-    /// afterwards depending on whether right or left alingment is requested.\n+    /// afterwards depending on whether right or left alignment is requested.\n     fn with_padding(&mut self,\n                     padding: uint,\n                     default: rt::Alignment,"}, {"sha": "180addfebcfe04f9d1b5525418c91cf306ecf129", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -105,7 +105,7 @@\n //! *Note: The actual definition of `Writer` uses `IoResult`, which\n //! is just a synonym for `Result<T, IoError>`.*\n //!\n-//! This method doesn`t produce a value, but the write may\n+//! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n //! something like this:\n //!"}, {"sha": "eb9c86f00147980ba5f65ee8d420c21505575652", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -163,7 +163,7 @@ pub struct OptGroup {\n     pub occur: Occur\n }\n \n-/// Describes wether an option is given at all or has a value.\n+/// Describes whether an option is given at all or has a value.\n #[deriving(Clone, PartialEq)]\n enum Optval {\n     Val(String),"}, {"sha": "9c7ad18454344a4234561f7551ed42612acbc6b6", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -226,7 +226,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n     regs[RUSTRT_R14] = procedure.env as uint;\n     regs[RUSTRT_R15] = fptr as uint;\n \n-    // These registers are picked up by the regulard context switch paths. These\n+    // These registers are picked up by the regular context switch paths. These\n     // will put us in \"mostly the right context\" except for frobbing all the\n     // arguments to the right place. We have the small trampoline code inside of\n     // rust_bootstrap_green_task to do that."}, {"sha": "1e8f774ea16832d7e6e8c5aace2797d304ac9998", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -82,7 +82,7 @@ pub struct Scheduler {\n     run_anything: bool,\n     /// A fast XorShift rng for scheduler use\n     rng: XorShiftRng,\n-    /// A togglable idle callback\n+    /// A toggleable idle callback\n     idle_callback: Option<Box<PausableIdleCallback:Send>>,\n     /// A countdown that starts at a random value and is decremented\n     /// every time a yield check is performed. When it hits 0 a task\n@@ -287,7 +287,7 @@ impl Scheduler {\n \n         // After processing a message, we consider doing some more work on the\n         // event loop. The \"keep going\" condition changes after the first\n-        // iteration becase we don't want to spin here infinitely.\n+        // iteration because we don't want to spin here infinitely.\n         //\n         // Once we start doing work we can keep doing work so long as the\n         // iteration does something. Note that we don't want to starve the"}, {"sha": "ff87b7fb0074bb2d0d08aa32d2b24ab743b8e842", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -291,7 +291,7 @@ pub use types::os::arch::extra::{mach_timebase_info};\n extern {}\n \n /// A wrapper for a nullable pointer. Don't use this except for interacting\n-/// with libc. Basically Option, but without the dependance on libstd.\n+/// with libc. Basically Option, but without the dependence on libstd.\n // If/when libprim happens, this can be removed in favor of that\n pub enum Nullable<T> {\n     Null,\n@@ -3497,7 +3497,7 @@ pub mod consts {\n \n \n pub mod funcs {\n-    // Thankfull most of c95 is universally available and does not vary by OS\n+    // Thankfully most of c95 is universally available and does not vary by OS\n     // or anything. The same is not true of POSIX.\n \n     pub mod c95 {"}, {"sha": "b097bde2ad8d0d22b2a1e42cff7e424f749d4375", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -50,7 +50,7 @@\n //! it sounded like named pipes just weren't built for this kind of interaction,\n //! and the suggested solution was to use overlapped I/O.\n //!\n-//! I don't realy know what overlapped I/O is, but my basic understanding after\n+//! I don't really know what overlapped I/O is, but my basic understanding after\n //! reading about it is that you have an external Event which is used to signal\n //! I/O completion, passed around in some OVERLAPPED structures. As to what this\n //! is, I'm not exactly sure."}, {"sha": "d8486cb9f0942c64cf7b101affebf09f7bb66d2d", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -923,7 +923,7 @@ fn waitpid(pid: pid_t, deadline: u64) -> IoResult<rtio::ProcessExit> {\n     // Register a new SIGCHLD handler, returning the reading half of the\n     // self-pipe plus the old handler registered (return value of sigaction).\n     //\n-    // Be sure to set up the self-pipe first because as soon as we reigster a\n+    // Be sure to set up the self-pipe first because as soon as we register a\n     // handler we're going to start receiving signals.\n     fn register_sigchld() -> (libc::c_int, c::sigaction) {\n         unsafe {"}, {"sha": "b073c2c7fbf026f8ecfe52b3a1065279315c3bb7", "filename": "src/libnative/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -166,7 +166,7 @@ impl rt::Runtime for Ops {\n     //\n     // On a mildly unrelated note, it should also be pointed out that OS\n     // condition variables are susceptible to spurious wakeups, which we need to\n-    // be ready for. In order to accomodate for this fact, we have an extra\n+    // be ready for. In order to accommodate for this fact, we have an extra\n     // `awoken` field which indicates whether we were actually woken up via some\n     // invocation of `reawaken`. This flag is only ever accessed inside the\n     // lock, so there's no need to make it atomic."}, {"sha": "ea472abeee690271b4ed6a12d582d81f633f81f9", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -34,7 +34,7 @@ pub enum Inst {\n \n     // The CharClass instruction tries to match one input character against\n     // the range of characters given.\n-    // The flags indicate whether to do a case insentivie match and whether\n+    // The flags indicate whether to do a case insensitive match and whether\n     // the character class is negated or not.\n     CharClass(Vec<(char, char)>, Flags),\n \n@@ -48,7 +48,7 @@ pub enum Inst {\n     EmptyBegin(Flags),\n \n     // Matches the end of the string, consumes no characters.\n-    // The flags indicate whether it matches if the proceding character\n+    // The flags indicate whether it matches if the proceeding character\n     // is a new line.\n     EmptyEnd(Flags),\n "}, {"sha": "59f53986af9fc8662cb1e25ed3942190d5408bd0", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -189,7 +189,7 @@ fn describe_codegen_flags() {\n     }\n }\n \n-/// Process command line options. Emits messages as appropirate.If compilation\n+/// Process command line options. Emits messages as appropriate. If compilation\n /// should continue, returns a getopts::Matches object parsed from args, otherwise\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {"}, {"sha": "2427df463bfe438751a5f9e904fc6a1e5ac35c02", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -551,7 +551,7 @@ are computed based on the kind of borrow:\n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n (`CLAIM`), and immutable borrows (`FREEZE`). An immutable borrow\n-permits other immutable borrows but forbids writes and mutable borows.\n+permits other immutable borrows but forbids writes and mutable borrows.\n Finally, a const borrow just wants to be sure that the value is not\n moved out from under it, so no actions are forbidden.\n "}, {"sha": "dbf8a1b0be8a3a5dea87117f9a0035006e7f3b8d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -438,7 +438,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                     None => {\n                         self.tcx().sess.span_bug(\n                             callee.span,\n-                            format!(\"unxpected callee type {}\",\n+                            format!(\"unexpected callee type {}\",\n                                     callee_ty.repr(self.tcx())).as_slice());\n                     }\n                 }"}, {"sha": "e3a89fe2525d2a8ed4587f6e3b7bd9f416499d66", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -257,7 +257,7 @@ impl<N,E> Graph<N,E> {\n     //\n     // A common use for graphs in our compiler is to perform\n     // fixed-point iteration. In this case, each edge represents a\n-    // constaint, and the nodes themselves are associated with\n+    // constraint, and the nodes themselves are associated with\n     // variables or other bitsets. This method facilitates such a\n     // computation.\n "}, {"sha": "27a0f0022fd1ca82d22397c5ebaac075796963b1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -31,7 +31,7 @@\n  * is the address of the lvalue.  If Expr is an rvalue, this is the address of\n  * some temporary spot in memory where the result is stored.\n  *\n- * Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n+ * Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n  * as follows:\n  *\n  * - cat: what kind of expression was this?  This is a subset of the\n@@ -42,7 +42,7 @@\n  *\n  * The resulting categorization tree differs somewhat from the expressions\n  * themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n- * decomposed into two operations: a derefence to reach the array data and\n+ * decomposed into two operations: a dereference to reach the array data and\n  * then an index to jump forward to the relevant item.\n  *\n  * ## By-reference upvars"}, {"sha": "e2974615423eb6153e718403f37703934733b201", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -39,7 +39,7 @@ The region maps encode information about region relationships.\n \n - `scope_map` maps from a scope id to the enclosing scope id; this is\n   usually corresponding to the lexical nesting, though in the case of\n-  closures the parent scope is the innermost conditinal expression or repeating\n+  closures the parent scope is the innermost conditional expression or repeating\n   block\n \n - `var_map` maps from a variable or binding id to the block in which"}, {"sha": "1b530ea34249193b3018b9e2dc66c8837295f267", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -717,7 +717,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n             assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n             // The contents of memory at this pointer can't matter, but use\n-            // the value that's \"reasonable\" in case of pointer comparision.\n+            // the value that's \"reasonable\" in case of pointer comparison.\n             PointerCast(bcx, val, ty.ptr_to())\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {"}, {"sha": "4814bf5bffcf010bb3939b581464c7f118473336", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -1571,7 +1571,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                 for var in variants.iter() {\n                     let mut size = 0;\n                     for field in var.fields.iter().skip(1) {\n-                        // skip the dicriminant\n+                        // skip the discriminant\n                         size += llsize_of_real(ccx, sizing_type_of(ccx, *field));\n                     }\n                     sizes.push(size);\n@@ -2318,7 +2318,7 @@ pub fn trans_crate(krate: ast::Crate,\n     // LLVM code generator emits a \".file filename\" directive\n     // for ELF backends. Value of the \"filename\" is set as the\n     // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n-    // crashes if the module identifer is same as other symbols\n+    // crashes if the module identifier is same as other symbols\n     // such as a function name in the module.\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let mut llmod_id = link_meta.crateid.name.clone();"}, {"sha": "df2f03a58411dce447b7b19420f5963acae2b760", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -1527,7 +1527,7 @@ impl EnumMemberDescriptionFactory {\n                 // As far as debuginfo is concerned, the pointer this enum represents is still\n                 // wrapped in a struct. This is to make the DWARF representation of enums uniform.\n \n-                // First create a description of the artifical wrapper struct:\n+                // First create a description of the artificial wrapper struct:\n                 let non_null_variant = self.variants.get(non_null_variant_index as uint);\n                 let non_null_variant_ident = non_null_variant.name;\n                 let non_null_variant_name = token::get_ident(non_null_variant_ident);"}, {"sha": "be19c2ef19953a9da32b50258738b23d80b1adba", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -204,7 +204,7 @@ impl FnStyleState {\n }\n \n /// Whether `check_binop` is part of an assignment or not.\n-/// Used to know wether we allow user overloads and to print\n+/// Used to know whether we allow user overloads and to print\n /// better messages on error.\n #[deriving(PartialEq)]\n enum IsBinopAssignment{\n@@ -3702,7 +3702,7 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n                            e: &ast::Expr,\n                            declty: ty::t) {\n     // Gather locals in statics (because of block expressions).\n-    // This is technically uneccessary because locals in static items are forbidden,\n+    // This is technically unnecessary because locals in static items are forbidden,\n     // but prevents type checking from blowing up before const checking can properly\n     // emit a error.\n     GatherLocalsVisitor { fcx: fcx }.visit_expr(e, ());\n@@ -4174,7 +4174,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n                 }\n                 None => {\n                     fcx.tcx().sess.span_bug(span,\n-                        \"missing default for a not explicitely provided type param\")\n+                        \"missing default for a not explicitly provided type param\")\n                 }\n             }\n         }"}, {"sha": "c03c7386fb3310648220bba50aa1b8902bf527b5", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -180,7 +180,7 @@ impl<'f> Coerce<'f> {\n         self.unpack_actual_value(a, |sty_a| {\n             match *sty_a {\n                 ty::ty_bare_fn(ref a_f) => {\n-                    // Bare functions are coercable to any closure type.\n+                    // Bare functions are coercible to any closure type.\n                     //\n                     // FIXME(#3320) this should go away and be\n                     // replaced with proper inference, got a patch"}, {"sha": "5099cc9c5a858c72f19c0ff0c38644fde0429e60", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -372,7 +372,7 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n \n pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n-    // This is a horible hack - historically, [T] was not treated as a type,\n+    // This is a horrible hack - historically, [T] was not treated as a type,\n     // so, for example, &T and &[U] should not unify. In fact the only thing\n     // &[U] should unify with is &[T]. We preserve that behaviour with this\n     // check."}, {"sha": "14261aef60c085b0dcdbcd1ef0b398886de098c9", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -17,7 +17,7 @@ works, it often happens that errors are not detected until far after\n the relevant line of code has been type-checked. Therefore, there is\n an elaborate system to track why a particular constraint in the\n inference graph arose so that we can explain to the user what gave\n-rise to a patricular error.\n+rise to a particular error.\n \n The basis of the system are the \"origin\" types. An \"origin\" is the\n reason that a constraint or inference variable arose. There are"}, {"sha": "6455344cb1351de4a88e00c10cd76dfb91cabcc1", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -19,7 +19,7 @@\n  * The code in here is defined quite generically so that it can be\n  * applied both to type variables, which represent types being inferred,\n  * and fn variables, which represent function types being inferred.\n- * It may eventually be applied to ther types as well, who knows.\n+ * It may eventually be applied to their types as well, who knows.\n  * In some cases, the functions are also generic with respect to the\n  * operation on the lattice (GLB vs LUB).\n  *"}, {"sha": "a64f7896cfbfd26821fc71cb9c6e4ed7c753acb8", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -362,7 +362,7 @@ identify and remove strongly connected components (SCC) in the graph.\n Note that such components must consist solely of region variables; all\n of these variables can effectively be unified into a single variable.\n Once SCCs are removed, we are left with a DAG.  At this point, we\n-could walk the DAG in toplogical order once to compute the expanding\n+could walk the DAG in topological order once to compute the expanding\n nodes, and again in reverse topological order to compute the\n contracting nodes. However, as I said, this does not work given the\n current treatment of closure bounds, but perhaps in the future we can\n@@ -617,7 +617,7 @@ created to replace the bound regions in the input types, but it also\n contains 'intermediate' variables created to represent the LUB/GLB of\n individual regions.  Basically, when asked to compute the LUB/GLB of a\n region variable with another region, the inferencer cannot oblige\n-immediately since the valuese of that variables are not known.\n+immediately since the values of that variables are not known.\n Therefore, it creates a new variable that is related to the two\n regions.  For example, the LUB of two variables `$x` and `$y` is a\n fresh variable `$z` that is constrained such that `$x <= $z` and `$y"}, {"sha": "961625fadefcc1fc4cb68b1f0eb988f26890d8b8", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -485,7 +485,7 @@ impl<'a> Visitor<()> for ConstraintContext<'a> {\n                     let variant =\n                         ty::VariantInfo::from_ast_variant(tcx,\n                                                           ast_variant,\n-                                                          /*discrimant*/ 0);\n+                                                          /*discriminant*/ 0);\n                     for &arg_ty in variant.args.iter() {\n                         self.add_constraints_from_ty(arg_ty, self.covariant);\n                     }"}, {"sha": "47d9e66fbd5a51325e2ad79a28b24db0ccb2d10d", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -61,12 +61,12 @@ fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n     let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n     if new_high_bits > Zero::zero() {\n-        fail!(\"numeric overflow occured.\")\n+        fail!(\"numeric overflow occurred.\")\n     }\n \n     match bits.checked_add(&new_low_bits) {\n         Some(x) => return x,\n-        None => fail!(\"numeric overflow occured.\")\n+        None => fail!(\"numeric overflow occurred.\")\n     }\n }\n "}, {"sha": "83f99fc881b7141d1f1c0ef84f68acc1f798d9fc", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -390,7 +390,7 @@ fn parse_lang_string(string: &str) -> (bool,bool,bool,bool) {\n }\n \n /// By default this markdown renderer generates anchors for each header in the\n-/// rendered document. The anchor name is the contents of the header spearated\n+/// rendered document. The anchor name is the contents of the header separated\n /// by hyphens, and a task-local map is used to disambiguate among duplicate\n /// headers (numbers are appended).\n ///"}, {"sha": "c6d8632082ea7852a01b7449ddaa5869163274f7", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -49,11 +49,11 @@ pub struct TocEntry {\n #[deriving(PartialEq)]\n pub struct TocBuilder {\n     top_level: Toc,\n-    /// The current heirachy of parent headings, the levels are\n+    /// The current hierarchy of parent headings, the levels are\n     /// strictly increasing (i.e. chain[0].level < chain[1].level <\n-    /// ...) with each entry being the most recent occurance of a\n+    /// ...) with each entry being the most recent occurrence of a\n     /// heading with that level (it doesn't include the most recent\n-    /// occurences of every level, just, if *is* in `chain` then is is\n+    /// occurrences of every level, just, if *is* in `chain` then is is\n     /// the most recent one).\n     ///\n     /// We also have `chain[0].level <= top_level.entries[last]`.\n@@ -123,7 +123,7 @@ impl TocBuilder {\n     }\n \n     /// Push a level `level` heading into the appropriate place in the\n-    /// heirarchy, returning a string containing the section number in\n+    /// hierarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n     pub fn push<'a>(&'a mut self, level: u32, name: String, id: String) -> &'a str {\n         assert!(level >= 1);"}, {"sha": "31eb83cb92015b69b43943c7865deab954a20d47", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -383,7 +383,7 @@ mod unindent_tests {\n \n     #[test]\n     fn should_ignore_first_line_indent() {\n-        // Thi first line of the first paragraph may not be indented as\n+        // The first line of the first paragraph may not be indented as\n         // far due to the way the doc string was written:\n         //\n         // #[doc = \"Start way over here"}, {"sha": "bde14b962c7a45020b92ffa3fc630c1ba37c9ccb", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -163,7 +163,7 @@ impl Task {\n \n         // Here we must unsafely borrow the task in order to not remove it from\n         // TLS. When collecting failure, we may attempt to send on a channel (or\n-        // just run aribitrary code), so we must be sure to still have a local\n+        // just run arbitrary code), so we must be sure to still have a local\n         // task in TLS.\n         unsafe {\n             let me: *mut Task = Local::unsafe_borrow();"}, {"sha": "f7475db1552f7181acd5bd414aca32e0d7ecd290", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -395,7 +395,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n /// The core of the unwinding.\n ///\n /// This is non-generic to avoid instantiation bloat in other crates\n-/// (which makes compilation of small crates noticably slower). (Note:\n+/// (which makes compilation of small crates noticeably slower). (Note:\n /// we need the `Any` object anyway, we're not just creating it to\n /// avoid being generic.)\n ///\n@@ -408,7 +408,7 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n     // First, invoke call the user-defined callbacks triggered on task failure.\n     //\n     // By the time that we see a callback has been registered (by reading\n-    // MAX_CALLBACKS), the actuall callback itself may have not been stored yet,\n+    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n     // so we just chalk it up to a race condition and move on to the next\n     // callback. Additionally, CALLBACK_CNT may briefly be higher than\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary."}, {"sha": "d67adfe501e62e5db7202c634a238ded8c432461", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -212,7 +212,7 @@ impl ForbidSwitch {\n impl Drop for ForbidSwitch {\n     fn drop(&mut self) {\n         assert!(self.io == homing::local_id(),\n-                \"didnt want a scheduler switch: {}\",\n+                \"didn't want a scheduler switch: {}\",\n                 self.msg);\n     }\n }"}, {"sha": "742944977622fa96c0132c22210290b92990d0f3", "filename": "src/librustuv/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -147,7 +147,7 @@ impl StreamWatcher {\n         // function is why that wording exists.\n         //\n         // Implementation-wise, we must be careful when passing a buffer down to\n-        // libuv. Most of this implementation avoids allocations becuase of the\n+        // libuv. Most of this implementation avoids allocations because of the\n         // blocking guarantee (all stack local variables are valid for the\n         // entire read/write request). If our write request can be timed out,\n         // however, we must heap allocate the data and pass that to the libuv\n@@ -164,7 +164,7 @@ impl StreamWatcher {\n         };\n \n         // Send off the request, but be careful to not block until we're sure\n-        // that the write reqeust is queued. If the reqeust couldn't be queued,\n+        // that the write request is queued. If the request couldn't be queued,\n         // then we should return immediately with an error.\n         match unsafe {\n             uvll::uv_write(req.handle, self.handle, [uv_buf], write_cb)"}, {"sha": "ffb2a0dbed8f90c97bea4cb8a1ea9aca1f3f5f5c", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -542,7 +542,7 @@ impl<T: Send> Sender<T> {\n     /// ```\n     pub fn send_opt(&self, t: T) -> Result<(), T> {\n         // In order to prevent starvation of other tasks in situations where\n-        // a task sends repeatedly without ever receiving, we occassionally\n+        // a task sends repeatedly without ever receiving, we occasionally\n         // yield instead of doing a send immediately.\n         //\n         // Don't unconditionally attempt to yield because the TLS overhead can"}, {"sha": "723d0d60867f5ac679b88fedafb0a501af7240ec", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -513,7 +513,7 @@ mod tests {\n     #[test]\n     fn test_mutex_arc_nested() {\n         // Tests nested mutexes and access\n-        // to underlaying data.\n+        // to underlying data.\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = Arc::new(Mutex::new(arc));\n         task::spawn(proc() {"}, {"sha": "bd4b5fae3d0922d74f8f35bc4c079b92bd9c6c36", "filename": "src/libsync/one.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fone.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -71,7 +71,7 @@ impl Once {\n \n         // Implementation-wise, this would seem like a fairly trivial primitive.\n         // The stickler part is where our mutexes currently require an\n-        // allocation, and usage of a `Once` should't leak this allocation.\n+        // allocation, and usage of a `Once` shouldn't leak this allocation.\n         //\n         // This means that there must be a deterministic destroyer of the mutex\n         // contained within (because it's not needed after the initialization"}, {"sha": "b656b0c06a06c2211d5041f10ac8ce29fb8c317c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -195,7 +195,7 @@ impl DummyResult {\n     /// Create a default MacResult that can only be an expression.\n     ///\n     /// Use this for macros that must expand to an expression, so even\n-    /// if an error is encountered internally, the user will recieve\n+    /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n     pub fn expr(sp: Span) -> Box<MacResult> {\n         box DummyResult { expr_only: true, span: sp } as Box<MacResult>"}, {"sha": "24cc286b190cf71d867b62998080022784d92bb2", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -77,7 +77,7 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substru\n             ```\n \n             The optimiser should remove the redundancy. We explicitly\n-            get use the binops to avoid auto-deref derefencing too many\n+            get use the binops to avoid auto-deref dereferencing too many\n             layers of pointers, if the type includes pointers.\n             */\n             let other_f = match other_fs {"}, {"sha": "bf0da94e3e363d1a6f1f754f8d2b58bb39ffea36", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -723,7 +723,7 @@ impl<'a> MethodDef<'a> {\n             &Struct(fields));\n \n         // make a series of nested matches, to destructure the\n-        // structs. This is actually right-to-left, but it shoudn't\n+        // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n             body = cx.expr_match(trait_.span, arg_expr,"}, {"sha": "c0c066fe4668b030fc8d36220cd4ba137211cf53", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -58,7 +58,7 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n             dotdotdoted: false,\n             sep: None,\n         }),\n-        interpolations: match interp { /* just a convienience */\n+        interpolations: match interp { /* just a convenience */\n             None => HashMap::new(),\n             Some(x) => x,\n         },"}, {"sha": "52e3693c31f2a1ad015538566bea41afc717da2c", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -112,7 +112,7 @@ impl<'a> ParserAttr for Parser<'a> {\n     }\n \n     // Parse attributes that appear after the opening of an item. These should\n-    // be preceded by an exclaimation mark, but we accept and warn about one\n+    // be preceded by an exclamation mark, but we accept and warn about one\n     // terminated by a semicolon. In addition to a vector of inner attributes,\n     // this function also returns a vector that may contain the first outer\n     // attribute of the next item (since we can't know whether the attribute"}, {"sha": "de5f533a96e1295a10f1d8c96dace3880458ccc7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -2582,7 +2582,7 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprLoop(body, opt_ident))\n     }\n \n-    // For distingishing between struct literals and blocks\n+    // For distinguishing between struct literals and blocks\n     fn looking_at_struct_literal(&mut self) -> bool {\n         self.token == token::LBRACE &&\n         ((self.look_ahead(1, |t| token::is_plain_ident(t)) &&"}, {"sha": "4fefa1f1d3d1ef07a215d9b751622ad0a9247038", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -233,7 +233,7 @@ pub fn mk_printer(out: Box<io::Writer>, linewidth: uint) -> Printer {\n  *\n  * There is a parallel ring buffer, 'size', that holds the calculated size of\n  * each token. Why calculated? Because for Begin/End pairs, the \"size\"\n- * includes everything betwen the pair. That is, the \"size\" of Begin is\n+ * includes everything between the pair. That is, the \"size\" of Begin is\n  * actually the sum of the sizes of everything between Begin and the paired\n  * End that follows. Since that is arbitrarily far in the future, 'size' is\n  * being rewritten regularly while the printer runs; in fact most of the\n@@ -434,7 +434,7 @@ impl Printer {\n         assert!((self.right != self.left));\n     }\n     pub fn advance_left(&mut self, x: Token, l: int) -> io::IoResult<()> {\n-        debug!(\"advnce_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n+        debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, l);\n         if l >= 0 {\n             let ret = self.print(x.clone(), l);"}, {"sha": "a306ebba96aba22381d8c1ac3d707f18397f1d03", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -62,7 +62,7 @@ pub fn generics_of_fn(fk: &FnKind) -> Generics {\n }\n \n /// Each method of the Visitor trait is a hook to be potentially\n-/// overriden.  Each method's default implementation recursively visits\n+/// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n /// e.g. the `visit_mod` method by default calls `visit::walk_mod`.\n ///"}, {"sha": "0002b20d205ca9abaf930211a058d3ca2a8e8dd7", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -32,7 +32,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n         Some(dir) => dirs_to_search.push(Path::new(dir)),\n         None => {\n             if homedir.is_some() {\n-                // ncurses compatability;\n+                // ncurses compatibility;\n                 dirs_to_search.push(homedir.unwrap().join(\".terminfo\"))\n             }\n             match getenv(\"TERMINFO_DIRS\") {"}, {"sha": "bace30e3f6ffd1dc5afbdbd842fa305ca1d4724a", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2c99463720e758d5aa0bdcea19dc5b3dd67292c/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=c2c99463720e758d5aa0bdcea19dc5b3dd67292c", "patch": "@@ -462,7 +462,7 @@ impl FromStr for Uuid {\n     /// Parse a hex string and interpret as a UUID\n     ///\n     /// Accepted formats are a sequence of 32 hexadecimal characters,\n-    /// with or without hypens (grouped as 8, 4, 4, 4, 12).\n+    /// with or without hyphens (grouped as 8, 4, 4, 4, 12).\n     fn from_str(us: &str) -> Option<Uuid> {\n         let result = Uuid::parse_string(us);\n         match result {\n@@ -492,7 +492,7 @@ impl Eq for Uuid {}\n \n // FIXME #9845: Test these more thoroughly\n impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n-    /// Encode a UUID as a hypenated string\n+    /// Encode a UUID as a hyphenated string\n     fn encode(&self, e: &mut T) -> Result<(), E> {\n         e.emit_str(self.to_hyphenated_str().as_slice())\n     }"}]}