{"sha": "728d16cfca4d1d12fdabbcc666071810c4d94dc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGQxNmNmY2E0ZDFkMTJmZGFiYmNjNjY2MDcxODEwYzRkOTRkYzk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T23:38:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-24T23:38:24Z"}, "message": "rustc: Parse new-style impl declarations", "tree": {"sha": "613fe2fb692e2d72adf91a641aae1e42bfd67c33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613fe2fb692e2d72adf91a641aae1e42bfd67c33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728d16cfca4d1d12fdabbcc666071810c4d94dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728d16cfca4d1d12fdabbcc666071810c4d94dc9", "html_url": "https://github.com/rust-lang/rust/commit/728d16cfca4d1d12fdabbcc666071810c4d94dc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728d16cfca4d1d12fdabbcc666071810c4d94dc9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "587b0edbbf6c3ac587be98679c4262049aa2a305", "url": "https://api.github.com/repos/rust-lang/rust/commits/587b0edbbf6c3ac587be98679c4262049aa2a305", "html_url": "https://github.com/rust-lang/rust/commit/587b0edbbf6c3ac587be98679c4262049aa2a305"}], "stats": {"total": 103, "additions": 69, "deletions": 34}, "files": [{"sha": "de772b0ff1cb02975c47bde6ff1903711abcde96", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 34, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/728d16cfca4d1d12fdabbcc666071810c4d94dc9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728d16cfca4d1d12fdabbcc666071810c4d94dc9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=728d16cfca4d1d12fdabbcc666071810c4d94dc9", "patch": "@@ -2089,51 +2089,86 @@ class parser {\n         (ident, item_trait(tps, meths), none)\n     }\n \n-    // Parses three variants (with the region/type params always optional):\n+    // Parses four variants (with the region/type params always optional):\n     //    impl /&<T: copy> of to_str for ~[T] { ... }\n     //    impl name/&<T> of to_str for ~[T] { ... }\n     //    impl name/&<T> for ~[T] { ... }\n+    //    impl<T> ~[T] : to_str { ... }\n     fn parse_item_impl() -> item_info {\n         fn wrap_path(p: parser, pt: @path) -> @ty {\n             @{id: p.get_id(), node: ty_path(pt, p.get_id()), span: pt.span}\n         }\n-        let mut (ident, tps) = {\n-            if self.token == token::LT {\n-                (none, self.parse_ty_params())\n-            } else if self.token == token::BINOP(token::SLASH) {\n-                self.parse_region_param();\n-                (none, self.parse_ty_params())\n+\n+        // We do two separate paths here: old-style impls and new-style impls.\n+\n+        // First, parse type parameters if necessary.\n+        let mut tps;\n+        if self.token == token::LT {\n+            tps = self.parse_ty_params();\n+        } else {\n+            tps = ~[];\n+        }\n+\n+        let mut ident;\n+        let ty, traits;\n+        if !self.is_keyword(~\"of\") &&\n+                !self.token_is_keyword(~\"of\", self.look_ahead(1)) &&\n+                !self.token_is_keyword(~\"for\", self.look_ahead(1)) &&\n+                self.look_ahead(1) != token::BINOP(token::SLASH) &&\n+                self.look_ahead(1) != token::LT {\n+\n+            // This is a new-style impl declaration.\n+            ident = @~\"__extensions__\";     // XXX: clownshoes\n+\n+            // Parse the type.\n+            ty = self.parse_ty(false);\n+\n+            // Parse traits, if necessary.\n+            if self.token == token::COLON {\n+                self.bump();\n+                traits = self.parse_trait_ref_list(token::LBRACE);\n+            } else {\n+                traits = ~[];\n             }\n-            else if self.is_keyword(~\"of\") {\n-                (none, ~[])\n+        } else {\n+            let mut ident_old;\n+            if self.token == token::BINOP(token::SLASH) {\n+                self.parse_region_param();\n+                ident_old = none;\n+                tps = self.parse_ty_params();\n+            } else if self.is_keyword(~\"of\") {\n+                ident_old = none;\n             } else {\n-                let id = self.parse_ident();\n+                ident_old = some(self.parse_ident());\n                 self.parse_region_param();\n-                (some(id), self.parse_ty_params())\n-            }\n-        };\n-        let traits;\n-        if self.eat_keyword(~\"of\") {\n-            let for_atom = interner::intern(*self.reader.interner(), @~\"for\");\n-            traits = self.parse_trait_ref_list(token::IDENT(for_atom, false));\n-            if traits.len() >= 1 && option::is_none(ident) {\n-                ident = some(vec::last(traits[0].path.idents));\n-            }\n-            if traits.len() == 0 {\n-                self.fatal(~\"BUG: 'of' but no trait\");\n+                tps = self.parse_ty_params();\n             }\n-            if traits.len() > 1 {\n-                self.fatal(~\"BUG: multiple traits\");\n-            }\n-        } else {\n-            traits = ~[];\n-        };\n-        let ident = alt ident {\n-          some(name) { name }\n-          none { self.expect_keyword(~\"of\"); fail; }\n-        };\n-        self.expect_keyword(~\"for\");\n-        let ty = self.parse_ty(false);\n+\n+            if self.eat_keyword(~\"of\") {\n+                let for_atom = interner::intern(*self.reader.interner(),\n+                                                @~\"for\");\n+                traits = self.parse_trait_ref_list\n+                    (token::IDENT(for_atom, false));\n+                if traits.len() >= 1 && option::is_none(ident_old) {\n+                    ident_old = some(vec::last(traits[0].path.idents));\n+                }\n+                if traits.len() == 0 {\n+                    self.fatal(~\"BUG: 'of' but no trait\");\n+                }\n+                if traits.len() > 1 {\n+                    self.fatal(~\"BUG: multiple traits\");\n+                }\n+            } else {\n+                traits = ~[];\n+            };\n+            ident = alt ident_old {\n+              some(name) { name }\n+              none { self.expect_keyword(~\"of\"); fail; }\n+            };\n+            self.expect_keyword(~\"for\");\n+            ty = self.parse_ty(false);\n+        }\n+\n         let mut meths = ~[];\n         self.expect(token::LBRACE);\n         while !self.eat(token::RBRACE) {"}]}