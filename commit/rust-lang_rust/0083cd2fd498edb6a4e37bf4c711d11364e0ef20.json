{"sha": "0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "node_id": "C_kwDOAAsO6NoAKDAwODNjZDJmZDQ5OGVkYjZhNGUzN2JmNGM3MTFkMTEzNjRlMGVmMjA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-13T14:02:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-13T14:02:33Z"}, "message": "Rollup merge of #98574 - dingxiangfei2009:let-else-thir, r=oli-obk\n\nLower let-else in MIR\n\nThis MR will switch to lower let-else statements in MIR building instead.\n\nTo lower let-else in MIR, we build a mini-switch two branches. One branch leads to the matching case, and the other leads to the `else` block. This arrangement will allow temporary lifetime analysis running as-is so that the temporaries are properly extended according to the same rule applied to regular `let` statements.\n\ncc https://github.com/rust-lang/rust/issues/87335\n\nFix #98672", "tree": {"sha": "ae0410e11bd58462d2ad36d710b887bf6dcb6dff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae0410e11bd58462d2ad36d710b887bf6dcb6dff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiztB5CRBK7hj4Ov3rIwAAuhsIAAelBI/gB6OyYhiUhgKK1jZT\nX3RClyFBD1E5uIfnVjvSXYI1EP2CBEgwv7U7rDmdZNkRKs/ZDYEmZ5Qh5uqUQDyQ\nY2vpJt1/S3K4QV1GC1HpF01mj86pDSUF3KWrx5dybeyTuIe71HDjbEZ29pOfqFac\nUsB1cz5HTd2HMOXqcAvmZYL7df6c98coPuAYw2ONMyrs3MqINaBLlBAD4Vz56cv6\n6T//KOPzOm9kchum+FZDQl4oOEeBLTaw1NcYpJk2nWbuiRWsed+YFAMRKMr+Ksma\nrlQcnVWA8263dwEjW5k7d2EtupO1t0tfJxfDwshsUNztp3Q46zNEWya1x5KTdag=\n=paEI\n-----END PGP SIGNATURE-----\n", "payload": "tree ae0410e11bd58462d2ad36d710b887bf6dcb6dff\nparent ca4e39400ef33198e2715973d1c67a1d3cee15e7\nparent 947cbda5eb557ee3015b2310adfc80a393e42051\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657720953 +0530\ncommitter GitHub <noreply@github.com> 1657720953 +0530\n\nRollup merge of #98574 - dingxiangfei2009:let-else-thir, r=oli-obk\n\nLower let-else in MIR\n\nThis MR will switch to lower let-else statements in MIR building instead.\n\nTo lower let-else in MIR, we build a mini-switch two branches. One branch leads to the matching case, and the other leads to the `else` block. This arrangement will allow temporary lifetime analysis running as-is so that the temporaries are properly extended according to the same rule applied to regular `let` statements.\n\ncc https://github.com/rust-lang/rust/issues/87335\n\nFix #98672\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "html_url": "https://github.com/rust-lang/rust/commit/0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca4e39400ef33198e2715973d1c67a1d3cee15e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4e39400ef33198e2715973d1c67a1d3cee15e7", "html_url": "https://github.com/rust-lang/rust/commit/ca4e39400ef33198e2715973d1c67a1d3cee15e7"}, {"sha": "947cbda5eb557ee3015b2310adfc80a393e42051", "url": "https://api.github.com/repos/rust-lang/rust/commits/947cbda5eb557ee3015b2310adfc80a393e42051", "html_url": "https://github.com/rust-lang/rust/commit/947cbda5eb557ee3015b2310adfc80a393e42051"}], "stats": {"total": 841, "additions": 576, "deletions": 265}, "files": [{"sha": "7cbfe143b4d83d3701a7b30e5571f8e4d4322c1c", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 22, "deletions": 73, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1,8 +1,8 @@\n use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n-use rustc_ast::{AttrVec, Block, BlockCheckMode, Expr, Local, LocalKind, Stmt, StmtKind};\n+use rustc_ast::{Block, BlockCheckMode, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n use rustc_session::parse::feature_err;\n-use rustc_span::{sym, DesugaringKind};\n+use rustc_span::sym;\n \n use smallvec::SmallVec;\n \n@@ -36,21 +36,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match s.kind {\n                 StmtKind::Local(ref local) => {\n                     let hir_id = self.lower_node_id(s.id);\n-                    match &local.kind {\n-                        LocalKind::InitElse(init, els) => {\n-                            let e = self.lower_let_else(hir_id, local, init, els, tail);\n-                            expr = Some(e);\n-                            // remaining statements are in let-else expression\n-                            break;\n-                        }\n-                        _ => {\n-                            let local = self.lower_local(local);\n-                            self.alias_attrs(hir_id, local.hir_id);\n-                            let kind = hir::StmtKind::Local(local);\n-                            let span = self.lower_span(s.span);\n-                            stmts.push(hir::Stmt { hir_id, kind, span });\n-                        }\n-                    }\n+                    let local = self.lower_local(local);\n+                    self.alias_attrs(hir_id, local.hir_id);\n+                    let kind = hir::StmtKind::Local(local);\n+                    let span = self.lower_span(s.span);\n+                    stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n                 StmtKind::Item(ref it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n@@ -101,10 +91,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let init = l.kind.init().map(|init| self.lower_expr(init));\n         let hir_id = self.lower_node_id(l.id);\n         let pat = self.lower_pat(&l.pat);\n+        let els = if let LocalKind::InitElse(_, els) = &l.kind {\n+            if !self.tcx.features().let_else {\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::let_else,\n+                    l.span,\n+                    \"`let...else` statements are unstable\",\n+                )\n+                .emit();\n+            }\n+            Some(self.lower_block(els, false))\n+        } else {\n+            None\n+        };\n         let span = self.lower_span(l.span);\n         let source = hir::LocalSource::Normal;\n         self.lower_attrs(hir_id, &l.attrs);\n-        self.arena.alloc(hir::Local { hir_id, ty, pat, init, span, source })\n+        self.arena.alloc(hir::Local { hir_id, ty, pat, init, els, span, source })\n     }\n \n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n@@ -115,59 +119,4 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n         }\n     }\n-\n-    fn lower_let_else(\n-        &mut self,\n-        stmt_hir_id: hir::HirId,\n-        local: &Local,\n-        init: &Expr,\n-        els: &Block,\n-        tail: &[Stmt],\n-    ) -> &'hir hir::Expr<'hir> {\n-        let ty = local\n-            .ty\n-            .as_ref()\n-            .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));\n-        let span = self.lower_span(local.span);\n-        let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);\n-        let init = self.lower_expr(init);\n-        let local_hir_id = self.lower_node_id(local.id);\n-        self.lower_attrs(local_hir_id, &local.attrs);\n-        let let_expr = {\n-            let lex = self.arena.alloc(hir::Let {\n-                hir_id: local_hir_id,\n-                pat: self.lower_pat(&local.pat),\n-                ty,\n-                init,\n-                span,\n-            });\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))\n-        };\n-        let then_expr = {\n-            let (stmts, expr) = self.lower_stmts(tail);\n-            let block = self.block_all(span, stmts, expr);\n-            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n-        };\n-        let else_expr = {\n-            let block = self.lower_block(els, false);\n-            self.arena.alloc(self.expr_block(block, AttrVec::new()))\n-        };\n-        self.alias_attrs(let_expr.hir_id, local_hir_id);\n-        self.alias_attrs(else_expr.hir_id, local_hir_id);\n-        let if_expr = self.arena.alloc(hir::Expr {\n-            hir_id: stmt_hir_id,\n-            span,\n-            kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n-        });\n-        if !self.tcx.features().let_else {\n-            feature_err(\n-                &self.tcx.sess.parse_sess,\n-                sym::let_else,\n-                local.span,\n-                \"`let...else` statements are unstable\",\n-            )\n-            .emit();\n-        }\n-        if_expr\n-    }\n }"}, {"sha": "4da3096f7c3aa9fecea17274ea678f2b1d84597f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -2146,7 +2146,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(!a.is_empty());\n             self.attrs.insert(hir_id.local_id, a);\n         }\n-        let local = hir::Local { hir_id, init, pat, source, span: self.lower_span(span), ty: None };\n+        let local = hir::Local {\n+            hir_id,\n+            init,\n+            pat,\n+            els: None,\n+            source,\n+            span: self.lower_span(span),\n+            ty: None,\n+        };\n         self.stmt(span, hir::StmtKind::Local(self.arena.alloc(local)))\n     }\n "}, {"sha": "ed874ae829b46df43c0632aa20e3f786dcd23583", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1316,6 +1316,8 @@ pub struct Local<'hir> {\n     pub ty: Option<&'hir Ty<'hir>>,\n     /// Initializer expression to set the value, if any.\n     pub init: Option<&'hir Expr<'hir>>,\n+    /// Else block for a `let...else` binding.\n+    pub els: Option<&'hir Block<'hir>>,\n     pub hir_id: HirId,\n     pub span: Span,\n     /// Can be `ForLoopDesugar` if the `let` statement is part of a `for` loop"}, {"sha": "b5d9769c578a5cb520dd19d1650f9474012ce70f", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -472,6 +472,9 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local<'v>) {\n     walk_list!(visitor, visit_expr, &local.init);\n     visitor.visit_id(local.hir_id);\n     visitor.visit_pat(&local.pat);\n+    if let Some(els) = local.els {\n+        visitor.visit_block(els);\n+    }\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n "}, {"sha": "e3c97ec357e876808e221f01d6d6992bedc8936f", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -883,7 +883,12 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::SubItem(ii.hir_id()))\n     }\n \n-    pub fn print_local(&mut self, init: Option<&hir::Expr<'_>>, decl: impl Fn(&mut Self)) {\n+    pub fn print_local(\n+        &mut self,\n+        init: Option<&hir::Expr<'_>>,\n+        els: Option<&hir::Block<'_>>,\n+        decl: impl Fn(&mut Self),\n+    ) {\n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_nbsp(\"let\");\n@@ -897,14 +902,21 @@ impl<'a> State<'a> {\n             self.word_space(\"=\");\n             self.print_expr(init);\n         }\n+\n+        if let Some(els) = els {\n+            self.nbsp();\n+            self.word_space(\"else\");\n+            self.print_block(els);\n+        }\n+\n         self.end()\n     }\n \n     pub fn print_stmt(&mut self, st: &hir::Stmt<'_>) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             hir::StmtKind::Local(loc) => {\n-                self.print_local(loc.init, |this| this.print_local_decl(loc));\n+                self.print_local(loc.init, loc.els, |this| this.print_local_decl(loc));\n             }\n             hir::StmtKind::Item(item) => self.ann.nested(self, Nested::Item(item)),\n             hir::StmtKind::Expr(expr) => {\n@@ -1404,7 +1416,7 @@ impl<'a> State<'a> {\n \n                 // Print `let _t = $init;`:\n                 let temp = Ident::from_str(\"_t\");\n-                self.print_local(Some(init), |this| this.print_ident(temp));\n+                self.print_local(Some(init), None, |this| this.print_ident(temp));\n                 self.word(\";\");\n \n                 // Print `_t`:"}, {"sha": "3e5f6bb8f0bcfd1f587d1a23c94f398427711505", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -182,6 +182,9 @@ pub enum StmtKind<'tcx> {\n         /// `let pat: ty = <INIT>`\n         initializer: Option<ExprId>,\n \n+        /// `let pat: ty = <INIT> else { <ELSE> }\n+        else_block: Option<Block>,\n+\n         /// The lint level for this `let` statement.\n         lint_level: LintLevel,\n     },"}, {"sha": "97249fdd175637e11747f19c8bef1f5f02df0341", "filename": "compiler/rustc_middle/src/thir/visit.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir%2Fvisit.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -167,11 +167,15 @@ pub fn walk_stmt<'a, 'tcx: 'a, V: Visitor<'a, 'tcx>>(visitor: &mut V, stmt: &Stm\n             init_scope: _,\n             ref pattern,\n             lint_level: _,\n+            else_block,\n         } => {\n             if let Some(init) = initializer {\n                 visitor.visit_expr(&visitor.thir()[*init]);\n             }\n             visitor.visit_pat(pattern);\n+            if let Some(block) = else_block {\n+                visitor.visit_block(block)\n+            }\n         }\n     }\n }"}, {"sha": "cb8be51a08562e9463f9505464a9b8d609a5f61c", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -99,6 +99,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     ref pattern,\n                     initializer,\n                     lint_level,\n+                    else_block,\n                 } => {\n                     let ignores_expr_result = matches!(*pattern.kind, PatKind::Wild);\n                     this.block_context.push(BlockFrame::Statement { ignores_expr_result });\n@@ -124,18 +125,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 |this| {\n                                     let scope = (*init_scope, source_info);\n                                     this.in_scope(scope, *lint_level, |this| {\n-                                        this.declare_bindings(\n-                                            visibility_scope,\n-                                            remainder_span,\n-                                            pattern,\n-                                            ArmHasGuard(false),\n-                                            Some((None, initializer_span)),\n-                                        );\n-                                        this.expr_into_pattern(block, pattern.clone(), init)\n+                                        if let Some(else_block) = else_block {\n+                                            this.ast_let_else(\n+                                                block,\n+                                                init,\n+                                                initializer_span,\n+                                                else_block,\n+                                                visibility_scope,\n+                                                remainder_span,\n+                                                pattern,\n+                                            )\n+                                        } else {\n+                                            this.declare_bindings(\n+                                                visibility_scope,\n+                                                remainder_span,\n+                                                pattern,\n+                                                ArmHasGuard(false),\n+                                                Some((None, initializer_span)),\n+                                            );\n+                                            this.expr_into_pattern(block, pattern.clone(), init) // irrefutable pattern\n+                                        }\n                                     })\n-                                }\n+                                },\n                             )\n-                        );\n+                        )\n                     } else {\n                         let scope = (*init_scope, source_info);\n                         unpack!(this.in_scope(scope, *lint_level, |this| {"}, {"sha": "7067a48b783ec24ad61e1c066db7c6120249c738", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 74, "deletions": 3, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1615,7 +1615,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        debug!(\"test_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let mut target_candidates: Vec<Vec<&mut Candidate<'pat, 'tcx>>> = vec![];\n         target_candidates.resize_with(test.targets(), Default::default);\n \n@@ -1635,8 +1635,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n         // at least the first candidate ought to be tested\n         assert!(total_candidate_count > candidates.len());\n-        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"untested_candidates: {}\", candidates.len());\n+        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -2274,4 +2274,75 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         debug!(\"declare_binding: vars={:?}\", locals);\n         self.var_indices.insert(var_id, locals);\n     }\n+\n+    pub(crate) fn ast_let_else(\n+        &mut self,\n+        mut block: BasicBlock,\n+        init: &Expr<'tcx>,\n+        initializer_span: Span,\n+        else_block: &Block,\n+        visibility_scope: Option<SourceScope>,\n+        remainder_span: Span,\n+        pattern: &Pat<'tcx>,\n+    ) -> BlockAnd<()> {\n+        let scrutinee = unpack!(block = self.lower_scrutinee(block, init, initializer_span));\n+        let pat = Pat { ty: init.ty, span: else_block.span, kind: Box::new(PatKind::Wild) };\n+        let mut wildcard = Candidate::new(scrutinee.clone(), &pat, false);\n+        self.declare_bindings(\n+            visibility_scope,\n+            remainder_span,\n+            pattern,\n+            ArmHasGuard(false),\n+            Some((None, initializer_span)),\n+        );\n+        let mut candidate = Candidate::new(scrutinee.clone(), pattern, false);\n+        let fake_borrow_temps = self.lower_match_tree(\n+            block,\n+            initializer_span,\n+            pattern.span,\n+            false,\n+            &mut [&mut candidate, &mut wildcard],\n+        );\n+        // This block is for the matching case\n+        let matching = self.bind_pattern(\n+            self.source_info(pattern.span),\n+            candidate,\n+            None,\n+            &fake_borrow_temps,\n+            initializer_span,\n+            None,\n+            None,\n+            None,\n+        );\n+        // This block is for the failure case\n+        let failure = self.bind_pattern(\n+            self.source_info(else_block.span),\n+            wildcard,\n+            None,\n+            &fake_borrow_temps,\n+            initializer_span,\n+            None,\n+            None,\n+            None,\n+        );\n+        // This place is not really used because this destination place\n+        // should never be used to take values at the end of the failure\n+        // block.\n+        let dummy_place = Place { local: RETURN_PLACE, projection: ty::List::empty() };\n+        let failure_block;\n+        unpack!(\n+            failure_block = self.ast_block(\n+                dummy_place,\n+                failure,\n+                else_block,\n+                self.source_info(else_block.span),\n+            )\n+        );\n+        self.cfg.terminate(\n+            failure_block,\n+            self.source_info(else_block.span),\n+            TerminatorKind::Unreachable,\n+        );\n+        matching.unit()\n+    }\n }"}, {"sha": "dccaa61ed89d45faabdd89b666532a55b6d1b394", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -74,6 +74,8 @@ impl<'tcx> Cx<'tcx> {\n                             )),\n                         };\n \n+                        let else_block = local.els.map(|els| self.mirror_block(els));\n+\n                         let mut pattern = self.pattern_from_hir(local.pat);\n                         debug!(?pattern);\n \n@@ -110,6 +112,7 @@ impl<'tcx> Cx<'tcx> {\n                                 },\n                                 pattern,\n                                 initializer: local.init.map(|init| self.mirror_expr(init)),\n+                                else_block,\n                                 lint_level: LintLevel::Explicit(local.hir_id),\n                             },\n                             opt_destruction_scope: opt_dxn_ext,"}, {"sha": "5bd1fad0bcb9f9cbbe1e9ec2edfff178451afd97", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -21,7 +21,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n-use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span};\n+use rustc_span::{BytePos, Span};\n \n pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n@@ -77,14 +77,20 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n \n     fn visit_local(&mut self, loc: &'tcx hir::Local<'tcx>) {\n         intravisit::walk_local(self, loc);\n+        let els = loc.els;\n+        if let Some(init) = loc.init && els.is_some() {\n+            self.check_let(&loc.pat, init, loc.span);\n+        }\n \n         let (msg, sp) = match loc.source {\n             hir::LocalSource::Normal => (\"local binding\", Some(loc.span)),\n             hir::LocalSource::AsyncFn => (\"async fn binding\", None),\n             hir::LocalSource::AwaitDesugar => (\"`await` future binding\", None),\n             hir::LocalSource::AssignDesugar(_) => (\"destructuring assignment binding\", None),\n         };\n-        self.check_irrefutable(&loc.pat, msg, sp);\n+        if els.is_none() {\n+            self.check_irrefutable(&loc.pat, msg, sp);\n+        }\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n@@ -1125,17 +1131,16 @@ fn let_source_parent(tcx: TyCtxt<'_>, parent: HirId, pat_id: Option<HirId>) -> L\n         }) if Some(*hir_id) == pat_id => {\n             return LetSource::IfLetGuard;\n         }\n-        hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Let(..), span, .. }) => {\n-            let expn_data = span.ctxt().outer_expn_data();\n-            if let ExpnKind::Desugaring(DesugaringKind::LetElse) = expn_data.kind {\n-                return LetSource::LetElse(expn_data.call_site);\n-            }\n-        }\n         _ => {}\n     }\n \n     let parent_parent = hir.get_parent_node(parent);\n     let parent_parent_node = hir.get(parent_parent);\n+    if let hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(_), span, .. }) =\n+        parent_parent_node\n+    {\n+        return LetSource::LetElse(*span);\n+    }\n \n     let parent_parent_parent = hir.get_parent_node(parent_parent);\n     let parent_parent_parent_parent = hir.get_parent_node(parent_parent_parent);"}, {"sha": "c48aa9a90efbed5bcea47076471e9b0366ced87c", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -102,7 +102,7 @@ fn is_needs_drop_and_init<'tcx>(\n     let field_needs_drop_and_init = |(f, f_ty, mpi)| {\n         let child = move_path_children_matching(move_data, mpi, |x| x.is_field_to(f));\n         let Some(mpi) = child else {\n-            return f_ty.needs_drop(tcx, param_env);\n+            return Ty::needs_drop(f_ty, tcx, param_env);\n         };\n \n         is_needs_drop_and_init(tcx, param_env, maybe_inits, move_data, f_ty, mpi)"}, {"sha": "eed3e1579a2313fc6bd67de639bb633d4250f8c7", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> IrMaps<'tcx> {\n                     pats.extend(inner_pat.iter());\n                 }\n                 Struct(_, fields, _) => {\n-                    let (short, not_short): (Vec<&_>, Vec<&_>) =\n+                    let (short, not_short): (Vec<_>, _) =\n                         fields.iter().partition(|f| f.is_shorthand);\n                     shorthand_field_ids.extend(short.iter().map(|f| f.pat.hir_id));\n                     pats.extend(not_short.iter().map(|f| f.pat));\n@@ -298,7 +298,7 @@ impl<'tcx> IrMaps<'tcx> {\n             }\n         }\n \n-        return shorthand_field_ids;\n+        shorthand_field_ids\n     }\n \n     fn add_from_pat(&mut self, pat: &hir::Pat<'tcx>) {\n@@ -368,6 +368,9 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n \n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.add_from_pat(&local.pat);\n+        if local.els.is_some() {\n+            self.add_live_node_for_node(local.hir_id, ExprNode(local.span, local.hir_id));\n+        }\n         intravisit::walk_local(self, local);\n     }\n \n@@ -800,8 +803,40 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // initialization, which is mildly more complex than checking\n                 // once at the func header but otherwise equivalent.\n \n-                let succ = self.propagate_through_opt_expr(local.init, succ);\n-                self.define_bindings_in_pat(&local.pat, succ)\n+                if let Some(els) = local.els {\n+                    // Eventually, `let pat: ty = init else { els };` is mostly equivalent to\n+                    // `let (bindings, ...) = match init { pat => (bindings, ...), _ => els };`\n+                    // except that extended lifetime applies at the `init` location.\n+                    //\n+                    //       (e)\n+                    //        |\n+                    //        v\n+                    //      (expr)\n+                    //      /   \\\n+                    //     |     |\n+                    //     v     v\n+                    // bindings  els\n+                    //     |\n+                    //     v\n+                    // ( succ )\n+                    //\n+                    if let Some(init) = local.init {\n+                        let else_ln = self.propagate_through_block(els, succ);\n+                        let ln = self.live_node(local.hir_id, local.span);\n+                        self.init_from_succ(ln, succ);\n+                        self.merge_from_succ(ln, else_ln);\n+                        let succ = self.propagate_through_expr(init, ln);\n+                        self.define_bindings_in_pat(&local.pat, succ)\n+                    } else {\n+                        span_bug!(\n+                            stmt.span,\n+                            \"variable is uninitialized but an unexpected else branch is found\"\n+                        )\n+                    }\n+                } else {\n+                    let succ = self.propagate_through_opt_expr(local.init, succ);\n+                    self.define_bindings_in_pat(&local.pat, succ)\n+                }\n             }\n             hir::StmtKind::Item(..) => succ,\n             hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n@@ -1121,7 +1156,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //     (rvalue)          ||       (rvalue)\n         //         |             ||           |\n         //         v             ||           v\n-        // (write of place)     ||   (place components)\n+        // (write of place)      ||   (place components)\n         //         |             ||           |\n         //         v             ||           v\n         //      (succ)           ||        (succ)"}, {"sha": "a4175f4c5f37731a9e8cc0aa679760cf16130038", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -82,14 +82,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     pub fn new(save_ctxt: SaveContext<'tcx>) -> DumpVisitor<'tcx> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         let dumper = Dumper::new(save_ctxt.config.clone());\n-        DumpVisitor {\n-            tcx: save_ctxt.tcx,\n-            save_ctxt,\n-            dumper,\n-            span: span_utils,\n-            // mac_defs: FxHashSet::default(),\n-            // macro_calls: FxHashSet::default(),\n-        }\n+        DumpVisitor { tcx: save_ctxt.tcx, save_ctxt, dumper, span: span_utils }\n     }\n \n     pub fn analysis(&self) -> &rls_data::Analysis {\n@@ -1425,9 +1418,10 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         self.process_macro_use(l.span);\n         self.process_var_decl(&l.pat);\n \n-        // Just walk the initializer and type (don't want to walk the pattern again).\n+        // Just walk the initializer, the else branch and type (don't want to walk the pattern again).\n         walk_list!(self, visit_ty, &l.ty);\n         walk_list!(self, visit_expr, &l.init);\n+        walk_list!(self, visit_block, l.els);\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {"}, {"sha": "29879c48b04ae04fab3eb75a4ebc4c00d35963cf", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1141,7 +1141,6 @@ pub enum DesugaringKind {\n     Async,\n     Await,\n     ForLoop,\n-    LetElse,\n     WhileLoop,\n }\n \n@@ -1157,7 +1156,6 @@ impl DesugaringKind {\n             DesugaringKind::YeetExpr => \"`do yeet` expression\",\n             DesugaringKind::OpaqueTy => \"`impl Trait`\",\n             DesugaringKind::ForLoop => \"`for` loop\",\n-            DesugaringKind::LetElse => \"`let...else`\",\n             DesugaringKind::WhileLoop => \"`while` loop\",\n         }\n     }"}, {"sha": "b08fc482186029fbbe3f818e6e11353ac39bd371", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         visitor.visit_body(&body);\n \n         let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n-        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id) else { return false; };\n+        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n \n         let ret_types = visitor\n             .returns"}, {"sha": "30b76b922c77a7f06e0ce77a26b2d7527943093d", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -997,26 +997,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n         if let Some(else_expr) = opt_else_expr {\n-            let else_ty = if sp.desugaring_kind() == Some(DesugaringKind::LetElse) {\n-                // todo introduce `check_expr_with_expectation(.., Expectation::LetElse)`\n-                //   for errors that point to the offending expression rather than the entire block.\n-                //   We could use `check_expr_eq_type(.., tcx.types.never)`, but then there is no\n-                //   way to detect that the expected type originated from let-else and provide\n-                //   a customized error.\n-                let else_ty = self.check_expr(else_expr);\n-                let cause = self.cause(else_expr.span, ObligationCauseCode::LetElse);\n-\n-                if let Some(mut err) =\n-                    self.demand_eqtype_with_origin(&cause, self.tcx.types.never, else_ty)\n-                {\n-                    err.emit();\n-                    self.tcx.ty_error()\n-                } else {\n-                    else_ty\n-                }\n-            } else {\n-                self.check_expr_with_expectation(else_expr, expected)\n-            };\n+            let else_ty = self.check_expr_with_expectation(else_expr, expected);\n             let else_diverges = self.diverges.get();\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(else_ty, orig_expected);"}, {"sha": "60ee2233ed9c0f7311ebe20282e308faf7827da6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1215,6 +1215,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_pat_top(&decl.pat, decl_ty, ty_span, origin_expr);\n         let pat_ty = self.node_ty(decl.pat.hir_id);\n         self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, pat_ty);\n+\n+        if let Some(blk) = decl.els {\n+            let previous_diverges = self.diverges.get();\n+            let else_ty = self.check_block_with_expected(blk, NoExpectation);\n+            let cause = self.cause(blk.span, ObligationCauseCode::LetElse);\n+            if let Some(mut err) =\n+                self.demand_eqtype_with_origin(&cause, self.tcx.types.never, else_ty)\n+            {\n+                err.emit();\n+            }\n+            self.diverges.set(previous_diverges);\n+        }\n     }\n \n     /// Type check a `let` statement.\n@@ -1236,8 +1248,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let old_has_errors = self.has_errors.replace(false);\n \n         match stmt.kind {\n-            hir::StmtKind::Local(ref l) => {\n-                self.check_decl_local(&l);\n+            hir::StmtKind::Local(l) => {\n+                self.check_decl_local(l);\n             }\n             // Ignore for now.\n             hir::StmtKind::Item(_) => {}"}, {"sha": "8f34a970f6ff7694ea9eb69468d0392e0e21f934", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -16,19 +16,20 @@ pub(super) struct Declaration<'a> {\n     pub ty: Option<&'a hir::Ty<'a>>,\n     pub span: Span,\n     pub init: Option<&'a hir::Expr<'a>>,\n+    pub els: Option<&'a hir::Block<'a>>,\n }\n \n impl<'a> From<&'a hir::Local<'a>> for Declaration<'a> {\n     fn from(local: &'a hir::Local<'a>) -> Self {\n-        let hir::Local { hir_id, pat, ty, span, init, .. } = *local;\n-        Declaration { hir_id, pat, ty, span, init }\n+        let hir::Local { hir_id, pat, ty, span, init, els, source: _ } = *local;\n+        Declaration { hir_id, pat, ty, span, init, els }\n     }\n }\n \n impl<'a> From<&'a hir::Let<'a>> for Declaration<'a> {\n     fn from(let_expr: &'a hir::Let<'a>) -> Self {\n         let hir::Let { hir_id, pat, ty, span, init } = *let_expr;\n-        Declaration { hir_id, pat, ty, span, init: Some(init) }\n+        Declaration { hir_id, pat, ty, span, init: Some(init), els: None }\n     }\n }\n \n@@ -101,7 +102,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n         self.declare(local.into());\n-        intravisit::walk_local(self, local);\n+        intravisit::walk_local(self, local)\n     }\n \n     fn visit_let_expr(&mut self, let_expr: &'tcx hir::Let<'tcx>) {"}, {"sha": "a1a92c62ad22f070af9be63604a71e45329dc3e6", "filename": "compiler/rustc_typeck/src/check/region.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregion.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -460,6 +460,7 @@ fn resolve_local<'tcx>(\n     visitor: &mut RegionResolutionVisitor<'tcx>,\n     pat: Option<&'tcx hir::Pat<'tcx>>,\n     init: Option<&'tcx hir::Expr<'tcx>>,\n+    els: Option<&'tcx hir::Block<'tcx>>,\n ) {\n     debug!(\"resolve_local(pat={:?}, init={:?})\", pat, init);\n \n@@ -537,13 +538,18 @@ fn resolve_local<'tcx>(\n         }\n     }\n \n-    // Make sure we visit the initializer first, so expr_and_pat_count remains correct\n+    // Make sure we visit the initializer first, so expr_and_pat_count remains correct.\n+    // The correct order, as shared between generator_interior, drop_ranges and intravisitor,\n+    // is to walk initializer, followed by pattern bindings, finally followed by the `else` block.\n     if let Some(expr) = init {\n         visitor.visit_expr(expr);\n     }\n     if let Some(pat) = pat {\n         visitor.visit_pat(pat);\n     }\n+    if let Some(els) = els {\n+        visitor.visit_block(els);\n+    }\n \n     /// Returns `true` if `pat` match the `P&` non-terminal.\n     ///\n@@ -764,7 +770,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             // (i.e., `'static`), which means that after `g` returns, it drops,\n             // and all the associated destruction scope rules apply.\n             self.cx.var_parent = None;\n-            resolve_local(self, None, Some(&body.value));\n+            resolve_local(self, None, Some(&body.value), None);\n         }\n \n         if body.generator_kind.is_some() {\n@@ -791,7 +797,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n         resolve_expr(self, ex);\n     }\n     fn visit_local(&mut self, l: &'tcx Local<'tcx>) {\n-        resolve_local(self, Some(&l.pat), l.init);\n+        resolve_local(self, Some(&l.pat), l.init, l.els)\n     }\n }\n "}, {"sha": "9d7420acd2662661182420ba50673dc733fddb87", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 115, "deletions": 91, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -2,7 +2,10 @@\n //! normal visitor, which just walks the entire body in one shot, the\n //! `ExprUseVisitor` determines how expressions are being used.\n \n+use std::slice::from_ref;\n+\n use hir::def::DefKind;\n+use hir::Expr;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n@@ -252,96 +255,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Let(hir::Let { pat, init, .. }) => {\n-                self.walk_local(init, pat, |t| t.borrow_expr(init, ty::ImmBorrow));\n+                self.walk_local(init, pat, None, |t| t.borrow_expr(init, ty::ImmBorrow))\n             }\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n                 let discr_place = return_if_err!(self.mc.cat_expr(discr));\n-\n-                // Matching should not always be considered a use of the place, hence\n-                // discr does not necessarily need to be borrowed.\n-                // We only want to borrow discr if the pattern contain something other\n-                // than wildcards.\n-                let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n-                let mut needs_to_be_read = false;\n-                for arm in arms.iter() {\n-                    return_if_err!(mc.cat_pattern(discr_place.clone(), arm.pat, |place, pat| {\n-                        match &pat.kind {\n-                            PatKind::Binding(.., opt_sub_pat) => {\n-                                // If the opt_sub_pat is None, than the binding does not count as\n-                                // a wildcard for the purpose of borrowing discr.\n-                                if opt_sub_pat.is_none() {\n-                                    needs_to_be_read = true;\n-                                }\n-                            }\n-                            PatKind::Path(qpath) => {\n-                                // A `Path` pattern is just a name like `Foo`. This is either a\n-                                // named constant or else it refers to an ADT variant\n-\n-                                let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n-                                match res {\n-                                    Res::Def(DefKind::Const, _)\n-                                    | Res::Def(DefKind::AssocConst, _) => {\n-                                        // Named constants have to be equated with the value\n-                                        // being matched, so that's a read of the value being matched.\n-                                        //\n-                                        // FIXME: We don't actually  reads for ZSTs.\n-                                        needs_to_be_read = true;\n-                                    }\n-                                    _ => {\n-                                        // Otherwise, this is a struct/enum variant, and so it's\n-                                        // only a read if we need to read the discriminant.\n-                                        needs_to_be_read |= is_multivariant_adt(place.place.ty());\n-                                    }\n-                                }\n-                            }\n-                            PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n-                                // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n-                                // against a multivariant enum or struct. In that case, we have to read\n-                                // the discriminant. Otherwise this kind of pattern doesn't actually\n-                                // read anything (we'll get invoked for the `...`, which may indeed\n-                                // perform some reads).\n-\n-                                let place_ty = place.place.ty();\n-                                needs_to_be_read |= is_multivariant_adt(place_ty);\n-                            }\n-                            PatKind::Lit(_) | PatKind::Range(..) => {\n-                                // If the PatKind is a Lit or a Range then we want\n-                                // to borrow discr.\n-                                needs_to_be_read = true;\n-                            }\n-                            PatKind::Or(_)\n-                            | PatKind::Box(_)\n-                            | PatKind::Slice(..)\n-                            | PatKind::Ref(..)\n-                            | PatKind::Wild => {\n-                                // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n-                                // as these patterns contains subpatterns\n-                                // If the PatKind is Wild, the decision is made based on the other patterns being\n-                                // examined\n-                            }\n-                        }\n-                    }));\n-                }\n-\n-                if needs_to_be_read {\n-                    self.borrow_expr(discr, ty::ImmBorrow);\n-                } else {\n-                    let closure_def_id = match discr_place.place.base {\n-                        PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n-                        _ => None,\n-                    };\n-\n-                    self.delegate.fake_read(\n-                        &discr_place,\n-                        FakeReadCause::ForMatchedPlace(closure_def_id),\n-                        discr_place.hir_id,\n-                    );\n-\n-                    // We always want to walk the discriminant. We want to make sure, for instance,\n-                    // that the discriminant has been initialized.\n-                    self.walk_expr(discr);\n-                }\n+                self.maybe_read_scrutinee(\n+                    discr,\n+                    discr_place.clone(),\n+                    arms.iter().map(|arm| arm.pat),\n+                );\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -453,8 +376,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n-            hir::StmtKind::Local(hir::Local { pat, init: Some(expr), .. }) => {\n-                self.walk_local(expr, pat, |_| {});\n+            hir::StmtKind::Local(hir::Local { pat, init: Some(expr), els, .. }) => {\n+                self.walk_local(expr, pat, *els, |_| {})\n             }\n \n             hir::StmtKind::Local(_) => {}\n@@ -470,13 +393,114 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn walk_local<F>(&mut self, expr: &hir::Expr<'_>, pat: &hir::Pat<'_>, mut f: F)\n-    where\n+    fn maybe_read_scrutinee<'t>(\n+        &mut self,\n+        discr: &Expr<'_>,\n+        discr_place: PlaceWithHirId<'tcx>,\n+        pats: impl Iterator<Item = &'t hir::Pat<'t>>,\n+    ) {\n+        // Matching should not always be considered a use of the place, hence\n+        // discr does not necessarily need to be borrowed.\n+        // We only want to borrow discr if the pattern contain something other\n+        // than wildcards.\n+        let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n+        let mut needs_to_be_read = false;\n+        for pat in pats {\n+            return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n+                match &pat.kind {\n+                    PatKind::Binding(.., opt_sub_pat) => {\n+                        // If the opt_sub_pat is None, than the binding does not count as\n+                        // a wildcard for the purpose of borrowing discr.\n+                        if opt_sub_pat.is_none() {\n+                            needs_to_be_read = true;\n+                        }\n+                    }\n+                    PatKind::Path(qpath) => {\n+                        // A `Path` pattern is just a name like `Foo`. This is either a\n+                        // named constant or else it refers to an ADT variant\n+\n+                        let res = self.mc.typeck_results.qpath_res(qpath, pat.hir_id);\n+                        match res {\n+                            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {\n+                                // Named constants have to be equated with the value\n+                                // being matched, so that's a read of the value being matched.\n+                                //\n+                                // FIXME: We don't actually  reads for ZSTs.\n+                                needs_to_be_read = true;\n+                            }\n+                            _ => {\n+                                // Otherwise, this is a struct/enum variant, and so it's\n+                                // only a read if we need to read the discriminant.\n+                                needs_to_be_read |= is_multivariant_adt(place.place.ty());\n+                            }\n+                        }\n+                    }\n+                    PatKind::TupleStruct(..) | PatKind::Struct(..) | PatKind::Tuple(..) => {\n+                        // For `Foo(..)`, `Foo { ... }` and `(...)` patterns, check if we are matching\n+                        // against a multivariant enum or struct. In that case, we have to read\n+                        // the discriminant. Otherwise this kind of pattern doesn't actually\n+                        // read anything (we'll get invoked for the `...`, which may indeed\n+                        // perform some reads).\n+\n+                        let place_ty = place.place.ty();\n+                        needs_to_be_read |= is_multivariant_adt(place_ty);\n+                    }\n+                    PatKind::Lit(_) | PatKind::Range(..) => {\n+                        // If the PatKind is a Lit or a Range then we want\n+                        // to borrow discr.\n+                        needs_to_be_read = true;\n+                    }\n+                    PatKind::Or(_)\n+                    | PatKind::Box(_)\n+                    | PatKind::Slice(..)\n+                    | PatKind::Ref(..)\n+                    | PatKind::Wild => {\n+                        // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n+                        // as these patterns contains subpatterns\n+                        // If the PatKind is Wild, the decision is made based on the other patterns being\n+                        // examined\n+                    }\n+                }\n+            }));\n+        }\n+\n+        if needs_to_be_read {\n+            self.borrow_expr(discr, ty::ImmBorrow);\n+        } else {\n+            let closure_def_id = match discr_place.place.base {\n+                PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n+                _ => None,\n+            };\n+\n+            self.delegate.fake_read(\n+                &discr_place,\n+                FakeReadCause::ForMatchedPlace(closure_def_id),\n+                discr_place.hir_id,\n+            );\n+\n+            // We always want to walk the discriminant. We want to make sure, for instance,\n+            // that the discriminant has been initialized.\n+            self.walk_expr(discr);\n+        }\n+    }\n+\n+    fn walk_local<F>(\n+        &mut self,\n+        expr: &hir::Expr<'_>,\n+        pat: &hir::Pat<'_>,\n+        els: Option<&hir::Block<'_>>,\n+        mut f: F,\n+    ) where\n         F: FnMut(&mut Self),\n     {\n         self.walk_expr(expr);\n         let expr_place = return_if_err!(self.mc.cat_expr(expr));\n         f(self);\n+        if let Some(els) = els {\n+            // borrowing because we need to test the descriminant\n+            self.maybe_read_scrutinee(expr, expr_place.clone(), from_ref(pat).iter());\n+            self.walk_block(els)\n+        }\n         self.walk_irrefutable_pat(&expr_place, &pat);\n     }\n \n@@ -667,7 +691,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         let ExprUseVisitor { ref mc, body_owner: _, ref mut delegate } = *self;\n         return_if_err!(mc.cat_pattern(discr_place.clone(), pat, |place, pat| {\n             if let PatKind::Binding(_, canonical_id, ..) = pat.kind {\n-                debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat,);\n+                debug!(\"walk_pat: binding place={:?} pat={:?}\", place, pat);\n                 if let Some(bm) =\n                     mc.typeck_results.extract_binding_mode(tcx.sess, pat.hir_id, pat.span)\n                 {"}, {"sha": "7ea07ae9add1bd7c66430df957460f1235de7dd7", "filename": "src/test/ui/async-await/async-await-let-else.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -0,0 +1,53 @@\n+// edition:2021\n+#![feature(let_else)]\n+use std::rc::Rc;\n+\n+async fn foo(x: Option<bool>) {\n+    let Some(_) = x else {\n+        let r = Rc::new(());\n+        bar().await\n+    };\n+}\n+\n+async fn bar() -> ! {\n+    panic!()\n+}\n+\n+fn is_send<T: Send>(_: T) {}\n+\n+async fn foo2(x: Option<bool>) {\n+    let Some(_) = x else {\n+        bar2(Rc::new(())).await\n+    };\n+}\n+\n+async fn bar2<T>(_: T) -> ! {\n+    panic!()\n+}\n+\n+async fn foo3(x: Option<bool>) {\n+    let Some(_) = x else {\n+        (Rc::new(()), bar().await);\n+        return;\n+    };\n+}\n+\n+async fn foo4(x: Option<bool>) {\n+    let Some(_) = x else {\n+        let r = Rc::new(());\n+        bar().await;\n+        println!(\"{:?}\", r);\n+        return;\n+    };\n+}\n+\n+fn main() {\n+    is_send(foo(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo2(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo3(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+    is_send(foo4(Some(true)));\n+    //~^ ERROR future cannot be sent between threads safely\n+}"}, {"sha": "4d23e27c426b280a0ca768942c3140c3a3345ae5", "filename": "src/test/ui/async-await/async-await-let-else.stderr", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-await-let-else.stderr?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -0,0 +1,94 @@\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:45:13\n+   |\n+LL |     is_send(foo(Some(true)));\n+   |             ^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:8:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:47:13\n+   |\n+LL |     is_send(foo2(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo2` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:20:26\n+   |\n+LL |         bar2(Rc::new(())).await\n+   |              ----------- ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n+   |              |\n+   |              has type `Rc<()>` which is not `Send`\n+LL |     };\n+   |      - `Rc::new(())` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:49:13\n+   |\n+LL |     is_send(foo3(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo3` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:30:28\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |          -----------       ^^^^^^ await occurs here, with `Rc::new(())` maybe used later\n+   |          |\n+   |          has type `Rc<()>` which is not `Send`\n+note: `Rc::new(())` is later dropped here\n+  --> $DIR/async-await-let-else.rs:30:35\n+   |\n+LL |         (Rc::new(()), bar().await);\n+   |                                   ^\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: future cannot be sent between threads safely\n+  --> $DIR/async-await-let-else.rs:51:13\n+   |\n+LL |     is_send(foo4(Some(true)));\n+   |             ^^^^^^^^^^^^^^^^ future returned by `foo4` is not `Send`\n+   |\n+   = help: within `impl Future<Output = ()>`, the trait `Send` is not implemented for `Rc<()>`\n+note: future is not `Send` as this value is used across an await\n+  --> $DIR/async-await-let-else.rs:38:14\n+   |\n+LL |         let r = Rc::new(());\n+   |             - has type `Rc<()>` which is not `Send`\n+LL |         bar().await;\n+   |              ^^^^^^ await occurs here, with `r` maybe used later\n+...\n+LL |     };\n+   |     - `r` is later dropped here\n+note: required by a bound in `is_send`\n+  --> $DIR/async-await-let-else.rs:16:15\n+   |\n+LL | fn is_send<T: Send>(_: T) {}\n+   |               ^^^^ required by this bound in `is_send`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "065787cab08ff65200d12ac52469bb05d39d700f", "filename": "src/test/ui/let-else/let-else-binding-explicit-mut-annotated.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-binding-explicit-mut-annotated.stderr?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-binding-explicit-mut-annotated.rs:9:37\n    |\n LL |     let Some(n): &mut Option<i32> = &&Some(5i32) else { return };\n-   |                                     ^^^^^^^^^^^^ types differ in mutability\n+   |                  ----------------   ^^^^^^^^^^^^ types differ in mutability\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected mutable reference `&mut Option<i32>`\n                       found reference `&&Option<i32>`\n@@ -11,7 +13,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-binding-explicit-mut-annotated.rs:13:37\n    |\n LL |     let Some(n): &mut Option<i32> = &&mut Some(5i32) else { return };\n-   |                                     ^^^^^^^^^^^^^^^^ types differ in mutability\n+   |                  ----------------   ^^^^^^^^^^^^^^^^ types differ in mutability\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected mutable reference `&mut Option<i32>`\n                       found reference `&&mut Option<i32>`"}, {"sha": "3d647a4c05d86524167bc57b84e279597b8924ed", "filename": "src/test/ui/let-else/let-else-check.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-check.stderr?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1,8 +1,8 @@\n error: unused variable: `x`\n-  --> $DIR/let-else-check.rs:18:9\n+  --> $DIR/let-else-check.rs:14:13\n    |\n-LL |     let x = 1;\n-   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n+LL |         let x = 1;\n+   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n    |\n note: the lint level is defined here\n   --> $DIR/let-else-check.rs:3:9\n@@ -11,10 +11,10 @@ LL | #![deny(unused_variables)]\n    |         ^^^^^^^^^^^^^^^^\n \n error: unused variable: `x`\n-  --> $DIR/let-else-check.rs:14:13\n+  --> $DIR/let-else-check.rs:18:9\n    |\n-LL |         let x = 1;\n-   |             ^ help: if this is intentional, prefix it with an underscore: `_x`\n+LL |     let x = 1;\n+   |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "05e45f689890d00eb9371766348a90b40927ce90", "filename": "src/test/ui/let-else/let-else-non-diverging.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-non-diverging.stderr?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: `else` clause of `let...else` does not diverge\n-  --> $DIR/let-else-non-diverging.rs:12:32\n+  --> $DIR/let-else-non-diverging.rs:4:32\n    |\n-LL |     let Some(x) = Some(1) else { Some(2) };\n-   |                                ^^^^^^^^^^^ expected `!`, found enum `Option`\n+LL |       let Some(x) = Some(1) else {\n+   |  ________________________________^\n+LL | |         Some(2)\n+LL | |     };\n+   | |_____^ expected `!`, found enum `Option`\n    |\n    = note: expected type `!`\n               found enum `Option<{integer}>`\n@@ -26,13 +29,10 @@ LL | |     };\n    = help: ...or use `match` instead of `let...else`\n \n error[E0308]: `else` clause of `let...else` does not diverge\n-  --> $DIR/let-else-non-diverging.rs:4:32\n+  --> $DIR/let-else-non-diverging.rs:12:32\n    |\n-LL |       let Some(x) = Some(1) else {\n-   |  ________________________________^\n-LL | |         Some(2)\n-LL | |     };\n-   | |_____^ expected `!`, found enum `Option`\n+LL |     let Some(x) = Some(1) else { Some(2) };\n+   |                                ^^^^^^^^^^^ expected `!`, found enum `Option`\n    |\n    = note: expected type `!`\n               found enum `Option<{integer}>`"}, {"sha": "56b9e073330a6237817715f5c4827f70d6f30fad", "filename": "src/test/ui/let-else/let-else-ref-bindings.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-ref-bindings.stderr?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -20,7 +20,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:24:34\n    |\n LL |     let Some(a): Option<&[u8]> = some else { return };\n-   |                                  ^^^^ expected `&[u8]`, found struct `Vec`\n+   |                  -------------   ^^^^ expected `&[u8]`, found struct `Vec`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected enum `Option<&[u8]>`\n               found enum `Option<Vec<u8>>`\n@@ -29,7 +31,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:27:34\n    |\n LL |     let Some(a): Option<&[u8]> = &some else { return };\n-   |                                  ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |                  -------------   ^^^^^ expected enum `Option`, found `&Option<Vec<u8>>`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note:   expected enum `Option<&[u8]>`\n            found reference `&Option<Vec<u8>>`\n@@ -56,7 +60,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:52:38\n    |\n LL |     let Some(a): Option<&mut [u8]> = some else { return };\n-   |                                      ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |                  -----------------   ^^^^ expected `&mut [u8]`, found struct `Vec`\n+   |                  |\n+   |                  expected due to this\n    |\n    = note: expected enum `Option<&mut [u8]>`\n               found enum `Option<Vec<u8>>`\n@@ -65,7 +71,9 @@ error[E0308]: mismatched types\n   --> $DIR/let-else-ref-bindings.rs:55:38\n    |\n LL |     let Some(a): Option<&mut [u8]> = &mut some else { return };\n-   |                                      ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |                  -----------------   ^^^^^^^^^ expected enum `Option`, found mutable reference\n+   |                  |\n+   |                  expected due to this\n    |\n    = note:           expected enum `Option<&mut [u8]>`\n            found mutable reference `&mut Option<Vec<u8>>`"}, {"sha": "624c2ea37a70bc758a8b08880ba5ebdbe7f70af3", "filename": "src/test/ui/let-else/let-else-temporary-lifetime.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet-else%2Flet-else-temporary-lifetime.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -0,0 +1,25 @@\n+// run-pass\n+#![feature(let_else)]\n+\n+use std::sync::atomic::{AtomicU8, Ordering};\n+\n+static TRACKER: AtomicU8 = AtomicU8::new(0);\n+\n+#[derive(Default)]\n+struct Droppy {\n+    inner: u32,\n+}\n+\n+impl Drop for Droppy {\n+    fn drop(&mut self) {\n+        TRACKER.store(1, Ordering::Release);\n+        println!(\"I've been dropped\");\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(TRACKER.load(Ordering::Acquire), 0);\n+    let 0 = Droppy::default().inner else { return };\n+    assert_eq!(TRACKER.load(Ordering::Acquire), 1);\n+    println!(\"Should have dropped \ud83d\udc46\");\n+}"}, {"sha": "ca617859db49d713ea5fe3ffa4fc0aaa52e0f771", "filename": "src/tools/clippy/clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -11,7 +11,7 @@ use rustc_lint::LateContext;\n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'tcx Block<'_>) {\n     let (init, has_trailing_exprs) = match (loop_block.stmts, loop_block.expr) {\n         ([stmt, stmts @ ..], expr) => {\n-            if let StmtKind::Local(&Local { init: Some(e), .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n+            if let StmtKind::Local(&Local { init: Some(e), els: None, .. }) | StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind {\n                 (e, !stmts.is_empty() || expr.is_some())\n             } else {\n                 return;"}, {"sha": "3077b999f4ee445f72716412911a1238eb2d4276", "filename": "src/tools/clippy/clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -1041,7 +1041,8 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        self.infallible_destructuring_match_linted |= infallible_destructuring_match::check(cx, local);\n+        self.infallible_destructuring_match_linted |=\n+            local.els.is_none() && infallible_destructuring_match::check(cx, local);\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {"}, {"sha": "819646bb6780e98099d405f0a1bd8993de003393", "filename": "src/tools/clippy/clippy_lints/src/no_effect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fno_effect.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -92,6 +92,7 @@ fn check_no_effect(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n         if_chain! {\n             if !is_lint_allowed(cx, NO_EFFECT_UNDERSCORE_BINDING, local.hir_id);\n             if let Some(init) = local.init;\n+            if local.els.is_none();\n             if !local.pat.span.from_expansion();\n             if has_no_effect(cx, init);\n             if let PatKind::Binding(_, _, ident, _) = local.pat.kind;"}, {"sha": "1d9a2abf7066c8819b61a42faacde644a72eb94a", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -10,7 +10,6 @@ use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n \n@@ -203,9 +202,7 @@ fn check_final_expr<'tcx>(\n                 check_block_return(cx, ifblock);\n             }\n             if let Some(else_clause) = else_clause_opt {\n-                if expr.span.desugaring_kind() != Some(DesugaringKind::LetElse) {\n-                    check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n-                }\n+                check_final_expr(cx, else_clause, None, RetReplacement::Empty);\n             }\n         },\n         // a match expr, check all arms"}, {"sha": "942f14ddd3d51337637ded33c8dde63aeb84744b", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0083cd2fd498edb6a4e37bf4c711d11364e0ef20/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=0083cd2fd498edb6a4e37bf4c711d11364e0ef20", "patch": "@@ -102,7 +102,7 @@ pub struct HirEqInterExpr<'a, 'b, 'tcx> {\n impl HirEqInterExpr<'_, '_, '_> {\n     pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n-            (&StmtKind::Local(l), &StmtKind::Local(r)) => {\n+            (&StmtKind::Local(l, ), &StmtKind::Local(r, )) => {\n                 // This additional check ensures that the type of the locals are equivalent even if the init\n                 // expression or type have some inferred parts.\n                 if let Some((typeck_lhs, typeck_rhs)) = self.inner.maybe_typeck_results {\n@@ -117,6 +117,7 @@ impl HirEqInterExpr<'_, '_, '_> {\n                 // these only get added if the init and type is equal.\n                 both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n                     && both(&l.ty, &r.ty, |l, r| self.eq_ty(l, r))\n+                    && both(&l.els, &r.els, |l, r| self.eq_block(l, r))\n                     && self.eq_pat(l.pat, r.pat)\n             },\n             (&StmtKind::Expr(l), &StmtKind::Expr(r)) | (&StmtKind::Semi(l), &StmtKind::Semi(r)) => self.eq_expr(l, r),\n@@ -921,11 +922,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         std::mem::discriminant(&b.kind).hash(&mut self.s);\n \n         match &b.kind {\n-            StmtKind::Local(local) => {\n+            StmtKind::Local(local, ) => {\n                 self.hash_pat(local.pat);\n                 if let Some(init) = local.init {\n                     self.hash_expr(init);\n                 }\n+                if let Some(els) = local.els {\n+                    self.hash_block(els);\n+                }\n             },\n             StmtKind::Item(..) => {},\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => {"}]}