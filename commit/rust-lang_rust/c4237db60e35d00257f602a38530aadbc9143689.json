{"sha": "c4237db60e35d00257f602a38530aadbc9143689", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MjM3ZGI2MGUzNWQwMDI1N2Y2MDJhMzg1MzBhYWRiYzkxNDM2ODk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T19:07:02Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-11T19:07:02Z"}, "message": "manual: capitalize examples, remove mention of named impls, change RC -> managed, clarify language.", "tree": {"sha": "6f6511ad101e37decec2bb26f03b6c3aa7392ead", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f6511ad101e37decec2bb26f03b6c3aa7392ead"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4237db60e35d00257f602a38530aadbc9143689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4237db60e35d00257f602a38530aadbc9143689", "html_url": "https://github.com/rust-lang/rust/commit/c4237db60e35d00257f602a38530aadbc9143689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4237db60e35d00257f602a38530aadbc9143689/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06a17a7ce5c2e6ff71fd6d24706dce15f51b8580", "url": "https://api.github.com/repos/rust-lang/rust/commits/06a17a7ce5c2e6ff71fd6d24706dce15f51b8580", "html_url": "https://github.com/rust-lang/rust/commit/06a17a7ce5c2e6ff71fd6d24706dce15f51b8580"}], "stats": {"total": 111, "additions": 54, "deletions": 57}, "files": [{"sha": "b2a1948ede47b9a79aa8ed0788e90202d65fd8fc", "filename": "doc/rust.md", "status": "modified", "additions": 54, "deletions": 57, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/c4237db60e35d00257f602a38530aadbc9143689/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c4237db60e35d00257f602a38530aadbc9143689/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c4237db60e35d00257f602a38530aadbc9143689", "patch": "@@ -1167,12 +1167,12 @@ or constrained by some other [trait type](#trait-types).\n Traits are implemented for specific types through separate [implementations](#implementations).\n \n ~~~~\n-# type surface = int;\n-# type bounding_box = int;\n+# type Surface = int;\n+# type BoundingBox = int;\n \n-trait shape {\n-    fn draw(surface);\n-    fn bounding_box() -> bounding_box;\n+trait Shape {\n+    fn draw(Surface);\n+    fn bounding_box() -> BoundingBox;\n }\n ~~~~\n \n@@ -1181,101 +1181,98 @@ All values that have [implementations](#implementations) of this trait in scope\n using `value.bounding_box()` [syntax](#method-call-expressions).\n \n Type parameters can be specified for a trait to make it generic.\n-These appear after the name, using the same syntax used in [generic\n-functions](#generic-functions).\n+These appear after the trait name, using the same syntax used in [generic functions](#generic-functions).\n \n ~~~~\n-trait seq<T> {\n+trait Seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n    fn iter(fn(T));\n }\n ~~~~\n \n-Generic functions may use traits as bounds on their type\n-parameters. This will have two effects: only types that have the trait\n-may instantiate the parameter, and within the\n-generic function, the methods of the trait can be called on values\n-that have the parameter's type. For example:\n+Generic functions may use traits as _bounds_ on their type parameters.\n+This will have two effects: only types that have the trait may instantiate the parameter,\n+and within the generic function,\n+the methods of the trait can be called on values that have the parameter's type.\n+For example:\n \n ~~~~\n-# type surface = int;\n-# trait shape { fn draw(surface); }\n+# type Surface = int;\n+# trait Shape { fn draw(Surface); }\n \n-fn draw_twice<T: shape>(surface: surface, sh: T) {\n+fn draw_twice<T: Shape>(surface: Surface, sh: T) {\n     sh.draw(surface);\n     sh.draw(surface);\n }\n ~~~~\n \n-Trait items also define a type with the same name as the\n-trait. Values of this type are created by\n-[casting](#type-cast-expressions) values (of a type for which an\n-implementation of the given trait is in scope) to the trait\n-type.\n+Traits also define a [type](#trait-types) with the same name as the trait.\n+Values of this type are created by [casting](#type-cast-expressions) pointer values\n+(pointing to a type for which an implementation of the given trait is in scope)\n+to pointers to the trait name, used as a type.\n \n ~~~~\n-# trait shape { }\n-# impl int: shape { }\n+# trait Shape { }\n+# impl int: Shape { }\n # let mycircle = 0;\n \n-let myshape: shape = mycircle as shape;\n+let myshape: Shape = @mycircle as @Shape;\n ~~~~\n \n-The resulting value is a reference-counted box containing the value\n-that was cast along with information that identify the methods of the\n-implementation that was used. Values with a trait type can always\n-have methods from their trait called on them, and can be used to\n-instantiate type parameters that are bounded by their trait.\n+The resulting value is a managed box containing the value that was cast,\n+along with information that identify the methods of the implementation that was used.\n+Values with a trait type can have [methods called](#method-call-expressions) on them,\n+for any method in the trait,\n+and can be used to instantiate type parameters that are bounded by the trait.\n \n ### Implementations\n \n-An _implementation item_ provides an implementation of a\n-[trait](#traits) for a type.\n+An _implementation_ is an item that implements a [trait](#traits) for a specific type.\n+\n+Implementations are defined with the keyword `impl`.\n \n ~~~~\n-# type point = {x: float, y: float};\n-# type surface = int;\n-# type bounding_box = {x: float, y: float, width: float, height: float};\n-# trait shape { fn draw(surface); fn bounding_box() -> bounding_box; }\n-# fn do_draw_circle(s: surface, c: circle) { }\n+# type Point = {x: float, y: float};\n+# type Surface = int;\n+# type BoundingBox = {x: float, y: float, width: float, height: float};\n+# trait Shape { fn draw(surface); fn bounding_box() -> BoundingBox; }\n+# fn do_draw_circle(s: Surface, c: Circle) { }\n \n-type circle = {radius: float, center: point};\n+type Circle = {radius: float, center: point};\n \n-impl circle: shape {\n-    fn draw(s: surface) { do_draw_circle(s, self); }\n-    fn bounding_box() -> bounding_box {\n+impl Circle: Shape {\n+    fn draw(s: Surface) { do_draw_circle(s, self); }\n+    fn bounding_box() -> BoundingBox {\n         let r = self.radius;\n         {x: self.center.x - r, y: self.center.y - r,\n          width: 2.0 * r, height: 2.0 * r}\n     }\n }\n ~~~~\n \n-It is possible to define an implementation without referring to a\n-trait.  The methods in such an implementation can only be used\n-statically (as direct calls on the values of the type that the\n-implementation targets). In such an implementation, the type after the colon is omitted,\n-and the name is mandatory.  Such implementations are\n-limited to nominal types (enums, structs) and the implementation must\n-appear in the same module or a sub-module as the receiver type.\n+It is possible to define an implementation without referring to a trait.\n+The methods in such an implementation can only be used statically\n+(as direct calls on the values of the type that the implementation targets).\n+In such an implementation, the type after the colon is omitted.\n+Such implementations are limited to nominal types (enums, structs),\n+and the implementation must appear in the same module or a sub-module as the `self` type.\n \n-_When_ a trait is specified, all methods declared as part of the\n-trait must be present, with matching types and type parameter\n-counts, in the implementation.\n+When a trait _is_ specified in an `impl`,\n+all methods declared as part of the trait must be implemented,\n+with matching types and type parameter counts.\n \n-An implementation can take type parameters, which can be different\n-from the type parameters taken by the trait it implements. They\n-are written after the name of the implementation, or if that is not\n-specified, after the `impl` keyword.\n+An implementation can take type parameters,\n+which can be different from the type parameters taken by the trait it implements.\n+Implementation parameters are written after after the `impl` keyword.\n \n ~~~~\n-# trait seq<T> { }\n+# trait Seq<T> { }\n \n-impl<T> ~[T]: seq<T> {\n+impl<T> ~[T]: Seq<T> {\n    ...\n }\n-impl u32: seq<bool> {\n+impl u32: Seq<bool> {\n    /* Treat the integer as a sequence of bits */\n }\n ~~~~"}]}