{"sha": "6710eef6b2165abef065c72c5fb57389b8e49441", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MTBlZWY2YjIxNjVhYmVmMDY1YzcyYzVmYjU3Mzg5YjhlNDk0NDE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-06T08:24:04Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-05-09T10:27:24Z"}, "message": "Refactor `hir::lowering::Resolver`", "tree": {"sha": "0162e77bc49bfdc4265baa80c24c14f8f173773f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0162e77bc49bfdc4265baa80c24c14f8f173773f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6710eef6b2165abef065c72c5fb57389b8e49441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6710eef6b2165abef065c72c5fb57389b8e49441", "html_url": "https://github.com/rust-lang/rust/commit/6710eef6b2165abef065c72c5fb57389b8e49441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6710eef6b2165abef065c72c5fb57389b8e49441/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6d6c379685243a877d52f05afd5e04129674194", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d6c379685243a877d52f05afd5e04129674194", "html_url": "https://github.com/rust-lang/rust/commit/e6d6c379685243a877d52f05afd5e04129674194"}], "stats": {"total": 193, "additions": 94, "deletions": 99}, "files": [{"sha": "0026412013c8eb881a8966d47e034fcf879ec09b", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 45, "deletions": 60, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=6710eef6b2165abef065c72c5fb57389b8e49441", "patch": "@@ -44,7 +44,7 @@ use hir;\n use hir::map::Definitions;\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n-use hir::def::{Def, DefMap, PathResolution};\n+use hir::def::Def;\n \n use std::collections::BTreeMap;\n use std::iter;\n@@ -68,15 +68,30 @@ pub struct LoweringContext<'a> {\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Cell<Option<DefIndex>>,\n-    resolver: Option<RefCell<&'a mut Resolver>>,\n+    resolver: RefCell<&'a mut Resolver>,\n }\n \n pub trait Resolver {\n+    // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n     fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n \n-    fn def_map(&mut self) -> &mut DefMap;\n+    // Record the resolution of a path or binding generated by the lowerer when expanding.\n+    fn record_resolution(&mut self, id: NodeId, def: Def);\n+\n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n-    fn definitions(&mut self) -> &mut Definitions;\n+    // This should only return `None` during testing.\n+    fn definitions(&mut self) -> Option<&mut Definitions>;\n+}\n+\n+pub struct DummyResolver;\n+impl Resolver for DummyResolver {\n+    fn resolve_generated_global_path(&mut self, _path: &hir::Path, _is_value: bool) -> Def {\n+        Def::Err\n+    }\n+    fn record_resolution(&mut self, _id: NodeId, _def: Def) {}\n+    fn definitions(&mut self) -> Option<&mut Definitions> {\n+        None\n+    }\n }\n \n impl<'a, 'hir> LoweringContext<'a> {\n@@ -98,18 +113,7 @@ impl<'a, 'hir> LoweringContext<'a> {\n             crate_root: crate_root,\n             id_assigner: id_assigner,\n             parent_def: Cell::new(None),\n-            resolver: Some(RefCell::new(resolver)),\n-        }\n-    }\n-\n-    // Only use this when you want a LoweringContext for testing and won't look\n-    // up def ids for anything created during lowering.\n-    pub fn testing_context(id_assigner: &'a NodeIdAssigner) -> LoweringContext<'a> {\n-        LoweringContext {\n-            crate_root: None,\n-            id_assigner: id_assigner,\n-            parent_def: Cell::new(None),\n-            resolver: None,\n+            resolver: RefCell::new(resolver),\n         }\n     }\n \n@@ -127,37 +131,17 @@ impl<'a, 'hir> LoweringContext<'a> {\n     }\n \n     fn with_parent_def<T, F: FnOnce() -> T>(&self, parent_id: NodeId, f: F) -> T {\n-        if self.resolver.is_none() {\n-            // This should only be used for testing.\n-            return f();\n-        }\n-\n         let old_def = self.parent_def.get();\n-        self.parent_def.set(Some(self.get_def(parent_id)));\n+        self.parent_def.set(match self.resolver.borrow_mut().definitions() {\n+            Some(defs) => Some(defs.opt_def_index(parent_id).unwrap()),\n+            None => old_def,\n+        });\n+\n         let result = f();\n-        self.parent_def.set(old_def);\n \n+        self.parent_def.set(old_def);\n         result\n     }\n-\n-    fn get_def(&self, id: NodeId) -> DefIndex {\n-        let mut resolver = self.resolver.as_ref().unwrap().borrow_mut();\n-        resolver.definitions().opt_def_index(id).unwrap()\n-    }\n-\n-    fn record_def(&self, id: NodeId, def: Def) {\n-        if let Some(ref resolver) = self.resolver {\n-            resolver.borrow_mut().def_map().insert(id, PathResolution { base_def: def, depth: 0 });\n-        }\n-    }\n-\n-    fn resolve_generated_global_path(&self, path: &hir::Path, is_value: bool) -> Def {\n-        if let Some(ref resolver) = self.resolver {\n-            resolver.borrow_mut().resolve_generated_global_path(path, is_value)\n-        } else {\n-            Def::Err\n-        }\n-    }\n }\n \n pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n@@ -1765,10 +1749,12 @@ fn expr_call(lctx: &LoweringContext,\n fn expr_ident(lctx: &LoweringContext, span: Span, id: hir::Ident,\n               attrs: ThinAttributes, binding: NodeId) -> P<hir::Expr> {\n     let expr = expr(lctx, span, hir::ExprPath(None, path_ident(span, id)), attrs);\n-    if let Some(ref resolver) = lctx.resolver {\n-        let def_id = resolver.borrow_mut().definitions().local_def_id(binding);\n-        lctx.record_def(expr.id, Def::Local(def_id, binding));\n-    }\n+\n+    let mut resolver = lctx.resolver.borrow_mut();\n+    let def = resolver.definitions().map(|defs| Def::Local(defs.local_def_id(binding), binding))\n+                                    .unwrap_or(Def::Err);\n+    resolver.record_resolution(expr.id, def);\n+\n     expr\n }\n \n@@ -1779,9 +1765,9 @@ fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n \n fn expr_path(lctx: &LoweringContext, path: hir::Path,\n              attrs: ThinAttributes) -> P<hir::Expr> {\n-    let def = lctx.resolve_generated_global_path(&path, true);\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, true);\n     let expr = expr(lctx, path.span, hir::ExprPath(None, path), attrs);\n-    lctx.record_def(expr.id, def);\n+    lctx.resolver.borrow_mut().record_resolution(expr.id, def);\n     expr\n }\n \n@@ -1811,9 +1797,9 @@ fn expr_struct(lctx: &LoweringContext,\n                fields: hir::HirVec<hir::Field>,\n                e: Option<P<hir::Expr>>,\n                attrs: ThinAttributes) -> P<hir::Expr> {\n-    let def = lctx.resolve_generated_global_path(&path, false);\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, false);\n     let expr = expr(lctx, sp, hir::ExprStruct(path, fields, e), attrs);\n-    lctx.record_def(expr.id, def);\n+    lctx.resolver.borrow_mut().record_resolution(expr.id, def);\n     expr\n \n }\n@@ -1900,14 +1886,14 @@ fn pat_enum(lctx: &LoweringContext,\n             path: hir::Path,\n             subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n-    let def = lctx.resolve_generated_global_path(&path, true);\n+    let def = lctx.resolver.borrow_mut().resolve_generated_global_path(&path, true);\n     let pt = if subpats.is_empty() {\n         hir::PatKind::Path(path)\n     } else {\n         hir::PatKind::TupleStruct(path, Some(subpats))\n     };\n     let pat = pat(lctx, span, pt);\n-    lctx.record_def(pat.id, def);\n+    lctx.resolver.borrow_mut().record_resolution(pat.id, def);\n     pat\n }\n \n@@ -1929,14 +1915,13 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n \n     let pat = pat(lctx, span, pat_ident);\n \n-    if let Some(ref resolver) = lctx.resolver {\n-        let def_index =\n-            resolver.borrow_mut().definitions()\n-                                 .create_def_with_parent(lctx.parent_def.get(),\n-                                                         pat.id,\n-                                                         DefPathData::Binding(ident.name));\n-        lctx.record_def(pat.id, Def::Local(DefId::local(def_index), pat.id));\n-    }\n+    let mut resolver = lctx.resolver.borrow_mut();\n+    let def = resolver.definitions().map(|defs| {\n+        let def_path_data = DefPathData::Binding(ident.name);\n+        let def_index = defs.create_def_with_parent(lctx.parent_def.get(), pat.id, def_path_data);\n+        Def::Local(DefId::local(def_index), pat.id)\n+    }).unwrap_or(Def::Err);\n+    resolver.record_resolution(pat.id, def);\n \n     pat\n }"}, {"sha": "56f6a3f7b14cb1605418a7a1beb36a6346a0f34e", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=6710eef6b2165abef065c72c5fb57389b8e49441", "patch": "@@ -57,7 +57,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n #[cfg(test)] use syntax::parse;\n #[cfg(test)] use syntax::ast::NodeId;\n #[cfg(test)] use rustc::hir::print as pprust;\n-#[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext};\n+#[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext, DummyResolver};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n@@ -1325,6 +1325,14 @@ fn mk_ctxt() -> parse::ParseSess {\n     parse::ParseSess::new()\n }\n \n+#[cfg(test)]\n+fn with_testing_context<T, F: FnOnce(LoweringContext) -> T>(f: F) -> T {\n+    let assigner = FakeNodeIdAssigner;\n+    let mut resolver = DummyResolver;\n+    let lcx = LoweringContext::new(&assigner, None, &mut resolver);\n+    f(lcx)\n+}\n+\n #[cfg(test)]\n fn roundtrip(in_item: hir::Item) {\n     let mut wr = Cursor::new(Vec::new());\n@@ -1338,34 +1346,34 @@ fn roundtrip(in_item: hir::Item) {\n #[test]\n fn test_basic() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo() {}\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo() {}\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n fn test_more() {\n     let cx = mk_ctxt();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    roundtrip(lower_item(&lcx, &quote_item!(&cx,\n-        fn foo(x: usize, y: usize) -> usize {\n-            let z = x + y;\n-            return z;\n-        }\n-    ).unwrap()));\n+    with_testing_context(|lcx| {\n+        roundtrip(lower_item(&lcx, &quote_item!(&cx,\n+            fn foo(x: usize, y: usize) -> usize {\n+                let z = x + y;\n+                return z;\n+            }\n+        ).unwrap()));\n+    });\n }\n \n #[test]\n@@ -1377,21 +1385,22 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let fnia = FakeNodeIdAssigner;\n-    let lcx = LoweringContext::testing_context(&fnia);\n-    let hir_item = lower_item(&lcx, &item);\n-    let item_in = InlinedItemRef::Item(&hir_item);\n-    let item_out = simplify_ast(item_in);\n-    let item_exp = InlinedItem::Item(P(lower_item(&lcx, &quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<isize, B> {\n-            return alist {eq_fn: eq_int, data: Vec::new()};\n+    let cx = mk_ctxt();\n+    with_testing_context(|lcx| {\n+        let hir_item = lower_item(&lcx, &item);\n+        let item_in = InlinedItemRef::Item(&hir_item);\n+        let item_out = simplify_ast(item_in);\n+        let item_exp = InlinedItem::Item(P(lower_item(&lcx, &quote_item!(&cx,\n+            fn new_int_alist<B>() -> alist<isize, B> {\n+                return alist {eq_fn: eq_int, data: Vec::new()};\n+            }\n+        ).unwrap())));\n+        match (item_out, item_exp) {\n+            (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n+                 assert!(pprust::item_to_string(&item_out) ==\n+                         pprust::item_to_string(&item_exp));\n+            }\n+            _ => bug!()\n         }\n-    ).unwrap())));\n-    match (item_out, item_exp) {\n-      (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n-        assert!(pprust::item_to_string(&item_out) ==\n-                pprust::item_to_string(&item_exp));\n-      }\n-      _ => bug!()\n-    }\n+    });\n }"}, {"sha": "0fb1c545870804bc690662c7d355b2cf0e911905", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6710eef6b2165abef065c72c5fb57389b8e49441/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6710eef6b2165abef065c72c5fb57389b8e49441", "patch": "@@ -1098,11 +1098,12 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         }\n     }\n \n-    fn def_map(&mut self) -> &mut DefMap {\n-        &mut self.def_map\n+    fn record_resolution(&mut self, id: NodeId, def: Def) {\n+        self.def_map.insert(id, PathResolution { base_def: def, depth: 0 });\n     }\n-    fn definitions(&mut self) -> &mut Definitions {\n-        self.definitions\n+\n+    fn definitions(&mut self) -> Option<&mut Definitions> {\n+        Some(self.definitions)\n     }\n }\n "}]}