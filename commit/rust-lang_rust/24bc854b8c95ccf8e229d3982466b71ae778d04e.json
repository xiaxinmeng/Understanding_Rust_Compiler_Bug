{"sha": "24bc854b8c95ccf8e229d3982466b71ae778d04e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YmM4NTRiOGM5NWNjZjhlMjI5ZDM5ODI0NjZiNzFhZTc3OGQwNGU=", "commit": {"author": {"name": "Pazzaz", "email": "pazzaz.sundqvist@gmail.com", "date": "2018-07-19T17:58:06Z"}, "committer": {"name": "Pazzaz", "email": "pazzaz.sundqvist@gmail.com", "date": "2018-07-19T21:32:22Z"}, "message": "Non-naive implementation for `VecDeque.append`", "tree": {"sha": "bb59456f01ac9453580a7dfb1925d2692e7be879", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb59456f01ac9453580a7dfb1925d2692e7be879"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24bc854b8c95ccf8e229d3982466b71ae778d04e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24bc854b8c95ccf8e229d3982466b71ae778d04e", "html_url": "https://github.com/rust-lang/rust/commit/24bc854b8c95ccf8e229d3982466b71ae778d04e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24bc854b8c95ccf8e229d3982466b71ae778d04e/comments", "author": {"login": "Pazzaz", "id": 16006944, "node_id": "MDQ6VXNlcjE2MDA2OTQ0", "avatar_url": "https://avatars.githubusercontent.com/u/16006944?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pazzaz", "html_url": "https://github.com/Pazzaz", "followers_url": "https://api.github.com/users/Pazzaz/followers", "following_url": "https://api.github.com/users/Pazzaz/following{/other_user}", "gists_url": "https://api.github.com/users/Pazzaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pazzaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pazzaz/subscriptions", "organizations_url": "https://api.github.com/users/Pazzaz/orgs", "repos_url": "https://api.github.com/users/Pazzaz/repos", "events_url": "https://api.github.com/users/Pazzaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Pazzaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Pazzaz", "id": 16006944, "node_id": "MDQ6VXNlcjE2MDA2OTQ0", "avatar_url": "https://avatars.githubusercontent.com/u/16006944?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pazzaz", "html_url": "https://github.com/Pazzaz", "followers_url": "https://api.github.com/users/Pazzaz/followers", "following_url": "https://api.github.com/users/Pazzaz/following{/other_user}", "gists_url": "https://api.github.com/users/Pazzaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pazzaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pazzaz/subscriptions", "organizations_url": "https://api.github.com/users/Pazzaz/orgs", "repos_url": "https://api.github.com/users/Pazzaz/repos", "events_url": "https://api.github.com/users/Pazzaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Pazzaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d6f4e5eea0ca537e0e03ef369eeff85774cce2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d6f4e5eea0ca537e0e03ef369eeff85774cce2c", "html_url": "https://github.com/rust-lang/rust/commit/9d6f4e5eea0ca537e0e03ef369eeff85774cce2c"}], "stats": {"total": 194, "additions": 192, "deletions": 2}, "files": [{"sha": "d0b70b5db2dfec37531f4acf23dbae778433753d", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 138, "deletions": 2, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/24bc854b8c95ccf8e229d3982466b71ae778d04e/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bc854b8c95ccf8e229d3982466b71ae778d04e/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=24bc854b8c95ccf8e229d3982466b71ae778d04e", "patch": "@@ -1834,8 +1834,144 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // naive impl\n-        self.extend(other.drain(..));\n+        // Copy from src[i1..i1 + len] to dst[i2..i2 + len].\n+        // Does not check if the ranges are valid.\n+        unsafe fn copy_part<T>(i1: usize, i2: usize, len: usize, src: &[T], dst: &mut [T]) {\n+            debug_assert!(src.get(i1..i1 + len).is_some() && dst.get(i2..i2 + len).is_some());\n+            ptr::copy_nonoverlapping(src.as_ptr().add(i1), dst.as_mut_ptr().add(i2), len);\n+        }\n+\n+        let src_total = other.len();\n+\n+        // Guarantees there is space in `self` for `other`.\n+        self.reserve(src_total);\n+\n+        self.head = {\n+            let dst_start_1 = self.head;\n+            let src_start_1 = other.tail;\n+            let dst_wrap_point = self.cap();\n+            let src_wrap_point = other.cap();\n+\n+            let dst = unsafe { self.buffer_as_mut_slice() };\n+            let src = unsafe { other.buffer_as_slice() };\n+\n+            let src_wraps = other.tail > other.head;\n+            let dst_wraps = dst_start_1 + src_total > dst_wrap_point;\n+\n+            // When minimizing the amount of calls to `copy_part`, there are\n+            // 6 different cases to handle. Whether src and/or dst wrap are 4\n+            // combinations and there are 3 distinct cases when they both wrap.\n+            // 6 = 3 + 1 + 1 + 1\n+            match (src_wraps, dst_wraps) {\n+                (true, true) => {\n+                    let dst_before_wrap = dst_wrap_point - dst_start_1;\n+                    let src_before_wrap = src_wrap_point - src_start_1;\n+\n+                    if src_before_wrap < dst_before_wrap {\n+                        //            src\n+                        // [o o o . . . . . . o o o]\n+                        //  2 3 3             1 1 1\n+                        //\n+                        //            dst\n+                        // [. . . . . . o o . . . .]\n+                        //  3 3 H           1 1 1 2\n+                        let src_2 = dst_before_wrap - src_before_wrap;\n+                        let dst_start_2 = dst_start_1 + src_before_wrap;\n+                        let src_3 = src_total - dst_before_wrap;\n+\n+                        unsafe {\n+                            copy_part(src_start_1, dst_start_1, src_before_wrap, src, dst);\n+                            copy_part(0, dst_start_2, src_2, src, dst);\n+                            copy_part(src_2, 0, src_3, src, dst);\n+                        }\n+                        src_3\n+                    } else if src_before_wrap > dst_before_wrap {\n+                        //            src\n+                        // [o o o . . . . . o o o o]\n+                        //  3 3 3           1 1 2 2\n+                        //\n+                        //            dst\n+                        // [. . . . . . o o o o . .]\n+                        //  2 2 3 3 3 H         1 1\n+                        let src_2 = src_before_wrap - dst_before_wrap;\n+                        let src_start_2 = src_start_1 + dst_before_wrap;\n+                        let src_3 = src_total - src_before_wrap;\n+\n+                        unsafe {\n+                            copy_part(src_start_1, dst_start_1, dst_before_wrap, src, dst);\n+                            copy_part(src_start_2, 0, src_2, src, dst);\n+                            copy_part(0, src_2, src_3, src, dst);\n+                        }\n+                        src_2 + src_3\n+                    } else {\n+                        //            src\n+                        // [o o . . . . . . . o o o]\n+                        //  2 2               1 1 1\n+                        //\n+                        //            dst\n+                        // [. . . . . . . o o . . .]\n+                        //  2 2 H             1 1 1\n+                        let src_2 = src_total - src_before_wrap;\n+\n+                        unsafe {\n+                            copy_part(src_start_1, dst_start_1, src_before_wrap, src, dst);\n+                            copy_part(0, 0, src_2, src, dst);\n+                        }\n+                        src_2\n+                    }\n+                }\n+                (false, true) => {\n+                    //            src\n+                    // [. . . o o o o o . . . .]\n+                    //        1 1 2 2 2\n+                    //\n+                    //            dst\n+                    // [. . . . . . . o o o . .]\n+                    //  2 2 2 H             1 1\n+                    let dst_1 = dst_wrap_point - dst_start_1;\n+                    let src_start_2 = src_start_1 + dst_1;\n+                    let dst_2 = src_total - dst_1;\n+\n+                    unsafe {\n+                        copy_part(src_start_1, dst_start_1, dst_1, src, dst);\n+                        copy_part(src_start_2, 0, dst_2, src, dst);\n+                    }\n+                    dst_2\n+                }\n+                (true, false) => {\n+                    //            src\n+                    // [o o . . . . . . . o o o]\n+                    //  2 2               1 1 1\n+                    //\n+                    //            dst\n+                    // [. o o . . . . . . . . .]\n+                    //        1 1 1 2 2 H\n+                    let src_1 = src_wrap_point - src_start_1;\n+                    let dst_start_2 = dst_start_1 + src_1;\n+                    let src_2 = src_total - src_1;\n+\n+                    unsafe {\n+                        copy_part(src_start_1, dst_start_1, src_1, src, dst);\n+                        copy_part(0, dst_start_2, src_2, src, dst);\n+                    }\n+                    dst_start_1 + src_1 + src_2\n+                }\n+                (false, false) => {\n+                    //            src\n+                    // [. . . o o o . . . . . .]\n+                    //        1 1 1\n+                    //\n+                    //            dst\n+                    // [. o o o o o . . . . . .]\n+                    //              1 1 1 H\n+                    unsafe {\n+                        copy_part(src_start_1, dst_start_1, src_total, src, dst);\n+                    }\n+                    dst_start_1 + src_total\n+                }\n+            }\n+        };\n+        other.clear();\n     }\n \n     /// Retains only the elements specified by the predicate."}, {"sha": "0c8c1f2c65bf199f0179c9938dba402f39661193", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/24bc854b8c95ccf8e229d3982466b71ae778d04e/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bc854b8c95ccf8e229d3982466b71ae778d04e/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=24bc854b8c95ccf8e229d3982466b71ae778d04e", "patch": "@@ -928,6 +928,60 @@ fn test_append() {\n     assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n }\n \n+#[test]\n+fn test_append_advanced() {\n+    fn check(\n+        a_push_back: usize,\n+        a_pop_back: usize,\n+        b_push_back: usize,\n+        b_pop_back: usize,\n+        a_push_front: usize,\n+        a_pop_front: usize,\n+        b_push_front: usize,\n+        b_pop_front: usize\n+    ) {\n+        let mut taken = 0;\n+        let mut a = VecDeque::new();\n+        let mut b = VecDeque::new();\n+        for n in (taken..).take(a_push_back) {\n+            a.push_back(n);\n+        }\n+        taken += a_push_back;\n+        for n in (taken..).take(a_push_front) {\n+            a.push_front(n);\n+        }\n+        taken += a_push_front;\n+        for n in (taken..).take(b_push_back) {\n+            b.push_back(n);\n+        }\n+        taken += b_push_back;\n+        for n in (taken..).take(b_push_front) {\n+            b.push_front(n);\n+        }\n+\n+        a.drain(..a_pop_back);\n+        a.drain(a_pop_front..);\n+        b.drain(..b_pop_back);\n+        b.drain(b_pop_front..);\n+        let checked = a.iter().chain(b.iter()).map(|&x| x).collect::<Vec<usize>>();\n+        a.append(&mut b);\n+        assert_eq!(a, checked);\n+        assert!(b.is_empty());\n+    }\n+    for a_push in 0..17 {\n+        for a_pop in 0..a_push {\n+            for b_push in 0..17 {\n+                for b_pop in 0..b_push {\n+                    check(a_push, a_pop, b_push, b_pop, 0, 0, 0, 0);\n+                    check(a_push, a_pop, b_push, b_pop, a_push, 0, 0, 0);\n+                    check(a_push, a_pop, b_push, b_pop, 0, 0, b_push, 0);\n+                    check(0, 0, 0, 0, a_push, a_pop, b_push, b_pop);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n fn test_retain() {\n     let mut buf = VecDeque::new();"}]}