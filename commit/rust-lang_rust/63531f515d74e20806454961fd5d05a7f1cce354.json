{"sha": "63531f515d74e20806454961fd5d05a7f1cce354", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzNTMxZjUxNWQ3NGUyMDgwNjQ1NDk2MWZkNWQwNWE3ZjFjY2UzNTQ=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-06-27T22:15:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-27T22:15:38Z"}, "message": "Rollup merge of #50342 - fkjogu:euclidean, r=BurntSushi\n\nDocument round-off error in `.mod_euc()`-method, see issue #50179\n\nDue to a round-off error the method `.mod_euc()` of both `f32` and `f64` can produce mathematical invalid outputs. If `self` in magnitude is much small than the modulus `rhs` and negative, `self + rhs` in the first branch cannot be represented in the given precision and results into `rhs`. In the mathematical strict sense, this breaks the definition. But given the limitation of floating point arithmetic it can be thought of the closest representable value to the true result, although it is not strictly in the domain `[0.0, rhs)` of the function. It is rather the left side asymptotical limit. It would be desirable that it produces the mathematical more sound approximation of `0.0`, the right side asymptotical limit. But this breaks the property, that `self == self.div_euc(rhs) * rhs + a.mod_euc(rhs)`.\n\nThe discussion in issue #50179 did not find an satisfying conclusion to which property is deemed more important. But at least we can document the behaviour. Which this pull request does.", "tree": {"sha": "b581eb859a7c3247162c8b34f32e92444d68f46b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b581eb859a7c3247162c8b34f32e92444d68f46b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63531f515d74e20806454961fd5d05a7f1cce354", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNAyKCRBK7hj4Ov3rIwAAdHIIACkWH6NJZFKJOPuNuzMjTaED\nj8Qsr45+Hg3e/8QxCHoOoyoXdxEZd7Fg/F3d+hLKTVBZtvxPCnHHhs1j5WfyMQvr\nlihhQ9QS84vTzTqns6vfFUdY9KyxG4zQ4j0EuUa4VnF3fbFwoF/m4qXOTaUMzvLH\nbUM2nIbWMMxJEOEc5bMAyEPV39+9wDMLENjeLlod5D9zTj0DfwRSBzcI3MdJlkhr\nCTNE1dwe8WEwMeoyxjwb060PypDIkDpjLFSCFecmyaUNbscrv8ZJXbDH7TWTTXYj\n4wa8CeunZxtNDSHl9DLsuh5KUjVqepc9Gy2mWHDsB7qlO55Fbmhaysr4Rnhd37I=\n=ED8a\n-----END PGP SIGNATURE-----\n", "payload": "tree b581eb859a7c3247162c8b34f32e92444d68f46b\nparent e5462b82e3c3090be8b5d1f7fa0b687afa6e3546\nparent bd853a6469fb71b4719d05c20535a70e75d1aa78\nauthor kennytm <kennytm@gmail.com> 1530137738 +0800\ncommitter GitHub <noreply@github.com> 1530137738 +0800\n\nRollup merge of #50342 - fkjogu:euclidean, r=BurntSushi\n\nDocument round-off error in `.mod_euc()`-method, see issue #50179\n\nDue to a round-off error the method `.mod_euc()` of both `f32` and `f64` can produce mathematical invalid outputs. If `self` in magnitude is much small than the modulus `rhs` and negative, `self + rhs` in the first branch cannot be represented in the given precision and results into `rhs`. In the mathematical strict sense, this breaks the definition. But given the limitation of floating point arithmetic it can be thought of the closest representable value to the true result, although it is not strictly in the domain `[0.0, rhs)` of the function. It is rather the left side asymptotical limit. It would be desirable that it produces the mathematical more sound approximation of `0.0`, the right side asymptotical limit. But this breaks the property, that `self == self.div_euc(rhs) * rhs + a.mod_euc(rhs)`.\n\nThe discussion in issue #50179 did not find an satisfying conclusion to which property is deemed more important. But at least we can document the behaviour. Which this pull request does.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63531f515d74e20806454961fd5d05a7f1cce354", "html_url": "https://github.com/rust-lang/rust/commit/63531f515d74e20806454961fd5d05a7f1cce354", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63531f515d74e20806454961fd5d05a7f1cce354/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546", "html_url": "https://github.com/rust-lang/rust/commit/e5462b82e3c3090be8b5d1f7fa0b687afa6e3546"}, {"sha": "bd853a6469fb71b4719d05c20535a70e75d1aa78", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd853a6469fb71b4719d05c20535a70e75d1aa78", "html_url": "https://github.com/rust-lang/rust/commit/bd853a6469fb71b4719d05c20535a70e75d1aa78"}], "stats": {"total": 41, "additions": 39, "deletions": 2}, "files": [{"sha": "24fe96a2b82559313605802cdcba06bd6ea01b34", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=63531f515d74e20806454961fd5d05a7f1cce354", "patch": "@@ -574,6 +574,25 @@ macro_rules! test_float {\n             assert_eq!((-9.0 as $fty).max($nan), -9.0);\n             assert!(($nan as $fty).max($nan).is_nan());\n         }\n+        #[test]\n+        fn mod_euc() {\n+            let a: $fty = 42.0;\n+            assert!($inf.mod_euc(a).is_nan());\n+            assert_eq!(a.mod_euc($inf), a);\n+            assert!(a.mod_euc($nan).is_nan());\n+            assert!($inf.mod_euc($inf).is_nan());\n+            assert!($inf.mod_euc($nan).is_nan());\n+            assert!($nan.mod_euc($inf).is_nan());\n+        }\n+        #[test]\n+        fn div_euc() {\n+            let a: $fty = 42.0;\n+            assert_eq!(a.div_euc($inf), 0.0);\n+            assert!(a.div_euc($nan).is_nan());\n+            assert!($inf.div_euc($inf).is_nan());\n+            assert!($inf.div_euc($nan).is_nan());\n+            assert!($nan.div_euc($inf).is_nan());\n+        }\n     } }\n }\n "}, {"sha": "8e8340b3ed901b557e23e7111bb54e236060cbc7", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=63531f515d74e20806454961fd5d05a7f1cce354", "patch": "@@ -254,7 +254,14 @@ impl f32 {\n \n     /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n     ///\n-    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n+    /// most cases. However, due to a floating point round-off error it can\n+    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n+    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n+    /// This result is not an element of the function's codomain, but it is the\n+    /// closest floating point number in the real numbers and thus fulfills the\n+    /// property `self == self.div_euc(rhs) * rhs + self.mod_euc(rhs)`\n+    /// approximatively.\n     ///\n     /// # Examples\n     ///\n@@ -266,6 +273,8 @@ impl f32 {\n     /// assert_eq!((-a).mod_euc(b), 1.0);\n     /// assert_eq!(a.mod_euc(-b), 3.0);\n     /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// // limitation due to round-off error\n+    /// assert!((-std::f32::EPSILON).mod_euc(3.0) != 0.0);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]"}, {"sha": "6880294afcaafd4f41c40f6d0ef448f3b5bd14fd", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63531f515d74e20806454961fd5d05a7f1cce354/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=63531f515d74e20806454961fd5d05a7f1cce354", "patch": "@@ -230,7 +230,14 @@ impl f64 {\n \n     /// Calculates the Euclidean modulo (self mod rhs), which is never negative.\n     ///\n-    /// In particular, the result `n` satisfies `0 <= n < rhs.abs()`.\n+    /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n+    /// most cases.  However, due to a floating point round-off error it can\n+    /// result in `r == rhs.abs()`, violating the mathematical definition, if\n+    /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n+    /// This result is not an element of the function's codomain, but it is the\n+    /// closest floating point number in the real numbers and thus fulfills the\n+    /// property `self == self.div_euc(rhs) * rhs + self.mod_euc(rhs)`\n+    /// approximatively.\n     ///\n     /// # Examples\n     ///\n@@ -242,6 +249,8 @@ impl f64 {\n     /// assert_eq!((-a).mod_euc(b), 1.0);\n     /// assert_eq!(a.mod_euc(-b), 3.0);\n     /// assert_eq!((-a).mod_euc(-b), 1.0);\n+    /// // limitation due to round-off error\n+    /// assert!((-std::f64::EPSILON).mod_euc(3.0) != 0.0);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"euclidean_division\", issue = \"49048\")]"}]}