{"sha": "15a8b981e08bb942a439b680da93bad1dd18843e", "node_id": "C_kwDOAAsO6NoAKDE1YThiOTgxZTA4YmI5NDJhNDM5YjY4MGRhOTNiYWQxZGQxODg0M2U", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-23T21:03:12Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-24T23:03:54Z"}, "message": "resolve: Optimize path resolution for rustdoc\n\nDo not construct or pass unused data", "tree": {"sha": "f41cb05cd9d650980c1f3ead28ee11f657fad129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f41cb05cd9d650980c1f3ead28ee11f657fad129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15a8b981e08bb942a439b680da93bad1dd18843e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15a8b981e08bb942a439b680da93bad1dd18843e", "html_url": "https://github.com/rust-lang/rust/commit/15a8b981e08bb942a439b680da93bad1dd18843e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15a8b981e08bb942a439b680da93bad1dd18843e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0749ec67bc927eba90f4be5544055d3cd9040e58", "url": "https://api.github.com/repos/rust-lang/rust/commits/0749ec67bc927eba90f4be5544055d3cd9040e58", "html_url": "https://github.com/rust-lang/rust/commit/0749ec67bc927eba90f4be5544055d3cd9040e58"}], "stats": {"total": 130, "additions": 38, "deletions": 92}, "files": [{"sha": "f8bc1f804719ac7e549688e56cc79eb1fd79373d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/15a8b981e08bb942a439b680da93bad1dd18843e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a8b981e08bb942a439b680da93bad1dd18843e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=15a8b981e08bb942a439b680da93bad1dd18843e", "patch": "@@ -71,7 +71,7 @@ use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n-use std::{cmp, fmt, iter, mem, ptr};\n+use std::{cmp, fmt, mem, ptr};\n use tracing::debug;\n \n use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_next_binding};\n@@ -3309,82 +3309,39 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n+    /// Rustdoc uses this to resolve doc link paths in a recoverable way. `PathResult<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occurred.\n-    // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-    pub fn resolve_str_path_error(\n+    pub fn resolve_rustdoc_path(\n         &mut self,\n-        span: Span,\n         path_str: &str,\n         ns: Namespace,\n         module_id: DefId,\n-    ) -> Result<(ast::Path, Res), ()> {\n-        let path = if path_str.starts_with(\"::\") {\n-            ast::Path {\n-                span,\n-                segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n-                    .chain(path_str.split(\"::\").skip(1).map(Ident::from_str))\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-                tokens: None,\n-            }\n-        } else {\n-            ast::Path {\n-                span,\n-                segments: path_str\n-                    .split(\"::\")\n-                    .map(Ident::from_str)\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-                tokens: None,\n-            }\n-        };\n-        let module = self.expect_module(module_id);\n-        let parent_scope = &ParentScope::module(module, self);\n-        let res = self.resolve_ast_path(&path, ns, parent_scope).map_err(|_| ())?;\n-        Ok((path, res))\n-    }\n+    ) -> Option<Res> {\n+        let mut segments =\n+            Vec::from_iter(path_str.split(\"::\").map(Ident::from_str).map(Segment::from_ident));\n+        if path_str.starts_with(\"::\") {\n+            segments[0].ident.name = kw::PathRoot;\n+        }\n \n-    // Resolve a path passed from rustdoc or HIR lowering.\n-    fn resolve_ast_path(\n-        &mut self,\n-        path: &ast::Path,\n-        ns: Namespace,\n-        parent_scope: &ParentScope<'a>,\n-    ) -> Result<Res, (Span, ResolutionError<'a>)> {\n+        let module = self.expect_module(module_id);\n         match self.resolve_path(\n-            &Segment::from_path(path),\n+            &segments,\n             Some(ns),\n-            parent_scope,\n-            path.span,\n+            &ParentScope::module(module, self),\n+            DUMMY_SP,\n             CrateLint::No,\n         ) {\n-            PathResult::Module(ModuleOrUniformRoot::Module(module)) => Ok(module.res().unwrap()),\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n-                Ok(path_res.base_res())\n+                Some(path_res.base_res())\n             }\n-            PathResult::NonModule(..) => Err((\n-                path.span,\n-                ResolutionError::FailedToResolve {\n-                    label: String::from(\"type-relative paths are not supported in this context\"),\n-                    suggestion: None,\n-                },\n-            )),\n+            PathResult::NonModule(..) | PathResult::Failed { .. } => None,\n             PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed { span, label, suggestion, .. } => {\n-                Err((span, ResolutionError::FailedToResolve { label, suggestion }))\n-            }\n         }\n     }\n \n-    fn new_ast_path_segment(&mut self, ident: Ident) -> ast::PathSegment {\n-        let mut seg = ast::PathSegment::from_ident(ident);\n-        seg.id = self.next_node_id();\n-        seg\n-    }\n-\n     // For rustdoc.\n     pub fn graph_root(&self) -> Module<'a> {\n         self.graph_root"}, {"sha": "5b14aca064e8ab85f2751cdc45e81454fe001443", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/15a8b981e08bb942a439b680da93bad1dd18843e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a8b981e08bb942a439b680da93bad1dd18843e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=15a8b981e08bb942a439b680da93bad1dd18843e", "patch": "@@ -487,12 +487,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n         self.cx.enter_resolver(|resolver| {\n-            // NOTE: this needs 2 separate lookups because `resolve_str_path_error` doesn't take\n+            // NOTE: this needs 2 separate lookups because `resolve_rustdoc_path` doesn't take\n             // lexical scope into account (it ignores all macros not defined at the mod-level)\n             debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n-            if let Ok((_, res)) =\n-                resolver.resolve_str_path_error(DUMMY_SP, path_str, MacroNS, module_id)\n-            {\n+            if let Some(res) = resolver.resolve_rustdoc_path(path_str, MacroNS, module_id) {\n                 // don't resolve builtins like `#[derive]`\n                 if let Ok(res) = res.try_into() {\n                     return Ok(res);\n@@ -540,10 +538,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n     }\n \n-    /// Convenience wrapper around `resolve_str_path_error`.\n+    /// Convenience wrapper around `resolve_rustdoc_path`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n-    /// NOTE: `resolve_str_path_error` knows only about paths, not about types.\n+    /// NOTE: `resolve_rustdoc_path` knows only about paths, not about types.\n     /// Associated items will never be resolved by this function.\n     fn resolve_path(\n         &self,\n@@ -556,18 +554,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             return res;\n         }\n \n-        let result = self.cx.enter_resolver(|resolver| {\n-            resolver\n-                .resolve_str_path_error(DUMMY_SP, path_str, ns, module_id)\n-                .and_then(|(_, res)| res.try_into())\n-        });\n+        // Resolver doesn't know about true, false, and types that aren't paths (e.g. `()`).\n+        let result = self\n+            .cx\n+            .enter_resolver(|resolver| resolver.resolve_rustdoc_path(path_str, ns, module_id))\n+            .and_then(|res| res.try_into().ok())\n+            .or_else(|| resolve_primitive(path_str, ns));\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n-        match result {\n-            // resolver doesn't know about true, false, and types that aren't paths (e.g. `()`)\n-            // manually as bool\n-            Err(()) => resolve_primitive(path_str, ns),\n-            Ok(res) => Some(res),\n-        }\n+        result\n     }\n \n     /// Resolves a string as a path within a particular namespace. Returns an"}, {"sha": "30636faf98c1f295e583926f1534886229194eac", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/15a8b981e08bb942a439b680da93bad1dd18843e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a8b981e08bb942a439b680da93bad1dd18843e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=15a8b981e08bb942a439b680da93bad1dd18843e", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::TraitCandidate;\n use rustc_middle::ty::{DefIdTree, Visibility};\n use rustc_resolve::{ParentScope, Resolver};\n use rustc_session::config::Externs;\n-use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n+use rustc_span::SyntaxContext;\n \n use std::collections::hash_map::Entry;\n use std::mem;\n@@ -39,7 +39,7 @@ crate fn early_resolve_intra_doc_links(\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n     // so we have to visit its attributes and reexports separately.\n-    loader.load_links_in_attrs(&krate.attrs, krate.spans.inner_span);\n+    loader.load_links_in_attrs(&krate.attrs);\n     loader.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut loader, krate);\n     loader.add_foreign_traits_in_scope();\n@@ -49,12 +49,7 @@ crate fn early_resolve_intra_doc_links(\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n     for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n-        let _ = loader.resolver.resolve_str_path_error(\n-            DUMMY_SP,\n-            extern_name,\n-            TypeNS,\n-            CRATE_DEF_ID.to_def_id(),\n-        );\n+        loader.resolver.resolve_rustdoc_path(extern_name, TypeNS, CRATE_DEF_ID.to_def_id());\n     }\n \n     ResolverCaches {\n@@ -151,7 +146,7 @@ impl IntraLinkCrateLoader<'_, '_> {\n         }\n     }\n \n-    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute], span: Span) {\n+    fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute]) {\n         // FIXME: this needs to consider reexport inlining.\n         let attrs = clean::Attributes::from_ast(attrs, None);\n         for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n@@ -165,7 +160,7 @@ impl IntraLinkCrateLoader<'_, '_> {\n                 } else {\n                     continue;\n                 };\n-                let _ = self.resolver.resolve_str_path_error(span, &path_str, TypeNS, module_id);\n+                self.resolver.resolve_rustdoc_path(&path_str, TypeNS, module_id);\n             }\n         }\n     }\n@@ -201,7 +196,7 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n             // loaded, even if the module itself has no doc comments.\n             self.add_traits_in_parent_scope(self.current_mod.to_def_id());\n \n-            self.load_links_in_attrs(&item.attrs, item.span);\n+            self.load_links_in_attrs(&item.attrs);\n             self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n \n@@ -216,28 +211,28 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n                 }\n                 _ => {}\n             }\n-            self.load_links_in_attrs(&item.attrs, item.span);\n+            self.load_links_in_attrs(&item.attrs);\n             visit::walk_item(self, item);\n         }\n     }\n \n     fn visit_assoc_item(&mut self, item: &ast::AssocItem, ctxt: AssocCtxt) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n+        self.load_links_in_attrs(&item.attrs);\n         visit::walk_assoc_item(self, item, ctxt)\n     }\n \n     fn visit_foreign_item(&mut self, item: &ast::ForeignItem) {\n-        self.load_links_in_attrs(&item.attrs, item.span);\n+        self.load_links_in_attrs(&item.attrs);\n         visit::walk_foreign_item(self, item)\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant) {\n-        self.load_links_in_attrs(&v.attrs, v.span);\n+        self.load_links_in_attrs(&v.attrs);\n         visit::walk_variant(self, v)\n     }\n \n     fn visit_field_def(&mut self, field: &ast::FieldDef) {\n-        self.load_links_in_attrs(&field.attrs, field.span);\n+        self.load_links_in_attrs(&field.attrs);\n         visit::walk_field_def(self, field)\n     }\n "}]}