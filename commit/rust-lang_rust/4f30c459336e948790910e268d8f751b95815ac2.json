{"sha": "4f30c459336e948790910e268d8f751b95815ac2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMzBjNDU5MzM2ZTk0ODc5MDkxMGUyNjhkOGY3NTFiOTU4MTVhYzI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T16:42:29Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-02T16:42:29Z"}, "message": "Merge #406\n\n406: Simplify r=matklad a=matklad\n\nGet rid of `AnalysisImpl` wrapper around salsa database. It was useful before we migrated by salsa, but it's long have been just a useless boilerplate. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5dbfb4e045d6b50ebee447cdaa36aad995089c8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dbfb4e045d6b50ebee447cdaa36aad995089c8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f30c459336e948790910e268d8f751b95815ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f30c459336e948790910e268d8f751b95815ac2", "html_url": "https://github.com/rust-lang/rust/commit/4f30c459336e948790910e268d8f751b95815ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f30c459336e948790910e268d8f751b95815ac2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "e6aadf6ef21a25a6dae55f39bc774b5a0ef2ad6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6aadf6ef21a25a6dae55f39bc774b5a0ef2ad6c", "html_url": "https://github.com/rust-lang/rust/commit/e6aadf6ef21a25a6dae55f39bc774b5a0ef2ad6c"}, {"sha": "ef08b6c084fc2676655fe6dfb693ab097d3f9fd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef08b6c084fc2676655fe6dfb693ab097d3f9fd9", "html_url": "https://github.com/rust-lang/rust/commit/ef08b6c084fc2676655fe6dfb693ab097d3f9fd9"}], "stats": {"total": 421, "additions": 203, "deletions": 218}, "files": [{"sha": "739ca6ae8374a08f074d2130278df11125e788cf", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=4f30c459336e948790910e268d8f751b95815ac2", "patch": "@@ -58,6 +58,6 @@ fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind\n     } else {\n         single_file_with_position(code)\n     };\n-    let completions = completions(&analysis.imp.db, position).unwrap().unwrap();\n+    let completions = completions(&analysis.db, position).unwrap().unwrap();\n     completions.assert_match(expected_completions, kind);\n }"}, {"sha": "0faf8b85d9f8fd1ebe72d685ad9f4fb8ca1b91b2", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 71, "deletions": 153, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=4f30c459336e948790910e268d8f751b95815ac2", "patch": "@@ -1,16 +1,12 @@\n-use std::{\n-    fmt,\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n-use rayon::prelude::*;\n-use salsa::{Database, ParallelDatabase};\n+use salsa::Database;\n \n use hir::{\n     self, FnSignatureInfo, Problem, source_binder,\n };\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n-use ra_editor::{self, find_node_at_offset, LineIndex, LocalEdit, Severity};\n+use ra_editor::{self, find_node_at_offset, LocalEdit, Severity};\n use ra_syntax::{\n     algo::find_covering_node,\n     ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n@@ -22,92 +18,70 @@ use ra_syntax::{\n use crate::{\n     AnalysisChange,\n     Cancelable, NavigationTarget,\n-    completion::{CompletionItem, completions},\n     CrateId, db, Diagnostic, FileId, FilePosition, FileRange, FileSystemEdit,\n     Query, ReferenceResolution, RootChange, SourceChange, SourceFileEdit,\n-    symbol_index::{LibrarySymbolsQuery, SymbolIndex, SymbolsDatabase, FileSymbol},\n+    symbol_index::{LibrarySymbolsQuery, FileSymbol},\n };\n \n-#[derive(Debug, Default)]\n-pub(crate) struct AnalysisHostImpl {\n-    db: db::RootDatabase,\n-}\n-\n-impl AnalysisHostImpl {\n-    pub fn analysis(&self) -> AnalysisImpl {\n-        AnalysisImpl {\n-            db: self.db.snapshot(),\n-        }\n-    }\n-    pub fn apply_change(&mut self, change: AnalysisChange) {\n+impl db::RootDatabase {\n+    pub(crate) fn apply_change(&mut self, change: AnalysisChange) {\n         log::info!(\"apply_change {:?}\", change);\n         // self.gc_syntax_trees();\n         if !change.new_roots.is_empty() {\n-            let mut local_roots = Vec::clone(&self.db.local_roots());\n+            let mut local_roots = Vec::clone(&self.local_roots());\n             for (root_id, is_local) in change.new_roots {\n-                self.db\n-                    .query_mut(ra_db::SourceRootQuery)\n+                self.query_mut(ra_db::SourceRootQuery)\n                     .set(root_id, Default::default());\n                 if is_local {\n                     local_roots.push(root_id);\n                 }\n             }\n-            self.db\n-                .query_mut(ra_db::LocalRootsQuery)\n+            self.query_mut(ra_db::LocalRootsQuery)\n                 .set((), Arc::new(local_roots));\n         }\n \n         for (root_id, root_change) in change.roots_changed {\n             self.apply_root_change(root_id, root_change);\n         }\n         for (file_id, text) in change.files_changed {\n-            self.db.query_mut(ra_db::FileTextQuery).set(file_id, text)\n+            self.query_mut(ra_db::FileTextQuery).set(file_id, text)\n         }\n         if !change.libraries_added.is_empty() {\n-            let mut libraries = Vec::clone(&self.db.library_roots());\n+            let mut libraries = Vec::clone(&self.library_roots());\n             for library in change.libraries_added {\n                 libraries.push(library.root_id);\n-                self.db\n-                    .query_mut(ra_db::SourceRootQuery)\n+                self.query_mut(ra_db::SourceRootQuery)\n                     .set(library.root_id, Default::default());\n-                self.db\n-                    .query_mut(LibrarySymbolsQuery)\n+                self.query_mut(LibrarySymbolsQuery)\n                     .set_constant(library.root_id, Arc::new(library.symbol_index));\n                 self.apply_root_change(library.root_id, library.root_change);\n             }\n-            self.db\n-                .query_mut(ra_db::LibraryRootsQuery)\n+            self.query_mut(ra_db::LibraryRootsQuery)\n                 .set((), Arc::new(libraries));\n         }\n         if let Some(crate_graph) = change.crate_graph {\n-            self.db\n-                .query_mut(ra_db::CrateGraphQuery)\n+            self.query_mut(ra_db::CrateGraphQuery)\n                 .set((), Arc::new(crate_graph))\n         }\n     }\n \n     fn apply_root_change(&mut self, root_id: SourceRootId, root_change: RootChange) {\n-        let mut source_root = SourceRoot::clone(&self.db.source_root(root_id));\n+        let mut source_root = SourceRoot::clone(&self.source_root(root_id));\n         for add_file in root_change.added {\n-            self.db\n-                .query_mut(ra_db::FileTextQuery)\n+            self.query_mut(ra_db::FileTextQuery)\n                 .set(add_file.file_id, add_file.text);\n-            self.db\n-                .query_mut(ra_db::FileRelativePathQuery)\n+            self.query_mut(ra_db::FileRelativePathQuery)\n                 .set(add_file.file_id, add_file.path.clone());\n-            self.db\n-                .query_mut(ra_db::FileSourceRootQuery)\n+            self.query_mut(ra_db::FileSourceRootQuery)\n                 .set(add_file.file_id, root_id);\n             source_root.files.insert(add_file.path, add_file.file_id);\n         }\n         for remove_file in root_change.removed {\n-            self.db\n-                .query_mut(ra_db::FileTextQuery)\n+            self.query_mut(ra_db::FileTextQuery)\n                 .set(remove_file.file_id, Default::default());\n             source_root.files.remove(&remove_file.path);\n         }\n-        self.db\n-            .query_mut(ra_db::SourceRootQuery)\n+        self.query_mut(ra_db::SourceRootQuery)\n             .set(root_id, Arc::new(source_root));\n     }\n \n@@ -116,74 +90,18 @@ impl AnalysisHostImpl {\n     /// syntax trees. However, if we actually do that, everything is recomputed\n     /// for some reason. Needs investigation.\n     fn gc_syntax_trees(&mut self) {\n-        self.db\n-            .query(ra_db::SourceFileQuery)\n+        self.query(ra_db::SourceFileQuery)\n             .sweep(salsa::SweepStrategy::default().discard_values());\n-        self.db\n-            .query(hir::db::SourceFileItemsQuery)\n+        self.query(hir::db::SourceFileItemsQuery)\n             .sweep(salsa::SweepStrategy::default().discard_values());\n-        self.db\n-            .query(hir::db::FileItemQuery)\n+        self.query(hir::db::FileItemQuery)\n             .sweep(salsa::SweepStrategy::default().discard_values());\n     }\n }\n \n-pub(crate) struct AnalysisImpl {\n-    pub(crate) db: salsa::Snapshot<db::RootDatabase>,\n-}\n-\n-impl fmt::Debug for AnalysisImpl {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let db: &db::RootDatabase = &self.db;\n-        fmt.debug_struct(\"AnalysisImpl\").field(\"db\", db).finish()\n-    }\n-}\n-\n-impl AnalysisImpl {\n-    pub fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        self.db.file_text(file_id)\n-    }\n-    pub fn file_syntax(&self, file_id: FileId) -> SourceFileNode {\n-        self.db.source_file(file_id)\n-    }\n-    pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.db.file_lines(file_id)\n-    }\n-    pub fn world_symbols(&self, query: Query) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n-        struct Snap(salsa::Snapshot<db::RootDatabase>);\n-        impl Clone for Snap {\n-            fn clone(&self) -> Snap {\n-                Snap(self.0.snapshot())\n-            }\n-        }\n-\n-        let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n-            let snap = Snap(self.db.snapshot());\n-            self.db\n-                .library_roots()\n-                .par_iter()\n-                .map_with(snap, |db, &lib_id| db.0.library_symbols(lib_id))\n-                .collect()\n-        } else {\n-            let mut files = Vec::new();\n-            for &root in self.db.local_roots().iter() {\n-                let sr = self.db.source_root(root);\n-                files.extend(sr.files.values().map(|&it| it))\n-            }\n-\n-            let snap = Snap(self.db.snapshot());\n-            files\n-                .par_iter()\n-                .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n-                .filter_map(|it| it.ok())\n-                .collect()\n-        };\n-        Ok(query.search(&buf))\n-    }\n-\n+impl db::RootDatabase {\n     pub(crate) fn module_path(&self, position: FilePosition) -> Cancelable<Option<String>> {\n-        let descr = match source_binder::module_from_position(&*self.db, position)? {\n+        let descr = match source_binder::module_from_position(self, position)? {\n             None => return Ok(None),\n             Some(it) => it,\n         };\n@@ -205,12 +123,15 @@ impl AnalysisImpl {\n \n     /// This returns `Vec` because a module may be included from several places. We\n     /// don't handle this case yet though, so the Vec has length at most one.\n-    pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        let descr = match source_binder::module_from_position(&*self.db, position)? {\n+    pub(crate) fn parent_module(\n+        &self,\n+        position: FilePosition,\n+    ) -> Cancelable<Vec<NavigationTarget>> {\n+        let descr = match source_binder::module_from_position(self, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n-        let (file_id, decl) = match descr.parent_link_source(&*self.db) {\n+        let (file_id, decl) = match descr.parent_link_source(self) {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -224,39 +145,33 @@ impl AnalysisImpl {\n         Ok(vec![NavigationTarget { file_id, symbol }])\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n-    pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let descr = match source_binder::module_from_file_id(&*self.db, file_id)? {\n+    pub(crate) fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n+        let descr = match source_binder::module_from_file_id(self, file_id)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n         let root = descr.crate_root();\n         let file_id = root.file_id();\n \n-        let crate_graph = self.db.crate_graph();\n+        let crate_graph = self.crate_graph();\n         let crate_id = crate_graph.crate_id_for_crate_root(file_id);\n         Ok(crate_id.into_iter().collect())\n     }\n-    pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.db.crate_graph().crate_root(crate_id)\n+    pub(crate) fn crate_root(&self, crate_id: CrateId) -> FileId {\n+        self.crate_graph().crate_root(crate_id)\n     }\n-    pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        let completions = completions(&self.db, position)?;\n-        Ok(completions.map(|it| it.into()))\n-    }\n-    pub fn approximately_resolve_symbol(\n+    pub(crate) fn approximately_resolve_symbol(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<ReferenceResolution>> {\n-        let file = self.db.source_file(position.file_id);\n+        let file = self.source_file(position.file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n             let mut rr = ReferenceResolution::new(name_ref.syntax().range());\n-            if let Some(fn_descr) = source_binder::function_from_child_node(\n-                &*self.db,\n-                position.file_id,\n-                name_ref.syntax(),\n-            )? {\n-                let scope = fn_descr.scopes(&*self.db);\n+            if let Some(fn_descr) =\n+                source_binder::function_from_child_node(self, position.file_id, name_ref.syntax())?\n+            {\n+                let scope = fn_descr.scopes(self);\n                 // First try to resolve the symbol locally\n                 if let Some(entry) = scope.resolve_local_name(name_ref) {\n                     rr.add_resolution(\n@@ -281,7 +196,7 @@ impl AnalysisImpl {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n                     if let Some(child_module) =\n-                        source_binder::module_from_declaration(&*self.db, position.file_id, module)?\n+                        source_binder::module_from_declaration(self, position.file_id, module)?\n                     {\n                         let file_id = child_module.file_id();\n                         let name = match child_module.name() {\n@@ -302,10 +217,13 @@ impl AnalysisImpl {\n         Ok(None)\n     }\n \n-    pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        let file = self.db.source_file(position.file_id);\n+    pub(crate) fn find_all_refs(\n+        &self,\n+        position: FilePosition,\n+    ) -> Cancelable<Vec<(FileId, TextRange)>> {\n+        let file = self.source_file(position.file_id);\n         // Find the binding associated with the offset\n-        let (binding, descr) = match find_binding(&self.db, &file, position)? {\n+        let (binding, descr) = match find_binding(self, &file, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -317,7 +235,7 @@ impl AnalysisImpl {\n             .collect::<Vec<_>>();\n         ret.extend(\n             descr\n-                .scopes(&*self.db)\n+                .scopes(self)\n                 .find_all_refs(binding)\n                 .into_iter()\n                 .map(|ref_desc| (position.file_id, ref_desc.range)),\n@@ -355,8 +273,8 @@ impl AnalysisImpl {\n             Ok(Some((binding, descr)))\n         }\n     }\n-    pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        let file = self.db.source_file(nav.file_id);\n+    pub(crate) fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n+        let file = self.source_file(nav.file_id);\n         let result = match (nav.symbol.description(&file), nav.symbol.docs(&file)) {\n             (Some(desc), Some(docs)) => {\n                 Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs)\n@@ -369,8 +287,8 @@ impl AnalysisImpl {\n         Ok(result)\n     }\n \n-    pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let syntax = self.db.source_file(file_id);\n+    pub(crate) fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n+        let syntax = self.source_file(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n             .into_iter()\n@@ -381,9 +299,9 @@ impl AnalysisImpl {\n                 fix: d.fix.map(|fix| SourceChange::from_local_edit(file_id, fix)),\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = source_binder::module_from_file_id(&*self.db, file_id)? {\n-            for (name_node, problem) in m.problems(&*self.db) {\n-                let source_root = self.db.file_source_root(file_id);\n+        if let Some(m) = source_binder::module_from_file_id(self, file_id)? {\n+            for (name_node, problem) in m.problems(self) {\n+                let source_root = self.file_source_root(file_id);\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n                         let create_file = FileSystemEdit::CreateFile {\n@@ -433,8 +351,8 @@ impl AnalysisImpl {\n         Ok(res)\n     }\n \n-    pub fn assists(&self, frange: FileRange) -> Vec<SourceChange> {\n-        let file = self.file_syntax(frange.file_id);\n+    pub(crate) fn assists(&self, frange: FileRange) -> Vec<SourceChange> {\n+        let file = self.source_file(frange.file_id);\n         let offset = frange.range.start();\n         let actions = vec![\n             ra_editor::flip_comma(&file, offset).map(|f| f()),\n@@ -451,11 +369,11 @@ impl AnalysisImpl {\n             .collect()\n     }\n \n-    pub fn resolve_callable(\n+    pub(crate) fn resolve_callable(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        let file = self.db.source_file(position.file_id);\n+        let file = self.source_file(position.file_id);\n         let syntax = file.syntax();\n \n         // Find the calling expression and it's NameRef\n@@ -466,12 +384,12 @@ impl AnalysisImpl {\n         let file_symbols = self.index_resolve(name_ref)?;\n         for (fn_file_id, fs) in file_symbols {\n             if fs.kind == FN_DEF {\n-                let fn_file = self.db.source_file(fn_file_id);\n+                let fn_file = self.source_file(fn_file_id);\n                 if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n                     let descr = ctry!(source_binder::function_from_source(\n-                        &*self.db, fn_file_id, fn_def\n+                        self, fn_file_id, fn_def\n                     )?);\n-                    if let Some(descriptor) = descr.signature_info(&*self.db) {\n+                    if let Some(descriptor) = descr.signature_info(self) {\n                         // If we have a calling expression let's find which argument we are on\n                         let mut current_parameter = None;\n \n@@ -518,20 +436,20 @@ impl AnalysisImpl {\n         Ok(None)\n     }\n \n-    pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        let file = self.db.source_file(frange.file_id);\n+    pub(crate) fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n+        let file = self.source_file(frange.file_id);\n         let syntax = file.syntax();\n         let node = find_covering_node(syntax, frange.range);\n         let parent_fn = ctry!(node.ancestors().find_map(FnDef::cast));\n         let function = ctry!(source_binder::function_from_source(\n-            &*self.db,\n+            self,\n             frange.file_id,\n             parent_fn\n         )?);\n-        let infer = function.infer(&*self.db)?;\n+        let infer = function.infer(self)?;\n         Ok(infer.type_of_node(node).map(|t| t.to_string()))\n     }\n-    pub fn rename(\n+    pub(crate) fn rename(\n         &self,\n         position: FilePosition,\n         new_name: &str,\n@@ -555,7 +473,7 @@ impl AnalysisImpl {\n         let mut query = Query::new(name.to_string());\n         query.exact();\n         query.limit(4);\n-        self.world_symbols(query)\n+        crate::symbol_index::world_symbols(self, query)\n     }\n }\n "}, {"sha": "54eb2f4d3af33ed550376b40f11aa6dfadfecf35", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 92, "deletions": 61, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=4f30c459336e948790910e268d8f751b95815ac2", "patch": "@@ -27,11 +27,9 @@ use ra_syntax::{SourceFileNode, TextRange, TextUnit, SmolStr, SyntaxKind};\n use ra_text_edit::TextEdit;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n+use salsa::ParallelDatabase;\n \n-use crate::{\n-    imp::{AnalysisHostImpl, AnalysisImpl},\n-    symbol_index::{SymbolIndex, FileSymbol},\n-};\n+use crate::symbol_index::{SymbolIndex, FileSymbol};\n \n pub use crate::{\n     completion::{CompletionItem, CompletionItemKind, InsertText},\n@@ -44,7 +42,7 @@ pub use hir::FnSignatureInfo;\n \n pub use ra_db::{\n     Canceled, Cancelable, FilePosition, FileRange,\n-    CrateGraph, CrateId, SourceRootId, FileId\n+    CrateGraph, CrateId, SourceRootId, FileId, SyntaxDatabase, FilesDatabase\n };\n \n #[derive(Default)]\n@@ -150,27 +148,6 @@ impl AnalysisChange {\n     }\n }\n \n-/// `AnalysisHost` stores the current state of the world.\n-#[derive(Debug, Default)]\n-pub struct AnalysisHost {\n-    imp: AnalysisHostImpl,\n-}\n-\n-impl AnalysisHost {\n-    /// Returns a snapshot of the current state, which you can query for\n-    /// semantic information.\n-    pub fn analysis(&self) -> Analysis {\n-        Analysis {\n-            imp: self.imp.analysis(),\n-        }\n-    }\n-    /// Applies changes to the current state of the world. If there are\n-    /// outstanding snapshots, they will be canceled.\n-    pub fn apply_change(&mut self, change: AnalysisChange) {\n-        self.imp.apply_change(change)\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n@@ -287,124 +264,178 @@ impl ReferenceResolution {\n     }\n }\n \n+/// `AnalysisHost` stores the current state of the world.\n+#[derive(Debug, Default)]\n+pub struct AnalysisHost {\n+    db: db::RootDatabase,\n+}\n+\n+impl AnalysisHost {\n+    /// Returns a snapshot of the current state, which you can query for\n+    /// semantic information.\n+    pub fn analysis(&self) -> Analysis {\n+        Analysis {\n+            db: self.db.snapshot(),\n+        }\n+    }\n+    /// Applies changes to the current state of the world. If there are\n+    /// outstanding snapshots, they will be canceled.\n+    pub fn apply_change(&mut self, change: AnalysisChange) {\n+        self.db.apply_change(change)\n+    }\n+}\n+\n /// Analysis is a snapshot of a world state at a moment in time. It is the main\n /// entry point for asking semantic information about the world. When the world\n /// state is advanced using `AnalysisHost::apply_change` method, all existing\n /// `Analysis` are canceled (most method return `Err(Canceled)`).\n #[derive(Debug)]\n pub struct Analysis {\n-    pub(crate) imp: AnalysisImpl,\n+    db: salsa::Snapshot<db::RootDatabase>,\n }\n \n impl Analysis {\n+    /// Gets the text of the source file.\n     pub fn file_text(&self, file_id: FileId) -> Arc<String> {\n-        self.imp.file_text(file_id)\n+        self.db.file_text(file_id)\n     }\n+    /// Gets the syntax tree of the file.\n     pub fn file_syntax(&self, file_id: FileId) -> SourceFileNode {\n-        self.imp.file_syntax(file_id).clone()\n+        self.db.source_file(file_id).clone()\n     }\n+    /// Gets the file's `LineIndex`: data structure to convert between absolute\n+    /// offsets and line/column representation.\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n-        self.imp.file_line_index(file_id)\n+        self.db.file_lines(file_id)\n     }\n+    /// Selects the next syntactic nodes encopasing the range.\n     pub fn extend_selection(&self, frange: FileRange) -> TextRange {\n-        extend_selection::extend_selection(&self.imp.db, frange)\n+        extend_selection::extend_selection(&self.db, frange)\n     }\n+    /// Returns position of the mathcing brace (all types of braces are\n+    /// supported).\n     pub fn matching_brace(&self, file: &SourceFileNode, offset: TextUnit) -> Option<TextUnit> {\n         ra_editor::matching_brace(file, offset)\n     }\n+    /// Returns a syntax tree represented as `String`, for debug purposes.\n+    // FIXME: use a better name here.\n     pub fn syntax_tree(&self, file_id: FileId) -> String {\n-        let file = self.imp.file_syntax(file_id);\n+        let file = self.db.source_file(file_id);\n         ra_editor::syntax_tree(&file)\n     }\n+    /// Returns an edit to remove all newlines in the range, cleaning up minor\n+    /// stuff like trailing commas.\n     pub fn join_lines(&self, frange: FileRange) -> SourceChange {\n-        let file = self.imp.file_syntax(frange.file_id);\n+        let file = self.db.source_file(frange.file_id);\n         SourceChange::from_local_edit(frange.file_id, ra_editor::join_lines(&file, frange.range))\n     }\n+    /// Returns an edit which should be applied when opening a new line, fixing\n+    /// up minor stuff like continuing the comment.\n     pub fn on_enter(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.imp.file_syntax(position.file_id);\n+        let file = self.db.source_file(position.file_id);\n         let edit = ra_editor::on_enter(&file, position.offset)?;\n-        let res = SourceChange::from_local_edit(position.file_id, edit);\n-        Some(res)\n+        Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+    /// Returns an edit which should be applied after `=` was typed. Primaraly,\n+    /// this works when adding `let =`.\n+    // FIXME: use a snippet completion instead of this hack here.\n     pub fn on_eq_typed(&self, position: FilePosition) -> Option<SourceChange> {\n-        let file = self.imp.file_syntax(position.file_id);\n-        Some(SourceChange::from_local_edit(\n-            position.file_id,\n-            ra_editor::on_eq_typed(&file, position.offset)?,\n-        ))\n+        let file = self.db.source_file(position.file_id);\n+        let edit = ra_editor::on_eq_typed(&file, position.offset)?;\n+        Some(SourceChange::from_local_edit(position.file_id, edit))\n     }\n+    /// Returns a tree representation of symbols in the file. Useful to draw a\n+    /// file outline.\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n-        let file = self.imp.file_syntax(file_id);\n+        let file = self.db.source_file(file_id);\n         ra_editor::file_structure(&file)\n     }\n+    /// Returns the set of folding ranges.\n     pub fn folding_ranges(&self, file_id: FileId) -> Vec<Fold> {\n-        let file = self.imp.file_syntax(file_id);\n+        let file = self.db.source_file(file_id);\n         ra_editor::folding_ranges(&file)\n     }\n+    /// Fuzzy searches for a symbol.\n     pub fn symbol_search(&self, query: Query) -> Cancelable<Vec<NavigationTarget>> {\n-        let res = self\n-            .imp\n-            .world_symbols(query)?\n+        let res = symbol_index::world_symbols(&*self.db, query)?\n             .into_iter()\n             .map(|(file_id, symbol)| NavigationTarget { file_id, symbol })\n             .collect();\n         Ok(res)\n     }\n+    /// Resolves reference to definition, but does not gurantee correctness.\n     pub fn approximately_resolve_symbol(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<ReferenceResolution>> {\n-        self.imp.approximately_resolve_symbol(position)\n+        self.db.approximately_resolve_symbol(position)\n     }\n+    /// Finds all usages of the reference at point.\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n-        self.imp.find_all_refs(position)\n+        self.db.find_all_refs(position)\n     }\n+    /// Returns documentation string for a given target.\n     pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        self.imp.doc_text_for(nav)\n+        self.db.doc_text_for(nav)\n     }\n+    /// Returns a `mod name;` declaration whihc created the current module.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<NavigationTarget>> {\n-        self.imp.parent_module(position)\n+        self.db.parent_module(position)\n     }\n+    /// Returns `::` separated path to the current module from the crate root.\n     pub fn module_path(&self, position: FilePosition) -> Cancelable<Option<String>> {\n-        self.imp.module_path(position)\n+        self.db.module_path(position)\n     }\n+    /// Returns crates this file belongs too.\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        self.imp.crate_for(file_id)\n+        self.db.crate_for(file_id)\n     }\n+    /// Returns the root file of the given crate.\n     pub fn crate_root(&self, crate_id: CrateId) -> Cancelable<FileId> {\n-        Ok(self.imp.crate_root(crate_id))\n+        Ok(self.db.crate_root(crate_id))\n     }\n+    /// Returns the set of possible targets to run for the current file.\n     pub fn runnables(&self, file_id: FileId) -> Cancelable<Vec<Runnable>> {\n-        let file = self.imp.file_syntax(file_id);\n+        let file = self.db.source_file(file_id);\n         Ok(runnables::runnables(self, &file, file_id))\n     }\n+    /// Computes syntax highlighting for the given file.\n     pub fn highlight(&self, file_id: FileId) -> Cancelable<Vec<HighlightedRange>> {\n-        syntax_highlighting::highlight(&*self.imp.db, file_id)\n+        syntax_highlighting::highlight(&*self.db, file_id)\n     }\n+    /// Computes completions at the given position.\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n-        self.imp.completions(position)\n+        let completions = completion::completions(&self.db, position)?;\n+        Ok(completions.map(|it| it.into()))\n     }\n+    /// Computes assists (aks code actons aka intentions) for the given\n+    /// position.\n     pub fn assists(&self, frange: FileRange) -> Cancelable<Vec<SourceChange>> {\n-        Ok(self.imp.assists(frange))\n+        Ok(self.db.assists(frange))\n     }\n+    /// Computes the set of diagnostics for the given file.\n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        self.imp.diagnostics(file_id)\n+        self.db.diagnostics(file_id)\n     }\n+    /// Computes parameter information for the given call expression.\n     pub fn resolve_callable(\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n-        self.imp.resolve_callable(position)\n+        self.db.resolve_callable(position)\n     }\n+    /// Computes the type of the expression at the given position.\n     pub fn type_of(&self, frange: FileRange) -> Cancelable<Option<String>> {\n-        self.imp.type_of(frange)\n+        self.db.type_of(frange)\n     }\n+    /// Returns the edit required to rename reference at the position to the new\n+    /// name.\n     pub fn rename(\n         &self,\n         position: FilePosition,\n         new_name: &str,\n     ) -> Cancelable<Vec<SourceFileEdit>> {\n-        self.imp.rename(position, new_name)\n+        self.db.rename(position, new_name)\n     }\n }\n "}, {"sha": "ddcf3d052bb45204b0ee0477ecf2f34b92c5729b", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f30c459336e948790910e268d8f751b95815ac2/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=4f30c459336e948790910e268d8f751b95815ac2", "patch": "@@ -10,12 +10,13 @@ use ra_syntax::{\n     SyntaxKind::{self, *},\n     ast::{self, NameOwner, DocCommentsOwner},\n };\n-use ra_db::{SyntaxDatabase, SourceRootId};\n+use ra_db::{SyntaxDatabase, SourceRootId, FilesDatabase};\n+use salsa::ParallelDatabase;\n use rayon::prelude::*;\n \n use crate::{\n-    Cancelable,\n-    FileId, Query,\n+    Cancelable, FileId, Query,\n+    db::RootDatabase,\n };\n \n salsa::query_group! {\n@@ -36,6 +37,41 @@ fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Cancelable<Arc<Sym\n     Ok(Arc::new(SymbolIndex::for_file(file_id, syntax)))\n }\n \n+pub(crate) fn world_symbols(\n+    db: &RootDatabase,\n+    query: Query,\n+) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n+    /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n+    struct Snap(salsa::Snapshot<RootDatabase>);\n+    impl Clone for Snap {\n+        fn clone(&self) -> Snap {\n+            Snap(self.0.snapshot())\n+        }\n+    }\n+\n+    let buf: Vec<Arc<SymbolIndex>> = if query.libs {\n+        let snap = Snap(db.snapshot());\n+        db.library_roots()\n+            .par_iter()\n+            .map_with(snap, |db, &lib_id| db.0.library_symbols(lib_id))\n+            .collect()\n+    } else {\n+        let mut files = Vec::new();\n+        for &root in db.local_roots().iter() {\n+            let sr = db.source_root(root);\n+            files.extend(sr.files.values().map(|&it| it))\n+        }\n+\n+        let snap = Snap(db.snapshot());\n+        files\n+            .par_iter()\n+            .map_with(snap, |db, &file_id| db.0.file_symbols(file_id))\n+            .filter_map(|it| it.ok())\n+            .collect()\n+    };\n+    Ok(query.search(&buf))\n+}\n+\n #[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n     symbols: Vec<(FileId, FileSymbol)>,"}]}