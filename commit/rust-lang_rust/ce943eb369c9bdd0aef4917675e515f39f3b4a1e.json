{"sha": "ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOTQzZWIzNjljOWJkZDBhZWY0OTE3Njc1ZTUxNWYzOWYzYjRhMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T16:27:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-13T16:27:17Z"}, "message": "Auto merge of #32184 - ollie27:win_stdout, r=alexcrichton\n\nFixup stout/stderr on Windows\n\nWriteConsoleW can fail if called with a large buffer so we need to slice\nany stdout/stderr output.\nHowever the current slicing has a few problems:\n 1. It slices by byte but still expects valid UTF-8.\n 2. The slicing happens even when not outputting to a console.\n 3. panic! output is not sliced.\n\nThis fixes these issues by moving the slice to right before\nWriteConsoleW and slicing on a char boundary.", "tree": {"sha": "b66a3a32cd6198ffea1bbf50afeba20092c5ca2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b66a3a32cd6198ffea1bbf50afeba20092c5ca2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "html_url": "https://github.com/rust-lang/rust/commit/ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce943eb369c9bdd0aef4917675e515f39f3b4a1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c8b245928c3f2463b45fbddd862a0a70882d087", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c8b245928c3f2463b45fbddd862a0a70882d087", "html_url": "https://github.com/rust-lang/rust/commit/1c8b245928c3f2463b45fbddd862a0a70882d087"}, {"sha": "bd80a53407e15f13ce50a07642491680010fa090", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd80a53407e15f13ce50a07642491680010fa090", "html_url": "https://github.com/rust-lang/rust/commit/bd80a53407e15f13ce50a07642491680010fa090"}], "stats": {"total": 44, "additions": 21, "deletions": 23}, "files": [{"sha": "e1a388c38c45334272b1bbdfbfc61f422ef37af2", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ce943eb369c9bdd0aef4917675e515f39f3b4a1e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce943eb369c9bdd0aef4917675e515f39f3b4a1e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "patch": "@@ -12,7 +12,6 @@ use prelude::v1::*;\n use io::prelude::*;\n \n use cell::{RefCell, BorrowState};\n-use cmp;\n use fmt;\n use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n@@ -312,22 +311,6 @@ impl<'a> BufRead for StdinLock<'a> {\n     fn consume(&mut self, n: usize) { self.inner.consume(n) }\n }\n \n-// As with stdin on windows, stdout often can't handle writes of large\n-// sizes. For an example, see #14940. For this reason, don't try to\n-// write the entire output buffer on windows. On unix we can just\n-// write the whole buffer all at once.\n-//\n-// For some other references, it appears that this problem has been\n-// encountered by others [1] [2]. We choose the number 8KB just because\n-// libuv does the same.\n-//\n-// [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-// [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-#[cfg(windows)]\n-const OUT_MAX: usize = 8192;\n-#[cfg(unix)]\n-const OUT_MAX: usize = ::usize::MAX;\n-\n /// A handle to the global standard output stream of the current process.\n ///\n /// Each handle shares a global buffer of data to be written to the standard\n@@ -440,7 +423,7 @@ impl Write for Stdout {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StdoutLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.borrow_mut().write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+        self.inner.borrow_mut().write(buf)\n     }\n     fn flush(&mut self) -> io::Result<()> {\n         self.inner.borrow_mut().flush()\n@@ -546,7 +529,7 @@ impl Write for Stderr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for StderrLock<'a> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.inner.borrow_mut().write(&buf[..cmp::min(buf.len(), OUT_MAX)])\n+        self.inner.borrow_mut().write(buf)\n     }\n     fn flush(&mut self) -> io::Result<()> {\n         self.inner.borrow_mut().flush()"}, {"sha": "0a0851ffac37aeb2ca88c7d28878237b268f9501", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ce943eb369c9bdd0aef4917675e515f39f3b4a1e/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce943eb369c9bdd0aef4917675e515f39f3b4a1e/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=ce943eb369c9bdd0aef4917675e515f39f3b4a1e", "patch": "@@ -13,6 +13,7 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n+use cmp;\n use io::{self, Cursor};\n use ptr;\n use str;\n@@ -58,10 +59,24 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n         Output::Console(ref c) => c.get().raw(),\n         Output::Pipe(ref p) => return p.get().write(data),\n     };\n-    let utf16 = match str::from_utf8(data).ok() {\n-        Some(utf8) => utf8.encode_utf16().collect::<Vec<u16>>(),\n-        None => return Err(invalid_encoding()),\n+    // As with stdin on windows, stdout often can't handle writes of large\n+    // sizes. For an example, see #14940. For this reason, don't try to\n+    // write the entire output buffer on windows.\n+    //\n+    // For some other references, it appears that this problem has been\n+    // encountered by others [1] [2]. We choose the number 8K just because\n+    // libuv does the same.\n+    //\n+    // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n+    // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n+    const OUT_MAX: usize = 8192;\n+    let len = cmp::min(data.len(), OUT_MAX);\n+    let utf8 = match str::from_utf8(&data[..len]) {\n+        Ok(s) => s,\n+        Err(ref e) if e.valid_up_to() == 0 => return Err(invalid_encoding()),\n+        Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n+    let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n     let mut written = 0;\n     try!(cvt(unsafe {\n         c::WriteConsoleW(handle,\n@@ -74,7 +89,7 @@ fn write(out: &Output, data: &[u8]) -> io::Result<usize> {\n     // FIXME if this only partially writes the utf16 buffer then we need to\n     //       figure out how many bytes of `data` were actually written\n     assert_eq!(written as usize, utf16.len());\n-    Ok(data.len())\n+    Ok(utf8.len())\n }\n \n impl Stdin {"}]}