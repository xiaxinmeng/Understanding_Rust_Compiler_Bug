{"sha": "1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "node_id": "C_kwDOAAsO6NoAKDExNTdkYzcxNjdkMTNhOWJkY2FmZDMwYjhhZDBlY2Y1YWU1ZmFhN2Y", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-05T14:33:42Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-04-21T13:53:26Z"}, "message": "implement valtree -> constvalue conversion", "tree": {"sha": "c7ecab9600453754e9e87d9ad86e4c392874cc4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7ecab9600453754e9e87d9ad86e4c392874cc4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "html_url": "https://github.com/rust-lang/rust/commit/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaf8cdaa0bcf7bc188da8d8d0a35126cf37b0580", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf8cdaa0bcf7bc188da8d8d0a35126cf37b0580", "html_url": "https://github.com/rust-lang/rust/commit/eaf8cdaa0bcf7bc188da8d8d0a35126cf37b0580"}], "stats": {"total": 697, "additions": 546, "deletions": 151}, "files": [{"sha": "38fecf7232ebc704436755d752b000401df2afbb", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -106,6 +106,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n \n /// This function converts an interpreter value into a constant that is meant for use in the\n /// type system.\n+#[instrument(skip(ecx), level = \"debug\")]\n pub(super) fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: &OpTy<'tcx>,\n@@ -140,21 +141,26 @@ pub(super) fn op_to_const<'tcx>(\n         op.try_as_mplace()\n     };\n \n+    debug!(?immediate);\n+\n     // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-    let to_const_value = |mplace: &MPlaceTy<'_>| match mplace.ptr.into_parts() {\n-        (Some(alloc_id), offset) => {\n-            let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n-            ConstValue::ByRef { alloc, offset }\n-        }\n-        (None, offset) => {\n-            assert!(mplace.layout.is_zst());\n-            assert_eq!(\n-                offset.bytes() % mplace.layout.align.abi.bytes(),\n-                0,\n-                \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n+    let to_const_value = |mplace: &MPlaceTy<'_>| {\n+        debug!(\"to_const_value(mplace: {:?})\", mplace);\n+        match mplace.ptr.into_parts() {\n+            (Some(alloc_id), offset) => {\n+                let alloc = ecx.tcx.global_alloc(alloc_id).unwrap_memory();\n+                ConstValue::ByRef { alloc, offset }\n+            }\n+            (None, offset) => {\n+                assert!(mplace.layout.is_zst());\n+                assert_eq!(\n+                    offset.bytes() % mplace.layout.align.abi.bytes(),\n+                    0,\n+                    \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n                 alignment is correct\",\n-            );\n-            ConstValue::Scalar(Scalar::ZST)\n+                );\n+                ConstValue::Scalar(Scalar::ZST)\n+            }\n         }\n     };\n     match immediate {\n@@ -166,6 +172,7 @@ pub(super) fn op_to_const<'tcx>(\n                 ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n             },\n             Immediate::ScalarPair(a, b) => {\n+                debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n                 let (data, start) =\n                     match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n@@ -209,7 +216,10 @@ fn turn_into_const_value<'tcx>(\n     );\n \n     // Turn this into a proper constant.\n-    op_to_const(&ecx, &mplace.into())\n+    let const_val = op_to_const(&ecx, &mplace.into());\n+    debug!(?const_val);\n+\n+    const_val\n }\n \n pub fn eval_to_const_value_raw_provider<'tcx>("}, {"sha": "96c18d488ee8c1e38aa6186cdad0be6f64d6190d", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 6, "deletions": 130, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -3,29 +3,26 @@\n use std::convert::TryFrom;\n \n use rustc_hir::Mutability;\n-use rustc_middle::ty::layout::HasTyCtxt;\n+use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_middle::{\n-    mir::{self, interpret::ConstAlloc},\n-    ty::ScalarInt,\n-};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n-use rustc_target::abi::VariantIdx;\n \n use crate::interpret::{\n-    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MPlaceTy,\n-    MemPlaceMeta, Scalar,\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, InterpResult, MemPlaceMeta,\n+    Scalar,\n };\n \n mod error;\n mod eval_queries;\n mod fn_queries;\n mod machine;\n+mod valtrees;\n \n pub use error::*;\n pub use eval_queries::*;\n pub use fn_queries::*;\n pub use machine::*;\n+pub(crate) use valtrees::{const_to_valtree, valtree_to_const_value};\n \n pub(crate) fn const_caller_location(\n     tcx: TyCtxt<'_>,\n@@ -41,128 +38,6 @@ pub(crate) fn const_caller_location(\n     ConstValue::Scalar(Scalar::from_maybe_pointer(loc_place.ptr, &tcx))\n }\n \n-/// Convert an evaluated constant to a type level constant\n-pub(crate) fn const_to_valtree<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    raw: ConstAlloc<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let ecx = mk_eval_cx(\n-        tcx, DUMMY_SP, param_env,\n-        // It is absolutely crucial for soundness that\n-        // we do not read from static items or other mutable memory.\n-        false,\n-    );\n-    let place = ecx.raw_const_to_mplace(raw).unwrap();\n-    const_to_valtree_inner(&ecx, &place)\n-}\n-\n-#[instrument(skip(ecx), level = \"debug\")]\n-fn branches<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-    n: usize,\n-    variant: Option<VariantIdx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let place = match variant {\n-        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n-        None => *place,\n-    };\n-    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n-    debug!(?place, ?variant);\n-\n-    let fields = (0..n).map(|i| {\n-        let field = ecx.mplace_field(&place, i).unwrap();\n-        const_to_valtree_inner(ecx, &field)\n-    });\n-    // For enums, we prepend their variant index before the variant's fields so we can figure out\n-    // the variant again when just seeing a valtree.\n-    let branches = variant.into_iter().chain(fields);\n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n-}\n-\n-fn slice_branches<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    let n = place.len(&ecx.tcx()).expect(&format!(\"expected to use len of place {:?}\", place));\n-    let branches = (0..n).map(|i| {\n-        let place_elem = ecx.mplace_index(place, i).unwrap();\n-        const_to_valtree_inner(ecx, &place_elem)\n-    });\n-\n-    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n-}\n-\n-#[instrument(skip(ecx), level = \"debug\")]\n-fn const_to_valtree_inner<'tcx>(\n-    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n-    place: &MPlaceTy<'tcx>,\n-) -> Option<ty::ValTree<'tcx>> {\n-    match place.layout.ty.kind() {\n-        ty::FnDef(..) => Some(ty::ValTree::zst()),\n-        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n-            let val = ecx.read_immediate(&place.into()).unwrap();\n-            let val = val.to_scalar().unwrap();\n-            Some(ty::ValTree::Leaf(val.assert_int()))\n-        }\n-\n-        // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n-        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n-        // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n-        // agree with runtime equality tests.\n-        ty::FnPtr(_) | ty::RawPtr(_) => None,\n-\n-        ty::Ref(_, _, _)  => {\n-            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n-            debug!(?derefd_place);\n-\n-            const_to_valtree_inner(ecx, &derefd_place)\n-        }\n-\n-        ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n-            let valtree = slice_branches(ecx, place);\n-            debug!(?valtree);\n-\n-            valtree\n-        }\n-        // Trait objects are not allowed in type level constants, as we have no concept for\n-        // resolving their backing type, even if we can do that at const eval time. We may\n-        // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n-        // but it is unclear if this is useful.\n-        ty::Dynamic(..) => None,\n-\n-        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n-\n-        ty::Adt(def, _) => {\n-            if def.variants().is_empty() {\n-                bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n-            }\n-\n-            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n-\n-            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n-        }\n-\n-        ty::Never\n-        | ty::Error(_)\n-        | ty::Foreign(..)\n-        | ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        // FIXME(oli-obk): we could look behind opaque types\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        // FIXME(oli-obk): we can probably encode closures just like structs\n-        | ty::Closure(..)\n-        | ty::Generator(..)\n-        | ty::GeneratorWitness(..) => None,\n-    }\n-}\n-\n /// This function should never fail for validated constants. However, it is also invoked from the\n /// pretty printer which might attempt to format invalid constants and in that case it might fail.\n pub(crate) fn try_destructure_const<'tcx>(\n@@ -202,6 +77,7 @@ pub(crate) fn try_destructure_const<'tcx>(\n     Ok(mir::DestructuredConst { variant, fields })\n }\n \n+#[instrument(skip(tcx), level = \"debug\")]\n pub(crate) fn deref_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "ded539fd3408bed79f0e594b8153106b0bdb23a7", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -0,0 +1,479 @@\n+use super::eval_queries::{mk_eval_cx, op_to_const};\n+use super::machine::CompileTimeEvalContext;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemoryKind, PlaceTy,\n+    Pointer, Scalar, ScalarMaybeUninit,\n+};\n+use rustc_middle::mir::interpret::{ConstAlloc, GlobalAlloc};\n+use rustc_middle::mir::{Field, ProjectionElem};\n+use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n+use rustc_span::source_map::DUMMY_SP;\n+use rustc_target::abi::VariantIdx;\n+\n+use crate::interpret::visitor::Value;\n+use crate::interpret::MPlaceTy;\n+\n+/// Convert an evaluated constant to a type level constant\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(crate) fn const_to_valtree<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    raw: ConstAlloc<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let ecx = mk_eval_cx(\n+        tcx, DUMMY_SP, param_env,\n+        // It is absolutely crucial for soundness that\n+        // we do not read from static items or other mutable memory.\n+        false,\n+    );\n+    let place = ecx.raw_const_to_mplace(raw).unwrap();\n+    const_to_valtree_inner(&ecx, &place)\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+    n: usize,\n+    variant: Option<VariantIdx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let place = match variant {\n+        Some(variant) => ecx.mplace_downcast(&place, variant).unwrap(),\n+        None => *place,\n+    };\n+    let variant = variant.map(|variant| Some(ty::ValTree::Leaf(ScalarInt::from(variant.as_u32()))));\n+    debug!(?place, ?variant);\n+\n+    let fields = (0..n).map(|i| {\n+        let field = ecx.mplace_field(&place, i).unwrap();\n+        const_to_valtree_inner(ecx, &field)\n+    });\n+    // For enums, we preped their variant index before the variant's fields so we can figure out\n+    // the variant again when just seeing a valtree.\n+    let branches = variant.into_iter().chain(fields);\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+fn slice_branches<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    let n = place.len(&ecx.tcx.tcx).expect(&format!(\"expected to use len of place {:?}\", place));\n+    let branches = (0..n).map(|i| {\n+        let place_elem = ecx.mplace_index(place, i).unwrap();\n+        const_to_valtree_inner(ecx, &place_elem)\n+    });\n+\n+    Some(ty::ValTree::Branch(ecx.tcx.arena.alloc_from_iter(branches.collect::<Option<Vec<_>>>()?)))\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn const_to_valtree_inner<'tcx>(\n+    ecx: &CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &MPlaceTy<'tcx>,\n+) -> Option<ty::ValTree<'tcx>> {\n+    match place.layout.ty.kind() {\n+        ty::FnDef(..) => Some(ty::ValTree::zst()),\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n+            let val = ecx.read_immediate(&place.into()).unwrap();\n+            let val = val.to_scalar().unwrap();\n+            Some(ty::ValTree::Leaf(val.assert_int()))\n+        }\n+\n+        // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n+        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n+        // agree with runtime equality tests.\n+        ty::FnPtr(_) | ty::RawPtr(_) => None,\n+\n+        ty::Ref(_, _, _)  => {\n+            let derefd_place = ecx.deref_operand(&place.into()).unwrap_or_else(|e| bug!(\"couldn't deref {:?}, error: {:?}\", place, e));\n+            debug!(?derefd_place);\n+\n+            const_to_valtree_inner(ecx, &derefd_place)\n+        }\n+\n+        ty::Str | ty::Slice(_) | ty::Array(_, _) => {\n+            let valtree = slice_branches(ecx, place);\n+            debug!(?valtree);\n+\n+            valtree\n+        }\n+        // Trait objects are not allowed in type level constants, as we have no concept for\n+        // resolving their backing type, even if we can do that at const eval time. We may\n+        // hypothetically be able to allow `dyn StructuralEq` trait objects in the future,\n+        // but it is unclear if this is useful.\n+        ty::Dynamic(..) => None,\n+\n+        ty::Tuple(substs) => branches(ecx, place, substs.len(), None),\n+\n+        ty::Adt(def, _) => {\n+            if def.variants().is_empty() {\n+                bug!(\"uninhabited types should have errored and never gotten converted to valtree\")\n+            }\n+\n+            let variant = ecx.read_discriminant(&place.into()).unwrap().1;\n+\n+            branches(ecx, place, def.variant(variant).fields.len(), def.is_enum().then_some(variant))\n+        }\n+\n+        ty::Never\n+        | ty::Error(_)\n+        | ty::Foreign(..)\n+        | ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        // FIXME(oli-obk): we could look behind opaque types\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        // FIXME(oli-obk): we can probably encode closures just like structs\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..) => None,\n+    }\n+}\n+\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn create_mplace_from_layout<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+) -> MPlaceTy<'tcx> {\n+    let tcx = ecx.tcx;\n+    let layout = tcx.layout_of(param_env_ty).unwrap();\n+    debug!(?layout);\n+\n+    ecx.allocate(layout, MemoryKind::Stack).unwrap()\n+}\n+\n+/// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n+/// construction has finished.\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub fn valtree_to_const_value<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    valtree: ty::ValTree<'tcx>,\n+) -> ConstValue<'tcx> {\n+    // Basic idea: We directly construct `Scalar` values from trivial `ValTree`s\n+    // (those for constants with type bool, int, uint, float or char).\n+    // For all other types we create an `MPlace` and fill that by walking\n+    // the `ValTree` and using `place_projection` and `place_field` to\n+    // create inner `MPlace`s which are filled recursively.\n+    // FIXME Does this need an example?\n+\n+    let (param_env, ty) = param_env_ty.into_parts();\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+\n+    match ty.kind() {\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => match valtree {\n+            ty::ValTree::Leaf(scalar_int) => ConstValue::Scalar(Scalar::Int(scalar_int)),\n+            ty::ValTree::Branch(_) => bug!(\n+                \"ValTrees for Bool, Int, Uint, Float or Char should have the form ValTree::Leaf\"\n+            ),\n+        },\n+        ty::Ref(_, inner_ty, _) => {\n+            match inner_ty.kind() {\n+                ty::Slice(_) | ty::Str => {\n+                    let slice_ty = match inner_ty.kind() {\n+                        ty::Slice(slice_ty) => *slice_ty,\n+                        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+                        _ => bug!(\"expected ty::Slice | ty::Str\"),\n+                    };\n+                    debug!(?slice_ty);\n+\n+                    let valtrees = valtree.unwrap_branch();\n+\n+                    // Create a place for the underlying array\n+                    let len = valtrees.len();\n+                    let arr_ty = tcx.mk_array(slice_ty, len as u64);\n+                    let mut place =\n+                        create_mplace_from_layout(&mut ecx, ty::ParamEnv::empty().and(arr_ty));\n+                    debug!(?place);\n+\n+                    // Insert elements of `arr_valtree` into `place`\n+                    fill_place_recursively(&mut ecx, &mut place, valtree, arr_ty);\n+                    dump_place(&ecx, place.into());\n+\n+                    // The allocation behind `place` is local, we need to intern it\n+                    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n+\n+                    // Now we need to get the Allocation\n+                    let alloc_id = place.mplace.ptr.provenance.unwrap();\n+                    debug!(?alloc_id);\n+\n+                    let data = match tcx.get_global_alloc(alloc_id) {\n+                        Some(GlobalAlloc::Memory(const_alloc)) => const_alloc,\n+                        _ => bug!(\"expected memory allocation\"),\n+                    };\n+                    debug!(?data);\n+\n+                    return ConstValue::Slice { data, start: 0, end: len as usize };\n+                }\n+                _ => {\n+                    match valtree {\n+                        ty::ValTree::Branch(_) => {\n+                            // create a place for the pointee\n+                            let mut place = create_mplace_from_layout(\n+                                &mut ecx,\n+                                ty::ParamEnv::empty().and(*inner_ty),\n+                            );\n+                            debug!(?place);\n+\n+                            // insert elements of valtree into `place`\n+                            fill_place_recursively(&mut ecx, &mut place, valtree, *inner_ty);\n+                            dump_place(&ecx, place.into());\n+                            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place)\n+                                .unwrap();\n+\n+                            let ref_place = place.mplace.to_ref(&tcx);\n+                            let imm = ImmTy::from_immediate(\n+                                ref_place,\n+                                tcx.layout_of(param_env_ty).unwrap(),\n+                            );\n+\n+                            let const_val = op_to_const(&ecx, &imm.into());\n+                            debug!(?const_val);\n+\n+                            const_val\n+                        }\n+                        ty::ValTree::Leaf(_) => {\n+                            let mut place = create_mplace_from_layout(\n+                                &mut ecx,\n+                                ty::ParamEnv::empty().and(*inner_ty),\n+                            );\n+\n+                            fill_place_recursively(&mut ecx, &mut place, valtree, *inner_ty);\n+                            dump_place(&ecx, place.into());\n+\n+                            let ref_place = place.mplace.to_ref(&tcx);\n+                            let imm = ImmTy::from_immediate(\n+                                ref_place,\n+                                tcx.layout_of(param_env_ty).unwrap(),\n+                            );\n+\n+                            op_to_const(&ecx, &imm.into())\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        ty::Tuple(_) | ty::Array(_, _) | ty::Adt(..) => {\n+            let mut place = create_mplace_from_layout(&mut ecx, param_env_ty);\n+            debug!(?place);\n+\n+            fill_place_recursively(&mut ecx, &mut place, valtree, ty);\n+            dump_place(&ecx, place.into());\n+            intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n+\n+            let const_val = op_to_const(&ecx, &place.into());\n+            debug!(?const_val);\n+\n+            const_val\n+        }\n+        ty::Never\n+        | ty::FnDef(..)\n+        | ty::Error(_)\n+        | ty::Foreign(..)\n+        | ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::FnPtr(_)\n+        | ty::RawPtr(_)\n+        | ty::Str\n+        | ty::Slice(_)\n+        | ty::Dynamic(..) => bug!(\"no ValTree should have been created for type {:?}\", ty.kind()),\n+    }\n+}\n+\n+// FIXME Needs a better/correct name\n+#[instrument(skip(ecx), level = \"debug\")]\n+fn fill_place_recursively<'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n+    place: &mut MPlaceTy<'tcx>,\n+    valtree: ty::ValTree<'tcx>,\n+    ty: Ty<'tcx>,\n+) {\n+    // This will match on valtree and write the value(s) corresponding to the ValTree\n+    // inside the place recursively.\n+\n+    let tcx = ecx.tcx.tcx;\n+\n+    match ty.kind() {\n+        ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n+            let scalar_int = valtree.unwrap_leaf();\n+            debug!(\"writing trivial valtree {:?} to place {:?}\", scalar_int, place);\n+            ecx.write_immediate(\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar_int.into())),\n+                &(*place).into(),\n+            )\n+            .unwrap();\n+        }\n+        ty::Ref(_, inner_ty, _) => {\n+            match inner_ty.kind() {\n+                ty::Slice(_) | ty::Str => {\n+                    let slice_ty = match inner_ty.kind() {\n+                        ty::Slice(slice_ty) => *slice_ty,\n+                        ty::Str => tcx.mk_ty(ty::Uint(ty::UintTy::U8)),\n+                        _ => bug!(\"expected ty::Slice | ty::Str\"),\n+                    };\n+                    debug!(?slice_ty);\n+\n+                    let valtrees = valtree.unwrap_branch();\n+                    debug!(?valtrees);\n+                    let len = valtrees.len();\n+                    debug!(?len);\n+\n+                    // create a place for the underlying array\n+                    let arr_ty = tcx.mk_array(slice_ty, len as u64);\n+                    let mut arr_place =\n+                        create_mplace_from_layout(ecx, ty::ParamEnv::empty().and(arr_ty));\n+                    debug!(?arr_place);\n+\n+                    // Insert elements of `arr_valtree` into `place`\n+                    fill_place_recursively(ecx, &mut arr_place, valtree, arr_ty);\n+                    dump_place(&ecx, arr_place.into());\n+\n+                    // Now we need to create a `ScalarPair` from the filled `place`\n+                    // and write that into `place`\n+                    let (alloc_id, offset) = arr_place.mplace.ptr.into_parts();\n+                    debug!(?alloc_id, ?offset);\n+                    let unwrapped_ptr = Pointer { offset, provenance: alloc_id.unwrap() };\n+                    let len_scalar = ScalarMaybeUninit::Scalar(Scalar::from_u64(len as u64));\n+\n+                    let imm = Immediate::ScalarPair(\n+                        ScalarMaybeUninit::from_pointer(unwrapped_ptr, &tcx),\n+                        len_scalar,\n+                    );\n+                    debug!(?imm);\n+\n+                    // Now write the ScalarPair into the original place we wanted to fill\n+                    // in this call\n+                    let _ = ecx.write_immediate(imm, &(*place).into()).unwrap();\n+\n+                    dump_place(&ecx, (*place).into());\n+                }\n+                _ => {\n+                    let mut pointee_place =\n+                        create_mplace_from_layout(ecx, ty::ParamEnv::empty().and(*inner_ty));\n+                    debug!(?pointee_place);\n+                    fill_place_recursively(ecx, &mut pointee_place, valtree, *inner_ty);\n+\n+                    dump_place(ecx, pointee_place.into());\n+                    intern_const_alloc_recursive(ecx, InternKind::Constant, &pointee_place)\n+                        .unwrap();\n+\n+                    let imm = pointee_place.mplace.to_ref(&tcx);\n+                    debug!(?imm);\n+\n+                    ecx.write_immediate(imm, &(*place).into()).unwrap();\n+                }\n+            }\n+        }\n+        ty::Tuple(tuple_types) => {\n+            let branches = valtree.unwrap_branch();\n+            assert_eq!(tuple_types.len(), branches.len());\n+\n+            for (i, inner_valtree) in branches.iter().enumerate() {\n+                debug!(?i, ?inner_valtree);\n+                let inner_ty = tuple_types.get(i).expect(&format!(\n+                    \"expected to be able to index at position {} into {:?}\",\n+                    i, tuple_types\n+                ));\n+                debug!(?inner_ty);\n+\n+                // Create the mplace for the tuple element\n+                let mut place_inner = ecx.mplace_field(place, i).unwrap();\n+                debug!(?place_inner);\n+\n+                // insert valtree corresponding to tuple element into place\n+                fill_place_recursively(ecx, &mut place_inner, *inner_valtree, *inner_ty);\n+            }\n+        }\n+        ty::Array(inner_ty, _) => {\n+            let inner_valtrees = valtree.unwrap_branch();\n+            for (i, inner_valtree) in inner_valtrees.iter().enumerate() {\n+                debug!(?i, ?inner_valtree);\n+\n+                let mut place_inner = ecx.mplace_field(place, i).unwrap();\n+                debug!(?place_inner);\n+\n+                fill_place_recursively(ecx, &mut place_inner, *inner_valtree, *inner_ty)\n+            }\n+        }\n+        ty::Adt(def, substs) if def.is_enum() => {\n+            debug!(\"enum, substs: {:?}\", substs);\n+            let inner_valtrees = valtree.unwrap_branch();\n+\n+            // First element of valtree corresponds to variant\n+            let scalar_int = inner_valtrees[0].unwrap_leaf();\n+            let variant_idx = VariantIdx::from_u32(scalar_int.try_to_u32().unwrap());\n+            let variant = def.variant(variant_idx);\n+            debug!(?variant);\n+\n+            // Need to downcast place\n+            let place_downcast = place.project_downcast(ecx, variant_idx).unwrap();\n+            debug!(?place_downcast);\n+\n+            // fill `place_downcast` with the valtree elements corresponding to\n+            // the fields of the enum\n+            let fields = &variant.fields;\n+            let inner_valtrees = &inner_valtrees[1..];\n+            for (i, field) in fields.iter().enumerate() {\n+                debug!(?i, ?field);\n+\n+                let field_ty = field.ty(tcx, substs);\n+                debug!(?field_ty);\n+\n+                let mut field_mplace = ecx.mplace_field(&place_downcast, i).unwrap();\n+                debug!(?field_mplace);\n+                let inner_valtree = inner_valtrees[i];\n+\n+                fill_place_recursively(ecx, &mut field_mplace, inner_valtree, field_ty);\n+                dump_place(&ecx, field_mplace.into());\n+            }\n+\n+            debug!(\"dump of place_downcast\");\n+            dump_place(ecx, place_downcast.into());\n+\n+            // don't forget filling the place with the discriminant of the enum\n+            ecx.write_discriminant(variant_idx, &(*place).into()).unwrap();\n+            dump_place(ecx, (*place).into());\n+        }\n+        ty::Adt(def, substs) => {\n+            debug!(\"Adt def: {:?} with substs: {:?}\", def, substs);\n+            let inner_valtrees = valtree.unwrap_branch();\n+            debug!(?inner_valtrees);\n+            let (fields, inner_valtrees) =\n+                (&def.variant(VariantIdx::from_usize(0)).fields[..], inner_valtrees);\n+\n+            debug!(\"fields: {:?}\", fields);\n+\n+            for (i, field) in fields.iter().enumerate() {\n+                let field_ty = field.ty(tcx, substs);\n+                debug!(?field_ty);\n+                let old_field_ty = tcx.type_of(field.did);\n+                debug!(?old_field_ty);\n+                let projection_elem = ProjectionElem::Field(Field::from_usize(i), field_ty);\n+                let mut field_place = ecx.mplace_projection(place, projection_elem).unwrap();\n+                let inner_valtree = inner_valtrees[i];\n+\n+                fill_place_recursively(ecx, &mut field_place, inner_valtree, field_ty);\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn dump_place<'tcx>(ecx: &CompileTimeEvalContext<'tcx, 'tcx>, place: PlaceTy<'tcx>) {\n+    trace!(\"{:?}\", ecx.dump_place(place.place));\n+}"}, {"sha": "dba746e72e2459f6ac3450c83b844b49dd1ad0ac", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -14,7 +14,7 @@ mod terminator;\n mod traits;\n mod util;\n mod validity;\n-mod visitor;\n+pub(crate) mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n "}, {"sha": "170fbab2cce0451fd5524fbbb617e487c0e2ff93", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -98,7 +98,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n-    imm: Immediate<Tag>,\n+    pub imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -248,7 +248,7 @@ impl<'tcx, Tag: Provenance> ImmTy<'tcx, Tag> {\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for `ScalarPair`.\n     /// Returns `None` if the layout does not permit loading this as a value.\n-    fn try_read_immediate_from_mplace(\n+    pub(crate) fn try_read_immediate_from_mplace(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n@@ -424,6 +424,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn operand_projection(\n         &self,\n         base: &OpTy<'tcx, M::PointerTag>,"}, {"sha": "8caf9eee2d95fea36cfcce0546a23f9553a8f957", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -82,7 +82,7 @@ rustc_data_structures::static_assert_size!(Place, 56);\n \n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    place: Place<Tag>, // Keep this private; it helps enforce invariants.\n+    pub(crate) place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -100,7 +100,7 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n /// A MemPlace with its layout. Constructing it is only possible in this module.\n #[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    mplace: MemPlace<Tag>,\n+    pub(crate) mplace: MemPlace<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -294,6 +294,7 @@ where\n \n     /// Take an operand, representing a pointer, and dereference it to a place -- that\n     /// will always be a MemPlace.  Lives in `place.rs` because it creates a place.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn deref_operand(\n         &self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -487,7 +488,8 @@ where\n     }\n \n     /// Project into an mplace\n-    pub(super) fn mplace_projection(\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(crate) fn mplace_projection(\n         &self,\n         base: &MPlaceTy<'tcx, M::PointerTag>,\n         proj_elem: mir::PlaceElem<'tcx>,\n@@ -548,6 +550,7 @@ where\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n     /// into the field of a local `ScalarPair`, we have to first allocate it.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn place_field(\n         &mut self,\n         base: &PlaceTy<'tcx, M::PointerTag>,\n@@ -586,6 +589,7 @@ where\n     }\n \n     /// Projects into a place.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn place_projection(\n         &mut self,\n         base: &PlaceTy<'tcx, M::PointerTag>,\n@@ -617,19 +621,23 @@ where\n \n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn eval_place(\n         &mut self,\n         place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n+        debug!(\"projection: {:?}\", place.projection);\n         let mut place_ty = PlaceTy {\n             // This works even for dead/uninitialized locals; we check further when writing\n             place: Place::Local { frame: self.frame_idx(), local: place.local },\n             layout: self.layout_of_local(self.frame(), place.local, None)?,\n         };\n+        debug!(?place_ty);\n \n         for elem in place.projection.iter() {\n             place_ty = self.place_projection(&place_ty, &elem)?\n         }\n+        debug!(\"place after projections: {:?}\", place_ty);\n \n         trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n@@ -646,6 +654,7 @@ where\n \n     /// Write an immediate to a place\n     #[inline(always)]\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_immediate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n@@ -684,6 +693,7 @@ where\n     /// Write an immediate to a place.\n     /// If you use this you are responsible for validating that things got copied at the\n     /// right type.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn write_immediate_no_validate(\n         &mut self,\n         src: Immediate<M::PointerTag>,\n@@ -736,6 +746,7 @@ where\n     /// Write an immediate to memory.\n     /// If you use this you are responsible for validating that things got copied at the\n     /// right type.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn write_immediate_to_mplace_no_validate(\n         &mut self,\n         value: Immediate<M::PointerTag>,\n@@ -758,6 +769,7 @@ where\n         // cover all the bytes!\n         match value {\n             Immediate::Scalar(scalar) => {\n+                debug!(?scalar);\n                 match dest.layout.abi {\n                     Abi::Scalar(_) => {} // fine\n                     _ => span_bug!(\n@@ -830,6 +842,7 @@ where\n     /// Copies the data from an operand to a place. This does not support transmuting!\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     #[inline(always)]\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn copy_op(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -849,6 +862,7 @@ where\n     /// Use `copy_op_transmute` if the layouts could disagree.\n     /// Also, if you use this you are responsible for validating that things get copied at the\n     /// right type.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn copy_op_no_validate(\n         &mut self,\n         src: &OpTy<'tcx, M::PointerTag>,\n@@ -868,6 +882,7 @@ where\n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n         let src = match self.try_read_immediate(src)? {\n             Ok(src_val) => {\n+                debug!(\"immediate from src is {:?}\", src_val);\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n@@ -955,13 +970,15 @@ where\n     /// This supports unsized types and returns the computed size to avoid some\n     /// redundant computation when copying; use `force_allocation` for a simpler, sized-only\n     /// version.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn force_allocation_maybe_sized(\n         &mut self,\n         place: &PlaceTy<'tcx, M::PointerTag>,\n         meta: MemPlaceMeta<M::PointerTag>,\n     ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, Option<Size>)> {\n         let (mplace, size) = match place.place {\n             Place::Local { frame, local } => {\n+                debug!(\"LocalPlace\");\n                 match M::access_local_mut(self, frame, local)? {\n                     Ok(&mut local_val) => {\n                         // We need to make an allocation.\n@@ -975,9 +992,12 @@ where\n                         let (size, align) = self\n                             .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n+                        debug!(?size, ?align);\n                         let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n+                        debug!(\"allocated ptr: {:?}\", ptr);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n+                            debug!(\"LocalValue::Live: immediate value {:?}\", value);\n                             // Preserve old value.\n                             // We don't have to validate as we can assume the local\n                             // was already valid for its type.\n@@ -1037,6 +1057,7 @@ where\n     }\n \n     /// Writes the discriminant of the given variant.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn write_discriminant(\n         &mut self,\n         variant_index: VariantIdx,"}, {"sha": "5e7e362eeef421fc2390cc289728008e2eefbdca", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -418,6 +418,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to call `InterpCx::write_scalar` instead of this method.\n+    #[instrument(skip(self, cx), level = \"debug\")]\n     pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n@@ -432,6 +433,7 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n                 return self.write_uninit(cx, range);\n             }\n         };\n+        debug!(?val);\n \n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n@@ -442,13 +444,16 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n             }\n             Ok(data) => (data, None),\n         };\n+        debug!(?bytes, ?provenance);\n \n         let endian = cx.data_layout().endian;\n         let dst = self.get_bytes_mut(cx, range)?;\n+        debug!(?dst);\n         write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation.\n         if let Some(provenance) = provenance {\n+            debug!(\"insert relocation for {:?}\", provenance);\n             self.relocations.0.insert(range.start, provenance);\n         }\n "}, {"sha": "cb36e5409543dbe72b774ca369fdb230623eaec4", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -158,7 +158,7 @@ impl Provenance for AllocId {\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n #[derive(HashStable)]\n pub struct Pointer<Tag = AllocId> {\n-    pub(super) offset: Size, // kept private to avoid accidental misinterpretation (meaning depends on `Tag` type)\n+    pub offset: Size, // FIXME This should probably be private\n     pub provenance: Tag,\n }\n "}, {"sha": "418848f69d726bc731fe1cfc56c917fc29353206", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=1157dc7167d13a9bdcafd30b8ad0ecf5ae5faa7f", "patch": "@@ -20,6 +20,9 @@ pub enum ValTree<'tcx> {\n     /// See the `ScalarInt` documentation for how `ScalarInt` guarantees that equal values\n     /// of these types have the same representation.\n     Leaf(ScalarInt),\n+\n+    //SliceOrStr(ValSlice<'tcx>),\n+    // dont use SliceOrStr for now\n     /// The fields of any kind of aggregate. Structs, tuples and arrays are represented by\n     /// listing their fields' values in order.\n     /// Enums are represented by storing their discriminant as a field, followed by all"}]}