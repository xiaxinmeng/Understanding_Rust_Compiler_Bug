{"sha": "8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyOTVkYzQyYTBmYzllODY0MTYwNmY3NWE1YmEyYTQ2ZmU0ODM3OWM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T16:17:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-01T16:27:58Z"}, "message": "Fold multiline calls", "tree": {"sha": "8efac1cc37f1bfb146cd28107cf1159f2881624b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8efac1cc37f1bfb146cd28107cf1159f2881624b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "html_url": "https://github.com/rust-lang/rust/commit/8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e3a7aeb4a706a6ee84229f94719dd78432417c", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e3a7aeb4a706a6ee84229f94719dd78432417c", "html_url": "https://github.com/rust-lang/rust/commit/53e3a7aeb4a706a6ee84229f94719dd78432417c"}], "stats": {"total": 219, "additions": 114, "deletions": 105}, "files": [{"sha": "5cec689f8bad11f12a632265f82f079ee7d8e9d3", "filename": "crates/ra_ide/src/folding_ranges.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ffolding_ranges.rs?ref=8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "patch": "@@ -15,6 +15,7 @@ pub enum FoldKind {\n     Imports,\n     Mods,\n     Block,\n+    ArgList,\n }\n \n #[derive(Debug)]\n@@ -83,6 +84,7 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     match kind {\n         COMMENT => Some(FoldKind::Comment),\n         USE_ITEM => Some(FoldKind::Imports),\n+        ARG_LIST => Some(FoldKind::ArgList),\n         RECORD_FIELD_DEF_LIST\n         | RECORD_FIELD_PAT_LIST\n         | ITEM_LIST\n@@ -196,180 +198,179 @@ fn contiguous_range_for_comment(\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::extract_tags;\n+\n     use super::*;\n-    use test_utils::extract_ranges;\n \n-    fn do_check(text: &str, fold_kinds: &[FoldKind]) {\n-        let (ranges, text) = extract_ranges(text, \"fold\");\n+    fn check(ra_fixture: &str) {\n+        let (ranges, text) = extract_tags(ra_fixture, \"fold\");\n+\n         let parse = SourceFile::parse(&text);\n         let folds = folding_ranges(&parse.tree());\n-\n         assert_eq!(\n             folds.len(),\n             ranges.len(),\n             \"The amount of folds is different than the expected amount\"\n         );\n-        assert_eq!(\n-            folds.len(),\n-            fold_kinds.len(),\n-            \"The amount of fold kinds is different than the expected amount\"\n-        );\n-        for ((fold, range), fold_kind) in\n-            folds.iter().zip(ranges.into_iter()).zip(fold_kinds.iter())\n-        {\n+\n+        for (fold, (range, attr)) in folds.iter().zip(ranges.into_iter()) {\n             assert_eq!(fold.range.start(), range.start());\n             assert_eq!(fold.range.end(), range.end());\n-            assert_eq!(&fold.kind, fold_kind);\n+\n+            let kind = match fold.kind {\n+                FoldKind::Comment => \"comment\",\n+                FoldKind::Imports => \"imports\",\n+                FoldKind::Mods => \"mods\",\n+                FoldKind::Block => \"block\",\n+                FoldKind::ArgList => \"arglist\",\n+            };\n+            assert_eq!(kind, &attr.unwrap());\n         }\n     }\n \n     #[test]\n     fn test_fold_comments() {\n-        let text = r#\"\n-<fold>// Hello\n+        check(\n+            r#\"\n+<fold comment>// Hello\n // this is a multiline\n // comment\n //</fold>\n \n // But this is not\n \n-fn main() <fold>{\n-    <fold>// We should\n+fn main() <fold block>{\n+    <fold comment>// We should\n     // also\n     // fold\n     // this one.</fold>\n-    <fold>//! But this one is different\n+    <fold comment>//! But this one is different\n     //! because it has another flavor</fold>\n-    <fold>/* As does this\n+    <fold comment>/* As does this\n     multiline comment */</fold>\n-}</fold>\"#;\n-\n-        let fold_kinds = &[\n-            FoldKind::Comment,\n-            FoldKind::Block,\n-            FoldKind::Comment,\n-            FoldKind::Comment,\n-            FoldKind::Comment,\n-        ];\n-        do_check(text, fold_kinds);\n+}</fold>\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fold_imports() {\n-        let text = r#\"\n-<fold>use std::<fold>{\n+        check(\n+            r#\"\n+<fold imports>use std::<fold block>{\n     str,\n     vec,\n     io as iop\n }</fold>;</fold>\n \n-fn main() <fold>{\n-}</fold>\"#;\n-\n-        let folds = &[FoldKind::Imports, FoldKind::Block, FoldKind::Block];\n-        do_check(text, folds);\n+fn main() <fold block>{\n+}</fold>\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fold_mods() {\n-        let text = r#\"\n+        check(\n+            r#\"\n \n pub mod foo;\n-<fold>mod after_pub;\n+<fold mods>mod after_pub;\n mod after_pub_next;</fold>\n \n-<fold>mod before_pub;\n+<fold mods>mod before_pub;\n mod before_pub_next;</fold>\n pub mod bar;\n \n mod not_folding_single;\n pub mod foobar;\n pub not_folding_single_next;\n \n-<fold>#[cfg(test)]\n+<fold mods>#[cfg(test)]\n mod with_attribute;\n mod with_attribute_next;</fold>\n \n-fn main() <fold>{\n-}</fold>\"#;\n-\n-        let folds = &[FoldKind::Mods, FoldKind::Mods, FoldKind::Mods, FoldKind::Block];\n-        do_check(text, folds);\n+fn main() <fold block>{\n+}</fold>\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fold_import_groups() {\n-        let text = r#\"\n-<fold>use std::str;\n+        check(\n+            r#\"\n+<fold imports>use std::str;\n use std::vec;\n use std::io as iop;</fold>\n \n-<fold>use std::mem;\n+<fold imports>use std::mem;\n use std::f64;</fold>\n \n use std::collections::HashMap;\n // Some random comment\n use std::collections::VecDeque;\n \n-fn main() <fold>{\n-}</fold>\"#;\n-\n-        let folds = &[FoldKind::Imports, FoldKind::Imports, FoldKind::Block];\n-        do_check(text, folds);\n+fn main() <fold block>{\n+}</fold>\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fold_import_and_groups() {\n-        let text = r#\"\n-<fold>use std::str;\n+        check(\n+            r#\"\n+<fold imports>use std::str;\n use std::vec;\n use std::io as iop;</fold>\n \n-<fold>use std::mem;\n+<fold imports>use std::mem;\n use std::f64;</fold>\n \n-<fold>use std::collections::<fold>{\n+<fold imports>use std::collections::<fold block>{\n     HashMap,\n     VecDeque,\n }</fold>;</fold>\n // Some random comment\n \n-fn main() <fold>{\n-}</fold>\"#;\n-\n-        let folds = &[\n-            FoldKind::Imports,\n-            FoldKind::Imports,\n-            FoldKind::Imports,\n-            FoldKind::Block,\n-            FoldKind::Block,\n-        ];\n-        do_check(text, folds);\n+fn main() <fold block>{\n+}</fold>\"#,\n+        );\n     }\n \n     #[test]\n     fn test_folds_macros() {\n-        let text = r#\"\n-macro_rules! foo <fold>{\n+        check(\n+            r#\"\n+macro_rules! foo <fold block>{\n     ($($tt:tt)*) => { $($tt)* }\n }</fold>\n-\"#;\n-\n-        let folds = &[FoldKind::Block];\n-        do_check(text, folds);\n+\"#,\n+        );\n     }\n \n     #[test]\n     fn test_fold_match_arms() {\n-        let text = r#\"\n-fn main() <fold>{\n-    match 0 <fold>{\n+        check(\n+            r#\"\n+fn main() <fold block>{\n+    match 0 <fold block>{\n         0 => 0,\n         _ => 1,\n     }</fold>\n-}</fold>\"#;\n+}</fold>\"#,\n+        );\n+    }\n \n-        let folds = &[FoldKind::Block, FoldKind::Block];\n-        do_check(text, folds);\n+    #[test]\n+    fn fold_big_calls() {\n+        check(\n+            r#\"\n+fn main() <fold block>{\n+    frobnicate<fold arglist>(\n+        1,\n+        2,\n+        3,\n+    )</fold>\n+}</fold>\n+        \"#,\n+        )\n     }\n }"}, {"sha": "95dd8e408d0d8ec41eb38a257dffa0f1c1c05f7f", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "patch": "@@ -352,7 +352,7 @@ pub(crate) fn folding_range(\n     let kind = match fold.kind {\n         FoldKind::Comment => Some(lsp_types::FoldingRangeKind::Comment),\n         FoldKind::Imports => Some(lsp_types::FoldingRangeKind::Imports),\n-        FoldKind::Mods | FoldKind::Block => None,\n+        FoldKind::Mods | FoldKind::Block | FoldKind::ArgList => None,\n     };\n \n     let range = range(line_index, fold.range);\n@@ -685,32 +685,27 @@ pub(crate) fn runnable(\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::extract_ranges;\n+    use ra_ide::Analysis;\n \n     use super::*;\n \n     #[test]\n     fn conv_fold_line_folding_only_fixup() {\n-        let text = r#\"<fold>mod a;\n+        let text = r#\"mod a;\n mod b;\n-mod c;</fold>\n+mod c;\n \n-fn main() <fold>{\n-    if cond <fold>{\n+fn main() {\n+    if cond {\n         a::do_a();\n-    }</fold> else <fold>{\n+    } else {\n         b::do_b();\n-    }</fold>\n-}</fold>\"#;\n-\n-        let (ranges, text) = extract_ranges(text, \"fold\");\n-        assert_eq!(ranges.len(), 4);\n-        let folds = vec![\n-            Fold { range: ranges[0], kind: FoldKind::Mods },\n-            Fold { range: ranges[1], kind: FoldKind::Block },\n-            Fold { range: ranges[2], kind: FoldKind::Block },\n-            Fold { range: ranges[3], kind: FoldKind::Block },\n-        ];\n+    }\n+}\"#;\n+\n+        let (analysis, file_id) = Analysis::from_single_file(text.to_string());\n+        let folds = analysis.folding_ranges(file_id).unwrap();\n+        assert_eq!(folds.len(), 4);\n \n         let line_index = LineIndex::new(&text);\n         let converted: Vec<lsp_types::FoldingRange> ="}, {"sha": "e4aa894ace3ec49686de0d0c59b78fe5fe265bb9", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295dc42a0fc9e8641606f75a5ba2a46fe48379c/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=8295dc42a0fc9e8641606f75a5ba2a46fe48379c", "patch": "@@ -118,8 +118,8 @@ pub fn extract_range_or_offset(text: &str) -> (RangeOrOffset, String) {\n }\n \n /// Extracts ranges, marked with `<tag> </tag>` pairs from the `text`\n-pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n-    let open = format!(\"<{}>\", tag);\n+pub fn extract_tags(mut text: &str, tag: &str) -> (Vec<(TextRange, Option<String>)>, String) {\n+    let open = format!(\"<{}\", tag);\n     let close = format!(\"</{}>\", tag);\n     let mut ranges = Vec::new();\n     let mut res = String::new();\n@@ -134,22 +134,35 @@ pub fn extract_ranges(mut text: &str, tag: &str) -> (Vec<TextRange>, String) {\n                 res.push_str(&text[..i]);\n                 text = &text[i..];\n                 if text.starts_with(&open) {\n-                    text = &text[open.len()..];\n+                    let close_open = text.find('>').unwrap();\n+                    let attr = text[open.len()..close_open].trim();\n+                    let attr = if attr.is_empty() { None } else { Some(attr.to_string()) };\n+                    text = &text[close_open + '>'.len_utf8()..];\n                     let from = TextSize::of(&res);\n-                    stack.push(from);\n+                    stack.push((from, attr));\n                 } else if text.starts_with(&close) {\n                     text = &text[close.len()..];\n-                    let from = stack.pop().unwrap_or_else(|| panic!(\"unmatched </{}>\", tag));\n+                    let (from, attr) =\n+                        stack.pop().unwrap_or_else(|| panic!(\"unmatched </{}>\", tag));\n                     let to = TextSize::of(&res);\n-                    ranges.push(TextRange::new(from, to));\n+                    ranges.push((TextRange::new(from, to), attr));\n+                } else {\n+                    res.push('<');\n+                    text = &text['<'.len_utf8()..];\n                 }\n             }\n         }\n     }\n     assert!(stack.is_empty(), \"unmatched <{}>\", tag);\n-    ranges.sort_by_key(|r| (r.start(), r.end()));\n+    ranges.sort_by_key(|r| (r.0.start(), r.0.end()));\n     (ranges, res)\n }\n+#[test]\n+fn test_extract_tags() {\n+    let (tags, text) = extract_tags(r#\"<tag fn>fn <tag>main</tag>() {}</tag>\"#, \"tag\");\n+    let actual = tags.into_iter().map(|(range, attr)| (&text[range], attr)).collect::<Vec<_>>();\n+    assert_eq!(actual, vec![(\"fn main() {}\", Some(\"fn\".into())), (\"main\", None),]);\n+}\n \n /// Inserts `<|>` marker into the `text` at `offset`.\n pub fn add_cursor(text: &str, offset: TextSize) -> String {"}]}