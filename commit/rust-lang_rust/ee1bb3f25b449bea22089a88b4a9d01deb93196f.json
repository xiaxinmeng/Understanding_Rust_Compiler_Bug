{"sha": "ee1bb3f25b449bea22089a88b4a9d01deb93196f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMWJiM2YyNWI0NDliZWEyMjA4OWE4OGI0YTlkMDFkZWI5MzE5NmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T08:04:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-21T17:26:43Z"}, "message": "rollup merge of #19969: aturon/inherit-trait-stab\n\nThere is currently no way to specify the stability level for a trait\nimpl produced by `deriving`. This patch is a stopgap solution that:\n\n* Turns of stability inheritance for trait impls, and\n* Uses the stability level of the *trait* if no level is directly\n  specified.\n\nThat is, manual trait impls may still provide a directly stability\nlevel, but `deriving` will use the level of the trait. While not a\nperfect solution, it should be good enough for 1.0 API stabilization, as\nwe will like *remove* any unwanted impls outright.\n\nr? @alexcrichton", "tree": {"sha": "94f1dd4b5fe79c201a07410e60f4117fd4c4a8bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f1dd4b5fe79c201a07410e60f4117fd4c4a8bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee1bb3f25b449bea22089a88b4a9d01deb93196f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1bb3f25b449bea22089a88b4a9d01deb93196f", "html_url": "https://github.com/rust-lang/rust/commit/ee1bb3f25b449bea22089a88b4a9d01deb93196f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee1bb3f25b449bea22089a88b4a9d01deb93196f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4f393ee8a1517e2c35afa4d71cbcea5187e5857", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4f393ee8a1517e2c35afa4d71cbcea5187e5857", "html_url": "https://github.com/rust-lang/rust/commit/b4f393ee8a1517e2c35afa4d71cbcea5187e5857"}, {"sha": "9bb5380d80dc961fc3bd7edd13d6584f5cc48b66", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb5380d80dc961fc3bd7edd13d6584f5cc48b66", "html_url": "https://github.com/rust-lang/rust/commit/9bb5380d80dc961fc3bd7edd13d6584f5cc48b66"}], "stats": {"total": 70, "additions": 51, "deletions": 19}, "files": [{"sha": "c4a5fd2f14a3ccd739779dcc83ec1cb82bbcb516", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ee1bb3f25b449bea22089a88b4a9d01deb93196f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee1bb3f25b449bea22089a88b4a9d01deb93196f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ee1bb3f25b449bea22089a88b4a9d01deb93196f", "patch": "@@ -43,7 +43,8 @@ struct Annotator {\n impl Annotator {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>, f: F) where\n+    fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n+                   attrs: &Vec<Attribute>, f: F) where\n         F: FnOnce(&mut Annotator),\n     {\n         match attr::find_stability(attrs.as_slice()) {\n@@ -60,7 +61,9 @@ impl Annotator {\n                 }\n             }\n             None => {\n-                self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                if use_parent {\n+                    self.parent.clone().map(|stab| self.index.local.insert(id, stab));\n+                }\n                 f(self);\n             }\n         }\n@@ -69,11 +72,24 @@ impl Annotator {\n \n impl<'v> Visitor<'v> for Annotator {\n     fn visit_item(&mut self, i: &Item) {\n-        self.annotate(i.id, &i.attrs, |v| visit::walk_item(v, i));\n+        // FIXME (#18969): the following is a hack around the fact\n+        // that we cannot currently annotate the stability of\n+        // `deriving`.  Basically, we do *not* allow stability\n+        // inheritance on trait implementations, so that derived\n+        // implementations appear to be unannotated. This then allows\n+        // derived implementations to be automatically tagged with the\n+        // stability of the trait. This is WRONG, but expedient to get\n+        // libstd stabilized for the 1.0 release.\n+        let use_parent = match i.node {\n+            ast::ItemImpl(_, _, Some(_), _, _) => false,\n+            _ => true,\n+        };\n+\n+        self.annotate(i.id, use_parent, &i.attrs, |v| visit::walk_item(v, i));\n \n         if let ast::ItemStruct(ref sd, _) = i.node {\n             sd.ctor_id.map(|id| {\n-                self.annotate(id, &i.attrs, |_| {})\n+                self.annotate(id, true, &i.attrs, |_| {})\n             });\n         }\n     }\n@@ -82,7 +98,7 @@ impl<'v> Visitor<'v> for Annotator {\n                 _: &'v Block, _: Span, _: NodeId) {\n         if let FkMethod(_, _, meth) = fk {\n             // Methods are not already annotated, so we annotate it\n-            self.annotate(meth.id, &meth.attrs, |_| {});\n+            self.annotate(meth.id, true, &meth.attrs, |_| {});\n         }\n         // Items defined in a function body have no reason to have\n         // a stability attribute, so we don't recurse.\n@@ -101,15 +117,17 @@ impl<'v> Visitor<'v> for Annotator {\n \n             TypeTraitItem(ref typedef) => (typedef.ty_param.id, &typedef.attrs),\n         };\n-        self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n+        self.annotate(id, true, attrs, |v| visit::walk_trait_item(v, t));\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics) {\n-        self.annotate(var.node.id, &var.node.attrs, |v| visit::walk_variant(v, var, g))\n+        self.annotate(var.node.id, true, &var.node.attrs,\n+                      |v| visit::walk_variant(v, var, g))\n     }\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n-        self.annotate(s.node.id, &s.node.attrs, |v| visit::walk_struct_field(v, s));\n+        self.annotate(s.node.id, true, &s.node.attrs,\n+                      |v| visit::walk_struct_field(v, s));\n     }\n }\n \n@@ -123,7 +141,8 @@ impl Index {\n             },\n             parent: None\n         };\n-        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, |v| visit::walk_crate(v, krate));\n+        annotator.annotate(ast::CRATE_NODE_ID, true, &krate.attrs,\n+                           |v| visit::walk_crate(v, krate));\n         annotator.index\n     }\n }\n@@ -135,16 +154,29 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     match ty::trait_item_of_item(tcx, id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n                 if trait_method_id != id => {\n-            lookup(tcx, trait_method_id)\n-        }\n-        _ if is_local(id) => {\n-            tcx.stability.borrow().local.get(&id.node).cloned()\n-        }\n-        _ => {\n-            let stab = csearch::get_stability(&tcx.sess.cstore, id);\n-            let mut index = tcx.stability.borrow_mut();\n-            (*index).extern_cache.insert(id, stab.clone());\n-            stab\n+            return lookup(tcx, trait_method_id)\n         }\n+        _ => {}\n     }\n+\n+    let item_stab = if is_local(id) {\n+        tcx.stability.borrow().local.get(&id.node).cloned()\n+    } else {\n+        let stab = csearch::get_stability(&tcx.sess.cstore, id);\n+        let mut index = tcx.stability.borrow_mut();\n+        (*index).extern_cache.insert(id, stab.clone());\n+        stab\n+    };\n+\n+    item_stab.or_else(|| {\n+        if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n+            // FIXME (#18969): for the time being, simply use the\n+            // stability of the trait to determine the stability of any\n+            // unmarked impls for it. See FIXME above for more details.\n+\n+            lookup(tcx, trait_id)\n+        } else {\n+            None\n+        }\n+    })\n }"}]}