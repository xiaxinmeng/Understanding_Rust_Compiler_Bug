{"sha": "e22b61bff0bdd08be7665607cb7be3748c8a35d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMmI2MWJmZjBiZGQwOGJlNzY2NTYwN2NiN2JlMzc0OGM4YTM1ZDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-22T08:18:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-22T08:18:46Z"}, "message": "Auto merge of #73270 - dylanmckay:avr-use-correct-addrspace, r=nagisa\n\n[AVR] Correctly set the pointer address space when constructing pointers to functions\n\nNOTE: Pull request iterations:\n\n* https://github.com/dylanmckay/rust/releases/tag/avr-use-correct-addrspace.0\n* https://github.com/dylanmckay/rust/releases/tag/avr-use-correct-addrspace.1\n* https://github.com/dylanmckay/rust/releases/tag/avr-use-correct-addrspace.2\n\nThis patch extends the existing `type_i8p` method so that it requires an\nexplicit address space to be specified. Before this patch, the\n`type_i8p` method implcitily assumed the default address space, which is\nnot a safe transformation on all targets, namely AVR.\n\nThe Rust compiler already has support for tracking the \"instruction\naddress space\" on a per-target basis. This patch extends the code\ngeneration routines so that an address space must always be specified.\n\nIn my estimation, around 15% of the callers of `type_i8p` produced\ninvalid code on AVR due to the loss of address space prior to LLVM final\ncode generation. This would lead to unavoidable assertion errors\nrelating to invalid bitcasts.\n\nWith this patch, the address space is always either 1) explicitly preserved\nfrom the input type, or 2) explicitly set to the instruction address\nspace because the logic is dealing with functions which must be placed\nthere, or 3) explicitly set to the default address space 0 because the\nlogic can only operate on data space pointers and thus we keep the\nexisting semantics of assuming the default, \"data\" address space.", "tree": {"sha": "01a600863f4ef3e76cfe58ceef2ba5d91700557e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a600863f4ef3e76cfe58ceef2ba5d91700557e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e22b61bff0bdd08be7665607cb7be3748c8a35d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e22b61bff0bdd08be7665607cb7be3748c8a35d2", "html_url": "https://github.com/rust-lang/rust/commit/e22b61bff0bdd08be7665607cb7be3748c8a35d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e22b61bff0bdd08be7665607cb7be3748c8a35d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4825e12fc9c79954aa0fe18f5521efa6c19c7539", "url": "https://api.github.com/repos/rust-lang/rust/commits/4825e12fc9c79954aa0fe18f5521efa6c19c7539", "html_url": "https://github.com/rust-lang/rust/commit/4825e12fc9c79954aa0fe18f5521efa6c19c7539"}, {"sha": "5581ce6c10ae0b4e6503db0081e2defd7ef829ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/5581ce6c10ae0b4e6503db0081e2defd7ef829ff", "html_url": "https://github.com/rust-lang/rust/commit/5581ce6c10ae0b4e6503db0081e2defd7ef829ff"}], "stats": {"total": 224, "additions": 188, "deletions": 36}, "files": [{"sha": "7857ccb613bf8abd7fe212b11576986f80e49c7d", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -366,7 +366,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         unsafe {\n             llvm::LLVMPointerType(\n                 self.llvm_type(cx),\n-                cx.data_layout().instruction_address_space as c_uint,\n+                cx.data_layout().instruction_address_space.0 as c_uint,\n             )\n         }\n     }"}, {"sha": "0e1cd8e493d9a8dcde2769fab461bff3adecbd26", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::bug;\n use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::symbol::Symbol;\n-use rustc_target::abi::{self, HasDataLayout, LayoutOf, Pointer, Size};\n+use rustc_target::abi::{self, AddressSpace, HasDataLayout, LayoutOf, Pointer, Size};\n \n use libc::{c_char, c_uint};\n use log::debug;\n@@ -244,7 +244,7 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 }\n             }\n             Scalar::Ptr(ptr) => {\n-                let base_addr = match self.tcx.global_alloc(ptr.alloc_id) {\n+                let (base_addr, base_addr_space) = match self.tcx.global_alloc(ptr.alloc_id) {\n                     GlobalAlloc::Memory(alloc) => {\n                         let init = const_alloc_to_llvm(self, alloc);\n                         let value = match alloc.mutability {\n@@ -254,18 +254,21 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         if !self.sess().fewer_names() {\n                             llvm::set_value_name(value, format!(\"{:?}\", ptr.alloc_id).as_bytes());\n                         }\n-                        value\n+                        (value, AddressSpace::DATA)\n                     }\n-                    GlobalAlloc::Function(fn_instance) => self.get_fn_addr(fn_instance),\n+                    GlobalAlloc::Function(fn_instance) => (\n+                        self.get_fn_addr(fn_instance),\n+                        self.data_layout().instruction_address_space,\n+                    ),\n                     GlobalAlloc::Static(def_id) => {\n                         assert!(self.tcx.is_static(def_id));\n                         assert!(!self.tcx.is_thread_local_static(def_id));\n-                        self.get_static(def_id)\n+                        (self.get_static(def_id), AddressSpace::DATA)\n                     }\n                 };\n                 let llval = unsafe {\n                     llvm::LLVMConstInBoundsGEP(\n-                        self.const_bitcast(base_addr, self.type_i8p()),\n+                        self.const_bitcast(base_addr, self.type_i8p_ext(base_addr_space)),\n                         &self.const_usize(ptr.offset.bytes()),\n                         1,\n                     )"}, {"sha": "3e9e5d9c8c1f44e059030d9397441ca8b31feb44", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -13,14 +13,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n-    read_target_uint, Allocation, ConstValue, ErrorHandled, Pointer,\n+    read_target_uint, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n+use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n \n use std::ffi::CStr;\n \n@@ -53,10 +53,16 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         )\n         .expect(\"const_alloc_to_llvm: could not read relocation pointer\")\n             as u64;\n+\n+        let address_space = match cx.tcx.global_alloc(alloc_id) {\n+            GlobalAlloc::Function(..) => cx.data_layout().instruction_address_space,\n+            GlobalAlloc::Static(..) | GlobalAlloc::Memory(..) => AddressSpace::DATA,\n+        };\n+\n         llvals.push(cx.scalar_to_backend(\n             Pointer::new(alloc_id, Size::from_bytes(ptr_offset)).into(),\n             &Scalar { value: Primitive::Pointer, valid_range: 0..=!0 },\n-            cx.type_i8p(),\n+            cx.type_i8p_ext(address_space),\n         ));\n         next_offset = offset + pointer_size;\n     }"}, {"sha": "05e364884f66dcd66fac3e1b2d5e3fa8d7e89ce6", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::Ty;\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n-use rustc_target::abi::{Align, Integer, Size};\n+use rustc_target::abi::{AddressSpace, Align, Integer, Size};\n \n use std::fmt;\n use std::ptr;\n@@ -198,9 +198,13 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         assert_ne!(\n             self.type_kind(ty),\n             TypeKind::Function,\n-            \"don't call ptr_to on function types, use ptr_to_llvm_type on FnAbi instead\"\n+            \"don't call ptr_to on function types, use ptr_to_llvm_type on FnAbi instead or explicitly specify an address space if it makes sense\"\n         );\n-        ty.ptr_to()\n+        ty.ptr_to(AddressSpace::DATA)\n+    }\n+\n+    fn type_ptr_to_ext(&self, ty: &'ll Type, address_space: AddressSpace) -> &'ll Type {\n+        ty.ptr_to(address_space)\n     }\n \n     fn element_type(&self, ty: &'ll Type) -> &'ll Type {\n@@ -241,11 +245,11 @@ impl Type {\n     }\n \n     pub fn i8p_llcx(llcx: &llvm::Context) -> &Type {\n-        Type::i8_llcx(llcx).ptr_to()\n+        Type::i8_llcx(llcx).ptr_to(AddressSpace::DATA)\n     }\n \n-    fn ptr_to(&self) -> &Type {\n-        unsafe { llvm::LLVMPointerType(&self, 0) }\n+    fn ptr_to(&self, address_space: AddressSpace) -> &Type {\n+        unsafe { llvm::LLVMPointerType(&self, address_space.0) }\n     }\n }\n "}, {"sha": "1d0adc5783f3d74dc99836108f59889fe23d1ce9", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::layout::{FnAbiExt, TyAndLayout};\n use rustc_middle::ty::print::obsolete::DefPathBasedNames;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_target::abi::{Abi, Align, FieldsShape};\n+use rustc_target::abi::{Abi, AddressSpace, Align, FieldsShape};\n use rustc_target::abi::{Int, Pointer, F32, F64};\n use rustc_target::abi::{LayoutOf, PointeeInfo, Scalar, Size, TyAndLayoutMethods, Variants};\n \n@@ -310,12 +310,13 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             F64 => cx.type_f64(),\n             Pointer => {\n                 // If we know the alignment, pick something better than i8.\n-                let pointee = if let Some(pointee) = self.pointee_info_at(cx, offset) {\n-                    cx.type_pointee_for_align(pointee.align)\n-                } else {\n-                    cx.type_i8()\n-                };\n-                cx.type_ptr_to(pointee)\n+                let (pointee, address_space) =\n+                    if let Some(pointee) = self.pointee_info_at(cx, offset) {\n+                        (cx.type_pointee_for_align(pointee.align), pointee.address_space)\n+                    } else {\n+                        (cx.type_i8(), AddressSpace::DATA)\n+                    };\n+                cx.type_ptr_to_ext(pointee, address_space)\n             }\n         }\n     }"}, {"sha": "bcc19c6a44bd829ffff227b9c606938cb26da6b5", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -75,7 +75,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     }\n \n     // Not in the cache; build it.\n-    let nullptr = cx.const_null(cx.type_i8p());\n+    let nullptr = cx.const_null(cx.type_i8p_ext(cx.data_layout().instruction_address_space));\n \n     let methods_root;\n     let methods = if let Some(trait_ref) = trait_ref {"}, {"sha": "f4d83e87710822836ccab73f7674d4bc417aef08", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n+use rustc_target::abi::HasDataLayout;\n \n use std::iter;\n \n@@ -323,7 +324,9 @@ fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let null = bx.const_null(bx.type_i8p());\n+                    let null = bx.const_null(\n+                        bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space),\n+                    );\n                     let sixty_four = bx.const_i32(64);\n                     funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                     cp_bx.br(llbb);"}, {"sha": "726d948cfd40cf483be1e705af99a8412f59abd4", "filename": "src/librustc_codegen_ssa/traits/type_.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Ftype_.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n-use rustc_target::abi::Integer;\n+use rustc_target::abi::{AddressSpace, Integer};\n \n // This depends on `Backend` and not `BackendTypes`, because consumers will probably want to use\n // `LayoutOf` or `HasTyCtxt`. This way, they don't have to add a constraint on it themselves.\n@@ -27,6 +27,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn type_struct(&self, els: &[Self::Type], packed: bool) -> Self::Type;\n     fn type_kind(&self, ty: Self::Type) -> TypeKind;\n     fn type_ptr_to(&self, ty: Self::Type) -> Self::Type;\n+    fn type_ptr_to_ext(&self, ty: Self::Type, address_space: AddressSpace) -> Self::Type;\n     fn element_type(&self, ty: Self::Type) -> Self::Type;\n \n     /// Returns the number of elements in `self` if it is a LLVM vector type.\n@@ -42,7 +43,11 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n \n pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     fn type_i8p(&self) -> Self::Type {\n-        self.type_ptr_to(self.type_i8())\n+        self.type_i8p_ext(AddressSpace::DATA)\n+    }\n+\n+    fn type_i8p_ext(&self, address_space: AddressSpace) -> Self::Type {\n+        self.type_ptr_to_ext(self.type_i8(), address_space)\n     }\n \n     fn type_int(&self) -> Self::Type {"}, {"sha": "dc775b15927fa2edaf2fa09c4194a4f27e79d96e", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -2166,16 +2166,31 @@ where\n     }\n \n     fn pointee_info_at(this: TyAndLayout<'tcx>, cx: &C, offset: Size) -> Option<PointeeInfo> {\n-        match this.ty.kind {\n+        let addr_space_of_ty = |ty: Ty<'tcx>| {\n+            if ty.is_fn() { cx.data_layout().instruction_address_space } else { AddressSpace::DATA }\n+        };\n+\n+        let pointee_info = match this.ty.kind {\n             ty::RawPtr(mt) if offset.bytes() == 0 => {\n                 cx.layout_of(mt.ty).to_result().ok().map(|layout| PointeeInfo {\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: None,\n+                    address_space: addr_space_of_ty(mt.ty),\n+                })\n+            }\n+            ty::FnPtr(fn_sig) if offset.bytes() == 0 => {\n+                cx.layout_of(cx.tcx().mk_fn_ptr(fn_sig)).to_result().ok().map(|layout| {\n+                    PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                        address_space: cx.data_layout().instruction_address_space,\n+                    }\n                 })\n             }\n-\n             ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                let address_space = addr_space_of_ty(ty);\n                 let tcx = cx.tcx();\n                 let is_freeze = ty.is_freeze(tcx.at(DUMMY_SP), cx.param_env());\n                 let kind = match mt {\n@@ -2210,6 +2225,7 @@ where\n                     size: layout.size,\n                     align: layout.align.abi,\n                     safe: Some(kind),\n+                    address_space,\n                 })\n             }\n \n@@ -2254,7 +2270,9 @@ where\n                             result = field.to_result().ok().and_then(|field| {\n                                 if ptr_end <= field_start + field.size {\n                                     // We found the right field, look inside it.\n-                                    field.pointee_info_at(cx, offset - field_start)\n+                                    let field_info =\n+                                        field.pointee_info_at(cx, offset - field_start);\n+                                    field_info\n                                 } else {\n                                     None\n                                 }\n@@ -2277,7 +2295,14 @@ where\n \n                 result\n             }\n-        }\n+        };\n+\n+        debug!(\n+            \"pointee_info_at (offset={:?}, type kind: {:?}) => {:?}\",\n+            offset, this.ty.kind, pointee_info\n+        );\n+\n+        pointee_info\n     }\n }\n "}, {"sha": "b3e5f5c0c74b163e90d55d521ac17a93e1050059", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -32,7 +32,7 @@ pub struct TargetDataLayout {\n     /// Alignments for vector types.\n     pub vector_align: Vec<(Size, AbiAndPrefAlign)>,\n \n-    pub instruction_address_space: u32,\n+    pub instruction_address_space: AddressSpace,\n }\n \n impl Default for TargetDataLayout {\n@@ -56,7 +56,7 @@ impl Default for TargetDataLayout {\n                 (Size::from_bits(64), AbiAndPrefAlign::new(align(64))),\n                 (Size::from_bits(128), AbiAndPrefAlign::new(align(128))),\n             ],\n-            instruction_address_space: 0,\n+            instruction_address_space: AddressSpace::DATA,\n         }\n     }\n }\n@@ -65,7 +65,7 @@ impl TargetDataLayout {\n     pub fn parse(target: &Target) -> Result<TargetDataLayout, String> {\n         // Parse an address space index from a string.\n         let parse_address_space = |s: &str, cause: &str| {\n-            s.parse::<u32>().map_err(|err| {\n+            s.parse::<u32>().map(AddressSpace).map_err(|err| {\n                 format!(\"invalid address space `{}` for `{}` in \\\"data-layout\\\": {}\", s, cause, err)\n             })\n         };\n@@ -744,6 +744,17 @@ impl FieldsShape {\n     }\n }\n \n+/// An identifier that specifies the address space that some operation\n+/// should operate on. Special address spaces have an effect on code generation,\n+/// depending on the target and the address spaces it implements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct AddressSpace(pub u32);\n+\n+impl AddressSpace {\n+    /// The default address space, corresponding to data space.\n+    pub const DATA: Self = AddressSpace(0);\n+}\n+\n /// Describes how values of the type are passed by target ABIs,\n /// in terms of categories of C types there are ABI rules for.\n #[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n@@ -1013,7 +1024,7 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PointerKind {\n     /// Most general case, we know no restrictions to tell LLVM.\n     Shared,\n@@ -1028,11 +1039,12 @@ pub enum PointerKind {\n     UniqueOwned,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct PointeeInfo {\n     pub size: Size,\n     pub align: Align,\n     pub safe: Option<PointerKind>,\n+    pub address_space: AddressSpace,\n }\n \n pub trait TyAndLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {"}, {"sha": "7759d9603a5a47a73104f01740180b1ae24a6d1b", "filename": "src/test/codegen/avr/avr-func-addrspace.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b61bff0bdd08be7665607cb7be3748c8a35d2/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Favr%2Favr-func-addrspace.rs?ref=e22b61bff0bdd08be7665607cb7be3748c8a35d2", "patch": "@@ -0,0 +1,93 @@\n+// compile-flags: -O --target=avr-unknown-unknown --crate-type=rlib\n+\n+// This test validates that function pointers can be stored in global variables\n+// and called upon. It ensures that Rust emits function pointers in the correct\n+// address space to LLVM so that an assertion error relating to casting is\n+// not triggered.\n+//\n+// It also validates that functions can be called through function pointers\n+// through traits.\n+\n+#![feature(no_core, lang_items, unboxed_closures, arbitrary_self_types)]\n+#![crate_type = \"lib\"]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+pub trait Sized { }\n+#[lang = \"copy\"]\n+pub trait Copy { }\n+#[lang = \"receiver\"]\n+pub trait Receiver { }\n+\n+pub struct Result<T, E> { _a: T, _b: E }\n+\n+impl Copy for usize {}\n+\n+#[lang = \"drop_in_place\"]\n+pub unsafe fn drop_in_place<T: ?Sized>(_: *mut T) {}\n+\n+#[lang = \"fn_once\"]\n+pub trait FnOnce<Args> {\n+    #[lang = \"fn_once_output\"]\n+    type Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn_mut\"]\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+#[lang = \"fn\"]\n+pub trait Fn<Args>: FnOnce<Args> {\n+    /// Performs the call operation.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n+impl<'a, A, R> FnOnce<A> for &'a fn(A) -> R {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> R {\n+        (*self)(args)\n+    }\n+}\n+\n+pub static mut STORAGE_FOO: fn(&usize, &mut u32) -> Result<(), ()> = arbitrary_black_box;\n+pub static mut STORAGE_BAR: u32 = 12;\n+\n+fn arbitrary_black_box(ptr: &usize, _: &mut u32) -> Result<(), ()> {\n+    let raw_ptr = ptr as *const usize;\n+    let _v: usize = unsafe { *raw_ptr };\n+    loop {}\n+}\n+\n+#[inline(never)]\n+#[no_mangle]\n+fn call_through_fn_trait(a: &mut impl Fn<(), Output=()>) {\n+    (*a)()\n+}\n+\n+#[inline(never)]\n+fn update_bar_value() {\n+    unsafe {\n+        STORAGE_BAR = 88;\n+    }\n+}\n+\n+// CHECK: define void @test(){{.+}}addrspace(1)\n+#[no_mangle]\n+pub extern \"C\" fn test() {\n+    let mut buf = 7;\n+\n+    // A call through the Fn trait must use address space 1.\n+    //\n+    // CHECK: call{{.+}}addrspace(1) void @call_through_fn_trait()\n+    call_through_fn_trait(&mut update_bar_value);\n+\n+    // A call through a global variable must use address space 1.\n+    // CHECK: load {{.*}}addrspace(1){{.+}}FOO\n+    unsafe {\n+        STORAGE_FOO(&1, &mut buf);\n+    }\n+}"}]}