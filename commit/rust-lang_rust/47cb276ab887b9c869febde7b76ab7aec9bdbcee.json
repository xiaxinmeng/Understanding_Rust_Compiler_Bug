{"sha": "47cb276ab887b9c869febde7b76ab7aec9bdbcee", "node_id": "C_kwDOAAsO6NoAKDQ3Y2IyNzZhYjg4N2I5Yzg2OWZlYmRlN2I3NmFiN2FlYzliZGJjZWU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-02T21:09:40Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-06T18:03:20Z"}, "message": "support passing unsized fn arguments", "tree": {"sha": "02013d820dcdc4db5eabf8340e9ad426f6ffbc3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02013d820dcdc4db5eabf8340e9ad426f6ffbc3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47cb276ab887b9c869febde7b76ab7aec9bdbcee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47cb276ab887b9c869febde7b76ab7aec9bdbcee", "html_url": "https://github.com/rust-lang/rust/commit/47cb276ab887b9c869febde7b76ab7aec9bdbcee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47cb276ab887b9c869febde7b76ab7aec9bdbcee/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6", "html_url": "https://github.com/rust-lang/rust/commit/8ef0caa23ca31ccc8ef3769a0aeb35bea15532a6"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "522f55bf56552cd493aa0649a6fc28cab7d22e10", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/47cb276ab887b9c869febde7b76ab7aec9bdbcee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb276ab887b9c869febde7b76ab7aec9bdbcee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=47cb276ab887b9c869febde7b76ab7aec9bdbcee", "patch": "@@ -183,6 +183,18 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     }\n }\n \n+impl<Tag: Provenance> Place<Tag> {\n+    /// Asserts that this points to some local variable.\n+    /// Returns the frame idx and the variable idx.\n+    #[inline]\n+    pub fn assert_local(&self) -> (usize, mir::Local) {\n+        match self {\n+            Place::Local { frame, local } => (*frame, *local),\n+            _ => bug!(\"assert_local: expected Place::Local, got {:?}\", self),\n+        }\n+    }\n+}\n+\n impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     /// Produces a MemPlace that works for ZST but nothing else\n     #[inline]\n@@ -286,7 +298,7 @@ impl<'tcx, Tag: Provenance> PlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Tag> {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Tag> {\n         self.try_as_mplace().unwrap()\n     }\n }\n@@ -899,16 +911,16 @@ where\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n         let dest = self.force_allocation(dest)?;\n-        assert!(!(src.layout.is_unsized() || dest.layout.is_unsized()), \"cannot copy unsized data\");\n-        assert_eq!(src.layout.size, dest.layout.size, \"Cannot copy differently-sized data\");\n+        let Some((dest_size, _)) = self.size_and_align_of_mplace(&dest)? else {\n+            span_bug!(self.cur_span(), \"copy_op needs (dynamically) sized values\")\n+        };\n+        if cfg!(debug_assertions) {\n+            let src_size = self.size_and_align_of_mplace(&src)?.unwrap().0;\n+            assert_eq!(src_size, dest_size, \"Cannot copy differently-sized data\");\n+        }\n \n         self.mem_copy(\n-            src.ptr,\n-            src.align,\n-            dest.ptr,\n-            dest.align,\n-            dest.layout.size,\n-            /*nonoverlapping*/ false,\n+            src.ptr, src.align, dest.ptr, dest.align, dest_size, /*nonoverlapping*/ false,\n         )\n     }\n "}, {"sha": "613533f85e98caa6aa07afbd900e578a67f02ef8", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/47cb276ab887b9c869febde7b76ab7aec9bdbcee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47cb276ab887b9c869febde7b76ab7aec9bdbcee/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=47cb276ab887b9c869febde7b76ab7aec9bdbcee", "patch": "@@ -12,8 +12,8 @@ use rustc_target::abi::call::{ArgAbi, ArgAttribute, ArgAttributes, FnAbi, PassMo\n use rustc_target::spec::abi::Abi;\n \n use super::{\n-    FnVal, ImmTy, InterpCx, InterpResult, MPlaceTy, Machine, OpTy, PlaceTy, Scalar,\n-    StackPopCleanup, StackPopUnwind,\n+    FnVal, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, Operand,\n+    PlaceTy, Scalar, StackPopCleanup, StackPopUnwind,\n };\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -185,11 +185,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // No question\n                 return true;\n             }\n+            if caller_abi.layout.is_unsized() || callee_abi.layout.is_unsized() {\n+                // No, no, no. We require the types to *exactly* match for unsized arguments. If\n+                // these are somehow unsized \"in a different way\" (say, `dyn Trait` vs `[i32]`),\n+                // then who knows what happens.\n+                return false;\n+            }\n             if caller_abi.layout.size != callee_abi.layout.size\n                 || caller_abi.layout.align.abi != callee_abi.layout.align.abi\n             {\n                 // This cannot go well...\n-                // FIXME: What about unsized types?\n                 return false;\n             }\n             // The rest *should* be okay, but we are extra conservative.\n@@ -287,6 +292,31 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 caller_arg.layout.ty\n             )\n         }\n+        // Special handling for unsized parameters.\n+        if caller_arg.layout.is_unsized() {\n+            // `check_argument_compat` ensures that both have the same type, so we know they will use the metadata the same way.\n+            assert_eq!(caller_arg.layout.ty, callee_arg.layout.ty);\n+            // We have to properly pre-allocate the memory for the callee.\n+            // So let's tear down some wrappers.\n+            // This all has to be in memory, there are no immediate unsized values.\n+            let src = caller_arg.assert_mem_place();\n+            // The destination cannot be one of these \"spread args\".\n+            let (dest_frame, dest_local) = callee_arg.assert_local();\n+            // We are just initializing things, so there can't be anything here yet.\n+            assert!(matches!(\n+                *self.local_to_op(&self.stack()[dest_frame], dest_local, None)?,\n+                Operand::Immediate(Immediate::Uninit)\n+            ));\n+            // Allocate enough memory to hold `src`.\n+            let Some((size, align)) = self.size_and_align_of_mplace(&src)? else {\n+                span_bug!(self.cur_span(), \"unsized fn arg with `extern` type tail should not be allowed\")\n+            };\n+            let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n+            let dest_place =\n+                MPlaceTy::from_aligned_ptr_with_meta(ptr.into(), callee_arg.layout, src.meta);\n+            // Update the local to be that new place.\n+            *M::access_local_mut(self, dest_frame, dest_local)? = Operand::Indirect(*dest_place);\n+        }\n         // We allow some transmutes here.\n         // FIXME: Depending on the PassMode, this should reset some padding to uninitialized. (This\n         // is true for all `copy_op`, but there are a lot of special cases for argument passing"}]}