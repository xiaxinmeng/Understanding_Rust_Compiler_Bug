{"sha": "6e3d5c62e79026920d09833889ea837b19b0a9d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlM2Q1YzYyZTc5MDI2OTIwZDA5ODMzODg5ZWE4MzdiMTliMGE5ZDA=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-09-15T00:47:20Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-09-15T04:41:41Z"}, "message": "std::num: Remove `range_step` for each numeric type\n\nReplaced by `std::iter::range_step`", "tree": {"sha": "dc8525bdac1e158af6b878933719646cc738af59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc8525bdac1e158af6b878933719646cc738af59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e3d5c62e79026920d09833889ea837b19b0a9d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e3d5c62e79026920d09833889ea837b19b0a9d0", "html_url": "https://github.com/rust-lang/rust/commit/6e3d5c62e79026920d09833889ea837b19b0a9d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e3d5c62e79026920d09833889ea837b19b0a9d0/comments", "author": null, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad74fde62f4076eb1877a8c68d9b2e34990459b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad74fde62f4076eb1877a8c68d9b2e34990459b9", "html_url": "https://github.com/rust-lang/rust/commit/ad74fde62f4076eb1877a8c68d9b2e34990459b9"}], "stats": {"total": 296, "additions": 0, "deletions": 296}, "files": [{"sha": "39f32c5ff426eab0055a252a870edc46050efca6", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/6e3d5c62e79026920d09833889ea837b19b0a9d0/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3d5c62e79026920d09833889ea837b19b0a9d0/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=6e3d5c62e79026920d09833889ea837b19b0a9d0", "patch": "@@ -41,101 +41,6 @@ impl CheckedDiv for $T {\n     }\n }\n \n-enum Range { Closed, HalfOpen }\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n-/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n-///\n-/// If no such nonnegative integer `n` exists, then the iteration range\n-/// is empty.\n-///\n-fn range_step_core(start: $T, stop: $T, step: $T, r: Range, it: &fn($T) -> bool) -> bool {\n-    let mut i = start;\n-    if step == 0 {\n-        fail!(~\"range_step called with step == 0\");\n-    } else if step == (1 as $T) { // elide bounds check to tighten loop\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // no need for overflow check;\n-            // cannot have i + 1 > max_value because i < stop <= max_value\n-            i += (1 as $T);\n-        }\n-    } else if step == (-1 as $T) { // elide bounds check to tighten loop\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // no need for underflow check;\n-            // cannot have i - 1 < min_value because i > stop >= min_value\n-            i -= (1 as $T);\n-        }\n-    } else if step > 0 { // ascending\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // avoiding overflow. break if i + step > max_value\n-            if i > max_value - step { return true; }\n-            i += step;\n-        }\n-    } else { // descending\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // avoiding underflow. break if i + step < min_value\n-            if i < min_value - step { return true; }\n-            i += step;\n-        }\n-    }\n-    match r {\n-        HalfOpen => return true,\n-        Closed => return (i != stop || it(i))\n-    }\n-}\n-\n-#[inline]\n-///\n-/// Iterate through the range [`start`..`stop`) with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// * `x_i == start + step*i`, and\n-/// * `n` is the greatest nonnegative integer such that `x_n < stop`\n-///\n-/// (If no such `n` exists, then the iteration range is empty.)\n-///\n-/// # Arguments\n-///\n-/// * `start` - lower bound, inclusive\n-/// * `stop` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~\n-/// let mut sum = 0;\n-/// for int::range(1, 5) |i| {\n-///     sum += i;\n-/// }\n-/// assert!(sum == 10);\n-/// ~~~\n-///\n-pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, stop, step, HalfOpen, it)\n-}\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n-///\n-/// (If no such nonnegative integer `n` exists, then the iteration\n-///  range is empty.)\n-///\n-pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, last, step, Closed, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -878,56 +783,6 @@ mod tests {\n         assert!(i64::from_str(\"-9223372036854775809\").is_none());\n     }\n \n-    #[test]\n-    fn test_ranges() {\n-        let mut l = ~[];\n-\n-        do range_step(20,26,2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(36,30,-2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 2, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 3, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 2, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 3, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        assert_eq!(l, ~[20,22,24,\n-                        36,34,32,\n-                        max_value-2,\n-                        max_value-3,max_value-1,\n-                        min_value+2,\n-                        min_value+3,min_value+1]);\n-\n-        // None of the `fail`s should execute.\n-        do range_step(10,0,1) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n-        do range_step(0,10,-1) |_i| {\n-            fail!(~\"unreachable\");\n-        };\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step() {\n-        do range_step(0,10,0) |_i| { true };\n-    }\n-\n     #[test]\n     fn test_signed_checked_div() {\n         assert_eq!(10i.checked_div(&2), Some(5));"}, {"sha": "4c64efb9114aa65d35dfbdb6d77d3bf51bc5353c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6e3d5c62e79026920d09833889ea837b19b0a9d0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e3d5c62e79026920d09833889ea837b19b0a9d0/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=6e3d5c62e79026920d09833889ea837b19b0a9d0", "patch": "@@ -42,101 +42,6 @@ impl CheckedDiv for $T {\n     }\n }\n \n-enum Range { Closed, HalfOpen }\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n-/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n-///\n-/// If no such nonnegative integer `n` exists, then the iteration range\n-/// is empty.\n-///\n-fn range_step_core(start: $T, stop: $T, step: $T_SIGNED, r: Range, it: &fn($T) -> bool) -> bool {\n-    let mut i = start;\n-    if step == 0 {\n-        fail!(\"range_step called with step == 0\");\n-    } else if step == (1 as $T_SIGNED) { // elide bounds check to tighten loop\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // no need for overflow check;\n-            // cannot have i + 1 > max_value because i < stop <= max_value\n-            i += (1 as $T);\n-        }\n-    } else if step == (-1 as $T_SIGNED) { // elide bounds check to tighten loop\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // no need for underflow check;\n-            // cannot have i - 1 < min_value because i > stop >= min_value\n-            i -= (1 as $T);\n-        }\n-    } else if step > 0 { // ascending\n-        while i < stop {\n-            if !it(i) { return false; }\n-            // avoiding overflow. break if i + step > max_value\n-            if i > max_value - (step as $T) { return true; }\n-            i += step as $T;\n-        }\n-    } else { // descending\n-        while i > stop {\n-            if !it(i) { return false; }\n-            // avoiding underflow. break if i + step < min_value\n-            if i < min_value + ((-step) as $T) { return true; }\n-            i -= -step as $T;\n-        }\n-    }\n-    match r {\n-        HalfOpen => return true,\n-        Closed => return (i != stop || it(i))\n-    }\n-}\n-\n-#[inline]\n-///\n-/// Iterate through the range [`start`..`stop`) with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// - `x_i == start + step*i`, and\n-/// - `n` is the greatest nonnegative integer such that `x_n < stop`\n-///\n-/// (If no such `n` exists, then the iteration range is empty.)\n-///\n-/// # Arguments\n-///\n-/// * `start` - lower bound, inclusive\n-/// * `stop` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~ {.rust}\n-/// let nums = [1,2,3,4,5,6,7];\n-///\n-/// for uint::range_step(0, nums.len() - 1, 2) |i| {\n-///     printfln!(\"%d & %d\", nums[i], nums[i+1]);\n-/// }\n-/// ~~~\n-///\n-pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, stop, step, HalfOpen, it)\n-}\n-\n-#[inline]\n-///\n-/// Iterate through a range with a given step value.\n-///\n-/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n-/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n-///\n-/// (If no such nonnegative integer `n` exists, then the iteration\n-///  range is empty.)\n-///\n-pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n-    range_step_core(start, last, step, Closed, it)\n-}\n-\n impl Num for $T {}\n \n #[cfg(not(test))]\n@@ -653,62 +558,6 @@ mod tests {\n         100u.to_str_radix(37u);\n     }\n \n-    #[test]\n-    pub fn test_ranges() {\n-        let mut l = ~[];\n-\n-        do range_step(20,26,2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(36,30,-2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 2, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(max_value - 3, max_value, 2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 2, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-        do range_step(min_value + 3, min_value, -2) |i| {\n-            l.push(i);\n-            true\n-        };\n-\n-        assert_eq!(l, ~[20,22,24,\n-                        36,34,32,\n-                        max_value-2,\n-                        max_value-3,max_value-1,\n-                        min_value+2,\n-                        min_value+3,min_value+1]);\n-\n-        // None of the `fail`s should execute.\n-        do range_step(10,0,1) |_i| {\n-            fail!(\"unreachable\");\n-        };\n-        do range_step(0,1,-10) |_i| {\n-            fail!(\"unreachable\");\n-        };\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step_up() {\n-        do range_step(0,10,0) |_i| { true };\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_range_step_zero_step_down() {\n-        do range_step(0,-10,0) |_i| { true };\n-    }\n-\n     #[test]\n     fn test_unsigned_checked_div() {\n         assert_eq!(10u.checked_div(&2), Some(5));"}]}