{"sha": "6601ffca07f9a18a07351dcb54bb85a451aacb74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2MDFmZmNhMDdmOWExOGEwNzM1MWRjYjU0YmI4NWE0NTFhYWNiNzQ=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-08-10T17:30:41Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2017-08-16T15:45:05Z"}, "message": "replace procsrv functions with `Command`", "tree": {"sha": "17fa81f63e4b01d2bec8f3125dacfdbe1a32375c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17fa81f63e4b01d2bec8f3125dacfdbe1a32375c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6601ffca07f9a18a07351dcb54bb85a451aacb74", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJ9c9OhXB85uXPmbOeLE+KEl68t8FAlmUaIEACgkQeLE+KEl6\n8t/XARAAlTj5snLR2X88+qNJuPYOhB7tsCTUBKJ7IKXGJKhqu+OFWBFQ+KJV+az9\n7XbHlLIzEXCP1AI3wI6uIH0fqgKIaD8Uq+JI8C8xXWb3g+YljylVtI26JsywfV6K\nRRj6uX/qLMG0KEnbeHb3p2VG0/ScimNd0/x0xmwRzLUdAieF99Jbt6qP6g3tEESr\nhwW3GB8H0VmxzP5fgAn6+sxbCrkg1zz5buIzgfsVn5rQ5Z/XQ7uFxNhWHFOa9qmz\n88mlZHUpuFn04eo2ZFmJB/3BjgP8ow3kjvMw7jd+FAqSBPEwEN9rgIv400YIZJ3N\nkT22JmAriHpmSeH5V5lv5f2J2fZIBuXXiaMJfV6qaGslvbQzdObqAZob6y213SaP\nfoVMTboY4jpAIW/kEILvsje9Ap84TGnPt4N5EJzn1DKaml7AUjf04UE8OCxbCgEs\nfcJvQIMsOWH6EuryIP3FPyut/FzpjPmaorH98cBquLC0SSn0oA9xSeD88xa15hqr\nuZyO2QAMeplx8wg8h05mDFvo7g/349gY7maFQ2lHWVNdwStc4nxoK0gKCA+iexyl\nsMAGjaYtj38o4A/MyJX3s8CtT8n5YtTi6TWVFmTIvtQ9QACSJ64jOaLdWagv5N/D\nqyi5a+WhLCsIYO2c0nZfRbZb8yLFkFPbiBO4DKGuo+BThNSi5FA=\n=uPtZ\n-----END PGP SIGNATURE-----", "payload": "tree 17fa81f63e4b01d2bec8f3125dacfdbe1a32375c\nparent c88624682ddb5768cca4dacc8482e9bc966261fc\nauthor Andy Russell <arussell123@gmail.com> 1502386241 -0400\ncommitter Andy Russell <arussell123@gmail.com> 1502898305 -0400\n\nreplace procsrv functions with `Command`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6601ffca07f9a18a07351dcb54bb85a451aacb74", "html_url": "https://github.com/rust-lang/rust/commit/6601ffca07f9a18a07351dcb54bb85a451aacb74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6601ffca07f9a18a07351dcb54bb85a451aacb74/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c88624682ddb5768cca4dacc8482e9bc966261fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c88624682ddb5768cca4dacc8482e9bc966261fc", "html_url": "https://github.com/rust-lang/rust/commit/c88624682ddb5768cca4dacc8482e9bc966261fc"}], "stats": {"total": 252, "additions": 70, "deletions": 182}, "files": [{"sha": "ab9eb5b9a5dab6c01f0f838a33128add7bfa6993", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 2, "deletions": 90, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6601ffca07f9a18a07351dcb54bb85a451aacb74/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6601ffca07f9a18a07351dcb54bb85a451aacb74/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=6601ffca07f9a18a07351dcb54bb85a451aacb74", "patch": "@@ -10,10 +10,8 @@\n \n use std::env;\n use std::ffi::OsString;\n-use std::io::prelude::*;\n-use std::io;\n use std::path::PathBuf;\n-use std::process::{Child, Command, ExitStatus, Output, Stdio};\n+use std::process::Command;\n \n /// Get the name of the environment variable that holds dynamic library\n /// locations\n@@ -31,7 +29,7 @@ pub fn dylib_env_var() -> &'static str {\n \n /// Add `lib_path` and `aux_path` (if it is `Some`) to the dynamic library\n /// env var\n-fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n+pub fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let var = dylib_env_var();\n@@ -46,89 +44,3 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     let newpath = env::join_paths(&path).unwrap();\n     cmd.env(var, newpath);\n }\n-\n-/// Represents exit status, stdout and stderr of a completed process\n-pub struct Result {\n-    pub status: ExitStatus,\n-    pub out: String,\n-    pub err: String,\n-}\n-\n-/// Runs a test program\n-///\n-/// # Params\n-///  - `lib_path` Path to search for required library\n-///  - `prog` command to run\n-///  - `aux_path` Optional extra path to search for required\n-///    auxiliary libraries\n-///  - `args` List of arguments to pass to `prog`\n-///  - `env` List of environment variables to set, `.0` is variable name,\n-///    `.1` is value\n-///  - `input` String to be fed as stdin\n-///  - `current_dir` Optional working dir to run command in\n-///\n-pub fn run(lib_path: &str,\n-           prog: &str,\n-           aux_path: Option<&str>,\n-           args: &[String],\n-           env: Vec<(String, String)>,\n-           input: Option<String>,\n-           current_dir: Option<String>)\n-           -> io::Result<Result> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::piped())\n-        .stdin(Stdio::piped());\n-\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-    let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n-\n-    Ok(Result {\n-        status,\n-        out: String::from_utf8(stdout).unwrap(),\n-        err: String::from_utf8(stderr).unwrap(),\n-    })\n-}\n-\n-/// Same as `run`, but return process rather than waiting on completion\n-pub fn run_background(lib_path: &str,\n-                      prog: &str,\n-                      aux_path: Option<&str>,\n-                      args: &[String],\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      current_dir: Option<String>)\n-                      -> io::Result<Child> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped());\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-\n-    Ok(process)\n-}"}, {"sha": "7614c865ce2cbd188df6df63f491737008e0c7dd", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 68, "deletions": 92, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/6601ffca07f9a18a07351dcb54bb85a451aacb74/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6601ffca07f9a18a07351dcb54bb85a451aacb74/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=6601ffca07f9a18a07351dcb54bb85a451aacb74", "patch": "@@ -27,7 +27,7 @@ use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus};\n+use std::process::{Command, Output, ExitStatus, Stdio};\n use std::str;\n use std::collections::HashMap;\n \n@@ -500,32 +500,19 @@ actual:\\n\\\n                 debug!(\"script_str = {}\", script_str);\n                 self.dump_output_file(&script_str, \"debugger.script\");\n \n+                let adb_path = &self.config.adb_path;\n \n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"push\".to_owned(),\n-                                 exe_file.to_str().unwrap().to_owned(),\n-                                 self.config.adb_test_dir.clone()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n-\n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"forward\".to_owned(),\n-                                 \"tcp:5039\".to_owned(),\n-                                 \"tcp:5039\".to_owned()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                Command::new(adb_path)\n+                    .arg(\"push\")\n+                    .arg(&exe_file)\n+                    .arg(&self.config.adb_test_dir)\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+                Command::new(adb_path)\n+                    .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                        gdbserver{} :5039 {}/{}\",\n@@ -537,23 +524,15 @@ actual:\\n\\\n                                       .unwrap());\n \n                 debug!(\"adb arg: {}\", adb_arg);\n-                let mut process = procsrv::run_background(\"\",\n-                                                          &self.config.adb_path\n-                                                          ,\n-                                                          None,\n-                                                          &[\n-                                                              \"shell\".to_owned(),\n-                                                              adb_arg.clone()\n-                                                          ],\n-                                                          Vec::new(),\n-                                                          None,\n-                                                          None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                let mut adb = Command::new(adb_path)\n+                    .args(&[\"shell\", &adb_arg])\n+                    .spawn()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 // Wait for the gdbserver to print out \"Listening on port ...\"\n                 // at which point we know that it's started and then we can\n                 // execute the debugger below.\n-                let mut stdout = BufReader::new(process.stdout.take().unwrap());\n+                let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n                 let mut line = String::new();\n                 loop {\n                     line.truncate(0);\n@@ -574,17 +553,13 @@ actual:\\n\\\n \n                 let mut gdb_path = tool_path;\n                 gdb_path.push_str(\"/bin/gdb\");\n-                let procsrv::Result {\n-                    out,\n-                    err,\n-                    status\n-                } = procsrv::run(\"\",\n-                                 &gdb_path,\n-                                 None,\n-                                 &debugger_opts,\n-                                 Vec::new(),\n-                                 None,\n-                                 None)\n+                let Output {\n+                    status,\n+                    stdout,\n+                    stderr\n+                } = Command::new(&gdb_path)\n+                    .args(&debugger_opts)\n+                    .output()\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {\n                     let cmdline = self.make_cmdline(\"\",\n@@ -596,11 +571,11 @@ actual:\\n\\\n \n                 debugger_run_result = ProcRes {\n                     status,\n-                    stdout: out,\n-                    stderr: err,\n+                    stdout: String::from_utf8(stdout).unwrap(),\n+                    stderr: String::from_utf8(stderr).unwrap(),\n                     cmdline,\n                 };\n-                if process.kill().is_err() {\n+                if adb.kill().is_err() {\n                     println!(\"Adb process is already finished.\");\n                 }\n             }\n@@ -1367,7 +1342,46 @@ actual:\\n\\\n                        aux_path: Option<&str>,\n                        input: Option<String>,\n                        working_dir: Option<String>) -> ProcRes {\n-        self.program_output(lib_path, prog, aux_path, args, procenv, input, working_dir)\n+        let cmdline =\n+        {\n+            let cmdline = self.make_cmdline(lib_path,\n+                                            &prog,\n+                                            &args);\n+            logv(self.config, format!(\"executing {}\", cmdline));\n+            cmdline\n+        };\n+\n+        let mut process = Command::new(&prog);\n+        process\n+            .args(&args)\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::piped())\n+            .stdin(Stdio::piped());\n+\n+        procsrv::add_target_env(&mut process, lib_path, aux_path);\n+        for (key, val) in procenv {\n+            process.env(&key, &val);\n+        }\n+        if let Some(cwd) = working_dir {\n+            process.current_dir(cwd);\n+        }\n+\n+        let mut child = process.spawn().expect(&format!(\"failed to exec `{}`\", prog));\n+        if let Some(input) = input {\n+            child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n+        }\n+        let Output { status, stdout, stderr } = child.wait_with_output().unwrap();\n+\n+        let result = ProcRes {\n+            status,\n+            stdout: String::from_utf8(stdout).unwrap(),\n+            stderr: String::from_utf8(stderr).unwrap(),\n+            cmdline,\n+        };\n+\n+        self.dump_output(&result.stdout, &result.stderr);\n+\n+        result\n     }\n \n     fn make_compile_args(&self,\n@@ -1554,44 +1568,6 @@ actual:\\n\\\n         }\n     }\n \n-    fn program_output(&self,\n-                      lib_path: &str,\n-                      prog: String,\n-                      aux_path: Option<&str>,\n-                      args: Vec<String>,\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      working_dir: Option<String>)\n-                      -> ProcRes {\n-        let cmdline =\n-        {\n-            let cmdline = self.make_cmdline(lib_path,\n-                                            &prog,\n-                                            &args);\n-            logv(self.config, format!(\"executing {}\", cmdline));\n-            cmdline\n-        };\n-\n-        let procsrv::Result {\n-            out,\n-            err,\n-            status\n-        } = procsrv::run(lib_path,\n-                         &prog,\n-                         aux_path,\n-                         &args,\n-                         env,\n-                         input,\n-                         working_dir).expect(&format!(\"failed to exec `{}`\", prog));\n-        self.dump_output(&out, &err);\n-        ProcRes {\n-            status,\n-            stdout: out,\n-            stderr: err,\n-            cmdline,\n-        }\n-    }\n-\n     fn make_cmdline(&self, libpath: &str, prog: &str, args: &[String]) -> String {\n         use util;\n "}]}