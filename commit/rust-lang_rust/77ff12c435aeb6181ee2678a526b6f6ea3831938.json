{"sha": "77ff12c435aeb6181ee2678a526b6f6ea3831938", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZmYxMmM0MzVhZWI2MTgxZWUyNjc4YTUyNmI2ZjZlYTM4MzE5Mzg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-18T22:17:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-18T22:19:06Z"}, "message": "rustboot: Don't use walk to traverse statements in type.ml; fixes redundant checking, improves diagnostics. Also report untyped slots.", "tree": {"sha": "499fd7149a5fc2a9f0f8c9201b4e2e21c4231f26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/499fd7149a5fc2a9f0f8c9201b4e2e21c4231f26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77ff12c435aeb6181ee2678a526b6f6ea3831938", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77ff12c435aeb6181ee2678a526b6f6ea3831938", "html_url": "https://github.com/rust-lang/rust/commit/77ff12c435aeb6181ee2678a526b6f6ea3831938", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77ff12c435aeb6181ee2678a526b6f6ea3831938/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26ecec4e123781c6e99e92cf42ce585e33a861ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/26ecec4e123781c6e99e92cf42ce585e33a861ef", "html_url": "https://github.com/rust-lang/rust/commit/26ecec4e123781c6e99e92cf42ce585e33a861ef"}], "stats": {"total": 123, "additions": 69, "deletions": 54}, "files": [{"sha": "70fc10948374b5b752378fd140165485ea8984ef", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -20,7 +20,9 @@ type ty_pat =\n type fn_ctx = {\n   fnctx_return_type: Ast.ty;\n   fnctx_is_iter: bool;\n-  mutable fnctx_just_saw_ret: bool\n+  mutable fnctx_just_saw_ret: bool;\n+  fnctx_blocks: Common.node_id Stack.t;\n+  fnctx_slot_decls: (Ast.slot_key,Common.node_id) Hashtbl.t;\n }\n \n exception Type_error of string * string\n@@ -188,7 +190,7 @@ let type_error cx expected actual =\n \n (* We explicitly curry [cx] like this to avoid threading it through all the\n  * inner functions. *)\n-let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n+let check_block (cx:Semant.ctxt) : (fn_ctx -> Ast.block -> unit) =\n   let pretty_ty_str = Semant.pretty_ty_str cx (Ast.sprintf_ty ()) in\n \n   (* Returns the part of the type that matters for typechecking. *)\n@@ -894,7 +896,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n   (* Again as above, we explicitly curry [fn_ctx] to avoid threading it\n    * through these functions. *)\n-  let check_stmt (fn_ctx:fn_ctx) : (Ast.stmt -> unit) =\n+  let check_block (fn_ctx:fn_ctx) : (Ast.block -> unit) =\n     let check_ret (stmt:Ast.stmt) : unit =\n       fn_ctx.fnctx_just_saw_ret <-\n         match stmt.Common.node with\n@@ -904,7 +906,8 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n     in\n \n     let rec check_block (block:Ast.block) : unit =\n-      Array.iter check_stmt block.Common.node\n+      Stack.push block.Common.id fn_ctx.fnctx_blocks;\n+      Array.iter check_stmt' block.Common.node\n \n     and check_stmt (stmt:Ast.stmt) : unit =\n       check_ret stmt;\n@@ -1050,7 +1053,7 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n         | Ast.STMT_while w | Ast.STMT_do_while w ->\n             let (stmts, expr) = w.Ast.while_lval in\n-            Array.iter check_stmt stmts;\n+            Array.iter check_stmt' stmts;\n             demand Ast.TY_bool (check_expr expr);\n             check_block w.Ast.while_body\n \n@@ -1098,7 +1101,10 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n             let get_pat arm = fst arm.Common.node in\n             let pats = Array.map get_pat alt_tag.Ast.alt_tag_arms in\n             let ty = check_lval alt_tag.Ast.alt_tag_lval in\n-            Array.iter (check_pat ty) pats\n+            let get_block arm = snd arm.Common.node in\n+            let blocks = Array.map get_block alt_tag.Ast.alt_tag_arms in\n+            Array.iter (check_pat ty) pats;\n+            Array.iter check_block blocks\n \n         | Ast.STMT_alt_type _ -> () (* TODO *)\n \n@@ -1132,10 +1138,12 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n \n         | Ast.STMT_block block -> check_block block\n \n-        | Ast.STMT_decl _ -> () (* always well-typed *)\n-    in\n+        | Ast.STMT_decl (Ast.DECL_slot (slot_key, _)) ->\n+            Hashtbl.add fn_ctx.fnctx_slot_decls slot_key stmt.Common.id\n+\n+        | Ast.STMT_decl (Ast.DECL_mod_item _) -> () (* always well-typed *)\n \n-    let check_stmt' stmt =\n+    and check_stmt' stmt =\n       try\n         check_stmt stmt\n       with Type_error (expected, actual) ->\n@@ -1145,9 +1153,9 @@ let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n           expected\n           actual\n     in\n-    check_stmt'\n+    check_block\n   in\n-  check_stmt\n+  check_block\n \n let create_tag_graph_nodes (cx:Semant.ctxt) =\n   let make_graph_node id _ =\n@@ -1259,8 +1267,6 @@ let check_for_tag_cycles (cx:Semant.ctxt) =\n   Hashtbl.iter check_node cx.Semant.ctxt_tag_containment\n \n let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n-  let fn_ctx_stack = Stack.create () in\n-\n   (* Verify that, if main is present, it has the right form. *)\n   let verify_main (item_id:Common.node_id) : unit =\n     let path_name = Hashtbl.find cx.Semant.ctxt_all_item_names item_id in\n@@ -1284,28 +1290,43 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n   in\n \n   let visitor (cx:Semant.ctxt) (inner:Walk.visitor) : Walk.visitor =\n-    let push_fn_ctx (ret_ty:Ast.ty) (is_iter:bool) =\n-      let fn_ctx = {\n+    let create_fn_ctx (ret_ty:Ast.ty) (is_iter:bool) =\n+      {\n         fnctx_return_type = ret_ty;\n         fnctx_is_iter = is_iter;\n-        fnctx_just_saw_ret = false\n-      } in\n-      Stack.push fn_ctx fn_ctx_stack\n+        fnctx_just_saw_ret = false;\n+        fnctx_blocks = Stack.create ();\n+        fnctx_slot_decls = Hashtbl.create 0;\n+      }\n     in\n \n-    let push_fn_ctx_of_ty_fn (ty_fn:Ast.ty_fn) : unit =\n+    let create_fn_ctx_of_ty_fn (ty_fn:Ast.ty_fn) : fn_ctx =\n       let (ty_sig, ty_fn_aux) = ty_fn in\n       let ret_ty = ty_sig.Ast.sig_output_slot.Ast.slot_ty in\n       let is_iter = ty_fn_aux.Ast.fn_is_iter in\n-      push_fn_ctx (Common.option_get ret_ty) is_iter\n+      create_fn_ctx (Common.option_get ret_ty) is_iter\n     in\n \n-    let finish_function (item_id:Common.node_id) =\n-      let fn_ctx = Stack.pop fn_ctx_stack in\n+    let finish_function (fn_ctx:fn_ctx) (item_id:Common.node_id option) =\n       if not fn_ctx.fnctx_just_saw_ret &&\n           fn_ctx.fnctx_return_type <> Ast.TY_nil &&\n           not fn_ctx.fnctx_is_iter then\n-        Common.err (Some item_id) \"this function must return a value\"\n+        Common.err item_id \"this function must return a value\";\n+\n+      let check_for_slot_types_in_block block_id =\n+        let check_for_slot_type slot_key defn_id =\n+          match Hashtbl.find cx.Semant.ctxt_all_defns defn_id with\n+              Semant.DEFN_slot { Ast.slot_ty = None; Ast.slot_mode = _ } ->\n+                let stmt_id = Hashtbl.find fn_ctx.fnctx_slot_decls slot_key in\n+                Common.err\n+                  (Some stmt_id)\n+                  \"no type could be inferred for this slot\"\n+            | _ -> ()\n+        in\n+        let block_slots = Hashtbl.find cx.Semant.ctxt_block_slots block_id in\n+        Hashtbl.iter check_for_slot_type block_slots\n+      in\n+      Stack.iter check_for_slot_types_in_block fn_ctx.fnctx_blocks\n     in\n \n     let check_fn_ty_validity item_id (ty_sig, _) =\n@@ -1328,14 +1349,16 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n     let visit_mod_item_pre _ _ item =\n       let { Common.node = item; Common.id = item_id } = item in\n       match item.Ast.decl_item with\n-          Ast.MOD_ITEM_fn _ when\n+          Ast.MOD_ITEM_fn fn when\n               not (Hashtbl.mem cx.Semant.ctxt_required_items item_id) ->\n             let fn_ty = Hashtbl.find cx.Semant.ctxt_all_item_types item_id in\n             begin\n               match fn_ty with\n                   Ast.TY_fn ty_fn ->\n                     check_fn_ty_validity item_id ty_fn;\n-                    push_fn_ctx_of_ty_fn ty_fn\n+                    let fn_ctx = create_fn_ctx_of_ty_fn ty_fn in\n+                    check_block cx fn_ctx fn.Ast.fn_body;\n+                    finish_function fn_ctx (Some item_id)\n                 | _ ->\n                   Common.bug ()\n                     \"Type.visit_mod_item_pre: fn item didn't have a fn type\"\n@@ -1346,10 +1369,7 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n       let item_id = item.Common.id in\n       verify_main item_id;\n       match item.Common.node.Ast.decl_item with\n-          Ast.MOD_ITEM_fn _ when\n-              not (Hashtbl.mem cx.Semant.ctxt_required_items item_id) ->\n-            finish_function item_id\n-        | Ast.MOD_ITEM_tag (_, id, n) -> populate_tag_graph_node cx id n\n+          Ast.MOD_ITEM_tag (_, id, n) -> populate_tag_graph_node cx id n\n         | _ -> ()\n     in\n \n@@ -1366,33 +1386,21 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n                 match tsig.Ast.sig_output_slot with\n                     { Ast.slot_ty = Some (Ast.TY_obj (_, methods));\n                       Ast.slot_mode = _ } ->\n-                      push_fn_ctx_of_ty_fn (Hashtbl.find methods ident)\n+                      let fn_ty = Hashtbl.find methods ident in\n+                      let fn_ctx = create_fn_ctx_of_ty_fn fn_ty in\n+                      let obj_fns = obj.Common.node.Ast.obj_fns in\n+                      let fn = Hashtbl.find obj_fns ident in\n+                      check_block cx fn_ctx fn.Common.node.Ast.fn_body;\n+                      finish_function fn_ctx (Some fn.Common.id)\n                   | _ -> bad()\n               end\n           | _ -> bad()\n     in\n-    let visit_obj_fn_post _ _ item = finish_function (item.Common.id) in\n-\n-    let visit_obj_drop_pre _ _ = push_fn_ctx Ast.TY_nil false in\n-    let visit_obj_drop_post _ _ = ignore (Stack.pop fn_ctx_stack) in\n \n-    let visit_stmt_pre (stmt:Ast.stmt) : unit =\n-      try\n-        iflog cx\n-          begin\n-            fun _ ->\n-              log cx \"\";\n-              log cx \"typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n-              log cx \"\";\n-          end;\n-        check_stmt cx (Stack.top fn_ctx_stack) stmt;\n-        iflog cx\n-          begin\n-            fun _ -> \n-              log cx \"finished typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n-          end;\n-      with Common.Semant_err (None, msg) ->\n-        raise (Common.Semant_err ((Some stmt.Common.id), msg))\n+    let visit_obj_drop_pre _ block =\n+      let fn_ctx = create_fn_ctx Ast.TY_nil false in\n+      check_block cx fn_ctx block;\n+      finish_function fn_ctx None\n     in\n \n     let visit_crate_pre _ : unit = create_tag_graph_nodes cx in\n@@ -1411,13 +1419,10 @@ let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n \n     {\n       inner with\n-        Walk.visit_stmt_pre = visit_stmt_pre;\n         Walk.visit_mod_item_pre = visit_mod_item_pre;\n         Walk.visit_mod_item_post = visit_mod_item_post;\n         Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n-        Walk.visit_obj_fn_post = visit_obj_fn_post;\n         Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n-        Walk.visit_obj_drop_post = visit_obj_drop_post;\n         Walk.visit_crate_pre = visit_crate_pre;\n         Walk.visit_crate_post = visit_crate_post\n     }"}, {"sha": "79b5fa242b3c1c9e4fcda55cf636ca1dc6bb68a8", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -55,6 +55,7 @@ fn to_str(mutable uint n, uint radix) -> str\n             case (14u) { ret 'e'; }\n             case (15u) { ret 'f'; }\n         }\n+        fail;\n     }\n \n     if (n == 0u) { ret \"0\"; }"}, {"sha": "1602345703d5784a3464733a93418d323128bb30", "filename": "src/lib/deque.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -53,6 +53,7 @@ fn create[T]() -> t[T] {\n             case (option.some[T](?t)) { ret t; }\n             case (_) { fail; }\n         }\n+        fail;   // FIXME: remove me when exhaustiveness checking works\n     }\n \n     obj deque[T](mutable uint nelts,"}, {"sha": "c4661940a5fe619b5d450341f1ac6518de471b02", "filename": "src/lib/list.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -24,6 +24,8 @@ fn foldl[T,U](&list[T] ls, &U u, fn(&T t, U u) -> U f) -> U {\n       ret u;\n     }\n   }\n+\n+  fail; // TODO: remove me when exhaustiveness checking works\n }\n \n fn find[T,U](&list[T] ls,\n@@ -45,6 +47,8 @@ fn find[T,U](&list[T] ls,\n         ret none[U];\n     }\n   }\n+\n+  fail; // TODO: remove me when exhaustiveness checking works\n }\n \n fn length[T](&list[T] ls) -> uint {"}, {"sha": "7f760b6596779eb442c5c54cb19b8a5f0ed68551", "filename": "src/lib/map.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -176,13 +176,15 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n                     case (option.some[V](_)) { ret true; }\n                     case (_) { ret false; }\n                 }\n+                fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n             fn get(&K key) -> V {\n                 alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n                     case (option.some[V](?val)) { ret val; }\n                     case (_) { fail; }\n                 }\n+                fail;   // FIXME: remove me when exhaustiveness checking works\n             }\n \n             fn find(&K key) -> option.t[V] {"}, {"sha": "25f82b52a0e73da25afd0db6e0fc19b687c5e9b5", "filename": "src/lib/option.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ff12c435aeb6181ee2678a526b6f6ea3831938/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=77ff12c435aeb6181ee2678a526b6f6ea3831938", "patch": "@@ -16,6 +16,7 @@ fn get[T](&t[T] opt) -> T {\n             fail;\n         }\n     }\n+    fail;   // FIXME: remove me when exhaustiveness checking works\n }\n \n fn map[T, U](&operator[T, U] f, &t[T] opt) -> t[U] {\n@@ -27,6 +28,7 @@ fn map[T, U](&operator[T, U] f, &t[T] opt) -> t[U] {\n             ret none[U];\n         }\n     }\n+    fail;   // FIXME: remove me when exhaustiveness checking works\n }\n \n // Local Variables:"}]}