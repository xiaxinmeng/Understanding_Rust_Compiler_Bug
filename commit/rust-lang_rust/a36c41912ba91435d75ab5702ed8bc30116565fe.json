{"sha": "a36c41912ba91435d75ab5702ed8bc30116565fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNmM0MTkxMmJhOTE0MzVkNzVhYjU3MDJlZDhiYzMwMTE2NTY1ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-06T10:07:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-06T10:07:00Z"}, "message": "Auto merge of #33086 - cardoe:non-blocking-rand-read, r=alexcrichton\n\nrand: don't block before random pool is initialized\n\nIf we attempt a read with getrandom() on Linux the syscall can block\nbefore the random pool is initialized unless the GRND_NONBLOCK flag is\npassed. This flag causes getrandom() to instead return EAGAIN while the\npool is uninitialized. To avoid downstream users of crate or std\nfunctionality that have no ability to avoid this blocking behavior this\nchange causes Rust to read bytes from /dev/urandom while getrandom()\nwould block and once getrandom() is available to use that. Fixes #32953.\n\nSigned-off-by: Doug Goldstein <cardoe@cardoe.com>", "tree": {"sha": "21f1a06a4801fefe286ff62d41ffcd27129d5061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21f1a06a4801fefe286ff62d41ffcd27129d5061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a36c41912ba91435d75ab5702ed8bc30116565fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a36c41912ba91435d75ab5702ed8bc30116565fe", "html_url": "https://github.com/rust-lang/rust/commit/a36c41912ba91435d75ab5702ed8bc30116565fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a36c41912ba91435d75ab5702ed8bc30116565fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6301e22e157ba676b0b2477f6670ab8f954767a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6301e22e157ba676b0b2477f6670ab8f954767a8", "html_url": "https://github.com/rust-lang/rust/commit/6301e22e157ba676b0b2477f6670ab8f954767a8"}, {"sha": "61cbd07dec2d9670f170bed44f1815ea29a8a214", "url": "https://api.github.com/repos/rust-lang/rust/commits/61cbd07dec2d9670f170bed44f1815ea29a8a214", "html_url": "https://github.com/rust-lang/rust/commit/61cbd07dec2d9670f170bed44f1815ea29a8a214"}], "stats": {"total": 23, "additions": 20, "deletions": 3}, "files": [{"sha": "9c68878574148c961b9989bb6bfa460938528682", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a36c41912ba91435d75ab5702ed8bc30116565fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36c41912ba91435d75ab5702ed8bc30116565fe/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=a36c41912ba91435d75ab5702ed8bc30116565fe", "patch": "@@ -202,8 +202,10 @@ fn test_resize_policy() {\n /// The hashes are all keyed by the thread-local random number generator\n /// on creation by default. This means that the ordering of the keys is\n /// randomized, but makes the tables more resistant to\n-/// denial-of-service attacks (Hash DoS). This behavior can be\n-/// overridden with one of the constructors.\n+/// denial-of-service attacks (Hash DoS). No guarantees are made to the\n+/// quality of the random data. The implementation uses the best available\n+/// random data from your platform at the time of creation. This behavior\n+/// can be overridden with one of the constructors.\n ///\n /// It is required that the keys implement the `Eq` and `Hash` traits, although\n /// this can frequently be achieved by using `#[derive(PartialEq, Eq, Hash)]`."}, {"sha": "25a7a3ce50dc431a7d22c5cfd215d0c25de29f82", "filename": "src/libstd/sys/unix/rand.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a36c41912ba91435d75ab5702ed8bc30116565fe/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a36c41912ba91435d75ab5702ed8bc30116565fe/src%2Flibstd%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frand.rs?ref=a36c41912ba91435d75ab5702ed8bc30116565fe", "patch": "@@ -41,8 +41,10 @@ mod imp {\n         #[cfg(target_arch = \"aarch64\")]\n         const NR_GETRANDOM: libc::c_long = 278;\n \n+        const GRND_NONBLOCK: libc::c_uint = 0x0001;\n+\n         unsafe {\n-            libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), 0)\n+            libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)\n         }\n     }\n \n@@ -63,6 +65,19 @@ mod imp {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {\n                     continue;\n+                } else if err == libc::EAGAIN {\n+                    // if getrandom() returns EAGAIN it would have blocked\n+                    // because the non-blocking pool (urandom) has not\n+                    // initialized in the kernel yet due to a lack of entropy\n+                    // the fallback we do here is to avoid blocking applications\n+                    // which could depend on this call without ever knowing\n+                    // they do and don't have a work around. The PRNG of\n+                    // /dev/urandom will still be used but not over a completely\n+                    // full entropy pool\n+                    let reader = File::open(\"/dev/urandom\").expect(\"Unable to open /dev/urandom\");\n+                    let mut reader_rng = ReaderRng::new(reader);\n+                    reader_rng.fill_bytes(& mut v[read..]);\n+                    read += v.len() as usize;\n                 } else {\n                     panic!(\"unexpected getrandom error: {}\", err);\n                 }"}]}