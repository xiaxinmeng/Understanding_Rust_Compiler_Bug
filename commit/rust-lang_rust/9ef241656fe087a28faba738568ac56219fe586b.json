{"sha": "9ef241656fe087a28faba738568ac56219fe586b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZjI0MTY1NmZlMDg3YTI4ZmFiYTczODU2OGFjNTYyMTlmZTU4NmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-28T20:42:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-28T22:48:49Z"}, "message": "Update docs for region inference to reflect current state better", "tree": {"sha": "d17d5e62e1fa13b71f8cc04fefc458078f56807a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d17d5e62e1fa13b71f8cc04fefc458078f56807a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ef241656fe087a28faba738568ac56219fe586b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ef241656fe087a28faba738568ac56219fe586b", "html_url": "https://github.com/rust-lang/rust/commit/9ef241656fe087a28faba738568ac56219fe586b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ef241656fe087a28faba738568ac56219fe586b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c81ce8249ccac031e5ab9848742ea9c226cb6e5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c81ce8249ccac031e5ab9848742ea9c226cb6e5d", "html_url": "https://github.com/rust-lang/rust/commit/c81ce8249ccac031e5ab9848742ea9c226cb6e5d"}], "stats": {"total": 92, "additions": 46, "deletions": 46}, "files": [{"sha": "80da861139b42fd9acc50f686746219a5f091c4a", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9ef241656fe087a28faba738568ac56219fe586b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ef241656fe087a28faba738568ac56219fe586b/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=9ef241656fe087a28faba738568ac56219fe586b", "patch": "@@ -2,13 +2,12 @@ Region inference\n \n # Terminology\n \n-Note that we use the terms region and lifetime interchangeably,\n-though the term `lifetime` is preferred.\n+Note that we use the terms region and lifetime interchangeably.\n \n # Introduction\n \n Region inference uses a somewhat more involved algorithm than type\n-inference.  It is not the most efficient thing ever written though it\n+inference. It is not the most efficient thing ever written though it\n seems to work well enough in practice (famous last words).  The reason\n that we use a different algorithm is because, unlike with types, it is\n impractical to hand-annotate with regions (in some cases, there aren't\n@@ -25,22 +24,42 @@ once.\n \n The constraints are always of one of three possible forms:\n \n-- ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n-  must be a subregion of R_j\n-- ConstrainRegSubVar(R, R_i) states that the concrete region R\n-  (which must not be a variable) must be a subregion of the variable R_i\n-- ConstrainVarSubReg(R_i, R) is the inverse\n+- `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be\n+  a subregion of Rj\n+- `ConstrainRegSubVar(R, Ri)` states that the concrete region R (which\n+  must not be a variable) must be a subregion of the variable Ri\n+- `ConstrainVarSubReg(Ri, R)` states the variable Ri shoudl be less\n+  than the concrete region R. This is kind of deprecated and ought to\n+  be replaced with a verify (they essentially play the same role).\n+\n+In addition to constraints, we also gather up a set of \"verifys\"\n+(what, you don't think Verify is a noun? Get used to it my\n+friend!). These represent relations that must hold but which don't\n+influence inference proper. These take the form of:\n+\n+- `VerifyRegSubReg(Ri, Rj)` indicates that Ri <= Rj must hold,\n+  where Rj is not an inference variable (and Ri may or may not contain\n+  one). This doesn't influence inference because we will already have\n+  inferred Ri to be as small as possible, so then we just test whether\n+  that result was less than Rj or not.\n+- `VerifyGenericBound(R, Vb)` is a more complex expression which tests\n+  that the region R must satisfy the bound `Vb`. The bounds themselves\n+  may have structure like \"must outlive one of the following regions\"\n+  or \"must outlive ALL of the following regions. These bounds arise\n+  from constraints like `T: 'a` -- if we know that `T: 'b` and `T: 'c`\n+  (say, from where clauses), then we can conclude that `T: 'a` if `'b:\n+  'a` *or* `'c: 'a`.\n \n # Building up the constraints\n \n Variables and constraints are created using the following methods:\n \n - `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(R_i, R_j)` states that R_i is a subregion of R_j\n-- `lub_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the smallest region that is greater than both R_i and R_j\n-- `glb_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the greatest region that is smaller than both R_i and R_j\n+- `make_subregion(Ri, Rj)` states that Ri is a subregion of Rj\n+- `lub_regions(Ri, Rj) -> Rk` returns a region Rk which is\n+  the smallest region that is greater than both Ri and Rj\n+- `glb_regions(Ri, Rj) -> Rk` returns a region Rk which is\n+  the greatest region that is smaller than both Ri and Rj\n \n The actual region resolution algorithm is not entirely\n obvious, though it is also not overly complex.\n@@ -54,14 +73,6 @@ Alternatively, you can call `commit()` which ends all snapshots.\n Snapshots can be recursive---so you can start a snapshot when another\n is in progress, but only the root snapshot can \"commit\".\n \n-# Resolving constraints\n-\n-The constraint resolution algorithm is not super complex but also not\n-entirely obvious.  Here I describe the problem somewhat abstractly,\n-then describe how the current code works.  There may be other, smarter\n-ways of doing this with which I am unfamiliar and can't be bothered to\n-research at the moment. - NDM\n-\n ## The problem\n \n Basically our input is a directed graph where nodes can be divided\n@@ -83,31 +94,20 @@ Before resolution begins, we build up the constraints in a hashmap\n that maps `Constraint` keys to spans.  During resolution, we construct\n the actual `Graph` structure that we describe here.\n \n-## Our current algorithm\n-\n-We divide region variables into two groups: Expanding and Contracting.\n-Expanding region variables are those that have a concrete region\n-predecessor (direct or indirect).  Contracting region variables are\n-all others.\n-\n-We first resolve the values of Expanding region variables and then\n-process Contracting ones.  We currently use an iterative, fixed-point\n-procedure (but read on, I believe this could be replaced with a linear\n-walk).  Basically we iterate over the edges in the graph, ensuring\n-that, if the source of the edge has a value, then this value is a\n-subregion of the target value.  If the target does not yet have a\n-value, it takes the value from the source.  If the target already had\n-a value, then the resulting value is Least Upper Bound of the old and\n-new values. When we are done, each Expanding node will have the\n-smallest region that it could possibly have and still satisfy the\n-constraints.\n-\n-We next process the Contracting nodes.  Here we again iterate over the\n-edges, only this time we move values from target to source (if the\n-source is a Contracting node).  For each contracting node, we compute\n-its value as the GLB of all its successors.  Basically contracting\n-nodes ensure that there is overlap between their successors; we will\n-ultimately infer the largest overlap possible.\n+## Computing the values for region variables\n+\n+The algorithm is a simple dataflow algorithm. Each region variable\n+begins as empty. We iterate over the constraints, and for each constraint\n+we grow the relevant region variable to be as big as it must be to meet all the\n+constraints. This means the region variables can grow to be `'static` if\n+necessary.\n+\n+## Verification\n+\n+After all constraints are fully propoagated, we do a \"verification\"\n+step where we walk over the verify bounds and check that they are\n+satisfied. These bounds represent the \"maximal\" values that a region\n+variable can take on, basically.\n \n # The Region Hierarchy\n "}]}