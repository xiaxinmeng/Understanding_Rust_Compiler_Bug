{"sha": "467a040509cd6732de48907e025f83b57b5701b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2EwNDA1MDljZDY3MzJkZTQ4OTA3ZTAyNWY4M2I1N2I1NzAxYjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-20T08:26:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-20T08:26:15Z"}, "message": "Merge #3623\n\n3623: 'Fill match arms' should work with existing match arms r=matklad a=slyngbaek\n\nAddresses #3039\r\n\r\nThis essentially adds missing match arms. The algorithm for this\r\ncan get complicated rather quickly so bail in certain conditions\r\nand rely on a PlaceholderPat.\r\n\r\nThe algorighm works as such:\r\n- Iterate through the Enum Def Variants\r\n- Attempt to see if the variant already exists as a match arm\r\n- If yes, skip the enum variant. If no, include it.\r\n- If it becomes complicated, rather than exhaustively deal with every\r\n  branch, mark it as a \"partial match\" and simply include the\r\n  placeholder.\r\n\r\n  Conditions for \"complication\":\r\n  - The match arm contains a match guard\r\n  - Any kind of nested destrucuring\r\n\r\nOrder the resulting merged match branches as such:\r\n1. Provided match arms\r\n2. Missing enum variant branch arms\r\n3. End with Placeholder if required\r\n\r\n- Add extra tests\n\nCo-authored-by: Steffen Lyngbaek <steffenlyngbaek@gmail.com>", "tree": {"sha": "217fec908db7dbcd39e5b452d43257a9f2977c53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/217fec908db7dbcd39e5b452d43257a9f2977c53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467a040509cd6732de48907e025f83b57b5701b9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJedH4nCRBK7hj4Ov3rIwAAdHIIAKyQ2by8xDkB0RdU1lX0sJaW\n5ypIrjCUd1dkXof6JgA0+BujiL/nApfAzszwYZFHYKqLn8eqoBZ6tRWCJEq1NJQJ\npeqnsGB34rVGNIy9DKCiVg1OgKPZsD7JG2mrH//4EO2P6OqFbbBF+YHQZdm6sT+/\nuhIcCxd6I5UnnEnwDY8hbnvR55UBinDrKy+Wef5ZE/jbVGxbW282mW6fdDz5GB/c\nQhjo7RER1qsMGnIIawXg1KvxYWRAUvZ1Lk+tU9DCPTa3hOLVCAj9LbGzmjbiwL/L\n95Ceslb1XMPuyUP+Bbt5U8sp+Q8i3BU8L75evudT5R4k1hiR6JZA0+xUKmwunvs=\n=rdKR\n-----END PGP SIGNATURE-----\n", "payload": "tree 217fec908db7dbcd39e5b452d43257a9f2977c53\nparent e0952899aee50b813379ca8e6dcab49a895ff0a0\nparent b5ba9c3e3ae25b6add36c670de75967a7b38bb53\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1584692775 +0000\ncommitter GitHub <noreply@github.com> 1584692775 +0000\n\nMerge #3623\n\n3623: 'Fill match arms' should work with existing match arms r=matklad a=slyngbaek\n\nAddresses #3039\r\n\r\nThis essentially adds missing match arms. The algorithm for this\r\ncan get complicated rather quickly so bail in certain conditions\r\nand rely on a PlaceholderPat.\r\n\r\nThe algorighm works as such:\r\n- Iterate through the Enum Def Variants\r\n- Attempt to see if the variant already exists as a match arm\r\n- If yes, skip the enum variant. If no, include it.\r\n- If it becomes complicated, rather than exhaustively deal with every\r\n  branch, mark it as a \"partial match\" and simply include the\r\n  placeholder.\r\n\r\n  Conditions for \"complication\":\r\n  - The match arm contains a match guard\r\n  - Any kind of nested destrucuring\r\n\r\nOrder the resulting merged match branches as such:\r\n1. Provided match arms\r\n2. Missing enum variant branch arms\r\n3. End with Placeholder if required\r\n\r\n- Add extra tests\n\nCo-authored-by: Steffen Lyngbaek <steffenlyngbaek@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467a040509cd6732de48907e025f83b57b5701b9", "html_url": "https://github.com/rust-lang/rust/commit/467a040509cd6732de48907e025f83b57b5701b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467a040509cd6732de48907e025f83b57b5701b9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0952899aee50b813379ca8e6dcab49a895ff0a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0952899aee50b813379ca8e6dcab49a895ff0a0", "html_url": "https://github.com/rust-lang/rust/commit/e0952899aee50b813379ca8e6dcab49a895ff0a0"}, {"sha": "b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ba9c3e3ae25b6add36c670de75967a7b38bb53", "html_url": "https://github.com/rust-lang/rust/commit/b5ba9c3e3ae25b6add36c670de75967a7b38bb53"}], "stats": {"total": 202, "additions": 177, "deletions": 25}, "files": [{"sha": "fbd6a3ec36c02ba82e3934c1fe57b34193bd15e8", "filename": "crates/ra_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 177, "deletions": 25, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/467a040509cd6732de48907e025f83b57b5701b9/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467a040509cd6732de48907e025f83b57b5701b9/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=467a040509cd6732de48907e025f83b57b5701b9", "patch": "@@ -4,9 +4,11 @@ use std::iter;\n \n use hir::{Adt, HasSource, Semantics};\n use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n \n use crate::{Assist, AssistCtx, AssistId};\n+use ra_syntax::ast::{self, edit::IndentLevel, make, AstNode, NameOwner};\n+\n+use ast::{MatchArm, Pat};\n \n // Assist: fill_match_arms\n //\n@@ -36,16 +38,6 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n     let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n     let match_arm_list = match_expr.match_arm_list()?;\n \n-    // We already have some match arms, so we don't provide any assists.\n-    // Unless if there is only one trivial match arm possibly created\n-    // by match postfix complete. Trivial match arm is the catch all arm.\n-    let mut existing_arms = match_arm_list.arms();\n-    if let Some(arm) = existing_arms.next() {\n-        if !is_trivial(&arm) || existing_arms.next().is_some() {\n-            return None;\n-        }\n-    };\n-\n     let expr = match_expr.expr()?;\n     let enum_def = resolve_enum_def(&ctx.sema, &expr)?;\n     let module = ctx.sema.scope(expr.syntax()).module()?;\n@@ -55,30 +47,54 @@ pub(crate) fn fill_match_arms(ctx: AssistCtx) -> Option<Assist> {\n         return None;\n     }\n \n+    let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n+    if arms.len() == 1 {\n+        if let Some(Pat::PlaceholderPat(..)) = arms[0].pat() {\n+            arms.clear();\n+        }\n+    }\n+\n     let db = ctx.db;\n+    let missing_arms: Vec<MatchArm> = variants\n+        .into_iter()\n+        .filter_map(|variant| build_pat(db, module, variant))\n+        .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+        .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()))\n+        .collect();\n+\n+    if missing_arms.is_empty() {\n+        return None;\n+    }\n \n     ctx.add_assist(AssistId(\"fill_match_arms\"), \"Fill match arms\", |edit| {\n-        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n+        arms.extend(missing_arms);\n \n-        let new_arm_list = {\n-            let arms = variants\n-                .into_iter()\n-                .filter_map(|variant| build_pat(db, module, variant))\n-                .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()));\n-            indent_level.increase_indent(make::match_arm_list(arms))\n-        };\n+        let indent_level = IndentLevel::from_node(match_arm_list.syntax());\n+        let new_arm_list = indent_level.increase_indent(make::match_arm_list(arms));\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n         edit.replace_ast(match_arm_list, new_arm_list);\n     })\n }\n \n-fn is_trivial(arm: &ast::MatchArm) -> bool {\n-    match arm.pat() {\n-        Some(ast::Pat::PlaceholderPat(..)) => true,\n-        _ => false,\n-    }\n+fn is_variant_missing(existing_arms: &mut Vec<MatchArm>, var: &Pat) -> bool {\n+    existing_arms.iter().filter_map(|arm| arm.pat()).all(|pat| {\n+        // Special casee OrPat as separate top-level pats\n+        let top_level_pats: Vec<Pat> = match pat {\n+            Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n+            _ => vec![pat],\n+        };\n+\n+        !top_level_pats.iter().any(|pat| does_pat_match_variant(pat, var))\n+    })\n+}\n+\n+fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n+    let pat_head = pat.syntax().first_child().map(|node| node.text());\n+    let var_head = var.syntax().first_child().map(|node| node.text());\n+\n+    pat_head == var_head\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n@@ -110,10 +126,146 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> O\n \n #[cfg(test)]\n mod tests {\n-    use crate::helpers::{check_assist, check_assist_target};\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n \n     use super::fill_match_arms;\n \n+    #[test]\n+    fn all_match_arms_provided() {\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::As,\n+                    A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill_record_tuple() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs{x:i32, y:Option<i32>},\n+                Cs(i32, Option<i32>),\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Bs{x,y:Some(_)} => (),\n+                    A::Cs(_, Some(_)) => (),\n+                    A::As => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill_or_pat() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Cs(_) | A::Bs => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs(Option<i32>),\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Cs(_) | A::Bs => (),\n+                    A::As => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn partial_fill() {\n+        check_assist(\n+            fill_match_arms,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs,\n+                Ds(String),\n+                Es(B),\n+            }\n+            enum B {\n+                Xs,\n+                Ys,\n+            }\n+            fn main() {\n+                match A::As<|> {\n+                    A::Bs if 0 < 1 => (),\n+                    A::Ds(_value) => (),\n+                    A::Es(B::Xs) => (),\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            enum A {\n+                As,\n+                Bs,\n+                Cs,\n+                Ds(String),\n+                Es(B),\n+            }\n+            enum B {\n+                Xs,\n+                Ys,\n+            }\n+            fn main() {\n+                match <|>A::As {\n+                    A::Bs if 0 < 1 => (),\n+                    A::Ds(_value) => (),\n+                    A::Es(B::Xs) => (),\n+                    A::As => (),\n+                    A::Cs => (),\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn fill_match_arms_empty_body() {\n         check_assist("}]}