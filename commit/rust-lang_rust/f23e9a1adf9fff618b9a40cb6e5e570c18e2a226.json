{"sha": "f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyM2U5YTFhZGY5ZmZmNjE4YjlhNDBjYjZlNWU1NzBjMThlMmEyMjY=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-10-02T20:30:36Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-10-04T11:54:02Z"}, "message": "Add regression test for issue #72470\n\nThis was fixed with the upgrade to LLVM 11 in #73526.\nIt seems extremely unlikey that this exact issue will ever reoccur,\nsince slight modifications to the code caused the crash to stop\nhappening. However, it can't hurt to have a test for it.", "tree": {"sha": "585e86d410ead35fda8f488b8c0604fd1626b82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/585e86d410ead35fda8f488b8c0604fd1626b82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl95t9oACgkQtAh+UQ6Y\nsWRGug/+OT+lTm9WRWQEGQ8yYrr5kQ+1M6bN6Mpz4vsAO3cgWRkYmQUXyW9BHgTm\nyi/YuP2QUbYnfvToMwrC85O37jvefcH78c+rXlyrABcKoPu7gLlQtuS/UtGTBsSn\ntZude+SuVdT/KMbc5NFAFCDbTCIwnFUn5mO8bwI12OkeesTuuviCtj6V2W9Efp0V\nTnwwbw3Ez4HfIJV2zyTaNKfTJfhT5PiDxIhZC7F1Cjc1p5rDV5mlQtPCpDAFUYNP\nftBhfO2hxT8HnSAvorKo4gD9Pr3EaKNeoS30ne3/CgecGeZPiYhlvC5k79AMI8BA\ncGF4iqPRCiETbwRuo01YnpCxxtrI4OkNyiCk30RW4oc+n4kUyLZKzgnd2HtGhsVf\n4KWu2rQae+l3pfjmlgjHCZiL1wLlC4fJWH5rIExGatASv/HnJqdtPOOq2iBvrrSg\n9ED6weO9vMpDgvXxpsEbWwKQdfR5RggofzOXEHMlvI4KHkvMPaNNVctvZfcLfyIh\nO+KchfmmH4mgLpfh1CWfWqNkSfkRhXLKm5ugmmFvpMmJZfyLUpjFl4T9HUo1sOR3\nUQCxlGagPDb8GwujH4hCelG2RwKAASlcKSEoPzW/5IXNp6WGp3gneCU0hAxBProi\n1Ssukl31pfIMRzKd14rHCnzZ2gx75iEzNpdqVdD+gno5uflaChI=\n=Lqzr\n-----END PGP SIGNATURE-----", "payload": "tree 585e86d410ead35fda8f488b8c0604fd1626b82a\nparent 4c83eec00883e10e7b859d039dcc0e937a0706d5\nauthor Aaron Hill <aa1ronham@gmail.com> 1601670636 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1601812442 -0400\n\nAdd regression test for issue #72470\n\nThis was fixed with the upgrade to LLVM 11 in #73526.\nIt seems extremely unlikey that this exact issue will ever reoccur,\nsince slight modifications to the code caused the crash to stop\nhappening. However, it can't hurt to have a test for it.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "html_url": "https://github.com/rust-lang/rust/commit/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c83eec00883e10e7b859d039dcc0e937a0706d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c83eec00883e10e7b859d039dcc0e937a0706d5", "html_url": "https://github.com/rust-lang/rust/commit/4c83eec00883e10e7b859d039dcc0e937a0706d5"}], "stats": {"total": 241, "additions": 241, "deletions": 0}, "files": [{"sha": "8383eba89124a50b934cb3d3e0556e5b8461c96d", "filename": "src/test/ui/auxiliary/issue-72470-lib.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226/src%2Ftest%2Fui%2Fauxiliary%2Fissue-72470-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226/src%2Ftest%2Fui%2Fauxiliary%2Fissue-72470-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fissue-72470-lib.rs?ref=f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "patch": "@@ -0,0 +1,175 @@\n+// compile-flags: -C opt-level=3\n+// edition:2018\n+\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::Arc;\n+use std::task::Poll::{Pending, Ready};\n+use std::task::Waker;\n+use std::task::{Context, Poll};\n+use std::{\n+    ptr,\n+    task::{RawWaker, RawWakerVTable},\n+};\n+\n+/// Future for the [`poll_fn`] function.\n+pub struct PollFn<F> {\n+    f: F,\n+}\n+\n+impl<F> Unpin for PollFn<F> {}\n+\n+/// Creates a new future wrapping around a function returning [`Poll`].\n+pub fn poll_fn<T, F>(f: F) -> PollFn<F>\n+where\n+    F: FnMut(&mut Context<'_>) -> Poll<T>,\n+{\n+    PollFn { f }\n+}\n+\n+impl<T, F> Future for PollFn<F>\n+where\n+    F: FnMut(&mut Context<'_>) -> Poll<T>,\n+{\n+    type Output = T;\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<T> {\n+        (&mut self.f)(cx)\n+    }\n+}\n+pub fn run<F: Future>(future: F) -> F::Output {\n+    BasicScheduler.block_on(future)\n+}\n+\n+pub(crate) struct BasicScheduler;\n+\n+impl BasicScheduler {\n+    pub(crate) fn block_on<F>(&mut self, mut future: F) -> F::Output\n+    where\n+        F: Future,\n+    {\n+        let waker = unsafe { Waker::from_raw(raw_waker()) };\n+        let mut cx = std::task::Context::from_waker(&waker);\n+\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+\n+        loop {\n+            if let Ready(v) = future.as_mut().poll(&mut cx) {\n+                return v;\n+            }\n+        }\n+    }\n+}\n+\n+// ===== impl Spawner =====\n+\n+fn raw_waker() -> RawWaker {\n+    RawWaker::new(ptr::null(), waker_vtable())\n+}\n+\n+fn waker_vtable() -> &'static RawWakerVTable {\n+    &RawWakerVTable::new(\n+        clone_arc_raw,\n+        wake_arc_raw,\n+        wake_by_ref_arc_raw,\n+        drop_arc_raw,\n+    )\n+}\n+\n+unsafe fn clone_arc_raw(_: *const ()) -> RawWaker {\n+    raw_waker()\n+}\n+\n+unsafe fn wake_arc_raw(_: *const ()) {}\n+\n+unsafe fn wake_by_ref_arc_raw(_: *const ()) {}\n+\n+unsafe fn drop_arc_raw(_: *const ()) {}\n+\n+struct AtomicWaker {}\n+\n+impl AtomicWaker {\n+    /// Create an `AtomicWaker`\n+    fn new() -> AtomicWaker {\n+        AtomicWaker {}\n+    }\n+\n+    fn register_by_ref(&self, _waker: &Waker) {}\n+}\n+\n+#[allow(dead_code)]\n+struct Tx<T> {\n+    inner: Arc<Chan<T>>,\n+}\n+\n+struct Rx<T> {\n+    inner: Arc<Chan<T>>,\n+}\n+\n+#[allow(dead_code)]\n+struct Chan<T> {\n+    tx: PhantomData<T>,\n+    semaphore: Sema,\n+    rx_waker: AtomicWaker,\n+    rx_closed: bool,\n+}\n+\n+fn channel<T>() -> (Tx<T>, Rx<T>) {\n+    let chan = Arc::new(Chan {\n+        tx: PhantomData,\n+        semaphore: Sema(AtomicUsize::new(0)),\n+        rx_waker: AtomicWaker::new(),\n+        rx_closed: false,\n+    });\n+\n+    (\n+        Tx {\n+            inner: chan.clone(),\n+        },\n+        Rx { inner: chan },\n+    )\n+}\n+\n+// ===== impl Rx =====\n+\n+impl<T> Rx<T> {\n+    /// Receive the next value\n+    fn recv(&mut self, cx: &mut Context<'_>) -> Poll<Option<T>> {\n+        self.inner.rx_waker.register_by_ref(cx.waker());\n+\n+        if self.inner.rx_closed && self.inner.semaphore.is_idle() {\n+            Ready(None)\n+        } else {\n+            Pending\n+        }\n+    }\n+}\n+\n+struct Sema(AtomicUsize);\n+\n+impl Sema {\n+    fn is_idle(&self) -> bool {\n+        false\n+    }\n+}\n+\n+pub struct UnboundedReceiver<T> {\n+    chan: Rx<T>,\n+}\n+\n+pub fn unbounded_channel<T>() -> UnboundedReceiver<T> {\n+    let (tx, rx) = channel();\n+\n+    drop(tx);\n+    let rx = UnboundedReceiver { chan: rx };\n+\n+    rx\n+}\n+\n+impl<T> UnboundedReceiver<T> {\n+    pub async fn recv(&mut self) -> Option<T> {\n+        poll_fn(|cx| self.chan.recv(cx)).await\n+    }\n+}"}, {"sha": "feea4683dada9e7d4e5b543a1a0b1ad5f5e34f53", "filename": "src/test/ui/issue-72470-llvm-dominate.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226/src%2Ftest%2Fui%2Fissue-72470-llvm-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23e9a1adf9fff618b9a40cb6e5e570c18e2a226/src%2Ftest%2Fui%2Fissue-72470-llvm-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-72470-llvm-dominate.rs?ref=f23e9a1adf9fff618b9a40cb6e5e570c18e2a226", "patch": "@@ -0,0 +1,66 @@\n+// compile-flags: -C opt-level=3\n+// aux-build: issue-72470-lib.rs\n+// edition:2018\n+// check-pass\n+\n+// Regression test for issue #72470, using the minimization\n+// in https://github.com/jonas-schievink/llvm-error\n+\n+extern crate issue_72470_lib;\n+\n+use std::future::Future;\n+use std::pin::Pin;\n+use std::sync::Mutex;\n+use std::task::Poll::{Pending, Ready};\n+\n+#[allow(dead_code)]\n+enum Msg {\n+    A(Vec<()>),\n+    B,\n+}\n+\n+#[allow(dead_code)]\n+enum Out {\n+    _0(Option<Msg>),\n+    Disabled,\n+}\n+\n+#[allow(unused_must_use)]\n+fn main() {\n+    let mut rx = issue_72470_lib::unbounded_channel::<Msg>();\n+    let entity = Mutex::new(());\n+    issue_72470_lib::run(async move {\n+        {\n+            let output = {\n+                let mut fut = rx.recv();\n+                issue_72470_lib::poll_fn(|cx| {\n+                    loop {\n+                        let fut = unsafe { Pin::new_unchecked(&mut fut) };\n+                        let out = match fut.poll(cx) {\n+                            Ready(out) => out,\n+                            Pending => {\n+                                break;\n+                            }\n+                        };\n+                        #[allow(unused_variables)]\n+                        match &out {\n+                            Some(_msg) => {}\n+                            _ => break,\n+                        }\n+                        return Ready(Out::_0(out));\n+                    }\n+                    Ready(Out::_0(None))\n+                })\n+                .await\n+            };\n+            match output {\n+                Out::_0(Some(_msg)) => {\n+                    entity.lock();\n+                }\n+                Out::_0(None) => unreachable!(),\n+                _ => unreachable!(),\n+            }\n+        }\n+        entity.lock();\n+    });\n+}"}]}