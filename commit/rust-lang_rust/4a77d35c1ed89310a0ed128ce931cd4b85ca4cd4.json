{"sha": "4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNzdkMzVjMWVkODkzMTBhMGVkMTI4Y2U5MzFjZDRiODVjYTRjZDQ=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-04-15T23:41:33Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-04-20T00:33:18Z"}, "message": "Remove HIR inlining\n\nFixes #49690", "tree": {"sha": "c9d0f8283478baf25c2e7facb505031181db4787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9d0f8283478baf25c2e7facb505031181db4787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "html_url": "https://github.com/rust-lang/rust/commit/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8830a0304327ba8c983555ac5d42cec0569c31bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8830a0304327ba8c983555ac5d42cec0569c31bb", "html_url": "https://github.com/rust-lang/rust/commit/8830a0304327ba8c983555ac5d42cec0569c31bb"}], "stats": {"total": 448, "additions": 117, "deletions": 331}, "files": [{"sha": "b4f39439d5b4d4d93c4b36bee707a1775650bd6a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -556,7 +556,6 @@ define_dep_nodes!( <'tcx>\n     [input] DefSpan(DefId),\n     [] LookupStability(DefId),\n     [] LookupDeprecationEntry(DefId),\n-    [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n     [] RvaluePromotableMap(DefId),\n     [] ImplParent(DefId),\n@@ -567,6 +566,7 @@ define_dep_nodes!( <'tcx>\n     [] ItemAttrs(DefId),\n     [] TransFnAttrs(DefId),\n     [] FnArgNames(DefId),\n+    [] RenderedConst(DefId),\n     [] DylibDepFormats(CrateNum),\n     [] IsPanicRuntime(CrateNum),\n     [] IsCompilerBuiltins(CrateNum),\n@@ -615,7 +615,6 @@ define_dep_nodes!( <'tcx>\n     [input] GetLangItems,\n     [] DefinedLangItems(CrateNum),\n     [] MissingLangItems(CrateNum),\n-    [] ExternConstBody(DefId),\n     [] VisibleParentMap,\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),"}, {"sha": "9520ed32af9e1a4b7d9c96c88d5e0306db44157e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -30,14 +30,11 @@ use syntax_pos::Span;\n use hir::*;\n use hir::print::Nested;\n use hir::svh::Svh;\n-use util::nodemap::{DefIdMap, FxHashMap};\n+use util::nodemap::FxHashMap;\n \n-use arena::SyncTypedArena;\n use std::io;\n use ty::TyCtxt;\n \n-use rustc_data_structures::sync::Lock;\n-\n pub mod blocks;\n mod collector;\n mod def_collector;\n@@ -219,15 +216,13 @@ impl<'hir> MapEntry<'hir> {\n pub struct Forest {\n     krate: Crate,\n     pub dep_graph: DepGraph,\n-    inlined_bodies: SyncTypedArena<Body>\n }\n \n impl Forest {\n     pub fn new(krate: Crate, dep_graph: &DepGraph) -> Forest {\n         Forest {\n             krate,\n             dep_graph: dep_graph.clone(),\n-            inlined_bodies: SyncTypedArena::new()\n         }\n     }\n \n@@ -264,9 +259,6 @@ pub struct Map<'hir> {\n \n     definitions: &'hir Definitions,\n \n-    /// Bodies inlined from other crates are cached here.\n-    inlined_bodies: Lock<DefIdMap<&'hir Body>>,\n-\n     /// The reverse mapping of `node_to_hir_id`.\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n@@ -923,21 +915,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_inlined_body_untracked(&self, def_id: DefId) -> Option<&'hir Body> {\n-        self.inlined_bodies.borrow().get(&def_id).cloned()\n-    }\n-\n-    pub fn intern_inlined_body(&self, def_id: DefId, body: Body) -> &'hir Body {\n-        let mut inlined_bodies = self.inlined_bodies.borrow_mut();\n-        if let Some(&b) = inlined_bodies.get(&def_id) {\n-            debug_assert_eq!(&body, b);\n-            return b;\n-        }\n-        let body = self.forest.inlined_bodies.alloc(body);\n-        inlined_bodies.insert(def_id, body);\n-        body\n-    }\n-\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -1195,7 +1172,6 @@ pub fn map_crate<'hir>(sess: &::session::Session,\n         map,\n         hir_to_node_id,\n         definitions,\n-        inlined_bodies: Lock::new(DefIdMap()),\n     };\n \n     hir_id_validator::check_crate(&map);"}, {"sha": "96d7cb6b041a83508866c568a7a48572a37ecf64", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -11,8 +11,6 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::middle::cstore in no particular order.\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n-\n use middle;\n \n impl_stable_hash_for!(enum middle::cstore::DepKind {\n@@ -64,29 +62,3 @@ impl_stable_hash_for!(struct middle::cstore::CrateSource {\n     rlib,\n     rmeta\n });\n-\n-impl<HCX> HashStable<HCX> for middle::cstore::ExternBodyNestedBodies {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n-        let middle::cstore::ExternBodyNestedBodies {\n-            nested_bodies: _,\n-            fingerprint,\n-        } = *self;\n-\n-        fingerprint.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, HCX> HashStable<HCX> for middle::cstore::ExternConstBody<'a> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut HCX,\n-                                          hasher: &mut StableHasher<W>) {\n-        let middle::cstore::ExternConstBody {\n-            body: _,\n-            fingerprint,\n-        } = *self;\n-\n-        fingerprint.hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "60e197e614aa6f7e3e98459bb47bbab59d99867f", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -22,19 +22,16 @@\n //! are *mostly* used as a part of that interface, but these should\n //! probably get a better home if someone can find one.\n \n-use hir;\n use hir::def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n-use ich;\n use ty::{self, TyCtxt};\n use session::{Session, CrateDisambiguator};\n use session::search_paths::PathKind;\n \n use std::any::Any;\n-use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax::ext::base::SyntaxExtension;\n@@ -209,26 +206,6 @@ pub trait MetadataLoader {\n                           -> Result<MetadataRef, String>;\n }\n \n-#[derive(Clone)]\n-pub struct ExternConstBody<'tcx> {\n-    pub body: &'tcx hir::Body,\n-\n-    // It would require a lot of infrastructure to enable stable-hashing Bodies\n-    // from other crates, so we hash on export and just store the fingerprint\n-    // with them.\n-    pub fingerprint: ich::Fingerprint,\n-}\n-\n-#[derive(Clone)]\n-pub struct ExternBodyNestedBodies {\n-    pub nested_bodies: Lrc<BTreeMap<hir::BodyId, hir::Body>>,\n-\n-    // It would require a lot of infrastructure to enable stable-hashing Bodies\n-    // from other crates, so we hash on export and just store the fingerprint\n-    // with them.\n-    pub fingerprint: ich::Fingerprint,\n-}\n-\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n ///"}, {"sha": "fea7de955e0bfdc72fa713bd0c94a321010ac785", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -283,12 +283,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::item_body_nested_bodies<'tcx> {\n-    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n-        format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"const checking if rvalue is promotable to static `{}`\","}, {"sha": "0ab9f16dab481064f7b8b6330a2b5be32fb24eb1", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -17,9 +17,8 @@ use hir::svh::Svh;\n use infer::canonical::{self, Canonical};\n use lint;\n use middle::borrowck::BorrowCheckResult;\n-use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n-                     ExternBodyNestedBodies, ForeignModule};\n-use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n+use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary, ForeignModule};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n use middle::privacy::AccessLevels;\n use middle::reachable::ReachableSet;\n use middle::region;\n@@ -254,9 +253,11 @@ define_maps! { <'tcx>\n     [] fn item_attrs: ItemAttrs(DefId) -> Lrc<[ast::Attribute]>,\n     [] fn trans_fn_attrs: trans_fn_attrs(DefId) -> TransFnAttrs,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n+    /// Gets the rendered value of the specified constant or associated constant.\n+    /// Used by rustdoc.\n+    [] fn rendered_const: RenderedConst(DefId) -> String,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n-    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn rvalue_promotable_map: RvaluePromotableMap(DefId) -> Lrc<ItemLocalSet>,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n@@ -376,7 +377,6 @@ define_maps! { <'tcx>\n     [] fn get_lang_items: get_lang_items_node(CrateNum) -> Lrc<LanguageItems>,\n     [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Lrc<Vec<(DefId, usize)>>,\n     [] fn missing_lang_items: MissingLangItems(CrateNum) -> Lrc<Vec<LangItem>>,\n-    [] fn extern_const_body: ExternConstBody(DefId) -> ExternConstBody<'tcx>,\n     [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n         -> Lrc<DefIdMap<DefId>>,\n     [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,"}, {"sha": "8d6c7474a9f94f495569460e2938754f7651caba", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -1048,7 +1048,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::LookupDeprecationEntry => {\n             force!(lookup_deprecation_entry, def_id!());\n         }\n-        DepKind::ItemBodyNestedBodies => { force!(item_body_nested_bodies, def_id!()); }\n         DepKind::ConstIsRvaluePromotableToStatic => {\n             force!(const_is_rvalue_promotable_to_static, def_id!());\n         }\n@@ -1063,6 +1062,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::ItemAttrs => { force!(item_attrs, def_id!()); }\n         DepKind::TransFnAttrs => { force!(trans_fn_attrs, def_id!()); }\n         DepKind::FnArgNames => { force!(fn_arg_names, def_id!()); }\n+        DepKind::RenderedConst => { force!(rendered_const, def_id!()); }\n         DepKind::DylibDepFormats => { force!(dylib_dependency_formats, krate!()); }\n         DepKind::IsPanicRuntime => { force!(is_panic_runtime, krate!()); }\n         DepKind::IsCompilerBuiltins => { force!(is_compiler_builtins, krate!()); }\n@@ -1119,7 +1119,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetLangItems => { force!(get_lang_items, LOCAL_CRATE); }\n         DepKind::DefinedLangItems => { force!(defined_lang_items, krate!()); }\n         DepKind::MissingLangItems => { force!(missing_lang_items, krate!()); }\n-        DepKind::ExternConstBody => { force!(extern_const_body, def_id!()); }\n         DepKind::VisibleParentMap => { force!(visible_parent_map, LOCAL_CRATE); }\n         DepKind::MissingExternCrateItem => {\n             force!(missing_extern_crate_item, krate!());"}, {"sha": "71b15643cbcef3de45140ad0785ff53f402e7be4", "filename": "src/librustc_metadata/astencode.rs", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8830a0304327ba8c983555ac5d42cec0569c31bb/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8830a0304327ba8c983555ac5d42cec0569c31bb/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=8830a0304327ba8c983555ac5d42cec0569c31bb", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-\n-use isolated_encoder::IsolatedEncoder;\n-use schema::*;\n-\n-use rustc::hir;\n-use rustc::ty::{self, TyCtxt};\n-\n-use rustc::ich::Fingerprint;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-pub struct Ast<'tcx> {\n-    pub body: Lazy<hir::Body>,\n-    pub tables: Lazy<ty::TypeckTables<'tcx>>,\n-    pub nested_bodies: LazySeq<hir::Body>,\n-    pub rvalue_promotable_to_static: bool,\n-    pub stable_bodies_hash: Fingerprint,\n-}\n-\n-impl_stable_hash_for!(struct Ast<'tcx> {\n-    body,\n-    tables,\n-    nested_bodies,\n-    rvalue_promotable_to_static,\n-    stable_bodies_hash\n-});\n-\n-impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n-    pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n-        let body = self.tcx.hir.body(body_id);\n-\n-        // In order to avoid having to hash hir::Bodies from extern crates, we\n-        // hash them here, during export, and store the hash with metadata.\n-        let stable_bodies_hash = {\n-            let mut hcx = self.tcx.create_stable_hashing_context();\n-            let mut hasher = StableHasher::new();\n-\n-            hcx.while_hashing_hir_bodies(true, |hcx| {\n-                body.hash_stable(hcx, &mut hasher);\n-            });\n-\n-            hasher.finish()\n-        };\n-\n-        let lazy_body = self.lazy(body);\n-        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n-        let tables = self.tcx.typeck_tables_of(body_owner_def_id);\n-        let lazy_tables = self.lazy(tables);\n-\n-        let mut visitor = NestedBodyCollector {\n-            tcx: self.tcx,\n-            bodies_found: Vec::new(),\n-        };\n-        visitor.visit_body(body);\n-        let lazy_nested_bodies = self.lazy_seq_ref_from_slice(&visitor.bodies_found);\n-\n-        let rvalue_promotable_to_static =\n-            self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n-\n-        self.lazy(&Ast {\n-            body: lazy_body,\n-            tables: lazy_tables,\n-            nested_bodies: lazy_nested_bodies,\n-            rvalue_promotable_to_static,\n-            stable_bodies_hash,\n-        })\n-    }\n-}\n-\n-struct NestedBodyCollector<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    bodies_found: Vec<&'tcx hir::Body>,\n-}\n-\n-impl<'a, 'tcx: 'a> Visitor<'tcx> for NestedBodyCollector<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let body = self.tcx.hir.body(body);\n-        self.bodies_found.push(body);\n-        self.visit_body(body);\n-    }\n-}"}, {"sha": "a11b95cb5b6c1a02bbb33881587176017807f714", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -142,7 +142,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     mir_const_qualif => {\n         (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSetBuf::new_empty(0)))\n     }\n-    typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n     is_const_fn => { cdata.is_const_fn(def_id.index) }\n@@ -161,9 +160,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     // This is only used by rustdoc anyway, which shouldn't have\n     // incremental recompilation ever enabled.\n     fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+    rendered_const => { cdata.get_rendered_const(def_id.index) }\n     impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-    item_body_nested_bodies => { cdata.item_body_nested_bodies(tcx, def_id.index) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n     }\n@@ -243,11 +242,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     defined_lang_items => { Lrc::new(cdata.get_lang_items()) }\n     missing_lang_items => { Lrc::new(cdata.get_missing_lang_items()) }\n \n-    extern_const_body => {\n-        debug!(\"item_body({:?}): inlining item\", def_id);\n-        cdata.extern_const_body(tcx, def_id.index)\n-    }\n-\n     missing_extern_crate_item => {\n         let r = match *cdata.extern_crate.borrow() {\n             Some(extern_crate) if !extern_crate.direct => true,"}, {"sha": "0147e8dc6075948f38e20a8fd0ac72f6e7726dc8", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 56, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -17,8 +17,7 @@ use rustc_data_structures::sync::{Lrc, ReadGuard};\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash,\n                       DisambiguatedDefPathData};\n use rustc::hir;\n-use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n-                            ExternBodyNestedBodies};\n+use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex,\n@@ -33,7 +32,6 @@ use rustc::mir::Mir;\n use rustc::util::captures::Captures;\n use rustc::util::nodemap::FxHashMap;\n \n-use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n use std::u32;\n@@ -433,7 +431,7 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const(_) => Def::Const(did),\n+            EntryKind::Const(..) => Def::Const(did),\n             EntryKind::AssociatedConst(..) => Def::AssociatedConst(did),\n             EntryKind::ImmStatic |\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n@@ -794,54 +792,12 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn extern_const_body(&self,\n-                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             id: DefIndex)\n-                             -> ExternConstBody<'tcx> {\n-        assert!(!self.is_proc_macro(id));\n-        let ast = self.entry(id).ast.unwrap();\n-        let def_id = self.local_def_id(id);\n-        let ast = ast.decode((self, tcx));\n-        let body = ast.body.decode((self, tcx));\n-        ExternConstBody {\n-            body: tcx.hir.intern_inlined_body(def_id, body),\n-            fingerprint: ast.stable_bodies_hash,\n-        }\n-    }\n-\n-    pub fn item_body_tables(&self,\n-                            id: DefIndex,\n-                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                            -> &'tcx ty::TypeckTables<'tcx> {\n-        let ast = self.entry(id).ast.unwrap().decode(self);\n-        tcx.alloc_tables(ast.tables.decode((self, tcx)))\n-    }\n-\n-    pub fn item_body_nested_bodies(&self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   id: DefIndex)\n-                                   -> ExternBodyNestedBodies {\n-        if let Some(ref ast) = self.entry(id).ast {\n-            let mut ast = ast.decode(self);\n-            let nested_bodies: BTreeMap<_, _> = ast.nested_bodies\n-                                                   .decode((self, tcx.sess))\n-                                                   .map(|body| (body.id(), body))\n-                                                   .collect();\n-            ExternBodyNestedBodies {\n-                nested_bodies: Lrc::new(nested_bodies),\n-                fingerprint: ast.stable_bodies_hash,\n-            }\n-        } else {\n-            ExternBodyNestedBodies {\n-                nested_bodies: Lrc::new(BTreeMap::new()),\n-                fingerprint: Fingerprint::ZERO,\n-            }\n-        }\n-    }\n-\n     pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {\n-        self.entry(id).ast.expect(\"const item missing `ast`\")\n-            .decode(self).rvalue_promotable_to_static\n+        match self.entry(id).kind {\n+            EntryKind::AssociatedConst(_, data, _) |\n+            EntryKind::Const(data, _) => data.ast_promotable,\n+            _ => bug!(),\n+        }\n     }\n \n     pub fn is_item_mir_available(&self, id: DefIndex) -> bool {\n@@ -861,10 +817,10 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn mir_const_qualif(&self, id: DefIndex) -> u8 {\n         match self.entry(id).kind {\n-            EntryKind::Const(qualif) |\n-            EntryKind::AssociatedConst(AssociatedContainer::ImplDefault, qualif) |\n-            EntryKind::AssociatedConst(AssociatedContainer::ImplFinal, qualif) => {\n-                qualif\n+            EntryKind::Const(qualif, _) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplDefault, qualif, _) |\n+            EntryKind::AssociatedConst(AssociatedContainer::ImplFinal, qualif, _) => {\n+                qualif.mir\n             }\n             _ => bug!(),\n         }\n@@ -877,7 +833,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n \n         let (kind, container, has_self) = match item.kind {\n-            EntryKind::AssociatedConst(container, _) => {\n+            EntryKind::AssociatedConst(container, _, _) => {\n                 (ty::AssociatedKind::Const, container, false)\n             }\n             EntryKind::Method(data) => {\n@@ -1076,6 +1032,14 @@ impl<'a, 'tcx> CrateMetadata {\n         lazy_seq.decode((self, tcx)).collect()\n     }\n \n+    pub fn get_rendered_const(&self, id: DefIndex) -> String {\n+        match self.entry(id).kind {\n+            EntryKind::Const(_, data) |\n+            EntryKind::AssociatedConst(_, _, data) => data.decode(self).0,\n+            _ => bug!(),\n+        }\n+    }\n+\n     pub fn wasm_custom_sections(&self) -> Vec<DefId> {\n         let sections = self.root\n             .wasm_custom_sections"}, {"sha": "212de375a3f91655c09069f0346049f2d548f653", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -622,7 +622,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: None,\n             mir: self.encode_optimized_mir(def_id),\n         }\n     }\n@@ -660,7 +659,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: None,\n             predicates: None,\n \n-            ast: None,\n             mir: None\n         }\n     }\n@@ -701,7 +699,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: None,\n             mir: None,\n         }\n     }\n@@ -759,7 +756,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: None,\n             mir: self.encode_optimized_mir(def_id),\n         }\n     }\n@@ -795,7 +791,18 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         let kind = match trait_item.kind {\n             ty::AssociatedKind::Const => {\n-                EntryKind::AssociatedConst(container, 0)\n+                let const_qualif =\n+                    if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.node {\n+                        self.const_qualif(0, body)\n+                    } else {\n+                        ConstQualif { mir: 0, ast_promotable: false }\n+                    };\n+\n+                let rendered =\n+                    hir::print::to_string(&self.tcx.hir, |s| s.print_trait_item(ast_item));\n+                let rendered_const = self.lazy(&RenderedConst(rendered));\n+\n+                EntryKind::AssociatedConst(container, const_qualif, rendered_const)\n             }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Method(_, ref m) = ast_item.node {\n@@ -855,11 +862,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: if let hir::TraitItemKind::Const(_, Some(body)) = ast_item.node {\n-                Some(self.encode_body(body))\n-            } else {\n-                None\n-            },\n             mir: self.encode_optimized_mir(def_id),\n         }\n     }\n@@ -869,6 +871,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         !self.tcx.sess.opts.output_types.should_trans()\n     }\n \n+    fn const_qualif(&self, mir: u8, body_id: hir::BodyId) -> ConstQualif {\n+        let body_owner_def_id = self.tcx.hir.body_owner_def_id(body_id);\n+        let ast_promotable = self.tcx.const_is_rvalue_promotable_to_static(body_owner_def_id);\n+\n+        ConstQualif { mir, ast_promotable }\n+    }\n+\n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -886,8 +895,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         let kind = match impl_item.kind {\n             ty::AssociatedKind::Const => {\n-                EntryKind::AssociatedConst(container,\n-                    self.tcx.at(ast_item.span).mir_const_qualif(def_id).0)\n+                if let hir::ImplItemKind::Const(_, body_id) = ast_item.node {\n+                    let mir = self.tcx.at(ast_item.span).mir_const_qualif(def_id).0;\n+\n+                    EntryKind::AssociatedConst(container,\n+                        self.const_qualif(mir, body_id),\n+                        self.encode_rendered_const_for_body(body_id))\n+                } else {\n+                    bug!()\n+                }\n             }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n@@ -908,20 +924,20 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             ty::AssociatedKind::Type => EntryKind::AssociatedType(container)\n         };\n \n-        let (ast, mir) = if let hir::ImplItemKind::Const(_, body) = ast_item.node {\n-            (Some(body), true)\n-        } else if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n-            let generics = self.tcx.generics_of(def_id);\n-            let types = generics.parent_types as usize + generics.types.len();\n-            let needs_inline = (types > 0 || tcx.trans_fn_attrs(def_id).requests_inline()) &&\n-                !self.metadata_output_only();\n-            let is_const_fn = sig.constness == hir::Constness::Const;\n-            let ast = if is_const_fn { Some(body) } else { None };\n-            let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n-            (ast, needs_inline || is_const_fn || always_encode_mir)\n-        } else {\n-            (None, false)\n-        };\n+        let mir =\n+            if let hir::ImplItemKind::Const(..) = ast_item.node {\n+                true\n+            } else if let hir::ImplItemKind::Method(ref sig, _) = ast_item.node {\n+                let generics = self.tcx.generics_of(def_id);\n+                let types = generics.parent_types as usize + generics.types.len();\n+                let needs_inline = types > 0 || tcx.trans_fn_attrs(def_id).requests_inline() &&\n+                    !self.metadata_output_only();\n+                let is_const_fn = sig.constness == hir::Constness::Const;\n+                let always_encode_mir = self.tcx.sess.opts.debugging_opts.always_encode_mir;\n+                needs_inline || is_const_fn || always_encode_mir\n+            } else {\n+                false\n+            };\n \n         Entry {\n             kind,\n@@ -942,7 +958,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: ast.map(|body| self.encode_body(body)),\n             mir: if mir { self.encode_optimized_mir(def_id) } else { None },\n         }\n     }\n@@ -999,6 +1014,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n+    fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n+        let body = self.tcx.hir.body(body_id);\n+        let rendered = hir::print::to_string(&self.tcx.hir, |s| s.print_expr(&body.value));\n+        let rendered_const = &RenderedConst(rendered);\n+        self.lazy(rendered_const)\n+    }\n+\n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n@@ -1007,8 +1029,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n-            hir::ItemConst(..) => {\n-                EntryKind::Const(tcx.at(item.span).mir_const_qualif(def_id).0)\n+            hir::ItemConst(_, body_id) => {\n+                let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n+                EntryKind::Const(\n+                    self.const_qualif(mir, body_id),\n+                    self.encode_rendered_const_for_body(body_id)\n+                )\n             }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n@@ -1191,13 +1217,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 _ => None,\n             },\n \n-            ast: match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemFn(_, _, hir::Constness::Const, _, _, body) => {\n-                    Some(self.encode_body(body))\n-                }\n-                _ => None,\n-            },\n             mir: match item.node {\n                 hir::ItemStatic(..) => {\n                     self.encode_optimized_mir(def_id)\n@@ -1240,7 +1259,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             variances: LazySeq::empty(),\n             generics: None,\n             predicates: None,\n-            ast: None,\n             mir: None,\n         }\n     }\n@@ -1269,7 +1287,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: None,\n             predicates: None,\n \n-            ast: None,\n             mir: None,\n         }\n     }\n@@ -1292,7 +1309,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: None,\n             mir: None,\n         }\n     }\n@@ -1337,7 +1353,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: None,\n \n-            ast: None,\n             mir: self.encode_optimized_mir(def_id),\n         }\n     }\n@@ -1346,10 +1361,12 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_embedded_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-        let body = tcx.hir.body_owned_by(id);\n+        let body_id = tcx.hir.body_owned_by(id);\n+        let const_data = self.encode_rendered_const_for_body(body_id);\n+        let mir = tcx.mir_const_qualif(def_id).0;\n \n         Entry {\n-            kind: EntryKind::Const(tcx.mir_const_qualif(def_id).0),\n+            kind: EntryKind::Const(self.const_qualif(mir, body_id), const_data),\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n@@ -1363,7 +1380,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: Some(self.encode_body(body)),\n             mir: self.encode_optimized_mir(def_id),\n         }\n     }\n@@ -1565,7 +1581,6 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n-            ast: None,\n             mir: None,\n         }\n     }"}, {"sha": "88594afa32024f5cb69c11897a61e47a1302abf2", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -55,10 +55,4 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     {\n         self.ecx.lazy_seq_ref(slice.iter())\n     }\n-\n-    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable\n-    {\n-        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n-    }\n }"}, {"sha": "9ecb3fd6cddf6aae48e57ddabbc54fabda79bd85", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -44,7 +44,6 @@ extern crate rustc_data_structures;\n \n mod diagnostics;\n \n-mod astencode;\n mod index_builder;\n mod index;\n mod encoder;"}, {"sha": "5d6db1abe7b68f0663ba66cdd4234e5d6c7e366e", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use astencode;\n use index;\n \n use rustc::hir;\n@@ -266,7 +265,6 @@ pub struct Entry<'tcx> {\n     pub generics: Option<Lazy<ty::Generics>>,\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n-    pub ast: Option<Lazy<astencode::Ast<'tcx>>>,\n     pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n \n@@ -283,13 +281,12 @@ impl_stable_hash_for!(struct Entry<'tcx> {\n     variances,\n     generics,\n     predicates,\n-    ast,\n     mir\n });\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n-    Const(u8),\n+    Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n     ForeignImmStatic,\n@@ -313,7 +310,7 @@ pub enum EntryKind<'tcx> {\n     Impl(Lazy<ImplData<'tcx>>),\n     Method(Lazy<MethodData<'tcx>>),\n     AssociatedType(AssociatedContainer),\n-    AssociatedConst(AssociatedContainer, u8),\n+    AssociatedConst(AssociatedContainer, ConstQualif, Lazy<RenderedConst>),\n }\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n@@ -333,8 +330,9 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n             EntryKind::Type => {\n                 // Nothing else to hash here.\n             }\n-            EntryKind::Const(qualif) => {\n+            EntryKind::Const(qualif, ref const_data) => {\n                 qualif.hash_stable(hcx, hasher);\n+                const_data.hash_stable(hcx, hasher);\n             }\n             EntryKind::Enum(ref repr_options) => {\n                 repr_options.hash_stable(hcx, hasher);\n@@ -375,14 +373,37 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n             EntryKind::AssociatedType(associated_container) => {\n                 associated_container.hash_stable(hcx, hasher);\n             }\n-            EntryKind::AssociatedConst(associated_container, qualif) => {\n+            EntryKind::AssociatedConst(associated_container, qualif, _) => {\n                 associated_container.hash_stable(hcx, hasher);\n                 qualif.hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n+/// Additional data for EntryKind::Const and EntryKind::AssociatedConst\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n+pub struct ConstQualif {\n+    pub mir: u8,\n+    pub ast_promotable: bool,\n+}\n+\n+impl_stable_hash_for!(struct ConstQualif { mir, ast_promotable });\n+\n+/// Contains a constant which has been rendered to a String.\n+/// Used by rustdoc.\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct RenderedConst(pub String);\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for RenderedConst {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.0.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export>,"}, {"sha": "32f23e923d91ba8121caf583fa4d330c7ff747a2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4a77d35c1ed89310a0ed128ce931cd4b85ca4cd4", "patch": "@@ -10,10 +10,7 @@\n \n //! Support for inlining external documentation into the current AST.\n \n-use std::collections::BTreeMap;\n-use std::io;\n use std::iter::once;\n-use rustc_data_structures::sync::Lrc;\n \n use syntax::ast;\n use rustc::hir;\n@@ -408,27 +405,8 @@ fn build_module(cx: &DocContext, did: DefId) -> clean::Module {\n     }\n }\n \n-struct InlinedConst {\n-    nested_bodies: Lrc<BTreeMap<hir::BodyId, hir::Body>>\n-}\n-\n-impl hir::print::PpAnn for InlinedConst {\n-    fn nested(&self, state: &mut hir::print::State, nested: hir::print::Nested)\n-              -> io::Result<()> {\n-        if let hir::print::Nested::Body(body) = nested {\n-            state.print_expr(&self.nested_bodies[&body].value)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.extern_const_body(did).body;\n-    let inlined = InlinedConst {\n-        nested_bodies: cx.tcx.item_body_nested_bodies(did).nested_bodies\n-    };\n-    hir::print::to_string(&inlined, |s| s.print_expr(&body.value))\n+    cx.tcx.rendered_const(did)\n }\n \n fn build_const(cx: &DocContext, did: DefId) -> clean::Constant {"}]}