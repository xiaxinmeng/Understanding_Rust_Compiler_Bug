{"sha": "887dffc44795f30c32e8776a9a1850f82da81942", "node_id": "C_kwDOAAsO6NoAKDg4N2RmZmM0NDc5NWYzMGMzMmU4Nzc2YTlhMTg1MGY4MmRhODE5NDI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-05-03T18:47:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-03T18:47:26Z"}, "message": "Rollup merge of #111086 - nnethercote:rm-MemEncoder, r=cjgillot\n\nRemove `MemEncoder`\n\n`MemEncoder` only has one non-test use, and `FileEncoder` would be more appropriate there anyway.\n\nr? ``@cjgillot``", "tree": {"sha": "2f97152f6b2a2ce4a713f693af9c295f1c948999", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f97152f6b2a2ce4a713f693af9c295f1c948999"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/887dffc44795f30c32e8776a9a1850f82da81942", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkUqw+CRBK7hj4Ov3rIwAADKgIAJSplCqO/84YM4uW741EZuBd\nIN2p1M9r+cSr5WHtZjStjyI76IJ/2Vk9pPFc0Ac9KWcv6nrQrwO3ZPE19sAVaHc4\nkerCDE/rjb8eiVxVp01zTf3VdwOTQIdyHApI9fXDoyJbKQlnmQmux/EEQn+AB5yd\nL+EM1UBV5gDlkDJ9e0y82ZYUFOz6KiGlV83K54P66SIWLorm1+wEb/nlHZBl0uaG\nOjGQgC7omCTfUbCSOIEh5jZv0ZjUoWsRwWdFbnRhf4VHG/tuiTAK6j1snNF3jYHC\n55XR3Gljh515IpsRg9HbtayCqWlTey9vzI4l/yiFqfnC6dPiBUFGNy7Plf9nOQU=\n=iE4z\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f97152f6b2a2ce4a713f693af9c295f1c948999\nparent a47fa34558e34811508e00c5b67a0c49d595de98\nparent ebee3f8515c6f5189b69ae56919ab5bba934aabe\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1683139646 +0530\ncommitter GitHub <noreply@github.com> 1683139646 +0530\n\nRollup merge of #111086 - nnethercote:rm-MemEncoder, r=cjgillot\n\nRemove `MemEncoder`\n\n`MemEncoder` only has one non-test use, and `FileEncoder` would be more appropriate there anyway.\n\nr? ``@cjgillot``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/887dffc44795f30c32e8776a9a1850f82da81942", "html_url": "https://github.com/rust-lang/rust/commit/887dffc44795f30c32e8776a9a1850f82da81942", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/887dffc44795f30c32e8776a9a1850f82da81942/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a47fa34558e34811508e00c5b67a0c49d595de98", "url": "https://api.github.com/repos/rust-lang/rust/commits/a47fa34558e34811508e00c5b67a0c49d595de98", "html_url": "https://github.com/rust-lang/rust/commit/a47fa34558e34811508e00c5b67a0c49d595de98"}, {"sha": "ebee3f8515c6f5189b69ae56919ab5bba934aabe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebee3f8515c6f5189b69ae56919ab5bba934aabe", "html_url": "https://github.com/rust-lang/rust/commit/ebee3f8515c6f5189b69ae56919ab5bba934aabe"}], "stats": {"total": 311, "additions": 63, "deletions": 248}, "files": [{"sha": "0b0182472aad5bda0fbcbb67f29b10cce77ff8b4", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -4060,6 +4060,7 @@ dependencies = [\n  \"indexmap\",\n  \"rustc_macros\",\n  \"smallvec\",\n+ \"tempfile\",\n  \"thin-vec\",\n ]\n "}, {"sha": "c3cc17c255b465435c4ef28a6350bea554b7733c", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -31,14 +31,15 @@ use rustc_middle::dep_graph::WorkProduct;\n use rustc_middle::middle::dependency_format::Dependencies;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque::{FileEncoder, MemDecoder};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_session::config::{CrateType, OutputFilenames, OutputType, RUST_CGU_EXT};\n use rustc_session::cstore::{self, CrateSource};\n use rustc_session::utils::NativeLibKind;\n use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use std::collections::BTreeSet;\n+use std::io;\n use std::path::{Path, PathBuf};\n \n pub mod back;\n@@ -215,8 +216,11 @@ const RLINK_MAGIC: &[u8] = b\"rustlink\";\n const RUSTC_VERSION: Option<&str> = option_env!(\"CFG_VERSION\");\n \n impl CodegenResults {\n-    pub fn serialize_rlink(codegen_results: &CodegenResults) -> Vec<u8> {\n-        let mut encoder = MemEncoder::new();\n+    pub fn serialize_rlink(\n+        rlink_file: &Path,\n+        codegen_results: &CodegenResults,\n+    ) -> Result<usize, io::Error> {\n+        let mut encoder = FileEncoder::new(rlink_file)?;\n         encoder.emit_raw_bytes(RLINK_MAGIC);\n         // `emit_raw_bytes` is used to make sure that the version representation does not depend on\n         // Encoder's inner representation of `u32`."}, {"sha": "6483d51a0b9a99b9ec3b338d1bed6f7ec0bb32e4", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -368,9 +368,8 @@ impl Linker {\n         }\n \n         if sess.opts.unstable_opts.no_link {\n-            let encoded = CodegenResults::serialize_rlink(&codegen_results);\n             let rlink_file = self.prepare_outputs.with_extension(config::RLINK_EXT);\n-            std::fs::write(&rlink_file, encoded)\n+            CodegenResults::serialize_rlink(&rlink_file, &codegen_results)\n                 .map_err(|error| sess.emit_fatal(FailedWritingFile { path: &rlink_file, error }))?;\n             return Ok(());\n         }"}, {"sha": "6046780685ad8eaeb40e1aa13d5352468f1934fc", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -10,3 +10,4 @@ thin-vec = \"0.2.12\"\n \n [dev-dependencies]\n rustc_macros = { path = \"../rustc_macros\" }\n+tempfile = \"3.2\""}, {"sha": "a2ec318df6d83cab3c371dac7c055e94f63c8ba5", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 4, "deletions": 125, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -12,118 +12,14 @@ use std::ptr;\n // Encoder\n // -----------------------------------------------------------------------------\n \n-pub struct MemEncoder {\n-    pub data: Vec<u8>,\n-}\n-\n-impl MemEncoder {\n-    pub fn new() -> MemEncoder {\n-        MemEncoder { data: vec![] }\n-    }\n-\n-    #[inline]\n-    pub fn position(&self) -> usize {\n-        self.data.len()\n-    }\n-\n-    pub fn finish(self) -> Vec<u8> {\n-        self.data\n-    }\n-}\n-\n-macro_rules! write_leb128 {\n-    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n-        let old_len = $enc.data.len();\n-\n-        if MAX_ENCODED_LEN > $enc.data.capacity() - old_len {\n-            $enc.data.reserve(MAX_ENCODED_LEN);\n-        }\n-\n-        // SAFETY: The above check and `reserve` ensures that there is enough\n-        // room to write the encoded value to the vector's internal buffer.\n-        unsafe {\n-            let buf = &mut *($enc.data.as_mut_ptr().add(old_len)\n-                as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN]);\n-            let encoded = leb128::$fun(buf, $value);\n-            $enc.data.set_len(old_len + encoded.len());\n-        }\n-    }};\n-}\n-\n-impl Encoder for MemEncoder {\n-    #[inline]\n-    fn emit_usize(&mut self, v: usize) {\n-        write_leb128!(self, v, usize, write_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u128(&mut self, v: u128) {\n-        write_leb128!(self, v, u128, write_u128_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u64(&mut self, v: u64) {\n-        write_leb128!(self, v, u64, write_u64_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u32(&mut self, v: u32) {\n-        write_leb128!(self, v, u32, write_u32_leb128);\n-    }\n-\n-    #[inline]\n-    fn emit_u16(&mut self, v: u16) {\n-        self.data.extend_from_slice(&v.to_le_bytes());\n-    }\n-\n-    #[inline]\n-    fn emit_u8(&mut self, v: u8) {\n-        self.data.push(v);\n-    }\n-\n-    #[inline]\n-    fn emit_isize(&mut self, v: isize) {\n-        write_leb128!(self, v, isize, write_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i128(&mut self, v: i128) {\n-        write_leb128!(self, v, i128, write_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i64(&mut self, v: i64) {\n-        write_leb128!(self, v, i64, write_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i32(&mut self, v: i32) {\n-        write_leb128!(self, v, i32, write_i32_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i16(&mut self, v: i16) {\n-        self.data.extend_from_slice(&v.to_le_bytes());\n-    }\n-\n-    #[inline]\n-    fn emit_raw_bytes(&mut self, s: &[u8]) {\n-        self.data.extend_from_slice(s);\n-    }\n-}\n-\n pub type FileEncodeResult = Result<usize, io::Error>;\n \n /// `FileEncoder` encodes data to file via fixed-size buffer.\n ///\n-/// When encoding large amounts of data to a file, using `FileEncoder` may be\n-/// preferred over using `MemEncoder` to encode to a `Vec`, and then writing the\n-/// `Vec` to file, as the latter uses as much memory as there is encoded data,\n-/// while the former uses the fixed amount of memory allocated to the buffer.\n-/// `FileEncoder` also has the advantage of not needing to reallocate as data\n-/// is appended to it, but the disadvantage of requiring more error handling,\n-/// which has some runtime overhead.\n+/// There used to be a `MemEncoder` type that encoded all the data into a\n+/// `Vec`. `FileEncoder` is better because its memory use is determined by the\n+/// size of the buffer, rather than the full length of the encoded data, and\n+/// because it doesn't need to reallocate memory along the way.\n pub struct FileEncoder {\n     /// The input buffer. For adequate performance, we need more control over\n     /// buffering than `BufWriter` offers. If `BufWriter` ever offers a raw\n@@ -645,13 +541,6 @@ impl<'a> Decoder for MemDecoder<'a> {\n \n // Specialize encoding byte slices. This specialization also applies to encoding `Vec<u8>`s, etc.,\n // since the default implementations call `encode` on their slices internally.\n-impl Encodable<MemEncoder> for [u8] {\n-    fn encode(&self, e: &mut MemEncoder) {\n-        Encoder::emit_usize(e, self.len());\n-        e.emit_raw_bytes(self);\n-    }\n-}\n-\n impl Encodable<FileEncoder> for [u8] {\n     fn encode(&self, e: &mut FileEncoder) {\n         Encoder::emit_usize(e, self.len());\n@@ -675,16 +564,6 @@ impl IntEncodedWithFixedSize {\n     pub const ENCODED_SIZE: usize = 8;\n }\n \n-impl Encodable<MemEncoder> for IntEncodedWithFixedSize {\n-    #[inline]\n-    fn encode(&self, e: &mut MemEncoder) {\n-        let _start_pos = e.position();\n-        e.emit_raw_bytes(&self.0.to_le_bytes());\n-        let _end_pos = e.position();\n-        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n-    }\n-}\n-\n impl Encodable<FileEncoder> for IntEncodedWithFixedSize {\n     #[inline]\n     fn encode(&self, e: &mut FileEncoder) {"}, {"sha": "861091688bb2dd6c14910260fd273934187b76f2", "filename": "compiler/rustc_serialize/tests/opaque.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/887dffc44795f30c32e8776a9a1850f82da81942/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fopaque.rs?ref=887dffc44795f30c32e8776a9a1850f82da81942", "patch": "@@ -1,9 +1,10 @@\n #![allow(rustc::internal)]\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n+use rustc_serialize::opaque::{MemDecoder, FileEncoder};\n use rustc_serialize::{Decodable, Encodable};\n use std::fmt::Debug;\n+use std::fs;\n \n #[derive(PartialEq, Clone, Debug, Encodable, Decodable)]\n struct Struct {\n@@ -27,18 +28,21 @@ struct Struct {\n }\n \n fn check_round_trip<\n-    T: Encodable<MemEncoder> + for<'a> Decodable<MemDecoder<'a>> + PartialEq + Debug,\n+    T: Encodable<FileEncoder> + for<'a> Decodable<MemDecoder<'a>> + PartialEq + Debug,\n >(\n     values: Vec<T>,\n ) {\n-    let mut encoder = MemEncoder::new();\n+    let tmpfile = tempfile::NamedTempFile::new().unwrap();\n+    let tmpfile = tmpfile.path();\n+\n+    let mut encoder = FileEncoder::new(&tmpfile).unwrap();\n     for value in &values {\n         Encodable::encode(value, &mut encoder);\n     }\n+    encoder.finish().unwrap();\n \n-    let data = encoder.finish();\n+    let data = fs::read(&tmpfile).unwrap();\n     let mut decoder = MemDecoder::new(&data[..], 0);\n-\n     for value in values {\n         let decoded = Decodable::decode(&mut decoder);\n         assert_eq!(value, decoded);\n@@ -61,7 +65,7 @@ fn test_u8() {\n \n #[test]\n fn test_u16() {\n-    for i in u16::MIN..u16::MAX {\n+    for i in [u16::MIN, 111, 3333, 55555, u16::MAX] {\n         check_round_trip(vec![1, 2, 3, i, i, i]);\n     }\n }\n@@ -92,7 +96,7 @@ fn test_i8() {\n \n #[test]\n fn test_i16() {\n-    for i in i16::MIN..i16::MAX {\n+    for i in [i16::MIN, -100, 0, 101, i16::MAX] {\n         check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n     }\n }\n@@ -251,3 +255,41 @@ fn test_tuples() {\n     check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n     check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n }\n+\n+#[test]\n+fn test_unit_like_struct() {\n+    #[derive(Encodable, Decodable, PartialEq, Debug)]\n+    struct UnitLikeStruct;\n+\n+    check_round_trip(vec![UnitLikeStruct]);\n+}\n+\n+#[test]\n+fn test_box() {\n+    #[derive(Encodable, Decodable, PartialEq, Debug)]\n+    struct A {\n+        foo: Box<[bool]>,\n+    }\n+\n+    let obj = A { foo: Box::new([true, false]) };\n+    check_round_trip(vec![obj]);\n+}\n+\n+#[test]\n+fn test_cell() {\n+    use std::cell::{Cell, RefCell};\n+\n+    #[derive(Encodable, Decodable, PartialEq, Debug)]\n+    struct A {\n+        baz: isize,\n+    }\n+\n+    #[derive(Encodable, Decodable, PartialEq, Debug)]\n+    struct B {\n+        foo: Cell<bool>,\n+        bar: RefCell<A>,\n+    }\n+\n+    let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n+    check_round_trip(vec![obj]);\n+}"}, {"sha": "1c376f59e5174a4d82654d5724de868e39e933e9", "filename": "tests/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=a47fa34558e34811508e00c5b67a0c49d595de98", "patch": "@@ -1,34 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_imports)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_macros;\n-extern crate rustc_serialize;\n-\n-// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n-// files.\n-#[allow(unused_extern_crates)]\n-extern crate rustc_driver;\n-\n-use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-\n-#[derive(Encodable, Decodable)]\n-struct A {\n-    foo: Box<[bool]>,\n-}\n-\n-fn main() {\n-    let obj = A { foo: Box::new([true, false]) };\n-\n-    let mut encoder = MemEncoder::new();\n-    obj.encode(&mut encoder);\n-    let data = encoder.finish();\n-\n-    let mut decoder = MemDecoder::new(&data, 0);\n-    let obj2 = A::decode(&mut decoder);\n-\n-    assert_eq!(obj.foo, obj2.foo);\n-}"}, {"sha": "844d40f2ecd6a4590500b18a1727df21d8dbbca9", "filename": "tests/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=a47fa34558e34811508e00c5b67a0c49d595de98", "patch": "@@ -1,44 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_imports)]\n-// This briefly tests the capability of `Cell` and `RefCell` to implement the\n-// `Encodable` and `Decodable` traits via `#[derive(Encodable, Decodable)]`\n-#![feature(rustc_private)]\n-\n-extern crate rustc_macros;\n-extern crate rustc_serialize;\n-\n-// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n-// files.\n-#[allow(unused_extern_crates)]\n-extern crate rustc_driver;\n-\n-use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-use std::cell::{Cell, RefCell};\n-\n-#[derive(Encodable, Decodable)]\n-struct A {\n-    baz: isize,\n-}\n-\n-#[derive(Encodable, Decodable)]\n-struct B {\n-    foo: Cell<bool>,\n-    bar: RefCell<A>,\n-}\n-\n-fn main() {\n-    let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n-\n-    let mut encoder = MemEncoder::new();\n-    obj.encode(&mut encoder);\n-    let data = encoder.finish();\n-\n-    let mut decoder = MemDecoder::new(&data, 0);\n-    let obj2 = B::decode(&mut decoder);\n-\n-    assert_eq!(obj.foo.get(), obj2.foo.get());\n-    assert_eq!(obj.bar.borrow().baz, obj2.bar.borrow().baz);\n-}"}, {"sha": "309b5c4a03d57c3b3f0e1e95561720dc60129936", "filename": "tests/ui-fulldeps/issue-14021.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a47fa34558e34811508e00c5b67a0c49d595de98/tests%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fissue-14021.rs?ref=a47fa34558e34811508e00c5b67a0c49d595de98", "patch": "@@ -1,33 +0,0 @@\n-// run-pass\n-\n-#![allow(unused_mut)]\n-#![allow(unused_imports)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_macros;\n-extern crate rustc_serialize;\n-\n-// Necessary to pull in object code as the rest of the rustc crates are shipped only as rmeta\n-// files.\n-#[allow(unused_extern_crates)]\n-extern crate rustc_driver;\n-\n-use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::opaque::{MemDecoder, MemEncoder};\n-use rustc_serialize::{Decodable, Encodable, Encoder};\n-\n-#[derive(Encodable, Decodable, PartialEq, Debug)]\n-struct UnitLikeStruct;\n-\n-pub fn main() {\n-    let obj = UnitLikeStruct;\n-\n-    let mut encoder = MemEncoder::new();\n-    obj.encode(&mut encoder);\n-    let data = encoder.finish();\n-\n-    let mut decoder = MemDecoder::new(&data, 0);\n-    let obj2 = UnitLikeStruct::decode(&mut decoder);\n-\n-    assert_eq!(obj, obj2);\n-}"}]}