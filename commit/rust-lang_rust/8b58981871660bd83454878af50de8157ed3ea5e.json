{"sha": "8b58981871660bd83454878af50de8157ed3ea5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiNTg5ODE4NzE2NjBiZDgzNDU0ODc4YWY1MGRlODE1N2VkM2VhNWU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-03-22T08:38:15Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-30T01:50:31Z"}, "message": "Add a bitflags! macro\n\nThe `bitflags!` macro generates a `struct` that holds a set of C-style bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n\nFor example:\n\n~~~rust\n#[feature(phase)];\n#[phase(syntax)] extern crate collections;\n\nbitflags!(Flags: u32 {\n    FlagA       = 0x00000001,\n    FlagB       = 0x00000010,\n    FlagC       = 0x00000100,\n    FlagABC     = FlagA.bits\n                | FlagB.bits\n                | FlagC.bits\n})\n\nfn main() {\n    let e1 = FlagA | FlagC;\n    let e2 = FlagB | FlagC;\n    assert!((e1 | e2) == FlagABC);   // union\n    assert!((e1 & e2) == FlagC);     // intersection\n    assert!((e1 - e2) == FlagA);     // set difference\n}\n~~~", "tree": {"sha": "dc4c8eee4bf9f5c871263da714583d3fb02c1c75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc4c8eee4bf9f5c871263da714583d3fb02c1c75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b58981871660bd83454878af50de8157ed3ea5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b58981871660bd83454878af50de8157ed3ea5e", "html_url": "https://github.com/rust-lang/rust/commit/8b58981871660bd83454878af50de8157ed3ea5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b58981871660bd83454878af50de8157ed3ea5e/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33259d979742e643a5dda4889d17d59c6fcf63e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/33259d979742e643a5dda4889d17d59c6fcf63e4", "html_url": "https://github.com/rust-lang/rust/commit/33259d979742e643a5dda4889d17d59c6fcf63e4"}], "stats": {"total": 223, "additions": 223, "deletions": 0}, "files": [{"sha": "294d5fe6d8e4623d16d5148104fe7bbc07be0df8", "filename": "src/libcollections/bitflags.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/8b58981871660bd83454878af50de8157ed3ea5e/src%2Flibcollections%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b58981871660bd83454878af50de8157ed3ea5e/src%2Flibcollections%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitflags.rs?ref=8b58981871660bd83454878af50de8157ed3ea5e", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The `bitflags!` macro generates a `struct` that holds a set of C-style\n+//! bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n+//!\n+//! The flags should only be defined for integer types, otherwise unexpected\n+//! type errors may occur at compile time.\n+//!\n+//! # Example\n+//!\n+//! ~~~rust\n+//! #[feature(phase)];\n+//! #[phase(syntax)] extern crate collections;\n+//!\n+//! bitflags!(Flags: u32 {\n+//!     FlagA       = 0x00000001,\n+//!     FlagB       = 0x00000010,\n+//!     FlagC       = 0x00000100,\n+//!     FlagABC     = FlagA.bits\n+//!                 | FlagB.bits\n+//!                 | FlagC.bits\n+//! })\n+//!\n+//! fn main() {\n+//!     let e1 = FlagA | FlagC;\n+//!     let e2 = FlagB | FlagC;\n+//!     assert!((e1 | e2) == FlagABC);   // union\n+//!     assert!((e1 & e2) == FlagC);     // intersection\n+//!     assert!((e1 - e2) == FlagA);     // set difference\n+//! }\n+//! ~~~\n+//!\n+//! # Operators\n+//!\n+//! The following operator traits are implemented for the generated `struct`:\n+//!\n+//! - `BitOr`: union\n+//! - `BitAnd`: intersection\n+//! - `Sub`: set difference\n+//!\n+//! # Methods\n+//!\n+//! The following methods are defined for the generated `struct`:\n+//!\n+//! - `empty`: an empty set of flags\n+//! - `bits`: the raw value of the flags currently stored\n+//! - `is_empty`: `true` if no flags are currently stored\n+//! - `intersects`: `true` if there are flags common to both `self` and `other`\n+//! - `contains`: `true` all of the flags in `other` are contained within `self`\n+//! - `insert`: inserts the specified flags in-place\n+//! - `remove`: removes the specified flags in-place\n+\n+#[macro_export]\n+macro_rules! bitflags(\n+    ($BitFlags:ident: $T:ty {\n+        $($Flag:ident = $value:expr),+\n+    }) => (\n+        #[deriving(Eq, TotalEq, Clone)]\n+        pub struct $BitFlags {\n+            priv bits: $T,\n+        }\n+\n+        $(pub static $Flag: $BitFlags = $BitFlags { bits: $value };)+\n+\n+        impl $BitFlags {\n+            /// Returns an empty set of flags.\n+            pub fn empty() -> $BitFlags {\n+                $BitFlags { bits: 0 }\n+            }\n+\n+            /// Returns the raw value of the flags currently stored.\n+            pub fn bits(&self) -> $T {\n+                self.bits\n+            }\n+\n+            /// Returns `true` if no flags are currently stored.\n+            pub fn is_empty(&self) -> bool {\n+                *self == $BitFlags::empty()\n+            }\n+\n+            /// Returns `true` if there are flags common to both `self` and `other`.\n+            pub fn intersects(&self, other: $BitFlags) -> bool {\n+                !(self & other).is_empty()\n+            }\n+\n+            /// Returns `true` all of the flags in `other` are contained within `self`.\n+            pub fn contains(&self, other: $BitFlags) -> bool {\n+                (self & other) == other\n+            }\n+\n+            /// Inserts the specified flags in-place.\n+            pub fn insert(&mut self, other: $BitFlags) {\n+                self.bits |= other.bits;\n+            }\n+\n+            /// Removes the specified flags in-place.\n+            pub fn remove(&mut self, other: $BitFlags) {\n+                self.bits &= !other.bits;\n+            }\n+        }\n+\n+        impl BitOr<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the union of the two sets of flags.\n+            #[inline]\n+            fn bitor(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits | other.bits }\n+            }\n+        }\n+\n+        impl BitAnd<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the intersection between the two sets of flags.\n+            #[inline]\n+            fn bitand(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & other.bits }\n+            }\n+        }\n+\n+        impl Sub<$BitFlags, $BitFlags> for $BitFlags {\n+            /// Returns the set difference of the two sets of flags.\n+            #[inline]\n+            fn sub(&self, other: &$BitFlags) -> $BitFlags {\n+                $BitFlags { bits: self.bits & !other.bits }\n+            }\n+        }\n+    )\n+)\n+\n+#[cfg(test)]\n+mod tests {\n+    bitflags!(Flags: u32 {\n+        FlagA       = 0x00000001,\n+        FlagB       = 0x00000010,\n+        FlagC       = 0x00000100,\n+        FlagABC     = FlagA.bits\n+                    | FlagB.bits\n+                    | FlagC.bits\n+    })\n+\n+    #[test]\n+    fn test_bits(){\n+        assert_eq!(Flags::empty().bits(), 0x00000000);\n+        assert_eq!(FlagA.bits(), 0x00000001);\n+        assert_eq!(FlagABC.bits(), 0x00000111);\n+    }\n+\n+    #[test]\n+    fn test_is_empty(){\n+        assert!(Flags::empty().is_empty());\n+        assert!(!FlagA.is_empty());\n+        assert!(!FlagABC.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_two_empties_do_not_intersect() {\n+        let e1 = Flags::empty();\n+        let e2 = Flags::empty();\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_empty_does_not_intersect_with_full() {\n+        let e1 = Flags::empty();\n+        let e2 = FlagABC;\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_disjoint_intersects() {\n+        let e1 = FlagA;\n+        let e2 = FlagB;\n+        assert!(!e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_overlapping_intersects() {\n+        let e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        assert!(e1.intersects(e2));\n+    }\n+\n+    #[test]\n+    fn test_contains() {\n+        let e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        assert!(!e1.contains(e2));\n+        assert!(e2.contains(e1));\n+        assert!(FlagABC.contains(e2));\n+    }\n+\n+    #[test]\n+    fn test_insert(){\n+        let mut e1 = FlagA;\n+        let e2 = FlagA | FlagB;\n+        e1.insert(e2);\n+        assert!(e1 == e2);\n+    }\n+\n+    #[test]\n+    fn test_remove(){\n+        let mut e1 = FlagA | FlagB;\n+        let e2 = FlagA | FlagC;\n+        e1.remove(e2);\n+        assert!(e1 == FlagB);\n+    }\n+\n+    #[test]\n+    fn test_operators() {\n+        let e1 = FlagA | FlagC;\n+        let e2 = FlagB | FlagC;\n+        assert!((e1 | e2) == FlagABC);   // union\n+        assert!((e1 & e2) == FlagC);     // intersection\n+        assert!((e1 - e2) == FlagA);     // set difference\n+    }\n+}"}, {"sha": "891ac3be0e92c41a190b2beddeaaad587a9e52b3", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b58981871660bd83454878af50de8157ed3ea5e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b58981871660bd83454878af50de8157ed3ea5e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8b58981871660bd83454878af50de8157ed3ea5e", "patch": "@@ -42,6 +42,7 @@ pub use smallintmap::SmallIntMap;\n pub use treemap::{TreeMap, TreeSet};\n pub use trie::{TrieMap, TrieSet};\n \n+pub mod bitflags;\n pub mod bitv;\n pub mod btree;\n pub mod deque;"}]}