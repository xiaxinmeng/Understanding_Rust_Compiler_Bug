{"sha": "265a23320dbeaeca45b889cfea684d71dec1b8e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NWEyMzMyMGRiZWFlY2E0NWI4ODljZmVhNjg0ZDcxZGVjMWI4ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-29T16:28:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-29T16:28:52Z"}, "message": "Auto merge of #21677 - japaric:no-range, r=alexcrichton\n\nNote: Do not merge until we get a newer snapshot that includes #21374\r\n\r\nThere was some type inference fallout (see 4th commit) because type inference with `a..b` is not as good as with `range(a, b)` (see #21672).\r\n\r\nr? @alexcrichton", "tree": {"sha": "36775481b19e207f139d108aeb88875b695de181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36775481b19e207f139d108aeb88875b695de181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/265a23320dbeaeca45b889cfea684d71dec1b8e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/265a23320dbeaeca45b889cfea684d71dec1b8e6", "html_url": "https://github.com/rust-lang/rust/commit/265a23320dbeaeca45b889cfea684d71dec1b8e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/265a23320dbeaeca45b889cfea684d71dec1b8e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d6f5100aff24aa97275dc92ade728caac605560", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d6f5100aff24aa97275dc92ade728caac605560", "html_url": "https://github.com/rust-lang/rust/commit/3d6f5100aff24aa97275dc92ade728caac605560"}, {"sha": "a6f9180fd61f509ebc6d666eda3f6bb42dd02573", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6f9180fd61f509ebc6d666eda3f6bb42dd02573", "html_url": "https://github.com/rust-lang/rust/commit/a6f9180fd61f509ebc6d666eda3f6bb42dd02573"}], "stats": {"total": 2651, "additions": 1314, "deletions": 1337}, "files": [{"sha": "b1deb8a36ade4a6399766b4d3f2ccf8ce710e559", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -12,20 +12,6 @@ pub use self::Mode::*;\n use std::fmt;\n use std::str::FromStr;\n \n-#[cfg(stage0)] // NOTE: remove impl after snapshot\n-#[derive(Clone, Copy, PartialEq, Show)]\n-pub enum Mode {\n-    CompileFail,\n-    RunFail,\n-    RunPass,\n-    RunPassValgrind,\n-    Pretty,\n-    DebugInfoGdb,\n-    DebugInfoLldb,\n-    Codegen\n-}\n-\n-#[cfg(not(stage0))] // NOTE: remove cfg after snapshot\n #[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,"}, {"sha": "357ccec7cf3520bb4abad2f6b05a677d09448bf7", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -23,6 +23,7 @@\n #![feature(os)]\n #![feature(unicode)]\n \n+#![allow(unstable)]\n #![deny(warnings)]\n \n extern crate test;"}, {"sha": "40d4397916d3f2d38f53142ec778ff895ce6e704", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -17,7 +17,7 @@ pub struct ExpectedError {\n     pub msg: String,\n }\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n \n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\""}, {"sha": "68b36e7a4b7ca225573b1accd19cf31c2534cc91", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -147,10 +147,10 @@ for all but the most trivial of situations.\n Here's an example of using `Result`:\n \n ```rust\n-#[derive(Show)]\n+#[derive(Debug)]\n enum Version { Version1, Version2 }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n enum ParseError { InvalidHeaderLength, InvalidVersion }\n \n fn parse_version(header: &[u8]) -> Result<Version, ParseError> {"}, {"sha": "9c649cd2273f8025117dd58f9f9eedf6f2b8e75d", "filename": "src/doc/trpl/pointers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fdoc%2Ftrpl%2Fpointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fdoc%2Ftrpl%2Fpointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fpointers.md?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -605,7 +605,7 @@ Sometimes, you need a recursive data structure. The simplest is known as a\n \n \n ```{rust}\n-#[derive(Show)]\n+#[derive(Debug)]\n enum List<T> {\n     Cons(T, Box<List<T>>),\n     Nil,"}, {"sha": "f9f6de2df58768c45b83d50db4dd0fc8e06b3ccc", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -37,7 +37,7 @@\n //!\n //! let five = Arc::new(5i);\n //!\n-//! for _ in range(0u, 10) {\n+//! for _ in 0u..10 {\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n@@ -54,7 +54,7 @@\n //!\n //! let five = Arc::new(Mutex::new(5i));\n //!\n-//! for _ in range(0u, 10) {\n+//! for _ in 0u..10 {\n //!     let five = five.clone();\n //!\n //!     Thread::spawn(move || {\n@@ -95,10 +95,10 @@ use heap::deallocate;\n /// use std::thread::Thread;\n ///\n /// fn main() {\n-///     let numbers: Vec<_> = range(0, 100u32).map(|i| i as f32).collect();\n+///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n-///     for _ in range(0u, 10) {\n+///     for _ in 0u..10 {\n ///         let child_numbers = shared_numbers.clone();\n ///\n ///         Thread::spawn(move || {\n@@ -814,6 +814,6 @@ mod tests {\n     }\n \n     // Make sure deriving works with Arc<T>\n-    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Show, Default)]\n+    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n     struct Foo { inner: Arc<int> }\n }"}, {"sha": "91577e30d9a01313a7f47cc971a44f96aa7c96bb", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -29,7 +29,7 @@\n //! Creating a recursive data structure:\n //!\n //! ```\n-//! #[derive(Show)]\n+//! #[derive(Debug)]\n //! enum List<T> {\n //!     Cons(T, Box<List<T>>),\n //!     Nil,\n@@ -250,8 +250,6 @@ impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-// FIXME(#21363) remove `old_impl_check` when bug is fixed\n-#[old_impl_check]\n impl<'a, T> Iterator for Box<Iterator<Item=T> + 'a> {\n     type Item = T;\n "}, {"sha": "f807d8d12a6b56d9dba2e8675e94dc28add38212", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -70,8 +70,6 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n-// FIXME(#21363) remove `old_impl_check` when bug is fixed\n-#![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(core)]\n #![feature(hash)]"}, {"sha": "9744feb4ee7642e97c6c8651a6f1dc3eb2ed228d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -311,7 +311,7 @@ impl Arena {\n #[test]\n fn test_arena_destructors() {\n     let arena = Arena::new();\n-    for i in range(0u, 10) {\n+    for i in 0u..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         arena.alloc(|| Rc::new(i));\n@@ -340,7 +340,7 @@ fn test_arena_alloc_nested() {\n fn test_arena_destructors_fail() {\n     let arena = Arena::new();\n     // Put some stuff in the arena.\n-    for i in range(0u, 10) {\n+    for i in 0u..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n         arena.alloc(|| { Rc::new(i) });\n@@ -410,7 +410,7 @@ impl<T> TypedArenaChunk<T> {\n         // Destroy all the allocated objects.\n         if intrinsics::needs_drop::<T>() {\n             let mut start = self.start();\n-            for _ in range(0, len) {\n+            for _ in 0..len {\n                 ptr::read(start as *const T); // run the destructor on the pointer\n                 start = start.offset(mem::size_of::<T>() as int)\n             }\n@@ -530,7 +530,7 @@ mod tests {\n     #[test]\n     pub fn test_copy() {\n         let arena = TypedArena::new();\n-        for _ in range(0u, 100000) {\n+        for _ in 0u..100000 {\n             arena.alloc(Point {\n                 x: 1,\n                 y: 2,\n@@ -585,7 +585,7 @@ mod tests {\n     #[test]\n     pub fn test_noncopy() {\n         let arena = TypedArena::new();\n-        for _ in range(0u, 100000) {\n+        for _ in 0u..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n                 array: vec!( 1, 2, 3, 4, 5 ),"}, {"sha": "d03fbf008470381cc57e16c0344e3c90608d79df", "filename": "src/libcollections/bench.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbench.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -24,7 +24,7 @@ pub fn insert_rand_n<M, I, R>(n: uint,\n     // setup\n     let mut rng = rand::weak_rng();\n \n-    for _ in range(0, n) {\n+    for _ in 0..n {\n         insert(map, rng.gen::<uint>() % n);\n     }\n \n@@ -46,7 +46,7 @@ pub fn insert_seq_n<M, I, R>(n: uint,\n     R: FnMut(&mut M, uint),\n {\n     // setup\n-    for i in range(0u, n) {\n+    for i in 0u..n {\n         insert(map, i * 2);\n     }\n \n@@ -70,7 +70,7 @@ pub fn find_rand_n<M, T, I, F>(n: uint,\n {\n     // setup\n     let mut rng = rand::weak_rng();\n-    let mut keys = range(0, n).map(|_| rng.gen::<uint>() % n)\n+    let mut keys = (0..n).map(|_| rng.gen::<uint>() % n)\n                               .collect::<Vec<_>>();\n \n     for k in keys.iter() {\n@@ -97,7 +97,7 @@ pub fn find_seq_n<M, T, I, F>(n: uint,\n     F: FnMut(&M, uint) -> T,\n {\n     // setup\n-    for i in range(0u, n) {\n+    for i in 0u..n {\n         insert(map, i);\n     }\n "}, {"sha": "f717fc6075d4679b3c883e80b4791a4caee2a32d", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -67,7 +67,7 @@\n //! // for a simpler implementation.\n //! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist: Vec<_> = range(0, adj_list.len()).map(|_| uint::MAX).collect();\n+//!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| uint::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!"}, {"sha": "c627574057969d93a479d779b19bf1d2d37d0ce4", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -66,9 +66,9 @@\n //! };\n //!\n //! // Simple primality tests below our max bound\n-//! let print_primes = 20;\n+//! let print_primes = 20u;\n //! print!(\"The primes below {} are: \", print_primes);\n-//! for x in range(0, print_primes) {\n+//! for x in 0..print_primes {\n //!     if primes.contains(&x) {\n //!         print!(\"{} \", x);\n //!     }\n@@ -104,7 +104,7 @@ type MatchWords<'a> = Chain<Enumerate<Blocks<'a>>, Skip<Take<Enumerate<Repeat<u3\n \n fn reverse_bits(byte: u8) -> u8 {\n     let mut result = 0;\n-    for i in range(0, u8::BITS) {\n+    for i in 0..u8::BITS {\n         result |= ((byte >> i) & 1) << (u8::BITS - 1 - i);\n     }\n     result\n@@ -320,7 +320,7 @@ impl Bitv {\n \n         bitv.nbits = len;\n \n-        for i in range(0, complete_words) {\n+        for i in 0..complete_words {\n             bitv.storage.push(\n                 ((reverse_bits(bytes[i * 4 + 0]) as u32) << 0) |\n                 ((reverse_bits(bytes[i * 4 + 1]) as u32) << 8) |\n@@ -353,7 +353,7 @@ impl Bitv {\n     /// ```\n     pub fn from_fn<F>(len: uint, mut f: F) -> Bitv where F: FnMut(uint) -> bool {\n         let mut bitv = Bitv::from_elem(len, false);\n-        for i in range(0u, len) {\n+        for i in 0u..len {\n             bitv.set(i, f(i));\n         }\n         bitv\n@@ -660,7 +660,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        range(0, len).map(|i|\n+        (0..len).map(|i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -830,7 +830,7 @@ impl Bitv {\n \n         // Fill in words after the old tail word\n         let stop_idx = cmp::min(self.storage.len(), new_nblocks);\n-        for idx in range(old_last_word + 1, stop_idx) {\n+        for idx in old_last_word + 1..stop_idx {\n             self.storage[idx] = full_value;\n         }\n \n@@ -2232,12 +2232,12 @@ mod tests {\n     #[test]\n     fn test_equal_sneaky_big() {\n         let mut a = Bitv::from_elem(100, false);\n-        for i in range(0u, 100) {\n+        for i in 0u..100 {\n             a.set(i, true);\n         }\n \n         let mut b = Bitv::from_elem(100, true);\n-        for i in range(0u, 100) {\n+        for i in 0u..100 {\n             b.set(i, true);\n         }\n \n@@ -2283,7 +2283,7 @@ mod tests {\n \n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n-        let long = range(0, 10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n+        let long = (0i32..10000).map(|i| i % 2 == 0).collect::<Vec<_>>();\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n         assert_eq!(bitv.iter().collect::<Vec<bool>>(), long)\n     }\n@@ -2526,7 +2526,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv |= 1 << ((r.next_u32() as uint) % u32::BITS);\n             }\n             black_box(&bitv);\n@@ -2538,7 +2538,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n             }\n             black_box(&bitv);\n@@ -2550,7 +2550,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(BENCH_BITS, false);\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv.set((r.next_u32() as uint) % BENCH_BITS, r.gen());\n             }\n             black_box(&bitv);\n@@ -2562,7 +2562,7 @@ mod bitv_bench {\n         let mut r = rng();\n         let mut bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv.set((r.next_u32() as uint) % u32::BITS, true);\n             }\n             black_box(&bitv);\n@@ -2583,7 +2583,7 @@ mod bitv_bench {\n         let bitv = Bitv::from_elem(u32::BITS, false);\n         b.iter(|| {\n             let mut sum = 0u;\n-            for _ in range(0u, 10) {\n+            for _ in 0u..10 {\n                 for pres in bitv.iter() {\n                     sum += pres as uint;\n                 }\n@@ -2647,7 +2647,7 @@ mod bitv_set_test {\n         let idxs: Vec<uint> = bitv.iter().collect();\n         assert_eq!(idxs, vec![0, 2, 3]);\n \n-        let long: BitvSet = range(0u, 10000).filter(|&n| n % 2 == 0).collect();\n+        let long: BitvSet = (0u..10000).filter(|&n| n % 2 == 0).collect();\n         let real = range_step(0, 10000, 2).collect::<Vec<uint>>();\n \n         let idxs: Vec<uint> = long.iter().collect();\n@@ -3021,7 +3021,7 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv.insert((r.next_u32() as uint) % u32::BITS);\n             }\n             black_box(&bitv);\n@@ -3033,7 +3033,7 @@ mod bitv_set_bench {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         b.iter(|| {\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n             }\n             black_box(&bitv);"}, {"sha": "4f2c2cb60287eebd1266feec69e4eb169228935a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1601,39 +1601,39 @@ mod test {\n         let size = 10000u;\n         assert_eq!(map.len(), 0);\n \n-        for i in range(0, size) {\n+        for i in 0..size {\n             assert_eq!(map.insert(i, 10*i), None);\n             assert_eq!(map.len(), i + 1);\n         }\n \n-        for i in range(0, size) {\n+        for i in 0..size {\n             assert_eq!(map.get(&i).unwrap(), &(i*10));\n         }\n \n-        for i in range(size, size*2) {\n+        for i in size..size*2 {\n             assert_eq!(map.get(&i), None);\n         }\n \n-        for i in range(0, size) {\n+        for i in 0..size {\n             assert_eq!(map.insert(i, 100*i), Some(10*i));\n             assert_eq!(map.len(), size);\n         }\n \n-        for i in range(0, size) {\n+        for i in 0..size {\n             assert_eq!(map.get(&i).unwrap(), &(i*100));\n         }\n \n-        for i in range(0, size/2) {\n+        for i in 0..size/2 {\n             assert_eq!(map.remove(&(i*2)), Some(i*200));\n             assert_eq!(map.len(), size - i - 1);\n         }\n \n-        for i in range(0, size/2) {\n+        for i in 0..size/2 {\n             assert_eq!(map.get(&(2*i)), None);\n             assert_eq!(map.get(&(2*i+1)).unwrap(), &(i*200 + 100));\n         }\n \n-        for i in range(0, size/2) {\n+        for i in 0..size/2 {\n             assert_eq!(map.remove(&(2*i)), None);\n             assert_eq!(map.remove(&(2*i+1)), Some(i*200 + 100));\n             assert_eq!(map.len(), size/2 - i - 1);\n@@ -1661,10 +1661,10 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n-            for i in range(0, size) {\n+            for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n             }\n@@ -1681,10 +1681,10 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T) where T: Iterator<Item=(uint, uint)> {\n-            for i in range(0, size) {\n+            for i in 0..size {\n                 assert_eq!(iter.size_hint(), (size - i, Some(size - i)));\n                 assert_eq!(iter.next().unwrap(), (size - i - 1, size - i - 1));\n             }\n@@ -1701,16 +1701,16 @@ mod test {\n         let size = 10000u;\n \n         // Forwards\n-        let mut map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let mut map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test<T>(size: uint, mut iter: T)\n                 where T: Iterator<Item=(uint, uint)> + DoubleEndedIterator {\n-            for i in range(0, size / 4) {\n+            for i in 0..size / 4 {\n                 assert_eq!(iter.size_hint(), (size - i * 2, Some(size - i * 2)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n                 assert_eq!(iter.next_back().unwrap(), (size - i - 1, size - i - 1));\n             }\n-            for i in range(size / 4, size * 3 / 4) {\n+            for i in size / 4..size * 3 / 4 {\n                 assert_eq!(iter.size_hint(), (size * 3 / 4 - i, Some(size * 3 / 4 - i)));\n                 assert_eq!(iter.next().unwrap(), (i, i));\n             }\n@@ -1727,10 +1727,10 @@ mod test {\n         let size = 5u;\n \n         // Forwards\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         let mut j = 0u;\n-        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(range(2u, size)) {\n+        for ((&k, &v), i) in map.range(Included(&2), Unbounded).zip(2u..size) {\n             assert_eq!(k, i);\n             assert_eq!(v, i);\n             j += 1;\n@@ -1741,11 +1741,11 @@ mod test {\n     #[test]\n     fn test_range_1000() {\n         let size = 1000u;\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n         fn test(map: &BTreeMap<uint, uint>, size: uint, min: Bound<&uint>, max: Bound<&uint>) {\n             let mut kvs = map.range(min, max).map(|(&k, &v)| (k, v));\n-            let mut pairs = range(0, size).map(|i| (i, i));\n+            let mut pairs = (0..size).map(|i| (i, i));\n \n             for (kv, pair) in kvs.by_ref().zip(pairs.by_ref()) {\n                 assert_eq!(kv, pair);\n@@ -1764,10 +1764,10 @@ mod test {\n     #[test]\n     fn test_range() {\n         let size = 200u;\n-        let map: BTreeMap<uint, uint> = range(0, size).map(|i| (i, i)).collect();\n+        let map: BTreeMap<uint, uint> = (0..size).map(|i| (i, i)).collect();\n \n-        for i in range(0, size) {\n-            for j in range(i, size) {\n+        for i in 0..size {\n+            for j in i..size {\n                 let mut kvs = map.range(Included(&i), Included(&j)).map(|(&k, &v)| (k, v));\n                 let mut pairs = range_inclusive(i, j).map(|i| (i, i));\n \n@@ -1917,7 +1917,7 @@ mod bench {\n         let mut map = BTreeMap::<uint, uint>::new();\n         let mut rng = weak_rng();\n \n-        for _ in range(0, size) {\n+        for _ in 0..size {\n             map.insert(rng.gen(), rng.gen());\n         }\n "}, {"sha": "ea167348a644cf7f4ebdc644b526bbfab87b181a", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -501,7 +501,7 @@ impl<K: Clone, V: Clone> Clone for Node<K, V> {\n ///     let mut small_node = Node::make_leaf_root(3);\n ///     let mut large_node = Node::make_leaf_root(100);\n ///\n-///     for i in range(0, 100) {\n+///     for i in 0..100 {\n ///         // Insert to the end\n ///         large_node.edge_handle(i).insert_as_leaf(i, i);\n ///     }"}, {"sha": "aded4b8a7ac9e7fabfd28fbc659e0037b95efb58", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -592,14 +592,14 @@ impl<T> DList<T> {\n             // instead of skipping using .skip() (which creates a new struct),\n             // we skip manually so we can access the head field without\n             // depending on implementation details of Skip\n-            for _ in range(0, at - 1) {\n+            for _ in 0..at - 1 {\n                 iter.next();\n             }\n             iter.head\n         }  else {\n             // better off starting from the end\n             let mut iter = self.iter_mut();\n-            for _ in range(0, len - 1 - (at - 1)) {\n+            for _ in 0..len - 1 - (at - 1) {\n                 iter.next_back();\n             }\n             iter.tail\n@@ -1070,10 +1070,10 @@ mod tests {\n             let mut n = m.split_off(2);\n             assert_eq!(m.len(), 2);\n             assert_eq!(n.len(), 3);\n-            for elt in range(1i, 3) {\n+            for elt in 1i..3 {\n                 assert_eq!(m.pop_front(), Some(elt));\n             }\n-            for elt in range(3i, 6) {\n+            for elt in 3i..6 {\n                 assert_eq!(n.pop_front(), Some(elt));\n             }\n         }\n@@ -1084,10 +1084,10 @@ mod tests {\n             let mut n = m.split_off(4);\n             assert_eq!(m.len(), 4);\n             assert_eq!(n.len(), 1);\n-            for elt in range(1i, 5) {\n+            for elt in 1i..5 {\n                 assert_eq!(m.pop_front(), Some(elt));\n             }\n-            for elt in range(5i, 6) {\n+            for elt in 5i..6 {\n                 assert_eq!(n.pop_front(), Some(elt));\n             }\n         }\n@@ -1325,7 +1325,7 @@ mod tests {\n \n     #[test]\n     fn test_fuzz() {\n-        for _ in range(0u, 25) {\n+        for _ in 0u..25 {\n             fuzz_test(3);\n             fuzz_test(16);\n             fuzz_test(189);\n@@ -1334,7 +1334,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let list: DList<int> = range(0i, 10).collect();\n+        let list: DList<int> = (0i..10).collect();\n         assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -1347,7 +1347,7 @@ mod tests {\n     fn fuzz_test(sz: int) {\n         let mut m: DList<int> = DList::new();\n         let mut v = vec![];\n-        for i in range(0, sz) {\n+        for i in 0..sz {\n             check_links(&m);\n             let r: u8 = rand::random();\n             match r % 6 {"}, {"sha": "b542259eba0dddd7efe1cb1e1da51a69cee34f13", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -272,7 +272,7 @@ mod test {\n \n     use super::{EnumSet, CLike};\n \n-    #[derive(Copy, PartialEq, Show)]\n+    #[derive(Copy, PartialEq, Debug)]\n     #[repr(uint)]\n     enum Foo {\n         A, B, C"}, {"sha": "34910f59fe03677231db083b1bb74d314e8d022b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -388,7 +388,7 @@ impl<T> RingBuf<T> {\n     /// use std::collections::RingBuf;\n     ///\n     /// let mut buf = RingBuf::with_capacity(15);\n-    /// buf.extend(range(0u, 4));\n+    /// buf.extend(0u..4);\n     /// assert_eq!(buf.capacity(), 15);\n     /// buf.shrink_to_fit();\n     /// assert!(buf.capacity() >= 4);\n@@ -483,7 +483,7 @@ impl<T> RingBuf<T> {\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: uint) {\n-        for _ in range(len, self.len()) {\n+        for _ in len..self.len() {\n             self.pop_back();\n         }\n     }\n@@ -1719,29 +1719,29 @@ mod tests {\n     #[test]\n     fn test_push_front_grow() {\n         let mut deq = RingBuf::new();\n-        for i in range(0u, 66) {\n+        for i in 0u..66 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq.len(), 66);\n \n-        for i in range(0u, 66) {\n+        for i in 0u..66 {\n             assert_eq!(deq[i], 65 - i);\n         }\n \n         let mut deq = RingBuf::new();\n-        for i in range(0u, 66) {\n+        for i in 0u..66 {\n             deq.push_back(i);\n         }\n \n-        for i in range(0u, 66) {\n+        for i in 0u..66 {\n             assert_eq!(deq[i], i);\n         }\n     }\n \n     #[test]\n     fn test_index() {\n         let mut deq = RingBuf::new();\n-        for i in range(1u, 4) {\n+        for i in 1u..4 {\n             deq.push_front(i);\n         }\n         assert_eq!(deq[1], 2);\n@@ -1751,7 +1751,7 @@ mod tests {\n     #[should_fail]\n     fn test_index_out_of_bounds() {\n         let mut deq = RingBuf::new();\n-        for i in range(1u, 4) {\n+        for i in 1u..4 {\n             deq.push_front(i);\n         }\n         deq[3];\n@@ -1769,7 +1769,7 @@ mod tests {\n     fn bench_push_back_100(b: &mut test::Bencher) {\n         let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            for i in range(0i, 100) {\n+            for i in 0i..100 {\n                 deq.push_back(i);\n             }\n             deq.head = 0;\n@@ -1781,7 +1781,7 @@ mod tests {\n     fn bench_push_front_100(b: &mut test::Bencher) {\n         let mut deq = RingBuf::with_capacity(101);\n         b.iter(|| {\n-            for i in range(0i, 100) {\n+            for i in 0i..100 {\n                 deq.push_front(i);\n             }\n             deq.head = 0;\n@@ -1819,7 +1819,7 @@ mod tests {\n     fn bench_grow_1025(b: &mut test::Bencher) {\n         b.iter(|| {\n             let mut deq = RingBuf::new();\n-            for i in range(0i, 1025) {\n+            for i in 0i..1025 {\n                 deq.push_front(i);\n             }\n             test::black_box(deq);\n@@ -1828,7 +1828,7 @@ mod tests {\n \n     #[bench]\n     fn bench_iter_1000(b: &mut test::Bencher) {\n-        let ring: RingBuf<int> = range(0i, 1000).collect();\n+        let ring: RingBuf<int> = (0i..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1841,7 +1841,7 @@ mod tests {\n \n     #[bench]\n     fn bench_mut_iter_1000(b: &mut test::Bencher) {\n-        let mut ring: RingBuf<int> = range(0i, 1000).collect();\n+        let mut ring: RingBuf<int> = (0i..1000).collect();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -1852,21 +1852,21 @@ mod tests {\n         })\n     }\n \n-    #[derive(Clone, PartialEq, Show)]\n+    #[derive(Clone, PartialEq, Debug)]\n     enum Taggy {\n         One(int),\n         Two(int, int),\n         Three(int, int, int),\n     }\n \n-    #[derive(Clone, PartialEq, Show)]\n+    #[derive(Clone, PartialEq, Debug)]\n     enum Taggypar<T> {\n         Onepar(int),\n         Twopar(int, int),\n         Threepar(int, int, int),\n     }\n \n-    #[derive(Clone, PartialEq, Show)]\n+    #[derive(Clone, PartialEq, Debug)]\n     struct RecCy {\n         x: int,\n         y: int,\n@@ -1977,7 +1977,7 @@ mod tests {\n \n     #[test]\n     fn test_swap() {\n-        let mut d: RingBuf<int> = range(0i, 5).collect();\n+        let mut d: RingBuf<int> = (0i..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n         assert_eq!(d.iter().map(|&x|x).collect::<Vec<int>>(), vec!(4, 2, 3, 1));\n@@ -1989,15 +1989,15 @@ mod tests {\n         assert_eq!(d.iter().next(), None);\n         assert_eq!(d.iter().size_hint(), (0, Some(0)));\n \n-        for i in range(0i, 5) {\n+        for i in 0i..5 {\n             d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n             assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n-        for i in range(6i, 9) {\n+        for i in 6i..9 {\n             d.push_front(i);\n         }\n         {\n@@ -2020,15 +2020,15 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert_eq!(d.iter().rev().next(), None);\n \n-        for i in range(0i, 5) {\n+        for i in 0i..5 {\n             d.push_back(i);\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n             assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n         }\n \n-        for i in range(6i, 9) {\n+        for i in 6i..9 {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n@@ -2055,7 +2055,7 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().next().is_none());\n \n-        for i in range(0u, 3) {\n+        for i in 0u..3 {\n             d.push_front(i);\n         }\n \n@@ -2078,7 +2078,7 @@ mod tests {\n         let mut d = RingBuf::new();\n         assert!(d.iter_mut().rev().next().is_none());\n \n-        for i in range(0u, 3) {\n+        for i in 0u..3 {\n             d.push_front(i);\n         }\n \n@@ -2112,7 +2112,7 @@ mod tests {\n         // simple iter\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n \n@@ -2123,10 +2123,10 @@ mod tests {\n         // wrapped iter\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n-            for i in range(6, 9) {\n+            for i in 6i..9 {\n                 d.push_front(i);\n             }\n \n@@ -2137,10 +2137,10 @@ mod tests {\n         // partially used\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n-            for i in range(6, 9) {\n+            for i in 6i..9 {\n                 d.push_front(i);\n             }\n \n@@ -2176,7 +2176,7 @@ mod tests {\n         // simple iter\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n \n@@ -2187,10 +2187,10 @@ mod tests {\n         // wrapped iter\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n-            for i in range(6, 9) {\n+            for i in 6i..9 {\n                 d.push_front(i);\n             }\n \n@@ -2201,10 +2201,10 @@ mod tests {\n         // partially used\n         {\n             let mut d = RingBuf::new();\n-            for i in range(0i, 5) {\n+            for i in 0i..5 {\n                 d.push_back(i);\n             }\n-            for i in range(6, 9) {\n+            for i in 6i..9 {\n                 d.push_front(i);\n             }\n \n@@ -2309,7 +2309,7 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        let ringbuf: RingBuf<int> = range(0i, 10).collect();\n+        let ringbuf: RingBuf<int> = (0i..10).collect();\n         assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n@@ -2389,41 +2389,41 @@ mod tests {\n         // test growth path A\n         // [T o o H] -> [T o o H . . . . ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n \n         // test growth path B\n         // [H T o o] -> [. T o o H . . . ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in range(0i, 1) {\n+        for i in 0i..1 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n \n         // test growth path C\n         // [o o H T] -> [o o H . . . . T ]\n         let mut ring = RingBuf::with_capacity(4);\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             ring.push_back(i);\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             ring.push_back(i);\n         }\n         ring.reserve(7);\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             assert_eq!(ring.pop_front(), Some(i));\n         }\n     }\n@@ -2463,7 +2463,7 @@ mod tests {\n     #[test]\n     fn test_get_mut() {\n         let mut ring = RingBuf::new();\n-        for i in range(0i, 3) {\n+        for i in 0i..3 {\n             ring.push_back(i);\n         }\n \n@@ -2492,27 +2492,27 @@ mod tests {\n             let usable_cap = tester.capacity();\n             let final_len = usable_cap / 2;\n \n-            for len in range(0, final_len) {\n+            for len in 0..final_len {\n                 let expected = if back {\n-                    range(0, len).collect()\n+                    (0..len).collect()\n                 } else {\n-                    range(0, len).rev().collect()\n+                    (0..len).rev().collect()\n                 };\n-                for tail_pos in range(0, usable_cap) {\n+                for tail_pos in 0..usable_cap {\n                     tester.tail = tail_pos;\n                     tester.head = tail_pos;\n                     if back {\n-                        for i in range(0, len * 2) {\n+                        for i in 0..len * 2 {\n                             tester.push_front(i);\n                         }\n-                        for i in range(0, len) {\n+                        for i in 0..len {\n                             assert_eq!(tester.swap_back_remove(i), Some(len * 2 - 1 - i));\n                         }\n                     } else {\n-                        for i in range(0, len * 2) {\n+                        for i in 0..len * 2 {\n                             tester.push_back(i);\n                         }\n-                        for i in range(0, len) {\n+                        for i in 0..len {\n                             let idx = tester.len() - 1 - i;\n                             assert_eq!(tester.swap_front_remove(idx), Some(len * 2 - 1 - i));\n                         }\n@@ -2540,14 +2540,14 @@ mod tests {\n \n \n         // len is the length *after* insertion\n-        for len in range(1, cap) {\n+        for len in 1..cap {\n             // 0, 1, 2, .., len - 1\n             let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in range(0, cap) {\n-                for to_insert in range(0, len) {\n+            for tail_pos in 0..cap {\n+                for to_insert in 0..len {\n                     tester.tail = tail_pos;\n                     tester.head = tail_pos;\n-                    for i in range(0, len) {\n+                    for i in 0..len {\n                         if i != to_insert {\n                             tester.push_back(i);\n                         }\n@@ -2573,14 +2573,14 @@ mod tests {\n         let cap = tester.capacity();\n \n         // len is the length *after* removal\n-        for len in range(0, cap - 1) {\n+        for len in 0..cap - 1 {\n             // 0, 1, 2, .., len - 1\n             let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in range(0, cap) {\n-                for to_remove in range(0, len + 1) {\n+            for tail_pos in 0..cap {\n+                for to_remove in 0..len + 1 {\n                     tester.tail = tail_pos;\n                     tester.head = tail_pos;\n-                    for i in range(0, len) {\n+                    for i in 0..len {\n                         if i == to_remove {\n                             tester.push_back(1234);\n                         }\n@@ -2611,14 +2611,14 @@ mod tests {\n         tester.reserve(63);\n         let max_cap = tester.capacity();\n \n-        for len in range(0, cap + 1) {\n+        for len in 0..cap + 1 {\n             // 0, 1, 2, .., len - 1\n             let expected = iter::count(0, 1).take(len).collect();\n-            for tail_pos in range(0, max_cap + 1) {\n+            for tail_pos in 0..max_cap + 1 {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n                 tester.reserve(63);\n-                for i in range(0, len) {\n+                for i in 0..len {\n                     tester.push_back(i);\n                 }\n                 tester.shrink_to_fit();\n@@ -2648,20 +2648,20 @@ mod tests {\n         let cap = ring.capacity() as int;\n         let first = cap/2;\n         let last  = cap - first;\n-        for i in range(0, first) {\n+        for i in 0..first {\n             ring.push_back(i);\n \n             let (left, right) = ring.as_slices();\n-            let expected: Vec<_> = range(0, i+1).collect();\n+            let expected: Vec<_> = (0..i+1).collect();\n             assert_eq!(left, expected);\n             assert_eq!(right, []);\n         }\n \n-        for j in range(-last, 0) {\n+        for j in -last..0 {\n             ring.push_front(j);\n             let (left, right) = ring.as_slices();\n-            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n-            let expected_right: Vec<_> = range(0, first).collect();\n+            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+            let expected_right: Vec<_> = (0..first).collect();\n             assert_eq!(left, expected_left);\n             assert_eq!(right, expected_right);\n         }\n@@ -2676,20 +2676,20 @@ mod tests {\n         let cap = ring.capacity() as int;\n         let first = cap/2;\n         let last  = cap - first;\n-        for i in range(0, first) {\n+        for i in 0..first {\n             ring.push_back(i);\n \n             let (left, right) = ring.as_mut_slices();\n-            let expected: Vec<_> = range(0, i+1).collect();\n+            let expected: Vec<_> = (0..i+1).collect();\n             assert_eq!(left, expected);\n             assert_eq!(right, []);\n         }\n \n-        for j in range(-last, 0) {\n+        for j in -last..0 {\n             ring.push_front(j);\n             let (left, right) = ring.as_mut_slices();\n-            let expected_left: Vec<_> = range(-last, j+1).rev().collect();\n-            let expected_right: Vec<_> = range(0, first).collect();\n+            let expected_left: Vec<_> = (-last..j+1).rev().collect();\n+            let expected_right: Vec<_> = (0..first).collect();\n             assert_eq!(left, expected_left);\n             assert_eq!(right, expected_right);\n         }"}, {"sha": "ba1be09934fdde858abb4015aa0cc25c074bb3a5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -94,7 +94,7 @@ use core::clone::Clone;\n use core::cmp::Ordering::{self, Greater, Less};\n use core::cmp::{self, Ord, PartialEq};\n use core::iter::{Iterator, IteratorExt};\n-use core::iter::{range, range_step, MultiplicativeIterator};\n+use core::iter::{range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n@@ -1165,7 +1165,7 @@ impl ElementSwaps {\n         // element (equal to the original index).\n         ElementSwaps{\n             emit_reset: true,\n-            sdir: range(0, length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n+            sdir: (0..length).map(|i| SizeDirection{ size: i, dir: Neg }).collect(),\n             swaps_made: 0\n         }\n     }\n@@ -1254,7 +1254,7 @@ impl Iterator for ElementSwaps {\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         // For a vector of size n, there are exactly n! permutations.\n-        let n = range(2, self.sdir.len() + 1).product();\n+        let n = (2..self.sdir.len() + 1).product();\n         (n - self.swaps_made, Some(n - self.swaps_made))\n     }\n }\n@@ -1305,7 +1305,7 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n     let buf_v = v.as_mut_ptr();\n \n     // 1 <= i < len;\n-    for i in range(1, len) {\n+    for i in 1..len {\n         // j satisfies: 0 <= j <= i;\n         let mut j = i;\n         unsafe {\n@@ -1385,7 +1385,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // .offset-ing.\n     for start in range_step(0, len, insertion) {\n         // start <= i < len;\n-        for i in range(start, cmp::min(start + insertion, len)) {\n+        for i in start..cmp::min(start + insertion, len) {\n             // j satisfies: start <= j <= i;\n             let mut j = i as int;\n             unsafe {\n@@ -1526,7 +1526,7 @@ mod tests {\n     #[test]\n     fn test_from_fn() {\n         // Test on-stack from_fn.\n-        let mut v = range(0, 3).map(square).collect::<Vec<_>>();\n+        let mut v = (0u..3).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 3u);\n@@ -1536,7 +1536,7 @@ mod tests {\n         }\n \n         // Test on-heap from_fn.\n-        v = range(0, 5).map(square).collect::<Vec<_>>();\n+        v = (0u..5).map(square).collect::<Vec<_>>();\n         {\n             let v = v.as_slice();\n             assert_eq!(v.len(), 5u);\n@@ -2097,8 +2097,8 @@ mod tests {\n \n     #[test]\n     fn test_sort() {\n-        for len in range(4u, 25) {\n-            for _ in range(0i, 100) {\n+        for len in 4u..25 {\n+            for _ in 0i..100 {\n                 let mut v = thread_rng().gen_iter::<uint>().take(len)\n                                       .collect::<Vec<uint>>();\n                 let mut v1 = v.clone();\n@@ -2125,16 +2125,16 @@ mod tests {\n \n     #[test]\n     fn test_sort_stability() {\n-        for len in range(4i, 25) {\n-            for _ in range(0u, 10) {\n+        for len in 4i..25 {\n+            for _ in 0u..10 {\n                 let mut counts = [0i; 10];\n \n                 // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n                 // where the first item of each tuple is random, but\n                 // the second item represents which occurrence of that\n                 // number this element is, i.e. the second elements\n                 // will occur in sorted order.\n-                let mut v = range(0, len).map(|_| {\n+                let mut v = (0..len).map(|_| {\n                         let n = thread_rng().gen::<uint>() % 10;\n                         counts[n] += 1;\n                         (n, counts[n])\n@@ -2717,13 +2717,13 @@ mod tests {\n     #[test]\n     fn test_shrink_to_fit() {\n         let mut xs = vec![0, 1, 2, 3];\n-        for i in range(4i, 100) {\n+        for i in 4i..100 {\n             xs.push(i)\n         }\n         assert_eq!(xs.capacity(), 128);\n         xs.shrink_to_fit();\n         assert_eq!(xs.capacity(), 100);\n-        assert_eq!(xs, range(0i, 100i).collect::<Vec<_>>());\n+        assert_eq!(xs, (0i..100i).collect::<Vec<_>>());\n     }\n \n     #[test]\n@@ -2854,7 +2854,7 @@ mod bench {\n     fn iterator(b: &mut Bencher) {\n         // peculiar numbers to stop LLVM from optimising the summation\n         // out.\n-        let v = range(0u, 100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n+        let v = (0u..100).map(|i| i ^ (i << 1) ^ (i >> 1)).collect::<Vec<_>>();\n \n         b.iter(|| {\n             let mut sum = 0;\n@@ -2882,7 +2882,7 @@ mod bench {\n     #[bench]\n     fn concat(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            (0..100u).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.concat();\n         });\n@@ -2891,7 +2891,7 @@ mod bench {\n     #[bench]\n     fn connect(b: &mut Bencher) {\n         let xss: Vec<Vec<uint>> =\n-            range(0, 100u).map(|i| range(0, i).collect()).collect();\n+            (0..100u).map(|i| (0..i).collect()).collect();\n         b.iter(|| {\n             xss.connect(&0)\n         });\n@@ -2908,7 +2908,7 @@ mod bench {\n \n     #[bench]\n     fn starts_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0u..100).collect();\n         b.iter(|| {\n             vec.starts_with(vec.as_slice())\n         })\n@@ -2924,8 +2924,8 @@ mod bench {\n \n     #[bench]\n     fn starts_with_diff_one_element_at_end(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 99).collect();\n+        let vec: Vec<uint> = (0u..100).collect();\n+        let mut match_vec: Vec<uint> = (0u..99).collect();\n         match_vec.push(0);\n         b.iter(|| {\n             vec.starts_with(match_vec.as_slice())\n@@ -2934,7 +2934,7 @@ mod bench {\n \n     #[bench]\n     fn ends_with_same_vector(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0u..100).collect();\n         b.iter(|| {\n             vec.ends_with(vec.as_slice())\n         })\n@@ -2950,8 +2950,8 @@ mod bench {\n \n     #[bench]\n     fn ends_with_diff_one_element_at_beginning(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n-        let mut match_vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0u..100).collect();\n+        let mut match_vec: Vec<uint> = (0u..100).collect();\n         match_vec.as_mut_slice()[0] = 200;\n         b.iter(|| {\n             vec.starts_with(match_vec.as_slice())\n@@ -2960,7 +2960,7 @@ mod bench {\n \n     #[bench]\n     fn contains_last_element(b: &mut Bencher) {\n-        let vec: Vec<uint> = range(0, 100).collect();\n+        let vec: Vec<uint> = (0u..100).collect();\n         b.iter(|| {\n             vec.contains(&99u)\n         })\n@@ -2993,7 +2993,7 @@ mod bench {\n             unsafe {\n                 v.set_len(1024);\n             }\n-            for i in range(0u, 1024) {\n+            for i in 0u..1024 {\n                 v[i] = 0;\n             }\n         });\n@@ -3018,7 +3018,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v = repeat((0u, 0u)).take(30).collect::<Vec<_>>();\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 let l = v.len();\n                 v.insert(rng.gen::<uint>() % (l + 1),\n                          (1, 1));\n@@ -3030,7 +3030,7 @@ mod bench {\n         let mut rng = weak_rng();\n         b.iter(|| {\n             let mut v = repeat((0u, 0u)).take(130).collect::<Vec<_>>();\n-            for _ in range(0u, 100) {\n+            for _ in 0u..100 {\n                 let l = v.len();\n                 v.remove(rng.gen::<uint>() % l);\n             }\n@@ -3069,7 +3069,7 @@ mod bench {\n \n     #[bench]\n     fn sort_sorted(b: &mut Bencher) {\n-        let mut v = range(0u, 10000).collect::<Vec<_>>();\n+        let mut v = (0u..10000).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });\n@@ -3113,7 +3113,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v = range(0, 10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n+        let mut v = (0..10000u).map(|i| (i, i, i, i)).collect::<Vec<_>>();\n         b.iter(|| {\n             v.sort();\n         });"}, {"sha": "5a1162b5c084a9c2890fa869995ca7830d44513d", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -59,7 +59,7 @@ use core::borrow::{BorrowFrom, ToOwned};\n use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n-use core::iter::{range, Iterator, IteratorExt};\n+use core::iter::{Iterator, IteratorExt};\n use core::ops::{FullRange, Index};\n use core::option::Option::{self, Some, None};\n use core::slice::AsSlice;\n@@ -142,9 +142,9 @@ Section: Iterators\n // Helper functions used for Unicode normalization\n fn canonical_sort(comb: &mut [(char, u8)]) {\n     let len = comb.len();\n-    for i in range(0, len) {\n+    for i in 0..len {\n         let mut swapped = false;\n-        for j in range(1, len-i) {\n+        for j in 1..len-i {\n             let class_a = comb[j-1].1;\n             let class_b = comb[j].1;\n             if class_a != 0 && class_b != 0 && class_a > class_b {\n@@ -2122,7 +2122,7 @@ mod tests {\n     #[test]\n     fn test_chars_decoding() {\n         let mut bytes = [0u8; 4];\n-        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+        for c in (0u32..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n@@ -2134,7 +2134,7 @@ mod tests {\n     #[test]\n     fn test_chars_rev_decoding() {\n         let mut bytes = [0u8; 4];\n-        for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n+        for c in (0u32..0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(&bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {"}, {"sha": "8f7920fe1c44bcd2207400678d7c44c5371499cc", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -41,7 +41,7 @@ pub struct String {\n \n /// A possible error value from the `String::from_utf8` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -50,7 +50,7 @@ pub struct FromUtf8Error {\n /// A possible error value from the `String::from_utf16` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_copy_implementations)]\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct FromUtf16Error(());\n \n impl String {\n@@ -1354,7 +1354,7 @@ mod tests {\n         b.bytes = REPETITIONS;\n         b.iter(|| {\n             let mut r = String::new();\n-            for _ in range(0, REPETITIONS) {\n+            for _ in 0..REPETITIONS {\n                 r.push_str(\"a\")\n             }\n         });\n@@ -1365,7 +1365,7 @@ mod tests {\n         b.bytes = REPETITIONS;\n         b.iter(|| {\n             let mut r = String::new();\n-            for _ in range(0, REPETITIONS) {\n+            for _ in 0..REPETITIONS {\n                 r.push('a')\n             }\n         });\n@@ -1376,7 +1376,7 @@ mod tests {\n         b.bytes = REPETITIONS * 2;\n         b.iter(|| {\n             let mut r = String::new();\n-            for _ in range(0, REPETITIONS) {\n+            for _ in 0..REPETITIONS {\n                 r.push('\u00e2')\n             }\n         });"}, {"sha": "336a3d7521a195eea6e3fd4a8bf6854bf8949206", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -186,7 +186,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.len(), 0);\n     ///\n     /// // These are all done without reallocating...\n-    /// for i in range(0i, 10) {\n+    /// for i in 0i..10 {\n     ///     vec.push(i);\n     /// }\n     ///\n@@ -233,7 +233,7 @@ impl<T> Vec<T> {\n     ///         mem::forget(v);\n     ///\n     ///         // Overwrite memory with 4, 5, 6\n-    ///         for i in range(0, len as int) {\n+    ///         for i in 0..len as int {\n     ///             ptr::write(p.offset(i), 4 + i);\n     ///         }\n     ///\n@@ -605,7 +605,7 @@ impl<T> Vec<T> {\n         {\n             let v = self.as_mut_slice();\n \n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 if !f(&v[i]) {\n                     del += 1;\n                 } else if del > 0 {\n@@ -811,7 +811,7 @@ impl<T> Vec<T> {\n     /// let w = v.map_in_place(|i| i + 3);\n     /// assert_eq!(w.as_slice(), [3, 4, 5].as_slice());\n     ///\n-    /// #[derive(PartialEq, Show)]\n+    /// #[derive(PartialEq, Debug)]\n     /// struct Newtype(u8);\n     /// let bytes = vec![0x11, 0x22];\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n@@ -1079,7 +1079,7 @@ impl<T: Clone> Vec<T> {\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n \n-        for i in range(0, other.len()) {\n+        for i in 0..other.len() {\n             let len = self.len();\n \n             // Unsafe code so this can be optimised to a memcpy (or something similarly\n@@ -1969,7 +1969,7 @@ mod tests {\n         v.reserve(2);\n         assert!(v.capacity() >= 2);\n \n-        for i in range(0i, 16) {\n+        for i in 0i..16 {\n             v.push(i);\n         }\n \n@@ -1988,13 +1988,13 @@ mod tests {\n         let mut v = Vec::new();\n         let mut w = Vec::new();\n \n-        v.extend(range(0i, 3));\n-        for i in range(0i, 3) { w.push(i) }\n+        v.extend(0i..3);\n+        for i in 0i..3 { w.push(i) }\n \n         assert_eq!(v, w);\n \n-        v.extend(range(3i, 10));\n-        for i in range(3i, 10) { w.push(i) }\n+        v.extend(3i..10);\n+        for i in 3i..10 { w.push(i) }\n \n         assert_eq!(v, w);\n     }\n@@ -2279,7 +2279,7 @@ mod tests {\n     #[test]\n     fn test_map_in_place_zero_sized() {\n         let v = vec![(), ()];\n-        #[derive(PartialEq, Show)]\n+        #[derive(PartialEq, Debug)]\n         struct ZeroSized;\n         assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n     }\n@@ -2288,11 +2288,11 @@ mod tests {\n     fn test_map_in_place_zero_drop_count() {\n         use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n-        #[derive(Clone, PartialEq, Show)]\n+        #[derive(Clone, PartialEq, Debug)]\n         struct Nothing;\n         impl Drop for Nothing { fn drop(&mut self) { } }\n \n-        #[derive(Clone, PartialEq, Show)]\n+        #[derive(Clone, PartialEq, Debug)]\n         struct ZeroSized;\n         impl Drop for ZeroSized {\n             fn drop(&mut self) {\n@@ -2442,7 +2442,7 @@ mod tests {\n         b.bytes = src_len as u64;\n \n         b.iter(|| {\n-            let dst = range(0, src_len).collect::<Vec<_>>();\n+            let dst = (0..src_len).collect::<Vec<_>>();\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         })\n@@ -2499,7 +2499,7 @@ mod tests {\n     }\n \n     fn do_bench_from_slice(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2531,7 +2531,7 @@ mod tests {\n     }\n \n     fn do_bench_from_iter(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2563,8 +2563,8 @@ mod tests {\n     }\n \n     fn do_bench_extend(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(range(0, dst_len));\n-        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2612,8 +2612,8 @@ mod tests {\n     }\n \n     fn do_bench_push_all(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(range(0, dst_len));\n-        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+        let dst: Vec<uint> = FromIterator::from_iter(0..dst_len);\n+        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2661,8 +2661,8 @@ mod tests {\n     }\n \n     fn do_bench_push_all_move(b: &mut Bencher, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(range(0u, dst_len));\n-        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+        let dst: Vec<uint> = FromIterator::from_iter(0u..dst_len);\n+        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2710,7 +2710,7 @@ mod tests {\n     }\n \n     fn do_bench_clone(b: &mut Bencher, src_len: uint) {\n-        let src: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n+        let src: Vec<uint> = FromIterator::from_iter(0..src_len);\n \n         b.bytes = src_len as u64;\n \n@@ -2742,15 +2742,15 @@ mod tests {\n     }\n \n     fn do_bench_clone_from(b: &mut Bencher, times: uint, dst_len: uint, src_len: uint) {\n-        let dst: Vec<uint> = FromIterator::from_iter(range(0, src_len));\n-        let src: Vec<uint> = FromIterator::from_iter(range(dst_len, dst_len + src_len));\n+        let dst: Vec<uint> = FromIterator::from_iter(0..src_len);\n+        let src: Vec<uint> = FromIterator::from_iter(dst_len..dst_len + src_len);\n \n         b.bytes = (times * src_len) as u64;\n \n         b.iter(|| {\n             let mut dst = dst.clone();\n \n-            for _ in range(0, times) {\n+            for _ in 0..times {\n                 dst.clone_from(&src);\n \n                 assert_eq!(dst.len(), src_len);"}, {"sha": "9f83b91fc9bbd972c81c8b0f5616c37a7bfd4add", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -459,7 +459,7 @@ impl<V> VecMap<V> {\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n-            self.v.extend(range(0, key - len + 1).map(|_| None));\n+            self.v.extend((0..key - len + 1).map(|_| None));\n         }\n         replace(&mut self.v[key], Some(value))\n     }"}, {"sha": "40c2d82bf4b3f78f61027df746908917a03e464f", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -166,8 +166,7 @@ impl Any {\n ///\n /// A `TypeId` is currently only available for types which ascribe to `'static`,\n /// but this limitation may be removed in the future.\n-#[cfg_attr(stage0, lang = \"type_id\")]\n-#[derive(Clone, Copy, PartialEq, Eq, Show, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct TypeId {\n     t: u64,"}, {"sha": "035443e9c3f35466a189e7b45bddb9a2092055cf", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -125,7 +125,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n /// use std::borrow::Cow;\n ///\n /// fn abs_all(input: &mut Cow<Vec<int>, [int]>) {\n-///     for i in range(0, input.len()) {\n+///     for i in 0..input.len() {\n ///         let v = input[i];\n ///         if v < 0 {\n ///             // clones into a vector the first time (if not already owned)"}, {"sha": "1ebd2df5814d16ca0f660d4365125df6a28fab84", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -105,7 +105,7 @@ pub trait Eq: PartialEq<Self> {\n }\n \n /// An ordering is, e.g, a result of a comparison between two values.\n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Ordering {\n     /// An ordering where a compared value is less [than another]."}, {"sha": "0963afaf72e21009c2a372fe97de5756153b11e2", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -17,7 +17,7 @@ pub use self::SignFormat::*;\n use char;\n use char::CharExt;\n use fmt;\n-use iter::{IteratorExt, range};\n+use iter::IteratorExt;\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n use ops::FnOnce;\n@@ -242,7 +242,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                     if i < 0\n                     || buf[i as uint] == b'-'\n                     || buf[i as uint] == b'+' {\n-                        for j in range(i as uint + 1, end).rev() {\n+                        for j in (i as uint + 1..end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n                         buf[(i + 1) as uint] = value2ascii(1);"}, {"sha": "8b7a4c677ac753426189ea66ea1790ed0d6e662c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -16,7 +16,7 @@\n use any;\n use cell::{Cell, RefCell, Ref, RefMut};\n use char::CharExt;\n-use iter::{Iterator, IteratorExt, range};\n+use iter::{Iterator, IteratorExt};\n use marker::{Copy, Sized};\n use mem;\n use option::Option;\n@@ -32,9 +32,6 @@ pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n-#[cfg(stage0)] pub use self::Debug as Show;\n-#[cfg(stage0)] pub use self::Display as String;\n-\n mod num;\n mod float;\n pub mod rt;\n@@ -51,7 +48,7 @@ pub type Result = result::Result<(), Error>;\n /// some other means.\n #[unstable(feature = \"core\",\n            reason = \"core and I/O reconciliation may alter this definition\")]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct Error;\n \n /// A collection of methods that are required to format a message into a stream.\n@@ -243,7 +240,6 @@ impl<'a> Display for Arguments<'a> {\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Debug\")]\n-#[cfg(not(stage0))]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -261,7 +257,6 @@ pub trait Debug {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-#[cfg(not(stage0))]\n impl<T: Show + ?Sized> Debug for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n@@ -271,7 +266,6 @@ impl<T: Show + ?Sized> Debug for T {\n /// used. It corresponds to the default format, `{}`.\n #[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\", reason = \"renamed to Display\")]\n-#[cfg(not(stage0))]\n pub trait String {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n@@ -288,7 +282,6 @@ pub trait Display {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-#[cfg(not(stage0))]\n impl<T: String + ?Sized> Display for T {\n     #[allow(deprecated)]\n     fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }\n@@ -596,13 +589,13 @@ impl<'a> Formatter<'a> {\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n         let fill = unsafe { str::from_utf8_unchecked(&fill[..len]) };\n \n-        for _ in range(0, pre_pad) {\n+        for _ in 0..pre_pad {\n             try!(self.buf.write_str(fill));\n         }\n \n         try!(f(self));\n \n-        for _ in range(0, post_pad) {\n+        for _ in 0..post_pad {\n             try!(self.buf.write_str(fill));\n         }\n "}, {"sha": "125e8a0e81476fe0653d8bf6905bdaced9fe9652", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -197,12 +197,8 @@ extern \"rust-intrinsic\" {\n     pub fn pref_align_of<T>() -> uint;\n \n     /// Get a static pointer to a type descriptor.\n-    #[cfg(not(stage0))]\n     pub fn get_tydesc<T: ?Sized>() -> *const TyDesc;\n \n-    #[cfg(stage0)]\n-    pub fn get_tydesc<T>() -> *const TyDesc;\n-\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in."}, {"sha": "b6b2f9c57fe7b77a26dd071e2c4c8c8a2ae1138a", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -101,8 +101,6 @@ pub trait Iterator {\n     fn size_hint(&self) -> (usize, Option<usize>) { (0, None) }\n }\n \n-// FIXME(#21363) remove `old_impl_check` when bug is fixed\n-#[old_impl_check]\n impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n     type Item = T;\n \n@@ -717,7 +715,7 @@ pub trait IteratorExt: Iterator + Sized {\n         Self: ExactSizeIterator + DoubleEndedIterator\n     {\n         let len = self.len();\n-        for i in range(0, len).rev() {\n+        for i in (0..len).rev() {\n             if predicate(self.next_back().expect(\"rposition: incorrect ExactSizeIterator\")) {\n                 return Some(i);\n             }\n@@ -1226,7 +1224,7 @@ impl_multiplicative! { f32,  1.0 }\n impl_multiplicative! { f64,  1.0 }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n #[unstable(feature = \"core\",\n            reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n@@ -1509,9 +1507,9 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n         if a_sz != b_sz {\n             // Adjust a, b to equal length\n             if a_sz > b_sz {\n-                for _ in range(0, a_sz - b_sz) { self.a.next_back(); }\n+                for _ in 0..a_sz - b_sz { self.a.next_back(); }\n             } else {\n-                for _ in range(0, b_sz - a_sz) { self.b.next_back(); }\n+                for _ in 0..b_sz - a_sz { self.b.next_back(); }\n             }\n         }\n         match (self.a.next_back(), self.b.next_back()) {"}, {"sha": "81ce0610923e5be3549392eb2b158b0ade5310a4", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -64,8 +64,6 @@\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(on_unimplemented)]\n-// FIXME(#21363) remove `old_impl_check` when bug is fixed\n-#![feature(old_impl_check)]\n #![deny(missing_docs)]\n \n #[macro_use]"}, {"sha": "299cdbda3cc7481a3087d625cb807fb0eef4e212", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -50,7 +50,7 @@ pub trait Sized {\n /// words:\n ///\n /// ```\n-/// #[derive(Show)]\n+/// #[derive(Debug)]\n /// struct Foo;\n ///\n /// let x = Foo;\n@@ -66,7 +66,7 @@ pub trait Sized {\n ///\n /// ```\n /// // we can just derive a `Copy` implementation\n-/// #[derive(Show, Copy)]\n+/// #[derive(Debug, Copy)]\n /// struct Foo;\n ///\n /// let x = Foo;"}, {"sha": "9ccea3b0739389b42a5d9c5e5fa17eec91a7f5b9", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -31,7 +31,7 @@ unsafe impl Zeroable for u64 {}\n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show, Hash)]\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]\n #[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n "}, {"sha": "dd9cc553c7c8f34b6a80aff46537fbf2956d89a2", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1241,7 +1241,7 @@ impl_num_cast! { f32,   to_f32 }\n impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n #[unstable(feature = \"core\", reason = \"may be renamed\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero"}, {"sha": "55ff3eb4d062d8bc7be2967c379931343591c5ff", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -35,7 +35,7 @@\n //! ```rust\n //! use std::ops::{Add, Sub};\n //!\n-//! #[derive(Show)]\n+//! #[derive(Debug)]\n //! struct Point {\n //!     x: int,\n //!     y: int"}, {"sha": "5cb8e5e556523cfa82d50375aa0edac1d94122ab", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -163,7 +163,7 @@ use slice;\n // which basically means it must be `Option`.\n \n /// The `Option` type.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value"}, {"sha": "92a7465038bb105387ee43921eb85e0676f3a06d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -30,7 +30,7 @@\n //! defined and used like so:\n //!\n //! ```\n-//! #[derive(Show)]\n+//! #[derive(Debug)]\n //! enum Version { Version1, Version2 }\n //!\n //! fn parse_version(header: &[u8]) -> Result<Version, &'static str> {\n@@ -239,7 +239,7 @@ use slice;\n /// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show, Hash)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Result<T, E> {"}, {"sha": "0058971faf0796d45727470afdac4e56a734947a", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -38,7 +38,7 @@\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n@@ -47,26 +47,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n@@ -75,31 +75,31 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n #[unstable(feature = \"core\")]\n #[simd]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n #[repr(C)]\n pub struct f64x2(pub f64, pub f64);"}, {"sha": "b1e9084d210f5c77d5f6258c012ecae0e5b64ce1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -482,7 +482,7 @@ impl<T> SliceExt for [T] {\n         let min = cmp::min(self.len(), src.len());\n         let dst = &mut self[.. min];\n         let src = &src[.. min];\n-        for i in range(0, min) {\n+        for i in 0..min {\n             dst[i].clone_from(&src[i]);\n         }\n         min"}, {"sha": "228519656446c5917ffa6c65c26b3905bac338d0", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -23,7 +23,6 @@ use default::Default;\n use error::Error;\n use fmt;\n use iter::ExactSizeIterator;\n-use iter::range;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n@@ -145,7 +144,7 @@ Section: Creating a string\n */\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n-#[derive(Copy, Eq, PartialEq, Clone, Show)]\n+#[derive(Copy, Eq, PartialEq, Clone, Debug)]\n #[unstable(feature = \"core\",\n            reason = \"error enumeration recently added and definitions may be refined\")]\n pub enum Utf8Error {\n@@ -800,7 +799,7 @@ impl TwoWaySearcher {\n             // See if the right part of the needle matches\n             let start = if long_period { self.crit_pos }\n                         else { cmp::max(self.crit_pos, self.memory) };\n-            for i in range(start, needle.len()) {\n+            for i in start..needle.len() {\n                 if needle[i] != haystack[self.position + i] {\n                     self.position += i - self.crit_pos + 1;\n                     if !long_period {\n@@ -812,7 +811,7 @@ impl TwoWaySearcher {\n \n             // See if the left part of the needle matches\n             let start = if long_period { 0 } else { self.memory };\n-            for i in range(start, self.crit_pos).rev() {\n+            for i in (start..self.crit_pos).rev() {\n                 if needle[i] != haystack[self.position + i] {\n                     self.position += self.period;\n                     if !long_period {"}, {"sha": "7c71c733662e8e0bedcb8a1650deb509c7d3572e", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@ use core::any::*;\n use test::Bencher;\n use test;\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct Test;\n \n static TEST: &'static str = \"Test\";"}, {"sha": "8bcd4982fba5d11b6ed388e799a3e2ff2a1fad57", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -305,7 +305,7 @@ fn test_cycle() {\n #[test]\n fn test_iterator_nth() {\n     let v: &[_] = &[0i, 1, 2, 3, 4];\n-    for i in range(0u, v.len()) {\n+    for i in 0u..v.len() {\n         assert_eq!(v.iter().nth(i).unwrap(), &v[i]);\n     }\n     assert_eq!(v.iter().nth(v.len()), None);\n@@ -458,7 +458,7 @@ fn test_min_by() {\n \n #[test]\n fn test_by_ref() {\n-    let mut xs = range(0i, 10);\n+    let mut xs = 0i..10;\n     // sum the first five values\n     let partial_sum = xs.by_ref().take(5).fold(0, |a, b| a + b);\n     assert_eq!(partial_sum, 10);\n@@ -730,32 +730,32 @@ fn test_random_access_cycle() {\n \n #[test]\n fn test_double_ended_range() {\n-    assert!(range(11i, 14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n-    for _ in range(10i, 0).rev() {\n+    assert!((11i..14).rev().collect::<Vec<int>>() == vec![13i, 12, 11]);\n+    for _ in (10i..0).rev() {\n         panic!(\"unreachable\");\n     }\n \n-    assert!(range(11u, 14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n-    for _ in range(10u, 0).rev() {\n+    assert!((11u..14).rev().collect::<Vec<uint>>() == vec![13u, 12, 11]);\n+    for _ in (10u..0).rev() {\n         panic!(\"unreachable\");\n     }\n }\n \n #[test]\n fn test_range() {\n-    assert!(range(0i, 5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n-    assert!(range(-10i, -1).collect::<Vec<int>>() ==\n+    assert!((0i..5).collect::<Vec<int>>() == vec![0i, 1, 2, 3, 4]);\n+    assert!((-10i..-1).collect::<Vec<int>>() ==\n                vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-    assert!(range(0i, 5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n-    assert_eq!(range(200i, -5).count(), 0);\n-    assert_eq!(range(200i, -5).rev().count(), 0);\n-    assert_eq!(range(200i, 200).count(), 0);\n-    assert_eq!(range(200i, 200).rev().count(), 0);\n+    assert!((0i..5).rev().collect::<Vec<int>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!((200i..-5).count(), 0);\n+    assert_eq!((200i..-5).rev().count(), 0);\n+    assert_eq!((200i..200).count(), 0);\n+    assert_eq!((200i..200).rev().count(), 0);\n \n-    assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n+    assert_eq!((0i..100).size_hint(), (100, Some(100)));\n     // this test is only meaningful when sizeof uint < sizeof u64\n-    assert_eq!(range(uint::MAX - 1, uint::MAX).size_hint(), (1, Some(1)));\n-    assert_eq!(range(-10i, -1).size_hint(), (9, Some(9)));\n+    assert_eq!((uint::MAX - 1..uint::MAX).size_hint(), (1, Some(1)));\n+    assert_eq!((-10i..-1).size_hint(), (9, Some(9)));\n }\n \n #[test]\n@@ -883,7 +883,7 @@ fn test_fuse() {\n \n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n-    let it: Vec<uint> = range(0u, 300).collect();\n+    let it: Vec<uint> = (0u..300).collect();\n     b.iter(|| {\n         it.iter().rposition(|&x| x <= 150);\n     });\n@@ -892,18 +892,18 @@ fn bench_rposition(b: &mut Bencher) {\n #[bench]\n fn bench_skip_while(b: &mut Bencher) {\n     b.iter(|| {\n-        let it = range(0u, 100);\n+        let it = 0u..100;\n         let mut sum = 0;\n         it.skip_while(|&x| { sum += x; sum < 4000 }).all(|_| true);\n     });\n }\n \n #[bench]\n fn bench_multiple_take(b: &mut Bencher) {\n-    let mut it = range(0u, 42).cycle();\n+    let mut it = (0u..42).cycle();\n     b.iter(|| {\n         let n = it.next().unwrap();\n-        for _ in range(0u, n) {\n+        for _ in 0u..n {\n             it.take(it.next().unwrap()).all(|_| true);\n         }\n     });"}, {"sha": "bb9d1524786829f9f92916685ef545e848e258a5", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -223,13 +223,13 @@ fn test_ord() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Option<Vec<int>> = range(0i, 0).map(|_| Some(0i)).collect();\n+    let v: Option<Vec<int>> = (0i..0).map(|_| Some(0i)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = range(0i, 3).map(|x| Some(x)).collect();\n+    let v: Option<Vec<int>> = (0i..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = range(0i, 3).map(|x| {\n+    let v: Option<Vec<int>> = (0i..3).map(|x| {\n         if x > 1 { None } else { Some(x) }\n     }).collect();\n     assert!(v == None);"}, {"sha": "d36228fa3d75b30a8ae38a9a575d31c3669f9fa5", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -68,13 +68,13 @@ pub fn test_impl_map_err() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = range(0i, 0).map(|_| Ok::<int, ()>(0)).collect();\n+    let v: Result<Vec<int>, ()> = (0i..0).map(|_| Ok::<int, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = range(0i, 3).map(|x| Ok::<int, ()>(x)).collect();\n+    let v: Result<Vec<int>, ()> = (0i..3).map(|x| Ok::<int, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = range(0i, 3).map(|x| {\n+    let v: Result<Vec<int>, int> = (0i..3).map(|x| {\n         if x > 1 { Err(x) } else { Ok(x) }\n     }).collect();\n     assert!(v == Err(2));"}, {"sha": "938755113b524e1fb05b0ca1d7d154327a6c0d30", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -17,7 +17,7 @@ fn test_bool_from_str() {\n \n fn check_contains_all_substrings(s: &str) {\n     assert!(s.contains(\"\"));\n-    for i in range(0, s.len()) {\n+    for i in 0..s.len() {\n         for j in range(i+1, s.len() + 1) {\n             assert!(s.contains(&s[i..j]));\n         }"}, {"sha": "5c868ce6910e7cc828ff587d421c29113132c6bb", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -138,14 +138,14 @@ mod tests {\n     fn test_flate_round_trip() {\n         let mut r = rand::thread_rng();\n         let mut words = vec!();\n-        for _ in range(0u, 20) {\n+        for _ in 0u..20 {\n             let range = r.gen_range(1u, 10);\n             let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n             words.push(v);\n         }\n-        for _ in range(0u, 20) {\n+        for _ in 0u..20 {\n             let mut input = vec![];\n-            for _ in range(0u, 2000) {\n+            for _ in 0u..2000 {\n                 input.push_all(r.choose(words.as_slice()).unwrap().as_slice());\n             }\n             debug!(\"de/inflate of {} bytes of random word-sequences\","}, {"sha": "7b86dab8a7cfd808a21f1b7205c5678b917bad9d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -111,7 +111,7 @@ use std::iter::repeat;\n use std::result;\n \n /// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Name {\n     /// A string representing the long name of an option.\n     /// For example: \"help\"\n@@ -122,7 +122,7 @@ pub enum Name {\n }\n \n /// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum HasArg {\n     /// The option requires an argument.\n     Yes,\n@@ -133,7 +133,7 @@ pub enum HasArg {\n }\n \n /// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum Occur {\n     /// The option occurs once.\n     Req,\n@@ -144,7 +144,7 @@ pub enum Occur {\n }\n \n /// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Opt {\n     /// Name of the option\n     pub name: Name,\n@@ -158,7 +158,7 @@ pub struct Opt {\n \n /// One group of options, e.g., both `-h` and `--help`, along with\n /// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct OptGroup {\n     /// Short name of the option, e.g. `h` for a `-h` option\n     pub short_name: String,\n@@ -175,15 +175,15 @@ pub struct OptGroup {\n }\n \n /// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n enum Optval {\n     Val(String),\n     Given,\n }\n \n /// The result of checking command line arguments. Contains a vector\n /// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct Matches {\n     /// Options that matched\n     opts: Vec<Opt>,\n@@ -196,7 +196,7 @@ pub struct Matches {\n /// The type returned when the command line does not conform to the\n /// expected format. Use the `Show` implementation to output detailed\n /// information.\n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub enum Fail {\n     /// The option requires an argument but none was passed.\n     ArgumentMissing(String),\n@@ -211,7 +211,7 @@ pub enum Fail {\n }\n \n /// The type of failure that occurred.\n-#[derive(Copy, PartialEq, Eq, Show)]\n+#[derive(Copy, PartialEq, Eq, Debug)]\n #[allow(missing_docs)]\n pub enum FailType {\n     ArgumentMissing_,\n@@ -586,7 +586,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals: Vec<_> = range(0, n_opts).map(f).collect();\n+    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;\n@@ -693,7 +693,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n         }\n         i += 1;\n     }\n-    for i in range(0u, n_opts) {\n+    for i in 0u..n_opts {\n         let n = vals[i].len();\n         let occ = opts[i].occur;\n         if occ == Req && n == 0 {\n@@ -761,7 +761,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n         // here we just need to indent the start of the description\n         let rowlen = row.chars().count();\n         if rowlen < 24 {\n-            for _ in range(0, 24 - rowlen) {\n+            for _ in 0..24 - rowlen {\n                 row.push(' ');\n             }\n         } else {"}, {"sha": "21d5cd3d516ab11fae9e6e30075e16d012ed4011", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -176,7 +176,7 @@\n //! }\n //!\n //! impl<'a> dot::GraphWalk<'a, Nd, Ed<'a>> for Graph {\n-//!     fn nodes(&self) -> dot::Nodes<'a,Nd> { range(0,self.nodes.len()).collect() }\n+//!     fn nodes(&self) -> dot::Nodes<'a,Nd> { (0..self.nodes.len()).collect() }\n //!     fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> { self.edges.iter().collect() }\n //!     fn source(&self, e: &Ed) -> Nd { let & &(s,_) = e; s }\n //!     fn target(&self, e: &Ed) -> Nd { let & &(_,t) = e; t }\n@@ -523,7 +523,7 @@ pub trait GraphWalk<'a, N, E> {\n     fn target(&'a self, edge: &E) -> N;\n }\n \n-#[derive(Copy, PartialEq, Eq, Show)]\n+#[derive(Copy, PartialEq, Eq, Debug)]\n pub enum RenderOption {\n     NoEdgeLabels,\n     NoNodeLabels,\n@@ -715,7 +715,7 @@ mod tests {\n \n     impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraph {\n         fn nodes(&'a self) -> Nodes<'a,Node> {\n-            range(0u, self.node_labels.len()).collect()\n+            (0u..self.node_labels.len()).collect()\n         }\n         fn edges(&'a self) -> Edges<'a,&'a Edge> {\n             self.edges.iter().collect()"}, {"sha": "edd93358bfa4d35d176edb3f8ae1e3ee1ce328ea", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n use std::ascii::AsciiExt;\n use std::cmp;\n \n-#[derive(Show, Clone)]\n+#[derive(Debug, Clone)]\n pub struct LogDirective {\n     pub name: Option<String>,\n     pub level: u32,"}, {"sha": "0e2ab008e1344e7d36aa870cddbd0d2755929a79", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -243,7 +243,7 @@ struct DefaultLogger {\n }\n \n /// Wraps the log level with fmt implementations.\n-#[derive(Copy, PartialEq, PartialOrd, Show)]\n+#[derive(Copy, PartialEq, PartialOrd, Debug)]\n pub struct LogLevel(pub u32);\n \n impl fmt::Display for LogLevel {\n@@ -330,7 +330,7 @@ pub fn set_logger(logger: Box<Logger + Send>) -> Option<Box<Logger + Send>> {\n \n /// A LogRecord is created by the logging macros, and passed as the only\n /// argument to Loggers.\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct LogRecord<'a> {\n \n     /// The module path of where the LogRecord originated."}, {"sha": "6bd971e7b5d62f7640362d21af69eb664901368b", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -69,11 +69,11 @@ macro_rules! double_round{\n fn core(output: &mut [u32; STATE_WORDS], input: &[u32; STATE_WORDS]) {\n     *output = *input;\n \n-    for _ in range(0, CHACHA_ROUNDS / 2) {\n+    for _ in 0..CHACHA_ROUNDS / 2 {\n         double_round!(output);\n     }\n \n-    for i in range(0, STATE_WORDS) {\n+    for i in 0..STATE_WORDS {\n         output[i] += input[i];\n     }\n }\n@@ -128,7 +128,7 @@ impl ChaChaRng {\n         self.state[2] = 0x79622D32;\n         self.state[3] = 0x6B206574;\n \n-        for i in range(0, KEY_WORDS) {\n+        for i in 0..KEY_WORDS {\n             self.state[4+i] = key[i];\n         }\n \n@@ -247,14 +247,14 @@ mod test {\n         let seed : &[_] = &[0u32; 8];\n         let mut ra: ChaChaRng = SeedableRng::from_seed(seed);\n \n-        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xade0b876, 0x903df1a0, 0xe56a5d40, 0x28bd8653,\n                         0xb819d2bd, 0x1aed8da0, 0xccef36a8, 0xc70d778b,\n                         0x7c5941da, 0x8d485751, 0x3fe02477, 0x374ad8b8,\n                         0xf4b8436a, 0x1ca11815, 0x69b687c3, 0x8665eeb2));\n \n-        let v = range(0, 16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..16).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(0xbee7079f, 0x7a385155, 0x7c97ba98, 0x0d082d73,\n                         0xa0290fcb, 0x6965e348, 0x3e53c612, 0xed7aee32,\n@@ -268,9 +268,9 @@ mod test {\n         // Store the 17*i-th 32-bit word,\n         // i.e., the i-th word of the i-th 16-word block\n         let mut v : Vec<u32> = Vec::new();\n-        for _ in range(0u, 16) {\n+        for _ in 0u..16 {\n             v.push(ra.next_u32());\n-            for _ in range(0u, 16) {\n+            for _ in 0u..16 {\n                 ra.next_u32();\n             }\n         }\n@@ -287,7 +287,7 @@ mod test {\n         let seed : &[_] = &[0u32; 8];\n         let mut rng: ChaChaRng = SeedableRng::from_seed(seed);\n         let mut clone = rng.clone();\n-        for _ in range(0u, 16) {\n+        for _ in 0u..16 {\n             assert_eq!(rng.next_u64(), clone.next_u64());\n         }\n     }"}, {"sha": "d7f80c00c90b579c58b8ceeab17e13a1027a3a31", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -103,7 +103,7 @@ mod test {\n     fn test_exp() {\n         let mut exp = Exp::new(10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             assert!(exp.sample(&mut rng) >= 0.0);\n             assert!(exp.ind_sample(&mut rng) >= 0.0);\n         }\n@@ -137,7 +137,7 @@ mod bench {\n         let mut exp = Exp::new(2.71828 * 3.14159);\n \n         b.iter(|| {\n-            for _ in range(0, ::RAND_BENCH_N) {\n+            for _ in 0..::RAND_BENCH_N {\n                 exp.sample(&mut rng);\n             }\n         });"}, {"sha": "19586cbbd691b6ae75edb458f0f840131036f9e8", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -332,7 +332,7 @@ mod test {\n     fn test_chi_squared_one() {\n         let mut chi = ChiSquared::new(1.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -341,7 +341,7 @@ mod test {\n     fn test_chi_squared_small() {\n         let mut chi = ChiSquared::new(0.5);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -350,7 +350,7 @@ mod test {\n     fn test_chi_squared_large() {\n         let mut chi = ChiSquared::new(30.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             chi.sample(&mut rng);\n             chi.ind_sample(&mut rng);\n         }\n@@ -365,7 +365,7 @@ mod test {\n     fn test_f() {\n         let mut f = FisherF::new(2.0, 32.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             f.sample(&mut rng);\n             f.ind_sample(&mut rng);\n         }\n@@ -375,7 +375,7 @@ mod test {\n     fn test_t() {\n         let mut t = StudentT::new(11.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             t.sample(&mut rng);\n             t.ind_sample(&mut rng);\n         }\n@@ -398,7 +398,7 @@ mod bench {\n         let mut rng = ::test::weak_rng();\n \n         b.iter(|| {\n-            for _ in range(0, ::RAND_BENCH_N) {\n+            for _ in 0..::RAND_BENCH_N {\n                 gamma.ind_sample(&mut rng);\n             }\n         });\n@@ -411,7 +411,7 @@ mod bench {\n         let mut rng = ::test::weak_rng();\n \n         b.iter(|| {\n-            for _ in range(0, ::RAND_BENCH_N) {\n+            for _ in 0..::RAND_BENCH_N {\n                 gamma.ind_sample(&mut rng);\n             }\n         });"}, {"sha": "8d87a8e5f0ec0e3fe4bbabc5d99aadfa15fb6fd0", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -97,7 +97,7 @@ pub struct Weighted<T> {\n ///                      Weighted { weight: 1, item: 'c' });\n /// let wc = WeightedChoice::new(items.as_mut_slice());\n /// let mut rng = rand::thread_rng();\n-/// for _ in range(0u, 16) {\n+/// for _ in 0u..16 {\n ///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n ///      println!(\"{}\", wc.ind_sample(&mut rng));\n /// }\n@@ -263,7 +263,7 @@ mod tests {\n     use {Rng, Rand};\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};\n \n-    #[derive(PartialEq, Show)]\n+    #[derive(PartialEq, Debug)]\n     struct ConstRand(uint);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {"}, {"sha": "8fda21e604db38c055948feaf2c0adcc0788eb92", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -169,7 +169,7 @@ mod tests {\n     fn test_normal() {\n         let mut norm = Normal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             norm.sample(&mut rng);\n             norm.ind_sample(&mut rng);\n         }\n@@ -185,7 +185,7 @@ mod tests {\n     fn test_log_normal() {\n         let mut lnorm = LogNormal::new(10.0, 10.0);\n         let mut rng = ::test::rng();\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             lnorm.sample(&mut rng);\n             lnorm.ind_sample(&mut rng);\n         }\n@@ -212,7 +212,7 @@ mod bench {\n         let mut normal = Normal::new(-2.71828, 3.14159);\n \n         b.iter(|| {\n-            for _ in range(0, ::RAND_BENCH_N) {\n+            for _ in 0..::RAND_BENCH_N {\n                 normal.sample(&mut rng);\n             }\n         });"}, {"sha": "e8dedeb8d606bfd594944c17022c04f765d3e1e2", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -41,7 +41,7 @@ use distributions::{Sample, IndependentSample};\n ///     let between = Range::new(10u, 10000u);\n ///     let mut rng = std::rand::thread_rng();\n ///     let mut sum = 0;\n-///     for _ in range(0u, 1000) {\n+///     for _ in 0u..1000 {\n ///         sum += between.ind_sample(&mut rng);\n ///     }\n ///     println!(\"{}\", sum);\n@@ -190,7 +190,7 @@ mod tests {\n                                             (Int::min_value(), Int::max_value())];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in range(0u, 1000) {\n+                        for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);\n@@ -216,7 +216,7 @@ mod tests {\n                                             (-1e35, 1e35)];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n-                        for _ in range(0u, 1000) {\n+                        for _ in 0u..1000 {\n                             let v = sampler.sample(&mut rng);\n                             assert!(low <= v && v < high);\n                             let v = sampler.ind_sample(&mut rng);"}, {"sha": "a22ef704fa5f6c7d5375af41599786672720d5b7", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -82,7 +82,7 @@ impl IsaacRng {\n             }}\n         }\n \n-        for _ in range(0u, 4) {\n+        for _ in 0u..4 {\n             mix!();\n         }\n \n@@ -323,14 +323,14 @@ impl Isaac64Rng {\n             }}\n         }\n \n-        for _ in range(0u, 4) {\n+        for _ in 0u..4 {\n             mix!();\n         }\n \n         if use_rsl {\n             macro_rules! memloop {\n                 ($arr:expr) => {{\n-                    for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                    for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n                         c+=$arr[i+2]; d+=$arr[i+3];\n                         e+=$arr[i+4]; f+=$arr[i+5];\n@@ -347,7 +347,7 @@ impl Isaac64Rng {\n             memloop!(self.rsl);\n             memloop!(self.mem);\n         } else {\n-            for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+            for i in (0..RAND_SIZE_64 / 8).map(|i| i * 8) {\n                 mix!();\n                 self.mem[i  ]=a; self.mem[i+1]=b;\n                 self.mem[i+2]=c; self.mem[i+3]=d;\n@@ -374,7 +374,7 @@ impl Isaac64Rng {\n         }\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n-            for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n+            for base in (0..MIDPOINT / 4).map(|i| i * 4) {\n \n                 macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n@@ -573,17 +573,17 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: IsaacRng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = range(0, 10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| ra.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(2558573138, 873787463, 263499565, 2103644246, 3595684709,\n                         4203127393, 264982119, 2765226902, 2737944514, 3900253796));\n \n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: IsaacRng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in range(0u, 10000) { rb.next_u32(); }\n+        for _ in 0u..10000 { rb.next_u32(); }\n \n-        let v = range(0, 10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| rb.next_u32()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(3676831399, 3183332890, 2834741178, 3854698763, 2717568474,\n                         1576568959, 3507990155, 179069555, 141456972, 2478885421));\n@@ -593,7 +593,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut ra: Isaac64Rng = SeedableRng::from_seed(seed);\n         // Regression test that isaac is actually using the above vector\n-        let v = range(0, 10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| ra.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(547121783600835980, 14377643087320773276, 17351601304698403469,\n                         1238879483818134882, 11952566807690396487, 13970131091560099343,\n@@ -603,9 +603,9 @@ mod test {\n         let seed: &[_] = &[12345, 67890, 54321, 9876];\n         let mut rb: Isaac64Rng = SeedableRng::from_seed(seed);\n         // skip forward to the 10000th number\n-        for _ in range(0u, 10000) { rb.next_u64(); }\n+        for _ in 0u..10000 { rb.next_u64(); }\n \n-        let v = range(0, 10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n+        let v = (0..10).map(|_| rb.next_u64()).collect::<Vec<_>>();\n         assert_eq!(v,\n                    vec!(18143823860592706164, 8491801882678285927, 2699425367717515619,\n                         17196852593171130876, 2606123525235546165, 15790932315217671084,\n@@ -618,7 +618,7 @@ mod test {\n         let seed: &[_] = &[1, 23, 456, 7890, 12345];\n         let mut rng: Isaac64Rng = SeedableRng::from_seed(seed);\n         let mut clone = rng.clone();\n-        for _ in range(0u, 16) {\n+        for _ in 0u..16 {\n             assert_eq!(rng.next_u64(), clone.next_u64());\n         }\n     }"}, {"sha": "3d2368a4a912e371bd789a34e786154fcd682d44", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -241,7 +241,7 @@ mod tests {\n         // this is unlikely to catch an incorrect implementation that\n         // generates exactly 0 or 1, but it keeps it sane.\n         let mut rng = thread_rng();\n-        for _ in range(0u, 1_000) {\n+        for _ in 0u..1_000 {\n             // strict inequalities\n             let Open01(f) = rng.gen::<Open01<f64>>();\n             assert!(0.0 < f && f < 1.0);\n@@ -254,7 +254,7 @@ mod tests {\n     #[test]\n     fn rand_closed() {\n         let mut rng = thread_rng();\n-        for _ in range(0u, 1_000) {\n+        for _ in 0u..1_000 {\n             // strict inequalities\n             let Closed01(f) = rng.gen::<Closed01<f64>>();\n             assert!(0.0 <= f && f <= 1.0);"}, {"sha": "57e901398767678ac6e417c2e7d0cacb1e969cb9", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -187,7 +187,7 @@ mod test {\n         let mut rs = ReseedingRng::new(Counter {i:0}, 400, ReseedWithDefault);\n \n         let mut i = 0;\n-        for _ in range(0u, 1000) {\n+        for _ in 0u..1000 {\n             assert_eq!(rs.next_u32(), i % 100);\n             i += 1;\n         }"}, {"sha": "fff28a95c4e13eb8d7e7722baeb3dcdd2fd9ebdc", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -189,7 +189,7 @@ mod tests {\n         b.bytes = (times * len) as u64;\n         b.iter(|| {\n             let mut wr = SeekableMemWriter::new();\n-            for _ in range(0, times) {\n+            for _ in 0..times {\n                 wr.write(src.as_slice()).unwrap();\n             }\n "}, {"sha": "f7fd8889fae59028227982a135aae70985211c1a", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -77,7 +77,7 @@ pub struct TaggedDoc<'a> {\n     pub doc: Doc<'a>,\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum EbmlEncoderTag {\n     EsUint,     // 0\n     EsU64,      // 1\n@@ -111,7 +111,7 @@ pub enum EbmlEncoderTag {\n     EsLabel, // Used only when debugging\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub enum Error {\n     IntTooBig(uint),\n     Expected(String),\n@@ -1184,7 +1184,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_aligned(b: &mut Bencher) {\n-        let data = range(0, 4*100).map(|i| {\n+        let data = (0i32..4*100).map(|i| {\n             match i % 2 {\n               0 => 0x80u8,\n               _ => i as u8,\n@@ -1202,7 +1202,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_A_unaligned(b: &mut Bencher) {\n-        let data = range(0, 4*100+1).map(|i| {\n+        let data = (0i32..4*100+1).map(|i| {\n             match i % 2 {\n               1 => 0x80u8,\n               _ => i as u8\n@@ -1220,7 +1220,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_aligned(b: &mut Bencher) {\n-        let data = range(0, 4*100).map(|i| {\n+        let data = (0i32..4*100).map(|i| {\n             match i % 4 {\n               0 => 0x10u8,\n               3 => i as u8,\n@@ -1239,7 +1239,7 @@ mod bench {\n \n     #[bench]\n     pub fn vuint_at_D_unaligned(b: &mut Bencher) {\n-        let data = range(0, 4*100+1).map(|i| {\n+        let data = (0i32..4*100+1).map(|i| {\n             match i % 4 {\n               1 => 0x10u8,\n               0 => i as u8,"}, {"sha": "f57d7956edfe5846614cb7d3b152456abd52730d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -540,7 +540,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         run_lints!(self, exit_lint_attrs, attrs);\n \n         // rollback\n-        for _ in range(0, pushed) {\n+        for _ in 0..pushed {\n             let (lint, lvlsrc) = self.level_stack.pop().unwrap();\n             self.lints.set_level(lint, lvlsrc);\n         }"}, {"sha": "5dc23d27ee11bb94d6488dc527b4e4f561b771ac", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -40,7 +40,7 @@ use syntax::ast;\n pub use lint::context::{Context, LintStore, raw_emit_lint, check_crate, gather_attrs};\n \n /// Specification of a single lint.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct Lint {\n     /// A string identifier for the lint.\n     ///\n@@ -207,7 +207,7 @@ impl LintId {\n }\n \n /// Setting for how to handle a lint.\n-#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Show)]\n+#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug)]\n pub enum Level {\n     Allow, Warn, Deny, Forbid\n }"}, {"sha": "aa2be7153ad456cf2b86468792c7077bb7bd88cd", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -219,7 +219,7 @@ pub const tag_items_data_item_stability: uint = 0x92;\n \n pub const tag_items_data_item_repr: uint = 0x93;\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct LinkMeta {\n     pub crate_name: String,\n     pub crate_hash: Svh,"}, {"sha": "40242f5249347df93a6c62f359412da5930d6806", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -49,7 +49,7 @@ pub struct crate_metadata {\n     pub span: Span,\n }\n \n-#[derive(Copy, Show, PartialEq, Clone)]\n+#[derive(Copy, Debug, PartialEq, Clone)]\n pub enum LinkagePreference {\n     RequireDynamic,\n     RequireStatic,"}, {"sha": "933fd873aeb7a06d4d3a6b9936c0ee06cc46cffa", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -493,7 +493,7 @@ pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n }\n \n // Something that a name can resolve to.\n-#[derive(Copy, Clone, Show)]\n+#[derive(Copy, Clone, Debug)]\n pub enum DefLike {\n     DlDef(def::Def),\n     DlImpl(ast::DefId),"}, {"sha": "13dc9397afc0f011d9f18fe98dbcc29d82f0b953", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1598,7 +1598,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash<SipHasher>,\n {\n-    let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n+    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);"}, {"sha": "943479ff35efa0001610eb85176795f023739159", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -43,7 +43,7 @@ use syntax::parse::token;\n // def-id will depend on where it originated from.  Therefore, the conversion\n // function is given an indicator of the source of the def-id.  See\n // astencode.rs for more information.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum DefIdSource {\n     // Identifies a struct, trait, enum, etc.\n     NominalType,\n@@ -132,7 +132,7 @@ pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n fn data_log_string(data: &[u8], pos: uint) -> String {\n     let mut buf = String::new();\n     buf.push_str(\"<<\");\n-    for i in range(pos, data.len()) {\n+    for i in pos..data.len() {\n         let c = data[i];\n         if c > 0x20 && c <= 0x7F {\n             buf.push(c as char);"}, {"sha": "52417c3e66c5cd613772f4e7259378ed8217b411", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1293,7 +1293,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             }\n             ty::AdjustDerefRef(ref adj) => {\n                 assert!(!ty::adjust_is_object(adjustment));\n-                for autoderef in range(0, adj.autoderefs) {\n+                for autoderef in 0..adj.autoderefs {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n                     for &method in tcx.method_map.borrow().get(&method_call).iter() {\n                         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n@@ -1529,7 +1529,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n         fn type_string(doc: rbml::Doc) -> String {\n             let mut str = String::new();\n-            for i in range(doc.start, doc.end) {\n+            for i in doc.start..doc.end {\n                 str.push(doc.data[i] as char);\n             }\n             str"}, {"sha": "fec7b51157d81a25e82974d82de6289cb6f3ea73", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -70,7 +70,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0u);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<uint> = range(0, column_count).map(|col| {\n+        let column_widths: Vec<uint> = (0..column_count).map(|col| {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0u)\n         }).collect();\n \n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = &pats[];\n-                                let subpats: Vec<_> = range(0, arity).map(|i| {\n+                                let subpats: Vec<_> = (0..arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]"}, {"sha": "01d42523f3556d6be755185075bf50a61bd75fc9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -28,7 +28,7 @@ use syntax::visit;\n use syntax::print::{pp, pprust};\n use util::nodemap::NodeMap;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum EntryOrExit {\n     Entry,\n     Exit,\n@@ -352,7 +352,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n                 let base_index = word_index * uint::BITS;\n-                for offset in range(0u, uint::BITS) {\n+                for offset in 0u..uint::BITS {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n@@ -552,7 +552,7 @@ fn bits_to_string(words: &[uint]) -> String {\n \n     for &word in words.iter() {\n         let mut v = word;\n-        for _ in range(0u, uint::BYTES) {\n+        for _ in 0u..uint::BYTES {\n             result.push(sep);\n             result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;"}, {"sha": "7857bcad8135d8dc6628c80aaf7e792221a07d84", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -20,7 +20,7 @@ use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     DefFn(ast::DefId, bool /* is_ctor */),\n     DefStaticMethod(/* method */ ast::DefId, MethodProvenance),\n@@ -72,13 +72,13 @@ pub struct Export {\n     pub def_id: ast::DefId, // The definition of the target.\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MethodProvenance {\n     FromTrait(ast::DefId),\n     FromImpl(ast::DefId),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TyParamProvenance {\n     FromSelf(ast::DefId),\n     FromParam(ast::DefId),"}, {"sha": "16b7d6134c39a37cd49b7b90cac639c52009f329", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -157,7 +157,7 @@ fn calculate_type(sess: &session::Session,\n     });\n \n     // Collect what we've got so far in the return vector.\n-    let mut ret = range(1, sess.cstore.next_crate_num()).map(|i| {\n+    let mut ret = (1..sess.cstore.next_crate_num()).map(|i| {\n         match formats.get(&i).map(|v| *v) {\n             v @ Some(cstore::RequireDynamic) => v,\n             _ => None,"}, {"sha": "0d543ca7beb0cad0b75f40f343ba7768476cf8f5", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -95,7 +95,7 @@ pub trait Delegate<'tcx> {\n               mode: MutateMode);\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum LoanCause {\n     ClosureCapture(Span),\n     AddrOf,\n@@ -107,28 +107,28 @@ pub enum LoanCause {\n     MatchDiscriminant\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum ConsumeMode {\n     Copy,                // reference to x where x has a type that copies\n     Move(MoveReason),    // reference to x where x has a type that moves\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum MoveReason {\n     DirectRefMove,\n     PatBindingMove,\n     CaptureMove,\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum MatchMode {\n     NonBindingMatch,\n     BorrowingMatch,\n     CopyingMatch,\n     MovingMatch,\n }\n \n-#[derive(PartialEq,Show)]\n+#[derive(PartialEq,Debug)]\n enum TrackMatchMode<T> {\n     Unknown,\n     Definite(MatchMode),\n@@ -197,7 +197,7 @@ impl<T> TrackMatchMode<T> {\n     }\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum MutateMode {\n     Init,\n     JustWrite,    // x = y\n@@ -842,7 +842,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                        autoderefs: uint) {\n         debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n \n-        for i in range(0, autoderefs) {\n+        for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i);\n             match self.typer.node_method_ty(deref_id) {\n                 None => {}"}, {"sha": "aca4b3df453676f7794fff3222cbf8ed707f7d92", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -61,18 +61,18 @@ impl<E: Debug> Debug for Edge<E> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub struct NodeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub struct EdgeIndex(pub uint);\n #[allow(non_upper_case_globals)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct Direction { repr: uint }\n #[allow(non_upper_case_globals)]\n pub const Outgoing: Direction = Direction { repr: 0 };"}, {"sha": "e286855c285487bc3a814820ddd3094f67eabee4", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -176,7 +176,7 @@ pub trait Combine<'tcx> : Sized {\n             assert_eq!(num_region_params, a_rs.len());\n             assert_eq!(num_region_params, b_rs.len());\n             let mut rs = vec!();\n-            for i in range(0, num_region_params) {\n+            for i in 0..num_region_params {\n                 let a_r = a_rs[i];\n                 let b_r = b_rs[i];\n                 let variance = variances[i];"}, {"sha": "f0174c5b0c6bcbda565a07e4aca1c540db813990", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1229,8 +1229,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let mut insert = Vec::new();\n                             if lifetimes.len() == 0 {\n                                 let anon = self.cur_anon.get();\n-                                for (i, a) in range(anon,\n-                                                    anon+expected).enumerate() {\n+                                for (i, a) in (anon..anon+expected).enumerate() {\n                                     if anon_nums.contains(&a) {\n                                         insert.push(i as u32);\n                                     }\n@@ -1343,11 +1342,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 let mut new_lts = Vec::new();\n                 if data.lifetimes.len() == 0 {\n                     // traverse once to see if there's a need to insert lifetime\n-                    let need_insert = range(0, expected).any(|i| {\n+                    let need_insert = (0..expected).any(|i| {\n                         indexes.contains(&i)\n                     });\n                     if need_insert {\n-                        for i in range(0, expected) {\n+                        for i in 0..expected {\n                             if indexes.contains(&i) {\n                                 new_lts.push(lifetime);\n                             } else {\n@@ -1767,7 +1766,7 @@ impl LifeGiver {\n             let mut s = String::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n-            for _ in range(0, n) {\n+            for _ in 0..n {\n                 s.push(letter);\n             }\n             s"}, {"sha": "cfcead51f7844a705dfcf304cfb879556644d700", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -95,7 +95,7 @@ pub type SkolemizationMap = FnvHashMap<ty::BoundRegion,ty::Region>;\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum TypeOrigin {\n     // Not yet categorized in a better way\n     Misc(Span),\n@@ -133,7 +133,7 @@ pub enum TypeOrigin {\n }\n \n /// See `error_reporting.rs` for more details\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n@@ -144,7 +144,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See `error_reporting.rs` for more details.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct TypeTrace<'tcx> {\n     origin: TypeOrigin,\n     values: ValuePairs<'tcx>,\n@@ -153,7 +153,7 @@ pub struct TypeTrace<'tcx> {\n /// The origin of a `r1 <= r2` constraint.\n ///\n /// See `error_reporting.rs` for more details\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     // Arose from a subtyping relation\n     Subtype(TypeTrace<'tcx>),\n@@ -222,7 +222,7 @@ pub enum SubregionOrigin<'tcx> {\n }\n \n /// Times when we replace late-bound regions with variables:\n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum LateBoundRegionConversionTime {\n     /// when a fn is called\n     FnCall,\n@@ -237,7 +237,7 @@ pub enum LateBoundRegionConversionTime {\n /// Reasons to create a region inference variable\n ///\n /// See `error_reporting.rs` for more details\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum RegionVariableOrigin<'tcx> {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n@@ -270,7 +270,7 @@ pub enum RegionVariableOrigin<'tcx> {\n     BoundRegionInCoherence(ast::Name),\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n-        range(0, n).map(|_i| self.next_ty_var()).collect()\n+        (0..n).map(|_i| self.next_ty_var()).collect()\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {"}, {"sha": "215c4945ea92097a153666dc9155c983430ef81f", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -120,7 +120,7 @@ struct ConstraintGraph<'a, 'tcx: 'a> {\n     node_ids: FnvHashMap<Node, uint>,\n }\n \n-#[derive(Clone, Hash, PartialEq, Eq, Show)]\n+#[derive(Clone, Hash, PartialEq, Eq, Debug)]\n enum Node {\n     RegionVid(ty::RegionVid),\n     Region(ty::Region),"}, {"sha": "052e7dbb3a4a7b293a9027aa9964cf0722431936", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -42,7 +42,7 @@ mod doc;\n mod graphviz;\n \n // A constraint that influences the inference process.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum Constraint {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n@@ -69,7 +69,7 @@ pub enum Verify<'tcx> {\n     VerifyGenericBound(GenericKind<'tcx>, SubregionOrigin<'tcx>, Region, Vec<Region>),\n }\n \n-#[derive(Clone, Show, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum GenericKind<'tcx> {\n     Param(ty::ParamTy),\n     Projection(ty::ProjectionTy<'tcx>),\n@@ -97,7 +97,7 @@ pub enum CombineMapType {\n     Lub, Glb\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n@@ -149,7 +149,7 @@ pub enum RegionResolutionError<'tcx> {\n /// ```\n /// would report an error because we expect 'a and 'b to match, and so we group\n /// 'a and 'b together inside a SameRegions struct\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct SameRegions {\n     pub scope_id: ast::NodeId,\n     pub regions: Vec<BoundRegion>\n@@ -223,7 +223,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     values: RefCell<Option<Vec<VarValue>>>,\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n #[allow(missing_copy_implementations)]\n pub struct RegionSnapshot {\n     length: uint,\n@@ -943,7 +943,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n // ______________________________________________________________________\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n enum Classification { Expanding, Contracting }\n \n #[derive(Copy)]\n@@ -983,7 +983,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        range(0, self.num_vars() as uint).map(|_| {\n+        (0..self.num_vars() as uint).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         let mut opt_graph = None;\n \n-        for idx in range(0u, self.num_vars() as uint) {\n+        for idx in 0u..self.num_vars() as uint {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1316,7 +1316,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        range(0, self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n+        (0..self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut graph = graph::Graph::with_capacity(num_vars as uint + 1,\n                                                     num_edges);\n \n-        for _ in range(0, num_vars) {\n+        for _ in 0..num_vars {\n             graph.add_node(());\n         }\n         let dummy_idx = graph.add_node(());"}, {"sha": "65061a29b78dd92786e74aa45a37132f6043b44d", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -46,7 +46,7 @@ struct Delegate<'tcx>;\n \n type Relation = (RelationDir, ty::TyVid);\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum RelationDir {\n     SubtypeOf, SupertypeOf, EqTo\n }"}, {"sha": "923f7d2d4ef358074568545e9eead858b478b6f9", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -63,7 +63,7 @@ pub trait UnifyValue : Clone + PartialEq + Debug {\n /// to keep the DAG relatively balanced, which helps keep the running\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone,Show)]\n+#[derive(PartialEq,Clone,Debug)]\n pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n     Root(K::Value, uint),"}, {"sha": "f6a51004eb680574e20e48a9cb9c91d1269fe244", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -159,7 +159,7 @@ impl Clone for LiveNode {\n     }\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n enum LiveNodeKind {\n     FreeVarNode(Span),\n     ExprNode(Span),\n@@ -245,13 +245,13 @@ struct CaptureInfo {\n     var_nid: NodeId\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n struct LocalInfo {\n     id: NodeId,\n     ident: ast::Ident\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum VarKind {\n     Arg(NodeId, ast::Ident),\n     Local(LocalInfo),\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     {\n         let node_base_idx = self.idx(ln, Variable(0u));\n         let succ_base_idx = self.idx(succ_ln, Variable(0u));\n-        for var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in 0u..self.ir.num_vars {\n             op(self, node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n@@ -700,7 +700,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         F: FnMut(uint) -> LiveNode,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n-        for var_idx in range(0u, self.ir.num_vars) {\n+        for var_idx in 0u..self.ir.num_vars {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 try!(write!(wr, \" {:?}\", Variable(var_idx)));\n@@ -860,7 +860,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // hack to skip the loop unless debug! is enabled:\n         debug!(\"^^ liveness computation results for body {} (entry={:?})\",\n                {\n-                   for ln_idx in range(0u, self.ir.num_live_nodes) {\n+                   for ln_idx in 0u..self.ir.num_live_nodes {\n                        debug!(\"{:?}\", self.ln_str(LiveNode(ln_idx)));\n                    }\n                    body.id"}, {"sha": "1be1bfa6730cdffa2eee0244d6081f13b79c403f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -87,7 +87,7 @@ use syntax::parse::token;\n use std::cell::RefCell;\n use std::rc::Rc;\n \n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum categorization<'tcx> {\n     cat_rvalue(ty::Region),                    // temporary val, argument is its scope\n     cat_static_item,\n@@ -101,14 +101,14 @@ pub enum categorization<'tcx> {\n }\n \n // Represents any kind of upvar\n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n     pub kind: ty::ClosureKind\n }\n \n // different kinds of pointers:\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum PointerKind {\n     /// `Box<T>`\n     Unique,\n@@ -125,25 +125,25 @@ pub enum PointerKind {\n \n // We use the term \"interior\" to mean \"something reachable from the\n // base without a pointer dereference\", e.g. a field\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorKind {\n     InteriorField(FieldName),\n     InteriorElement(ElementKind),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum FieldName {\n     NamedField(ast::Name),\n     PositionalField(uint)\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum ElementKind {\n     VecElement,\n     OtherElement,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n@@ -155,7 +155,7 @@ pub enum MutabilityCategory {\n // Upvar categorization can generate a variable number of nested\n // derefs.  The note allows detecting them without deep pattern\n // matching on the categorization.\n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum Note {\n     NoteClosureEnv(ty::UpvarId), // Deref through closure env\n     NoteUpvarRef(ty::UpvarId),   // Deref through by-ref upvar\n@@ -176,7 +176,7 @@ pub enum Note {\n // dereference, but its type is the type *before* the dereference\n // (`@T`). So use `cmt.ty` to find the type of the value in a consistent\n // fashion. For more details, see the method `cat_pattern`\n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n@@ -456,7 +456,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n                autoderefs,\n                cmt.repr(self.tcx()));\n-        for deref in range(1u, autoderefs + 1) {\n+        for deref in 1u..autoderefs + 1 {\n             cmt = try!(self.cat_deref(expr, cmt, deref));\n         }\n         return Ok(cmt);"}, {"sha": "dd1e32d13a2be07d512d3d506f159b8387d13f51", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -35,7 +35,7 @@ pub type PublicItems = NodeSet;\n // FIXME: dox\n pub type LastPrivateMap = NodeMap<LastPrivate>;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -49,14 +49,14 @@ pub enum LastPrivate {\n                type_used: ImportUse},\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(ast::DefId),\n }\n \n // How an import is used.\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used."}, {"sha": "4e29e9b75e860bd073a2dd841403f553bb363b1c", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -37,7 +37,7 @@ use syntax::visit::{Visitor, FnKind};\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Show, Copy)]\n+           RustcDecodable, Debug, Copy)]\n pub enum CodeExtent {\n     Misc(ast::NodeId),\n     Remainder(BlockRemainder),\n@@ -61,7 +61,7 @@ pub enum CodeExtent {\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-         RustcDecodable, Show, Copy)]\n+         RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: ast::NodeId,\n     pub first_statement_index: uint,\n@@ -179,7 +179,7 @@ pub struct RegionMaps {\n /// Carries the node id for the innermost block or match expression,\n /// for building up the `var_map` which maps ids to the blocks in\n /// which they were declared.\n-#[derive(PartialEq, Eq, Show, Copy)]\n+#[derive(PartialEq, Eq, Debug, Copy)]\n enum InnermostDeclaringBlock {\n     None,\n     Block(ast::NodeId),\n@@ -204,7 +204,7 @@ impl InnermostDeclaringBlock {\n /// Contextual information for declarations introduced by a statement\n /// (i.e. `let`). It carries node-id's for statement and enclosing\n /// block both, as well as the statement's index within the block.\n-#[derive(PartialEq, Eq, Show, Copy)]\n+#[derive(PartialEq, Eq, Debug, Copy)]\n struct DeclaringStatementContext {\n     stmt_id: ast::NodeId,\n     block_id: ast::NodeId,\n@@ -220,7 +220,7 @@ impl DeclaringStatementContext {\n     }\n }\n \n-#[derive(PartialEq, Eq, Show, Copy)]\n+#[derive(PartialEq, Eq, Debug, Copy)]\n enum InnermostEnclosingExpr {\n     None,\n     Some(ast::NodeId),\n@@ -242,7 +242,7 @@ impl InnermostEnclosingExpr {\n     }\n }\n \n-#[derive(Show, Copy)]\n+#[derive(Debug, Copy)]\n pub struct Context {\n     var_parent: InnermostDeclaringBlock,\n "}, {"sha": "9433f7b0a70f608283f249cba26fc24345bf211c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -33,7 +33,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use util::nodemap::NodeMap;\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n     DefStaticRegion,\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n@@ -404,7 +404,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n-        for i in range(0, lifetimes.len()) {\n+        for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n             let special_idents = [special_idents::static_lifetime];\n@@ -417,7 +417,7 @@ impl<'a> LifetimeContext<'a> {\n             }\n \n             // It is a hard error to shadow a lifetime within the same scope.\n-            for j in range(i + 1, lifetimes.len()) {\n+            for j in i + 1..lifetimes.len() {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {"}, {"sha": "cbf65080a86c146c8e585f99750eb81745ae6d36", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -28,7 +28,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n /// identify each in-scope parameter by an *index* and a *parameter\n /// space* (which indices where the parameter is defined; see\n /// `ParamSpace`).\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Substs<'tcx> {\n     pub types: VecPerParamSpace<Ty<'tcx>>,\n     pub regions: RegionSubsts,\n@@ -37,7 +37,7 @@ pub struct Substs<'tcx> {\n /// Represents the values to use when substituting lifetime parameters.\n /// If the value is `ErasedRegions`, then this subst is occurring during\n /// trans, and all region parameters will be replaced with `ty::ReStatic`.\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum RegionSubsts {\n     ErasedRegions,\n     NonerasedRegions(VecPerParamSpace<ty::Region>)\n@@ -180,7 +180,7 @@ impl RegionSubsts {\n // ParamSpace\n \n #[derive(PartialOrd, Ord, PartialEq, Eq, Copy,\n-           Clone, Hash, RustcEncodable, RustcDecodable, Show)]\n+           Clone, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum ParamSpace {\n     TypeSpace,  // Type parameters attached to a type definition, trait, or impl\n     SelfSpace,  // Self parameter on a trait"}, {"sha": "94da688181e1b5c9de17eeda26009f3794da8d93", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -147,7 +147,7 @@ pub type TraitObligations<'tcx> = subst::VecPerParamSpace<TraitObligation<'tcx>>\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n@@ -215,7 +215,7 @@ pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n /// ### The type parameter `N`\n ///\n /// See explanation on `VtableImplData`.\n-#[derive(Show,Clone)]\n+#[derive(Debug,Clone)]\n pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n@@ -258,7 +258,7 @@ pub struct VtableImplData<'tcx, N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n-#[derive(Show,Clone)]\n+#[derive(Debug,Clone)]\n pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n }"}, {"sha": "530190ddfc164780ff815ff2b70142b3a624666a", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -36,7 +36,7 @@ pub enum ObjectSafetyViolation<'tcx> {\n }\n \n /// Reasons a method might not be object-safe.\n-#[derive(Copy,Clone,Show)]\n+#[derive(Copy,Clone,Debug)]\n pub enum MethodViolationCode {\n     /// e.g., `fn(self)`\n     ByValueSelf,"}, {"sha": "5780b5b70f4a2d3f8ea79e30212cd11baa1224bb", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -96,7 +96,7 @@ pub enum MethodMatchResult {\n     MethodDidNotMatch,\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum MethodMatchedData {\n     // In the case of a precise match, we don't really need to store\n     // how the match was found. So don't.\n@@ -131,7 +131,7 @@ pub enum MethodMatchedData {\n /// matching where clause. Part of the reason for this is that where\n /// clauses can give additional information (like, the types of output\n /// parameters) that would have to be inferred from the impl.\n-#[derive(PartialEq,Eq,Show,Clone)]\n+#[derive(PartialEq,Eq,Debug,Clone)]\n enum SelectionCandidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n@@ -172,7 +172,7 @@ enum BuiltinBoundConditions<'tcx> {\n     AmbiguousBuiltin\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n enum EvaluationResult<'tcx> {\n     EvaluatedToOk,\n     EvaluatedToAmbig,\n@@ -595,7 +595,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let mut i = 0;\n             while i < candidates.len() {\n                 let is_dup =\n-                    range(0, candidates.len())\n+                    (0..candidates.len())\n                     .filter(|&j| i != j)\n                     .any(|j| self.candidate_should_be_dropped_in_favor_of(stack,\n                                                                           &candidates[i],"}, {"sha": "44615f19d94aa7b9e6afc4c312bfbe97c6584190", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -112,7 +112,7 @@ pub struct field<'tcx> {\n     pub mt: mt<'tcx>\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemContainer {\n     TraitContainer(ast::DefId),\n     ImplContainer(ast::DefId),\n@@ -127,7 +127,7 @@ impl ImplOrTraitItemContainer {\n     }\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum ImplOrTraitItem<'tcx> {\n     MethodTraitItem(Rc<Method<'tcx>>),\n     TypeTraitItem(Rc<AssociatedType>),\n@@ -172,7 +172,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum ImplOrTraitItemId {\n     MethodTraitItemId(ast::DefId),\n     TypeTraitItemId(ast::DefId),\n@@ -187,7 +187,7 @@ impl ImplOrTraitItemId {\n     }\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: ast::Name,\n     pub generics: ty::Generics<'tcx>,\n@@ -231,21 +231,21 @@ impl<'tcx> Method<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub struct AssociatedType {\n     pub name: ast::Name,\n     pub vis: ast::Visibility,\n     pub def_id: ast::DefId,\n     pub container: ImplOrTraitItemContainer,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct mt<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub struct field_ty {\n     pub name: Name,\n     pub id: DefId,\n@@ -274,21 +274,21 @@ pub struct ItemVariances {\n     pub regions: VecPerParamSpace<Variance>,\n }\n \n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Show, Copy)]\n+#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug, Copy)]\n pub enum Variance {\n     Covariant,      // T<A> <: T<B> iff A <: B -- e.g., function return type\n     Invariant,      // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n     Contravariant,  // T<A> <: T<B> iff B <: A -- e.g., function param type\n     Bivariant,      // T<A> <: T<B>            -- e.g., unused type parameter\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum AutoAdjustment<'tcx> {\n     AdjustReifyFnPointer(ast::DefId), // go from a fn-item type to a fn-pointer type\n     AdjustDerefRef(AutoDerefRef<'tcx>)\n }\n \n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum UnsizeKind<'tcx> {\n     // [T, ..n] -> [T], the uint field is n.\n     UnsizeLength(uint),\n@@ -298,13 +298,13 @@ pub enum UnsizeKind<'tcx> {\n     UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>)\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n     pub autoderefs: uint,\n     pub autoref: Option<AutoRef<'tcx>>\n }\n \n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum AutoRef<'tcx> {\n     /// Convert from T to &T\n     /// The third field allows us to wrap other AutoRef adjustments.\n@@ -421,13 +421,13 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n     }\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Show)]\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n     pub index: uint\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n     MethodStatic(ast::DefId),\n@@ -445,7 +445,7 @@ pub enum MethodOrigin<'tcx> {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n     // be a supertrait of what the user actually typed. Note that it\n@@ -466,7 +466,7 @@ pub struct MethodParam<'tcx> {\n }\n \n // details for a method invoked with a receiver whose type is an object\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct MethodObject<'tcx> {\n     // the (super)trait containing the method to be invoked\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n@@ -503,13 +503,13 @@ pub struct MethodCallee<'tcx> {\n /// needed to add to the side tables. Thus to disambiguate\n /// we also keep track of whether there's an adjustment in\n /// our key.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct MethodCall {\n     pub expr_id: ast::NodeId,\n     pub adjustment: ExprAdjustment\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum ExprAdjustment {\n     NoAdjustment,\n     AutoDeref(uint),\n@@ -923,7 +923,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct TyS<'tcx> {\n     pub sty: sty<'tcx>,\n     pub flags: TypeFlags,\n@@ -1029,21 +1029,21 @@ pub fn type_escapes_depth(ty: Ty, depth: u32) -> bool {\n     ty.region_depth > depth\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct BareFnTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum FnOutput<'tcx> {\n     FnConverging(Ty<'tcx>),\n     FnDiverging\n@@ -1100,7 +1100,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n     pub idx: u32,\n@@ -1146,15 +1146,15 @@ pub struct ParamTy {\n /// is the outer fn.\n ///\n /// [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct DebruijnIndex {\n     // We maintain the invariant that this is never 0. So 1 indicates\n     // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n     pub depth: u32,\n }\n \n /// Representation of regions:\n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum Region {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n@@ -1195,13 +1195,13 @@ pub enum Region {\n /// Upvars do not get their own node-id. Instead, we use the pair of\n /// the original var id (that is, the root variable that is referenced\n /// by the upvar) and the id of the closure expression.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct UpvarId {\n     pub var_id: ast::NodeId,\n     pub closure_expr_id: ast::NodeId,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum BorrowKind {\n     /// Data must be immutable and is aliasable.\n     ImmBorrow,\n@@ -1294,7 +1294,7 @@ pub enum BorrowKind {\n /// - Through mutation, the borrowed upvars can actually escape\n ///   the closure, so sometimes it is necessary for them to be larger\n ///   than the closure lifetime itself.\n-#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Show, Copy)]\n+#[derive(PartialEq, Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct UpvarBorrow {\n     pub kind: BorrowKind,\n     pub region: ty::Region,\n@@ -1320,7 +1320,7 @@ impl Region {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Show, Copy)]\n+           RustcEncodable, RustcDecodable, Debug, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n pub struct FreeRegion {\n@@ -1329,7 +1329,7 @@ pub struct FreeRegion {\n }\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash,\n-           RustcEncodable, RustcDecodable, Show, Copy)]\n+           RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BoundRegion {\n     /// An anonymous region parameter for a given fn (&T)\n     BrAnon(u32),\n@@ -1350,7 +1350,7 @@ pub enum BoundRegion {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum sty<'tcx> {\n     ty_bool,\n     ty_char,\n@@ -1397,7 +1397,7 @@ pub enum sty<'tcx> {\n             // on non-useful type error messages)\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TyTrait<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds<'tcx>,\n@@ -1469,7 +1469,7 @@ impl<'tcx> TyTrait<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -1509,7 +1509,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound reons, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Binder<T>(pub T);\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -1518,22 +1518,22 @@ pub enum IntVarValue {\n     UintType(ast::UintTy),\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum terr_vstore_kind {\n     terr_vec,\n     terr_str,\n     terr_fn,\n     terr_trait\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub struct expected_found<T> {\n     pub expected: T,\n     pub found: T\n }\n \n // Data structures used in type unification\n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub enum type_err<'tcx> {\n     terr_mismatch,\n     terr_unsafety_mismatch(expected_found<ast::Unsafety>),\n@@ -1567,7 +1567,7 @@ pub enum type_err<'tcx> {\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n /// as well as the existential type parameter in an object type.\n-#[derive(PartialEq, Eq, Hash, Clone, Show)]\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n@@ -1580,7 +1580,7 @@ pub struct ParamBounds<'tcx> {\n /// major difference between this case and `ParamBounds` is that\n /// general purpose trait bounds are omitted and there must be\n /// *exactly one* region.\n-#[derive(PartialEq, Eq, Hash, Clone, Show)]\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n pub struct ExistentialBounds<'tcx> {\n     pub region_bound: ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n@@ -1590,7 +1590,7 @@ pub struct ExistentialBounds<'tcx> {\n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n-           Show, Copy)]\n+           Debug, Copy)]\n #[repr(uint)]\n pub enum BuiltinBound {\n     BoundSend,\n@@ -1664,15 +1664,15 @@ pub enum InferTy {\n     FreshIntTy(u32),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum UnconstrainedNumeric {\n     UnconstrainedFloat,\n     UnconstrainedInt,\n     Neither,\n }\n \n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Eq, Hash, Debug, Copy)]\n pub enum InferRegion {\n     ReVar(RegionVid),\n     ReSkolemized(u32, BoundRegion)\n@@ -1746,7 +1746,7 @@ impl fmt::Debug for IntVarValue {\n     }\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -1756,7 +1756,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub default: Option<Ty<'tcx>>,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, Clone, Show)]\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug)]\n pub struct RegionParameterDef {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n@@ -1773,7 +1773,7 @@ impl RegionParameterDef {\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to ast::Generics.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct Generics<'tcx> {\n     pub types: VecPerParamSpace<TypeParameterDef<'tcx>>,\n     pub regions: VecPerParamSpace<RegionParameterDef>,\n@@ -1809,7 +1809,7 @@ impl<'tcx> Generics<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -1830,7 +1830,7 @@ pub enum Predicate<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: Rc<TraitRef<'tcx>>\n }\n@@ -1856,11 +1856,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n@@ -1878,7 +1878,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::R\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,\n@@ -1898,7 +1898,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n@@ -2034,7 +2034,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n /// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n /// [uint:Bar<int>]]`.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct GenericBounds<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n@@ -2243,7 +2243,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n /// stray references in a comment or something). We try to reserve the\n /// \"poly\" prefix to refer to higher-ranked things, as in\n /// `PolyTraitRef`.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct TypeScheme<'tcx> {\n     pub generics: Generics<'tcx>,\n     pub ty: Ty<'tcx>\n@@ -2286,7 +2286,7 @@ pub struct Closure<'tcx> {\n     pub kind: ClosureKind,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum ClosureKind {\n     FnClosureKind,\n     FnMutClosureKind,\n@@ -3745,7 +3745,7 @@ pub fn is_instantiable<'tcx>(cx: &ctxt<'tcx>, r_ty: Ty<'tcx>) -> bool {\n ///\n /// The ordering of the cases is significant. They are sorted so that cmp::max\n /// will keep the \"more erroneous\" of two values.\n-#[derive(Copy, PartialOrd, Ord, Eq, PartialEq, Show)]\n+#[derive(Copy, PartialOrd, Ord, Eq, PartialEq, Debug)]\n pub enum Representability {\n     Representable,\n     ContainsRecursive,\n@@ -4344,7 +4344,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                     let mut adjusted_ty = unadjusted_ty;\n \n                     if !ty::type_is_error(adjusted_ty) {\n-                        for i in range(0, adj.autoderefs) {\n+                        for i in 0..adj.autoderefs {\n                             let method_call = MethodCall::autoderef(expr_id, i);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n@@ -6536,7 +6536,7 @@ impl<'a,'tcx> ClosureTyper<'tcx> for ty::ParameterEnvironment<'a,'tcx> {\n \n \n /// The category of explicit self.\n-#[derive(Clone, Copy, Eq, PartialEq, Show)]\n+#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n pub enum ExplicitSelfCategory {\n     StaticExplicitSelfCategory,\n     ByValueExplicitSelfCategory,"}, {"sha": "2fc68e6244a3314c45816d050dd81411771d3a16", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -249,7 +249,7 @@ pub enum EntryFnType {\n     EntryNone,\n }\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Show)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,\n@@ -672,7 +672,7 @@ pub fn optgroups() -> Vec<getopts::OptGroup> {\n         .collect()\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Show)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum OptionStability { Stable, Unstable }\n \n #[derive(Clone, PartialEq, Eq)]"}, {"sha": "c6436d47c73c86421747e29deb855d1f74b648df", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,7 +10,7 @@\n \n use std::slice;\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct SearchPaths {\n     paths: Vec<(PathKind, Path)>,\n }\n@@ -20,7 +20,7 @@ pub struct Iter<'a> {\n     iter: slice::Iter<'a, (PathKind, Path)>,\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy, Show)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n pub enum PathKind {\n     Native,\n     Crate,"}, {"sha": "cdaca497b904ca8d9450df95c6489eb8968d6400", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -27,7 +27,7 @@ pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n // Useful type to use with `Result<>` indicate that an error has already\n // been reported to the user, so no need to continue checking.\n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub struct ErrorReported;\n \n pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where"}, {"sha": "ca1bb7d7a9404f0c2fea79bda4dac885476450a9", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -14,7 +14,7 @@ pub fn lev_distance(me: &str, t: &str) -> uint {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n \n-    let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n+    let mut dcol: Vec<_> = (0..t.len() + 1).collect();\n     let mut t_last = 0;\n \n     for (i, sc) in me.chars().enumerate() {\n@@ -45,7 +45,7 @@ pub fn lev_distance(me: &str, t: &str) -> uint {\n fn test_lev_distance() {\n     use std::char::{ from_u32, MAX };\n     // Test bytelength agnosticity\n-    for c in range(0u32, MAX as u32)\n+    for c in (0u32..MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n         assert_eq!(lev_distance(&c[], &c[]), 0);"}, {"sha": "aef4f7a896ba2c85fe92b7c060703b250357e45c", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -52,7 +52,7 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub struct Svh {\n     hash: String,\n }"}, {"sha": "16adccfba575e97013dd91bcce1689077a25e829", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -84,7 +84,7 @@ mod x86_64_unknown_linux_gnu;\n /// Everything `rustc` knows about how to compile for a specific target.\n ///\n /// Every field here must be specified, and has no default value.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct Target {\n     /// [Data layout](http://llvm.org/docs/LangRef.html#data-layout) to pass to LLVM.\n     pub data_layout: String,\n@@ -107,7 +107,7 @@ pub struct Target {\n ///\n /// This has an implementation of `Default`, see each field for what the default is. In general,\n /// these try to take \"minimal defaults\" that don't assume anything about the runtime they run in.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct TargetOptions {\n     /// Linker to invoke. Defaults to \"cc\".\n     pub linker: String,"}, {"sha": "487de3a6bb5746a8e6c57564a4f1b884d9ebad1b", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -73,7 +73,7 @@\n ///     }\n /// }\n ///\n-/// impl fmt::Show for Flags {\n+/// impl fmt::Debug for Flags {\n ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n ///         write!(f, \"hi!\")\n ///     }"}, {"sha": "6e71da198e3599964edb0f7ccb5770b89cd76e2b", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -358,7 +358,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                            parent_ty.repr(tcx)),\n             };\n             let tuple_len = v.len();\n-            for i in range(0, tuple_len) {\n+            for i in 0..tuple_len {\n                 if i == tuple_idx { continue }\n                 let field_name = mc::PositionalField(i);\n                 add_fragment_sibling_local(field_name, None);"}, {"sha": "311229717da1ca23f51a281a71c1e879ec1bc459", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -21,7 +21,7 @@ use syntax::codemap::Span;\n \n use std::rc::Rc;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub enum RestrictionResult<'tcx> {\n     Safe,\n     SafeIf(Rc<LoanPath<'tcx>>, Vec<Rc<LoanPath<'tcx>>>)"}, {"sha": "d90907888e314c60f4b18b8297395cb121b3dbef", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> Loan<'tcx> {\n     }\n }\n \n-#[derive(Eq, Hash, Show)]\n+#[derive(Eq, Hash, Debug)]\n pub struct LoanPath<'tcx> {\n     kind: LoanPathKind<'tcx>,\n     ty: ty::Ty<'tcx>,\n@@ -293,7 +293,7 @@ impl<'tcx> PartialEq for LoanPath<'tcx> {\n     }\n }\n \n-#[derive(PartialEq, Eq, Hash, Show)]\n+#[derive(PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathKind<'tcx> {\n     LpVar(ast::NodeId),                         // `x` in doc.rs\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n@@ -314,7 +314,7 @@ impl<'tcx> LoanPath<'tcx> {\n //     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n static DOWNCAST_PRINTED_OPERATOR : &'static str = \" as \";\n \n-#[derive(Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Copy, PartialEq, Eq, Hash, Debug)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n@@ -487,7 +487,7 @@ pub enum AliasableViolationKind {\n     BorrowViolation(euv::LoanCause)\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum MovedValueUseKind {\n     MovedInUse,\n     MovedInCapture,"}, {"sha": "ece9d61d7f204df9d615bf22d0d2b955dcb04a49", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -76,7 +76,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Show)]\n+#[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -128,7 +128,7 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: MovePathIndex,\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum MoveKind {\n     Declared,   // When declared, variables start out \"moved\".\n     MoveExpr,   // Expression or binding that moves a variable"}, {"sha": "150e616b36c6f137b1a53e1b6bab37dab7bba53c", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::dataflow;\n use std::rc::Rc;\n use std::borrow::IntoCow;\n \n-#[derive(Show, Copy)]\n+#[derive(Debug, Copy)]\n pub enum Variant {\n     Loans,\n     Moves,"}, {"sha": "4ee13f5a5428f67fc1dc096db8b6cd6a4e9d1f66", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -42,7 +42,7 @@ use std::old_io::{self, MemReader};\n use std::option;\n use std::str::FromStr;\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n     PpmEveryBodyLoops,\n@@ -54,7 +54,7 @@ pub enum PpSourceMode {\n }\n \n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum PpFlowGraphMode {\n     Default,\n     /// Drops the labels from the edges in the flowgraph output. This\n@@ -63,7 +63,7 @@ pub enum PpFlowGraphMode {\n     /// have become a pain to maintain.\n     UnlabelledEdges,\n }\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum PpMode {\n     PpmSource(PpSourceMode),\n     PpmFlowGraph(PpFlowGraphMode),\n@@ -338,7 +338,7 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n     variants\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub enum UserIdentifiedItem {\n     ItemViaNode(ast::NodeId),\n     ItemViaPath(Vec<String>),"}, {"sha": "5ce916f536047366449db9706d266948e9e54e50", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -115,7 +115,7 @@ pub enum Linkage {\n }\n \n #[repr(C)]\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum DiagnosticSeverity {\n     Error,\n     Warning,\n@@ -312,7 +312,7 @@ pub enum RealPredicate {\n \n // The LLVM TypeKind type - must stay in sync with the def of\n // LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n #[repr(C)]\n pub enum TypeKind {\n     Void      = 0,"}, {"sha": "000426771a81af14a6b78c2336d78d1d0697fe56", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -127,7 +127,7 @@ enum PatternBindingMode {\n     ArgumentIrrefutableMode,\n }\n \n-#[derive(Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Copy, PartialEq, Eq, Hash, Debug)]\n enum Namespace {\n     TypeNS,\n     ValueNS\n@@ -193,7 +193,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n }\n \n /// Contains data for specific types of import directives.\n-#[derive(Copy,Show)]\n+#[derive(Copy,Debug)]\n enum ImportDirectiveSubclass {\n     SingleImport(Name /* target */, Name /* source */),\n     GlobImport\n@@ -242,7 +242,7 @@ enum TypeParameters<'a> {\n \n // The rib kind controls the translation of local\n // definitions (`DefLocal`) to upvars (`DefUpvar`).\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum RibKind {\n     // No translation needs to be applied.\n     NormalRibKind,\n@@ -266,7 +266,7 @@ enum RibKind {\n }\n \n // Methods can be required or provided. RequiredMethod methods only occur in traits.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum MethodSort {\n     RequiredMethod,\n     ProvidedMethod(NodeId)\n@@ -301,7 +301,7 @@ enum BareIdentifierPatternResolution {\n }\n \n /// One local scope.\n-#[derive(Show)]\n+#[derive(Debug)]\n struct Rib {\n     bindings: HashMap<Name, DefLike>,\n     kind: RibKind,\n@@ -317,14 +317,14 @@ impl Rib {\n }\n \n /// Whether an import can be shadowed by another import.\n-#[derive(Show,PartialEq,Clone,Copy)]\n+#[derive(Debug,PartialEq,Clone,Copy)]\n enum Shadowable {\n     Always,\n     Never\n }\n \n /// One import directive.\n-#[derive(Show)]\n+#[derive(Debug)]\n struct ImportDirective {\n     module_path: Vec<Name>,\n     subclass: ImportDirectiveSubclass,\n@@ -354,7 +354,7 @@ impl ImportDirective {\n }\n \n /// The item that an import resolves to.\n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n struct Target {\n     target_module: Rc<Module>,\n     bindings: Rc<NameBindings>,\n@@ -375,7 +375,7 @@ impl Target {\n }\n \n /// An ImportResolution represents a particular `use` directive.\n-#[derive(Show)]\n+#[derive(Debug)]\n struct ImportResolution {\n     /// Whether this resolution came from a `use` or a `pub use`. Note that this\n     /// should *not* be used whenever resolution is being performed, this is\n@@ -455,15 +455,15 @@ impl ImportResolution {\n }\n \n /// The link from a module up to its nearest parent node.\n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n enum ParentLink {\n     NoParentLink,\n     ModuleParentLink(Weak<Module>, Name),\n     BlockParentLink(Weak<Module>, NodeId)\n }\n \n /// The type of module this is.\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n enum ModuleKind {\n     NormalModuleKind,\n     TraitModuleKind,\n@@ -556,15 +556,15 @@ impl fmt::Debug for Module {\n }\n \n bitflags! {\n-    #[derive(Show)]\n+    #[derive(Debug)]\n     flags DefModifiers: u8 {\n         const PUBLIC            = 0b0000_0001,\n         const IMPORTABLE        = 0b0000_0010,\n     }\n }\n \n // Records a possibly-private type definition.\n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n struct TypeNsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     module_def: Option<Rc<Module>>,\n@@ -573,7 +573,7 @@ struct TypeNsDef {\n }\n \n // Records a possibly-private value definition.\n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n struct ValueNsDef {\n     modifiers: DefModifiers, // see note in ImportResolution about how to use this\n     def: Def,\n@@ -582,7 +582,7 @@ struct ValueNsDef {\n \n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n-#[derive(Show)]\n+#[derive(Debug)]\n struct NameBindings {\n     type_def: RefCell<Option<TypeNsDef>>,   //< Meaning in type namespace.\n     value_def: RefCell<Option<ValueNsDef>>, //< Meaning in value namespace."}, {"sha": "93a2b6eaa4f02b6600f8b5dff67d81a7f88265ba", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -600,7 +600,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // For LTO purposes, the bytecode of this library is also inserted\n             // into the archive.  If codegen_units > 1, we insert each of the\n             // bitcode files.\n-            for i in range(0, sess.opts.cg.codegen_units) {\n+            for i in 0..sess.opts.cg.codegen_units {\n                 // Note that we make sure that the bytecode filename in the\n                 // archive is never exactly 16 bytes long by adding a 16 byte\n                 // extension to it. This is to work around a bug in LLDB that"}, {"sha": "9b195486d5d68162aeec64708bdf67abf736eb7d", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -714,7 +714,7 @@ pub fn run_passes(sess: &Session,\n         cmd.args(&sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n \n-        for index in range(0, trans.modules.len()) {\n+        for index in 0..trans.modules.len() {\n             cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)[]));\n         }\n \n@@ -824,7 +824,7 @@ pub fn run_passes(sess: &Session,\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n-        for i in range(0, trans.modules.len()) {\n+        for i in 0..trans.modules.len() {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n                 remove(sess, &crate_output.with_extension(&ext[]));\n@@ -901,7 +901,7 @@ fn run_work_multithreaded(sess: &Session,\n     let mut diag_emitter = SharedEmitter::new();\n     let mut futures = Vec::with_capacity(num_workers);\n \n-    for i in range(0, num_workers) {\n+    for i in 0..num_workers {\n         let work_items_arc = work_items_arc.clone();\n         let diag_emitter = diag_emitter.clone();\n         let remark = sess.opts.cg.remark.clone();"}, {"sha": "ef1eb3cb8048860b9748e2d366b32c12c011c731", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -63,7 +63,7 @@ macro_rules! svec {\n     })\n }\n \n-#[derive(Copy,Show)]\n+#[derive(Copy,Debug)]\n pub enum Row {\n     Variable,\n     Enum,"}, {"sha": "8d7eb5816c2b10cd5622f5d221b9e65512b6d9c6", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -227,7 +227,7 @@ use syntax::codemap::Span;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n struct ConstantExpr<'a>(&'a ast::Expr);\n \n impl<'a> ConstantExpr<'a> {\n@@ -242,7 +242,7 @@ impl<'a> ConstantExpr<'a> {\n }\n \n // An option identifying a branch (either a literal, an enum variant or a range)\n-#[derive(Show)]\n+#[derive(Debug)]\n enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>),\n@@ -606,7 +606,7 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = range(0, adt::num_args(repr, disr_val)).map(|i| {\n+    let args = (0..adt::num_args(repr, disr_val)).map(|i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     }).collect();\n \n@@ -653,8 +653,8 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let vec_datum = match_datum(val, left_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let mut elems = vec![];\n-    elems.extend(range(0, before).map(|i| GEPi(bcx, base, &[i])));\n-    elems.extend(range(0, after).rev().map(|i| {\n+    elems.extend((0..before).map(|i| GEPi(bcx, base, &[i])));\n+    elems.extend((0..after).rev().map(|i| {\n         InBoundsGEP(bcx, base, &[\n             Sub(bcx, len, C_uint(bcx.ccx(), i + 1), DebugLoc::None)\n         ])\n@@ -768,7 +768,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         })\n     };\n \n-    range(0, m[0].pats.len())\n+    (0..m[0].pats.len())\n         .filter(column_contains_any_nonwild_patterns)\n         .map(|col| (col, column_score(m, col)))\n         .max_by(|&(_, score)| score)\n@@ -1005,7 +1005,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n         let arg_count = adt::num_args(&*repr, 0);\n-        let field_vals: Vec<ValueRef> = std::iter::range(0, arg_count).map(|ix|\n+        let field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             adt::trans_field_ptr(bcx, &*repr, val, 0, ix)\n         ).collect();\n         Some(field_vals)"}, {"sha": "1deb07e1ba09a487f88eaffb9efa07a9468b1116", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -72,7 +72,7 @@ use util::ppaux::ty_to_string;\n type Hint = attr::ReprAttr;\n \n /// Representations.\n-#[derive(Eq, PartialEq, Show)]\n+#[derive(Eq, PartialEq, Debug)]\n pub enum Repr<'tcx> {\n     /// C-like enums; basically an int.\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n@@ -117,7 +117,7 @@ pub enum Repr<'tcx> {\n }\n \n /// For structs, and struct-like parts of anything fancier.\n-#[derive(Eq, PartialEq, Show)]\n+#[derive(Eq, PartialEq, Debug)]\n pub struct Struct<'tcx> {\n     // If the struct is DST, then the size and alignment do not take into\n     // account the unsized fields of the struct.\n@@ -465,7 +465,7 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct IntBounds {\n     slo: i64,\n     shi: i64,"}, {"sha": "1195b9f084b0f37595f7134fd5afab867ab80d49", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1651,7 +1651,7 @@ fn copy_closure_args_to_allocas<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                      wasn't a tuple?!\")\n         }\n     };\n-    for j in range(0, args.len()) {\n+    for j in 0..args.len() {\n         let tuple_element_type = untupled_arg_types[j];\n         let tuple_element_datum =\n             tuple_datum.get_element(bcx,"}, {"sha": "fc29c7071f2e37f153107d7ba679f2c815a85b42", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -905,7 +905,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                                                           tuple_expr.id));\n             let repr = adt::represent_type(bcx.ccx(), tuple_type);\n             let repr_ptr = &*repr;\n-            for i in range(0, field_types.len()) {\n+            for i in 0..field_types.len() {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n                     field_types[i],"}, {"sha": "61a6f4cfe10a949d7542b5333a895bf3de795649", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -50,7 +50,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n     cached_landing_pad: Option<BasicBlockRef>,\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct CustomScopeIndex {\n     index: uint\n }\n@@ -81,7 +81,7 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n     }\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,\n@@ -106,7 +106,7 @@ pub trait Cleanup<'tcx> {\n \n pub type CleanupObj<'tcx> = Box<Cleanup<'tcx>+'tcx>;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum ScopeId {\n     AstScope(ast::NodeId),\n     CustomScope(CustomScopeIndex)\n@@ -911,7 +911,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n     }\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum Heap {\n     HeapExchange\n }"}, {"sha": "7d4e6aed876a547d6cfb760c39c03d51036907b6", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1137,7 +1137,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n }\n \n // Key used to lookup values supplied for type parameters in an expr.\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum ExprOrMethodCall {\n     // Type parameters for a path like `None::<int>`\n     ExprId(ast::NodeId),"}, {"sha": "0403a2f2e3c679d9d4447c79db69b76c045a4046", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -195,7 +195,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                     let mut ty = ety;\n                     // Save the last autoderef in case we can avoid it.\n                     if adj.autoderefs > 0 {\n-                        for _ in range(0, adj.autoderefs-1) {\n+                        for _ in 0..adj.autoderefs-1 {\n                             let (dv, dt) = const_deref(cx, llconst, ty, false);\n                             llconst = dv;\n                             ty = dt;"}, {"sha": "12e79c407eceaf11006302a213d5dce10214b4f4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -274,7 +274,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             available_drop_glues: RefCell::new(FnvHashMap()),\n         };\n \n-        for i in range(0, local_count) {\n+        for i in 0..local_count {\n             // Append \".rs\" to crate name as LLVM module identifier.\n             //\n             // LLVM code generator emits a \".file filename\" directive\n@@ -310,7 +310,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         let (local_ccx, index) =\n             self.local_ccxs\n                 .iter()\n-                .zip(range(0, self.local_ccxs.len()))\n+                .zip(0..self.local_ccxs.len())\n                 .min_by(|&(local_ccx, _idx)| local_ccx.n_llvm_insns.get())\n                 .unwrap();\n         CrateContext {"}, {"sha": "dd4ef97b88da69ba3ae2979967160b3482920852", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -52,7 +52,7 @@ pub struct DatumBlock<'blk, 'tcx: 'blk, K> {\n     pub datum: Datum<'tcx, K>,\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub enum Expr {\n     /// a fresh value that was produced and which has no cleanup yet\n     /// because it has not yet \"landed\" into its permanent home\n@@ -64,10 +64,10 @@ pub enum Expr {\n     LvalueExpr,\n }\n \n-#[derive(Clone, Copy, Show)]\n+#[derive(Clone, Copy, Debug)]\n pub struct Lvalue;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct Rvalue {\n     pub mode: RvalueMode\n }\n@@ -83,7 +83,7 @@ impl Drop for Rvalue {\n     fn drop(&mut self) { }\n }\n \n-#[derive(Copy, PartialEq, Eq, Hash, Show)]\n+#[derive(Copy, PartialEq, Eq, Hash, Debug)]\n pub enum RvalueMode {\n     /// `val` is a pointer to the actual value (and thus has type *T)\n     ByRef,"}, {"sha": "ce9af3162a08927c88ec68c33a36508135e1bbe4", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -249,7 +249,7 @@ const FLAGS_NONE: c_uint = 0;\n //  Public Interface of debuginfo module\n //=-----------------------------------------------------------------------------\n \n-#[derive(Copy, Show, Hash, Eq, PartialEq, Clone)]\n+#[derive(Copy, Debug, Hash, Eq, PartialEq, Clone)]\n struct UniqueTypeId(ast::Name);\n \n // The TypeMap is where the CrateDebugContext holds the type metadata nodes"}, {"sha": "a6c9a988b4d46e486639a50248219c439296a281", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1924,7 +1924,7 @@ fn float_cast(bcx: Block,\n     } else { llsrc };\n }\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum cast_kind {\n     cast_pointer,\n     cast_integral,\n@@ -2117,7 +2117,7 @@ fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;\n-    for i in range(0, times) {\n+    for i in 0..times {\n         let method_call = MethodCall::autoderef(expr.id, i);\n         datum = unpack_datum!(bcx, deref_once(bcx, expr, datum, method_call));\n     }"}, {"sha": "5965d396e8719c13f24875fe8615c55abd121e9c", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -716,7 +716,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in range(0, tys.fn_sig.inputs.len()) {\n+        for i in 0..tys.fn_sig.inputs.len() {\n             let rust_ty = tys.fn_sig.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);"}, {"sha": "cc0d76efcf0a683767a3d684b3396c0a2e4b55df", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -286,7 +286,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     (lldecl, mono_ty, true)\n }\n \n-#[derive(PartialEq, Eq, Hash, Show)]\n+#[derive(PartialEq, Eq, Hash, Debug)]\n pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n     pub params: subst::VecPerParamSpace<Ty<'tcx>>"}, {"sha": "e3e4ca62c262f0f4931fd4691a4062f9ed3f2f41", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -27,7 +27,7 @@ use std::iter::repeat;\n \n use libc::c_uint;\n \n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n #[repr(C)]\n pub struct Type {\n     rf: TypeRef"}, {"sha": "a382cfca0bd899e73b25c1e185dfb984e78dc774", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -314,7 +314,7 @@ fn create_substs_for_ast_path<'tcx>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(_) => range(0, expected_num_region_params)\n+            Err(_) => (0..expected_num_region_params)\n                           .map(|_| ty::ReStatic).collect() // hokey\n         }\n     };"}, {"sha": "cb4c880717bc86b5ea47d8cd2c96f030a41be199", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -167,7 +167,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         }\n         ast::PatTup(ref elements) => {\n             let element_tys: Vec<_> =\n-                range(0, elements.len()).map(|_| fcx.infcx().next_ty_var())\n+                (0..elements.len()).map(|_| fcx.infcx().next_ty_var())\n                                         .collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);"}, {"sha": "4980630a03593d9d866ca3fcb094cdb385285248", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -73,7 +73,7 @@ pub struct Pick<'tcx> {\n     pub kind: PickKind<'tcx>,\n }\n \n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n@@ -88,7 +88,7 @@ pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n // difference is that it doesn't embed any regions or other\n // specifics. The \"confirmation\" step recreates those details as\n // needed.\n-#[derive(Clone,Show)]\n+#[derive(Clone,Debug)]\n pub enum PickAdjustment {\n     // Indicates that the source expression should be autoderef'd N times\n     //"}, {"sha": "6dabec31e2c6ff855b06bc2cb81f42b4c7db3fe9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1871,13 +1871,13 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n \n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(range(0, count).map(|_| {\n+        Ok((0..count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n         }).collect())\n     }\n }\n \n-#[derive(Copy, Show, PartialEq, Eq)]\n+#[derive(Copy, Debug, PartialEq, Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference\n@@ -1903,7 +1903,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n            lvalue_pref);\n \n     let mut t = base_ty;\n-    for autoderefs in range(0, fcx.tcx().sess.recursion_limit.get()) {\n+    for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n         let resolved_t = structurally_resolved_type(fcx, sp, t);\n \n         if ty::type_is_error(resolved_t) {\n@@ -2473,7 +2473,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n-    range(0, len).map(|_| tcx.types.err).collect()\n+    (0..len).map(|_| tcx.types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -5107,7 +5107,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // that the *default* type are expressed in terms of all prior\n         // parameters, so we have to substitute as we go with the\n         // partial substitution that we have built up.\n-        for i in range(provided_len, desired.len()) {\n+        for i in provided_len..desired.len() {\n             let default = desired[i].default.unwrap();\n             let default = default.subst_spanned(fcx.tcx(), substs, Some(span));\n             substs.types.push(space, default);"}, {"sha": "15602505d90d4e4bf3e67553adfa2e40a67ef790", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -948,7 +948,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n            derefd_ty.repr(rcx.tcx()));\n \n     let r_deref_expr = ty::ReScope(CodeExtent::from_node_id(deref_expr.id));\n-    for i in range(0u, derefs) {\n+    for i in 0u..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n "}, {"sha": "a5a600c5748b32a6fe8d588c2fa280a30a9ac3ae", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -263,7 +263,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     }\n \n                     ty::AdjustDerefRef(adj) => {\n-                        for autoderef in range(0, adj.autoderefs) {\n+                        for autoderef in 0..adj.autoderefs {\n                             let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n                         }"}, {"sha": "7aaf56336a83b80fd436d047dac17f00120f97cb", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -135,7 +135,7 @@ impl RegionScope for BindingRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(range(0, count).map(|_| self.next_region()).collect())\n+        Ok((0..count).map(|_| self.next_region()).collect())\n     }\n }\n "}, {"sha": "dd42c667956511dbe1555ed65b4b1a439e8fdd33", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -230,7 +230,7 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n \n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n struct InferredIndex(uint);\n \n #[derive(Copy)]\n@@ -266,7 +266,7 @@ struct TermsContext<'a, 'tcx: 'a> {\n     inferred_infos: Vec<InferredInfo<'a>> ,\n }\n \n-#[derive(Copy, Show, PartialEq)]\n+#[derive(Copy, Debug, PartialEq)]\n enum ParamKind {\n     TypeParam,\n     RegionParam"}, {"sha": "9cb29cb14b807025c8cc9f9969967388c90d0338", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -115,7 +115,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub name: String,\n     pub src: FsPath,\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n@@ -237,7 +237,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Item {\n     /// Stringified span\n     pub source: Span,\n@@ -313,7 +313,7 @@ impl Item {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ItemEnum {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n@@ -342,7 +342,7 @@ pub enum ItemEnum {\n     AssociatedTypeItem(TyParam),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Module {\n     pub items: Vec<Item>,\n     pub is_crate: bool,\n@@ -401,7 +401,7 @@ impl Clean<Item> for doctree::Module {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Attribute {\n     Word(String),\n     List(String, Vec<Attribute> ),\n@@ -456,7 +456,7 @@ impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn span(&self) -> codemap::Span { unimplemented!() }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct TyParam {\n     pub name: String,\n     pub did: ast::DefId,\n@@ -489,7 +489,7 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum TyParamBound {\n     RegionBound(Lifetime),\n     TraitBound(PolyTrait, ast::TraitBoundModifier)\n@@ -684,7 +684,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Lifetime(String);\n \n impl Lifetime {\n@@ -734,7 +734,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<TyParamBound> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<Lifetime>},\n@@ -843,7 +843,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n }\n \n // maybe use a Generic enum and use ~[Generic]?\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n     pub type_params: Vec<TyParam>,\n@@ -940,7 +940,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n     pub self_: SelfTy,\n@@ -979,7 +979,7 @@ impl Clean<Item> for ast::Method {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct TyMethod {\n     pub unsafety: ast::Unsafety,\n     pub decl: FnDecl,\n@@ -1017,7 +1017,7 @@ impl Clean<Item> for ast::TypeMethod {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n@@ -1038,7 +1038,7 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n@@ -1063,14 +1063,14 @@ impl Clean<Item> for doctree::Function {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct FnDecl {\n     pub inputs: Arguments,\n     pub output: FunctionRetTy,\n     pub attrs: Vec<Attribute>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n@@ -1123,7 +1123,7 @@ impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Argument {\n     pub type_: Type,\n     pub name: String,\n@@ -1140,7 +1140,7 @@ impl Clean<Argument> for ast::Arg {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum FunctionRetTy {\n     Return(Type),\n     DefaultReturn,\n@@ -1157,7 +1157,7 @@ impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n     pub items: Vec<TraitMethod>,\n@@ -1201,7 +1201,7 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n \n /// An item belonging to a trait, whether a method or associated. Could be named\n /// TraitItem except that's already taken by an exported enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum TraitMethod {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n@@ -1246,7 +1246,7 @@ impl Clean<TraitMethod> for ast::TraitItem {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum ImplMethod {\n     MethodImplItem(Item),\n     TypeImplItem(Item),\n@@ -1317,7 +1317,7 @@ impl<'tcx> Clean<Item> for ty::ImplOrTraitItem<'tcx> {\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PolyTrait {\n     pub trait_: Type,\n     pub lifetimes: Vec<Lifetime>\n@@ -1326,7 +1326,7 @@ pub struct PolyTrait {\n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n /// type out of the AST/ty::ctxt given one of these, if more information is needed. Most importantly\n /// it does not preserve mutability or boxes.\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum Type {\n     /// structs/enums/traits (anything that'd be an ast::TyPath)\n     ResolvedPath {\n@@ -1370,7 +1370,7 @@ pub enum Type {\n     PolyTraitRef(Vec<TyParamBound>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum PrimitiveType {\n     Isize, I8, I16, I32, I64,\n     Usize, U8, U16, U32, U64,\n@@ -1382,7 +1382,7 @@ pub enum PrimitiveType {\n     PrimitiveTuple,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n pub enum TypeKind {\n     TypeEnum,\n     TypeFunction,\n@@ -1625,7 +1625,7 @@ impl Clean<Type> for ast::QPath {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes\n     TypedStructField(Type),\n@@ -1684,7 +1684,7 @@ impl Clean<Option<Visibility>> for ast::Visibility {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Struct {\n     pub struct_type: doctree::StructType,\n     pub generics: Generics,\n@@ -1714,7 +1714,7 @@ impl Clean<Item> for doctree::Struct {\n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct VariantStruct {\n     pub struct_type: doctree::StructType,\n     pub fields: Vec<Item>,\n@@ -1731,7 +1731,7 @@ impl Clean<VariantStruct> for syntax::ast::StructDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Enum {\n     pub variants: Vec<Item>,\n     pub generics: Generics,\n@@ -1756,7 +1756,7 @@ impl Clean<Item> for doctree::Enum {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Variant {\n     pub kind: VariantKind,\n }\n@@ -1824,7 +1824,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum VariantKind {\n     CLikeVariant,\n     TupleVariant(Vec<Type>),\n@@ -1846,7 +1846,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Span {\n     pub filename: String,\n     pub loline: uint,\n@@ -1881,7 +1881,7 @@ impl Clean<Span> for syntax::codemap::Span {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Path {\n     pub global: bool,\n     pub segments: Vec<PathSegment>,\n@@ -1896,7 +1896,7 @@ impl Clean<Path> for ast::Path {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub enum PathParameters {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n@@ -1930,7 +1930,7 @@ impl Clean<PathParameters> for ast::PathParameters {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct PathSegment {\n     pub name: String,\n     pub params: PathParameters\n@@ -1971,7 +1971,7 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n@@ -1994,7 +1994,7 @@ impl Clean<Item> for doctree::Typedef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct BareFunctionDecl {\n     pub unsafety: ast::Unsafety,\n     pub generics: Generics,\n@@ -2017,7 +2017,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Static {\n     pub type_: Type,\n     pub mutability: Mutability,\n@@ -2046,7 +2046,7 @@ impl Clean<Item> for doctree::Static {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Constant {\n     pub type_: Type,\n     pub expr: String,\n@@ -2069,7 +2069,7 @@ impl Clean<Item> for doctree::Constant {\n     }\n }\n \n-#[derive(Show, Clone, RustcEncodable, RustcDecodable, PartialEq, Copy)]\n+#[derive(Debug, Clone, RustcEncodable, RustcDecodable, PartialEq, Copy)]\n pub enum Mutability {\n     Mutable,\n     Immutable,\n@@ -2084,7 +2084,7 @@ impl Clean<Mutability> for ast::Mutability {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Copy, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Copy, Debug)]\n pub enum ImplPolarity {\n     Positive,\n     Negative,\n@@ -2099,7 +2099,7 @@ impl Clean<ImplPolarity> for ast::ImplPolarity {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Impl {\n     pub generics: Generics,\n     pub trait_: Option<Type>,\n@@ -2219,7 +2219,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum Import {\n     // use source as str;\n     SimpleImport(String, ImportSource),\n@@ -2229,13 +2229,13 @@ pub enum Import {\n     ImportList(ImportSource, Vec<ViewListIdent>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ImportSource {\n     pub path: Path,\n     pub did: Option<ast::DefId>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ViewListIdent {\n     pub name: String,\n     pub source: Option<ast::DefId>,\n@@ -2454,7 +2454,7 @@ fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     })\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Macro {\n     pub source: String,\n }\n@@ -2475,7 +2475,7 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n     pub feature: String,\n@@ -2595,7 +2595,7 @@ fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n }\n \n /// An equality constraint on an associated type, e.g. `A=Bar` in `Foo<A=Bar>`\n-#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Show)]\n+#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Debug)]\n pub struct TypeBinding {\n     pub name: String,\n     pub ty: Type"}, {"sha": "ba5df56f4fb5655d44762548fe8f53eaf83db88c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -72,7 +72,7 @@ impl Module {\n     }\n }\n \n-#[derive(Show, Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Debug, Clone, RustcEncodable, RustcDecodable, Copy)]\n pub enum StructType {\n     /// A normal struct\n     Plain,\n@@ -145,7 +145,7 @@ pub struct Typedef {\n     pub stab: Option<attr::Stability>,\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct Static {\n     pub type_: P<ast::Ty>,\n     pub mutability: ast::Mutability,"}, {"sha": "1c916ad817cc7d9fff9172f841c08f3ed38e9f24", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -395,7 +395,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n     }\n }\n \n-#[derive(Eq, PartialEq, Clone, Show)]\n+#[derive(Eq, PartialEq, Clone, Debug)]\n struct LangString {\n     should_fail: bool,\n     no_run: bool,"}, {"sha": "b8ebbf8ff3604d0b030b416aac668c23eac9ffc8", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1500,7 +1500,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n \n-    let mut indices = range(0, items.len()).filter(|i| {\n+    let mut indices = (0..items.len()).filter(|i| {\n         !cx.ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n@@ -2251,7 +2251,7 @@ impl<'a> fmt::Display for Source<'a> {\n             tmp /= 10;\n         }\n         try!(write!(fmt, \"<pre class=\\\"line-numbers\\\">\"));\n-        for i in range(1, lines + 1) {\n+        for i in 1..lines + 1 {\n             try!(write!(fmt, \"<span id=\\\"{0}\\\">{0:1$}</span>\\n\", i, cols));\n         }\n         try!(write!(fmt, \"</pre>\"));"}, {"sha": "9143baf9ed949f9c6e35ca85ce7a98b60588eb19", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -154,7 +154,7 @@ impl TocBuilder {\n             // fill in any missing zeros, e.g. for\n             // # Foo (1)\n             // ### Bar (1.0.1)\n-            for _ in range(toc_level, level - 1) {\n+            for _ in toc_level..level - 1 {\n                 sec_number.push_str(\"0.\");\n             }\n             let number = toc.count_entries_with_level(level);"}, {"sha": "8b39d91ffaeb0f029af4ad0493e2089cf9634b8c", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -36,7 +36,7 @@ impl<T:Decodable> Decodable for DList<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = DList::new();\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(list)\n@@ -59,7 +59,7 @@ impl<T:Decodable> Decodable for RingBuf<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: RingBuf<T> = RingBuf::new();\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(deque)\n@@ -91,7 +91,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n@@ -122,7 +122,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(set)\n@@ -148,7 +148,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n         let bits = try!(d.read_uint());\n         let mut set = EnumSet::new();\n-        for bit in range(0, uint::BITS) {\n+        for bit in 0..uint::BITS {\n             if bits & (1 << bit) != 0 {\n                 set.insert(CLike::from_uint(1 << bit));\n             }\n@@ -186,7 +186,7 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hash_state(len, state);\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n@@ -222,7 +222,7 @@ impl<T, S> Decodable for HashSet<T, S>\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hash_state(len, state);\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(set)\n@@ -246,7 +246,7 @@ impl<V: Decodable> Decodable for VecMap<V> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<VecMap<V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = VecMap::new();\n-            for i in range(0u, len) {\n+            for i in 0u..len {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);"}, {"sha": "d3c2ffa95441f3d4066358b56476e992457e1e06", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -61,7 +61,7 @@ pub trait FromHex {\n }\n \n /// Errors that can occur when decoding a hex encoded string\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum FromHexError {\n     /// The input contained a character not part of the hex format\n     InvalidHexCharacter(char, uint),\n@@ -185,14 +185,14 @@ mod tests {\n \n     #[test]\n     pub fn test_to_hex_all_bytes() {\n-        for i in range(0u, 256) {\n+        for i in 0u..256 {\n             assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n-        for i in range(0u, 256) {\n+        for i in 0u..256 {\n             let ii: &[u8] = &[i as u8];\n             assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n                                                    .unwrap(),"}, {"sha": "2e7a6fd4923545c0b0857016a40e7ce0d6d006a9", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -214,7 +214,7 @@ use unicode::str::Utf16Item;\n use Encodable;\n \n /// Represents a json value\n-#[derive(Clone, PartialEq, PartialOrd, Show)]\n+#[derive(Clone, PartialEq, PartialOrd, Debug)]\n pub enum Json {\n     I64(i64),\n     U64(u64),\n@@ -235,7 +235,7 @@ pub struct AsJson<'a, T: 'a> { inner: &'a T }\n pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n \n /// The errors that can arise while parsing a JSON stream.\n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum ErrorCode {\n     InvalidSyntax,\n     InvalidNumber,\n@@ -256,7 +256,7 @@ pub enum ErrorCode {\n     NotUtf8,\n }\n \n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum ParserError {\n     /// msg, line, col\n     SyntaxError(ErrorCode, uint, uint),\n@@ -266,7 +266,7 @@ pub enum ParserError {\n // Builder and Parser have the same errors.\n pub type BuilderError = ParserError;\n \n-#[derive(Clone, PartialEq, Show)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum DecoderError {\n     ParseError(ParserError),\n     ExpectedError(string::String, string::String),\n@@ -275,7 +275,7 @@ pub enum DecoderError {\n     ApplicationError(string::String)\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum EncoderError {\n     FmtError(fmt::Error),\n     BadHashmapKey,\n@@ -1237,7 +1237,7 @@ impl Index<uint> for Json {\n }\n \n /// The output of the streaming parser.\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone, Debug)]\n pub enum JsonEvent {\n     ObjectStart,\n     ObjectEnd,\n@@ -1252,7 +1252,7 @@ pub enum JsonEvent {\n     Error(ParserError),\n }\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum ParserState {\n     // Parse a value in an array, true means first element.\n     ParseArray(bool),\n@@ -1282,15 +1282,15 @@ pub struct Stack {\n /// For example, StackElement::Key(\"foo\"), StackElement::Key(\"bar\"),\n /// StackElement::Index(3) and StackElement::Key(\"x\") are the\n /// StackElements compositing the stack that represents foo.bar[3].x\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone, Debug)]\n pub enum StackElement<'l> {\n     Index(u32),\n     Key(&'l str),\n }\n \n // Internally, Key elements are stored as indices in a buffer to avoid\n // allocating a string for every member of an object.\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone, Debug)]\n enum InternalStackElement {\n     InternalIndex(u32),\n     InternalKey(u16, u16), // start, size\n@@ -1324,7 +1324,7 @@ impl Stack {\n     /// Compares this stack with an array of StackElements.\n     pub fn is_equal_to(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() != rhs.len() { return false; }\n-        for i in range(0, rhs.len()) {\n+        for i in 0..rhs.len() {\n             if self.get(i) != rhs[i] { return false; }\n         }\n         return true;\n@@ -1334,7 +1334,7 @@ impl Stack {\n     /// the ones passed as parameter.\n     pub fn starts_with(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n-        for i in range(0, rhs.len()) {\n+        for i in 0..rhs.len() {\n             if self.get(i) != rhs[i] { return false; }\n         }\n         return true;\n@@ -1345,7 +1345,7 @@ impl Stack {\n     pub fn ends_with(&self, rhs: &[StackElement]) -> bool {\n         if self.stack.len() < rhs.len() { return false; }\n         let offset = self.stack.len() - rhs.len();\n-        for i in range(0, rhs.len()) {\n+        for i in 0..rhs.len() {\n             if self.get(i + offset) != rhs[i] { return false; }\n         }\n         return true;\n@@ -2621,7 +2621,7 @@ mod tests {\n     use std::num::Float;\n     use std::string;\n \n-    #[derive(RustcDecodable, Eq, PartialEq, Show)]\n+    #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n     struct OptionData {\n         opt: Option<uint>,\n     }\n@@ -2648,20 +2648,20 @@ mod tests {\n                                 ExpectedError(\"Number\".to_string(), \"false\".to_string()));\n     }\n \n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Show)]\n+    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     enum Animal {\n         Dog,\n         Frog(string::String, int)\n     }\n \n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Show)]\n+    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     struct Inner {\n         a: (),\n         b: uint,\n         c: Vec<string::String>,\n     }\n \n-    #[derive(PartialEq, RustcEncodable, RustcDecodable, Show)]\n+    #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n@@ -3511,7 +3511,7 @@ mod tests {\n         }\n \n         // Test up to 4 spaces of indents (more?)\n-        for i in range(0, 4u) {\n+        for i in 0..4u {\n             let mut writer = Vec::new();\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n@@ -3997,7 +3997,7 @@ mod tests {\n \n     fn big_json() -> string::String {\n         let mut src = \"[\\n\".to_string();\n-        for _ in range(0i, 500) {\n+        for _ in 0i..500 {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n                             [1,2,3]},\"#);\n         }"}, {"sha": "f963d0ce813ee790eb360dfa38aed139b634a093", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -461,7 +461,7 @@ impl<T:Decodable> Decodable for Vec<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n-            for i in range(0, len) {\n+            for i in 0..len {\n                 v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n             Ok(v)\n@@ -641,7 +641,7 @@ impl<D: Decoder> DecoderHelpers for D {\n     {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n-            for i in range(0, len) {\n+            for i in 0..len {\n                 v.push(try!(this.read_seq_elt(i, |this| f(this))));\n             }\n             Ok(v)"}, {"sha": "a291ec16a62440183b0b7385f831dc794ec4e480", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -89,7 +89,7 @@ impl DefaultResizePolicy {\n fn test_resize_policy() {\n     use prelude::v1::*;\n     let rp = DefaultResizePolicy;\n-    for n in range(0u, 1000) {\n+    for n in 0u..1000 {\n         assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n         assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n     }\n@@ -1681,24 +1681,24 @@ mod test_map {\n             let mut m = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 200) {\n+                for i in 0u..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in range(0u, 100) {\n+            for i in 0u..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 m.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 200) {\n+                for i in 0u..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n-            for i in range(0u, 50) {\n+            for i in 0u..50 {\n                 let k = Dropable::new(i);\n                 let v = m.remove(&k);\n \n@@ -1711,20 +1711,20 @@ mod test_map {\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 50) {\n+                for i in 0u..50 {\n                     assert_eq!(v.borrow()[i], 0);\n                     assert_eq!(v.borrow()[i+100], 0);\n                 }\n \n-                for i in range(50u, 100) {\n+                for i in 50u..100 {\n                     assert_eq!(v.borrow()[i], 1);\n                     assert_eq!(v.borrow()[i+100], 1);\n                 }\n             });\n         }\n \n         DROP_VECTOR.with(|v| {\n-            for i in range(0u, 200) {\n+            for i in 0u..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1740,19 +1740,19 @@ mod test_map {\n             let mut hm = HashMap::new();\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 200) {\n+                for i in 0u..200 {\n                     assert_eq!(v.borrow()[i], 0);\n                 }\n             });\n \n-            for i in range(0u, 100) {\n+            for i in 0u..100 {\n                 let d1 = Dropable::new(i);\n                 let d2 = Dropable::new(i+100);\n                 hm.insert(d1, d2);\n             }\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 200) {\n+                for i in 0u..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n@@ -1767,19 +1767,19 @@ mod test_map {\n             let mut half = hm.into_iter().take(50);\n \n             DROP_VECTOR.with(|v| {\n-                for i in range(0u, 200) {\n+                for i in 0u..200 {\n                     assert_eq!(v.borrow()[i], 1);\n                 }\n             });\n \n             for _ in half {}\n \n             DROP_VECTOR.with(|v| {\n-                let nk = range(0u, 100).filter(|&i| {\n+                let nk = (0u..100).filter(|&i| {\n                     v.borrow()[i] == 1\n                 }).count();\n \n-                let nv = range(0u, 100).filter(|&i| {\n+                let nv = (0u..100).filter(|&i| {\n                     v.borrow()[i+100] == 1\n                 }).count();\n \n@@ -1789,7 +1789,7 @@ mod test_map {\n         };\n \n         DROP_VECTOR.with(|v| {\n-            for i in range(0u, 200) {\n+            for i in 0u..200 {\n                 assert_eq!(v.borrow()[i], 0);\n             }\n         });\n@@ -1807,7 +1807,7 @@ mod test_map {\n \n         // Try this a few times to make sure we never screw up the hashmap's\n         // internal state.\n-        for _ in range(0i, 10) {\n+        for _ in 0i..10 {\n             assert!(m.is_empty());\n \n             for i in range_inclusive(1i, 1000) {\n@@ -1934,7 +1934,7 @@ mod test_map {\n     #[test]\n     fn test_iterate() {\n         let mut m = HashMap::with_capacity(4);\n-        for i in range(0u, 32) {\n+        for i in 0u..32 {\n             assert!(m.insert(i, i*2).is_none());\n         }\n         assert_eq!(m.len(), 32);\n@@ -2050,7 +2050,7 @@ mod test_map {\n         assert_eq!(cap, initial_cap * 2);\n \n         let mut i = 0u;\n-        for _ in range(0, cap * 3 / 4) {\n+        for _ in 0..cap * 3 / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -2059,7 +2059,7 @@ mod test_map {\n         assert_eq!(m.len(), i);\n         assert_eq!(m.table.capacity(), cap);\n \n-        for _ in range(0, cap / 4) {\n+        for _ in 0..cap / 4 {\n             m.insert(i, i);\n             i += 1;\n         }\n@@ -2068,7 +2068,7 @@ mod test_map {\n         let new_cap = m.table.capacity();\n         assert_eq!(new_cap, cap * 2);\n \n-        for _ in range(0, cap / 2 - 1) {\n+        for _ in 0..cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n             assert_eq!(m.table.capacity(), new_cap);\n@@ -2077,7 +2077,7 @@ mod test_map {\n         m.shrink_to_fit();\n         assert_eq!(m.table.capacity(), cap);\n         // again, a little more than half full\n-        for _ in range(0, cap / 2 - 1) {\n+        for _ in 0..cap / 2 - 1 {\n             i -= 1;\n             m.remove(&i);\n         }\n@@ -2094,18 +2094,18 @@ mod test_map {\n         m.insert(0u, 0u);\n         m.remove(&0);\n         assert!(m.capacity() >= m.len());\n-        for i in range(0, 128) {\n+        for i in 0us..128 {\n             m.insert(i, i);\n         }\n         m.reserve(256);\n \n         let usable_cap = m.capacity();\n-        for i in range(128, 128+256) {\n+        for i in 128us..128+256 {\n             m.insert(i, i);\n             assert_eq!(m.capacity(), usable_cap);\n         }\n \n-        for i in range(100, 128+256) {\n+        for i in 100us..128+256 {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2114,7 +2114,7 @@ mod test_map {\n         assert!(!m.is_empty());\n         assert!(m.capacity() >= m.len());\n \n-        for i in range(0, 100) {\n+        for i in 0us..100 {\n             assert_eq!(m.remove(&i), Some(i));\n         }\n         m.shrink_to_fit();\n@@ -2277,12 +2277,12 @@ mod test_map {\n         let mut rng = weak_rng();\n \n         // Populate the map with some items.\n-        for _ in range(0u, 50) {\n+        for _ in 0u..50 {\n             let x = rng.gen_range(-10, 10);\n             m.insert(x, ());\n         }\n \n-        for i in range(0u, 1000) {\n+        for i in 0u..1000 {\n             let x = rng.gen_range(-10, 10);\n             match m.entry(x) {\n                 Vacant(_) => {},"}, {"sha": "2b15e50c6fac3e275311af79835598385f297588", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1003,7 +1003,7 @@ mod test_set {\n     #[test]\n     fn test_iterate() {\n         let mut a = HashSet::new();\n-        for i in range(0u, 32) {\n+        for i in 0u..32 {\n             assert!(a.insert(i));\n         }\n         let mut observed: u32 = 0;\n@@ -1198,10 +1198,10 @@ mod test_set {\n \n     #[test]\n     fn test_drain() {\n-        let mut s: HashSet<int> = range(1, 100).collect();\n+        let mut s: HashSet<int> = (1is..100).collect();\n \n         // try this a bunch of times to make sure we don't screw up internal state.\n-        for _ in range(0i, 20) {\n+        for _ in 0i..20 {\n             assert_eq!(s.len(), 99);\n \n             {\n@@ -1217,7 +1217,7 @@ mod test_set {\n             for _ in s.iter() { panic!(\"s should be empty!\"); }\n \n             // reset to try again.\n-            s.extend(range(1, 100));\n+            s.extend(1is..100);\n         }\n     }\n }"}, {"sha": "d010a5de622d44dc98b8801a19eba7d0bb00ba0a", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -951,7 +951,7 @@ mod tests {\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n     test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, uint }\n \n-    #[derive(PartialEq, Show)]\n+    #[derive(PartialEq, Debug)]\n     struct Value { x: int }\n \n     impl ToPrimitive for Value {\n@@ -1001,7 +1001,7 @@ mod tests {\n     fn test_pow() {\n         fn naive_pow<T: Int>(base: T, exp: uint) -> T {\n             let one: T = Int::one();\n-            range(0, exp).fold(one, |acc, _| acc * base)\n+            (0..exp).fold(one, |acc, _| acc * base)\n         }\n         macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n@@ -1028,7 +1028,7 @@ mod bench {\n \n     #[bench]\n     fn bench_pow_function(b: &mut Bencher) {\n-        let v = range(0, 1024u).collect::<Vec<_>>();\n+        let v = (0..1024u).collect::<Vec<_>>();\n         b.iter(|| {v.iter().fold(0u, |old, new| old.pow(*new));});\n     }\n }"}, {"sha": "f429f731b7d00d01a808b244208f3256b0f282d1", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -518,7 +518,7 @@ mod bench {\n         ({\n             use super::u64_from_be_bytes;\n \n-            let data = range(0u8, $stride*100+$start_index).collect::<Vec<_>>();\n+            let data = (0u8..$stride*100+$start_index).collect::<Vec<_>>();\n             let mut sum = 0u64;\n             $b.iter(|| {\n                 let mut i = $start_index;"}, {"sha": "99c7e399b1c72817443c8e6a8578831e85356c5a", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1101,7 +1101,7 @@ mod test {\n         let dir = &tmpdir.join(\"di_readdir\");\n         check!(mkdir(dir, old_io::USER_RWX));\n         let prefix = \"foo\";\n-        for n in range(0i,3) {\n+        for n in 0i..3 {\n             let f = dir.join(format!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n             let msg_str = format!(\"{}{}\", prefix, n.to_string());"}, {"sha": "ddb364a703a3a23186856f323666a41f17dfa580", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -663,7 +663,7 @@ mod test {\n         b.bytes = (times * len) as u64;\n         b.iter(|| {\n             let mut wr = MemWriter::new();\n-            for _ in range(0, times) {\n+            for _ in 0..times {\n                 wr.write(src.as_slice()).unwrap();\n             }\n \n@@ -719,7 +719,7 @@ mod test {\n             let buf = [5 as u8; 100].to_vec();\n             {\n                 let mut rdr = MemReader::new(buf);\n-                for _i in range(0u, 10) {\n+                for _i in 0u..10 {\n                     let mut buf = [0 as u8; 10];\n                     rdr.read(&mut buf).unwrap();\n                     assert_eq!(buf.as_slice(), [5; 10].as_slice());\n@@ -734,7 +734,7 @@ mod test {\n             let mut buf = [0 as u8; 100];\n             {\n                 let mut wr = BufWriter::new(&mut buf);\n-                for _i in range(0u, 10) {\n+                for _i in 0u..10 {\n                     wr.write(&[5; 10]).unwrap();\n                 }\n             }\n@@ -748,7 +748,7 @@ mod test {\n             let buf = [5 as u8; 100];\n             {\n                 let mut rdr = BufReader::new(&buf);\n-                for _i in range(0u, 10) {\n+                for _i in 0u..10 {\n                     let mut buf = [0 as u8; 10];\n                     rdr.read(&mut buf).unwrap();\n                     assert_eq!(buf, [5; 10]);"}, {"sha": "c9cabe648b994880dd5c6f125767fb91cea41d35", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -320,7 +320,7 @@ pub type IoResult<T> = Result<T, IoError>;\n /// # FIXME\n ///\n /// Is something like this sufficient? It's kind of archaic\n-#[derive(PartialEq, Eq, Clone, Show)]\n+#[derive(PartialEq, Eq, Clone, Debug)]\n pub struct IoError {\n     /// An enumeration which can be matched against for determining the flavor\n     /// of error.\n@@ -376,7 +376,7 @@ impl Error for IoError {\n }\n \n /// A list specifying general categories of I/O error.\n-#[derive(Copy, PartialEq, Eq, Clone, Show)]\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n pub enum IoErrorKind {\n     /// Any I/O error not part of this list.\n     OtherIoError,\n@@ -1662,7 +1662,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n /// A mode specifies how a file should be opened or created. These modes are\n /// passed to `File::open_mode` and are used to control where the file is\n /// positioned when it is initially opened.\n-#[derive(Copy, Clone, PartialEq, Eq, Show)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum FileMode {\n     /// Opens a file positioned at the beginning.\n     Open,\n@@ -1674,7 +1674,7 @@ pub enum FileMode {\n \n /// Access permissions with which the file should be opened. `File`s\n /// opened with `Read` will return an error if written to.\n-#[derive(Copy, Clone, PartialEq, Eq, Show)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum FileAccess {\n     /// Read-only access, requests to write will result in an error\n     Read,\n@@ -1685,7 +1685,7 @@ pub enum FileAccess {\n }\n \n /// Different kinds of files which can be identified by a call to stat\n-#[derive(Copy, PartialEq, Show, Hash, Clone)]\n+#[derive(Copy, PartialEq, Debug, Hash, Clone)]\n pub enum FileType {\n     /// This is a normal file, corresponding to `S_IFREG`\n     RegularFile,\n@@ -1789,7 +1789,7 @@ pub struct UnstableFileStat {\n bitflags! {\n     /// A set of permissions for a file or directory is represented by a set of\n     /// flags which are or'd together.\n-    #[derive(Show)]\n+    #[derive(Debug)]\n     flags FilePermission: u32 {\n         const USER_READ     = 0o400,\n         const USER_WRITE    = 0o200,\n@@ -1845,7 +1845,7 @@ mod tests {\n     use prelude::v1::{Ok, Vec, Buffer, SliceExt};\n     use uint;\n \n-    #[derive(Clone, PartialEq, Show)]\n+    #[derive(Clone, PartialEq, Debug)]\n     enum BadReaderBehavior {\n         GoodBehavior(uint),\n         BadBehavior(uint)"}, {"sha": "e37744f3aa3ec8c1f8873daeacde128ff5ee3794", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -29,7 +29,7 @@ use sys;\n use vec::Vec;\n \n /// Hints to the types of sockets that are desired when looking up hosts\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum SocketType {\n     Stream, Datagram, Raw\n }\n@@ -38,7 +38,7 @@ pub enum SocketType {\n /// to manipulate how a query is performed.\n ///\n /// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum Flag {\n     AddrConfig,\n     All,\n@@ -51,7 +51,7 @@ pub enum Flag {\n \n /// A transport protocol associated with either a hint or a return value of\n /// `lookup`\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum Protocol {\n     TCP, UDP\n }\n@@ -61,15 +61,15 @@ pub enum Protocol {\n ///\n /// For details on these fields, see their corresponding definitions via\n /// `man -s 3 getaddrinfo`\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct Hint {\n     pub family: uint,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n     pub flags: uint,\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct Info {\n     pub address: SocketAddr,\n     pub family: uint,"}, {"sha": "f0b73bd37f2b19e28b4e40d51e9ab36ff407edd3", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -32,7 +32,7 @@ use vec::Vec;\n \n pub type Port = u16;\n \n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Show)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n pub enum IpAddr {\n     Ipv4Addr(u8, u8, u8, u8),\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n@@ -64,7 +64,7 @@ impl fmt::Display for IpAddr {\n     }\n }\n \n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Show)]\n+#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n pub struct SocketAddr {\n     pub ip: IpAddr,\n     pub port: Port,"}, {"sha": "0da7670c5b49cf2a2eda037c8557a45824a27f0f", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -390,7 +390,7 @@ mod tests {\n         };\n \n         let _t = Thread::spawn(move|| {\n-            for _ in range(0u, times) {\n+            for _ in 0u..times {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write(&[100]) {\n                     Ok(..) => {}\n@@ -399,7 +399,7 @@ mod tests {\n             }\n         });\n \n-        for _ in range(0, times) {\n+        for _ in 0..times {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n             match client.read(&mut buf) {\n@@ -555,7 +555,7 @@ mod tests {\n             tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n         });\n         let l = rx.recv().unwrap();\n-        for i in range(0u, 1001) {\n+        for i in 0u..1001 {\n             match a.accept() {\n                 Ok(..) => break,\n                 Err(ref e) if e.kind == TimedOut => {}\n@@ -683,7 +683,7 @@ mod tests {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n-        for i in range(0u, 1001) {\n+        for i in 0u..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -727,7 +727,7 @@ mod tests {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         tx.send(()).unwrap();\n-        for _ in range(0u, 100) {\n+        for _ in 0u..100 {\n             assert!(s.write(&[0;128 * 1024]).is_ok());\n         }\n     }\n@@ -746,7 +746,7 @@ mod tests {\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n-        for i in range(0u, 1001) {\n+        for i in 0u..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,"}, {"sha": "e0feaa4e558e49ee4f2c3c85310fb83d47028fac", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -748,7 +748,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let _t = Thread::spawn(move|| {\n-            for _ in range(0, max) {\n+            for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n             }\n@@ -768,7 +768,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let _t = Thread::spawn(move|| {\n-            for _ in range(0, max) {\n+            for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n             }\n@@ -1160,7 +1160,7 @@ mod test {\n                 tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n             let _l = rx.recv().unwrap();\n-            for i in range(0i, 1001) {\n+            for i in 0i..1001 {\n                 match a.accept() {\n                     Ok(..) => break,\n                     Err(ref e) if e.kind == TimedOut => {}\n@@ -1260,7 +1260,7 @@ mod test {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n-        for i in range(0i, 1001) {\n+        for i in 0i..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -1299,7 +1299,7 @@ mod test {\n         assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         tx.send(()).unwrap();\n-        for _ in range(0i, 100) {\n+        for _ in 0i..100 {\n             assert!(s.write(&[0;128 * 1024]).is_ok());\n         }\n     }\n@@ -1318,7 +1318,7 @@ mod test {\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n-        for i in range(0i, 1001) {\n+        for i in 0i..1001 {\n             match s.write(&[0; 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n@@ -1388,7 +1388,7 @@ mod test {\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n-        for _ in range(0i, 50) {\n+        for _ in 0i..50 {\n             ::thread::Thread::yield_now();\n         }\n "}, {"sha": "5f1089bc63b99fe6c57e1959d5a330aaa2991bfc", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -448,7 +448,7 @@ mod test {\n         let _b = UdpSocket::bind(addr2).unwrap();\n \n         a.set_write_timeout(Some(1000));\n-        for _ in range(0u, 100) {\n+        for _ in 0u..100 {\n             match a.send_to(&[0;4*1024], addr2) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,"}, {"sha": "d3e60de2780e9398e755de89c8610fa6159eaad0", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -96,12 +96,12 @@ pub struct Process {\n /// A representation of environment variable name\n /// It compares case-insensitive on Windows and case-sensitive everywhere else.\n #[cfg(not(windows))]\n-#[derive(Hash, PartialEq, Eq, Clone, Show)]\n+#[derive(Hash, PartialEq, Eq, Clone, Debug)]\n struct EnvKey(CString);\n \n #[doc(hidden)]\n #[cfg(windows)]\n-#[derive(Eq, Clone, Show)]\n+#[derive(Eq, Clone, Debug)]\n struct EnvKey(CString);\n \n #[cfg(windows)]\n@@ -492,7 +492,7 @@ pub enum StdioContainer {\n \n /// Describes the result of a process after it has terminated.\n /// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[derive(PartialEq, Eq, Clone, Copy, Show)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n     ExitStatus(int),\n@@ -1142,7 +1142,7 @@ mod tests {\n     fn test_zero() {\n         let mut p = sleeper();\n         p.signal_kill().unwrap();\n-        for _ in range(0i, 20) {\n+        for _ in 0i..20 {\n             if p.signal(0).is_err() {\n                 assert!(!p.wait().unwrap().success());\n                 return"}, {"sha": "20cbde5db715ac69d031e4a787329f9008b5ca33", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -12,7 +12,7 @@\n \n use old_io::{fs, IoError, IoErrorKind, IoResult};\n use old_io;\n-use iter::{IteratorExt, range};\n+use iter::IteratorExt;\n use ops::Drop;\n use option::Option;\n use option::Option::{None, Some};\n@@ -102,7 +102,7 @@ impl TempDir {\n         }\n \n         let mut rng = thread_rng();\n-        for _ in range(0, NUM_RETRIES) {\n+        for _ in 0..NUM_RETRIES {\n             let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n             let leaf = if prefix.len() > 0 {\n                 format!(\"{}.{}\", prefix, suffix)"}, {"sha": "35f0bcb21d94b4a5b5e8c0ec35baaf81903ba7a4", "filename": "src/libstd/old_io/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -121,7 +121,7 @@ impl Timer {\n     /// let mut timer = Timer::new().unwrap();\n     /// let ten_milliseconds = timer.oneshot(Duration::milliseconds(10));\n     ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n+    /// for _ in 0u..100 { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `oneshot` call\n     /// ten_milliseconds.recv().unwrap();\n@@ -173,12 +173,12 @@ impl Timer {\n     /// let mut timer = Timer::new().unwrap();\n     /// let ten_milliseconds = timer.periodic(Duration::milliseconds(10));\n     ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n+    /// for _ in 0u..100 { /* do work */ }\n     ///\n     /// // blocks until 10 ms after the `periodic` call\n     /// ten_milliseconds.recv().unwrap();\n     ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n+    /// for _ in 0u..100 { /* do work */ }\n     ///\n     /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n     /// // previous `recv`)"}, {"sha": "9a55f32c372983919fbdad8d4aaab1787c5f6961", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -16,7 +16,7 @@ use old_io;\n use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct LimitReader<R> {\n     limit: uint,\n     inner: R\n@@ -78,7 +78,7 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n }\n \n /// A `Writer` which ignores bytes written to it, like /dev/null.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct NullWriter;\n \n impl Writer for NullWriter {\n@@ -87,7 +87,7 @@ impl Writer for NullWriter {\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct ZeroReader;\n \n impl Reader for ZeroReader {\n@@ -108,7 +108,7 @@ impl Buffer for ZeroReader {\n }\n \n /// A `Reader` which is always at EOF, like /dev/null.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub struct NullReader;\n \n impl Reader for NullReader {\n@@ -129,7 +129,7 @@ impl Buffer for NullReader {\n ///\n /// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n /// that error is returned immediately and remaining `Writer`s are not called.\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct MultiWriter<W> {\n     writers: Vec<W>\n }\n@@ -161,7 +161,7 @@ impl<W> Writer for MultiWriter<W> where W: Writer {\n \n /// A `Reader` which chains input from multiple `Reader`s, reading each to\n /// completion before moving onto the next.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct ChainedReader<I, R> {\n     readers: I,\n     cur_reader: Option<R>,\n@@ -200,7 +200,7 @@ impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n \n /// A `Reader` which forwards input from another `Reader`, passing it along to\n /// a `Writer` as well. Similar to the `tee(1)` command.\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct TeeReader<R, W> {\n     reader: R,\n     writer: W,\n@@ -242,7 +242,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()>\n }\n \n /// An adaptor converting an `Iterator<u8>` to a `Reader`.\n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct IterReader<T> {\n     iter: T,\n }\n@@ -418,7 +418,7 @@ mod test {\n \n     #[test]\n     fn test_iter_reader() {\n-        let mut r = IterReader::new(range(0u8, 8));\n+        let mut r = IterReader::new(0u8..8);\n         let mut buf = [0, 0, 0];\n         let len = r.read(&mut buf).unwrap();\n         assert_eq!(len, 3);\n@@ -437,7 +437,7 @@ mod test {\n \n     #[test]\n     fn iter_reader_zero_length() {\n-        let mut r = IterReader::new(range(0u8, 8));\n+        let mut r = IterReader::new(0u8..8);\n         let mut buf = [];\n         assert_eq!(Ok(0), r.read(&mut buf));\n     }"}, {"sha": "38c0a7b8f9b90e6b9b7e593d11df014f90fdb08a", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -617,7 +617,7 @@ unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use iter::range;\n \n-    range(0, argc as uint).map(|i| {\n+    (0..argc as uint).map(|i| {\n         ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n     }).collect()\n }\n@@ -643,7 +643,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n // In general it looks like:\n // res = Vec::new()\n // let args = [[NSProcessInfo processInfo] arguments]\n-// for i in range(0, [args count])\n+// for i in 0..[args count]\n //      res.push([args objectAtIndex:i])\n // res\n #[cfg(target_os = \"ios\")]\n@@ -679,7 +679,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n         let args = objc_msgSend(info, argumentsSel);\n \n         let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n-        for i in range(0, cnt) {\n+        for i in 0..cnt {\n             let tmp = objc_msgSend(args, objectAtSel, i);\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8Sel));\n@@ -717,7 +717,7 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args: Vec<_> = range(0, nArgs as uint).map(|i| unsafe {\n+    let args: Vec<_> = (0..nArgs as uint).map(|i| unsafe {\n         // Determine the length of this argument.\n         let ptr = *szArgList.offset(i as int);\n         let mut len = 0;\n@@ -857,7 +857,7 @@ pub enum MapOption {\n }\n \n /// Possible errors when creating a map.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum MapError {\n     /// # The following are POSIX-specific\n     ///"}, {"sha": "2e6b9d50553fa7c064081d8fc8b1d67fc9a029ef", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -959,7 +959,7 @@ pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n }\n \n /// Prefix types for Path\n-#[derive(Copy, PartialEq, Clone, Show)]\n+#[derive(Copy, PartialEq, Clone, Debug)]\n pub enum PathPrefix {\n     /// Prefix `\\\\?\\`, uint is the length of the following component\n     VerbatimPrefix(uint),"}, {"sha": "2969eec47373b122f3a06fbda59fc9952612b7c3", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -102,7 +102,7 @@\n //!    let total = 1_000_000;\n //!    let mut in_circle = 0;\n //!\n-//!    for _ in range(0, total) {\n+//!    for _ in 0u..total {\n //!        let a = between.ind_sample(&mut rng);\n //!        let b = between.ind_sample(&mut rng);\n //!        if a*a + b*b <= 1. {\n@@ -176,7 +176,7 @@\n //! }\n //!\n //! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n-//!     range(0, 3).filter(|x| !blocked.contains(x)).collect()\n+//!     (0u..3).filter(|x| !blocked.contains(x)).collect()\n //! }\n //!\n //! fn main() {\n@@ -190,7 +190,7 @@\n //!     let (mut keep_wins, mut keep_losses) = (0, 0);\n //!\n //!     println!(\"Running {} simulations...\", num_simulations);\n-//!     for _ in range(0, num_simulations) {\n+//!     for _ in 0..num_simulations {\n //!         let result = simulate(&random_door, &mut rng);\n //!\n //!         match (result.win, result.switch) {\n@@ -427,7 +427,7 @@ pub fn random<T: Rand>() -> T {\n /// use std::rand::{thread_rng, sample};\n ///\n /// let mut rng = thread_rng();\n-/// let sample = sample(&mut rng, range(1i, 100), 5);\n+/// let sample = sample(&mut rng, 1i..100, 5);\n /// println!(\"{:?}\", sample);\n /// ```\n pub fn sample<T, I: Iterator<Item=T>, R: Rng>(rng: &mut R,\n@@ -480,14 +480,14 @@ mod test {\n     #[test]\n     fn test_gen_range() {\n         let mut r = thread_rng();\n-        for _ in range(0, 1000) {\n+        for _ in 0u..1000 {\n             let a = r.gen_range(-3i, 42);\n             assert!(a >= -3 && a < 42);\n             assert_eq!(r.gen_range(0i, 1), 0);\n             assert_eq!(r.gen_range(-12i, -11), -12);\n         }\n \n-        for _ in range(0, 1000) {\n+        for _ in 0u..1000 {\n             let a = r.gen_range(10i, 42);\n             assert!(a >= 10 && a < 42);\n             assert_eq!(r.gen_range(0i, 1), 0);\n@@ -601,7 +601,7 @@ mod test {\n         let max_val = 100i;\n \n         let mut r = thread_rng();\n-        let vals = range(min_val, max_val).collect::<Vec<int>>();\n+        let vals = (min_val..max_val).collect::<Vec<int>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n \n@@ -652,7 +652,7 @@ mod bench {\n     fn rand_xorshift(b: &mut Bencher) {\n         let mut rng: XorShiftRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in 0..RAND_BENCH_N {\n                 rng.gen::<uint>();\n             }\n         });\n@@ -663,7 +663,7 @@ mod bench {\n     fn rand_isaac(b: &mut Bencher) {\n         let mut rng: IsaacRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in 0..RAND_BENCH_N {\n                 rng.gen::<uint>();\n             }\n         });\n@@ -674,7 +674,7 @@ mod bench {\n     fn rand_isaac64(b: &mut Bencher) {\n         let mut rng: Isaac64Rng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in 0..RAND_BENCH_N {\n                 rng.gen::<uint>();\n             }\n         });\n@@ -685,7 +685,7 @@ mod bench {\n     fn rand_std(b: &mut Bencher) {\n         let mut rng = StdRng::new().unwrap();\n         b.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n+            for _ in 0..RAND_BENCH_N {\n                 rng.gen::<uint>();\n             }\n         });"}, {"sha": "992afb2d10fc487232c6235c0e59bd6359b69b89", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -378,7 +378,7 @@ mod test {\n     fn test_os_rng_tasks() {\n \n         let mut txs = vec!();\n-        for _ in range(0, 20) {\n+        for _ in 0u..20 {\n             let (tx, rx) = channel();\n             txs.push(tx);\n \n@@ -392,7 +392,7 @@ mod test {\n                 Thread::yield_now();\n                 let mut v = [0u8; 1000];\n \n-                for _ in range(0, 100) {\n+                for _ in 0u..100 {\n                     r.next_u32();\n                     Thread::yield_now();\n                     r.next_u64();"}, {"sha": "b63f2e2d73a03df4f783892ed18f17cca57550bd", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -97,7 +97,7 @@ mod imp {\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n         let argv = argv as *const *const libc::c_char;\n-        range(0, argc as uint).map(|i| {\n+        (0..argc as uint).map(|i| {\n             ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n         }).collect()\n     }"}, {"sha": "581e540d3b6ed6686a0ce7aaf60d0fc8088de2ea", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -18,7 +18,7 @@ use sync::{Mutex, Condvar};\n /// use std::thread::Thread;\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n-/// for _ in range(0u, 10) {\n+/// for _ in 0u..10 {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n@@ -121,7 +121,7 @@ mod tests {\n         let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();\n \n-        for _ in range(0u, N - 1) {\n+        for _ in 0u..N - 1 {\n             let c = barrier.clone();\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n@@ -139,7 +139,7 @@ mod tests {\n         let mut leader_found = barrier.wait().is_leader();\n \n         // Now, the barrier is cleared and we should get data.\n-        for _ in range(0u, N - 1) {\n+        for _ in 0u..N - 1 {\n             if rx.recv().unwrap() {\n                 assert!(!leader_found);\n                 leader_found = true;"}, {"sha": "2ae81ad7dffe2fe2f20a6f4046439c3fbf30c28a", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -392,7 +392,7 @@ mod tests {\n \n         let data = Arc::new((Mutex::new(0), Condvar::new()));\n         let (tx, rx) = channel();\n-        for _ in range(0, N) {\n+        for _ in 0..N {\n             let data = data.clone();\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n@@ -417,7 +417,7 @@ mod tests {\n         cond.notify_all();\n         drop(cnt);\n \n-        for _ in range(0, N) {\n+        for _ in 0..N {\n             rx.recv().unwrap();\n         }\n     }"}, {"sha": "6a43eccbaba4e935945a19caec6a4aecb021d567", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -74,14 +74,14 @@\n //! // where tx is the sending half (tx for transmission), and rx is the receiving\n //! // half (rx for receiving).\n //! let (tx, rx) = channel();\n-//! for i in range(0i, 10i) {\n+//! for i in 0i..10i {\n //!     let tx = tx.clone();\n //!     Thread::spawn(move|| {\n //!         tx.send(i).unwrap();\n //!     });\n //! }\n //!\n-//! for _ in range(0i, 10i) {\n+//! for _ in 0i..10i {\n //!     let j = rx.recv().unwrap();\n //!     assert!(0 <= j && j < 10);\n //! }\n@@ -390,13 +390,13 @@ pub struct SendError<T>(pub T);\n ///\n /// The `recv` operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n-#[derive(PartialEq, Eq, Clone, Copy, Show)]\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[derive(PartialEq, Clone, Copy, Show)]\n+#[derive(PartialEq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n@@ -1147,9 +1147,9 @@ mod test {\n     fn stress() {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::scoped(move|| {\n-            for _ in range(0u, 10000) { tx.send(1i).unwrap(); }\n+            for _ in 0u..10000 { tx.send(1i).unwrap(); }\n         });\n-        for _ in range(0u, 10000) {\n+        for _ in 0u..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n         }\n         t.join().ok().unwrap();\n@@ -1162,7 +1162,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n \n         let t = Thread::scoped(move|| {\n-            for _ in range(0, AMT * NTHREADS) {\n+            for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n@@ -1171,10 +1171,10 @@ mod test {\n             }\n         });\n \n-        for _ in range(0, NTHREADS) {\n+        for _ in 0..NTHREADS {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n+                for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n         drop(tx);\n@@ -1187,13 +1187,13 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let t1 = Thread::scoped(move|| {\n             tx1.send(()).unwrap();\n-            for _ in range(0i, 40) {\n+            for _ in 0i..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n         let t2 = Thread::scoped(move|| {\n-            for _ in range(0i, 40) {\n+            for _ in 0i..40 {\n                 tx2.send(1).unwrap();\n             }\n         });\n@@ -1205,11 +1205,11 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n         let t = Thread::scoped(move|| {\n-            for _ in range(0i, 40) {\n+            for _ in 0i..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n         });\n-        for _ in range(0u, 40) {\n+        for _ in 0u..40 {\n             tx.send(1).unwrap();\n         }\n         t.join().ok().unwrap();\n@@ -1346,7 +1346,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n             let _t = Thread::spawn(move|| {\n                 drop(rx);\n@@ -1357,7 +1357,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n             let _t = Thread::spawn(move|| {\n                 drop(rx);\n@@ -1370,7 +1370,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n             Thread::spawn(move|| {\n                 let res = Thread::scoped(move|| {\n@@ -1388,7 +1388,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n             let _t = Thread::spawn(move|| {\n                 tx.send(box 10i).unwrap();\n@@ -1399,7 +1399,7 @@ mod test {\n \n     #[test]\n     fn stream_send_recv_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n \n             send(tx, 0);\n@@ -1429,22 +1429,22 @@ mod test {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n-        for _ in range(0i, 10000) { tx.send(()).unwrap(); }\n-        for _ in range(0i, 10000) { rx.recv().unwrap(); }\n+        for _ in 0i..10000 { tx.send(()).unwrap(); }\n+        for _ in 0i..10000 { rx.recv().unwrap(); }\n     }\n \n     #[test]\n     fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n-        for _ in range(0, total) {\n+        for _ in 0..total {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n \n-        for _ in range(0, total) {\n+        for _ in 0..total {\n             rx.recv().unwrap();\n         }\n     }\n@@ -1530,7 +1530,7 @@ mod test {\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { Thread::yield_now(); }\n+        for _ in 0u..5000 { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1654,9 +1654,9 @@ mod sync_tests {\n     fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n         Thread::spawn(move|| {\n-            for _ in range(0u, 10000) { tx.send(1).unwrap(); }\n+            for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n-        for _ in range(0u, 10000) {\n+        for _ in 0u..10000 {\n             assert_eq!(rx.recv().unwrap(), 1);\n         }\n     }\n@@ -1669,7 +1669,7 @@ mod sync_tests {\n         let (dtx, drx) = sync_channel::<()>(0);\n \n         Thread::spawn(move|| {\n-            for _ in range(0, AMT * NTHREADS) {\n+            for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n             match rx.try_recv() {\n@@ -1679,10 +1679,10 @@ mod sync_tests {\n             dtx.send(()).unwrap();\n         });\n \n-        for _ in range(0, NTHREADS) {\n+        for _ in 0..NTHREADS {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                for _ in range(0, AMT) { tx.send(1).unwrap(); }\n+                for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n         drop(tx);\n@@ -1810,7 +1810,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n             let _t = Thread::spawn(move|| {\n                 drop(rx);\n@@ -1821,7 +1821,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n             let _t = Thread::spawn(move|| {\n                 drop(rx);\n@@ -1834,7 +1834,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n             let _t = Thread::spawn(move|| {\n                 let res = Thread::scoped(move|| {\n@@ -1852,7 +1852,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n             let _t = Thread::spawn(move|| {\n                 tx.send(box 10i).unwrap();\n@@ -1863,7 +1863,7 @@ mod sync_tests {\n \n     #[test]\n     fn stream_send_recv_stress() {\n-        for _ in range(0, stress_factor()) {\n+        for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n \n             send(tx, 0);\n@@ -1893,22 +1893,22 @@ mod sync_tests {\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n-        for _ in range(0u, 10000) { tx.send(()).unwrap(); }\n-        for _ in range(0u, 10000) { rx.recv().unwrap(); }\n+        for _ in 0u..10000 { tx.send(()).unwrap(); }\n+        for _ in 0u..10000 { rx.recv().unwrap(); }\n     }\n \n     #[test]\n     fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n-        for _ in range(0, total) {\n+        for _ in 0..total {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n \n-        for _ in range(0, total) {\n+        for _ in 0..total {\n             rx.recv().unwrap();\n         }\n     }\n@@ -1994,7 +1994,7 @@ mod sync_tests {\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in range(0u, 5000) { Thread::yield_now(); }\n+        for _ in 0u..5000 { Thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2082,7 +2082,7 @@ mod sync_tests {\n             rx2.recv().unwrap();\n         }\n \n-        for _ in range(0u, 100) {\n+        for _ in 0u..100 {\n             repro()\n         }\n     }"}, {"sha": "53eba131674cf6b45d79ddd084fe9181138eba1b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -181,11 +181,11 @@ mod tests {\n         let (tx, rx) = channel();\n         let q = Arc::new(q);\n \n-        for _ in range(0, nthreads) {\n+        for _ in 0..nthreads {\n             let tx = tx.clone();\n             let q = q.clone();\n             Thread::spawn(move|| {\n-                for i in range(0, nmsgs) {\n+                for i in 0..nmsgs {\n                     q.push(i);\n                 }\n                 tx.send(()).unwrap();\n@@ -200,7 +200,7 @@ mod tests {\n             }\n         }\n         drop(tx);\n-        for _ in range(0, nthreads) {\n+        for _ in 0..nthreads {\n             rx.recv().unwrap();\n         }\n     }"}, {"sha": "f70e2dee8ee42c1e51bb126297f2d03a9d7a7b81", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -421,10 +421,10 @@ mod test {\n         let (tx3, rx3) = channel::<int>();\n \n         let _t = Thread::spawn(move|| {\n-            for _ in range(0u, 20) { Thread::yield_now(); }\n+            for _ in 0u..20 { Thread::yield_now(); }\n             tx1.send(1).unwrap();\n             rx3.recv().unwrap();\n-            for _ in range(0u, 20) { Thread::yield_now(); }\n+            for _ in 0u..20 { Thread::yield_now(); }\n         });\n \n         select! {\n@@ -445,7 +445,7 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = Thread::spawn(move|| {\n-            for _ in range(0u, 20) { Thread::yield_now(); }\n+            for _ in 0u..20 { Thread::yield_now(); }\n             tx1.send(1).unwrap();\n             tx2.send(2).unwrap();\n             rx3.recv().unwrap();\n@@ -472,7 +472,7 @@ mod test {\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = Thread::spawn(move|| {\n-            for i in range(0, AMT) {\n+            for i in 0..AMT {\n                 if i % 2 == 0 {\n                     tx1.send(i).unwrap();\n                 } else {\n@@ -482,7 +482,7 @@ mod test {\n             }\n         });\n \n-        for i in range(0, AMT) {\n+        for i in 0..AMT {\n             select! {\n                 i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1.unwrap()); },\n                 i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2.unwrap()); }\n@@ -550,7 +550,7 @@ mod test {\n             tx3.send(()).unwrap();\n         });\n \n-        for _ in range(0u, 1000) { Thread::yield_now(); }\n+        for _ in 0u..1000 { Thread::yield_now(); }\n         drop(tx1.clone());\n         tx2.send(()).unwrap();\n         rx3.recv().unwrap();\n@@ -663,7 +663,7 @@ mod test {\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in range(0u, 100) { Thread::yield_now() }\n+        for _ in 0u..100 { Thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -683,7 +683,7 @@ mod test {\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in range(0u, 100) { Thread::yield_now() }\n+        for _ in 0u..100 { Thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -702,7 +702,7 @@ mod test {\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in range(0u, 100) { Thread::yield_now() }\n+        for _ in 0u..100 { Thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -720,7 +720,7 @@ mod test {\n     fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let _t = Thread::spawn(move|| {\n-            for _ in range(0u, 100) { Thread::yield_now() }\n+            for _ in 0u..100 { Thread::yield_now() }\n             tx.send(1).unwrap();\n         });\n         select! {"}, {"sha": "45503f0b58e9150b2c25cba3aeace45a0edaafeb", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -325,7 +325,7 @@ mod test {\n             let (tx, rx) = channel();\n             let q2 = q.clone();\n             let _t = Thread::spawn(move|| {\n-                for _ in range(0u, 100000) {\n+                for _ in 0u..100000 {\n                     loop {\n                         match q2.pop() {\n                             Some(1i) => break,\n@@ -336,7 +336,7 @@ mod test {\n                 }\n                 tx.send(()).unwrap();\n             });\n-            for _ in range(0i, 100000) {\n+            for _ in 0i..100000 {\n                 q.push(1);\n             }\n             rx.recv().unwrap();"}, {"sha": "da3ce51a652f792823cac87646197331d9ebfb60", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -105,7 +105,7 @@ struct Buffer<T> {\n     size: uint,\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub enum Failure {\n     Empty,\n     Disconnected,\n@@ -150,7 +150,7 @@ impl<T: Send> Packet<T> {\n                     tail: ptr::null_mut(),\n                 },\n                 buf: Buffer {\n-                    buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n+                    buf: (0..cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },"}, {"sha": "c31010c170db9347379a5315032966fe16642fb3", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -60,7 +60,7 @@ use sys_common::mutex as sys;\n /// let data = Arc::new(Mutex::new(0));\n ///\n /// let (tx, rx) = channel();\n-/// for _ in range(0u, 10) {\n+/// for _ in 0u..10 {\n ///     let (data, tx) = (data.clone(), tx.clone());\n ///     Thread::spawn(move || {\n ///         // The shared static can only be accessed once the lock is held.\n@@ -371,7 +371,7 @@ mod test {\n         static K: uint = 3;\n \n         fn inc() {\n-            for _ in range(0, J) {\n+            for _ in 0..J {\n                 unsafe {\n                     let _g = M.lock().unwrap();\n                     CNT += 1;\n@@ -380,15 +380,15 @@ mod test {\n         }\n \n         let (tx, rx) = channel();\n-        for _ in range(0, K) {\n+        for _ in 0..K {\n             let tx2 = tx.clone();\n             Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n             let tx2 = tx.clone();\n             Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n         }\n \n         drop(tx);\n-        for _ in range(0, 2 * K) {\n+        for _ in 0..2 * K {\n             rx.recv().unwrap();\n         }\n         assert_eq!(unsafe {CNT}, J * K * 2);"}, {"sha": "0604003cecda56856e393d60c60d509660111f56", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -147,10 +147,10 @@ mod test {\n         static mut run: bool = false;\n \n         let (tx, rx) = channel();\n-        for _ in range(0u, 10) {\n+        for _ in 0u..10 {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n-                for _ in range(0u, 4) { Thread::yield_now() }\n+                for _ in 0u..4 { Thread::yield_now() }\n                 unsafe {\n                     O.call_once(|| {\n                         assert!(!run);\n@@ -170,7 +170,7 @@ mod test {\n             assert!(run);\n         }\n \n-        for _ in range(0u, 10) {\n+        for _ in 0u..10 {\n             rx.recv().unwrap();\n         }\n     }"}, {"sha": "b5817ad64f612d01887df4a79bc70c6d58118c78", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -416,11 +416,11 @@ mod tests {\n         static M: uint = 1000;\n \n         let (tx, rx) = channel::<()>();\n-        for _ in range(0, N) {\n+        for _ in 0..N {\n             let tx = tx.clone();\n             Thread::spawn(move|| {\n                 let mut rng = rand::thread_rng();\n-                for _ in range(0, M) {\n+                for _ in 0..M {\n                     if rng.gen_weighted_bool(N) {\n                         drop(R.write().unwrap());\n                     } else {\n@@ -488,7 +488,7 @@ mod tests {\n \n         Thread::spawn(move|| {\n             let mut lock = arc2.write().unwrap();\n-            for _ in range(0u, 10) {\n+            for _ in 0u..10 {\n                 let tmp = *lock;\n                 *lock = -1;\n                 Thread::yield_now();\n@@ -499,7 +499,7 @@ mod tests {\n \n         // Readers try to catch the writer in the act\n         let mut children = Vec::new();\n-        for _ in range(0u, 5) {\n+        for _ in 0u..5 {\n             let arc3 = arc.clone();\n             children.push(Thread::scoped(move|| {\n                 let lock = arc3.read().unwrap();"}, {"sha": "1bfcbcf96f1443cbbd78a721ac6dece674c4c96b", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -66,7 +66,7 @@ impl<'a> Drop for Sentinel<'a> {\n /// let pool = TaskPool::new(4u);\n ///\n /// let (tx, rx) = channel();\n-/// for _ in range(0, 8u) {\n+/// for _ in 0..8u {\n ///     let tx = tx.clone();\n ///     pool.execute(move|| {\n ///         tx.send(1u).unwrap();\n@@ -96,7 +96,7 @@ impl TaskPool {\n         let rx = Arc::new(Mutex::new(rx));\n \n         // Threadpool threads\n-        for _ in range(0, threads) {\n+        for _ in 0..threads {\n             spawn_in_pool(rx.clone());\n         }\n \n@@ -151,7 +151,7 @@ mod test {\n         let pool = TaskPool::new(TEST_TASKS);\n \n         let (tx, rx) = channel();\n-        for _ in range(0, TEST_TASKS) {\n+        for _ in 0..TEST_TASKS {\n             let tx = tx.clone();\n             pool.execute(move|| {\n                 tx.send(1u).unwrap();\n@@ -174,13 +174,13 @@ mod test {\n         let pool = TaskPool::new(TEST_TASKS);\n \n         // Panic all the existing threads.\n-        for _ in range(0, TEST_TASKS) {\n+        for _ in 0..TEST_TASKS {\n             pool.execute(move|| -> () { panic!() });\n         }\n \n         // Ensure new threads were spawned to compensate.\n         let (tx, rx) = channel();\n-        for _ in range(0, TEST_TASKS) {\n+        for _ in 0..TEST_TASKS {\n             let tx = tx.clone();\n             pool.execute(move|| {\n                 tx.send(1u).unwrap();\n@@ -198,7 +198,7 @@ mod test {\n         let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n \n         // Panic all the existing threads in a bit.\n-        for _ in range(0, TEST_TASKS) {\n+        for _ in 0..TEST_TASKS {\n             let waiter = waiter.clone();\n             pool.execute(move|| {\n                 waiter.wait();"}, {"sha": "51b6e0a1c1e12de0e9f011620d4430fe8b78cc58", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -32,7 +32,7 @@ use old_io;\n \n // FIXME: move uses of Arc and deadline tracking to std::io\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub enum SocketStatus {\n     Readable,\n     Writable,"}, {"sha": "e310b8f6d90b3f3fe5a635124e1ba7ab06fbce8c", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -126,7 +126,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     let cnt = unsafe { backtrace(buf.as_mut_ptr(), SIZE as libc::c_int) as uint};\n \n     // skipping the first one as it is write itself\n-    let iter = range(1, cnt).map(|i| {\n+    let iter = (1..cnt).map(|i| {\n         print(w, i as int, buf[i])\n     });\n     result::fold(iter, (), |_, _| ())"}, {"sha": "3fcca2f35e1b760b3a01b9d7c1b70ab6d5ed3375", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -224,7 +224,7 @@ impl Process {\n                 if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n \n                 // close all other fds\n-                for fd in range(3, getdtablesize()).rev() {\n+                for fd in (3..getdtablesize()).rev() {\n                     if fd != output.fd() {\n                         let _ = close(fd as c_int);\n                     }"}, {"sha": "3d66718d00ba0c73f08cd996603eea48de612975", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -388,7 +388,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n             cmd.push('\"');\n         }\n         let argvec: Vec<char> = arg.chars().collect();\n-        for i in range(0u, argvec.len()) {\n+        for i in 0u..argvec.len() {\n             append_char_at(cmd, argvec.as_slice(), i);\n         }\n         if quote {"}, {"sha": "655195a3c28c0cbe8238678209f09b80a429237a", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -235,7 +235,7 @@ unsafe extern \"system\" fn on_tls_callback(h: LPVOID,\n \n unsafe fn run_dtors() {\n     let mut any_run = true;\n-    for _ in range(0, 5i) {\n+    for _ in 0..5i {\n         if !any_run { break }\n         any_run = false;\n         let dtors = {"}, {"sha": "483e5995298959368f263763ab9abe1bd56ecb03", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -45,7 +45,7 @@ macro_rules! try_opt {\n \n /// ISO 8601 time duration with nanosecond precision.\n /// This also allows for the negative duration; see individual methods for details.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct Duration {\n     secs: i64,\n     nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC"}, {"sha": "2325b3778c757713531e8142505b0cdca8734d24", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,7 +15,7 @@ pub use self::AbiArchitecture::*;\n \n use std::fmt;\n \n-#[derive(Copy, PartialEq, Eq, Show)]\n+#[derive(Copy, PartialEq, Eq, Debug)]\n pub enum Os {\n     OsWindows,\n     OsMacos,\n@@ -26,7 +26,7 @@ pub enum Os {\n     OsDragonfly,\n }\n \n-#[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Show)]\n+#[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Debug)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -47,7 +47,7 @@ pub enum Abi {\n }\n \n #[allow(non_camel_case_types)]\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub enum Architecture {\n     X86,\n     X86_64,"}, {"sha": "11068880b0e261b23edaebf9297a960f9c12800f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -208,14 +208,14 @@ impl Decodable for Ident {\n pub type FnIdent = Option<Ident>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash,\n-           Show, Copy)]\n+           Debug, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n     pub span: Span,\n     pub name: Name\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>\n@@ -224,7 +224,7 @@ pub struct LifetimeDef {\n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n /// std::cmp::PartialEq  .  It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Path {\n     pub span: Span,\n     /// A `::foo` path, is relative to the crate root rather than current\n@@ -236,7 +236,7 @@ pub struct Path {\n \n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     pub identifier: Ident,\n@@ -249,7 +249,7 @@ pub struct PathSegment {\n     pub parameters: PathParameters,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n     AngleBracketedParameters(AngleBracketedParameterData),\n     ParenthesizedParameters(ParenthesizedParameterData),\n@@ -327,7 +327,7 @@ impl PathParameters {\n }\n \n /// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: Vec<Lifetime>,\n@@ -345,7 +345,7 @@ impl AngleBracketedParameterData {\n }\n \n /// A path like `Foo(A,B) -> C`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ParenthesizedParameterData {\n     /// Overall span\n     pub span: Span,\n@@ -362,7 +362,7 @@ pub type CrateNum = u32;\n pub type NodeId = u32;\n \n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n-           RustcDecodable, Hash, Show, Copy)]\n+           RustcDecodable, Hash, Debug, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub node: NodeId,\n@@ -382,23 +382,23 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and\n /// detects Copy, Send and Sync.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TyParamBound {\n     TraitTyParamBound(PolyTraitRef, TraitBoundModifier),\n     RegionTyParamBound(Lifetime)\n }\n \n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitBoundModifier {\n     None,\n     Maybe,\n }\n \n pub type TyParamBounds = OwnedSlice<TyParamBound>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n@@ -409,7 +409,7 @@ pub struct TyParam {\n \n /// Represents lifetimes and type parameters attached to a declaration\n /// of a function, enum, trait, etc.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n     pub lifetimes: Vec<LifetimeDef>,\n     pub ty_params: OwnedSlice<TyParam>,\n@@ -428,34 +428,34 @@ impl Generics {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum WherePredicate {\n     BoundPredicate(WhereBoundPredicate),\n     RegionPredicate(WhereRegionPredicate),\n     EqPredicate(WhereEqPredicate)\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     pub bounded_ty: P<Ty>,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n     pub bounds: Vec<Lifetime>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereEqPredicate {\n     pub id: NodeId,\n     pub span: Span,\n@@ -467,7 +467,7 @@ pub struct WhereEqPredicate {\n /// used to drive conditional compilation\n pub type CrateConfig = Vec<P<MetaItem>> ;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n@@ -478,7 +478,7 @@ pub struct Crate {\n \n pub type MetaItem = Spanned<MetaItem_>;\n \n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MetaItem_ {\n     MetaWord(InternedString),\n     MetaList(InternedString, Vec<P<MetaItem>>),\n@@ -510,7 +510,7 @@ impl PartialEq for MetaItem_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     pub stmts: Vec<P<Stmt>>,\n     pub expr: Option<P<Expr>>,\n@@ -519,27 +519,27 @@ pub struct Block {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Pat {\n     pub id: NodeId,\n     pub node: Pat_,\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FieldPat {\n     pub ident: Ident,\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n     BindByValue(Mutability),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PatWildKind {\n     /// Represents the wildcard pattern `_`\n     PatWildSingle,\n@@ -548,7 +548,7 @@ pub enum PatWildKind {\n     PatWildMulti,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Pat_ {\n     /// Represents a wildcard pattern (either `_` or `..`)\n     PatWild(PatWildKind),\n@@ -577,13 +577,13 @@ pub enum Pat_ {\n     PatMac(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Mutability {\n     MutMutable,\n     MutImmutable,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n     BiAdd,\n     BiSub,\n@@ -607,7 +607,7 @@ pub enum BinOp_ {\n \n pub type BinOp = Spanned<BinOp_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnOp {\n     UnUniq,\n     UnDeref,\n@@ -617,7 +617,7 @@ pub enum UnOp {\n \n pub type Stmt = Spanned<Stmt_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Stmt_ {\n     /// Could be an item or a local (let) binding:\n     StmtDecl(P<Decl>, NodeId),\n@@ -631,7 +631,7 @@ pub enum Stmt_ {\n     StmtMac(P<Mac>, MacStmtStyle),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n     /// `foo!(...);`, `foo![...];`\n@@ -646,7 +646,7 @@ pub enum MacStmtStyle {\n \n /// Where a local declaration came from: either a true `let ... =\n /// ...;`, or one desugared from the pattern of a for loop.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LocalSource {\n     LocalLet,\n     LocalFor,\n@@ -655,7 +655,7 @@ pub enum LocalSource {\n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n /// Local represents a `let` statement, e.g., `let <pat>:<ty> = <expr>;`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Local {\n     pub pat: P<Pat>,\n     pub ty: Option<P<Ty>>,\n@@ -667,7 +667,7 @@ pub struct Local {\n \n pub type Decl = Spanned<Decl_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Decl_ {\n     /// A local (let) binding:\n     DeclLocal(P<Local>),\n@@ -676,15 +676,15 @@ pub enum Decl_ {\n }\n \n /// represents one arm of a 'match'\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n     pub pats: Vec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n     pub ident: SpannedIdent,\n     pub expr: P<Expr>,\n@@ -693,26 +693,26 @@ pub struct Field {\n \n pub type SpannedIdent = Spanned<Ident>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BlockCheckMode {\n     DefaultBlock,\n     UnsafeBlock(UnsafeSource),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum UnsafeSource {\n     CompilerGenerated,\n     UserProvided,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Expr_ {\n     /// First expr is the place; second expr is the value.\n     ExprBox(Option<P<Expr>>, P<Expr>),\n@@ -776,28 +776,28 @@ pub enum Expr_ {\n ///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n ///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n ///      self_type  trait_name  item_path\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QPath {\n     pub self_type: P<Ty>,\n     pub trait_ref: P<TraitRef>,\n     pub item_path: PathSegment,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum MatchSource {\n     Normal,\n     IfLetDesugar { contains_else_clause: bool },\n     WhileLetDesugar,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n     CaptureByRef,\n }\n \n /// A delimited sequence of token trees\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Delimited {\n     /// The type of delimiter\n     pub delim: token::DelimToken,\n@@ -832,7 +832,7 @@ impl Delimited {\n }\n \n /// A sequence of token treesee\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct SequenceRepetition {\n     /// The sequence of token trees\n     pub tts: Vec<TokenTree>,\n@@ -846,7 +846,7 @@ pub struct SequenceRepetition {\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum KleeneOp {\n     ZeroOrMore,\n     OneOrMore,\n@@ -864,7 +864,7 @@ pub enum KleeneOp {\n ///\n /// The RHS of an MBE macro is the only place `SubstNt`s are substituted.\n /// Nothing special happens to misnamed or misplaced `SubstNt`s.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum TokenTree {\n     /// A single token\n@@ -955,22 +955,22 @@ pub type Mac = Spanned<Mac_>;\n /// is being invoked, and the vector of token-trees contains the source\n /// of the macro invocation.\n /// There's only one flavor, now, so this could presumably be simplified.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Mac_ {\n     // NB: the additional ident for a macro_rules-style macro is actually\n     // stored in the enclosing item. Oog.\n     MacInvocTT(Path, Vec<TokenTree>, SyntaxContext),   // new macro-invocation\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StrStyle {\n     CookedStr,\n     RawStr(usize)\n }\n \n pub type Lit = Spanned<Lit_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Sign {\n     Minus,\n     Plus\n@@ -986,7 +986,7 @@ impl Sign {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum LitIntType {\n     SignedIntLit(IntTy, Sign),\n     UnsignedIntLit(UintTy),\n@@ -1003,7 +1003,7 @@ impl LitIntType {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Lit_ {\n     LitStr(InternedString, StrStyle),\n     LitBinary(Rc<Vec<u8>>),\n@@ -1017,13 +1017,13 @@ pub enum Lit_ {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MutTy {\n     pub ty: P<Ty>,\n     pub mutbl: Mutability,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeField {\n     pub ident: Ident,\n     pub mt: MutTy,\n@@ -1032,7 +1032,7 @@ pub struct TypeField {\n \n /// Represents a required method in a trait declaration,\n /// one without a default implementation\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeMethod {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1050,26 +1050,26 @@ pub struct TypeMethod {\n /// a default implementation A trait method is either required (meaning it\n /// doesn't have an implementation, just a signature) or provided (meaning it\n /// has a default implementation).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitItem {\n     RequiredMethod(TypeMethod),\n     ProvidedMethod(P<Method>),\n     TypeTraitItem(P<AssociatedType>),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ImplItem {\n     MethodImplItem(P<Method>),\n     TypeImplItem(P<Typedef>),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AssociatedType {\n     pub attrs: Vec<Attribute>,\n     pub ty_param: TyParam,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Typedef {\n     pub id: NodeId,\n     pub span: Span,\n@@ -1196,7 +1196,7 @@ impl FloatTy {\n }\n \n // Bind a type to an associated type: `A=Foo`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n     pub id: NodeId,\n     pub ident: Ident,\n@@ -1206,15 +1206,15 @@ pub struct TypeBinding {\n \n \n // NB PartialEq method appears below.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Ty {\n     pub id: NodeId,\n     pub node: Ty_,\n     pub span: Span,\n }\n \n /// Not represented directly in the AST, referred to by name through a ty_path.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PrimTy {\n     TyInt(IntTy),\n     TyUint(UintTy),\n@@ -1224,15 +1224,15 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n     pub lifetimes: Vec<LifetimeDef>,\n     pub decl: P<FnDecl>\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n /// The different kinds of types recognized by the compiler\n pub enum Ty_ {\n     TyVec(P<Ty>),\n@@ -1265,13 +1265,13 @@ pub enum Ty_ {\n     TyInfer,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum AsmDialect {\n     AsmAtt,\n     AsmIntel\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n@@ -1285,7 +1285,7 @@ pub struct InlineAsm {\n }\n \n /// represents an argument in a function header\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n@@ -1313,14 +1313,14 @@ impl Arg {\n }\n \n /// represents the header (not the body) of a function declaration\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n     pub output: FunctionRetTy,\n     pub variadic: bool\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n     Normal,\n@@ -1353,7 +1353,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum FunctionRetTy {\n     /// Functions with return type ! that always\n     /// raise an error or exit (i.e. never return to the caller)\n@@ -1377,7 +1377,7 @@ impl FunctionRetTy {\n }\n \n /// Represents the kind of 'self' associated with a method\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ExplicitSelf_ {\n     /// No self\n     SelfStatic,\n@@ -1391,15 +1391,15 @@ pub enum ExplicitSelf_ {\n \n pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Method {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub node: Method_,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Method_ {\n     /// Represents a method declaration\n     MethDecl(Ident,\n@@ -1414,7 +1414,7 @@ pub enum Method_ {\n     MethMac(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token\n@@ -1423,30 +1423,30 @@ pub struct Mod {\n     pub items: Vec<P<Item>>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n     pub items: Vec<P<ForeignItem>>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct VariantArg {\n     pub ty: P<Ty>,\n     pub id: NodeId,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantKind {\n     TupleVariantKind(Vec<VariantArg>),\n     StructVariantKind(P<StructDef>),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n     pub variants: Vec<P<Variant>>,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub name: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1458,7 +1458,7 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum PathListItem_ {\n     PathListIdent { name: Ident, id: NodeId },\n     PathListMod { id: NodeId }\n@@ -1476,7 +1476,7 @@ pub type PathListItem = Spanned<PathListItem_>;\n \n pub type ViewPath = Spanned<ViewPath_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ViewPath_ {\n \n     /// `foo::bar::baz as quux`\n@@ -1499,17 +1499,17 @@ pub type Attribute = Spanned<Attribute_>;\n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n /// distinguished for pretty-printing.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum AttrStyle {\n     AttrOuter,\n     AttrInner,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct AttrId(pub usize);\n \n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Attribute_ {\n     pub id: AttrId,\n     pub style: AttrStyle,\n@@ -1522,13 +1522,13 @@ pub struct Attribute_ {\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n /// If this impl is an ItemImpl, the impl_id is redundant (it could be the\n /// same as the impl's node id).\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n     pub bound_lifetimes: Vec<LifetimeDef>,\n@@ -1537,7 +1537,7 @@ pub struct PolyTraitRef {\n     pub trait_ref: TraitRef,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum Visibility {\n     Public,\n     Inherited,\n@@ -1552,7 +1552,7 @@ impl Visibility {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n@@ -1571,7 +1571,7 @@ impl StructField_ {\n \n pub type StructField = Spanned<StructField_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum StructFieldKind {\n     NamedField(Ident, Visibility),\n     /// Element of a tuple-like struct\n@@ -1587,7 +1587,7 @@ impl StructFieldKind {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructDef {\n     /// Fields, not including ctor\n     pub fields: Vec<StructField>,\n@@ -1600,7 +1600,7 @@ pub struct StructDef {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1610,7 +1610,7 @@ pub struct Item {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     // Optional location (containing arbitrary characters) from which\n     // to fetch the crate sources.\n@@ -1661,7 +1661,7 @@ impl Item_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,\n@@ -1671,7 +1671,7 @@ pub struct ForeignItem {\n     pub vis: Visibility,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n     ForeignItemFn(P<FnDecl>, Generics),\n     ForeignItemStatic(P<Ty>, /* is_mutbl */ bool),\n@@ -1686,7 +1686,7 @@ impl ForeignItem_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum ClosureKind {\n     FnClosureKind,\n     FnMutClosureKind,\n@@ -1696,7 +1696,7 @@ pub enum ClosureKind {\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum InlinedItem {\n     IIItem(P<Item>),\n     IITraitItem(DefId /* impl id */, TraitItem),\n@@ -1707,7 +1707,7 @@ pub enum InlinedItem {\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub ident: Ident,\n     pub attrs: Vec<Attribute>,"}, {"sha": "8546e03cc87d9e5a586112ac4764aca59664a644", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -32,7 +32,7 @@ use std::slice;\n \n pub mod blocks;\n \n-#[derive(Clone, Copy, PartialEq, Show)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n pub enum PathElem {\n     PathMod(Name),\n     PathName(Name)\n@@ -91,7 +91,7 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n     })\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n     NodeForeignItem(&'ast ForeignItem),\n@@ -113,7 +113,7 @@ pub enum Node<'ast> {\n \n /// Represents an entry and its parent Node ID\n /// The odd layout is to bring down the total size.\n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum MapEntry<'ast> {\n     /// Placeholder for holes in the map.\n     NotPresent,\n@@ -144,7 +144,7 @@ impl<'ast> Clone for MapEntry<'ast> {\n     }\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct InlinedParent {\n     path: Vec<PathElem>,\n     ii: InlinedItem"}, {"sha": "7f1264ac9a1d304811e723f3a110a787b5945cc8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -352,7 +352,7 @@ pub fn empty_generics() -> Generics {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-#[derive(RustcEncodable, RustcDecodable, Show, Copy)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, Copy)]\n pub struct IdRange {\n     pub min: NodeId,\n     pub max: NodeId,"}, {"sha": "4427a7aaf021b34e6578f7dcc09be61a99e3f686", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -346,7 +346,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n }\n \n /// Represents the #[deprecated] and friends attributes.\n-#[derive(RustcEncodable,RustcDecodable,Clone,Show)]\n+#[derive(RustcEncodable,RustcDecodable,Clone,Debug)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: InternedString,\n@@ -358,7 +358,7 @@ pub struct Stability {\n }\n \n /// The available stability levels.\n-#[derive(RustcEncodable,RustcDecodable,PartialEq,PartialOrd,Clone,Show,Copy)]\n+#[derive(RustcEncodable,RustcDecodable,PartialEq,PartialOrd,Clone,Debug,Copy)]\n pub enum StabilityLevel {\n     Unstable,\n     Stable,\n@@ -570,7 +570,7 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n     }\n }\n \n-#[derive(PartialEq, Show, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(PartialEq, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum ReprAttr {\n     ReprAny,\n     ReprInt(Span, IntType),\n@@ -589,7 +589,7 @@ impl ReprAttr {\n     }\n }\n \n-#[derive(Eq, Hash, PartialEq, Show, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Eq, Hash, PartialEq, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum IntType {\n     SignedInt(ast::IntTy),\n     UnsignedInt(ast::UintTy)"}, {"sha": "8adb9b24222392a030f2358494e99316d4b6f3aa", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -36,13 +36,13 @@ pub trait Pos {\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Show)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Debug)]\n pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, PartialEq, Hash, PartialOrd, Show)]\n+#[derive(Copy, PartialEq, Hash, PartialOrd, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -94,7 +94,7 @@ impl Sub for CharPos {\n /// are *absolute* positions from the beginning of the codemap, not positions\n /// relative to FileMaps. Methods on the CodeMap can be used to relate spans back\n /// to the original source.\n-#[derive(Clone, Copy, Show, Hash)]\n+#[derive(Clone, Copy, Debug, Hash)]\n pub struct Span {\n     pub lo: BytePos,\n     pub hi: BytePos,\n@@ -110,7 +110,7 @@ pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n                                          hi: BytePos(0),\n                                          expn_id: COMMAND_LINE_EXPN };\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct Spanned<T> {\n     pub node: T,\n     pub span: Span,\n@@ -193,15 +193,15 @@ pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n \n /// The syntax with which a macro was invoked.\n-#[derive(Clone, Copy, Hash, Show)]\n+#[derive(Clone, Copy, Hash, Debug)]\n pub enum MacroFormat {\n     /// e.g. #[derive(...)] <item>\n     MacroAttribute,\n     /// e.g. `format!()`\n     MacroBang\n }\n \n-#[derive(Clone, Hash, Show)]\n+#[derive(Clone, Hash, Debug)]\n pub struct NameAndSpan {\n     /// The name of the macro that was invoked to create the thing\n     /// with this Span.\n@@ -215,7 +215,7 @@ pub struct NameAndSpan {\n }\n \n /// Extra information for tracking macro expansion of spans\n-#[derive(Hash, Show)]\n+#[derive(Hash, Debug)]\n pub struct ExpnInfo {\n     /// The location of the actual macro invocation, e.g. `let x =\n     /// foo!();`\n@@ -236,7 +236,7 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n-#[derive(PartialEq, Eq, Clone, Show, Hash, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(PartialEq, Eq, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Copy)]\n pub struct ExpnId(u32);\n \n pub const NO_EXPANSION: ExpnId = ExpnId(-1);\n@@ -431,7 +431,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in range(lo.line - 1us, hi.line as usize) {\n+        for i in lo.line - 1us..hi.line as usize {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}"}, {"sha": "821ac8e2f89bc1c0db6f5488c36f96e840beef8d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -20,7 +20,6 @@ use diagnostics;\n use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::old_io;\n-use std::iter::range;\n use std::string::String;\n use term::WriterWrapper;\n use term;\n@@ -235,7 +234,7 @@ pub fn mk_handler(can_emit_warnings: bool, e: Box<Emitter + Send>) -> Handler {\n     }\n }\n \n-#[derive(Copy, PartialEq, Clone, Show)]\n+#[derive(Copy, PartialEq, Clone, Debug)]\n pub enum Level {\n     Bug,\n     Fatal,\n@@ -490,11 +489,11 @@ fn highlight_lines(err: &mut EmitterWriter,\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3us;\n-        for _ in range(0, skip) {\n+        for _ in 0..skip {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in range(0us, left - skip) {\n+            for pos in 0us..left - skip {\n                 let cur_char = orig.as_bytes()[pos] as char;\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space).\n@@ -513,7 +512,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1us;\n-            for _ in range(0, num_squigglies) {\n+            for _ in 0..num_squigglies {\n                 s.push('~');\n             }\n         }\n@@ -563,7 +562,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     // Span seems to use half-opened interval, so subtract 1\n     let skip = last_line_start.len() + hi.col.to_usize() - 1;\n     let mut s = String::new();\n-    for _ in range(0, skip) {\n+    for _ in 0..skip {\n         s.push(' ');\n     }\n     s.push('^');"}, {"sha": "a184cc5c2b296820c3c0fe50772cf6e0bb105cb4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -73,7 +73,7 @@ impl<F> ItemModifier for F\n     }\n }\n \n-#[derive(Show,Clone)]\n+#[derive(Debug,Clone)]\n pub enum Annotatable {\n     Item(P<ast::Item>),\n     TraitItem(ast::TraitItem),"}, {"sha": "1b84d93738d5e6c2bec3e1edb712fcf67e05fc1f", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -770,7 +770,7 @@ impl<'a> MethodDef<'a> {\n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n-        for i in range(0us, self_args.len()) {\n+        for i in 0us..self_args.len() {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n             let (pat, ident_expr) =\n                 trait_.create_struct_pattern(cx,\n@@ -1154,7 +1154,7 @@ impl<'a> MethodDef<'a> {\n             // to an uninhabited type (e.g. a zero-variant enum or a\n             // type holding such an enum), but do not feature-gate\n             // zero-variant enums themselves, then attempting to\n-            // derive Show on such a type could here generate code\n+            // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n             return cx.expr_unreachable(sp);"}, {"sha": "d3d7fee3a189a19a578835ce1712b5b888c8d600", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -107,8 +107,14 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n \n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n-                            // NOTE(stage0): remove \"Show\"\n-                            \"Show\" => expand!(show::expand_deriving_show),\n+                            \"Show\" => {\n+                                cx.span_warn(titem.span,\n+                                             \"derive(Show) is deprecated \\\n+                                              in favor of derive(Debug)\");\n+\n+                                expand!(show::expand_deriving_show)\n+                            },\n+\n                             \"Debug\" => expand!(show::expand_deriving_show),\n \n                             \"Default\" => expand!(default::expand_deriving_default),"}, {"sha": "2a0a352f1281a6b5119693c4a368146f74df5fe9", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -661,7 +661,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     name_ordering: Vec<String>,\n                                     names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n-    let arg_types: Vec<_> = range(0, args.len()).map(|_| None).collect();\n+    let arg_types: Vec<_> = (0..args.len()).map(|_| None).collect();\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,"}, {"sha": "b6563d77b8864e7df854dd6be4dbee1af75fecae", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -38,7 +38,7 @@ pub struct SCTable {\n     rename_memo: RefCell<HashMap<(SyntaxContext,Ident,Name),SyntaxContext>>,\n }\n \n-#[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n+#[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n@@ -309,7 +309,7 @@ mod tests {\n \n     // because of the SCTable, I now need a tidy way of\n     // creating syntax objects. Sigh.\n-    #[derive(Clone, PartialEq, Show)]\n+    #[derive(Clone, PartialEq, Debug)]\n     enum TestSC {\n         M(Mrk),\n         R(Ident,Name)"}, {"sha": "0f617302c921951706d3e7a11185233e4946719f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -665,7 +665,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n         }\n         ref tt @ ast::TtToken(_, MatchNt(..)) => {\n             let mut seq = vec![];\n-            for i in range(0, tt.len()) {\n+            for i in 0..tt.len() {\n                 seq.push(tt.get_tt(i));\n             }\n             mk_tts(cx, &seq[])"}, {"sha": "e3211c7c337e64d975d2abf48af6f4636ff2e5e4", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -166,7 +166,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(&ms[]);\n-    let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n+    let matches: Vec<_> = (0..match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n@@ -339,7 +339,7 @@ pub fn parse(sess: &ParseSess,\n                         // most of the time.\n \n                         // Only touch the binders we have actually bound\n-                        for idx in range(ei.match_lo, ei.match_hi) {\n+                        for idx in ei.match_lo..ei.match_hi {\n                             let sub = (ei.matches[idx]).clone();\n                             (&mut new_pos.matches[idx])\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n@@ -385,14 +385,14 @@ pub fn parse(sess: &ParseSess,\n                             new_ei.match_cur += seq.num_captures;\n                             new_ei.idx += 1us;\n                             //we specifically matched zero repeats.\n-                            for idx in range(ei.match_cur, ei.match_cur + seq.num_captures) {\n+                            for idx in ei.match_cur..ei.match_cur + seq.num_captures {\n                                 (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n                             }\n \n                             cur_eis.push(new_ei);\n                         }\n \n-                        let matches: Vec<_> = range(0, ei.matches.len())\n+                        let matches: Vec<_> = (0..ei.matches.len())\n                             .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n                         cur_eis.push(box MatcherPos {\n@@ -495,7 +495,7 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 cur_eis.push(ei);\n \n-                for _ in range(0, rust_parser.tokens_consumed) {\n+                for _ in 0..rust_parser.tokens_consumed {\n                     let _ = rdr.next_token();\n                 }\n             }"}, {"sha": "493a97c24cff492421e7f3cc4fe4a077048a79b5", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -52,7 +52,7 @@ pub trait Reader {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Show)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct TokenAndSpan {\n     pub tok: token::Token,\n     pub sp: Span,\n@@ -732,7 +732,7 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.last_pos;\n         let mut accum_int = 0;\n \n-        for _ in range(0, n_digits) {\n+        for _ in 0..n_digits {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n@@ -1217,15 +1217,15 @@ impl<'a> StringReader<'a> {\n                 }\n                 //if self.curr_is('\"') {\n                     //content_end_bpos = self.last_pos;\n-                    //for _ in range(0, hash_count) {\n+                    //for _ in 0..hash_count {\n                         //self.bump();\n                         //if !self.curr_is('#') {\n                             //continue 'outer;\n                 let c = self.curr.unwrap();\n                 match c {\n                     '\"' => {\n                         content_end_bpos = self.last_pos;\n-                        for _ in range(0, hash_count) {\n+                        for _ in 0..hash_count {\n                             self.bump();\n                             if !self.curr_is('#') {\n                                 continue 'outer;\n@@ -1402,7 +1402,7 @@ impl<'a> StringReader<'a> {\n                 },\n                 Some('\"') => {\n                     content_end_bpos = self.last_pos;\n-                    for _ in range(0, hash_count) {\n+                    for _ in 0..hash_count {\n                         self.bump();\n                         if !self.curr_is('#') {\n                             continue 'outer;"}, {"sha": "1c146968fd548fe8bd98ef5ac81c22ee6420b765", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -472,7 +472,7 @@ pub fn str_lit(lit: &str) -> String {\n                         } else {\n                             // otherwise, a normal escape\n                             let (c, n) = char_lit(&lit[i..]);\n-                            for _ in range(0, n - 1) { // we don't need to move past the first \\\n+                            for _ in 0..n - 1 { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n                             res.push(c);\n@@ -635,7 +635,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n                         // otherwise, a normal escape\n                         let (c, n) = byte_lit(&lit[i..]);\n                         // we don't need to move past the first \\\n-                        for _ in range(0, n - 1) {\n+                        for _ in 0..n - 1 {\n                             chars.next();\n                         }\n                         res.push(c);"}, {"sha": "1ef33a2401e1b0fe57856acae435a455706f1d95", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -29,7 +29,7 @@ use std::path::BytesContainer;\n use std::rc::Rc;\n \n #[allow(non_camel_case_types)]\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum BinOpToken {\n     Plus,\n     Minus,\n@@ -44,7 +44,7 @@ pub enum BinOpToken {\n }\n \n /// A delimiter token\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum DelimToken {\n     /// A round parenthesis: `(` or `)`\n     Paren,\n@@ -54,14 +54,14 @@ pub enum DelimToken {\n     Brace,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum IdentStyle {\n     /// `::` follows the identifier with no whitespace in-between.\n     ModName,\n     Plain,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum SpecialMacroVar {\n     /// `$crate` will be filled in with the name of the crate a macro was\n     /// imported from, if any.\n@@ -76,7 +76,7 @@ impl SpecialMacroVar {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n     Char(ast::Name),\n@@ -102,7 +102,7 @@ impl Lit {\n }\n \n #[allow(non_camel_case_types)]\n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n     Eq,"}, {"sha": "5367ccc1357c9ebc888e5ccc7198aa8019b670b6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -2457,7 +2457,7 @@ impl<'a> State<'a> {\n         try!(word(&mut self.s, \"<\"));\n \n         let mut ints = Vec::new();\n-        for i in range(0us, total) {\n+        for i in 0us..total {\n             ints.push(i);\n         }\n "}, {"sha": "d126717ce6817bce3520c57ed5b0847f78d890a0", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -24,7 +24,7 @@ use self::parm::{expand, Number, Variables};\n \n \n /// A parsed terminfo database entry.\n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct TermInfo {\n     /// Names for the terminal\n     pub names: Vec<String> ,"}, {"sha": "a5571076aabe2ee11424d9adec8930637297a183", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -226,7 +226,7 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n \n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n-        for i in range(0, bools_bytes) {\n+        for i in 0..bools_bytes {\n             let b = try!(file.read_byte());\n             if b == 1 {\n                 bools_map.insert(bnames[i as uint].to_string(), true);\n@@ -240,7 +240,7 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n \n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n-        for i in range(0, numbers_count) {\n+        for i in 0..numbers_count {\n             let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n                 numbers_map.insert(nnames[i as uint].to_string(), n);\n@@ -252,7 +252,7 @@ pub fn parse(file: &mut old_io::Reader, longnames: bool)\n \n     if string_offsets_count != 0 {\n         let mut string_offsets = Vec::with_capacity(10);\n-        for _ in range(0, string_offsets_count) {\n+        for _ in 0..string_offsets_count {\n             string_offsets.push(try!(file.read_le_u16()));\n         }\n "}, {"sha": "8fea6bb539f57331fb821b7bcc077b2fb1d281df", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -97,7 +97,7 @@ pub mod stats;\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n \n-#[derive(Clone, PartialEq, Eq, Hash, Show)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String)\n@@ -198,15 +198,15 @@ pub struct Bencher {\n     pub bytes: u64,\n }\n \n-#[derive(Copy, Clone, Show, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ShouldFail {\n     No,\n     Yes(Option<&'static str>)\n }\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-#[derive(Clone, Show, PartialEq, Eq, Hash)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct TestDesc {\n     pub name: TestName,\n     pub ignore: bool,\n@@ -215,13 +215,13 @@ pub struct TestDesc {\n \n unsafe impl Send for TestDesc {}\n \n-#[derive(Show)]\n+#[derive(Debug)]\n pub struct TestDescAndFn {\n     pub desc: TestDesc,\n     pub testfn: TestFn,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug, Copy)]\n pub struct Metric {\n     value: f64,\n     noise: f64\n@@ -1008,7 +1008,7 @@ impl Bencher {\n     pub fn iter<T, F>(&mut self, mut inner: F) where F: FnMut() -> T {\n         self.dur = Duration::span(|| {\n             let k = self.iterations;\n-            for _ in range(0u64, k) {\n+            for _ in 0u64..k {\n                 black_box(inner());\n             }\n         });"}, {"sha": "237acbd7b65b74fc89ab26175db27ede8b66fa1d", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -172,7 +172,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n             let mut j = 0;\n             // This inner loop applies `hi`/`lo` summation to each\n             // partial so that the list of partial sums remains exact.\n-            for i in range(0, partials.len()) {\n+            for i in 0..partials.len() {\n                 let mut y: T = partials[i];\n                 if x.abs() < y.abs() {\n                     mem::swap(&mut x, &mut y);\n@@ -939,7 +939,7 @@ mod bench {\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = range(0, 500).map(|i| nums[i%5]).collect::<Vec<_>>();\n+        let v = (0us..500).map(|i| nums[i%5]).collect::<Vec<_>>();\n \n         b.iter(|| {\n             v.sum();"}, {"sha": "370f59a5b2679300829e56b97f95f5e2efd72ead", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -410,7 +410,7 @@ pub struct Utf16Items<'a> {\n     iter: slice::Iter<'a, u16>\n }\n /// The possibilities for values decoded from a `u16` stream.\n-#[derive(Copy, PartialEq, Eq, Clone, Show)]\n+#[derive(Copy, PartialEq, Eq, Clone, Debug)]\n pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),"}, {"sha": "1c10a270acc6c9ff1d2e708967ca0a8e5ca4a4f4", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n //! Error handling utilities. WIP.\n \n use std::fmt;\n-use std::fmt::{Show, Formatter};\n+use std::fmt::{Debug, Formatter};\n \n use std::old_io::IoError;\n \n@@ -32,7 +32,7 @@ pub trait FromError<E> {\n     fn from_err(err: E) -> Self;\n }\n \n-impl Show for Box<Error + 'static> {\n+impl Debug for Box<Error + 'static> {\n     fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.description())\n     }"}, {"sha": "8d3ab53ef7feb7b88b48ebabe3539ced27ee49d0", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-27 7774359\n+  freebsd-x86_64 63623b632d4f9c33ad3b3cfaeebf8e2dd8395c96\n+  linux-i386 937b0b126aade54dc2c7198cad67f40d711b64ba\n+  linux-x86_64 3a0ed2a90e1e8b3ee7d81ac7d2feddda0b359c9c\n+  macos-i386 3dbed5c058661cab4ece146fb76acd35cc4d333b\n+  macos-x86_64 fc776bc6b9b60cbd25f07fad43e0f01c76663542\n+  winnt-i386 77ed0484b6ceb53e5ffa50028d986af8b09a0441\n+  winnt-x86_64 db1ee5b7939197958e59fe37ce7e123285be64fb\n+\n S 2015-01-20 9006c3c\n   freebsd-x86_64 240b30b33263d175e30f925ed1e1e1a4e553a513\n   linux-i386 544c2063b8d5035342c705b881b8868244c1e9a1"}, {"sha": "36442ed6c193114ae722f1eb05db77845f0029e8", "filename": "src/test/auxiliary/trait_inheritance_overloading_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftrait_inheritance_overloading_xc.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -14,7 +14,7 @@ use std::ops::{Add, Sub, Mul};\n pub trait MyNum : Add<Output=Self> + Sub<Output=Self> + Mul<Output=Self> + PartialEq + Clone {\n }\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n pub struct MyInt {\n     pub val: int\n }"}, {"sha": "8330c159769fd06dd5a2610ddebef910c46bdd55", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -40,19 +40,19 @@ fn ascending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Ascending integers:\");\n \n     timed(\"insert\", || {\n-        for i in range(0u, n_keys) {\n+        for i in 0u..n_keys {\n             map.insert(i, i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in range(0u, n_keys) {\n+        for i in 0u..n_keys {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     });\n \n     timed(\"remove\", || {\n-        for i in range(0, n_keys) {\n+        for i in 0..n_keys {\n             assert!(map.remove(&i));\n         }\n     });\n@@ -62,39 +62,39 @@ fn descending<M: MutableMap>(map: &mut M, n_keys: uint) {\n     println!(\" Descending integers:\");\n \n     timed(\"insert\", || {\n-        for i in range(0, n_keys).rev() {\n+        for i in (0..n_keys).rev() {\n             map.insert(i, i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in range(0, n_keys).rev() {\n+        for i in (0..n_keys).rev() {\n             assert_eq!(map.find(&i).unwrap(), &(i + 1));\n         }\n     });\n \n     timed(\"remove\", || {\n-        for i in range(0, n_keys) {\n+        for i in 0..n_keys {\n             assert!(map.remove(&i));\n         }\n     });\n }\n \n fn vector<M: MutableMap>(map: &mut M, n_keys: uint, dist: &[uint]) {\n     timed(\"insert\", || {\n-        for i in range(0u, n_keys) {\n+        for i in 0u..n_keys {\n             map.insert(dist[i], i + 1);\n         }\n     });\n \n     timed(\"search\", || {\n-        for i in range(0u, n_keys) {\n+        for i in 0u..n_keys {\n             assert_eq!(map.find(&dist[i]).unwrap(), &(i + 1));\n         }\n     });\n \n     timed(\"remove\", || {\n-        for i in range(0u, n_keys) {\n+        for i in 0u..n_keys {\n             assert!(map.remove(&dist[i]));\n         }\n     });"}, {"sha": "b78b147348a8cf0bfceb1d4b04da8e3bee63612b", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -71,11 +71,11 @@ impl Results {\n         {\n             let mut set = f();\n             timed(&mut self.sequential_ints, || {\n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     set.insert(i);\n                 }\n \n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     assert!(set.contains(&i));\n                 }\n             })\n@@ -84,20 +84,20 @@ impl Results {\n         {\n             let mut set = f();\n             timed(&mut self.random_ints, || {\n-                for _ in range(0, num_keys) {\n+                for _ in 0..num_keys {\n                     set.insert(rng.gen::<uint>() % rand_cap);\n                 }\n             })\n         }\n \n         {\n             let mut set = f();\n-            for i in range(0u, num_keys) {\n+            for i in 0u..num_keys {\n                 set.insert(i);\n             }\n \n             timed(&mut self.delete_ints, || {\n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     assert!(set.remove(&i));\n                 }\n             })\n@@ -114,11 +114,11 @@ impl Results {\n         {\n             let mut set = f();\n             timed(&mut self.sequential_strings, || {\n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     set.insert(i.to_string());\n                 }\n \n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     assert!(set.contains(&i.to_string()));\n                 }\n             })\n@@ -127,7 +127,7 @@ impl Results {\n         {\n             let mut set = f();\n             timed(&mut self.random_strings, || {\n-                for _ in range(0, num_keys) {\n+                for _ in 0..num_keys {\n                     let s = rng.gen::<uint>().to_string();\n                     set.insert(s);\n                 }\n@@ -136,11 +136,11 @@ impl Results {\n \n         {\n             let mut set = f();\n-            for i in range(0u, num_keys) {\n+            for i in 0u..num_keys {\n                 set.insert(i.to_string());\n             }\n             timed(&mut self.delete_strings, || {\n-                for i in range(0u, num_keys) {\n+                for i in 0u..num_keys {\n                     assert!(set.remove(&i.to_string()));\n                 }\n             })"}, {"sha": "6d12d84f652165f4ba73ef97f96269b2b69650a7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -76,7 +76,7 @@ fn read_line() {\n     let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");\n \n-    for _ in range(0u, 3) {\n+    for _ in 0u..3 {\n         let mut reader = BufferedReader::new(File::open(&path).unwrap());\n         for _line in reader.lines() {\n         }\n@@ -126,7 +126,7 @@ fn vec_push_all() {\n     let mut r = rand::thread_rng();\n \n     let mut v = Vec::new();\n-    for i in range(0u, 1500) {\n+    for i in 0u..1500 {\n         let mut rv = repeat(i).take(r.gen_range(0u, i + 1)).collect::<Vec<_>>();\n         if r.gen() {\n             v.push_all(rv.as_slice());\n@@ -140,7 +140,7 @@ fn vec_push_all() {\n \n fn is_utf8_ascii() {\n     let mut v : Vec<u8> = Vec::new();\n-    for _ in range(0u, 20000) {\n+    for _ in 0u..20000 {\n         v.push('b' as u8);\n         if str::from_utf8(v.as_slice()).is_err() {\n             panic!(\"from_utf8 panicked\");\n@@ -151,7 +151,7 @@ fn is_utf8_ascii() {\n fn is_utf8_multibyte() {\n     let s = \"b\u00a2\u20ac\ud852\udf62\";\n     let mut v : Vec<u8> = Vec::new();\n-    for _ in range(0u, 5000) {\n+    for _ in 0u..5000 {\n         v.push_all(s.as_bytes());\n         if str::from_utf8(v.as_slice()).is_err() {\n             panic!(\"from_utf8 panicked\");"}, {"sha": "99d83d761df66dd3ebac84aca8aec6e91036939f", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -22,7 +22,7 @@ fn main() {\n \n     let n = args[1].parse().unwrap();\n \n-    for i in range(0u, n) {\n+    for i in 0u..n {\n         let x = i.to_string();\n         println!(\"{}\", x);\n     }"}, {"sha": "6928397566dd0cee7cc619b1358d3972dc1cf870", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -61,10 +61,10 @@ fn run(args: &[String]) {\n     let dur = Duration::span(|| {\n         let (to_child, to_parent, from_parent) = p.take().unwrap();\n         let mut worker_results = Vec::new();\n-        for _ in range(0u, workers) {\n+        for _ in 0u..workers {\n             let to_child = to_child.clone();\n             worker_results.push(Thread::scoped(move|| {\n-                for _ in range(0u, size / workers) {\n+                for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes)).unwrap();\n                 }"}, {"sha": "9bf0ce1a59099a782f5b6addab025138dc8c4104", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -57,7 +57,7 @@ fn run(args: &[String]) {\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n             worker_results.push(Thread::scoped(move|| {\n-                for _ in range(0u, size / workers) {\n+                for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n                 }\n@@ -66,10 +66,10 @@ fn run(args: &[String]) {\n             from_parent\n         } else {\n             let (to_child, from_parent) = channel();\n-            for _ in range(0u, workers) {\n+            for _ in 0u..workers {\n                 let to_child = to_child.clone();\n                 worker_results.push(Thread::scoped(move|| {\n-                    for _ in range(0u, size / workers) {\n+                    for _ in 0u..size / workers {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n                     }"}, {"sha": "c344084a4c02bd9ab1cc4e0b4b2e970d36e267fc", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -50,7 +50,7 @@ fn thread_ring(i: uint, count: uint, num_chan: pipe, num_port: pipe) {\n     let mut num_chan = Some(num_chan);\n     let mut num_port = Some(num_port);\n     // Send/Receive lots of messages.\n-    for j in range(0u, count) {\n+    for j in 0u..count {\n         //println!(\"task %?, iter %?\", i, j);\n         let num_chan2 = num_chan.take().unwrap();\n         let num_port2 = num_port.take().unwrap();\n@@ -84,7 +84,7 @@ fn main() {\n         // create the ring\n         let mut futures = Vec::new();\n \n-        for i in range(1u, num_tasks) {\n+        for i in 1u..num_tasks {\n             //println!(\"spawning %?\", i);\n             let (new_chan, num_port) = init();\n             let num_chan_2 = num_chan.clone();"}, {"sha": "664491eed7d67028ad487f456818b1027be890f0", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -104,17 +104,17 @@ fn main() {\n     let mut pixels = [0f32; 256*256];\n     let n2d = Noise2DContext::new();\n \n-    for _ in range(0u, 100) {\n-        for y in range(0u, 256) {\n-            for x in range(0u, 256) {\n+    for _ in 0u..100 {\n+        for y in 0u..256 {\n+            for x in 0u..256 {\n                 let v = n2d.get(x as f32 * 0.1, y as f32 * 0.1);\n                 pixels[y*256+x] = v * 0.5 + 0.5;\n             }\n         }\n     }\n \n-    for y in range(0u, 256) {\n-        for x in range(0u, 256) {\n+    for y in 0u..256 {\n+        for x in 0u..256 {\n             let idx = (pixels[y*256+x] / 0.2) as uint;\n             print!(\"{}\", symbols[idx]);\n         }"}, {"sha": "a67deac67db6cf3c348944f1e739f223c45da828", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -37,15 +37,15 @@ fn ping_pong_bench(n: uint, m: uint) {\n \n         let guard_a = Thread::scoped(move|| {\n             let (tx, rx) = (atx, brx);\n-            for _ in range(0, n) {\n+            for _ in 0..n {\n                 tx.send(()).unwrap();\n                 rx.recv().unwrap();\n             }\n         });\n \n         let guard_b = Thread::scoped(move|| {\n             let (tx, rx) = (btx, arx);\n-            for _ in range(0, n) {\n+            for _ in 0..n {\n                 rx.recv().unwrap();\n                 tx.send(()).unwrap();\n             }\n@@ -55,7 +55,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n         guard_b.join().ok();\n     }\n \n-    for _ in range(0, m) {\n+    for _ in 0..m {\n         run_pair(n)\n     }\n }"}, {"sha": "7fad2c9b4be994231cd3eba77b94e6f21558fa61", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -61,7 +61,7 @@ enum Color {\n     Blue,\n }\n \n-impl fmt::Show for Color {\n+impl fmt::Debug for Color {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *self {\n             Red => \"red\",\n@@ -104,7 +104,7 @@ fn show_digit(nn: uint) -> &'static str {\n }\n \n struct Number(uint);\n-impl fmt::Show for Number {\n+impl fmt::Debug for Number {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut out = vec![];\n         let Number(mut num) = *self;\n@@ -200,7 +200,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n     let mut creatures_met = 0;\n \n     // set up meetings...\n-    for _ in range(0, nn) {\n+    for _ in 0..nn {\n         let fst_creature = from_creatures.recv().unwrap();\n         let snd_creature = from_creatures.recv().unwrap();\n "}, {"sha": "e12a9e7cb161bb99d59e968a85bd5cc2238d7276", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -49,7 +49,7 @@ fn rotate(x: &mut [i32]) {\n }\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n-    for i in range(1, perm.len()) {\n+    for i in 1..perm.len() {\n         rotate(&mut perm[..i + 1]);\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n@@ -78,7 +78,7 @@ struct Perm {\n impl Perm {\n     fn new(n: u32) -> Perm {\n         let mut fact = [1; 16];\n-        for i in range(1, n as uint + 1) {\n+        for i in 1..n as uint + 1 {\n             fact[i] = fact[i - 1] * i as u32;\n         }\n         Perm {\n@@ -97,7 +97,7 @@ impl Perm {\n             *place = i as i32 + 1;\n         }\n \n-        for i in range(1, self.n as uint).rev() {\n+        for i in (1..self.n as uint).rev() {\n             let d = idx / self.fact[i] as i32;\n             self.cnt[i] = d;\n             idx %= self.fact[i] as i32;\n@@ -106,7 +106,7 @@ impl Perm {\n             }\n \n             let d = d as uint;\n-            for j in range(0, i + 1) {\n+            for j in 0..i + 1 {\n                 self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n             }\n         }\n@@ -161,7 +161,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     let mut futures = vec![];\n     let k = perm.max() / N;\n \n-    for (_, j) in range(0, N).zip(iter::count(0, k)) {\n+    for (_, j) in (0..N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n         futures.push(Thread::scoped(move|| {"}, {"sha": "f32e98ef17d851e529948a274e7913de0d0c343a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -193,14 +193,14 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         let chars_left = n % LINE_LEN;\n         let mut buf = [0;LINE_LEN + 1];\n \n-        for _ in range(0, lines) {\n-            for i in range(0u, LINE_LEN) {\n+        for _ in 0..lines {\n+            for i in 0u..LINE_LEN {\n                 buf[i] = self.nextc();\n             }\n             buf[LINE_LEN] = '\\n' as u8;\n             try!(self.out.write(&buf));\n         }\n-        for i in range(0u, chars_left) {\n+        for i in 0u..chars_left {\n             buf[i] = self.nextc();\n         }\n         self.out.write(&buf[..chars_left])"}, {"sha": "8a2a8453a9ef533c8a81fb6d38c88ed30b18e1b1", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -92,7 +92,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n     let mut line = [0u8; LINE_LENGTH + 1];\n     while n > 0 {\n         let nb = min(LINE_LENGTH, n);\n-        for i in range(0, nb) {\n+        for i in 0..nb {\n             line[i] = it.next().unwrap();\n         }\n         n -= nb;"}, {"sha": "2da276b722e870811c99fde7183d234ac5c3ec5b", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -158,7 +158,7 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = vec!(1u,2,3,4,6,12,18);\n-    let mut streams = range(0, sizes.len()).map(|_| {\n+    let mut streams = (0..sizes.len()).map(|_| {\n         Some(channel::<String>())\n     }).collect::<Vec<_>>();\n     let mut from_child = Vec::new();"}, {"sha": "2c3ade63f06d3ad1345540cb2b46264657efca3d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -84,7 +84,7 @@ impl Code {\n     fn unpack(&self, frame: uint) -> String {\n         let mut key = self.hash();\n         let mut result = Vec::new();\n-        for _ in range(0, frame) {\n+        for _ in 0..frame {\n             result.push(unpack_symbol((key as u8) & 3));\n             key >>= 2;\n         }\n@@ -135,7 +135,7 @@ struct Items<'a> {\n impl Table {\n     fn new() -> Table {\n         Table {\n-            items: range(0, TABLE_SIZE).map(|_| None).collect()\n+            items: (0..TABLE_SIZE).map(|_| None).collect()\n         }\n     }\n \n@@ -242,7 +242,7 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     let mut code = Code(0);\n \n     // Pull first frame.\n-    for _ in range(0, frame) {\n+    for _ in 0..frame {\n         code = code.push_char(input[0]);\n         input = &input[1..];\n     }\n@@ -299,7 +299,7 @@ fn main() {\n     };\n     let input = Arc::new(input);\n \n-    let nb_freqs: Vec<_> = range(1u, 3).map(|i| {\n+    let nb_freqs: Vec<_> = (1u..3).map(|i| {\n         let input = input.clone();\n         (i, Thread::scoped(move|| generate_frequencies(input.as_slice(), i)))\n     }).collect();"}, {"sha": "4a9c5a91dcf0bb5cbe976946e7782e8f9225c627", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -80,7 +80,7 @@ fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n     let mut precalc_r = Vec::with_capacity(w);\n     let mut precalc_i = Vec::with_capacity(h);\n \n-    let precalc_futures = range(0, WORKERS).map(|i| {\n+    let precalc_futures = (0..WORKERS).map(|i| {\n         Thread::scoped(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n@@ -93,7 +93,7 @@ fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n             };\n \n             // This assumes w == h\n-            for x in range(start, end) {\n+            for x in start..end {\n                 let xf = x as f64;\n                 let xy = f64x2(xf, xf);\n \n@@ -118,7 +118,7 @@ fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n     let arc_init_r = Arc::new(precalc_r);\n     let arc_init_i = Arc::new(precalc_i);\n \n-    let data = range(0, WORKERS).map(|i| {\n+    let data = (0..WORKERS).map(|i| {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n@@ -165,7 +165,7 @@ fn write_line(init_i: f64, vec_init_r: &[f64], res: &mut Vec<u8>) {\n             let mut i_sq = v_init_i * v_init_i;\n \n             let mut b = 0;\n-            for _ in range(0, ITER) {\n+            for _ in 0..ITER {\n                 let r = cur_r;\n                 let i = cur_i;\n "}, {"sha": "e6ef58cba35f83b07f16e5bbaa02e78018a9fd8b", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -169,7 +169,7 @@ fn make_masks() -> Vec<Vec<Vec<u64> > > {\n         .map(|(id, p)| transform(p, id != 3))\n         .collect();\n \n-    range(0i, 50).map(|yx| {\n+    (0i..50).map(|yx| {\n         transforms.iter().enumerate().map(|(id, t)| {\n             t.iter().filter_map(|p| mask(yx / 5, yx % 5, id, p)).collect()\n         }).collect()\n@@ -199,8 +199,8 @@ fn is_board_unfeasible(board: u64, masks: &Vec<Vec<Vec<u64>>>) -> bool {\n \n // Filter the masks that we can prove to result to unfeasible board.\n fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n-    for i in range(0, masks.len()) {\n-        for j in range(0, (*masks)[i].len()) {\n+    for i in 0..masks.len() {\n+        for j in 0..(*masks)[i].len() {\n             masks[i][j] =\n                 (*masks)[i][j].iter().map(|&m| m)\n                 .filter(|&m| !is_board_unfeasible(m, masks))\n@@ -211,7 +211,7 @@ fn filter_masks(masks: &mut Vec<Vec<Vec<u64>>>) {\n \n // Gets the identifier of a mask.\n fn get_id(m: u64) -> u8 {\n-    for id in range(0u8, 10) {\n+    for id in 0u8..10 {\n         if m & (1 << (id + 50) as uint) != 0 {return id;}\n     }\n     panic!(\"{:016x} does not have a valid identifier\", m);\n@@ -222,7 +222,7 @@ fn to_vec(raw_sol: &List<u64>) -> Vec<u8> {\n     let mut sol = repeat('.' as u8).take(50).collect::<Vec<_>>();\n     for &m in raw_sol.iter() {\n         let id = '0' as u8 + get_id(m);\n-        for i in range(0u, 50) {\n+        for i in 0u..50 {\n             if m & 1 << i != 0 {\n                 sol[i] = id;\n             }\n@@ -297,7 +297,7 @@ fn search(\n     let masks_at = &masks[i];\n \n     // for every unused piece\n-    for id in range(0u, 10).filter(|&id| board & (1 << (id + 50)) == 0) {\n+    for id in (0u..10).filter(|&id| board & (1 << (id + 50)) == 0) {\n         // for each mask that fits on the board\n         for m in masks_at[id].iter().filter(|&m| board & *m == 0) {\n             // This check is too costly."}, {"sha": "7325b8a4738f2460c723e66d1336e26d5c1ca3ca", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -102,7 +102,7 @@ struct Planet {\n }\n \n fn advance(bodies: &mut [Planet;N_BODIES], dt: f64, steps: int) {\n-    for _ in range(0, steps) {\n+    for _ in 0..steps {\n         let mut b_slice = bodies.as_mut_slice();\n         loop {\n             let bi = match shift_mut_ref(&mut b_slice) {"}, {"sha": "2f68262b608c677abf7b500875885181e1df64fb", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -77,7 +77,7 @@ fn stress_task(id: int) {\n \n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n-    for i in range(0, num_tasks) {\n+    for i in 0..num_tasks {\n         results.push(Thread::scoped(move|| {\n             stress_task(i);\n         }));\n@@ -106,8 +106,8 @@ fn main() {\n \n         let num_trials = 10;\n \n-        for n in range(1, max + 1) {\n-            for _ in range(0u, num_trials) {\n+        for n in 1..max + 1 {\n+            for _ in 0u..num_trials {\n                 let mut fibn = None;\n                 let dur = Duration::span(|| fibn = Some(fib(n)));\n                 let fibn = fibn.unwrap();"}, {"sha": "ec85ba18f900a1fd136f0e169162a212846b8685", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -68,7 +68,7 @@ fn spectralnorm(n: uint) -> f64 {\n     let mut u = repeat(1.0).take(n).collect::<Vec<_>>();\n     let mut v = u.clone();\n     let mut tmp = v.clone();\n-    for _ in range(0u, 10) {\n+    for _ in 0u..10 {\n         mult_AtAv(u.as_slice(), v.as_mut_slice(), tmp.as_mut_slice());\n         mult_AtAv(v.as_slice(), u.as_mut_slice(), tmp.as_mut_slice());\n     }"}, {"sha": "562b82a92a31c9dd029e48e515480ad0c0c405cf", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,13 +15,13 @@ use std::os;\n use std::time::Duration;\n \n fn append_sequential(min: uint, max: uint, map: &mut VecMap<uint>) {\n-    for i in range(min, max) {\n+    for i in min..max {\n         map.insert(i, i + 22u);\n     }\n }\n \n fn check_sequential(min: uint, max: uint, map: &VecMap<uint>) {\n-    for i in range(min, max) {\n+    for i in min..max {\n         assert_eq!(map[i], i + 22u);\n     }\n }\n@@ -41,7 +41,7 @@ fn main() {\n     let mut checkf = Duration::seconds(0);\n     let mut appendf = Duration::seconds(0);\n \n-    for _ in range(0u, rep) {\n+    for _ in 0u..rep {\n         let mut map = VecMap::new();\n         let d1 = Duration::span(|| append_sequential(0u, max, &mut map));\n         let d2 = Duration::span(|| check_sequential(0u, max, &map));"}, {"sha": "75126973cd9f4b579bcd2700e6e4efddfa4ae163", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -49,8 +49,8 @@ impl Sudoku {\n     }\n \n     pub fn from_vec(vec: &[[u8;9];9]) -> Sudoku {\n-        let g = range(0, 9u).map(|i| {\n-            range(0, 9u).map(|j| { vec[i][j] }).collect()\n+        let g = (0..9u).map(|i| {\n+            (0..9u).map(|j| { vec[i][j] }).collect()\n         }).collect();\n         return Sudoku::new(g)\n     }\n@@ -81,9 +81,9 @@ impl Sudoku {\n     }\n \n     pub fn write(&self, writer: &mut old_io::Writer) {\n-        for row in range(0u8, 9u8) {\n+        for row in 0u8..9u8 {\n             write!(writer, \"{}\", self.grid[row as uint][0]);\n-            for col in range(1u8, 9u8) {\n+            for col in 1u8..9u8 {\n                 write!(writer, \" {}\", self.grid[row as uint][col as uint]);\n             }\n             write!(writer, \"\\n\");\n@@ -93,8 +93,8 @@ impl Sudoku {\n     // solve sudoku grid\n     pub fn solve(&mut self) {\n         let mut work: Vec<(u8, u8)> = Vec::new(); /* queue of uncolored fields */\n-        for row in range(0u8, 9u8) {\n-            for col in range(0u8, 9u8) {\n+        for row in 0u8..9u8 {\n+            for col in 0u8..9u8 {\n                 let color = self.grid[row as uint][col as uint];\n                 if color == 0u8 {\n                     work.push((row, col));\n@@ -139,7 +139,7 @@ impl Sudoku {\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(&mut self, avail: &mut Colors, row: u8, col: u8) {\n-        for idx in range(0u8, 9u8) {\n+        for idx in 0u8..9u8 {\n             /* check same column fields */\n             avail.remove(self.grid[idx as uint][col as uint]);\n             /* check same row fields */\n@@ -149,8 +149,8 @@ impl Sudoku {\n         // check same block fields\n         let row0 = (row / 3u8) * 3u8;\n         let col0 = (col / 3u8) * 3u8;\n-        for alt_row in range(row0, row0 + 3u8) {\n-            for alt_col in range(col0, col0 + 3u8) {\n+        for alt_row in row0..row0 + 3u8 {\n+            for alt_col in col0..col0 + 3u8 {\n                 avail.remove(self.grid[alt_row as uint][alt_col as uint]);\n             }\n         }"}, {"sha": "216745ca1105838b60bc41531dbff5687e713df0", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -30,7 +30,7 @@ fn main() {\n }\n \n fn run(repeat: int, depth: int) {\n-    for _ in range(0, repeat) {\n+    for _ in 0..repeat {\n         let dur = Duration::span(|| {\n             let _ = Thread::scoped(move|| {\n                 recurse_or_panic(depth, None)"}, {"sha": "e34756229bdfab9e31361ccc87e603ca4402edc1", "filename": "src/test/compile-fail/attr-before-eof.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fattr-before-eof.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fattr-before-eof.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-eof.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)] //~ERROR expected item after attributes\n+#[derive(Debug)] //~ERROR expected item after attributes"}, {"sha": "545c766308545aad252ebe754ecc6a8f15cf06aa", "filename": "src/test/compile-fail/borrowck-lend-flow-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-lend-flow-loop.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -41,7 +41,7 @@ fn block_overarching_alias_mut() {\n \n     let mut v = box 3;\n     let mut x = &mut v;\n-    for _ in range(0is, 3) {\n+    for _ in 0is..3 {\n         borrow(&*v); //~ ERROR cannot borrow\n     }\n     *x = box 5;"}, {"sha": "4e7d81a1cb0cc5f4f526149f8813c1bad72e2bb3", "filename": "src/test/compile-fail/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-out-of-vec-tail.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,7 +10,7 @@\n \n // Test that we do not permit moves from &[] matched by a vec pattern.\n \n-#[derive(Clone, Show)]\n+#[derive(Clone, Debug)]\n struct Foo {\n     string: String\n }"}, {"sha": "98402591e728aedf83ec8e26955d63dfc81e4012", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct foo {\n   i: isize,\n }"}, {"sha": "1d9099e8ed69bce92240590299eae92274cd6de4", "filename": "src/test/compile-fail/deriving-span-Show-enum-struct-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum-struct-variant.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,7 +15,7 @@ extern crate rand;\n \n struct Error;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n enum Enum {\n    A {\n      x: Error //~ ERROR"}, {"sha": "ab31ca95bdb38c98ba3c4e8efd220136d61206cc", "filename": "src/test/compile-fail/deriving-span-Show-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-enum.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,7 +15,7 @@ extern crate rand;\n \n struct Error;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n enum Enum {\n    A(\n      Error //~ ERROR"}, {"sha": "eb8ac4649f29af8e496280493566ee0158f8e785", "filename": "src/test/compile-fail/deriving-span-Show-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,7 +15,7 @@ extern crate rand;\n \n struct Error;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Struct {\n     x: Error //~ ERROR\n }"}, {"sha": "b93db4ab535060990917a4cefe7152480358dbd3", "filename": "src/test/compile-fail/deriving-span-Show-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-span-Show-tuple-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -15,7 +15,7 @@ extern crate rand;\n \n struct Error;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Struct(\n     Error //~ ERROR\n );"}, {"sha": "bb44a6a8abb32de93f73fb0ab4671450ae015885", "filename": "src/test/compile-fail/doc-before-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fdoc-before-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fdoc-before-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoc-before-attr.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n /// hi\n-#[derive(Show)] //~ERROR expected item after attributes\n+#[derive(Debug)] //~ERROR expected item after attributes"}, {"sha": "e58cd09a84c0d8e61eb8482f46cf45b056b766bd", "filename": "src/test/compile-fail/hygienic-label-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -13,7 +13,7 @@ macro_rules! foo {\n }\n \n pub fn main() {\n-    'x: for _ in range(0,1) {\n+    'x: for _ in 0..1 {\n         foo!() //~ ERROR use of undeclared label `'x`\n     };\n }"}, {"sha": "5bfcb6360e4528b81a354252c792d8e3d06c318f", "filename": "src/test/compile-fail/hygienic-label-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n macro_rules! foo {\n-    ($e: expr) => { 'x: for _ in range(0,1) { $e } }\n+    ($e: expr) => { 'x: for _ in 0..1 { $e } }\n }\n \n pub fn main() {"}, {"sha": "a7adaacc0a5bfc41c6206d8301f591a5d6a9c023", "filename": "src/test/compile-fail/issue-14303-fncall.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-14303-fncall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-14303-fncall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14303-fncall.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    range(0, 4)\n+    (0..4)\n     .map(|x| x * 2)\n     .collect::<Vec<'a, usize, 'b>>()\n     //~^ ERROR lifetime parameters must be declared prior to type parameters"}, {"sha": "c98c543462e974e34d468c7bc2d0f55b0931a731", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -18,7 +18,7 @@\n macro_rules! f { () => (n) }\n \n fn main() -> (){\n-    for n in range(0is, 1) {\n+    for n in 0is..1 {\n         println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n     }\n }"}, {"sha": "9c708bdeaa8093fe68ac0c30ef32f5c7616e6ea7", "filename": "src/test/compile-fail/issue-17728.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17728.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt::{Show, Formatter, Error};\n+use std::fmt::{Debug, Formatter, Error};\n use std::collections::HashMap;\n \n trait HasInventory {\n@@ -30,7 +30,7 @@ trait TraversesWorld {\n }\n \n \n-#[derive(Show, Eq, PartialEq, Hash)]\n+#[derive(Debug, Eq, PartialEq, Hash)]\n enum RoomDirection {\n     West,\n     East,\n@@ -97,7 +97,7 @@ impl Player {\n impl TraversesWorld for Player {\n }\n \n-impl Show for Player {\n+impl Debug for Player {\n     fn fmt(&self, formatter: &mut Formatter) -> Result<(), Error> {\n         formatter.write_str(\"Player{ name:\");\n         formatter.write_str(self.name.as_slice());"}, {"sha": "d5973abc462ed71cc65a254c97a374559dc39523", "filename": "src/test/compile-fail/issue-17905.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17905.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Pair<T, V> (T, V);\n \n impl Pair<"}, {"sha": "99cb2ec2c02e35954098b6564d673497e04f1896", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n #![deny(unused_variables)]\n-#![feature(core)]\n \n fn main() {\n-    for _ in range(1is, 101) {\n+    for _ in 1is..101 {\n         let x = (); //~ ERROR: unused variable: `x`\n         match () {\n             a => {} //~ ERROR: unused variable: `a`"}, {"sha": "c49959c16a62180c7c1b7276173585687d22c694", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     let foo = 100;\n \n-    #[derive(Show)]\n+    #[derive(Debug)]\n     enum Stuff {\n         Bar = foo //~ ERROR attempt to use a non-constant value in a constant\n     }"}, {"sha": "6262783dd380ed4ccb8534ac291bca91fa0c628a", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,6 @@\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n-#![feature(core)]\n #![feature(os)]\n \n fn f1(x: isize) {\n@@ -85,7 +84,7 @@ fn f4b() -> isize {\n }\n \n fn f5a() {\n-    for x in range(1is, 10) { }\n+    for x in 1is..10 { }\n     //~^ ERROR unused variable: `x`\n }\n "}, {"sha": "ae2847aab0963fe0dc652f98f438d7913a480b4f", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -13,11 +13,11 @@\n use std::thread::Thread;\n use std::rc::Rc;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Port<T>(Rc<T>);\n \n fn main() {\n-    #[derive(Show)]\n+    #[derive(Debug)]\n     struct foo {\n       _x: Port<()>,\n     }"}, {"sha": "df135c3a8e309cc9acd1f6f07d15376517613c66", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n // Test that a class with a non-copyable field can't be\n // copied\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct bar {\n   x: isize,\n }\n@@ -26,7 +26,7 @@ fn bar(x:isize) -> bar {\n     }\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct foo {\n   i: isize,\n   j: bar,"}, {"sha": "d6f274da967d11e4d227794bb7fb3929123e6bfe", "filename": "src/test/compile-fail/nonscalar-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonscalar-cast.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,7 +10,7 @@\n \n // error-pattern:non-scalar cast\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct foo {\n     x: isize\n }"}, {"sha": "1b164709ac73c4f7303144ae7c239840a06d62d1", "filename": "src/test/compile-fail/packed-struct-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-transmute.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -23,7 +23,7 @@ struct Foo {\n     baz: usize\n }\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Oof {\n     rab: u8,\n     zab: usize"}, {"sha": "88535ee04fb5b847fd23c21f4433d4d0331cdcf7", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct r {\n   b: bool,\n }"}, {"sha": "b9ddc3f4de98be154db9582d114361c5bd0f85c9", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -14,7 +14,7 @@\n \n use std::cell::Cell;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct r<'a> {\n   i: &'a Cell<isize>,\n }"}, {"sha": "cf64486c9c7bf4fa8ef06cc2cc92dd04d8cccdbd", "filename": "src/test/compile-fail/vec-res-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-res-add.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct r {\n   i:isize\n }"}, {"sha": "38f8f859d39760d444a33320bcce7fb3e82f7d5e", "filename": "src/test/debuginfo/destructured-for-loop-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdestructured-for-loop-variable.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -202,7 +202,7 @@ fn main() {\n         zzz(); // #break\n     }\n \n-    for i in range(1234, 1235i) {\n+    for i in 1234..1235i {\n         zzz(); // #break\n     }\n "}, {"sha": "107c5cb9782252cfd687f7c3bb9a424cc4a4839d", "filename": "src/test/debuginfo/lexical-scope-in-parameterless-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-parameterless-closure.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -19,6 +19,6 @@\n // Nothing to do here really, just make sure it compiles. See issue #8513.\n fn main() {\n     let _ = |&:|();\n-    let _ = range(1u,3).map(|_| 5i);\n+    let _ = (1u..3).map(|_| 5i);\n }\n "}, {"sha": "e1aec83714d031c00584b2d0a1afbc85c61a1840", "filename": "src/test/debuginfo/limited-debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flimited-debuginfo.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -49,7 +49,7 @@ fn some_function(a: int, b: int) {\n     let some_variable = Struct { a: 11, b: 22 };\n     let some_other_variable = 23i;\n \n-    for x in range(0, 1) {\n+    for x in 0..1 {\n         zzz(); // #break\n     }\n }"}, {"sha": "70f8b1ccd96715b37a1afde8566cdfb64b10700b", "filename": "src/test/debuginfo/unreachable-locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -62,7 +62,7 @@ fn after_break() {\n }\n \n fn after_continue() {\n-    for _ in range(0, 10i32) {\n+    for _ in 0..10i32 {\n         break;\n         let x = \"0\";\n         let (ref y,z) = (1i32, 2u32);"}, {"sha": "f45c36023d218201dae23fe8640afeaa7967bad4", "filename": "src/test/run-fail/extern-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-fail%2Fextern-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-fail%2Fextern-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-panic.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -41,7 +41,7 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    for _ in range(0, 10u) {\n+    for _ in 0..10u {\n         task::spawn(move|| {\n             let result = count(5u);\n             println!(\"result = %?\", result);"}, {"sha": "6cad55e6358203b0aae4ddade9650d0f3b387f32", "filename": "src/test/run-fail/for-each-loop-panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-fail%2Ffor-each-loop-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-fail%2Ffor-each-loop-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffor-each-loop-panic.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,4 +10,4 @@\n \n // error-pattern:moop\n \n-fn main() { for _ in range(0u, 10u) { panic!(\"moop\"); } }\n+fn main() { for _ in 0u..10u { panic!(\"moop\"); } }"}, {"sha": "838ef338846a8dbb05ddf90cb1cf1bb43df039e7", "filename": "src/test/run-make/extern-fn-with-packed-struct/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-with-packed-struct%2Ftest.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #[repr(packed)]\n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n struct Foo {\n     a: i8,\n     b: i16,"}, {"sha": "f9ffdffb4647ae98daace7106d7d5800d4633b73", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -43,11 +43,11 @@ fn main() {\n             .write_str(\"mod unicode_input_multiple_files_chars;\");\n     }\n \n-    for _ in range(0u, 100) {\n+    for _ in 0u..100 {\n         {\n             let randoms = tmpdir.join(\"unicode_input_multiple_files_chars.rs\");\n             let mut w = File::create(&randoms).unwrap();\n-            for _ in range(0u, 30) {\n+            for _ in 0u..30 {\n                 let _ = w.write_char(random_char());\n             }\n         }"}, {"sha": "01e2c1f29730beab99535782beb7167401c4a394", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -38,14 +38,14 @@ fn main() {\n     let tmpdir = Path::new(args[2].as_slice());\n     let main_file = tmpdir.join(\"span_main.rs\");\n \n-    for _ in range(0u, 100) {\n+    for _ in 0u..100 {\n         let n = thread_rng().gen_range(3u, 20);\n \n         {\n             let _ = write!(&mut File::create(&main_file).unwrap(),\n                            \"#![feature(non_ascii_idents)] fn main() {{ {} }}\",\n                            // random string of length n\n-                           range(0, n).map(|_| random_char()).collect::<String>());\n+                           (0..n).map(|_| random_char()).collect::<String>());\n         }\n \n         // rustc is passed to us with --out-dir and -L etc., so we"}, {"sha": "a9e93aa8df5cfe2f3f6133295867a6a95a2d335f", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -17,11 +17,11 @@\n extern crate macro_crate_test;\n \n #[into_foo]\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone, Debug)]\n fn foo() -> AFakeTypeThatHadBetterGoAway {}\n \n #[into_multi_foo]\n-#[derive(PartialEq, Clone, Show)]\n+#[derive(PartialEq, Clone, Debug)]\n fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n \n trait Qux {"}, {"sha": "8771ed7a7424416fe8ef6d736bea83cc1660a51d", "filename": "src/test/run-pass/assert-eq-macro-success.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassert-eq-macro-success.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct Point { x : int }\n \n pub fn main() {"}, {"sha": "0e2f6ef056e6e5950c27d547c7029f681d973bf7", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Pair<T, U> { a: T, b: U }\n struct Triple { x: int, y: int, z: int }\n "}, {"sha": "af1cc3b1f4dd24845628ace506b7563478b0a965", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -77,7 +77,7 @@ fn runtest(me: &str) {\n     assert!(!out.status.success());\n     let s = str::from_utf8(out.error.as_slice()).unwrap();\n     let mut i = 0;\n-    for _ in range(0i, 2) {\n+    for _ in 0i..2 {\n         i += s[i + 10..].find_str(\"stack backtrace\").unwrap() + 10;\n     }\n     assert!(s[i + 10..].find_str(\"stack backtrace\").is_none(),"}, {"sha": "30f10d23563b06c9caeea0c92294c2969c6f365c", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -59,7 +59,7 @@ fn test_ptr() {\n     }\n }\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct p {\n   x: int,\n   y: int,"}, {"sha": "167d0ace159a9751766d62380e79acc8f6ee40e9", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -22,5 +22,5 @@ fn bitv_test() {\n }\n \n pub fn main() {\n-    for _ in range(0i, 10000) { bitv_test(); }\n+    for _ in 0i..10000 { bitv_test(); }\n }"}, {"sha": "747aca5332465cfabbdb33630e88d0fcdcc8137b", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -13,7 +13,7 @@\n \n use std::mem::swap;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Ints {sum: Box<int>, values: Vec<int> }\n \n fn add_int(x: &mut Ints, v: int) {\n@@ -26,7 +26,7 @@ fn add_int(x: &mut Ints, v: int) {\n \n fn iter_ints<F>(x: &Ints, mut f: F) -> bool where F: FnMut(&int) -> bool {\n     let l = x.values.len();\n-    range(0u, l).all(|i| f(&x.values[i]))\n+    (0u..l).all(|i| f(&x.values[i]))\n }\n \n pub fn main() {"}, {"sha": "8aca51cab546e9143e62366a7ea42c45c1687d63", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -88,7 +88,7 @@ fn cat(in_x: uint, in_y: int, in_name: String) -> cat {\n \n \n fn annoy_neighbors(critter: &mut noisy) {\n-    for _i in range(0u, 10) { critter.speak(); }\n+    for _i in 0u..10 { critter.speak(); }\n }\n \n pub fn main() {"}, {"sha": "83e7df1c711c6ca22a1e7e147266b2dd771001a2", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n \n use std::cmp;\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n impl cmp::PartialEq for cat_type {\n@@ -103,11 +103,11 @@ impl<T> cat<T> {\n \n pub fn main() {\n     let mut nyan: cat<String> = cat::new(0, 2, \"nyan\".to_string());\n-    for _ in range(1u, 5) { nyan.speak(); }\n+    for _ in 1u..5 { nyan.speak(); }\n     assert!(*nyan.find(&1).unwrap() == \"nyan\".to_string());\n     assert_eq!(nyan.find(&10), None);\n     let mut spotty: cat<cat_type> = cat::new(2, 57, cat_type::tuxedo);\n-    for _ in range(0u, 6) { spotty.speak(); }\n+    for _ in 0u..6 { spotty.speak(); }\n     assert_eq!(spotty.len(), 8);\n     assert!((spotty.contains_key(&2)));\n     assert_eq!(spotty.get(&3), &cat_type::tuxedo);"}, {"sha": "b2804a417891c9a683fb49fb27e32ca70ac6739f", "filename": "src/test/run-pass/class-implement-trait-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-trait-cross-crate.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -60,6 +60,6 @@ pub fn main() {\n   let mut nyan = cat(0u, 2, \"nyan\".to_string());\n   nyan.eat();\n   assert!((!nyan.eat()));\n-  for _ in range(1u, 10u) { nyan.speak(); };\n+  for _ in 1u..10u { nyan.speak(); };\n   assert!((nyan.eat()));\n }"}, {"sha": "172df8c2afd2856f4e2cfeb3ee6a2d6d1df524fd", "filename": "src/test/run-pass/class-implement-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-traits.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -65,7 +65,7 @@ pub fn main() {\n     let mut nyan = cat(0u, 2, \"nyan\".to_string());\n     nyan.eat();\n     assert!((!nyan.eat()));\n-    for _ in range(1u, 10u) {\n+    for _ in 1u..10u {\n         make_speak(nyan.clone());\n     }\n }"}, {"sha": "abf6968662cc2b466ae7d2e275d414743de24039", "filename": "src/test/run-pass/classes-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-cross-crate.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -16,6 +16,6 @@ pub fn main() {\n     let mut nyan = cat(0u, 2, \"nyan\".to_string());\n     nyan.eat();\n     assert!((!nyan.eat()));\n-    for _ in range(1u, 10u) { nyan.speak(); };\n+    for _ in 1u..10u { nyan.speak(); };\n     assert!((nyan.eat()));\n }"}, {"sha": "413e59633cd5603d5387d9e5cf139609306863fc", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -52,6 +52,6 @@ pub fn main() {\n   let mut nyan = cat(0u, 2, \"nyan\".to_string());\n   nyan.eat();\n   assert!((!nyan.eat()));\n-  for _ in range(1u, 10u) { nyan.speak(); };\n+  for _ in 1u..10u { nyan.speak(); };\n   assert!((nyan.eat()));\n }"}, {"sha": "27c514160c069be271285c34875094ef5e751617", "filename": "src/test/run-pass/const-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fconst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp;\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct foo { a: int, b: int, c: int }\n \n impl cmp::PartialEq for foo {"}, {"sha": "8c93f1ec78dc1f0849834b265db35c362dd6aedc", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -71,7 +71,7 @@ pub fn main() {\n     roundtrip::<C>();\n     roundtrip::<D>();\n \n-    for _ in range(0, 20) {\n+    for _ in 0..20 {\n         roundtrip::<E>();\n         roundtrip::<F>();\n         roundtrip::<G<int>>();"}, {"sha": "6777cbdab960486a3b1e306301e5f7f7408597e6", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -20,21 +20,21 @@ mod submod {\n     #[derive(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n-               Show, Rand,\n+               Debug, Rand,\n                Encodable, Decodable)]\n     enum A { A1(uint), A2(int) }\n \n     #[derive(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n-               Show, Rand,\n+               Debug, Rand,\n                Encodable, Decodable)]\n     struct B { x: uint, y: int }\n \n     #[derive(PartialEq, PartialOrd, Eq, Ord,\n                Hash,\n                Clone,\n-               Show, Rand,\n+               Debug, Rand,\n                Encodable, Decodable)]\n     struct C(uint, int);\n "}, {"sha": "bf2c2b01e6a51a0512e0cc084841eb17fd89e516", "filename": "src/test/run-pass/deriving-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-fn.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    #[derive(Show)]\n+    #[derive(Debug)]\n     struct Foo {\n         foo: int,\n     }"}, {"sha": "eb3cb30594ea808880b998a5c1513c054f038cb8", "filename": "src/test/run-pass/deriving-primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-primitive.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n use std::num::FromPrimitive;\n use std::int;\n \n-#[derive(PartialEq, FromPrimitive, Show)]\n+#[derive(PartialEq, FromPrimitive, Debug)]\n enum A {\n     Foo = int::MAX,\n     Bar = 1,"}, {"sha": "36b6b3cbeea8352a678942222d0cf95546ff6ac8", "filename": "src/test/run-pass/deriving-rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -31,7 +31,7 @@ enum D {\n \n pub fn main() {\n     // check there's no segfaults\n-    for _ in range(0i, 20) {\n+    for _ in 0i..20 {\n         rand::random::<A>();\n         rand::random::<B>();\n         rand::random::<C>();"}, {"sha": "92ffd82d90288275294d10a0dd795b68c727def4", "filename": "src/test/run-pass/deriving-via-extension-c-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-c-enum.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum Foo {\n     Bar,\n     Baz,"}, {"sha": "9761a87d4aa992ab51a901cb2ccc9fe37612e5c7", "filename": "src/test/run-pass/deriving-via-extension-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-enum.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum Foo {\n     Bar(int, int),\n     Baz(f64, f64)"}, {"sha": "9c929940eba28d420a423b4553d80c476c423a79", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct Foo;\n \n pub fn main() {"}, {"sha": "ed92a3baab9aa6986846122c837b23f4bb8a6672", "filename": "src/test/run-pass/deriving-via-extension-struct-like-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-like-enum-variant.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum S {\n     X { x: int, y: int },\n     Y"}, {"sha": "9319a4f752dc62fa188850e469301d96537292c8", "filename": "src/test/run-pass/deriving-via-extension-struct-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-tuple.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct Foo(int, int, String);\n \n pub fn main() {"}, {"sha": "e32e080cacb0a99f9ed12aaf765dda4e41b09254", "filename": "src/test/run-pass/deriving-via-extension-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct Foo {\n     x: int,\n     y: int,"}, {"sha": "890b4e69783098ca6aa7da903a3a74cbc0c3ca6a", "filename": "src/test/run-pass/deriving-via-extension-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-type-params.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(PartialEq, Hash, Show)]\n+#[derive(PartialEq, Hash, Debug)]\n struct Foo<T> {\n     x: int,\n     y: T,"}, {"sha": "2474bb8a4f36c12ab0321ab8763164b6afe58168", "filename": "src/test/run-pass/drop-trait-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-trait-enum.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -14,7 +14,7 @@\n use std::thread::Thread;\n use std::sync::mpsc::{channel, Sender};\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n enum Message {\n     Dropped,\n     DestructorRan"}, {"sha": "6557594594565f33639b764f41644346338e8a69", "filename": "src/test/run-pass/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-tag.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum chan { chan_t, }\n \n impl PartialEq for chan {"}, {"sha": "0242e53aa8c4ff761ec5d0cb0b8a23ad0bcc4f94", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -12,7 +12,7 @@ macro_rules! check {\n     ($m:ident, $t:ty, $v:expr) => {{\n         mod $m {\n             use std::mem::size_of;\n-            #[derive(Copy, Show)]\n+            #[derive(Copy, Debug)]\n             enum E {\n                 V = $v,\n                 A = 0"}, {"sha": "ee2c07150435e9cb9a51e7fec7d3da6ef285a0c9", "filename": "src/test/run-pass/expr-if-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -22,7 +22,7 @@ fn test_rec() {\n     assert_eq!(rs.i, 100);\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum mood { happy, sad, }\n \n impl PartialEq for mood {"}, {"sha": "e4ce71200b5f315f3425e8e00485305f72972e71", "filename": "src/test/run-pass/expr-match-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-struct.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -21,7 +21,7 @@ fn test_rec() {\n     assert_eq!(rs.i, 100);\n }\n \n-#[derive(Copy, Show)]\n+#[derive(Copy, Debug)]\n enum mood { happy, sad, }\n \n impl PartialEq for mood {"}, {"sha": "1f48dc3bcf1d7dbba1bf20a1ab25342dded4b0cd", "filename": "src/test/run-pass/extern-pass-TwoU16s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU16s.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub struct TwoU16s {\n     one: u16, two: u16\n }"}, {"sha": "171e2a647cc6386e9624b0f21908d0e9a04d17f9", "filename": "src/test/run-pass/extern-pass-TwoU32s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU32s.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub struct TwoU32s {\n     one: u32, two: u32\n }"}, {"sha": "83555f6bb1d51dd2a7ac5af64fd1fa60ad76ff42", "filename": "src/test/run-pass/extern-pass-TwoU64s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU64s.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub struct TwoU64s {\n     one: u64, two: u64\n }"}, {"sha": "d2b13445e6a22d99d4b06dea9ca66992ec087080", "filename": "src/test/run-pass/extern-pass-TwoU8s.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-pass-TwoU8s.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -11,7 +11,7 @@\n // Test a foreign function that accepts and returns a struct\n // by value.\n \n-#[derive(Copy, PartialEq, Show)]\n+#[derive(Copy, PartialEq, Debug)]\n pub struct TwoU8s {\n     one: u8, two: u8\n }"}, {"sha": "533d67e27eb2fd8137761e4f156e82d7ebe253c4", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -41,7 +41,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    range(0u, 100).map(|_| {\n+    (0u..100).map(|_| {\n         Thread::scoped(move|| {\n             assert_eq!(count(5), 16);\n         })"}, {"sha": "5201c934185a78a3bb669dc7efd26eb41fcaf0ca", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -38,7 +38,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n pub fn main() {\n-    range(0, 10u).map(|i| {\n+    (0..10u).map(|i| {\n         Thread::scoped(move|| {\n             let result = count(5);\n             println!(\"result = {}\", result);"}, {"sha": "8c686aba5f358d37df243008f0c4f0d828fc0305", "filename": "src/test/run-pass/functional-struct-upd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunctional-struct-upd.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[derive(Show)]\n+#[derive(Debug)]\n struct Foo {\n     x: int,\n     y: int"}, {"sha": "e7ef1d42f5fc14486d2c97c77e7df61eeaa3930d", "filename": "src/test/run-pass/generic-default-type-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265a23320dbeaeca45b889cfea684d71dec1b8e6/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-default-type-params.rs?ref=265a23320dbeaeca45b889cfea684d71dec1b8e6", "patch": "@@ -47,10 +47,10 @@ fn default_foo(x: Foo) {\n     assert_eq!(x.baz(), (1, 'a'));\n }\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n struct BazHelper<T>(T);\n \n-#[derive(PartialEq, Show)]\n+#[derive(PartialEq, Debug)]\n // Ensure that we can use previous type parameters in defaults.\n struct Baz<T, U = BazHelper<T>, V = Option<U>>(T, U, V);\n "}]}