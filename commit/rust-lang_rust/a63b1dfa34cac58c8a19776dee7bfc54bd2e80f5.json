{"sha": "a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2M2IxZGZhMzRjYWM1OGM4YTE5Nzc2ZGVlN2JmYzU0YmQyZTgwZjU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-29T12:57:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-29T12:57:06Z"}, "message": "Rollup merge of #40841 - arielb1:immutable-blame, r=pnkfelix\n\nborrowck: consolidate `mut` suggestions\n\nThis converts all of borrowck's `mut` suggestions to a new\n`mc::ImmutabilityBlame` API instead of the current mix of various hacks.\n\nFixes #35937.\nFixes #40823.\nFixes #40859.\n\ncc @estebank\nr? @pnkfelix", "tree": {"sha": "782376996e2ff71f913524f13a6baad7b8eded61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/782376996e2ff71f913524f13a6baad7b8eded61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "html_url": "https://github.com/rust-lang/rust/commit/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96dd9a9d27fdb59bad8ad545e96ecacad5dec8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/96dd9a9d27fdb59bad8ad545e96ecacad5dec8e6", "html_url": "https://github.com/rust-lang/rust/commit/96dd9a9d27fdb59bad8ad545e96ecacad5dec8e6"}, {"sha": "39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "html_url": "https://github.com/rust-lang/rust/commit/39011f8590b69d5ee9037c4ac9b863a516ae2e1e"}], "stats": {"total": 652, "additions": 427, "deletions": 225}, "files": [{"sha": "f9b740235f49e46534af00fd689dfbf1299af9a3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -907,6 +907,13 @@ impl<'a> LoweringContext<'a> {\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             },\n             variadic: decl.variadic,\n+            has_implicit_self: decl.inputs.get(0).map_or(false, |arg| {\n+                match arg.ty.node {\n+                    TyKind::ImplicitSelf => true,\n+                    TyKind::Rptr(_, ref mt) => mt.ty.node == TyKind::ImplicitSelf,\n+                    _ => false\n+                }\n+            })\n         })\n     }\n "}, {"sha": "27fa7487270885968948620ca571e64f7d849762", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -1383,6 +1383,9 @@ pub struct FnDecl {\n     pub inputs: HirVec<P<Ty>>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n+    /// True if this function has an `self`, `&self` or `&mut self` receiver\n+    /// (but not a `self: Xxx` one).\n+    pub has_implicit_self: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "3b52e85e08e329c798316505a993f1ca9c267ba8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -194,76 +194,75 @@ pub struct cmt_<'tcx> {\n \n pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n+pub enum ImmutabilityBlame<'tcx> {\n+    ImmLocal(ast::NodeId),\n+    ClosureEnv(ast::NodeId),\n+    LocalDeref(ast::NodeId),\n+    AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n+}\n+\n impl<'tcx> cmt_<'tcx> {\n-    pub fn get_def(&self) -> Option<ast::NodeId> {\n-        match self.cat {\n-            Categorization::Deref(ref cmt, ..) |\n-            Categorization::Interior(ref cmt, _) |\n-            Categorization::Downcast(ref cmt, _) => {\n-                if let Categorization::Local(nid) = cmt.cat {\n-                    Some(nid)\n-                } else {\n-                    None\n-                }\n+    fn resolve_field(&self, field_name: FieldName) -> (&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n+    {\n+        let adt_def = self.ty.ty_adt_def().unwrap_or_else(|| {\n+            bug!(\"interior cmt {:?} is not an ADT\", self)\n+        });\n+        let variant_def = match self.cat {\n+            Categorization::Downcast(_, variant_did) => {\n+                adt_def.variant_with_id(variant_did)\n             }\n-            _ => None\n-        }\n+            _ => {\n+                assert!(adt_def.is_univariant());\n+                &adt_def.variants[0]\n+            }\n+        };\n+        let field_def = match field_name {\n+            NamedField(name) => variant_def.field_named(name),\n+            PositionalField(idx) => &variant_def.fields[idx]\n+        };\n+        (adt_def, field_def)\n     }\n \n-    pub fn get_field(&self, name: ast::Name) -> Option<DefId> {\n+    pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n         match self.cat {\n-            Categorization::Deref(ref cmt, ..) |\n-            Categorization::Interior(ref cmt, _) |\n-            Categorization::Downcast(ref cmt, _) => {\n-                if let Categorization::Local(_) = cmt.cat {\n-                    if let ty::TyAdt(def, _) = self.ty.sty {\n-                        if def.is_struct() {\n-                            return def.struct_variant().find_field_named(name).map(|x| x.did);\n+            Categorization::Deref(ref base_cmt, _, BorrowedPtr(ty::ImmBorrow, _)) |\n+            Categorization::Deref(ref base_cmt, _, Implicit(ty::ImmBorrow, _)) => {\n+                // try to figure out where the immutable reference came from\n+                match base_cmt.cat {\n+                    Categorization::Local(node_id) =>\n+                        Some(ImmutabilityBlame::LocalDeref(node_id)),\n+                    Categorization::Interior(ref base_cmt, InteriorField(field_name)) => {\n+                        let (adt_def, field_def) = base_cmt.resolve_field(field_name);\n+                        Some(ImmutabilityBlame::AdtFieldDeref(adt_def, field_def))\n+                    }\n+                    Categorization::Upvar(Upvar { id, .. }) => {\n+                        if let NoteClosureEnv(..) = self.note {\n+                            Some(ImmutabilityBlame::ClosureEnv(id.closure_expr_id))\n+                        } else {\n+                            None\n                         }\n                     }\n-                    None\n-                } else {\n-                    cmt.get_field(name)\n+                    _ => None\n                 }\n             }\n-            _ => None\n-        }\n-    }\n-\n-    pub fn get_field_name(&self) -> Option<ast::Name> {\n-        match self.cat {\n-            Categorization::Interior(_, ref ik) => {\n-                if let InteriorKind::InteriorField(FieldName::NamedField(name)) = *ik {\n-                    Some(name)\n-                } else {\n-                    None\n-                }\n+            Categorization::Local(node_id) => {\n+                Some(ImmutabilityBlame::ImmLocal(node_id))\n             }\n-            Categorization::Deref(ref cmt, ..) |\n-            Categorization::Downcast(ref cmt, _) => {\n-                cmt.get_field_name()\n+            Categorization::Rvalue(..) |\n+            Categorization::Upvar(..) |\n+            Categorization::Deref(.., UnsafePtr(..)) => {\n+                // This should not be reachable up to inference limitations.\n+                None\n             }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn get_arg_if_immutable(&self, map: &hir_map::Map) -> Option<ast::NodeId> {\n-        match self.cat {\n-            Categorization::Deref(ref cmt, ..) |\n-            Categorization::Interior(ref cmt, _) |\n-            Categorization::Downcast(ref cmt, _) => {\n-                if let Categorization::Local(nid) = cmt.cat {\n-                    if let ty::TyAdt(_, _) = self.ty.sty {\n-                        if let ty::TyRef(_, ty::TypeAndMut{mutbl: MutImmutable, ..}) = cmt.ty.sty {\n-                            return Some(nid);\n-                        }\n-                    }\n-                    None\n-                } else {\n-                    cmt.get_arg_if_immutable(map)\n-                }\n+            Categorization::Interior(ref base_cmt, _) |\n+            Categorization::Downcast(ref base_cmt, _) |\n+            Categorization::Deref(ref base_cmt, _, _) => {\n+                base_cmt.immutability_blame()\n+            }\n+            Categorization::StaticItem => {\n+                // Do we want to do something here?\n+                None\n             }\n-            _ => None\n         }\n     }\n }\n@@ -1282,9 +1281,6 @@ pub enum Aliasability {\n #[derive(Copy, Clone, Debug)]\n pub enum AliasableReason {\n     AliasableBorrowed,\n-    AliasableClosure(ast::NodeId), // Aliasable due to capture Fn closure env\n-    AliasableOther,\n-    UnaliasableImmutable, // Created as needed upon seeing ImmutableUnique\n     AliasableStatic,\n     AliasableStaticMut,\n }\n@@ -1324,23 +1320,13 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Deref(ref b, _, Implicit(ty::MutBorrow, _)) |\n             Categorization::Deref(ref b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             Categorization::Deref(ref b, _, Implicit(ty::UniqueImmBorrow, _)) |\n+            Categorization::Deref(ref b, _, Unique) |\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n                 b.freely_aliasable()\n             }\n \n-            Categorization::Deref(ref b, _, Unique) => {\n-                let sub = b.freely_aliasable();\n-                if b.mutbl.is_mutable() {\n-                    // Aliasability depends on base cmt alone\n-                    sub\n-                } else {\n-                    // Do not allow mutation through an immutable box.\n-                    ImmutableUnique(Box::new(sub))\n-                }\n-            }\n-\n             Categorization::Rvalue(..) |\n             Categorization::Local(..) |\n             Categorization::Upvar(..) |\n@@ -1356,13 +1342,9 @@ impl<'tcx> cmt_<'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(ref base, _, BorrowedPtr(ty::ImmBorrow, _)) |\n-            Categorization::Deref(ref base, _, Implicit(ty::ImmBorrow, _)) => {\n-                match base.cat {\n-                    Categorization::Upvar(Upvar{ id, .. }) =>\n-                        FreelyAliasable(AliasableClosure(id.closure_expr_id)),\n-                    _ => FreelyAliasable(AliasableBorrowed)\n-                }\n+            Categorization::Deref(_, _, BorrowedPtr(ty::ImmBorrow, _)) |\n+            Categorization::Deref(_, _, Implicit(ty::ImmBorrow, _)) => {\n+                FreelyAliasable(AliasableBorrowed)\n             }\n         }\n     }"}, {"sha": "cedb9e1cd1cfffc6c1b0df1b98cc60dcd6ec0982", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -188,14 +188,6 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             // user knows what they're doing in these cases.\n             Ok(())\n         }\n-        (mc::Aliasability::ImmutableUnique(_), ty::MutBorrow) => {\n-            bccx.report_aliasability_violation(\n-                        borrow_span,\n-                        loan_cause,\n-                        mc::AliasableReason::UnaliasableImmutable,\n-                        cmt);\n-            Err(())\n-        }\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::UniqueImmBorrow) |\n         (mc::Aliasability::FreelyAliasable(alias_cause), ty::MutBorrow) => {\n             bccx.report_aliasability_violation(\n@@ -510,4 +502,3 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         self.move_error_collector.report_potential_errors(self.bccx);\n     }\n }\n-"}, {"sha": "0915c57b588eb1a7c2c33b091682fd4fce4790e7", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 137, "deletions": 111, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -34,6 +34,7 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n+use rustc::middle::mem_categorization::ImmutabilityBlame;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n \n@@ -659,12 +660,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err_with_code(s, msg, code);\n     }\n \n-    pub fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n+    fn bckerr_to_diag(&self, err: &BckError<'tcx>) -> DiagnosticBuilder<'a> {\n         let span = err.span.clone();\n-        let mut immutable_field = None;\n-        let mut local_def = None;\n \n-        let msg = &match err.code {\n+        let msg = match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n                     mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n@@ -700,27 +699,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        // Check for this field's definition to see if it is an immutable reference\n-                        // and suggest making it mutable if that is the case.\n-                        immutable_field = err.cmt.get_field_name()\n-                            .and_then(|name| err.cmt.get_field(name))\n-                            .and_then(|did| self.tcx.hir.as_local_node_id(did))\n-                            .and_then(|nid| {\n-                                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(nid) {\n-                                    return self.suggest_mut_for_immutable(&field.ty)\n-                                        .map(|msg| (self.tcx.hir.span(nid), msg));\n-                                }\n-                                None\n-                            });\n-                        local_def = err.cmt.get_def()\n-                            .and_then(|nid| {\n-                                if !self.tcx.hir.is_argument(nid) {\n-                                    Some(self.tcx.hir.span(nid))\n-                                } else {\n-                                    None\n-                                }\n-                            });\n-\n                         format!(\"cannot borrow {} as mutable\", descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n@@ -746,16 +724,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let mut db = self.struct_span_err(span, msg);\n-        if let Some((span, msg)) = immutable_field {\n-            db.span_label(span, &msg);\n-        }\n-        if let Some(let_span) = local_def {\n-            if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n-                db.span_label(let_span, &format!(\"consider changing this to `mut {}`\", snippet));\n-            }\n-        }\n-        db\n+        self.struct_span_err(span, &msg)\n     }\n \n     pub fn report_aliasability_violation(&self,\n@@ -788,55 +757,49 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = match cause {\n-            mc::AliasableOther => {\n-                struct_span_err!(\n-                    self.tcx.sess, span, E0385,\n-                    \"{} in an aliasable location\", prefix)\n-            }\n-            mc::AliasableReason::UnaliasableImmutable => {\n-                struct_span_err!(\n-                    self.tcx.sess, span, E0386,\n-                    \"{} in an immutable container\", prefix)\n+        match cause {\n+            mc::AliasableStatic |\n+            mc::AliasableStaticMut => {\n+                // This path cannot occur. It happens when we have an\n+                // `&mut` or assignment to a static. But in the case\n+                // of `static X`, we get a mutability violation first,\n+                // and never get here. In the case of `static mut X`,\n+                // that is unsafe and hence the aliasability error is\n+                // ignored.\n+                span_bug!(span, \"aliasability violation for static `{}`\", prefix)\n             }\n-            mc::AliasableClosure(id) => {\n+            mc::AliasableBorrowed => {}\n+        };\n+        let blame = cmt.immutability_blame();\n+        let mut err = match blame {\n+            Some(ImmutabilityBlame::ClosureEnv(id)) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess, span, E0387,\n                     \"{} in a captured outer variable in an `Fn` closure\", prefix);\n-                if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n+\n+                // FIXME: the distinction between these 2 messages looks wrong.\n+                let help = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n                     // be `FnMut`.\n-                    span_help!(&mut err, self.tcx.hir.span(id),\n-                           \"consider changing this to accept closures that implement `FnMut`\");\n+                    \"consider changing this to accept closures that implement `FnMut`\"\n+\n                 } else {\n-                    span_help!(&mut err, self.tcx.hir.span(id),\n-                           \"consider changing this closure to take self by mutable reference\");\n-                }\n+                    \"consider changing this closure to take self by mutable reference\"\n+                };\n+                err.span_help(self.tcx.hir.span(id), help);\n                 err\n             }\n-            mc::AliasableStatic |\n-            mc::AliasableStaticMut => {\n-                // This path cannot occur. It happens when we have an\n-                // `&mut` or assignment to a static. But in the case\n-                // of `static X`, we get a mutability violation first,\n-                // and never get here. In the case of `static mut X`,\n-                // that is unsafe and hence the aliasability error is\n-                // ignored.\n-                span_bug!(span, \"aliasability violation for static `{}`\", prefix)\n-            }\n-            mc::AliasableBorrowed => {\n-                let mut e = struct_span_err!(\n+            _ =>  {\n+                let mut err = struct_span_err!(\n                     self.tcx.sess, span, E0389,\n                     \"{} in a `&` reference\", prefix);\n-                e.span_label(span, &\"assignment into an immutable reference\");\n-                if let Some(nid) = cmt.get_arg_if_immutable(&self.tcx.hir) {\n-                    self.immutable_argument_should_be_mut(nid, &mut e);\n-                }\n-                e\n+                err.span_label(span, &\"assignment into an immutable reference\");\n+                err\n             }\n         };\n+        self.note_immutability_blame(&mut err, blame);\n \n         if is_closure {\n             err.help(\"closures behind references must be called via `&mut`\");\n@@ -845,49 +808,124 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n-    fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n+    fn suggest_mut_for_immutable(&self, pty: &hir::Ty, is_implicit_self: bool) -> Option<String> {\n         // Check wether the argument is an immutable reference\n+        debug!(\"suggest_mut_for_immutable({:?}, {:?})\", pty, is_implicit_self);\n         if let hir::TyRptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            if !lifetime.is_elided() {\n-                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n-                    if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n-                        .span_to_snippet(lifetime.span) {\n-                            return Some(format!(\"use `&{} mut {}` here to make mutable\",\n-                                                lifetime_snippet,\n-                                                snippet));\n-                    }\n-                }\n-            } else if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(pty.span) {\n-                if snippet.starts_with(\"&\") {\n-                    return Some(format!(\"use `{}` here to make mutable\",\n-                                        snippet.replace(\"&\", \"&mut \")));\n-                }\n+            let pointee_snippet = match self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+                Ok(snippet) => snippet,\n+                _ => return None\n+            };\n+\n+            let lifetime_snippet = if !lifetime.is_elided() {\n+                format!(\"{} \", match self.tcx.sess.codemap().span_to_snippet(lifetime.span) {\n+                    Ok(lifetime_snippet) => lifetime_snippet,\n+                    _ => return None\n+                })\n             } else {\n-                bug!(\"couldn't find a snippet for span: {:?}\", pty.span);\n-            }\n+                String::new()\n+            };\n+            Some(format!(\"use `&{}mut {}` here to make mutable\",\n+                         lifetime_snippet,\n+                         if is_implicit_self { \"self\" } else { &*pointee_snippet }))\n+        } else {\n+            None\n         }\n-        None\n     }\n \n-    fn immutable_argument_should_be_mut(&self, nid: ast::NodeId, db: &mut DiagnosticBuilder) {\n-        let parent = self.tcx.hir.get_parent_node(nid);\n+    fn local_binding_mode(&self, node_id: ast::NodeId) -> hir::BindingMode {\n+        let pat = match self.tcx.hir.get(node_id) {\n+            hir_map::Node::NodeLocal(pat) => pat,\n+            node => bug!(\"bad node for local: {:?}\", node)\n+        };\n+\n+        match pat.node {\n+            hir::PatKind::Binding(mode, ..) => mode,\n+            _ => bug!(\"local is not a binding: {:?}\", pat)\n+        }\n+    }\n+\n+    fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n+        let parent = self.tcx.hir.get_parent_node(node_id);\n         let parent_node = self.tcx.hir.get(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n             let fn_body = self.tcx.hir.body(fn_like.body());\n-            // Get the position of `nid` in the arguments list\n-            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == nid);\n+            // Get the position of `node_id` in the arguments list\n+            let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n-                let arg_ty = &fn_like.decl().inputs[i];\n-                if let Some(msg) = self.suggest_mut_for_immutable(&arg_ty) {\n-                    db.span_label(arg_ty.span, &msg);\n+                (Some(&fn_like.decl().inputs[i]),\n+                 i == 0 && fn_like.decl().has_implicit_self)\n+            } else {\n+                (None, false)\n+            }\n+        } else {\n+            (None, false)\n+        }\n+    }\n+\n+    fn note_immutability_blame(&self,\n+                               db: &mut DiagnosticBuilder,\n+                               blame: Option<ImmutabilityBlame>) {\n+        match blame {\n+            None => {}\n+            Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n+            Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n+                let let_span = self.tcx.hir.span(node_id);\n+                if let hir::BindingMode::BindByValue(..) = self.local_binding_mode(node_id) {\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n+                        let (_, is_implicit_self) = self.local_ty(node_id);\n+                        if is_implicit_self && snippet != \"self\" {\n+                            // avoid suggesting `mut &self`.\n+                            return\n+                        }\n+                        db.span_label(\n+                            let_span,\n+                            &format!(\"consider changing this to `mut {}`\", snippet)\n+                        );\n+                    }\n+                }\n+            }\n+            Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n+                let let_span = self.tcx.hir.span(node_id);\n+                match self.local_binding_mode(node_id) {\n+                    hir::BindingMode::BindByRef(..) => {\n+                        let snippet = self.tcx.sess.codemap().span_to_snippet(let_span);\n+                        if let Ok(snippet) = snippet {\n+                            db.span_label(\n+                                let_span,\n+                                &format!(\"consider changing this to `{}`\",\n+                                         snippet.replace(\"ref \", \"ref mut \"))\n+                            );\n+                        }\n+                    }\n+                    hir::BindingMode::BindByValue(..) => {\n+                        if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n+                            if let Some(msg) =\n+                                 self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n+                                db.span_label(local_ty.span, &msg);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            Some(ImmutabilityBlame::AdtFieldDeref(_, field)) => {\n+                let node_id = match self.tcx.hir.as_local_node_id(field.did) {\n+                    Some(node_id) => node_id,\n+                    None => return\n+                };\n+\n+                if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n+                    if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n+                        db.span_label(field.ty.span, &msg);\n+                    }\n                 }\n             }\n         }\n@@ -941,10 +979,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n+    fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>) {\n         let error_span = err.span.clone();\n         match err.code {\n-            err_mutbl => self.note_and_explain_mutbl_error(db, &err, &error_span),\n+            err_mutbl => {\n+                self.note_and_explain_mutbl_error(db, &err, &error_span);\n+                self.note_immutability_blame(db, err.cmt.immutability_blame());\n+            }\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n@@ -1096,28 +1137,13 @@ before rustc 1.16, this temporary lived longer - see issue #39283 \\\n             _ => {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, &\"cannot borrow as mutable\");\n-                    if let Some(local_id) = err.cmt.get_arg_if_immutable(&self.tcx.hir) {\n-                        self.immutable_argument_should_be_mut(local_id, db);\n-                    } else if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n-                        if let Categorization::Local(local_id) = inner_cmt.cat {\n-                            self.immutable_argument_should_be_mut(local_id, db);\n-                        }\n-                    }\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n                     let span = self.tcx.hir.span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, &format!(\"cannot reborrow mutably\"));\n                             db.span_label(*error_span, &format!(\"try removing `&mut` here\"));\n                         } else {\n-                            if snippet.starts_with(\"ref \") {\n-                                db.span_label(span, &format!(\"use `{}` here to make mutable\",\n-                                                             snippet.replace(\"ref \", \"ref mut \")));\n-                            } else if snippet != \"self\" {\n-                                db.span_label(span,\n-                                              &format!(\"use `mut {}` here to make mutable\",\n-                                                       snippet));\n-                            }\n                             db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n                         }\n                     } else {"}, {"sha": "bfd342a9f213465a9e52b7630bce4e85672cd8e0", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -198,7 +198,7 @@ fn main() {\n ```\n \"##,\n \n-E0386: r##\"\n+/*E0386: r##\"\n This error occurs when an attempt is made to mutate the target of a mutable\n reference stored inside an immutable container.\n \n@@ -228,7 +228,7 @@ let x: i64 = 1;\n let y: Box<Cell<_>> = Box::new(Cell::new(x));\n y.set(2);\n ```\n-\"##,\n+\"##,*/\n \n E0387: r##\"\n This error occurs when an attempt is made to mutate or mutably reference data\n@@ -1117,6 +1117,6 @@ fn main() {\n }\n \n register_diagnostics! {\n-    E0385, // {} in an aliasable location\n+//    E0385, // {} in an aliasable location\n     E0524, // two closures require unique access to `..` at the same time\n }"}, {"sha": "736aa465aa7327a2db646b2f502c98c2db1d8983", "filename": "src/test/compile-fail/augmented-assignments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Faugmented-assignments.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     x;  //~ value moved here\n \n     let y = Int(2);\n-    //~^use `mut y` here to make mutable\n+    //~^ consider changing this to `mut y`\n     y   //~ error: cannot borrow immutable local variable `y` as mutable\n         //~| cannot borrow\n     +="}, {"sha": "8b7ccedd6974fe1be00649de25d8220e7ba7c581", "filename": "src/test/compile-fail/borrowck/borrowck-issue-14498.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-issue-14498.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -23,7 +23,7 @@ fn indirect_write_to_imm_box() {\n     let mut x: isize = 1;\n     let y: Box<_> = box &mut x;\n     let p = &y;\n-    ***p = 2; //~ ERROR cannot assign to data in an immutable container\n+    ***p = 2; //~ ERROR cannot assign to data in a `&` reference\n     drop(p);\n }\n \n@@ -43,7 +43,6 @@ fn borrow_in_var_from_var_via_imm_box() {\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n-    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n@@ -64,7 +63,6 @@ fn borrow_in_var_from_field_via_imm_box() {\n     let p = &y;\n     let q = &***p;\n     **y = 2; //~ ERROR cannot assign to `**y` because it is borrowed\n-    //~^         ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n@@ -85,7 +83,6 @@ fn borrow_in_field_from_var_via_imm_box() {\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n-    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }\n@@ -106,7 +103,6 @@ fn borrow_in_field_from_field_via_imm_box() {\n     let p = &y.a;\n     let q = &***p;\n     **y.a = 2; //~ ERROR cannot assign to `**y.a` because it is borrowed\n-    //~^           ERROR cannot assign to data in an immutable container\n     drop(p);\n     drop(q);\n }"}, {"sha": "499e7e54947b70ed50962dd104ba66b71d6458a6", "filename": "src/test/compile-fail/issue-33819.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     match op {\n         Some(ref v) => { let a = &mut v; },\n         //~^ ERROR:cannot borrow immutable\n-        //~| use `ref mut v` here to make mutable\n+        //~| cannot borrow mutably\n         None => {},\n     }\n }"}, {"sha": "0015c8e5c00a1212731754a71b73af892d25d0e2", "filename": "src/test/compile-fail/mut-suggestion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fmut-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fcompile-fail%2Fmut-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-suggestion.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -17,15 +17,15 @@ impl S {\n }\n \n fn func(arg: S) {\n-    //~^ here to make mutable\n+    //~^ consider changing this to `mut arg`\n     arg.mutate();\n     //~^ ERROR cannot borrow immutable argument\n     //~| cannot borrow mutably\n }\n \n fn main() {\n     let local = S;\n-    //~^ here to make mutable\n+    //~^ consider changing this to `mut local`\n     local.mutate();\n     //~^ ERROR cannot borrow immutable local variable\n     //~| cannot borrow mutably"}, {"sha": "7bb69caa1024af4c060687c83e5bc9ba41a59a5e", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -2,7 +2,7 @@ error: cannot borrow immutable local variable `x` as mutable\n    --> $DIR/huge_multispan_highlight.rs:100:18\n     |\n 12  |     let x = \"foo\";\n-    |         - use `mut x` here to make mutable\n+    |         - consider changing this to `mut x`\n ...\n 100 |     let y = &mut x;\n     |                  ^ cannot borrow mutably"}, {"sha": "60fa06d314ff7bcf7da74a8c2f8a7fa53f1750d7", "filename": "src/test/ui/did_you_mean/issue-31424.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -10,6 +10,8 @@ error: cannot borrow immutable argument `self` as mutable\n error: cannot borrow immutable argument `self` as mutable\n   --> $DIR/issue-31424.rs:23:15\n    |\n+22 |     fn bar(self: &mut Self) {\n+   |            ---- consider changing this to `mut self`\n 23 |         (&mut self).bar();\n    |               ^^^^ cannot borrow mutably\n "}, {"sha": "9ec8728fd32c17ff6c5e826ebbb3354f48b9f50b", "filename": "src/test/ui/did_you_mean/issue-35937.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    pub v: Vec<String>\n+}\n+\n+fn main() {\n+    let f = Foo { v: Vec::new() };\n+    f.v.push(\"cat\".to_string());\n+}\n+\n+\n+struct S {\n+    x: i32,\n+}\n+fn foo() {\n+    let s = S { x: 42 };\n+    s.x += 1;\n+}\n+\n+fn bar(s: S) {\n+    s.x += 1;\n+}"}, {"sha": "bea3d1291433db20d39470c6b61ecb951edad56d", "filename": "src/test/ui/did_you_mean/issue-35937.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -0,0 +1,26 @@\n+error: cannot borrow immutable field `f.v` as mutable\n+  --> $DIR/issue-35937.rs:17:5\n+   |\n+16 |     let f = Foo { v: Vec::new() };\n+   |         - consider changing this to `mut f`\n+17 |     f.v.push(\"cat\".to_string());\n+   |     ^^^ cannot mutably borrow immutable field\n+\n+error: cannot assign to immutable field `s.x`\n+  --> $DIR/issue-35937.rs:26:5\n+   |\n+25 |     let s = S { x: 42 };\n+   |         - consider changing this to `mut s`\n+26 |     s.x += 1;\n+   |     ^^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot assign to immutable field `s.x`\n+  --> $DIR/issue-35937.rs:30:5\n+   |\n+29 | fn bar(s: S) {\n+   |        - consider changing this to `mut s`\n+30 |     s.x += 1;\n+   |     ^^^^^^^^ cannot mutably borrow immutable field\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "855feaf7d2d5e6931e58b0081234dfb866e4a70a", "filename": "src/test/ui/did_you_mean/issue-38147-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -2,7 +2,7 @@ error: cannot borrow immutable borrowed content `*self.s` as mutable\n   --> $DIR/issue-38147-2.rs:17:9\n    |\n 12 |     s: &'a String\n-   |     ------------- use `&'a mut String` here to make mutable\n+   |        ---------- use `&'a mut String` here to make mutable\n ...\n 17 |         self.s.push('x');\n    |         ^^^^^^ cannot borrow as mutable"}, {"sha": "d970d078df8d96c395d088d5a32b442df964ee88", "filename": "src/test/ui/did_you_mean/issue-38147-3.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -2,10 +2,8 @@ error: cannot borrow immutable borrowed content `*self.s` as mutable\n   --> $DIR/issue-38147-3.rs:17:9\n    |\n 12 |     s: &'a String\n-   |     ------------- use `&'a mut String` here to make mutable\n+   |        ---------- use `&'a mut String` here to make mutable\n ...\n-16 |     fn f(&self) {\n-   |          ----- use `&mut self` here to make mutable\n 17 |         self.s.push('x');\n    |         ^^^^^^ cannot borrow as mutable\n "}, {"sha": "6331fc5771fcbb218694944e4034efe72e3cdad3", "filename": "src/test/ui/did_you_mean/issue-39544.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -8,15 +8,46 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum X {\n+pub enum X {\n     Y\n }\n \n-struct Z {\n+pub struct Z {\n     x: X\n }\n \n fn main() {\n     let z = Z { x: X::Y };\n     let _ = &mut z.x;\n }\n+\n+impl Z {\n+    fn foo<'z>(&'z self) {\n+        let _ = &mut self.x;\n+    }\n+\n+    fn foo1(&self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo2<'a>(&'a self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo3<'a>(self: &'a Self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo4(other: &Z) {\n+        let _ = &mut other.x;\n+    }\n+\n+}\n+\n+pub fn with_arg(z: Z, w: &Z) {\n+    let _ = &mut z.x;\n+    let _ = &mut w.x;\n+}"}, {"sha": "e1e229a8b05725acb48415d4dc01a566cc60fab4", "filename": "src/test/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -6,5 +6,89 @@ error: cannot borrow immutable field `z.x` as mutable\n 21 |     let _ = &mut z.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n-error: aborting due to previous error\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:26:22\n+   |\n+25 |     fn foo<'z>(&'z self) {\n+   |                -------- use `&'z mut self` here to make mutable\n+26 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:30:22\n+   |\n+29 |     fn foo1(&self, other: &Z) {\n+   |             ----- use `&mut self` here to make mutable\n+30 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:31:22\n+   |\n+29 |     fn foo1(&self, other: &Z) {\n+   |                           -- use `&mut Z` here to make mutable\n+30 |         let _ = &mut self.x;\n+31 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:35:22\n+   |\n+34 |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                 -------- use `&'a mut self` here to make mutable\n+35 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:36:22\n+   |\n+34 |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                                  -- use `&mut Z` here to make mutable\n+35 |         let _ = &mut self.x;\n+36 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:40:22\n+   |\n+39 |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                       -------- use `&'a mut Self` here to make mutable\n+40 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:41:22\n+   |\n+39 |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                                        -- use `&mut Z` here to make mutable\n+40 |         let _ = &mut self.x;\n+41 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:45:22\n+   |\n+44 |     fn foo4(other: &Z) {\n+   |                    -- use `&mut Z` here to make mutable\n+45 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `z.x` as mutable\n+  --> $DIR/issue-39544.rs:51:18\n+   |\n+50 | pub fn with_arg(z: Z, w: &Z) {\n+   |                 - consider changing this to `mut z`\n+51 |     let _ = &mut z.x;\n+   |                  ^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `w.x` as mutable\n+  --> $DIR/issue-39544.rs:52:18\n+   |\n+50 | pub fn with_arg(z: Z, w: &Z) {\n+   |                          -- use `&mut Z` here to make mutable\n+51 |     let _ = &mut z.x;\n+52 |     let _ = &mut w.x;\n+   |                  ^^^ cannot mutably borrow immutable field\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "f4ae3257279823d57d71a391832d48188ec0e4cd", "filename": "src/test/ui/did_you_mean/issue-40823.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.rs?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let mut buf = &[1, 2, 3, 4];\n+    buf.iter_mut();\n+}"}, {"sha": "8e77ebd9b6da3c1920166533f804014793c63703", "filename": "src/test/ui/did_you_mean/issue-40823.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -0,0 +1,8 @@\n+error: cannot borrow immutable borrowed content `*buf` as mutable\n+  --> $DIR/issue-40823.rs:13:5\n+   |\n+13 |     buf.iter_mut();\n+   |     ^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+"}, {"sha": "edf1635a6b84fe7f1b0f187bf865cc4fccc9e787", "filename": "src/test/ui/span/borrowck-borrow-overloaded-auto-deref-mut.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -2,7 +2,7 @@ error: cannot borrow immutable argument `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:63:24\n    |\n 62 | fn deref_mut_field1(x: Own<Point>) {\n-   |                     - use `mut x` here to make mutable\n+   |                     - consider changing this to `mut x`\n 63 |     let __isize = &mut x.y; //~ ERROR cannot borrow\n    |                        ^ cannot borrow mutably\n \n@@ -28,7 +28,7 @@ error: cannot borrow immutable argument `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:98:5\n    |\n 97 | fn assign_field1<'a>(x: Own<Point>) {\n-   |                      - use `mut x` here to make mutable\n+   |                      - consider changing this to `mut x`\n 98 |     x.y = 3; //~ ERROR cannot borrow\n    |     ^ cannot borrow mutably\n \n@@ -54,7 +54,7 @@ error: cannot borrow immutable argument `x` as mutable\n    --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:119:5\n     |\n 118 | fn deref_mut_method1(x: Own<Point>) {\n-    |                      - use `mut x` here to make mutable\n+    |                      - consider changing this to `mut x`\n 119 |     x.set(0, 0); //~ ERROR cannot borrow\n     |     ^ cannot borrow mutably\n \n@@ -70,7 +70,7 @@ error: cannot borrow immutable argument `x` as mutable\n    --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:139:6\n     |\n 138 | fn assign_method1<'a>(x: Own<Point>) {\n-    |                       - use `mut x` here to make mutable\n+    |                       - consider changing this to `mut x`\n 139 |     *x.y_mut() = 3; //~ ERROR cannot borrow\n     |      ^ cannot borrow mutably\n "}, {"sha": "2ec01168721798684e360cd3a54fca6aa53868dc", "filename": "src/test/ui/span/borrowck-borrow-overloaded-deref-mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -2,7 +2,7 @@ error: cannot borrow immutable argument `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:39:25\n    |\n 38 | fn deref_mut1(x: Own<isize>) {\n-   |               - use `mut x` here to make mutable\n+   |               - consider changing this to `mut x`\n 39 |     let __isize = &mut *x; //~ ERROR cannot borrow\n    |                         ^ cannot borrow mutably\n \n@@ -18,7 +18,7 @@ error: cannot borrow immutable argument `x` as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:59:6\n    |\n 58 | fn assign1<'a>(x: Own<isize>) {\n-   |                - use `mut x` here to make mutable\n+   |                - consider changing this to `mut x`\n 59 |     *x = 3; //~ ERROR cannot borrow\n    |      ^ cannot borrow mutably\n "}, {"sha": "0abdbdc3a21b58f1560763529439ac66aeb5ca35", "filename": "src/test/ui/span/borrowck-object-mutability.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.stderr?ref=a63b1dfa34cac58c8a19776dee7bfc54bd2e80f5", "patch": "@@ -10,6 +10,9 @@ error: cannot borrow immutable borrowed content `*x` as mutable\n error: cannot borrow immutable `Box` content `*x` as mutable\n   --> $DIR/borrowck-object-mutability.rs:29:5\n    |\n+27 | fn owned_receiver(x: Box<Foo>) {\n+   |                   - consider changing this to `mut x`\n+28 |     x.borrowed();\n 29 |     x.borrowed_mut(); //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n "}]}