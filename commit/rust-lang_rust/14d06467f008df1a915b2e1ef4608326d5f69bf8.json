{"sha": "14d06467f008df1a915b2e1ef4608326d5f69bf8", "node_id": "C_kwDOAAsO6NoAKDE0ZDA2NDY3ZjAwOGRmMWE5MTViMmUxZWY0NjA4MzI2ZDVmNjliZjg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-03-22T18:30:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-22T18:30:31Z"}, "message": "Rollup merge of #109179 - llogiq:intrinsically-option-as-slice, r=eholk\n\nmove Option::as_slice to intrinsic\n\n````@scottmcm```` suggested on #109095 I use a direct approach of unpacking the operation in MIR lowering, so here's the implementation.\n\ncc ````@nikic```` as this should hopefully unblock #107224 (though perhaps other changes to the prior implementation, which I left for bootstrapping, are needed).", "tree": {"sha": "3e4b1edde7d3a85e6ef054004205d28bba8deb03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e4b1edde7d3a85e6ef054004205d28bba8deb03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14d06467f008df1a915b2e1ef4608326d5f69bf8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkG0lHCRBK7hj4Ov3rIwAAhnsIAHvR69TY9NCpedu0XjWiUQcx\nflsqm4sdzH/mDsXSwsSIzSzJTHH36+V3t0pa5qrOk205Z9jyUXwqcWDwY+Mg+ujy\n7+yE4dRqXQT2AFeC51gLpO+ZqGWGZNartTgzMoTHAJOwR7kcvk4UztRiAXdGIUL8\nrmq18H9uHSGzGM6OLEw9H+Au/ZvPByLqnZUxWxATFZlqgXyFRyQ6D9sO1eJWnpme\ncWNYb57xUARiM5rYyi0pDKrD+dllJJLPdm1EjHxLCOpxv5vBS/gOKxQ9Rq9E0Xha\nCCY95oEWszMnMNeXJUlwphDnS3r4OQNY7J7CmLxuShK5fNHTahudvnTYKkC6q/E=\n=3lhL\n-----END PGP SIGNATURE-----\n", "payload": "tree 3e4b1edde7d3a85e6ef054004205d28bba8deb03\nparent 59d9cbfa14086540419611491dae90b90daeb588\nparent 27e9ee9baeb8149e3f3d56572061c008109cd134\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1679509831 +0530\ncommitter GitHub <noreply@github.com> 1679509831 +0530\n\nRollup merge of #109179 - llogiq:intrinsically-option-as-slice, r=eholk\n\nmove Option::as_slice to intrinsic\n\n````@scottmcm```` suggested on #109095 I use a direct approach of unpacking the operation in MIR lowering, so here's the implementation.\n\ncc ````@nikic```` as this should hopefully unblock #107224 (though perhaps other changes to the prior implementation, which I left for bootstrapping, are needed).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14d06467f008df1a915b2e1ef4608326d5f69bf8", "html_url": "https://github.com/rust-lang/rust/commit/14d06467f008df1a915b2e1ef4608326d5f69bf8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14d06467f008df1a915b2e1ef4608326d5f69bf8/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59d9cbfa14086540419611491dae90b90daeb588", "url": "https://api.github.com/repos/rust-lang/rust/commits/59d9cbfa14086540419611491dae90b90daeb588", "html_url": "https://github.com/rust-lang/rust/commit/59d9cbfa14086540419611491dae90b90daeb588"}, {"sha": "27e9ee9baeb8149e3f3d56572061c008109cd134", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e9ee9baeb8149e3f3d56572061c008109cd134", "html_url": "https://github.com/rust-lang/rust/commit/27e9ee9baeb8149e3f3d56572061c008109cd134"}], "stats": {"total": 224, "additions": 152, "deletions": 72}, "files": [{"sha": "0863d65d8f9c8a4bdbafab19d6d8a04962f56755", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -301,6 +301,7 @@ language_item_table! {\n     Context,                 sym::Context,             context,                    Target::Struct,         GenericRequirement::None;\n     FuturePoll,              sym::poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n \n+    Option,                  sym::Option,              option_type,                Target::Enum,           GenericRequirement::None;\n     OptionSome,              sym::Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n     OptionNone,              sym::None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n "}, {"sha": "1b7475486dceace01728f805f507c1139fbc6d73", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -223,6 +223,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n             ),\n+            sym::option_payload_ptr => {\n+                let option_def_id = tcx.require_lang_item(hir::LangItem::Option, None);\n+                let p0 = param(0);\n+                (\n+                    1,\n+                    vec![tcx.mk_ptr(ty::TypeAndMut {\n+                        ty: tcx.mk_adt(\n+                            tcx.adt_def(option_def_id),\n+                            tcx.mk_substs_from_iter([ty::GenericArg::from(p0)].into_iter()),\n+                        ),\n+                        mutbl: hir::Mutability::Not,\n+                    })],\n+                    tcx.mk_ptr(ty::TypeAndMut { ty: p0, mutbl: hir::Mutability::Not }),\n+                )\n+            }\n             sym::ptr_mask => (\n                 1,\n                 vec!["}, {"sha": "46eab1184bdad1d45254cd74376ec085506e6f4f", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use rustc_target::abi::VariantIdx;\n \n pub struct LowerIntrinsics;\n \n@@ -191,6 +192,35 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n+                    sym::option_payload_ptr => {\n+                        if let (Some(target), Some(arg)) = (*target, args[0].place()) {\n+                            let ty::RawPtr(ty::TypeAndMut { ty: dest_ty, .. }) =\n+                                destination.ty(local_decls, tcx).ty.kind()\n+                            else { bug!(); };\n+\n+                            block.statements.push(Statement {\n+                                source_info: terminator.source_info,\n+                                kind: StatementKind::Assign(Box::new((\n+                                    *destination,\n+                                    Rvalue::AddressOf(\n+                                        Mutability::Not,\n+                                        arg.project_deeper(\n+                                            &[\n+                                                PlaceElem::Deref,\n+                                                PlaceElem::Downcast(\n+                                                    Some(sym::Some),\n+                                                    VariantIdx::from_u32(1),\n+                                                ),\n+                                                PlaceElem::Field(Field::from_u32(0), *dest_ty),\n+                                            ],\n+                                            tcx,\n+                                        ),\n+                                    ),\n+                                ))),\n+                            });\n+                            terminator.kind = TerminatorKind::Goto { target };\n+                        }\n+                    }\n                     _ if intrinsic_name.as_str().starts_with(\"simd_shuffle\") => {\n                         validate_simd_shuffle(tcx, args, terminator.source_info.span);\n                     }"}, {"sha": "4a1abdf63180a1c5cd61a57a1c2bfc89418be661", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -1044,6 +1044,7 @@ symbols! {\n         optin_builtin_traits,\n         option,\n         option_env,\n+        option_payload_ptr,\n         options,\n         or,\n         or_patterns,"}, {"sha": "7482b8b0862e259a81f7522c708b8845ada71dd1", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -2214,6 +2214,12 @@ extern \"rust-intrinsic\" {\n     where\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n+\n+    #[cfg(not(bootstrap))]\n+    /// This method creates a pointer to any `Some` value. If the argument is\n+    /// `None`, an invalid within-bounds pointer (that is still acceptable for\n+    /// constructing an empty slice) is returned.\n+    pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "cba597e66aa136c90e8e4d3a36d99d4f2e70370a", "filename": "library/core/src/option.rs", "status": "modified", "additions": 36, "deletions": 72, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -559,6 +559,7 @@ use crate::{\n /// The `Option` type. See [the module level documentation](self) for more.\n #[derive(Copy, PartialOrd, Eq, Ord, Debug, Hash)]\n #[rustc_diagnostic_item = \"Option\"]\n+#[cfg_attr(not(bootstrap), lang = \"Option\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n     /// No value.\n@@ -735,48 +736,6 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// This is a guess at how many bytes into the option the payload can be found.\n-    ///\n-    /// For niche-optimized types it's correct because it's pigeon-holed to only\n-    /// one possible place.  For other types, it's usually correct today, but\n-    /// tweaks to the layout algorithm (particularly expansions of\n-    /// `-Z randomize-layout`) might make it incorrect at any point.\n-    ///\n-    /// It's guaranteed to be a multiple of alignment (so will always give a\n-    /// correctly-aligned location) and to be within the allocated object, so\n-    /// is valid to use with `offset` and to use for a zero-sized read.\n-    ///\n-    /// FIXME: This is a horrible hack, but allows a nice optimization.  It should\n-    /// be replaced with `offset_of!` once that works on enum variants.\n-    const SOME_BYTE_OFFSET_GUESS: isize = {\n-        let some_uninit = Some(mem::MaybeUninit::<T>::uninit());\n-        let payload_ref = some_uninit.as_ref().unwrap();\n-        // SAFETY: `as_ref` gives an address inside the existing `Option`,\n-        // so both pointers are derived from the same thing and the result\n-        // cannot overflow an `isize`.\n-        let offset = unsafe { <*const _>::byte_offset_from(payload_ref, &some_uninit) };\n-\n-        // The offset is into the object, so it's guaranteed to be non-negative.\n-        assert!(offset >= 0);\n-\n-        // The payload and the overall option are aligned,\n-        // so the offset will be a multiple of the alignment too.\n-        assert!((offset as usize) % mem::align_of::<T>() == 0);\n-\n-        let max_offset = mem::size_of::<Self>() - mem::size_of::<T>();\n-        if offset as usize <= max_offset {\n-            // There's enough space after this offset for a `T` to exist without\n-            // overflowing the bounds of the object, so let's try it.\n-            offset\n-        } else {\n-            // The offset guess is definitely wrong, so use the address\n-            // of the original option since we have it already.\n-            // This also correctly handles the case of layout-optimized enums\n-            // where `max_offset == 0` and thus this is the only possibility.\n-            0\n-        }\n-    };\n-\n     /// Returns a slice of the contained value, if any. If this is `None`, an\n     /// empty slice is returned. This can be useful to have a single type of\n     /// iterator over an `Option` or slice.\n@@ -809,28 +768,29 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_slice(&self) -> &[T] {\n-        let payload_ptr: *const T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *const Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_ref(value),\n+            None => &[],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_ref`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic always returns a pointer to an\n+        // in-bounds and correctly aligned position for a `T` (even if in the\n+        // `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_ref(self)),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /// Returns a mutable slice of the contained value, if any. If this is\n@@ -875,28 +835,32 @@ impl<T> Option<T> {\n     #[must_use]\n     #[unstable(feature = \"option_as_slice\", issue = \"108545\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        let payload_ptr: *mut T =\n-            // The goal here is that both arms here are calculating exactly\n-            // the same pointer, and thus it'll be folded away when the guessed\n-            // offset is correct, but if the guess is wrong for some reason\n-            // it'll at least still be sound, just no longer optimal.\n-            if let Some(payload) = self {\n-                payload\n-            } else {\n-                let self_ptr: *mut Self = self;\n-                // SAFETY: `SOME_BYTE_OFFSET_GUESS` guarantees that its value is\n-                // such that this will be in-bounds of the object.\n-                unsafe { self_ptr.byte_offset(Self::SOME_BYTE_OFFSET_GUESS).cast() }\n-            };\n-        let len = usize::from(self.is_some());\n+        #[cfg(bootstrap)]\n+        match self {\n+            Some(value) => slice::from_mut(value),\n+            None => &mut [],\n+        }\n \n+        #[cfg(not(bootstrap))]\n         // SAFETY: When the `Option` is `Some`, we're using the actual pointer\n         // to the payload, with a length of 1, so this is equivalent to\n         // `slice::from_mut`, and thus is safe.\n         // When the `Option` is `None`, the length used is 0, so to be safe it\n         // just needs to be aligned, which it is because `&self` is aligned and\n         // the offset used is a multiple of alignment.\n-        unsafe { slice::from_raw_parts_mut(payload_ptr, len) }\n+        //\n+        // In the new version, the intrinsic creates a `*const T` from a\n+        // mutable reference  so it is safe to cast back to a mutable pointer\n+        // here. As with `as_slice`, the intrinsic always returns a pointer to\n+        // an in-bounds and correctly aligned position for a `T` (even if in\n+        // the `None` case it's just padding).\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                crate::intrinsics::option_payload_ptr(crate::ptr::from_mut(self).cast_const())\n+                    .cast_mut(),\n+                usize::from(self.is_some()),\n+            )\n+        }\n     }\n \n     /////////////////////////////////////////////////////////////////////////"}, {"sha": "e535141e772f816770805a0b1336592a27653338", "filename": "tests/mir-opt/lower_intrinsics.option_payload.LowerIntrinsics.diff", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.option_payload.LowerIntrinsics.diff?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -0,0 +1,54 @@\n+- // MIR for `option_payload` before LowerIntrinsics\n++ // MIR for `option_payload` after LowerIntrinsics\n+  \n+  fn option_payload(_1: &Option<usize>, _2: &Option<String>) -> () {\n+      debug o => _1;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:23: +0:24\n+      debug p => _2;                       // in scope 0 at $DIR/lower_intrinsics.rs:+0:42: +0:43\n+      let mut _0: ();                      // return place in scope 0 at $DIR/lower_intrinsics.rs:+0:62: +0:62\n+      let mut _4: *const std::option::Option<usize>; // in scope 0 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+      let mut _6: *const std::option::Option<std::string::String>; // in scope 0 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+      scope 1 {\n+          let _3: *const usize;            // in scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          scope 2 {\n+              debug _x => _3;              // in scope 2 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+              let _5: *const std::string::String; // in scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              scope 3 {\n+                  debug _y => _5;          // in scope 3 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:13: +2:15\n+          StorageLive(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+          _4 = &raw const (*_1);           // scope 1 at $DIR/lower_intrinsics.rs:+2:55: +2:56\n+-         _3 = option_payload_ptr::<usize>(move _4) -> bb1; // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:99:18: 99:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<usize>) -> *const usize {option_payload_ptr::<usize>}, val: Value(<ZST>) }\n++         _3 = &raw const (((*_4) as Some).0: usize); // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n++         goto -> bb1;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:18: +2:57\n+      }\n+  \n+      bb1: {\n+          StorageDead(_4);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:56: +2:57\n+          StorageLive(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:13: +3:15\n+          StorageLive(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+          _6 = &raw const (*_2);           // scope 2 at $DIR/lower_intrinsics.rs:+3:55: +3:56\n+-         _5 = option_payload_ptr::<String>(move _6) -> bb2; // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/lower_intrinsics.rs:100:18: 100:54\n+-                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(*const Option<String>) -> *const String {option_payload_ptr::<String>}, val: Value(<ZST>) }\n++         _5 = &raw const (((*_6) as Some).0: std::string::String); // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n++         goto -> bb2;                     // scope 2 at $DIR/lower_intrinsics.rs:+3:18: +3:57\n+      }\n+  \n+      bb2: {\n+          StorageDead(_6);                 // scope 2 at $DIR/lower_intrinsics.rs:+3:56: +3:57\n+          _0 = const ();                   // scope 1 at $DIR/lower_intrinsics.rs:+1:5: +4:6\n+          StorageDead(_5);                 // scope 2 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          StorageDead(_3);                 // scope 1 at $DIR/lower_intrinsics.rs:+4:5: +4:6\n+          return;                          // scope 0 at $DIR/lower_intrinsics.rs:+5:2: +5:2\n+      }\n+  }\n+  "}, {"sha": "f07e2816f4f41196761acd4859dd2e6869c1d65d", "filename": "tests/mir-opt/lower_intrinsics.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14d06467f008df1a915b2e1ef4608326d5f69bf8/tests%2Fmir-opt%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14d06467f008df1a915b2e1ef4608326d5f69bf8/tests%2Fmir-opt%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.rs?ref=14d06467f008df1a915b2e1ef4608326d5f69bf8", "patch": "@@ -91,3 +91,12 @@ pub fn read_via_copy_uninhabited(r: &Never) -> Never {\n }\n \n pub enum Never {}\n+\n+// EMIT_MIR lower_intrinsics.option_payload.LowerIntrinsics.diff\n+#[cfg(not(bootstrap))]\n+pub fn option_payload(o: &Option<usize>, p: &Option<String>) {\n+    unsafe {\n+        let _x = core::intrinsics::option_payload_ptr(o);\n+        let _y = core::intrinsics::option_payload_ptr(p);\n+    }\n+}"}]}