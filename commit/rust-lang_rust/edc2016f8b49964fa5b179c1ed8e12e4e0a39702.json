{"sha": "edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYzIwMTZmOGI0OTk2NGZhNWIxNzljMWVkOGUxMmU0ZTBhMzk3MDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-05T14:51:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-05T14:51:14Z"}, "message": "Merge #1766\n\n1766: always use \\n newlines r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "75b872d4f0c6a3f084ee24112b003c58c6c64fb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75b872d4f0c6a3f084ee24112b003c58c6c64fb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdcSDiCRBK7hj4Ov3rIwAAdHIIAExJYk4Aiw97du0yCYK1ywR6\nc8uqd/BXEBguhf2w+umNH4eugTCKOTCsq1ei6E3JfA5JPLno2CphHOYFBaUTSrdr\nq0WTxkO5MbhzVWqPIYcGpBUlGQL6LZP1byqvqnBfuQLyROPY9uIfS+mPr2jAZRiz\nIzNHwQLOMGZ1VleD5uVrO0l6K0rT6YqLLq7u97A1qEBsDlZOmmdFi1M6ePrqN81q\nfSoXMytLN6Kp3e/z2DpTLHlpuiWUkrvGvsnF1jI3tMwpEuHxcYDoKcl69zECSL7+\n83ojHg7rCDY0Imw494r46zZzOhszQfKK+z9HynJBBgugVmzhC09OWEzkf1tWKvc=\n=39v2\n-----END PGP SIGNATURE-----\n", "payload": "tree 75b872d4f0c6a3f084ee24112b003c58c6c64fb7\nparent 566c26cbb111981cf861135a15e9ae7912a2083d\nparent 8b8a11ded73df2c2e8a0549a3c7c9ddd2760b0a1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567695074 +0000\ncommitter GitHub <noreply@github.com> 1567695074 +0000\n\nMerge #1766\n\n1766: always use \\n newlines r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "html_url": "https://github.com/rust-lang/rust/commit/edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edc2016f8b49964fa5b179c1ed8e12e4e0a39702/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "566c26cbb111981cf861135a15e9ae7912a2083d", "url": "https://api.github.com/repos/rust-lang/rust/commits/566c26cbb111981cf861135a15e9ae7912a2083d", "html_url": "https://github.com/rust-lang/rust/commit/566c26cbb111981cf861135a15e9ae7912a2083d"}, {"sha": "8b8a11ded73df2c2e8a0549a3c7c9ddd2760b0a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8a11ded73df2c2e8a0549a3c7c9ddd2760b0a1", "html_url": "https://github.com/rust-lang/rust/commit/8b8a11ded73df2c2e8a0549a3c7c9ddd2760b0a1"}], "stats": {"total": 715, "additions": 358, "deletions": 357}, "files": [{"sha": "e2bb120b4b5b93c19e6c8405377d7a388db66848", "filename": "crates/ra_ide_api/src/syntax_tree.rs", "status": "modified", "additions": 357, "deletions": 357, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/edc2016f8b49964fa5b179c1ed8e12e4e0a39702/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edc2016f8b49964fa5b179c1ed8e12e4e0a39702/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_tree.rs?ref=edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "patch": "@@ -1,357 +1,357 @@\n-use crate::db::RootDatabase;\r\n-use ra_db::SourceDatabase;\r\n-use ra_syntax::{\r\n-    algo, AstNode, NodeOrToken, SourceFile,\r\n-    SyntaxKind::{RAW_STRING, STRING},\r\n-    SyntaxToken, TextRange,\r\n-};\r\n-\r\n-pub use ra_db::FileId;\r\n-\r\n-pub(crate) fn syntax_tree(\r\n-    db: &RootDatabase,\r\n-    file_id: FileId,\r\n-    text_range: Option<TextRange>,\r\n-) -> String {\r\n-    let parse = db.parse(file_id);\r\n-    if let Some(text_range) = text_range {\r\n-        let node = match algo::find_covering_element(parse.tree().syntax(), text_range) {\r\n-            NodeOrToken::Node(node) => node,\r\n-            NodeOrToken::Token(token) => {\r\n-                if let Some(tree) = syntax_tree_for_string(&token, text_range) {\r\n-                    return tree;\r\n-                }\r\n-                token.parent()\r\n-            }\r\n-        };\r\n-\r\n-        format!(\"{:#?}\", node)\r\n-    } else {\r\n-        format!(\"{:#?}\", parse.tree().syntax())\r\n-    }\r\n-}\r\n-\r\n-/// Attempts parsing the selected contents of a string literal\r\n-/// as rust syntax and returns its syntax tree\r\n-fn syntax_tree_for_string(token: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n-    // When the range is inside a string\r\n-    // we'll attempt parsing it as rust syntax\r\n-    // to provide the syntax tree of the contents of the string\r\n-    match token.kind() {\r\n-        STRING | RAW_STRING => syntax_tree_for_token(token, text_range),\r\n-        _ => None,\r\n-    }\r\n-}\r\n-\r\n-fn syntax_tree_for_token(node: &SyntaxToken, text_range: TextRange) -> Option<String> {\r\n-    // Range of the full node\r\n-    let node_range = node.text_range();\r\n-    let text = node.text().to_string();\r\n-\r\n-    // We start at some point inside the node\r\n-    // Either we have selected the whole string\r\n-    // or our selection is inside it\r\n-    let start = text_range.start() - node_range.start();\r\n-\r\n-    // how many characters we have selected\r\n-    let len = text_range.len().to_usize();\r\n-\r\n-    let node_len = node_range.len().to_usize();\r\n-\r\n-    let start = start.to_usize();\r\n-\r\n-    // We want to cap our length\r\n-    let len = len.min(node_len);\r\n-\r\n-    // Ensure our slice is inside the actual string\r\n-    let end = if start + len < text.len() { start + len } else { text.len() - start };\r\n-\r\n-    let text = &text[start..end];\r\n-\r\n-    // Remove possible extra string quotes from the start\r\n-    // and the end of the string\r\n-    let text = text\r\n-        .trim_start_matches('r')\r\n-        .trim_start_matches('#')\r\n-        .trim_start_matches('\"')\r\n-        .trim_end_matches('#')\r\n-        .trim_end_matches('\"')\r\n-        .trim()\r\n-        // Remove custom markers\r\n-        .replace(\"<|>\", \"\");\r\n-\r\n-    let parsed = SourceFile::parse(&text);\r\n-\r\n-    // If the \"file\" parsed without errors,\r\n-    // return its syntax\r\n-    if parsed.errors().is_empty() {\r\n-        return Some(format!(\"{:#?}\", parsed.tree().syntax()));\r\n-    }\r\n-\r\n-    None\r\n-}\r\n-\r\n-#[cfg(test)]\r\n-mod tests {\r\n-    use test_utils::assert_eq_text;\r\n-\r\n-    use crate::mock_analysis::{single_file, single_file_with_range};\r\n-\r\n-    #[test]\r\n-    fn test_syntax_tree_without_range() {\r\n-        // Basic syntax\r\n-        let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\r\n-        let syn = analysis.syntax_tree(file_id, None).unwrap();\r\n-\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-SOURCE_FILE@[0; 11)\r\n-  FN_DEF@[0; 11)\r\n-    FN_KW@[0; 2) \"fn\"\r\n-    WHITESPACE@[2; 3) \" \"\r\n-    NAME@[3; 6)\r\n-      IDENT@[3; 6) \"foo\"\r\n-    PARAM_LIST@[6; 8)\r\n-      L_PAREN@[6; 7) \"(\"\r\n-      R_PAREN@[7; 8) \")\"\r\n-    WHITESPACE@[8; 9) \" \"\r\n-    BLOCK_EXPR@[9; 11)\r\n-      BLOCK@[9; 11)\r\n-        L_CURLY@[9; 10) \"{\"\r\n-        R_CURLY@[10; 11) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-\r\n-        let (analysis, file_id) = single_file(\r\n-            r#\"\r\n-fn test() {\r\n-    assert!(\"\r\n-    fn foo() {\r\n-    }\r\n-    \", \"\");\r\n-}\"#\r\n-            .trim(),\r\n-        );\r\n-        let syn = analysis.syntax_tree(file_id, None).unwrap();\r\n-\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-SOURCE_FILE@[0; 60)\r\n-  FN_DEF@[0; 60)\r\n-    FN_KW@[0; 2) \"fn\"\r\n-    WHITESPACE@[2; 3) \" \"\r\n-    NAME@[3; 7)\r\n-      IDENT@[3; 7) \"test\"\r\n-    PARAM_LIST@[7; 9)\r\n-      L_PAREN@[7; 8) \"(\"\r\n-      R_PAREN@[8; 9) \")\"\r\n-    WHITESPACE@[9; 10) \" \"\r\n-    BLOCK_EXPR@[10; 60)\r\n-      BLOCK@[10; 60)\r\n-        L_CURLY@[10; 11) \"{\"\r\n-        WHITESPACE@[11; 16) \"\\n    \"\r\n-        EXPR_STMT@[16; 58)\r\n-          MACRO_CALL@[16; 57)\r\n-            PATH@[16; 22)\r\n-              PATH_SEGMENT@[16; 22)\r\n-                NAME_REF@[16; 22)\r\n-                  IDENT@[16; 22) \"assert\"\r\n-            EXCL@[22; 23) \"!\"\r\n-            TOKEN_TREE@[23; 57)\r\n-              L_PAREN@[23; 24) \"(\"\r\n-              STRING@[24; 52) \"\\\"\\n    fn foo() {\\n     ...\"\r\n-              COMMA@[52; 53) \",\"\r\n-              WHITESPACE@[53; 54) \" \"\r\n-              STRING@[54; 56) \"\\\"\\\"\"\r\n-              R_PAREN@[56; 57) \")\"\r\n-          SEMI@[57; 58) \";\"\r\n-        WHITESPACE@[58; 59) \"\\n\"\r\n-        R_CURLY@[59; 60) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn test_syntax_tree_with_range() {\r\n-        let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\r\n-        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\r\n-\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-FN_DEF@[0; 11)\r\n-  FN_KW@[0; 2) \"fn\"\r\n-  WHITESPACE@[2; 3) \" \"\r\n-  NAME@[3; 6)\r\n-    IDENT@[3; 6) \"foo\"\r\n-  PARAM_LIST@[6; 8)\r\n-    L_PAREN@[6; 7) \"(\"\r\n-    R_PAREN@[7; 8) \")\"\r\n-  WHITESPACE@[8; 9) \" \"\r\n-  BLOCK_EXPR@[9; 11)\r\n-    BLOCK@[9; 11)\r\n-      L_CURLY@[9; 10) \"{\"\r\n-      R_CURLY@[10; 11) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-\r\n-        let (analysis, range) = single_file_with_range(\r\n-            r#\"fn test() {\r\n-    <|>assert!(\"\r\n-    fn foo() {\r\n-    }\r\n-    \", \"\");<|>\r\n-}\"#\r\n-            .trim(),\r\n-        );\r\n-        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\r\n-\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-EXPR_STMT@[16; 58)\r\n-  MACRO_CALL@[16; 57)\r\n-    PATH@[16; 22)\r\n-      PATH_SEGMENT@[16; 22)\r\n-        NAME_REF@[16; 22)\r\n-          IDENT@[16; 22) \"assert\"\r\n-    EXCL@[22; 23) \"!\"\r\n-    TOKEN_TREE@[23; 57)\r\n-      L_PAREN@[23; 24) \"(\"\r\n-      STRING@[24; 52) \"\\\"\\n    fn foo() {\\n     ...\"\r\n-      COMMA@[52; 53) \",\"\r\n-      WHITESPACE@[53; 54) \" \"\r\n-      STRING@[54; 56) \"\\\"\\\"\"\r\n-      R_PAREN@[56; 57) \")\"\r\n-  SEMI@[57; 58) \";\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn test_syntax_tree_inside_string() {\r\n-        let (analysis, range) = single_file_with_range(\r\n-            r#\"fn test() {\r\n-    assert!(\"\r\n-<|>fn foo() {\r\n-}<|>\r\n-fn bar() {\r\n-}\r\n-    \", \"\");\r\n-}\"#\r\n-            .trim(),\r\n-        );\r\n-        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-SOURCE_FILE@[0; 12)\r\n-  FN_DEF@[0; 12)\r\n-    FN_KW@[0; 2) \"fn\"\r\n-    WHITESPACE@[2; 3) \" \"\r\n-    NAME@[3; 6)\r\n-      IDENT@[3; 6) \"foo\"\r\n-    PARAM_LIST@[6; 8)\r\n-      L_PAREN@[6; 7) \"(\"\r\n-      R_PAREN@[7; 8) \")\"\r\n-    WHITESPACE@[8; 9) \" \"\r\n-    BLOCK_EXPR@[9; 12)\r\n-      BLOCK@[9; 12)\r\n-        L_CURLY@[9; 10) \"{\"\r\n-        WHITESPACE@[10; 11) \"\\n\"\r\n-        R_CURLY@[11; 12) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-\r\n-        // With a raw string\r\n-        let (analysis, range) = single_file_with_range(\r\n-            r###\"fn test() {\r\n-    assert!(r#\"\r\n-<|>fn foo() {\r\n-}<|>\r\n-fn bar() {\r\n-}\r\n-    \"#, \"\");\r\n-}\"###\r\n-                .trim(),\r\n-        );\r\n-        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-SOURCE_FILE@[0; 12)\r\n-  FN_DEF@[0; 12)\r\n-    FN_KW@[0; 2) \"fn\"\r\n-    WHITESPACE@[2; 3) \" \"\r\n-    NAME@[3; 6)\r\n-      IDENT@[3; 6) \"foo\"\r\n-    PARAM_LIST@[6; 8)\r\n-      L_PAREN@[6; 7) \"(\"\r\n-      R_PAREN@[7; 8) \")\"\r\n-    WHITESPACE@[8; 9) \" \"\r\n-    BLOCK_EXPR@[9; 12)\r\n-      BLOCK@[9; 12)\r\n-        L_CURLY@[9; 10) \"{\"\r\n-        WHITESPACE@[10; 11) \"\\n\"\r\n-        R_CURLY@[11; 12) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-\r\n-        // With a raw string\r\n-        let (analysis, range) = single_file_with_range(\r\n-            r###\"fn test() {\r\n-    assert!(r<|>#\"\r\n-fn foo() {\r\n-}\r\n-fn bar() {\r\n-}\"<|>#, \"\");\r\n-}\"###\r\n-                .trim(),\r\n-        );\r\n-        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\r\n-        assert_eq_text!(\r\n-            syn.trim(),\r\n-            r#\"\r\n-SOURCE_FILE@[0; 25)\r\n-  FN_DEF@[0; 12)\r\n-    FN_KW@[0; 2) \"fn\"\r\n-    WHITESPACE@[2; 3) \" \"\r\n-    NAME@[3; 6)\r\n-      IDENT@[3; 6) \"foo\"\r\n-    PARAM_LIST@[6; 8)\r\n-      L_PAREN@[6; 7) \"(\"\r\n-      R_PAREN@[7; 8) \")\"\r\n-    WHITESPACE@[8; 9) \" \"\r\n-    BLOCK_EXPR@[9; 12)\r\n-      BLOCK@[9; 12)\r\n-        L_CURLY@[9; 10) \"{\"\r\n-        WHITESPACE@[10; 11) \"\\n\"\r\n-        R_CURLY@[11; 12) \"}\"\r\n-  WHITESPACE@[12; 13) \"\\n\"\r\n-  FN_DEF@[13; 25)\r\n-    FN_KW@[13; 15) \"fn\"\r\n-    WHITESPACE@[15; 16) \" \"\r\n-    NAME@[16; 19)\r\n-      IDENT@[16; 19) \"bar\"\r\n-    PARAM_LIST@[19; 21)\r\n-      L_PAREN@[19; 20) \"(\"\r\n-      R_PAREN@[20; 21) \")\"\r\n-    WHITESPACE@[21; 22) \" \"\r\n-    BLOCK_EXPR@[22; 25)\r\n-      BLOCK@[22; 25)\r\n-        L_CURLY@[22; 23) \"{\"\r\n-        WHITESPACE@[23; 24) \"\\n\"\r\n-        R_CURLY@[24; 25) \"}\"\r\n-\"#\r\n-            .trim()\r\n-        );\r\n-    }\r\n-}\r\n+use crate::db::RootDatabase;\n+use ra_db::SourceDatabase;\n+use ra_syntax::{\n+    algo, AstNode, NodeOrToken, SourceFile,\n+    SyntaxKind::{RAW_STRING, STRING},\n+    SyntaxToken, TextRange,\n+};\n+\n+pub use ra_db::FileId;\n+\n+pub(crate) fn syntax_tree(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    text_range: Option<TextRange>,\n+) -> String {\n+    let parse = db.parse(file_id);\n+    if let Some(text_range) = text_range {\n+        let node = match algo::find_covering_element(parse.tree().syntax(), text_range) {\n+            NodeOrToken::Node(node) => node,\n+            NodeOrToken::Token(token) => {\n+                if let Some(tree) = syntax_tree_for_string(&token, text_range) {\n+                    return tree;\n+                }\n+                token.parent()\n+            }\n+        };\n+\n+        format!(\"{:#?}\", node)\n+    } else {\n+        format!(\"{:#?}\", parse.tree().syntax())\n+    }\n+}\n+\n+/// Attempts parsing the selected contents of a string literal\n+/// as rust syntax and returns its syntax tree\n+fn syntax_tree_for_string(token: &SyntaxToken, text_range: TextRange) -> Option<String> {\n+    // When the range is inside a string\n+    // we'll attempt parsing it as rust syntax\n+    // to provide the syntax tree of the contents of the string\n+    match token.kind() {\n+        STRING | RAW_STRING => syntax_tree_for_token(token, text_range),\n+        _ => None,\n+    }\n+}\n+\n+fn syntax_tree_for_token(node: &SyntaxToken, text_range: TextRange) -> Option<String> {\n+    // Range of the full node\n+    let node_range = node.text_range();\n+    let text = node.text().to_string();\n+\n+    // We start at some point inside the node\n+    // Either we have selected the whole string\n+    // or our selection is inside it\n+    let start = text_range.start() - node_range.start();\n+\n+    // how many characters we have selected\n+    let len = text_range.len().to_usize();\n+\n+    let node_len = node_range.len().to_usize();\n+\n+    let start = start.to_usize();\n+\n+    // We want to cap our length\n+    let len = len.min(node_len);\n+\n+    // Ensure our slice is inside the actual string\n+    let end = if start + len < text.len() { start + len } else { text.len() - start };\n+\n+    let text = &text[start..end];\n+\n+    // Remove possible extra string quotes from the start\n+    // and the end of the string\n+    let text = text\n+        .trim_start_matches('r')\n+        .trim_start_matches('#')\n+        .trim_start_matches('\"')\n+        .trim_end_matches('#')\n+        .trim_end_matches('\"')\n+        .trim()\n+        // Remove custom markers\n+        .replace(\"<|>\", \"\");\n+\n+    let parsed = SourceFile::parse(&text);\n+\n+    // If the \"file\" parsed without errors,\n+    // return its syntax\n+    if parsed.errors().is_empty() {\n+        return Some(format!(\"{:#?}\", parsed.tree().syntax()));\n+    }\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::assert_eq_text;\n+\n+    use crate::mock_analysis::{single_file, single_file_with_range};\n+\n+    #[test]\n+    fn test_syntax_tree_without_range() {\n+        // Basic syntax\n+        let (analysis, file_id) = single_file(r#\"fn foo() {}\"#);\n+        let syn = analysis.syntax_tree(file_id, None).unwrap();\n+\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+SOURCE_FILE@[0; 11)\n+  FN_DEF@[0; 11)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 6)\n+      IDENT@[3; 6) \"foo\"\n+    PARAM_LIST@[6; 8)\n+      L_PAREN@[6; 7) \"(\"\n+      R_PAREN@[7; 8) \")\"\n+    WHITESPACE@[8; 9) \" \"\n+    BLOCK_EXPR@[9; 11)\n+      BLOCK@[9; 11)\n+        L_CURLY@[9; 10) \"{\"\n+        R_CURLY@[10; 11) \"}\"\n+\"#\n+            .trim()\n+        );\n+\n+        let (analysis, file_id) = single_file(\n+            r#\"\n+fn test() {\n+    assert!(\"\n+    fn foo() {\n+    }\n+    \", \"\");\n+}\"#\n+            .trim(),\n+        );\n+        let syn = analysis.syntax_tree(file_id, None).unwrap();\n+\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+SOURCE_FILE@[0; 60)\n+  FN_DEF@[0; 60)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 7)\n+      IDENT@[3; 7) \"test\"\n+    PARAM_LIST@[7; 9)\n+      L_PAREN@[7; 8) \"(\"\n+      R_PAREN@[8; 9) \")\"\n+    WHITESPACE@[9; 10) \" \"\n+    BLOCK_EXPR@[10; 60)\n+      BLOCK@[10; 60)\n+        L_CURLY@[10; 11) \"{\"\n+        WHITESPACE@[11; 16) \"\\n    \"\n+        EXPR_STMT@[16; 58)\n+          MACRO_CALL@[16; 57)\n+            PATH@[16; 22)\n+              PATH_SEGMENT@[16; 22)\n+                NAME_REF@[16; 22)\n+                  IDENT@[16; 22) \"assert\"\n+            EXCL@[22; 23) \"!\"\n+            TOKEN_TREE@[23; 57)\n+              L_PAREN@[23; 24) \"(\"\n+              STRING@[24; 52) \"\\\"\\n    fn foo() {\\n     ...\"\n+              COMMA@[52; 53) \",\"\n+              WHITESPACE@[53; 54) \" \"\n+              STRING@[54; 56) \"\\\"\\\"\"\n+              R_PAREN@[56; 57) \")\"\n+          SEMI@[57; 58) \";\"\n+        WHITESPACE@[58; 59) \"\\n\"\n+        R_CURLY@[59; 60) \"}\"\n+\"#\n+            .trim()\n+        );\n+    }\n+\n+    #[test]\n+    fn test_syntax_tree_with_range() {\n+        let (analysis, range) = single_file_with_range(r#\"<|>fn foo() {}<|>\"#.trim());\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\n+\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+FN_DEF@[0; 11)\n+  FN_KW@[0; 2) \"fn\"\n+  WHITESPACE@[2; 3) \" \"\n+  NAME@[3; 6)\n+    IDENT@[3; 6) \"foo\"\n+  PARAM_LIST@[6; 8)\n+    L_PAREN@[6; 7) \"(\"\n+    R_PAREN@[7; 8) \")\"\n+  WHITESPACE@[8; 9) \" \"\n+  BLOCK_EXPR@[9; 11)\n+    BLOCK@[9; 11)\n+      L_CURLY@[9; 10) \"{\"\n+      R_CURLY@[10; 11) \"}\"\n+\"#\n+            .trim()\n+        );\n+\n+        let (analysis, range) = single_file_with_range(\n+            r#\"fn test() {\n+    <|>assert!(\"\n+    fn foo() {\n+    }\n+    \", \"\");<|>\n+}\"#\n+            .trim(),\n+        );\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\n+\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+EXPR_STMT@[16; 58)\n+  MACRO_CALL@[16; 57)\n+    PATH@[16; 22)\n+      PATH_SEGMENT@[16; 22)\n+        NAME_REF@[16; 22)\n+          IDENT@[16; 22) \"assert\"\n+    EXCL@[22; 23) \"!\"\n+    TOKEN_TREE@[23; 57)\n+      L_PAREN@[23; 24) \"(\"\n+      STRING@[24; 52) \"\\\"\\n    fn foo() {\\n     ...\"\n+      COMMA@[52; 53) \",\"\n+      WHITESPACE@[53; 54) \" \"\n+      STRING@[54; 56) \"\\\"\\\"\"\n+      R_PAREN@[56; 57) \")\"\n+  SEMI@[57; 58) \";\"\n+\"#\n+            .trim()\n+        );\n+    }\n+\n+    #[test]\n+    fn test_syntax_tree_inside_string() {\n+        let (analysis, range) = single_file_with_range(\n+            r#\"fn test() {\n+    assert!(\"\n+<|>fn foo() {\n+}<|>\n+fn bar() {\n+}\n+    \", \"\");\n+}\"#\n+            .trim(),\n+        );\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+SOURCE_FILE@[0; 12)\n+  FN_DEF@[0; 12)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 6)\n+      IDENT@[3; 6) \"foo\"\n+    PARAM_LIST@[6; 8)\n+      L_PAREN@[6; 7) \"(\"\n+      R_PAREN@[7; 8) \")\"\n+    WHITESPACE@[8; 9) \" \"\n+    BLOCK_EXPR@[9; 12)\n+      BLOCK@[9; 12)\n+        L_CURLY@[9; 10) \"{\"\n+        WHITESPACE@[10; 11) \"\\n\"\n+        R_CURLY@[11; 12) \"}\"\n+\"#\n+            .trim()\n+        );\n+\n+        // With a raw string\n+        let (analysis, range) = single_file_with_range(\n+            r###\"fn test() {\n+    assert!(r#\"\n+<|>fn foo() {\n+}<|>\n+fn bar() {\n+}\n+    \"#, \"\");\n+}\"###\n+                .trim(),\n+        );\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+SOURCE_FILE@[0; 12)\n+  FN_DEF@[0; 12)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 6)\n+      IDENT@[3; 6) \"foo\"\n+    PARAM_LIST@[6; 8)\n+      L_PAREN@[6; 7) \"(\"\n+      R_PAREN@[7; 8) \")\"\n+    WHITESPACE@[8; 9) \" \"\n+    BLOCK_EXPR@[9; 12)\n+      BLOCK@[9; 12)\n+        L_CURLY@[9; 10) \"{\"\n+        WHITESPACE@[10; 11) \"\\n\"\n+        R_CURLY@[11; 12) \"}\"\n+\"#\n+            .trim()\n+        );\n+\n+        // With a raw string\n+        let (analysis, range) = single_file_with_range(\n+            r###\"fn test() {\n+    assert!(r<|>#\"\n+fn foo() {\n+}\n+fn bar() {\n+}\"<|>#, \"\");\n+}\"###\n+                .trim(),\n+        );\n+        let syn = analysis.syntax_tree(range.file_id, Some(range.range)).unwrap();\n+        assert_eq_text!(\n+            syn.trim(),\n+            r#\"\n+SOURCE_FILE@[0; 25)\n+  FN_DEF@[0; 12)\n+    FN_KW@[0; 2) \"fn\"\n+    WHITESPACE@[2; 3) \" \"\n+    NAME@[3; 6)\n+      IDENT@[3; 6) \"foo\"\n+    PARAM_LIST@[6; 8)\n+      L_PAREN@[6; 7) \"(\"\n+      R_PAREN@[7; 8) \")\"\n+    WHITESPACE@[8; 9) \" \"\n+    BLOCK_EXPR@[9; 12)\n+      BLOCK@[9; 12)\n+        L_CURLY@[9; 10) \"{\"\n+        WHITESPACE@[10; 11) \"\\n\"\n+        R_CURLY@[11; 12) \"}\"\n+  WHITESPACE@[12; 13) \"\\n\"\n+  FN_DEF@[13; 25)\n+    FN_KW@[13; 15) \"fn\"\n+    WHITESPACE@[15; 16) \" \"\n+    NAME@[16; 19)\n+      IDENT@[16; 19) \"bar\"\n+    PARAM_LIST@[19; 21)\n+      L_PAREN@[19; 20) \"(\"\n+      R_PAREN@[20; 21) \")\"\n+    WHITESPACE@[21; 22) \" \"\n+    BLOCK_EXPR@[22; 25)\n+      BLOCK@[22; 25)\n+        L_CURLY@[22; 23) \"{\"\n+        WHITESPACE@[23; 24) \"\\n\"\n+        R_CURLY@[24; 25) \"}\"\n+\"#\n+            .trim()\n+        );\n+    }\n+}"}, {"sha": "f2e1646181bc4212a4a4658582c3dc2b1a84d70b", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edc2016f8b49964fa5b179c1ed8e12e4e0a39702/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/edc2016f8b49964fa5b179c1ed8e12e4e0a39702/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=edc2016f8b49964fa5b179c1ed8e12e4e0a39702", "patch": "@@ -1,2 +1,3 @@\n reorder_modules = false\n use_small_heuristics = \"Max\"\n+newline_style = \"Unix\""}]}