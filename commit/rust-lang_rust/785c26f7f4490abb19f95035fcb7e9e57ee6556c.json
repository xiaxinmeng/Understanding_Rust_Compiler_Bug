{"sha": "785c26f7f4490abb19f95035fcb7e9e57ee6556c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NWMyNmY3ZjQ0OTBhYmIxOWY5NTAzNWZjYjdlOWU1N2VlNjU1NmM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-02T14:09:41Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-02T14:09:41Z"}, "message": "Rename ivecs to vecs in the compiler", "tree": {"sha": "dd00e52a1d767c2c6e668dd348d432a9bfbe11ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd00e52a1d767c2c6e668dd348d432a9bfbe11ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/785c26f7f4490abb19f95035fcb7e9e57ee6556c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/785c26f7f4490abb19f95035fcb7e9e57ee6556c", "html_url": "https://github.com/rust-lang/rust/commit/785c26f7f4490abb19f95035fcb7e9e57ee6556c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/785c26f7f4490abb19f95035fcb7e9e57ee6556c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0e2809f54fcb6ea39fec3b58b0c6fcbcba98cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0e2809f54fcb6ea39fec3b58b0c6fcbcba98cf2", "html_url": "https://github.com/rust-lang/rust/commit/a0e2809f54fcb6ea39fec3b58b0c6fcbcba98cf2"}], "stats": {"total": 209, "additions": 85, "deletions": 124}, "files": [{"sha": "b14afb0d594f2f6a7a72d69bde7f4887b727a287", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -36,16 +36,6 @@ const box_rc_field_body: int = 1;\n \n const general_code_alignment: int = 16;\n \n-const vec_elt_rc: int = 0;\n-\n-const vec_elt_alloc: int = 1;\n-\n-const vec_elt_fill: int = 2;\n-\n-const vec_elt_pad: int = 3;\n-\n-const vec_elt_data: int = 4;\n-\n const tydesc_field_first_param: int = 0;\n const tydesc_field_size: int = 1;\n const tydesc_field_align: int = 2;\n@@ -92,11 +82,11 @@ const closure_elt_bindings: int = 1;\n \n const closure_elt_ty_params: int = 2;\n \n-const ivec_elt_fill: uint = 0u;\n+const vec_elt_fill: uint = 0u;\n \n-const ivec_elt_alloc: uint = 1u;\n+const vec_elt_alloc: uint = 1u;\n \n-const ivec_elt_elems: uint = 2u;\n+const vec_elt_elems: uint = 2u;\n \n const worst_case_glue_call_args: int = 7;\n "}, {"sha": "dc007a1d3f20be7d1b169017e25bf79da53ab0b0", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -10,10 +10,10 @@ import middle::trans_common::T_i1;\n import middle::trans_common::T_i8;\n import middle::trans_common::T_i32;\n import middle::trans_common::T_int;\n-import middle::trans_common::T_ivec;\n+import middle::trans_common::T_vec;\n import middle::trans_common::T_nil;\n import middle::trans_common::T_opaque_chan_ptr;\n-import middle::trans_common::T_opaque_ivec;\n+import middle::trans_common::T_opaque_vec;\n import middle::trans_common::T_opaque_port_ptr;\n import middle::trans_common::T_ptr;\n import middle::trans_common::T_size_t;\n@@ -36,8 +36,8 @@ type upcalls =\n      shared_free: ValueRef,\n      mark: ValueRef,\n      get_type_desc: ValueRef,\n-     ivec_grow: ValueRef,\n-     ivec_push: ValueRef,\n+     vec_grow: ValueRef,\n+     vec_push: ValueRef,\n      cmp_type: ValueRef,\n      log_type: ValueRef,\n      dynastack_mark: ValueRef,\n@@ -82,12 +82,12 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n               d(~\"get_type_desc\",\n                 [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n                  T_ptr(T_ptr(tydesc_type)), T_int()], T_ptr(tydesc_type)),\n-          ivec_grow:\n-              d(~\"vec_grow\", [T_ptr(T_ptr(T_opaque_ivec())), T_int()],\n+          vec_grow:\n+              d(~\"vec_grow\", [T_ptr(T_ptr(T_opaque_vec())), T_int()],\n                 T_void()),\n-          ivec_push:\n+          vec_push:\n               d(~\"vec_push\",\n-                [T_ptr(T_ptr(T_opaque_ivec())), T_ptr(tydesc_type),\n+                [T_ptr(T_ptr(T_opaque_vec())), T_ptr(tydesc_type),\n                  T_ptr(T_i8())], T_void()),\n           cmp_type:\n               dr(~\"cmp_type\","}, {"sha": "99f376042e1e6d0318027a5dd20a67256ceeaba9", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -56,7 +56,7 @@ const shape_i64: u8 = 7u8;\n const shape_f32: u8 = 8u8;\n const shape_f64: u8 = 9u8;\n // (10 is currently unused, was evec)\n-const shape_ivec: u8 = 11u8;\n+const shape_vec: u8 = 11u8;\n const shape_tag: u8 = 12u8;\n const shape_box: u8 = 13u8;\n const shape_struct: u8 = 17u8;\n@@ -306,7 +306,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n \n \n       ty::ty_istr. {\n-        s += [shape_ivec];\n+        s += [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty));\n@@ -358,7 +358,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n         add_substr(s, shape_of(ccx, subt));\n       }\n       ty::ty_vec(mt) {\n-        s += [shape_ivec];\n+        s += [shape_vec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n         add_substr(s, shape_of(ccx, mt.ty));\n       }"}, {"sha": "f8247d206a9fa63a22bfd35c19d4e39715a252f6", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 31, "deletions": 60, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -72,7 +72,7 @@ import trans_build::*;\n \n import trans_objects::trans_anon_obj;\n import trans_objects::trans_obj;\n-import ivec = trans_ivec;\n+import tvec = trans_vec;\n \n // This function now fails if called on a type with dynamic size (as its\n // return value was always meaningless in that case anyhow). Beware!\n@@ -202,14 +202,14 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n         }\n       }\n       ty::ty_char. { llty = T_char(); }\n-      ty::ty_istr. { llty = T_ptr(T_ivec(T_i8())); }\n+      ty::ty_istr. { llty = T_ptr(T_vec(T_i8())); }\n       ty::ty_tag(did, _) { llty = type_of_tag(cx, sp, did, t); }\n       ty::ty_box(mt) { llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty))); }\n       ty::ty_uniq(t) { llty = T_ptr(type_of_inner(cx, sp, t)); }\n       ty::ty_vec(mt) {\n         if ty::type_has_dynamic_size(cx.tcx, mt.ty) {\n-            llty = T_ptr(T_opaque_ivec());\n-        } else { llty = T_ptr(T_ivec(type_of_inner(cx, sp, mt.ty))); }\n+            llty = T_ptr(T_opaque_vec());\n+        } else { llty = T_ptr(T_vec(type_of_inner(cx, sp, mt.ty))); }\n       }\n       ty::ty_ptr(mt) { llty = T_ptr(type_of_inner(cx, sp, mt.ty)); }\n       ty::ty_rec(fields) {\n@@ -1306,9 +1306,9 @@ fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n         bcx = incr_refcnt_of_boxed(bcx, Load(bcx, v));\n     } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n         bcx = iter_structural_ty(bcx, v, t, take_ty);\n-    } else if ty::type_is_ivec(bcx_tcx(bcx), t) {\n-        bcx = ivec::duplicate(bcx, v);\n-        bcx = ivec::iter_ivec(bcx, v, t, take_ty);\n+    } else if ty::type_is_vec(bcx_tcx(bcx), t) {\n+        bcx = tvec::duplicate(bcx, v);\n+        bcx = tvec::iter_vec(bcx, v, t, take_ty);\n     }\n \n     build_return(bcx);\n@@ -1390,8 +1390,8 @@ fn make_drop_glue(bcx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(bcx);\n     let bcx = alt ty::struct(ccx.tcx, t) {\n-      ty::ty_vec(_) { ivec::make_drop_glue(bcx, v0, t) }\n-      ty::ty_istr. { ivec::make_drop_glue(bcx, v0, t) }\n+      ty::ty_vec(_) { tvec::make_drop_glue(bcx, v0, t) }\n+      ty::ty_istr. { tvec::make_drop_glue(bcx, v0, t) }\n       ty::ty_box(_) { decr_refcnt_maybe_free(bcx, v0, v0, t) }\n       ty::ty_uniq(_) { trans_shared_free(bcx, Load(bcx, v0)) }\n       ty::ty_obj(_) {\n@@ -1809,19 +1809,11 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n    -> @block_ctxt {\n     fn iter_sequence_body(bcx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n-                          f: &val_and_ty_fn, trailing_null: bool,\n-                          interior: bool) -> @block_ctxt {\n-        let p0;\n-        let len;\n+                          f: &val_and_ty_fn, trailing_null: bool)\n+        -> @block_ctxt {\n         let llunit_ty = type_of_or_i8(bcx, elt_ty);\n-        if !interior {\n-            p0 = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n-            let lp = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n-            len = Load(bcx, lp);\n-        } else {\n-            len = ivec::get_fill(bcx, v);\n-            p0 = ivec::get_dataptr(bcx, v, llunit_ty);\n-        }\n+        let p0 = tvec::get_dataptr(bcx, v, llunit_ty);\n+        let len = tvec::get_fill(bcx, v);\n \n         if trailing_null {\n             let unit_sz = size_of(bcx, elt_ty);\n@@ -1836,11 +1828,11 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n \n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_vec(elt) {\n-        ret iter_sequence_body(cx, v, elt.ty, f, false, true);\n+        ret iter_sequence_body(cx, v, elt.ty, f, false);\n       }\n       ty::ty_istr. {\n         let et = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n-        ret iter_sequence_body(cx, v, et, f, true, true);\n+        ret iter_sequence_body(cx, v, et, f, true);\n       }\n       _ {\n         bcx_ccx(cx).sess.bug(\n@@ -2147,7 +2139,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n     } else if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) {\n         ret cx;\n     } else if ty::type_is_boxed(ccx.tcx, t) ||\n-              ty::type_is_ivec(ccx.tcx, t) {\n+              ty::type_is_vec(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n             drop_ty(cx, dst, t)\n         } else { cx };\n@@ -2259,7 +2251,7 @@ fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n \n fn trans_lit(cx: &@block_ctxt, lit: &ast::lit) -> result {\n     alt lit.node {\n-      ast::lit_str(s) { ret ivec::trans_istr(cx, s); }\n+      ast::lit_str(s) { ret tvec::trans_istr(cx, s); }\n       _ { ret rslt(cx, trans_crate_lit(bcx_ccx(cx), lit)); }\n     }\n }\n@@ -2357,7 +2349,7 @@ fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n     alt op {\n       ast::add. {\n         if ty::type_is_sequence(bcx_tcx(cx), intype) {\n-            ret ivec::trans_add(cx, intype, lhs, rhs);\n+            ret tvec::trans_add(cx, intype, lhs, rhs);\n         }\n         if is_float {\n             ret rslt(cx, FAdd(cx, lhs, rhs));\n@@ -3168,8 +3160,8 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     maybe_name_value(bcx_ccx(cx), unit_sz.val, ~\"unit_sz\");\n     let scaled_ix = Mul(bcx, ix_val, unit_sz.val);\n     maybe_name_value(bcx_ccx(cx), scaled_ix, ~\"scaled_ix\");\n-    let lim = ivec::get_fill(bcx, v);\n-    let body = ivec::get_dataptr(bcx, v, type_of_or_i8(bcx, unit_ty));\n+    let lim = tvec::get_fill(bcx, v);\n+    let body = tvec::get_dataptr(bcx, v, type_of_or_i8(bcx, unit_ty));\n     let bounds_check = ICmp(bcx, lib::llvm::LLVMIntULT, scaled_ix, lim);\n     let fail_cx = new_sub_block_ctxt(bcx, ~\"fail\");\n     let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n@@ -3632,7 +3624,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             val = dst.val;\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n-            if ty::type_is_ivec(ccx.tcx, e_ty) {\n+            if ty::type_is_vec(ccx.tcx, e_ty) {\n                 let arg_copy = do_spill(bcx, Load(bcx, val));\n                 bcx = take_ty(bcx, arg_copy, e_ty);\n                 val = Load(bcx, arg_copy);\n@@ -4056,7 +4048,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n           ty::ty_vec(_) {\n             alt src.node {\n               ast::expr_vec(args, _) {\n-                let bcx = ivec::trans_append_literal\n+                let bcx = tvec::trans_append_literal\n                     (lhs_res.res.bcx, lhs_res.res.val, t, args);\n                 ret rslt(bcx, C_nil());\n               }\n@@ -4071,7 +4063,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         if ty::type_is_sequence(tcx, t) {\n             alt op {\n               ast::add. {\n-                ret ivec::trans_append(rhs_res.bcx, t, lhs_res.res.val,\n+                ret tvec::trans_append(rhs_res.bcx, t, lhs_res.res.val,\n                                        rhs_res.val);\n               }\n               _ { }\n@@ -4091,7 +4083,7 @@ fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n         ret trans_call(cx, f, none::<ValueRef>, args, e.id);\n       }\n       ast::expr_cast(val, _) { ret trans_cast(cx, val, e.id); }\n-      ast::expr_vec(args, _) { ret ivec::trans_ivec(cx, args, e.id); }\n+      ast::expr_vec(args, _) { ret tvec::trans_vec(cx, args, e.id); }\n       ast::expr_rec(args, base) { ret trans_rec(cx, args, base, e.id); }\n       ast::expr_tup(args) { ret trans_tup(cx, args, e.id); }\n       ast::expr_mac(_) { ret bcx_ccx(cx).sess.bug(~\"unexpanded macro\"); }\n@@ -4177,7 +4169,7 @@ fn with_out_method(work: fn(&out_method) -> result, cx: @block_ctxt,\n // immediate-ness of the type.\n fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n     ret ty::type_is_scalar(ccx.tcx, t) || ty::type_is_boxed(ccx.tcx, t) ||\n-        ty::type_is_native(ccx.tcx, t) || ty::type_is_ivec(ccx.tcx, t);\n+        ty::type_is_native(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t);\n }\n \n fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n@@ -4264,21 +4256,10 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(tcx, e_ty) {\n-            let is_istr = alt ty::struct(tcx, e_ty) {\n-              ty::ty_istr. { true }\n-              _ { false }\n-            };\n-            if !is_istr {\n-                let elt =\n-                    GEP(bcx, expr_res.val,\n-                        [C_int(0), C_int(abi::vec_elt_data)]);\n-                ret trans_fail_value(bcx, sp_opt, elt);\n-            } else {\n-                let data = ivec::get_dataptr(\n-                    bcx, expr_res.val,\n-                    type_of_or_i8(bcx, ty::mk_mach(tcx, ast::ty_u8)));\n-                ret trans_fail_value(bcx, sp_opt, data);\n-            }\n+            let data = tvec::get_dataptr(\n+                bcx, expr_res.val,\n+                type_of_or_i8(bcx, ty::mk_mach(tcx, ast::ty_u8)));\n+            ret trans_fail_value(bcx, sp_opt, data);\n         } else {\n             bcx_ccx(cx).sess.span_bug(expr.span,\n                                       ~\"fail called with unsupported type \"\n@@ -5449,13 +5430,13 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n     fn create_main(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_istr(ccx.tcx);\n-        let ivecarg_ty: ty::arg =\n+        let vecarg_ty: ty::arg =\n             {mode: ty::mo_val,\n              ty:\n                  ty::mk_vec(ccx.tcx,\n                             {ty: unit_ty, mut: ast::imm})};\n         let llfty =\n-            type_of_fn(ccx, sp, ast::proto_fn, [ivecarg_ty],\n+            type_of_fn(ccx, sp, ast::proto_fn, [vecarg_ty],\n                        ty::mk_nil(ccx.tcx), 0u);\n         let llfdecl = decl_fastcall_fn(ccx.llmod, ~\"_rust_main\", llfty);\n \n@@ -5942,16 +5923,6 @@ fn decl_no_op_type_glue(llmod: ModuleRef, taskptr_type: TypeRef) -> ValueRef {\n                          abi::no_op_type_glue_name(), ty);\n }\n \n-fn vec_fill(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    ret Load(bcx, GEP(bcx, v,\n-                                     [C_int(0), C_int(abi::vec_elt_fill)]));\n-}\n-\n-fn vec_p0(bcx: &@block_ctxt, v: ValueRef) -> ValueRef {\n-    let p = GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n-    ret PointerCast(bcx, p, T_ptr(T_i8()));\n-}\n-\n fn make_glues(llmod: ModuleRef, taskptr_type: TypeRef) -> @glue_fns {\n     ret @{no_op_type_glue: decl_no_op_type_glue(llmod, taskptr_type)};\n }"}, {"sha": "1b34d09d33ef0d4290aaa96d743053ca1931608a", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -643,15 +643,15 @@ fn T_array(t: TypeRef, n: uint) -> TypeRef { ret llvm::LLVMArrayType(t, n); }\n // Interior vector.\n //\n // TODO: Support user-defined vector sizes.\n-fn T_ivec(t: TypeRef) -> TypeRef {\n+fn T_vec(t: TypeRef) -> TypeRef {\n     ret T_struct([T_int(), // fill\n                   T_int(), // alloc\n                   T_array(t, 0u)]); // elements\n }\n \n // Note that the size of this one is in bytes.\n-fn T_opaque_ivec() -> TypeRef {\n-    ret T_ivec(T_i8());\n+fn T_opaque_vec() -> TypeRef {\n+    ret T_vec(T_i8());\n }\n \n fn T_box(t: TypeRef) -> TypeRef { ret T_struct([T_int(), t]); }"}, {"sha": "317d6513b3e807d06d0bf726ccd300fb35e3fe2e", "filename": "src/comp/middle/trans_vec.rs", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -13,14 +13,14 @@ import trans_build::*;\n import trans_common::*;\n \n fn get_fill(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::ivec_elt_fill)]))\n+    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::vec_elt_fill)]))\n }\n fn get_alloc(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n-    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]))\n+    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::vec_elt_alloc)]))\n }\n fn get_dataptr(bcx: &@block_ctxt, vpt: ValueRef,\n                unit_ty: TypeRef) -> ValueRef {\n-    let ptr = InBoundsGEP(bcx, vpt, [C_int(0), C_uint(abi::ivec_elt_elems)]);\n+    let ptr = InBoundsGEP(bcx, vpt, [C_int(0), C_uint(abi::vec_elt_elems)]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n@@ -32,14 +32,14 @@ fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef)\n }\n \n fn alloc_raw(bcx: &@block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n-    let llvecty = T_opaque_ivec();\n+    let llvecty = T_opaque_vec();\n     let vecsize = Add(bcx, alloc, llsize_of(llvecty));\n     let {bcx, val: vecptr} =\n         trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n     Store(bcx, fill, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_fill)]));\n+          (bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_fill)]));\n     Store(bcx, alloc, InBoundsGEP\n-          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n+          (bcx, vecptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n     ret {bcx: bcx, val: vecptr};\n }\n \n@@ -52,7 +52,7 @@ type alloc_result = {bcx: @block_ctxt,\n fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let llvecty = T_ivec(llunitty);\n+    let llvecty = T_vec(llunitty);\n     let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n \n     let fill = Mul(bcx, C_uint(elts), unit_sz);\n@@ -67,11 +67,11 @@ fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n     let vptr = Load(bcx, vptrptr);\n     let fill = get_fill(bcx, vptr);\n-    let size = Add(bcx, fill, llsize_of(T_opaque_ivec()));\n+    let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n     let {bcx, val: newptr} = trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n     Store(bcx, fill,\n-          InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n+          InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n     Store(bcx, newptr, vptrptr);\n     ret bcx;\n }\n@@ -84,14 +84,14 @@ fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t)\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        drop_cx = iter_ivec(drop_cx, vptrptr, vec_ty, trans::drop_ty);\n+        drop_cx = iter_vec(drop_cx, vptrptr, vec_ty, trans::drop_ty);\n     }\n     drop_cx = trans::trans_shared_free(drop_cx, vptr);\n     Br(drop_cx, next_cx.llbb);\n     ret next_cx;\n }\n \n-fn trans_ivec(bcx: &@block_ctxt, args: &[@ast::expr],\n+fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr],\n               id: ast::node_id) -> result {\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n     let {bcx, val: vptr, llunitsz, unit_ty, llunitty} =\n@@ -131,8 +131,8 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n     if dynamic {\n-        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_ivec())));\n-        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_ivec()));\n+        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n+        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_vec()));\n     }\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_istr. { true }\n@@ -148,8 +148,8 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let rfill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n-    let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_ivec())));\n-    Call(bcx, bcx_ccx(cx).upcalls.ivec_grow,\n+    let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n+    Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n          [cx.fcx.lltaskptr, opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n@@ -160,7 +160,7 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill(bcx, write_ptr);\n-    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rfill, { | &bcx, addr, _ty |\n+    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill, { | &bcx, addr, _ty |\n         let write_ptr = Load(bcx, write_ptr_ptr);\n         let bcx = copy_val(bcx, INIT, write_ptr,\n                            load_if_immediate(bcx, addr, unit_ty), unit_ty);\n@@ -182,12 +182,12 @@ fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     let {bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, tps_normal, ti).result;\n     trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n-    let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_ivec())));\n+    let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n         bcx = e_bcx;\n         let spilled = trans::spill_if_immediate(bcx, elt, elt_ty);\n-        Call(bcx, bcx_ccx(bcx).upcalls.ivec_push,\n+        Call(bcx, bcx_ccx(bcx).upcalls.vec_push,\n              [bcx.fcx.lltaskptr, opaque_v, td,\n               PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n@@ -209,7 +209,7 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n     let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let {bcx, val: new_vec} = alloc_raw(bcx, new_fill, new_fill);\n-    let new_vec = PointerCast(bcx, new_vec, T_ptr(T_ivec(llunitty)));\n+    let new_vec = PointerCast(bcx, new_vec, T_ptr(T_vec(llunitty)));\n     add_clean_temp(bcx, new_vec, vec_ty);\n \n     let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n@@ -228,21 +228,21 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n         ret bcx;\n     } (_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n-    let bcx = iter_ivec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n-    let bcx = iter_ivec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n+    let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n+    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n     ret rslt(bcx, new_vec);\n }\n \n type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n \n-type iter_ivec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n+type iter_vec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n-fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n-                 fill: ValueRef, f: &iter_ivec_block) -> @block_ctxt {\n+fn iter_vec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n+                 fill: ValueRef, f: &iter_vec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(T_ivec(llunitty)));\n+    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(llunitty)));\n     let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n@@ -252,13 +252,13 @@ fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     let data_ptr_ptr = do_spill(bcx, data_ptr);\n \n     // Now perform the iteration.\n-    let header_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_header\");\n+    let header_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_loop_header\");\n     Br(bcx, header_cx.llbb);\n     let data_ptr = Load(header_cx, data_ptr_ptr);\n     let not_yet_at_end = ICmp(header_cx, lib::llvm::LLVMIntULT,\n                               data_ptr, data_end_ptr);\n-    let body_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_body\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_next\");\n+    let body_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_loop_body\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"iter_vec_next\");\n     CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n     body_cx = f(body_cx, data_ptr, unit_ty);\n     let increment = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n@@ -270,11 +270,11 @@ fn iter_ivec_raw(bcx: &@block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n     ret next_cx;\n }\n \n-fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-             f: &iter_ivec_block) -> @block_ctxt {\n+fn iter_vec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+             f: &iter_vec_block) -> @block_ctxt {\n     let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n-                                     T_ptr(T_ptr(T_opaque_ivec()))));\n-    ret iter_ivec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+                                     T_ptr(T_ptr(T_opaque_vec()))));\n+    ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n \n //", "previous_filename": "src/comp/middle/trans_ivec.rs"}, {"sha": "7a9d3221539f5f38323964651d18e05fcdd0bb68", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -153,7 +153,7 @@ export type_is_bool;\n export type_is_bot;\n export type_is_box;\n export type_is_boxed;\n-export type_is_ivec;\n+export type_is_vec;\n export type_is_fp;\n export type_is_integral;\n export type_is_native;\n@@ -877,7 +877,7 @@ fn type_is_boxed(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_is_ivec(cx: &ctxt, ty: t) -> bool {\n+fn type_is_vec(cx: &ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n       ty_vec(_) { true }\n       ty_istr. { true }"}, {"sha": "91ab6c2026a03ad7ce05fdd91d4f499d87d14a11", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -19,7 +19,7 @@ mod middle {\n     mod trans;\n     mod trans_alt;\n     mod trans_objects;\n-    mod trans_ivec;\n+    mod trans_vec;\n     mod ty;\n     mod ast_map;\n     mod resolve;"}, {"sha": "a6d04451ba155dd9a4164d945d4876ecdd78825f", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785c26f7f4490abb19f95035fcb7e9e57ee6556c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=785c26f7f4490abb19f95035fcb7e9e57ee6556c", "patch": "@@ -301,9 +301,9 @@ tag ty_ {\n     ty_float;\n     ty_machine(ty_mach);\n     ty_char;\n-    ty_istr; // interior string\n+    ty_istr;\n     ty_box(mt);\n-    ty_vec(mt); // interior vector\n+    ty_vec(mt);\n     ty_ptr(mt);\n     ty_task;\n     ty_port(@ty);"}]}