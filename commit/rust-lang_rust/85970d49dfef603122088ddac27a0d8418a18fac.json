{"sha": "85970d49dfef603122088ddac27a0d8418a18fac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTcwZDQ5ZGZlZjYwMzEyMjA4OGRkYWMyN2EwZDg0MThhMThmYWM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-05T00:52:57Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-12-29T12:55:25Z"}, "message": "Intern Region in tcx.\n\nThis makes sty only 32 bytes on machines with 64-bit pointers.", "tree": {"sha": "20c1cbe131cd779a04ed76f13896efbb38c5767d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20c1cbe131cd779a04ed76f13896efbb38c5767d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85970d49dfef603122088ddac27a0d8418a18fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85970d49dfef603122088ddac27a0d8418a18fac", "html_url": "https://github.com/rust-lang/rust/commit/85970d49dfef603122088ddac27a0d8418a18fac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85970d49dfef603122088ddac27a0d8418a18fac/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add6bb2f2dc764865ee3ea4c2713d7655f2e72db", "url": "https://api.github.com/repos/rust-lang/rust/commits/add6bb2f2dc764865ee3ea4c2713d7655f2e72db", "html_url": "https://github.com/rust-lang/rust/commit/add6bb2f2dc764865ee3ea4c2713d7655f2e72db"}], "stats": {"total": 164, "additions": 93, "deletions": 71}, "files": [{"sha": "9b008f36a9646fcf9c9d5227a0732ba2e08b225f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -432,7 +432,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       '&' => {\n         let r = parse_region(st, |x,y| conv(x,y));\n         let mt = parse_mt(st, |x,y| conv(x,y));\n-        return ty::mk_rptr(st.tcx, r, mt);\n+        return ty::mk_rptr(st.tcx, st.tcx.mk_region(r), mt);\n       }\n       'V' => {\n         let t = parse_ty(st, |x,y| conv(x,y));\n@@ -500,7 +500,8 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n           let region = parse_region(st, |x,y| conv(x,y));\n           let substs = parse_substs(st, |x,y| conv(x,y));\n           assert_eq!(next(st), ']');\n-          return ty::mk_unboxed_closure(st.tcx, did, region, st.tcx.mk_substs(substs));\n+          return ty::mk_unboxed_closure(st.tcx, did,\n+                  st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n       }\n       'e' => {\n           return ty::mk_err();"}, {"sha": "1dfd602794f80fdcbf29cef8a924ce097332af85", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -861,7 +861,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n-                                         r, bk, AutoRef);\n+                                         *r, bk, AutoRef);\n                 }\n             }\n         }"}, {"sha": "48e16c4bfa1d4e3adba1f28299b44dbfe428e3c4", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -230,7 +230,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         let a_borrowed = ty::mk_rptr(self.tcx(),\n-                                     r_borrow,\n+                                     self.tcx().mk_region(r_borrow),\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n \n@@ -271,7 +271,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let coercion = Coercion(self.get_ref().trace.clone());\n                             let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.tcx(),\n-                                                 r_borrow,\n+                                                 self.tcx().mk_region(r_borrow),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n                             try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n@@ -424,7 +424,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         self.coerce_object(a, b, b_mutbl,\n-                           |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           |tr| ty::mk_rptr(tcx, tcx.mk_region(r_a),\n+                                            ty::mt{ mutbl: b_mutbl, ty: tr }),\n                            || AutoPtr(r_a, b_mutbl, None))\n     }\n "}, {"sha": "2e03a9b21e5ab288e01535efcd60fa110f057531", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -499,9 +499,9 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n           // All ty_unboxed_closure types with the same id represent\n           // the (anonymous) type of the same closure expression. So\n           // all of their regions should be equated.\n-          let region = try!(this.equate().regions(a_region, b_region));\n+          let region = try!(this.equate().regions(*a_region, *b_region));\n           let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_unboxed_closure(tcx, a_id, region, tcx.mk_substs(substs)))\n+          Ok(ty::mk_unboxed_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n       }\n \n       (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n@@ -515,7 +515,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       }\n \n       (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.contraregions(a_r, b_r));\n+            let r = try!(this.contraregions(*a_r, *b_r));\n             // FIXME(14985)  If we have mutable references to trait objects, we\n             // used to use covariant subtyping. I have preserved this behaviour,\n             // even though it is probably incorrect. So don't go down the usual\n@@ -527,7 +527,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                 }\n                 _ => try!(this.mts(a_mt, b_mt))\n             };\n-            Ok(ty::mk_rptr(tcx, r, mt))\n+            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n       }\n \n       (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {"}, {"sha": "87841c7675b9168d29b6ca76595cbfe414f58203", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -204,7 +204,7 @@ pub fn opt_deref_kind(t: Ty) -> Option<deref_kind> {\n \n         ty::ty_rptr(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Some(deref_ptr(BorrowedPtr(kind, r)))\n+            Some(deref_ptr(BorrowedPtr(kind, *r)))\n         }\n \n         ty::ty_closure(box ty::ClosureTy {\n@@ -1071,7 +1071,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           -> (ast::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::ty_rptr(r, ref mt) => match mt.ty.sty {\n-                    ty::ty_vec(_, None) => (mt.mutbl, r),\n+                    ty::ty_vec(_, None) => (mt.mutbl, *r),\n                     _ => vec_slice_info(tcx, pat, mt.ty),\n                 },\n "}, {"sha": "413d70819f3eb71a060363ecd77bdc573633da56", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -410,7 +410,7 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n             },\n             &AutoPtr(r, m, Some(box ref autoref)) => {\n                 match type_of_autoref(cx, autoref) {\n-                    Some(ty) => Some(mk_rptr(cx, r, mt {mutbl: m, ty: ty})),\n+                    Some(ty) => Some(mk_rptr(cx, cx.mk_region(r), mt {mutbl: m, ty: ty})),\n                     None => None\n                 }\n             }\n@@ -609,6 +609,7 @@ pub struct CtxtArenas<'tcx> {\n     type_: TypedArena<TyS<'tcx>>,\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n+    region: TypedArena<Region>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -617,6 +618,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             type_: TypedArena::new(),\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n+            region: TypedArena::new(),\n         }\n     }\n }\n@@ -636,6 +638,7 @@ pub struct ctxt<'tcx> {\n     // FIXME as above, use a hashset if equivalent elements can be queried.\n     substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n     bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n+    region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n \n     pub sess: Session,\n     pub def_map: DefMap,\n@@ -1340,7 +1343,7 @@ pub enum sty<'tcx> {\n     ty_str,\n     ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n-    ty_rptr(Region, mt<'tcx>),\n+    ty_rptr(&'tcx Region, mt<'tcx>),\n \n     // If the def-id is Some(_), then this is the type of a specific\n     // fn item. Otherwise, if None(_), it a fn pointer type.\n@@ -1350,7 +1353,7 @@ pub enum sty<'tcx> {\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_unboxed_closure(DefId, Region, &'tcx Substs<'tcx>),\n+    ty_unboxed_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -2085,6 +2088,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         interner: RefCell::new(FnvHashMap::new()),\n         substs_interner: RefCell::new(FnvHashMap::new()),\n         bare_fn_interner: RefCell::new(FnvHashMap::new()),\n+        region_interner: RefCell::new(FnvHashMap::new()),\n         named_region_map: named_region_map,\n         item_variance_map: RefCell::new(DefIdMap::new()),\n         variance_computed: Cell::new(false),\n@@ -2164,6 +2168,16 @@ impl<'tcx> ctxt<'tcx> {\n         self.bare_fn_interner.borrow_mut().insert(bare_fn, bare_fn);\n         bare_fn\n     }\n+\n+    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n+        if let Some(region) = self.region_interner.borrow().get(&region) {\n+            return *region;\n+        }\n+\n+        let region = self.arenas.region.alloc(region);\n+        self.region_interner.borrow_mut().insert(region, region);\n+        region\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n@@ -2269,7 +2283,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_unboxed_closure(_, ref region, substs) => {\n+            &ty_unboxed_closure(_, region, substs) => {\n                 self.add_region(*region);\n                 self.add_substs(substs);\n             }\n@@ -2299,7 +2313,7 @@ impl FlagComputation {\n             }\n \n             &ty_rptr(r, ref m) => {\n-                self.add_region(r);\n+                self.add_region(*r);\n                 self.add_ty(m.ty);\n             }\n \n@@ -2404,7 +2418,7 @@ pub fn mk_str<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_str)\n }\n \n-pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, m: ast::Mutability) -> Ty<'tcx> {\n+pub fn mk_str_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, m: ast::Mutability) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_t(cx, ty_str),\n@@ -2421,14 +2435,14 @@ pub fn mk_uniq<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_un\n \n pub fn mk_ptr<'tcx>(cx: &ctxt<'tcx>, tm: mt<'tcx>) -> Ty<'tcx> { mk_t(cx, ty_ptr(tm)) }\n \n-pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+pub fn mk_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n     mk_t(cx, ty_rptr(r, tm))\n }\n \n-pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn mk_mut_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutMutable})\n }\n-pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+pub fn mk_imm_rptr<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r, mt {ty: ty, mutbl: ast::MutImmutable})\n }\n \n@@ -2448,7 +2462,7 @@ pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<uint>) -> Ty<'tcx>\n     mk_t(cx, ty_vec(ty, sz))\n }\n \n-pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: Region, tm: mt<'tcx>) -> Ty<'tcx> {\n+pub fn mk_slice<'tcx>(cx: &ctxt<'tcx>, r: &'tcx Region, tm: mt<'tcx>) -> Ty<'tcx> {\n     mk_rptr(cx, r,\n             mt {\n                 ty: mk_vec(cx, tm.ty, None),\n@@ -2512,7 +2526,7 @@ pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n }\n \n pub fn mk_unboxed_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                                region: Region, substs: &'tcx Substs<'tcx>)\n+                                region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n                                 -> Ty<'tcx> {\n     mk_t(cx, ty_unboxed_closure(closure_id, region, substs))\n }\n@@ -3087,9 +3101,10 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n             ty_rptr(r, ref mt) => {\n                 TC::ReachesFfiUnsafe | match mt.ty.sty {\n-                    ty_str => borrowed_contents(r, ast::MutImmutable),\n-                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n-                    _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(r, mt.mutbl)),\n+                    ty_str => borrowed_contents(*r, ast::MutImmutable),\n+                    ty_vec(..) => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r,\n+                                                                                      mt.mutbl)),\n+                    _ => tc_ty(cx, mt.ty, cache).reference(borrowed_contents(*r, mt.mutbl)),\n                 }\n             }\n \n@@ -3124,7 +3139,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 let upvars = unboxed_closure_upvars(cx, did, substs);\n                 TypeContents::union(upvars.as_slice(),\n                                     |f| tc_ty(cx, f.ty, cache))\n-                    | borrowed_contents(r, MutMutable)\n+                    | borrowed_contents(*r, MutMutable)\n             }\n \n             ty_tup(ref tys) => {\n@@ -3796,7 +3811,7 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n \n pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n-        ty_open(ty) => mk_rptr(cx, ReStatic, mt {ty: ty, mutbl:ast::MutImmutable}),\n+        ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n                                  ty_to_string(cx, ty))[])\n     }\n@@ -4000,7 +4015,7 @@ pub fn ty_region(tcx: &ctxt,\n                  span: Span,\n                  ty: Ty) -> Region {\n     match ty.sty {\n-        ty_rptr(r, _) => r,\n+        ty_rptr(r, _) => *r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -4206,7 +4221,7 @@ pub fn adjust_ty_for_autoref<'tcx>(cx: &ctxt<'tcx>,\n                 &Some(box ref a) => adjust_ty_for_autoref(cx, span, ty, Some(a)),\n                 &None => ty\n             };\n-            mk_rptr(cx, r, mt {\n+            mk_rptr(cx, cx.mk_region(r), mt {\n                 ty: adjusted_ty,\n                 mutbl: m\n             })\n@@ -5494,7 +5509,7 @@ pub fn unboxed_closure_upvars<'tcx>(tcx: &ctxt<'tcx>, closure_id: ast::DefId, su\n                         var_id: freevar_def_id.node,\n                         closure_expr_id: closure_id.node\n                     }].clone();\n-                    freevar_ty = mk_rptr(tcx, borrow.region, ty::mt {\n+                    freevar_ty = mk_rptr(tcx, tcx.mk_region(borrow.region), ty::mt {\n                         ty: freevar_ty,\n                         mutbl: borrow.kind.to_mutbl_lossy()\n                     });\n@@ -6348,7 +6363,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n     walk_ty(ty, |ty| {\n         match ty.sty {\n             ty_rptr(region, _) => {\n-                accumulator.push(region)\n+                accumulator.push(*region)\n             }\n             ty_trait(ref t) => {\n                 accumulator.push_all(t.principal.substs().regions().as_slice());\n@@ -6363,7 +6378,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                     UniqTraitStore => {}\n                 }\n             }\n-            ty_unboxed_closure(_, ref region, substs) => {\n+            ty_unboxed_closure(_, region, substs) => {\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }"}, {"sha": "7887c4e2dcee1e8fcd7034d604a647dd4f70da5d", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -401,7 +401,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             }, ty_to_string(cx, tm.ty))\n         }\n         ty_rptr(r, ref tm) => {\n-            let mut buf = region_ptr_to_string(cx, r);\n+            let mut buf = region_ptr_to_string(cx, *r);\n             buf.push_str(mt_to_string(cx, tm)[]);\n             buf\n         }"}, {"sha": "a798d09872ca2fd8b31dd9dc8e9c6616132c0e3b", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -635,7 +635,7 @@ fn bind_subslice_pat(bcx: Block,\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n     let slice_len = Sub(bcx, len, slice_len_offset);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n-                                ty::ReStatic,\n+                                bcx.tcx().mk_region(ty::ReStatic),\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n@@ -808,7 +808,9 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 ty::ty_uint(ast::TyU8) => {\n                     // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n                     // which calls memcmp().\n-                    let t = ty::mk_str_slice(cx.tcx(), ty::ReStatic, ast::MutImmutable);\n+                    let t = ty::mk_str_slice(cx.tcx(),\n+                                             cx.tcx().mk_region(ty::ReStatic),\n+                                             ast::MutImmutable);\n                     let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n                     compare_str(cx, lhs, rhs, rhs_t)"}, {"sha": "aa6ffc00a3e69d97ec31491e839253b121db504d", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -264,10 +264,10 @@ pub fn self_type_for_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let unboxed_closure = &(*unboxed_closures)[closure_id];\n     match unboxed_closure.kind {\n         ty::FnUnboxedClosureKind => {\n-            ty::mk_imm_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n+            ty::mk_imm_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnMutUnboxedClosureKind => {\n-            ty::mk_mut_rptr(ccx.tcx(), ty::ReStatic, fn_ty)\n+            ty::mk_mut_rptr(ccx.tcx(), ccx.tcx().mk_region(ty::ReStatic), fn_ty)\n         }\n         ty::FnOnceUnboxedClosureKind => fn_ty\n     }\n@@ -2599,14 +2599,14 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n                     attrs.arg(idx, llvm::ReadOnlyAttribute);\n                 }\n \n-                if let ReLateBound(_, BrAnon(_)) = b {\n+                if let ReLateBound(_, BrAnon(_)) = *b {\n                     attrs.arg(idx, llvm::NoCaptureAttribute);\n                 }\n             }\n \n             // When a reference in an argument has no named lifetime, it's impossible for that\n             // reference to escape this function (returned or stored beyond the call by a closure).\n-            ty::ty_rptr(ReLateBound(_, BrAnon(_)), mt) => {\n+            ty::ty_rptr(&ReLateBound(_, BrAnon(_)), mt) => {\n                 let llsz = llsize_of_real(ccx, type_of::type_of(ccx, mt.ty));\n                 attrs.arg(idx, llvm::NoCaptureAttribute)\n                      .arg(idx, llvm::DereferenceableAttribute(llsz));"}, {"sha": "ca34b10e394d7282c1776dfb2bbe9f22c5f632b6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -2130,7 +2130,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Compute final type. Note that we are loose with the region and\n     // mutability, since those things don't matter in trans.\n     let referent_ty = lv_datum.ty;\n-    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), ty::ReStatic, referent_ty);\n+    let ptr_ty = ty::mk_imm_rptr(bcx.tcx(), bcx.tcx().mk_region(ty::ReStatic), referent_ty);\n \n     // Get the pointer.\n     let llref = lv_datum.to_llref();"}, {"sha": "81e6ec4df562714010173f4ee0f3fc91f19e3d37", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -940,7 +940,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 let r = opt_ast_region_to_region(this, rscope, ast_ty.span, region);\n                 debug!(\"ty_rptr r={}\", r.repr(this.tcx()));\n                 let t = ast_ty_to_ty(this, rscope, &*mt.ty);\n-                ty::mk_rptr(tcx, r, ty::mt {ty: t, mutbl: mt.mutbl})\n+                ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty: t, mutbl: mt.mutbl})\n             }\n             ast::TyTup(ref fields) => {\n                 let flds = fields.iter()\n@@ -1218,7 +1218,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(ty::mk_rptr(this.tcx(),\n-                                      region,\n+                                      this.tcx().mk_region(region),\n                                       ty::mt {\n                                         ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability\n@@ -1351,7 +1351,7 @@ fn determine_explicit_self_category<'a, 'tcx, AC: AstConv<'tcx>,\n                 ty::ByValueExplicitSelfCategory\n             } else {\n                 match explicit_type.sty {\n-                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n+                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(*r, mt.mutbl),\n                     ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n                     _ => ty::ByValueExplicitSelfCategory,\n                 }"}, {"sha": "09a5dd521f882de6dd28dc4c881bf6fdc7e8ab9d", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -93,7 +93,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     // and T is the expected type\n                     let region_var = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::mt { ty: expected, mutbl: mutbl };\n-                    let region_ty = ty::mk_rptr(tcx, region_var, mt);\n+                    let region_ty = ty::mk_rptr(tcx, tcx.mk_region(region_var), mt);\n                     demand::eqtype(fcx, pat.span, region_ty, typ);\n                 }\n                 // otherwise the type of x is the expected type T\n@@ -154,7 +154,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-            let rptr_ty = ty::mk_rptr(tcx, region, mt);\n+            let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);\n \n             if check_dereferencable(pcx, pat.span, expected, &**inner) {\n                 demand::suptype(fcx, pat.span, expected, rptr_ty);\n@@ -178,7 +178,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 })),\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n-                    ty::mk_slice(tcx, region, ty::mt {\n+                    ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                         ty: inner_ty,\n                         mutbl: ty::deref(expected_ty, true)\n                             .map_or(ast::MutImmutable, |mt| mt.mutbl)\n@@ -197,7 +197,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 let mutbl = ty::deref(expected_ty, true)\n                     .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n-                let slice_ty = ty::mk_slice(tcx, region, ty::mt {\n+                let slice_ty = ty::mk_slice(tcx, tcx.mk_region(region), ty::mt {\n                     ty: inner_ty,\n                     mutbl: mutbl\n                 });"}, {"sha": "c8a8a0ff55908b07ea0615417d53a2d4cdf7aadb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -126,7 +126,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     let closure_type = ty::mk_unboxed_closure(fcx.ccx.tcx,\n                                               expr_def_id,\n-                                              region,\n+                                              fcx.ccx.tcx.mk_region(region),\n                                               fcx.ccx.tcx.mk_substs(\n                                                   fcx.inh.param_env.free_substs.clone()));\n "}, {"sha": "65ee44db77c441bfc07442f127d6f9a389646d31", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -259,7 +259,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                 span,\n                                 ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n-                                    autoref: Some(ty::AutoPtr(region, mutbl, autoref))\n+                                    autoref: Some(ty::AutoPtr(*region, mutbl, autoref))\n                                 }));\n                         }\n "}, {"sha": "ee6366b8b4e313c19a88bde75f80e255863f37ee", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -657,7 +657,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let tcx = self.tcx();\n         self.search_mutabilities(\n             |m| AutoRef(m, box step.adjustment.clone()),\n-            |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:step.self_ty, mutbl:m}))\n+            |m,r| ty::mk_rptr(tcx, tcx.mk_region(r), ty::mt {ty:step.self_ty, mutbl:m}))\n     }\n \n     fn search_mutabilities<F, G>(&mut self,"}, {"sha": "70276305c38ab26d3cb3ba98399c368db5b09995", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -2736,9 +2736,10 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_str_slice(tcx, ty::ReStatic, ast::MutImmutable),\n+        ast::LitStr(..) => ty::mk_str_slice(tcx, tcx.mk_region(ty::ReStatic), ast::MutImmutable),\n         ast::LitBinary(..) => {\n-            ty::mk_slice(tcx, ty::ReStatic, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n+            ty::mk_slice(tcx, tcx.mk_region(ty::ReStatic),\n+                         ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable })\n         }\n         ast::LitByte(_) => ty::mk_u8(),\n         ast::LitChar(_) => ty::mk_char(),\n@@ -3098,8 +3099,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let (adj_ty, adjustment) = match lhs_ty.sty {\n                     ty::ty_rptr(r_in, mt) => {\n                         let r_adj = fcx.infcx().next_region_var(infer::Autoref(lhs.span));\n-                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, r_in);\n-                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), r_adj, mt);\n+                        fcx.mk_subr(infer::Reborrow(lhs.span), r_adj, *r_in);\n+                        let adjusted_ty = ty::mk_rptr(fcx.tcx(), fcx.tcx().mk_region(r_adj), mt);\n                         let autoptr = ty::AutoPtr(r_adj, mt.mutbl, None);\n                         let adjustment = ty::AutoDerefRef { autoderefs: 1, autoref: Some(autoptr) };\n                         (adjusted_ty, adjustment)\n@@ -3839,11 +3840,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     // `'static`!\n                     let region = fcx.infcx().next_region_var(\n                         infer::AddrOfSlice(expr.span));\n-                    ty::mk_rptr(tcx, region, tm)\n+                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n                 }\n                 _ => {\n                     let region = fcx.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n-                    ty::mk_rptr(tcx, region, tm)\n+                    ty::mk_rptr(tcx, tcx.mk_region(region), tm)\n                 }\n             }\n         };\n@@ -5568,7 +5569,9 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx, ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(0)),\n+                    ty::mk_mut_rptr(tcx,\n+                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n                                     param(ccx, 0)),\n                     param(ccx, 0)\n                   ),"}, {"sha": "b8cf215f89eeca4e57dc9a66409c7a8df54d96a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -645,7 +645,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             };\n             if let ty::ty_rptr(r_ptr, _) = base_ty.sty {\n                 mk_subregion_due_to_dereference(\n-                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), r_ptr);\n+                    rcx, expr.span, ty::ReScope(CodeExtent::from_node_id(expr.id)), *r_ptr);\n             }\n \n             visit::walk_expr(rcx, expr);\n@@ -763,7 +763,7 @@ fn constrain_cast(rcx: &mut Rcx,\n             /*From:*/ (&ty::ty_rptr(from_r, ref from_mt),\n             /*To:  */  &ty::ty_rptr(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), to_r, from_r);\n+                rcx.fcx.mk_subr(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n                 walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -822,7 +822,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                         // Variables being referenced must be constrained and registered\n                         // in the upvar borrow map\n                         constrain_free_variables_in_by_ref_closure(\n-                            rcx, region, expr, freevars);\n+                            rcx, *region, expr, freevars);\n                     }\n                 })\n             }\n@@ -858,7 +858,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         }\n         ty::ty_unboxed_closure(_, region, _) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n-                let bounds = ty::region_existential_bound(region);\n+                let bounds = ty::region_existential_bound(*region);\n                 ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n             })\n         }\n@@ -897,7 +897,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().get(&upvar_id) {\n                 Some(upvar_borrow) => {\n                     ty::mk_rptr(rcx.tcx(),\n-                                upvar_borrow.region,\n+                                rcx.tcx().mk_region(upvar_borrow.region),\n                                 ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n                                          ty: raw_var_ty })\n                 }\n@@ -1137,7 +1137,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n                     let self_cmt = mc.cat_expr_autoderefd(deref_expr, i);\n-                    link_region(rcx, deref_expr.span, r,\n+                    link_region(rcx, deref_expr.span, *r,\n                                 ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n@@ -1158,7 +1158,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n         if let ty::ty_rptr(r_ptr, _) =  derefd_ty.sty {\n             mk_subregion_due_to_dereference(rcx, deref_expr.span,\n-                                            r_deref_expr, r_ptr);\n+                                            r_deref_expr, *r_ptr);\n         }\n \n         match ty::deref(derefd_ty, true) {\n@@ -1193,7 +1193,7 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         match mt.ty.sty {\n             ty::ty_vec(_, None) | ty::ty_str => {\n                 rcx.fcx.mk_subr(infer::IndexSlice(index_expr.span),\n-                                r_index_expr, r_ptr);\n+                                r_index_expr, *r_ptr);\n             }\n             _ => {}\n         }"}, {"sha": "ea70b9d9e2ef16f75028211b42cbbca4ef2c1feb", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                 // captured by reference it must also outlive the\n                 // region bound on the closure, but this is explicitly\n                 // handled by logic in regionck.\n-                self.push_region_constraint_from_top(region);\n+                self.push_region_constraint_from_top(*region);\n             }\n \n             ty::ty_trait(ref t) => {\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             }\n \n             ty::ty_rptr(r_b, mt) => {\n-                self.accumulate_from_rptr(ty, r_b, mt.ty);\n+                self.accumulate_from_rptr(ty, *r_b, mt.ty);\n             }\n \n             ty::ty_param(p) => {"}, {"sha": "e348a509c0c6f76ab9b87e4a8a3c90166f5554c3", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -63,8 +63,8 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // Ensure that if &'a T is cast to &'b Trait, then 'b <= 'a\n                 infer::mk_subr(fcx.infcx(),\n                                infer::RelateObjectBound(source_expr.span),\n-                               target_region,\n-                               referent_region);\n+                               *target_region,\n+                               *referent_region);\n \n                 check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }"}, {"sha": "bdd8c7c3da7c011b444af8df51793e4d6d46885d", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85970d49dfef603122088ddac27a0d8418a18fac/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=85970d49dfef603122088ddac27a0d8418a18fac", "patch": "@@ -732,7 +732,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_rptr(region, ref mt) => {\n                 let contra = self.contravariant(variance);\n-                self.add_constraints_from_region(region, contra);\n+                self.add_constraints_from_region(*region, contra);\n                 self.add_constraints_from_mt(mt, variance);\n             }\n "}]}