{"sha": "13efb20846dc3b3916e44c67ebd4141a39c54d9b", "node_id": "C_kwDOAAsO6NoAKDEzZWZiMjA4NDZkYzNiMzkxNmU0NGM2N2ViZDQxNDFhMzljNTRkOWI", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-11-15T09:19:17Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2022-11-15T13:50:20Z"}, "message": "add tool to collect license metadata from REUSE", "tree": {"sha": "3ef37499d0a38f01b07bf86f7e09d430ba4344a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ef37499d0a38f01b07bf86f7e09d430ba4344a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13efb20846dc3b3916e44c67ebd4141a39c54d9b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmNzmRwACgkQzXazX3c0\ndp7IVRAAg6bqmgrrEw6yJO/+DfqeLnIdkPNo5gEA4kHRfVjSGDPCw129+Y5iJheO\n9engEACv3/4Qq/VhMLknsvSp+dQ/dnb2P09aDuxe6jqG/BD9wB/QRWr0a4qQ5u5P\nlCFJJumb0od9gSRgiEjE9pfpRs1OTPdjzKinT9zHkoB2GA3kIpytsj2sHeVo1/rm\nDVRIBB48IHylEJxf0W693VFotRqgXwiQmSM8JkXf+iyhM3VeUu3A4PsD+R4kFFal\nFJsnvGpEObWXnxXNhLbsXQs2g2ZadnkNDVBzBiAqoWgOXBMyMiv6jxtOkzxVdF/w\np+axD3MChKnOIGri1+PirA52JlunBUy+7oM3+xui3pEH46mTdQz61/cB4Zmix+bS\nmoL3HeVSQz0xqYGvI50N31/ZCK3vKoxMlYn5hmWSuUVl7Bn9nq2Y5RzXL8010gae\nmfgJ1aXBwzYZf7qO+9qJZz3S/MzGImlzhyxwB58neJ8oHTjVfdVQCvnmIkPPjxaJ\nE44eN+UDYBDQBxNvxuvhK9AHnPRIdJwAiERZz8JrYzGlJ8n5scNiG/VaYQkb1Szw\n+mApGtoPkpw3rLNZwixmmv/SSbFsoLoY5jcqqlZvYuEIX+HuetH/b4+UGAbKERZA\nLRYjMTdZlnX3O0VJMc7otkHuYq4Ez5DihZPXdZwb+UPSQUpsPQk=\n=ORBO\n-----END PGP SIGNATURE-----", "payload": "tree 3ef37499d0a38f01b07bf86f7e09d430ba4344a0\nparent 17ee25d77550b771200d73533e3bcb2a9959122d\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1668503957 +0100\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1668520220 +0100\n\nadd tool to collect license metadata from REUSE\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13efb20846dc3b3916e44c67ebd4141a39c54d9b", "html_url": "https://github.com/rust-lang/rust/commit/13efb20846dc3b3916e44c67ebd4141a39c54d9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13efb20846dc3b3916e44c67ebd4141a39c54d9b/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ee25d77550b771200d73533e3bcb2a9959122d", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ee25d77550b771200d73533e3bcb2a9959122d", "html_url": "https://github.com/rust-lang/rust/commit/17ee25d77550b771200d73533e3bcb2a9959122d"}], "stats": {"total": 522, "additions": 522, "deletions": 0}, "files": [{"sha": "eadaf721f0210fdfcfdad5da88750a3eacc5f20b", "filename": "Cargo.lock", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -563,6 +563,7 @@ dependencies = [\n  \"libc\",\n  \"num-integer\",\n  \"num-traits\",\n+ \"serde\",\n  \"time\",\n  \"winapi\",\n ]\n@@ -712,6 +713,16 @@ dependencies = [\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"spdx-rs\",\n+]\n+\n [[package]]\n name = \"color-eyre\"\n version = \"0.6.2\"\n@@ -4628,6 +4639,35 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"spdx-expression\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53d7ac03c67c572d85049d6db815e20a4a19b41b3d5cca732ac582342021ad77\"\n+dependencies = [\n+ \"nom\",\n+ \"serde\",\n+ \"thiserror\",\n+ \"tracing\",\n+]\n+\n+[[package]]\n+name = \"spdx-rs\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3c02f6eb7e7b4100c272f685a9ccaccaab302324e8c7ec3e2ee72340fb29ff3\"\n+dependencies = [\n+ \"chrono\",\n+ \"log\",\n+ \"nom\",\n+ \"serde\",\n+ \"spdx-expression\",\n+ \"strum\",\n+ \"strum_macros\",\n+ \"thiserror\",\n+ \"uuid\",\n+]\n+\n [[package]]\n name = \"stable_deref_trait\"\n version = \"1.2.0\"\n@@ -4731,6 +4771,25 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n+[[package]]\n+name = \"strum\"\n+version = \"0.24.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"063e6045c0e62079840579a7e47a355ae92f60eb74daaf156fb1e84ba164e63f\"\n+\n+[[package]]\n+name = \"strum_macros\"\n+version = \"0.24.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e385be0d24f186b4ce2f9982191e7101bb737312ad61c1f2f984f34bcf85d59\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.102\"\n@@ -5357,6 +5416,15 @@ version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8772a4ccbb4e89959023bc5b7cb8623a795caa7092d99f3aa9501b9484d4557d\"\n \n+[[package]]\n+name = \"uuid\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc5cf98d8186244414c848017f0e2676b3fcb46807f6668a97dfe67359a3c4b7\"\n+dependencies = [\n+ \"getrandom 0.2.0\",\n+]\n+\n [[package]]\n name = \"valuable\"\n version = \"0.1.0\""}, {"sha": "ddaf9b41f860a2c4bc64dedc0558df6db8fcf607", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -39,6 +39,7 @@ members = [\n   \"src/tools/bump-stage0\",\n   \"src/tools/replace-version-placeholder\",\n   \"src/tools/lld-wrapper\",\n+  \"src/tools/collect-license-metadata\",\n ]\n \n exclude = ["}, {"sha": "803b1c266f3c08669cd4deacfd381adbd54f13ca", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -753,6 +753,7 @@ impl<'a> Builder<'a> {\n                 run::BumpStage0,\n                 run::ReplaceVersionPlaceholder,\n                 run::Miri,\n+                run::CollectLicenseMetadata,\n             ),\n             // These commands either don't use paths, or they're special-cased in Build::build()\n             Kind::Clean | Kind::Format | Kind::Setup => vec![],"}, {"sha": "8cbfe3ebab555e6a1c82bd803a01ba91ef98f4b4", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -1,3 +1,4 @@\n+use std::path::PathBuf;\n use std::process::Command;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -189,3 +190,35 @@ impl Step for Miri {\n         builder.run(&mut miri);\n     }\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct CollectLicenseMetadata;\n+\n+impl Step for CollectLicenseMetadata {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/collect-license-metadata\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(CollectLicenseMetadata);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> Self::Output {\n+        let Some(reuse) = &builder.config.reuse else {\n+            panic!(\"REUSE is required to collect the license metadata\");\n+        };\n+\n+        // Temporary location, it will be moved to src/etc once it's accurate.\n+        let dest = builder.out.join(\"license-metadata.json\");\n+\n+        let mut cmd = builder.tool_cmd(Tool::CollectLicenseMetadata);\n+        cmd.env(\"REUSE_EXE\", reuse);\n+        cmd.env(\"DEST\", &dest);\n+        builder.run(&mut cmd);\n+\n+        dest\n+    }\n+}"}, {"sha": "4dd9a40dcb3c3865e526b4fc0c90368c66c2d492", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -380,6 +380,7 @@ bootstrap_tool!(\n     HtmlChecker, \"src/tools/html-checker\", \"html-checker\";\n     BumpStage0, \"src/tools/bump-stage0\", \"bump-stage0\";\n     ReplaceVersionPlaceholder, \"src/tools/replace-version-placeholder\", \"replace-version-placeholder\";\n+    CollectLicenseMetadata, \"src/tools/collect-license-metadata\", \"collect-license-metadata\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "d0820cfc2a0e46b1b1919337824ea24c7b17ea51", "filename": "src/tools/collect-license-metadata/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2FCargo.toml?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"collect-license-metadata\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+[dependencies]\n+anyhow = \"1.0.65\"\n+serde = { version = \"1.0.147\", features = [\"derive\"] }\n+serde_json = \"1.0.85\"\n+spdx-rs = \"0.5.1\""}, {"sha": "34aabc87301498f31848979f3464ef8c16812370", "filename": "src/tools/collect-license-metadata/src/licenses.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Flicenses.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -0,0 +1,37 @@\n+use std::collections::HashMap;\n+\n+pub(crate) struct LicensesInterner {\n+    by_id: Vec<License>,\n+    by_struct: HashMap<License, usize>,\n+}\n+\n+impl LicensesInterner {\n+    pub(crate) fn new() -> Self {\n+        LicensesInterner { by_id: Vec::new(), by_struct: HashMap::new() }\n+    }\n+\n+    pub(crate) fn intern(&mut self, license: License) -> LicenseId {\n+        if let Some(id) = self.by_struct.get(&license) {\n+            LicenseId(*id)\n+        } else {\n+            let id = self.by_id.len();\n+            self.by_id.push(license.clone());\n+            self.by_struct.insert(license, id);\n+            LicenseId(id)\n+        }\n+    }\n+\n+    pub(crate) fn resolve(&self, id: LicenseId) -> &License {\n+        &self.by_id[id.0]\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize)]\n+#[serde(transparent)]\n+pub(crate) struct LicenseId(usize);\n+\n+#[derive(Clone, Hash, PartialEq, Eq, serde::Serialize)]\n+pub(crate) struct License {\n+    pub(crate) spdx: String,\n+    pub(crate) copyright: Vec<String>,\n+}"}, {"sha": "0864408fd53459e3c0d0de576f7120cae96fe47e", "filename": "src/tools/collect-license-metadata/src/main.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fmain.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -0,0 +1,30 @@\n+mod licenses;\n+mod path_tree;\n+mod reuse;\n+\n+use crate::licenses::LicensesInterner;\n+use anyhow::Error;\n+use std::path::PathBuf;\n+\n+fn main() -> Result<(), Error> {\n+    let reuse_exe: PathBuf = std::env::var_os(\"REUSE_EXE\").expect(\"Missing REUSE_EXE\").into();\n+    let dest: PathBuf = std::env::var_os(\"DEST\").expect(\"Missing DEST\").into();\n+\n+    let mut interner = LicensesInterner::new();\n+    let paths = crate::reuse::collect(&reuse_exe, &mut interner)?;\n+\n+    let mut tree = crate::path_tree::build(paths);\n+    tree.simplify();\n+\n+    if let Some(parent) = dest.parent() {\n+        std::fs::create_dir_all(parent)?;\n+    }\n+    std::fs::write(\n+        &dest,\n+        &serde_json::to_vec_pretty(&serde_json::json!({\n+            \"files\": crate::path_tree::strip_interning(tree, &interner),\n+        }))?,\n+    )?;\n+\n+    Ok(())\n+}"}, {"sha": "6278970d813658111f94210922856fa067b8df25", "filename": "src/tools/collect-license-metadata/src/path_tree.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Fpath_tree.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -0,0 +1,292 @@\n+//! Tools like REUSE output per-file licensing information, but we need to condense it in the\n+//! minimum amount of data that still represents the same licensing metadata. This module is\n+//! responsible for that, by turning the list of paths into a tree and executing simplification\n+//! passes over the tree to remove redundant information.\n+\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use std::collections::BTreeMap;\n+use std::path::{Path, PathBuf};\n+\n+#[derive(serde::Serialize)]\n+#[serde(rename_all = \"kebab-case\", tag = \"type\")]\n+pub(crate) enum Node<L> {\n+    Root { childs: Vec<Node<L>> },\n+    Directory { name: PathBuf, childs: Vec<Node<L>>, license: Option<L> },\n+    File { name: PathBuf, license: L },\n+    FileGroup { names: Vec<PathBuf>, license: L },\n+    Empty,\n+}\n+\n+impl Node<LicenseId> {\n+    pub(crate) fn simplify(&mut self) {\n+        self.merge_directories();\n+        self.collapse_in_licensed_directories();\n+        self.merge_directory_licenses();\n+        self.merge_file_groups();\n+        self.remove_empty();\n+    }\n+\n+    /// Initially, trees are built by the build() function with each file practically having a\n+    /// separate directory tree, like so:\n+    ///\n+    /// ```text\n+    ///         \u250c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///         \u2502\n+    /// <root> \u2500\u253c\u2500\u25ba ./ \u2500\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u25ba Cargo.toml\n+    ///         \u2502\n+    ///         \u2514\u2500\u25ba ./ \u2500\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    ///\n+    /// This pass is responsible for turning that into a proper directory tree:\n+    ///\n+    /// ```text\n+    ///                 \u250c\u2500\u25ba compiler/ \u2500\u2500\u25ba rustc/ \u2500\u2500\u252c\u2500\u25ba src/ \u2500\u2500\u25ba main.rs\n+    ///                 \u2502                          \u2502\n+    /// <root> \u2500\u2500\u25ba ./ \u2500\u2500\u2524                          \u2514\u2500\u25ba Cargo.toml\n+    ///                 \u2502\n+    ///                 \u2514\u2500\u25ba library/ \u2500\u2500\u2500\u25ba std/ \u2500\u2500\u25ba Cargo.toml\n+    /// ```\n+    fn merge_directories(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, license: None, .. } => {\n+                let mut directories = BTreeMap::new();\n+                let mut files = Vec::new();\n+\n+                for child in childs.drain(..) {\n+                    match child {\n+                        Node::Directory { name, mut childs, license: None } => {\n+                            directories.entry(name).or_insert_with(Vec::new).append(&mut childs);\n+                        }\n+                        file @ Node::File { .. } => {\n+                            files.push(file);\n+                        }\n+                        Node::Empty => {}\n+                        Node::Root { .. } => {\n+                            panic!(\"can't have a root inside another element\");\n+                        }\n+                        Node::FileGroup { .. } => {\n+                            panic!(\"FileGroup should not be present at this stage\");\n+                        }\n+                        Node::Directory { license: Some(_), .. } => {\n+                            panic!(\"license should not be set at this stage\");\n+                        }\n+                    }\n+                }\n+\n+                childs.extend(directories.into_iter().map(|(name, childs)| Node::Directory {\n+                    name,\n+                    childs,\n+                    license: None,\n+                }));\n+                childs.append(&mut files);\n+\n+                for child in &mut *childs {\n+                    child.merge_directories();\n+                }\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {\n+                panic!(\"FileGroup should not be present at this stage\");\n+            }\n+            Node::Directory { license: Some(_), .. } => {\n+                panic!(\"license should not be set at this stage\");\n+            }\n+        }\n+    }\n+\n+    /// In our codebase, most files in a directory have the same license as the other files in that\n+    /// same directory, so it's redundant to store licensing metadata for all the files. Instead,\n+    /// we can add a license for a whole directory, and only record the exceptions to a directory\n+    /// licensing metadata.\n+    ///\n+    /// We cannot instead record only the difference to Rust's standard licensing, as the majority\n+    /// of the files in our repository are *not* licensed under Rust's standard licensing due to\n+    /// our inclusion of LLVM.\n+    fn collapse_in_licensed_directories(&mut self) {\n+        match self {\n+            Node::Directory { childs, license, .. } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+\n+                let mut licenses_count = BTreeMap::new();\n+                for child in &*childs {\n+                    let Some(license) = child.license() else { continue };\n+                    *licenses_count.entry(license).or_insert(0) += 1;\n+                }\n+\n+                let most_popular_license = licenses_count\n+                    .into_iter()\n+                    .max_by_key(|(_, count)| *count)\n+                    .map(|(license, _)| license);\n+\n+                if let Some(most_popular_license) = most_popular_license {\n+                    childs.retain(|child| child.license() != Some(most_popular_license));\n+                    *license = Some(most_popular_license);\n+                }\n+            }\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.collapse_in_licensed_directories();\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Reduce the depth of the tree by merging subdirectories with the same license as their\n+    /// parent directory into their parent, and adjusting the paths of the childs accordingly.\n+    fn merge_directory_licenses(&mut self) {\n+        match self {\n+            Node::Root { childs } => {\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+                }\n+            }\n+            Node::Directory { childs, license, .. } => {\n+                let mut to_add = Vec::new();\n+                for child in &mut *childs {\n+                    child.merge_directory_licenses();\n+\n+                    let Node::Directory {\n+                        name: child_name,\n+                        childs: child_childs,\n+                        license: child_license,\n+                    } = child else { continue };\n+\n+                    if child_license != license {\n+                        continue;\n+                    }\n+                    for mut child_child in child_childs.drain(..) {\n+                        match &mut child_child {\n+                            Node::Root { .. } => {\n+                                panic!(\"can't have a root inside another element\");\n+                            }\n+                            Node::FileGroup { .. } => {\n+                                panic!(\"FileGroup should not be present at this stage\");\n+                            }\n+                            Node::Directory { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::File { name: child_child_name, .. } => {\n+                                *child_child_name = child_name.join(&child_child_name);\n+                            }\n+                            Node::Empty => {}\n+                        }\n+                        to_add.push(child_child);\n+                    }\n+\n+                    *child = Node::Empty;\n+                }\n+                childs.append(&mut to_add);\n+            }\n+            Node::Empty => {}\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => {}\n+        }\n+    }\n+\n+    /// This pass groups multiple files in a directory with the same license into a single\n+    /// \"FileGroup\", so that the license of all those files can be reported as a group.\n+    ///\n+    /// Crucially this pass runs after collapse_in_licensed_directories, so the most common license\n+    /// will already be marked as the directory's license and won't be turned into a group.\n+    fn merge_file_groups(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                let mut grouped = BTreeMap::new();\n+\n+                for child in &mut *childs {\n+                    child.merge_file_groups();\n+                    if let Node::File { name, license } = child {\n+                        grouped.entry(*license).or_insert_with(Vec::new).push(name.clone());\n+                        *child = Node::Empty;\n+                    }\n+                }\n+\n+                for (license, mut names) in grouped.into_iter() {\n+                    if names.len() == 1 {\n+                        childs.push(Node::File { license, name: names.pop().unwrap() });\n+                    } else {\n+                        childs.push(Node::FileGroup { license, names });\n+                    }\n+                }\n+            }\n+            Node::File { .. } => {}\n+            Node::FileGroup { .. } => panic!(\"FileGroup should not be present at this stage\"),\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    /// Some nodes were replaced with Node::Empty to mark them for deletion. As the last step, make\n+    /// sure to remove them from the tree.\n+    fn remove_empty(&mut self) {\n+        match self {\n+            Node::Root { childs } | Node::Directory { childs, .. } => {\n+                for child in &mut *childs {\n+                    child.remove_empty();\n+                }\n+                childs.retain(|child| !matches!(child, Node::Empty));\n+            }\n+            Node::FileGroup { .. } => {}\n+            Node::File { .. } => {}\n+            Node::Empty => {}\n+        }\n+    }\n+\n+    fn license(&self) -> Option<LicenseId> {\n+        match self {\n+            Node::Directory { childs, license: Some(license), .. } if childs.is_empty() => {\n+                Some(*license)\n+            }\n+            Node::File { license, .. } => Some(*license),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(crate) fn build(mut input: Vec<(PathBuf, LicenseId)>) -> Node<LicenseId> {\n+    let mut childs = Vec::new();\n+\n+    // Ensure reproducibility of all future steps.\n+    input.sort();\n+\n+    for (path, license) in input {\n+        let mut node = Node::File { name: path.file_name().unwrap().into(), license };\n+        for component in path.parent().unwrap_or_else(|| Path::new(\".\")).components().rev() {\n+            node = Node::Directory {\n+                name: component.as_os_str().into(),\n+                childs: vec![node],\n+                license: None,\n+            };\n+        }\n+\n+        childs.push(node);\n+    }\n+\n+    Node::Root { childs }\n+}\n+\n+pub(crate) fn strip_interning(\n+    node: Node<LicenseId>,\n+    interner: &LicensesInterner,\n+) -> Node<&License> {\n+    match node {\n+        Node::Root { childs } => Node::Root {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+        },\n+        Node::Directory { name, childs, license } => Node::Directory {\n+            childs: childs.into_iter().map(|child| strip_interning(child, interner)).collect(),\n+            license: license.map(|license| interner.resolve(license)),\n+            name,\n+        },\n+        Node::File { name, license } => Node::File { name, license: interner.resolve(license) },\n+        Node::FileGroup { names, license } => {\n+            Node::FileGroup { names, license: interner.resolve(license) }\n+        }\n+        Node::Empty => Node::Empty,\n+    }\n+}"}, {"sha": "d6b3772ba5159a9e4debcbdcecfdb20d05596668", "filename": "src/tools/collect-license-metadata/src/reuse.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efb20846dc3b3916e44c67ebd4141a39c54d9b/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcollect-license-metadata%2Fsrc%2Freuse.rs?ref=13efb20846dc3b3916e44c67ebd4141a39c54d9b", "patch": "@@ -0,0 +1,49 @@\n+use crate::licenses::{License, LicenseId, LicensesInterner};\n+use anyhow::Error;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, Stdio};\n+use std::time::Instant;\n+\n+pub(crate) fn collect(\n+    reuse_exe: &Path,\n+    interner: &mut LicensesInterner,\n+) -> Result<Vec<(PathBuf, LicenseId)>, Error> {\n+    eprintln!(\"gathering license information from REUSE\");\n+    let start = Instant::now();\n+    let raw = &obtain_spdx_document(reuse_exe)?;\n+    eprintln!(\"finished gathering the license information from REUSE in {:.2?}\", start.elapsed());\n+\n+    let document = spdx_rs::parsers::spdx_from_tag_value(&raw)?;\n+\n+    let mut result = Vec::new();\n+    for file in document.file_information {\n+        let license = interner.intern(License {\n+            spdx: file.concluded_license.to_string(),\n+            copyright: file.copyright_text.split('\\n').map(|s| s.into()).collect(),\n+        });\n+\n+        result.push((file.file_name.into(), license));\n+    }\n+\n+    Ok(result)\n+}\n+\n+fn obtain_spdx_document(reuse_exe: &Path) -> Result<String, Error> {\n+    let output = Command::new(reuse_exe)\n+        .args(&[\"spdx\", \"--add-license-concluded\", \"--creator-person=bors\"])\n+        .stdout(Stdio::piped())\n+        .spawn()?\n+        .wait_with_output()?;\n+\n+    if !output.status.success() {\n+        eprintln!();\n+        eprintln!(\"Note that Rust requires some REUSE features that might not be present in the\");\n+        eprintln!(\"release you're using. Make sure your REUSE release includes these PRs:\");\n+        eprintln!();\n+        eprintln!(\" - https://github.com/fsfe/reuse-tool/pull/623\");\n+        eprintln!();\n+        anyhow::bail!(\"collecting licensing information with REUSE failed\");\n+    }\n+\n+    Ok(String::from_utf8(output.stdout)?)\n+}"}]}