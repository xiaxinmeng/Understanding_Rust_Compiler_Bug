{"sha": "4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "node_id": "C_kwDOAAsO6NoAKDRmMzcyYjE0ZGVhNThjYmZmMWRkNzZiYjY1MWY5YzAzNWQzZjZlN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-21T06:38:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-21T06:38:49Z"}, "message": "Auto merge of #97239 - jhpratt:remove-crate-vis, r=joshtriplett\n\nRemove `crate` visibility modifier\n\nFCP to remove this syntax is just about complete in #53120. Once it completes, this should be merged ASAP to avoid merge conflicts.\n\nThe first two commits remove usage of the feature in this repository, while the last removes the feature itself.", "tree": {"sha": "950b33879d87e39f4112e562136c21191809aef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/950b33879d87e39f4112e562136c21191809aef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "html_url": "https://github.com/rust-lang/rust/commit/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b64fe953c23b7d56dd5ebf61b6dbd82b345f880", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880", "html_url": "https://github.com/rust-lang/rust/commit/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880"}, {"sha": "69702468865d582f512df31a52ac2608afe5df0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/69702468865d582f512df31a52ac2608afe5df0d", "html_url": "https://github.com/rust-lang/rust/commit/69702468865d582f512df31a52ac2608afe5df0d"}], "stats": {"total": 3954, "additions": 1902, "deletions": 2052}, "files": [{"sha": "988918b0505e0dcb2599e79cefc28b9e363760c4", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -340,7 +340,7 @@ pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n     NestedMetaItem::MetaItem(mk_word_item(ident))\n }\n \n-crate fn mk_attr_id() -> AttrId {\n+pub(crate) fn mk_attr_id() -> AttrId {\n     use std::sync::atomic::AtomicU32;\n     use std::sync::atomic::Ordering;\n "}, {"sha": "2015d635e561b83c76cb22c78a4c62733d5f8a9a", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,7 +12,6 @@\n #![feature(box_patterns)]\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(label_break_value)]\n #![feature(let_chains)]"}, {"sha": "1522d12cbf92e819a437ea98008e55f77ac00bbf", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -134,7 +134,7 @@ impl LitKind {\n         }\n     }\n \n-    crate fn may_have_suffix(self) -> bool {\n+    pub(crate) fn may_have_suffix(self) -> bool {\n         matches!(self, Integer | Float | Err)\n     }\n }"}, {"sha": "6c055645ef3e9dcc86166a95a44664e4dcc4149f", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,11 @@ use std::collections::hash_map::Entry;\n use std::fmt::Write;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_inline_asm(&mut self, sp: Span, asm: &InlineAsm) -> &'hir hir::InlineAsm<'hir> {\n+    pub(crate) fn lower_inline_asm(\n+        &mut self,\n+        sp: Span,\n+        asm: &InlineAsm,\n+    ) -> &'hir hir::InlineAsm<'hir> {\n         // Rustdoc needs to support asm! from foreign architectures: don't try\n         // lowering the register constraints in this case.\n         let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };"}, {"sha": "a01ab32c282f6c5702a05dd75b04b45c1b55ff7c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -848,7 +848,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    crate fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n+    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n         self.expr(span, hir::ExprKind::Err, AttrVec::new())\n     }\n "}, {"sha": "3dd6b4e52db3dfa4930303d9a2cc11150bb0ec41", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -30,7 +30,6 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n-#![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "e27bc7a0f472f937743d2dbc21a7c20506929586", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,11 +12,11 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, pattern: &Pat) -> &'hir hir::Pat<'hir> {\n+    pub(crate) fn lower_pat(&mut self, pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         self.arena.alloc(self.lower_pat_mut(pattern))\n     }\n \n-    crate fn lower_pat_mut(&mut self, mut pattern: &Pat) -> hir::Pat<'hir> {\n+    pub(crate) fn lower_pat_mut(&mut self, mut pattern: &Pat) -> hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n             // loop here to avoid recursion\n             let node = loop {\n@@ -290,7 +290,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Emit a friendly error for extra `..` patterns in a tuple/tuple struct/slice pattern.\n-    crate fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n+    pub(crate) fn ban_extra_rest_pat(&self, sp: Span, prev_sp: Span, ctx: &str) {\n         self.diagnostic()\n             .struct_span_err(sp, &format!(\"`..` can only be used once per {} pattern\", ctx))\n             .span_label(sp, &format!(\"can only be used once per {} pattern\", ctx))"}, {"sha": "7fc8aac5116f91f1c03909cfd49f57d34c37ef50", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,7 +15,7 @@ use smallvec::smallvec;\n use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_qpath(\n+    pub(crate) fn lower_qpath(\n         &mut self,\n         id: NodeId,\n         qself: &Option<QSelf>,\n@@ -142,7 +142,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         );\n     }\n \n-    crate fn lower_path_extra(\n+    pub(crate) fn lower_path_extra(\n         &mut self,\n         res: Res,\n         p: &Path,\n@@ -163,7 +163,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         })\n     }\n \n-    crate fn lower_path(\n+    pub(crate) fn lower_path(\n         &mut self,\n         id: NodeId,\n         p: &Path,\n@@ -174,7 +174,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.lower_path_extra(res, p, param_mode)\n     }\n \n-    crate fn lower_path_segment(\n+    pub(crate) fn lower_path_segment(\n         &mut self,\n         path_span: Span,\n         segment: &PathSegment,\n@@ -381,7 +381,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// An associated type binding `Output = $ty`.\n-    crate fn output_ty_binding(\n+    pub(crate) fn output_ty_binding(\n         &mut self,\n         span: Span,\n         ty: &'hir hir::Ty<'hir>,"}, {"sha": "79178830bf949d3f1b5f714eb063401b39136902", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,4 @@\n #![feature(associated_type_bounds)]\n-#![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n #![feature(with_negative_coherence)]\n #![recursion_limit = \"256\"]"}, {"sha": "7357ddf2134e48581a580afbc192b3f2542b3d90", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -95,7 +95,7 @@ pub struct State<'a> {\n     ann: &'a (dyn PpAnn + 'a),\n }\n \n-crate const INDENT_UNIT: isize = 4;\n+pub(crate) const INDENT_UNIT: isize = 4;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments to copy forward.\n@@ -955,8 +955,13 @@ impl<'a> State<'a> {\n         State { s: pp::Printer::new(), comments: None, ann: &NoAnn }\n     }\n \n-    crate fn commasep_cmnt<T, F, G>(&mut self, b: Breaks, elts: &[T], mut op: F, mut get_span: G)\n-    where\n+    pub(crate) fn commasep_cmnt<T, F, G>(\n+        &mut self,\n+        b: Breaks,\n+        elts: &[T],\n+        mut op: F,\n+        mut get_span: G,\n+    ) where\n         F: FnMut(&mut State<'_>, &T),\n         G: FnMut(&T) -> rustc_span::Span,\n     {\n@@ -976,7 +981,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<ast::Expr>]) {\n+    pub(crate) fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<ast::Expr>]) {\n         self.commasep_cmnt(b, exprs, |s, e| s.print_expr(e), |e| e.span)\n     }\n \n@@ -1109,7 +1114,7 @@ impl<'a> State<'a> {\n         self.print_trait_ref(&t.trait_ref)\n     }\n \n-    crate fn print_stmt(&mut self, st: &ast::Stmt) {\n+    pub(crate) fn print_stmt(&mut self, st: &ast::Stmt) {\n         self.maybe_print_comment(st.span.lo());\n         match st.kind {\n             ast::StmtKind::Local(ref loc) => {\n@@ -1164,19 +1169,19 @@ impl<'a> State<'a> {\n         self.maybe_print_trailing_comment(st.span, None)\n     }\n \n-    crate fn print_block(&mut self, blk: &ast::Block) {\n+    pub(crate) fn print_block(&mut self, blk: &ast::Block) {\n         self.print_block_with_attrs(blk, &[])\n     }\n \n-    crate fn print_block_unclosed_indent(&mut self, blk: &ast::Block) {\n+    pub(crate) fn print_block_unclosed_indent(&mut self, blk: &ast::Block) {\n         self.print_block_maybe_unclosed(blk, &[], false)\n     }\n \n-    crate fn print_block_with_attrs(&mut self, blk: &ast::Block, attrs: &[ast::Attribute]) {\n+    pub(crate) fn print_block_with_attrs(&mut self, blk: &ast::Block, attrs: &[ast::Attribute]) {\n         self.print_block_maybe_unclosed(blk, attrs, true)\n     }\n \n-    crate fn print_block_maybe_unclosed(\n+    pub(crate) fn print_block_maybe_unclosed(\n         &mut self,\n         blk: &ast::Block,\n         attrs: &[ast::Attribute],\n@@ -1210,7 +1215,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Print a `let pat = expr` expression.\n-    crate fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n+    pub(crate) fn print_let(&mut self, pat: &ast::Pat, expr: &ast::Expr) {\n         self.word(\"let \");\n         self.print_pat(pat);\n         self.space();\n@@ -1219,7 +1224,7 @@ impl<'a> State<'a> {\n         self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n     }\n \n-    crate fn print_mac(&mut self, m: &ast::MacCall) {\n+    pub(crate) fn print_mac(&mut self, m: &ast::MacCall) {\n         self.print_mac_common(\n             Some(MacHeader::Path(&m.path)),\n             true,\n@@ -1360,15 +1365,15 @@ impl<'a> State<'a> {\n         self.pclose();\n     }\n \n-    crate fn print_local_decl(&mut self, loc: &ast::Local) {\n+    pub(crate) fn print_local_decl(&mut self, loc: &ast::Local) {\n         self.print_pat(&loc.pat);\n         if let Some(ref ty) = loc.ty {\n             self.word_space(\":\");\n             self.print_type(ty);\n         }\n     }\n \n-    crate fn print_name(&mut self, name: Symbol) {\n+    pub(crate) fn print_name(&mut self, name: Symbol) {\n         self.word(name.to_string());\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n@@ -1392,7 +1397,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_pat(&mut self, pat: &ast::Pat) {\n+    pub(crate) fn print_pat(&mut self, pat: &ast::Pat) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));\n         /* Pat isn't normalized, but the beauty of it\n@@ -1551,7 +1556,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_asyncness(&mut self, asyncness: ast::Async) {\n+    pub(crate) fn print_asyncness(&mut self, asyncness: ast::Async) {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\");\n         }\n@@ -1584,11 +1589,11 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_lifetime(&mut self, lifetime: ast::Lifetime) {\n+    pub(crate) fn print_lifetime(&mut self, lifetime: ast::Lifetime) {\n         self.print_name(lifetime.ident.name)\n     }\n \n-    crate fn print_lifetime_bounds(\n+    pub(crate) fn print_lifetime_bounds(\n         &mut self,\n         lifetime: ast::Lifetime,\n         bounds: &ast::GenericBounds,\n@@ -1608,7 +1613,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n+    pub(crate) fn print_generic_params(&mut self, generic_params: &[ast::GenericParam]) {\n         if generic_params.is_empty() {\n             return;\n         }\n@@ -1662,12 +1667,12 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n+    pub(crate) fn print_mt(&mut self, mt: &ast::MutTy, print_const: bool) {\n         self.print_mutability(mt.mutbl, print_const);\n         self.print_type(&mt.ty)\n     }\n \n-    crate fn print_param(&mut self, input: &ast::Param, is_closure: bool) {\n+    pub(crate) fn print_param(&mut self, input: &ast::Param, is_closure: bool) {\n         self.ibox(INDENT_UNIT);\n \n         self.print_outer_attributes_inline(&input.attrs);\n@@ -1695,7 +1700,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_fn_ret_ty(&mut self, fn_ret_ty: &ast::FnRetTy) {\n+    pub(crate) fn print_fn_ret_ty(&mut self, fn_ret_ty: &ast::FnRetTy) {\n         if let ast::FnRetTy::Ty(ty) = fn_ret_ty {\n             self.space_if_not_bol();\n             self.ibox(INDENT_UNIT);\n@@ -1706,7 +1711,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_ty_fn(\n+    pub(crate) fn print_ty_fn(\n         &mut self,\n         ext: ast::Extern,\n         unsafety: ast::Unsafe,\n@@ -1730,7 +1735,7 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_fn_header_info(&mut self, header: ast::FnHeader) {\n+    pub(crate) fn print_fn_header_info(&mut self, header: ast::FnHeader) {\n         self.print_constness(header.constness);\n         self.print_asyncness(header.asyncness);\n         self.print_unsafety(header.unsafety);\n@@ -1750,21 +1755,21 @@ impl<'a> State<'a> {\n         self.word(\"fn\")\n     }\n \n-    crate fn print_unsafety(&mut self, s: ast::Unsafe) {\n+    pub(crate) fn print_unsafety(&mut self, s: ast::Unsafe) {\n         match s {\n             ast::Unsafe::No => {}\n             ast::Unsafe::Yes(_) => self.word_nbsp(\"unsafe\"),\n         }\n     }\n \n-    crate fn print_constness(&mut self, s: ast::Const) {\n+    pub(crate) fn print_constness(&mut self, s: ast::Const) {\n         match s {\n             ast::Const::No => {}\n             ast::Const::Yes(_) => self.word_nbsp(\"const\"),\n         }\n     }\n \n-    crate fn print_is_auto(&mut self, s: ast::IsAuto) {\n+    pub(crate) fn print_is_auto(&mut self, s: ast::IsAuto) {\n         match s {\n             ast::IsAuto::Yes => self.word_nbsp(\"auto\"),\n             ast::IsAuto::No => {}"}, {"sha": "0de5e2099fd0b1ff5f6595e50df4ad479df879ab", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -19,7 +19,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+    pub(crate) fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n@@ -128,7 +128,7 @@ impl<'a> State<'a> {\n     }\n \n     /// Pretty-prints an item.\n-    crate fn print_item(&mut self, item: &ast::Item) {\n+    pub(crate) fn print_item(&mut self, item: &ast::Item) {\n         self.hardbreak_if_not_bol();\n         self.maybe_print_comment(item.span.lo());\n         self.print_outer_attributes(&item.attrs);\n@@ -400,7 +400,7 @@ impl<'a> State<'a> {\n         self.bclose(span, empty)\n     }\n \n-    crate fn print_visibility(&mut self, vis: &ast::Visibility) {\n+    pub(crate) fn print_visibility(&mut self, vis: &ast::Visibility) {\n         match vis.kind {\n             ast::VisibilityKind::Public => self.word_nbsp(\"pub\"),\n             ast::VisibilityKind::Crate(sugar) => match sugar {\n@@ -484,7 +484,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_variant(&mut self, v: &ast::Variant) {\n+    pub(crate) fn print_variant(&mut self, v: &ast::Variant) {\n         self.head(\"\");\n         self.print_visibility(&v.vis);\n         let generics = ast::Generics::default();\n@@ -496,7 +496,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+    pub(crate) fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n@@ -562,7 +562,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_fn(\n+    pub(crate) fn print_fn(\n         &mut self,\n         decl: &ast::FnDecl,\n         header: ast::FnHeader,\n@@ -579,7 +579,7 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+    pub(crate) fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n         let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n         self.word(open);\n         self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n@@ -591,7 +591,7 @@ impl<'a> State<'a> {\n         self.print_where_clause_parts(where_clause.has_where_token, &where_clause.predicates);\n     }\n \n-    crate fn print_where_clause_parts(\n+    pub(crate) fn print_where_clause_parts(\n         &mut self,\n         has_where_token: bool,\n         predicates: &[ast::WherePredicate],"}, {"sha": "c7d0e3361331c51ea488331be0f107b094b5aa1d", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -29,7 +29,7 @@ pub struct BorrowSet<'tcx> {\n     /// Map from local to all the borrows on that local.\n     pub local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n-    crate locals_state_at_exit: LocalsStateAtExit,\n+    pub(crate) locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n@@ -148,23 +148,23 @@ impl<'tcx> BorrowSet<'tcx> {\n         }\n     }\n \n-    crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n+    pub(crate) fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n         self.activation_map.get(&location).map_or(&[], |activations| &activations[..])\n     }\n \n-    crate fn len(&self) -> usize {\n+    pub(crate) fn len(&self) -> usize {\n         self.location_map.len()\n     }\n \n-    crate fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n+    pub(crate) fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n         BorrowIndex::from_usize(0)..BorrowIndex::from_usize(self.len())\n     }\n \n-    crate fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n+    pub(crate) fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n         self.indices().zip(self.location_map.values())\n     }\n \n-    crate fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n+    pub(crate) fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n         self.location_map.get_index_of(location).map(BorrowIndex::from)\n     }\n }"}, {"sha": "a1233d62cb02ea2ecb832d05bd30975ccb2e4629", "filename": "compiler/rustc_borrowck/src/borrowck_errors.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrowck_errors.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,15 +3,15 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n-    crate fn cannot_move_when_borrowed(\n+    pub(crate) fn cannot_move_when_borrowed(\n         &self,\n         span: Span,\n         desc: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0505, \"cannot move out of {} because it is borrowed\", desc,)\n     }\n \n-    crate fn cannot_use_when_mutably_borrowed(\n+    pub(crate) fn cannot_use_when_mutably_borrowed(\n         &self,\n         span: Span,\n         desc: &str,\n@@ -31,7 +31,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_act_on_uninitialized_variable(\n+    pub(crate) fn cannot_act_on_uninitialized_variable(\n         &self,\n         span: Span,\n         verb: &str,\n@@ -47,7 +47,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_mutably_borrow_multiply(\n+    pub(crate) fn cannot_mutably_borrow_multiply(\n         &self,\n         new_loan_span: Span,\n         desc: &str,\n@@ -97,7 +97,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_uniquely_borrow_by_two_closures(\n+    pub(crate) fn cannot_uniquely_borrow_by_two_closures(\n         &self,\n         new_loan_span: Span,\n         desc: &str,\n@@ -126,7 +126,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_uniquely_borrow_by_one_closure(\n+    pub(crate) fn cannot_uniquely_borrow_by_one_closure(\n         &self,\n         new_loan_span: Span,\n         container_name: &str,\n@@ -157,7 +157,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reborrow_already_uniquely_borrowed(\n+    pub(crate) fn cannot_reborrow_already_uniquely_borrowed(\n         &self,\n         new_loan_span: Span,\n         container_name: &str,\n@@ -193,7 +193,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reborrow_already_borrowed(\n+    pub(crate) fn cannot_reborrow_already_borrowed(\n         &self,\n         span: Span,\n         desc_new: &str,\n@@ -242,7 +242,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_assign_to_borrowed(\n+    pub(crate) fn cannot_assign_to_borrowed(\n         &self,\n         span: Span,\n         borrow_span: Span,\n@@ -261,7 +261,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_reassign_immutable(\n+    pub(crate) fn cannot_reassign_immutable(\n         &self,\n         span: Span,\n         desc: &str,\n@@ -271,15 +271,15 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         struct_span_err!(self, span, E0384, \"cannot assign {} {}\", msg, desc)\n     }\n \n-    crate fn cannot_assign(\n+    pub(crate) fn cannot_assign(\n         &self,\n         span: Span,\n         desc: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0594, \"cannot assign to {}\", desc)\n     }\n \n-    crate fn cannot_move_out_of(\n+    pub(crate) fn cannot_move_out_of(\n         &self,\n         move_from_span: Span,\n         move_from_desc: &str,\n@@ -290,7 +290,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     /// Signal an error due to an attempt to move out of the interior\n     /// of an array or slice. `is_index` is None when error origin\n     /// didn't capture whether there was an indexing operation or not.\n-    crate fn cannot_move_out_of_interior_noncopy(\n+    pub(crate) fn cannot_move_out_of_interior_noncopy(\n         &self,\n         move_from_span: Span,\n         ty: Ty<'_>,\n@@ -313,7 +313,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_move_out_of_interior_of_drop(\n+    pub(crate) fn cannot_move_out_of_interior_of_drop(\n         &self,\n         move_from_span: Span,\n         container_ty: Ty<'_>,\n@@ -329,7 +329,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_act_on_moved_value(\n+    pub(crate) fn cannot_act_on_moved_value(\n         &self,\n         use_span: Span,\n         verb: &str,\n@@ -349,7 +349,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn cannot_borrow_path_as_mutable_because(\n+    pub(crate) fn cannot_borrow_path_as_mutable_because(\n         &self,\n         span: Span,\n         path: &str,\n@@ -358,7 +358,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{}\", path, reason,)\n     }\n \n-    crate fn cannot_mutate_in_immutable_section(\n+    pub(crate) fn cannot_mutate_in_immutable_section(\n         &self,\n         mutate_span: Span,\n         immutable_span: Span,\n@@ -380,7 +380,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_borrow_across_generator_yield(\n+    pub(crate) fn cannot_borrow_across_generator_yield(\n         &self,\n         span: Span,\n         yield_span: Span,\n@@ -395,7 +395,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_borrow_across_destructor(\n+    pub(crate) fn cannot_borrow_across_destructor(\n         &self,\n         borrow_span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n@@ -407,15 +407,15 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         )\n     }\n \n-    crate fn path_does_not_live_long_enough(\n+    pub(crate) fn path_does_not_live_long_enough(\n         &self,\n         span: Span,\n         path: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0597, \"{} does not live long enough\", path,)\n     }\n \n-    crate fn cannot_return_reference_to_local(\n+    pub(crate) fn cannot_return_reference_to_local(\n         &self,\n         span: Span,\n         return_kind: &str,\n@@ -440,7 +440,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn cannot_capture_in_long_lived_closure(\n+    pub(crate) fn cannot_capture_in_long_lived_closure(\n         &self,\n         closure_span: Span,\n         closure_kind: &str,\n@@ -462,14 +462,14 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n         err\n     }\n \n-    crate fn thread_local_value_does_not_live_long_enough(\n+    pub(crate) fn thread_local_value_does_not_live_long_enough(\n         &self,\n         span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         struct_span_err!(self, span, E0712, \"thread-local variable borrowed past end of function\",)\n     }\n \n-    crate fn temporary_value_borrowed_for_too_long(\n+    pub(crate) fn temporary_value_borrowed_for_too_long(\n         &self,\n         span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n@@ -486,7 +486,7 @@ impl<'cx, 'tcx> crate::MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-crate fn borrowed_data_escapes_closure<'tcx>(\n+pub(crate) fn borrowed_data_escapes_closure<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     escape_span: Span,\n     escapes_from: &str,"}, {"sha": "609fbc2bc1515aa7e0e76bfabc3ed577316ed81a", "filename": "compiler/rustc_borrowck/src/constraints/graph.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fgraph.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -13,19 +13,19 @@ use crate::{\n /// The construct graph organizes the constraints by their end-points.\n /// It can be used to view a `R1: R2` constraint as either an edge `R1\n /// -> R2` or `R2 -> R1` depending on the direction type `D`.\n-crate struct ConstraintGraph<D: ConstraintGraphDirecton> {\n+pub(crate) struct ConstraintGraph<D: ConstraintGraphDirecton> {\n     _direction: D,\n     first_constraints: IndexVec<RegionVid, Option<OutlivesConstraintIndex>>,\n     next_constraints: IndexVec<OutlivesConstraintIndex, Option<OutlivesConstraintIndex>>,\n }\n \n-crate type NormalConstraintGraph = ConstraintGraph<Normal>;\n+pub(crate) type NormalConstraintGraph = ConstraintGraph<Normal>;\n \n-crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n+pub(crate) type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n \n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n-crate trait ConstraintGraphDirecton: Copy + 'static {\n+pub(crate) trait ConstraintGraphDirecton: Copy + 'static {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn is_normal() -> bool;\n@@ -36,7 +36,7 @@ crate trait ConstraintGraphDirecton: Copy + 'static {\n /// inference. This is because we compute the value of R1 by union'ing\n /// all the things that it relies on.\n #[derive(Copy, Clone, Debug)]\n-crate struct Normal;\n+pub(crate) struct Normal;\n \n impl ConstraintGraphDirecton for Normal {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n@@ -57,7 +57,7 @@ impl ConstraintGraphDirecton for Normal {\n /// we wish to iterate from a region (e.g., R2) to all the regions\n /// that will outlive it (e.g., R1).\n #[derive(Copy, Clone, Debug)]\n-crate struct Reverse;\n+pub(crate) struct Reverse;\n \n impl ConstraintGraphDirecton for Reverse {\n     fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n@@ -78,7 +78,11 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(direction: D, set: &OutlivesConstraintSet<'_>, num_region_vars: usize) -> Self {\n+    pub(crate) fn new(\n+        direction: D,\n+        set: &OutlivesConstraintSet<'_>,\n+        num_region_vars: usize,\n+    ) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n@@ -96,7 +100,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Given the constraint set from which this graph was built\n     /// creates a region graph so that you can iterate over *regions*\n     /// and not constraints.\n-    crate fn region_graph<'rg, 'tcx>(\n+    pub(crate) fn region_graph<'rg, 'tcx>(\n         &'rg self,\n         set: &'rg OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n@@ -105,7 +109,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges<'a, 'tcx>(\n+    pub(crate) fn outgoing_edges<'a, 'tcx>(\n         &'a self,\n         region_sup: RegionVid,\n         constraints: &'a OutlivesConstraintSet<'tcx>,\n@@ -129,7 +133,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n }\n \n-crate struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n     constraints: &'s OutlivesConstraintSet<'tcx>,\n     pointer: Option<OutlivesConstraintIndex>,\n@@ -169,7 +173,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n /// This struct brings together a constraint set and a (normal, not\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n-crate struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n     set: &'s OutlivesConstraintSet<'tcx>,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n@@ -180,7 +184,7 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(\n+    pub(crate) fn new(\n         set: &'s OutlivesConstraintSet<'tcx>,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n@@ -190,14 +194,14 @@ impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'s, 'tcx, D> {\n+    pub(crate) fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'s, 'tcx, D> {\n         Successors {\n             edges: self.constraint_graph.outgoing_edges(region_sup, self.set, self.static_region),\n         }\n     }\n }\n \n-crate struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n+pub(crate) struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n     edges: Edges<'s, 'tcx, D>,\n }\n "}, {"sha": "6d5466c0c41e3c3b4e4aaa77ef8a9f5834ef973b", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,19 +8,19 @@ use std::ops::Index;\n \n use crate::type_check::Locations;\n \n-crate mod graph;\n+pub(crate) mod graph;\n \n /// A set of NLL region constraints. These include \"outlives\"\n /// constraints of the form `R1: R2`. Each constraint is identified by\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct OutlivesConstraintSet<'tcx> {\n+pub(crate) struct OutlivesConstraintSet<'tcx> {\n     outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }\n \n impl<'tcx> OutlivesConstraintSet<'tcx> {\n-    crate fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n+    pub(crate) fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n         debug!(\n             \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n@@ -38,20 +38,20 @@ impl<'tcx> OutlivesConstraintSet<'tcx> {\n     /// N.B., this graph contains a \"frozen\" view of the current\n     /// constraints. Any new constraints added to the `OutlivesConstraintSet`\n     /// after the graph is built will not be present in the graph.\n-    crate fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n+    pub(crate) fn graph(&self, num_region_vars: usize) -> graph::NormalConstraintGraph {\n         graph::ConstraintGraph::new(graph::Normal, self, num_region_vars)\n     }\n \n     /// Like `graph`, but constraints a reverse graph where `R1: R2`\n     /// represents an edge `R2 -> R1`.\n-    crate fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n+    pub(crate) fn reverse_graph(&self, num_region_vars: usize) -> graph::ReverseConstraintGraph {\n         graph::ConstraintGraph::new(graph::Reverse, self, num_region_vars)\n     }\n \n     /// Computes cycles (SCCs) in the graph of regions. In particular,\n     /// find all regions R1, R2 such that R1: R2 and R2: R1 and group\n     /// them into an SCC, and find the relationships between SCCs.\n-    crate fn compute_sccs(\n+    pub(crate) fn compute_sccs(\n         &self,\n         constraint_graph: &graph::NormalConstraintGraph,\n         static_region: RegionVid,\n@@ -60,7 +60,7 @@ impl<'tcx> OutlivesConstraintSet<'tcx> {\n         Sccs::new(region_graph)\n     }\n \n-    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n+    pub(crate) fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n         &self.outlives\n     }\n }"}, {"sha": "97d5a8d158e1e63e7b72f2f77bc255fa1c352059", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -233,7 +233,7 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n }\n \n impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: &'a RegionInferenceContext<'tcx>,"}, {"sha": "07f182102f346009b130861e5938fd4723032652", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -22,7 +22,7 @@ use crate::region_infer::values::RegionElement;\n use crate::MirBorrowckCtxt;\n \n #[derive(Clone)]\n-crate struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n+pub(crate) struct UniverseInfo<'tcx>(UniverseInfoInner<'tcx>);\n \n /// What operation a universe was created for.\n #[derive(Clone)]\n@@ -36,15 +36,15 @@ enum UniverseInfoInner<'tcx> {\n }\n \n impl<'tcx> UniverseInfo<'tcx> {\n-    crate fn other() -> UniverseInfo<'tcx> {\n+    pub(crate) fn other() -> UniverseInfo<'tcx> {\n         UniverseInfo(UniverseInfoInner::Other)\n     }\n \n-    crate fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n+    pub(crate) fn relate(expected: Ty<'tcx>, found: Ty<'tcx>) -> UniverseInfo<'tcx> {\n         UniverseInfo(UniverseInfoInner::RelateTys { expected, found })\n     }\n \n-    crate fn report_error(\n+    pub(crate) fn report_error(\n         &self,\n         mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         placeholder: ty::PlaceholderRegion,\n@@ -76,7 +76,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n     }\n }\n \n-crate trait ToUniverseInfo<'tcx> {\n+pub(crate) trait ToUniverseInfo<'tcx> {\n     fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n }\n "}, {"sha": "06fca4db0cf1f9ab72bb942d123a463d66ae9d3c", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n \n-crate fn find<'tcx>(\n+pub(crate) fn find<'tcx>(\n     body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'tcx>,"}, {"sha": "9581bb652362ff4fbb4fd1937b18564281d78ea8", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -35,12 +35,12 @@ mod move_errors;\n mod mutability_errors;\n mod region_errors;\n \n-crate use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n-crate use mutability_errors::AccessKind;\n-crate use outlives_suggestion::OutlivesSuggestionBuilder;\n-crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n-crate use region_name::{RegionName, RegionNameSource};\n-crate use rustc_const_eval::util::CallKind;\n+pub(crate) use bound_region_errors::{ToUniverseInfo, UniverseInfo};\n+pub(crate) use mutability_errors::AccessKind;\n+pub(crate) use outlives_suggestion::OutlivesSuggestionBuilder;\n+pub(crate) use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n+pub(crate) use region_name::{RegionName, RegionNameSource};\n+pub(crate) use rustc_const_eval::util::CallKind;\n use rustc_middle::mir::tcx::PlaceTy;\n \n pub(super) struct IncludingDowncast(pub(super) bool);"}, {"sha": "1688d1259fa86ec3166c929f1013b09ceb976178", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -149,7 +149,7 @@ impl OutlivesSuggestionBuilder {\n     }\n \n     /// Add the outlives constraint `fr: outlived_fr` to the set of constraints we need to suggest.\n-    crate fn collect_constraint(&mut self, fr: RegionVid, outlived_fr: RegionVid) {\n+    pub(crate) fn collect_constraint(&mut self, fr: RegionVid, outlived_fr: RegionVid) {\n         debug!(\"Collected {:?}: {:?}\", fr, outlived_fr);\n \n         // Add to set of constraints for final help note.\n@@ -158,7 +158,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// Emit an intermediate note on the given `Diagnostic` if the involved regions are\n     /// suggestable.\n-    crate fn intermediate_suggestion(\n+    pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n@@ -179,7 +179,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n+    pub(crate) fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n         // No constraints to add? Done.\n         if self.constraints_to_add.is_empty() {\n             debug!(\"No constraints to suggest.\");"}, {"sha": "f2b5c83c5c1d08afd5bb5f0ff16b5d9533867ae1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -58,10 +58,10 @@ impl ConstraintDescription for ConstraintCategory {\n ///\n /// Usually we expect this to either be empty or contain a small number of items, so we can avoid\n /// allocation most of the time.\n-crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n+pub(crate) type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n \n #[derive(Clone, Debug)]\n-crate enum RegionErrorKind<'tcx> {\n+pub(crate) enum RegionErrorKind<'tcx> {\n     /// A generic bound failure for a type test (`T: 'a`).\n     TypeTestError { type_test: TypeTest<'tcx> },\n "}, {"sha": "4d2a16aa609846a1e1931b062add52cb2a6ee032", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,18 +15,18 @@ use crate::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n #[derive(Debug, Clone)]\n-crate struct RegionName {\n+pub(crate) struct RegionName {\n     /// The name of the region (interned).\n-    crate name: Symbol,\n+    pub(crate) name: Symbol,\n     /// Where the region comes from.\n-    crate source: RegionNameSource,\n+    pub(crate) source: RegionNameSource,\n }\n \n /// Denotes the source of a region that is named by a `RegionName`. For example, a free region that\n /// was named by the user would get `NamedFreeRegion` and `'static` lifetime would get `Static`.\n /// This helps to print the right kinds of diagnostics.\n #[derive(Debug, Clone)]\n-crate enum RegionNameSource {\n+pub(crate) enum RegionNameSource {\n     /// A bound (not free) region that was substituted at the def site (not an HRTB).\n     NamedEarlyBoundRegion(Span),\n     /// A free region that the user has a name (`'a`) for.\n@@ -50,7 +50,7 @@ crate enum RegionNameSource {\n /// Describes what to highlight to explain to the user that we're giving an anonymous region a\n /// synthesized name, and how to highlight it.\n #[derive(Debug, Clone)]\n-crate enum RegionNameHighlight {\n+pub(crate) enum RegionNameHighlight {\n     /// The anonymous region corresponds to a reference that was found by traversing the type in the HIR.\n     MatchedHirTy(Span),\n     /// The anonymous region corresponds to a `'_` in the generics list of a struct/enum/union.\n@@ -65,7 +65,7 @@ crate enum RegionNameHighlight {\n }\n \n impl RegionName {\n-    crate fn was_named(&self) -> bool {\n+    pub(crate) fn was_named(&self) -> bool {\n         match self.source {\n             RegionNameSource::NamedEarlyBoundRegion(..)\n             | RegionNameSource::NamedFreeRegion(..)\n@@ -79,7 +79,7 @@ impl RegionName {\n         }\n     }\n \n-    crate fn span(&self) -> Option<Span> {\n+    pub(crate) fn span(&self) -> Option<Span> {\n         match self.source {\n             RegionNameSource::Static => None,\n             RegionNameSource::NamedEarlyBoundRegion(span)\n@@ -98,7 +98,7 @@ impl RegionName {\n         }\n     }\n \n-    crate fn highlight_region_name(&self, diag: &mut Diagnostic) {\n+    pub(crate) fn highlight_region_name(&self, diag: &mut Diagnostic) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n             | RegionNameSource::NamedEarlyBoundRegion(span) => {\n@@ -178,11 +178,11 @@ impl Display for RegionName {\n }\n \n impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n-    crate fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n+    pub(crate) fn mir_def_id(&self) -> hir::def_id::LocalDefId {\n         self.body.source.def_id().as_local().unwrap()\n     }\n \n-    crate fn mir_hir_id(&self) -> hir::HirId {\n+    pub(crate) fn mir_hir_id(&self) -> hir::HirId {\n         self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id())\n     }\n \n@@ -222,7 +222,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// ```\n     ///\n     /// and then return the name `'1` for us to use.\n-    crate fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n+    pub(crate) fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n         debug!(\n             \"give_region_a_name(fr={:?}, counter={:?})\",\n             fr,"}, {"sha": "9ba29f04b1a9aa4cffc27b0ea8539bb3cd3098d9", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,7 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n-    crate fn get_var_name_and_span_for_region(\n+    pub(crate) fn get_var_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -34,7 +34,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Search the upvars (if any) to find one that references fr. Return its index.\n-    crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n+    pub(crate) fn get_upvar_index_for_region(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        fr: RegionVid,\n+    ) -> Option<usize> {\n         let upvar_index =\n             self.universal_regions().defining_ty.upvar_tys().position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n@@ -57,7 +61,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Given the index of an upvar, finds its name and the span from where it was\n     /// declared.\n-    crate fn get_upvar_name_and_span_for_region(\n+    pub(crate) fn get_upvar_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         upvars: &[Upvar<'tcx>],\n@@ -81,7 +85,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// N.B., in the case of a closure, the index is indexing into the signature as seen by the\n     /// user - in particular, index 0 is not the implicit self parameter.\n-    crate fn get_argument_index_for_region(\n+    pub(crate) fn get_argument_index_for_region(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n@@ -107,7 +111,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Given the index of an argument, finds its name (if any) and the span from where it was\n     /// declared.\n-    crate fn get_argument_name_and_span_for_region(\n+    pub(crate) fn get_argument_name_and_span_for_region(\n         &self,\n         body: &Body<'tcx>,\n         local_names: &IndexVec<Local, Option<Symbol>>,"}, {"sha": "7f0a637c9d30bccfb4e9ce669011099aacfe606e", "filename": "compiler/rustc_borrowck/src/facts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ffacts.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -25,7 +25,7 @@ impl polonius_engine::FactTypes for RustcFacts {\n \n pub type AllFacts = PoloniusFacts<RustcFacts>;\n \n-crate trait AllFactsExt {\n+pub(crate) trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n     /// current `-Z` flags.\n     fn enabled(tcx: TyCtxt<'_>) -> bool;"}, {"sha": "a3e7c953ee3b04fb14143444a4ba66ccb1562131", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2,7 +2,6 @@\n \n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(min_specialization)]"}, {"sha": "70a3116949894f7a8a423ca266277206a547a0a4", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -30,7 +30,7 @@ pub enum RichLocation {\n }\n \n impl LocationTable {\n-    crate fn new(body: &Body<'_>) -> Self {\n+    pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = body\n             .basic_blocks()"}, {"sha": "61838c41e393e98597ee8190d1167c1551204f92", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use std::ops::Index;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region `R0`.\n-crate struct MemberConstraintSet<'tcx, R>\n+pub(crate) struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Eq,\n {\n@@ -28,17 +28,17 @@ where\n }\n \n /// Represents a `R0 member of [R1..Rn]` constraint\n-crate struct NllMemberConstraint<'tcx> {\n+pub(crate) struct NllMemberConstraint<'tcx> {\n     next_constraint: Option<NllMemberConstraintIndex>,\n \n     /// The span where the hidden type was instantiated.\n-    crate definition_span: Span,\n+    pub(crate) definition_span: Span,\n \n     /// The hidden type in which `R0` appears. (Used in error reporting.)\n-    crate hidden_ty: Ty<'tcx>,\n+    pub(crate) hidden_ty: Ty<'tcx>,\n \n     /// The region `R0`.\n-    crate member_region_vid: ty::RegionVid,\n+    pub(crate) member_region_vid: ty::RegionVid,\n \n     /// Index of `R1` in `choice_regions` vector from `MemberConstraintSet`.\n     start_index: usize,\n@@ -48,7 +48,7 @@ crate struct NllMemberConstraint<'tcx> {\n }\n \n rustc_index::newtype_index! {\n-    crate struct NllMemberConstraintIndex {\n+    pub(crate) struct NllMemberConstraintIndex {\n         DEBUG_FORMAT = \"MemberConstraintIndex({})\"\n     }\n }\n@@ -73,7 +73,7 @@ impl<'tcx> MemberConstraintSet<'tcx, ty::RegionVid> {\n     /// within into `RegionVid` format -- it typically consults the\n     /// `UniversalRegions` data structure that is known to the caller\n     /// (but which this code is unaware of).\n-    crate fn push_constraint(\n+    pub(crate) fn push_constraint(\n         &mut self,\n         m_c: &MemberConstraint<'tcx>,\n         mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n@@ -106,7 +106,7 @@ where\n     /// the original `RegionVid` to an scc index. In some cases, we\n     /// may have multiple `R1` values mapping to the same `R2` key -- that\n     /// is ok, the two sets will be merged.\n-    crate fn into_mapped<R2>(\n+    pub(crate) fn into_mapped<R2>(\n         self,\n         mut map_fn: impl FnMut(R1) -> R2,\n     ) -> MemberConstraintSet<'tcx, R2>\n@@ -144,14 +144,14 @@ impl<R> MemberConstraintSet<'_, R>\n where\n     R: Copy + Hash + Eq,\n {\n-    crate fn all_indices(&self) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n+    pub(crate) fn all_indices(&self) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n         self.constraints.indices()\n     }\n \n     /// Iterate down the constraint indices associated with a given\n     /// peek-region.  You can then use `choice_regions` and other\n     /// methods to access data.\n-    crate fn indices(\n+    pub(crate) fn indices(\n         &self,\n         member_region_vid: R,\n     ) -> impl Iterator<Item = NllMemberConstraintIndex> + '_ {\n@@ -172,7 +172,7 @@ where\n     /// ```text\n     /// R0 member of [R1..Rn]\n     /// ```\n-    crate fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n+    pub(crate) fn choice_regions(&self, pci: NllMemberConstraintIndex) -> &[ty::RegionVid] {\n         let NllMemberConstraint { start_index, end_index, .. } = &self.constraints[pci];\n         &self.choice_regions[*start_index..*end_index]\n     }"}, {"sha": "2440ae9780d230bacb50acdea0e082cbd9c12d37", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -42,7 +42,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n \n /// The output of `nll::compute_regions`. This includes the computed `RegionInferenceContext`, any\n /// closure requirements to propagate, and any generated errors.\n-crate struct NllOutput<'tcx> {\n+pub(crate) struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n     pub opaque_type_values: VecMap<DefId, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n@@ -457,6 +457,6 @@ impl ToRegionVid for RegionVid {\n     }\n }\n \n-crate trait ConstraintDescription {\n+pub(crate) trait ConstraintDescription {\n     fn description(&self) -> &'static str;\n }"}, {"sha": "93d202e49a159fc4173a852ce879d0941e3d16de", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::{Body, Mutability, Place};\n use rustc_middle::ty::{self, TyCtxt};\n \n /// Extension methods for the `Place` type.\n-crate trait PlaceExt<'tcx> {\n+pub(crate) trait PlaceExt<'tcx> {\n     /// Returns `true` if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true"}, {"sha": "97335fd0dffaeb4d28205c7adfd76654f4e4706e", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -14,15 +14,15 @@ use std::iter;\n /// being run in the calling context, the conservative choice is to assume the compared indices\n /// are disjoint (and therefore, do not overlap).\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum PlaceConflictBias {\n+pub(crate) enum PlaceConflictBias {\n     Overlap,\n     NoOverlap,\n }\n \n /// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n-crate fn places_conflict<'tcx>(\n+pub(crate) fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: Place<'tcx>,"}, {"sha": "f31ccd74ca6f72b198346dfcd908fa6e4ba8c057", "filename": "compiler/rustc_borrowck/src/region_infer/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fgraphviz.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -11,12 +11,12 @@ use rustc_graphviz as dot;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Write out the region constraint graph.\n-    crate fn dump_graphviz_raw_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+    pub(crate) fn dump_graphviz_raw_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n         dot::render(&RawConstraints { regioncx: self }, &mut w)\n     }\n \n     /// Write out the region constraint graph.\n-    crate fn dump_graphviz_scc_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n+    pub(crate) fn dump_graphviz_scc_constraints(&self, mut w: &mut dyn Write) -> io::Result<()> {\n         let mut nodes_per_scc: IndexVec<ConstraintSccIndex, _> =\n             self.constraint_sccs.all_sccs().map(|_| Vec::new()).collect();\n "}, {"sha": "dc6337c54edd98838b5ea90967b4479f8c2cdf80", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -513,26 +513,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n+    pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         self.universal_regions.annotate(tcx, err)\n     }\n \n     /// Returns `true` if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n-    crate fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n+    pub(crate) fn region_contains(&self, r: impl ToRegionVid, p: impl ToElementIndex) -> bool {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_values.contains(scc, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    crate fn region_value_str(&self, r: RegionVid) -> String {\n+    pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_values.region_value_str(scc)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    crate fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n+    pub(crate) fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n         let scc = self.constraint_sccs.scc(r.to_region_vid());\n         self.scc_universes[scc]\n     }\n@@ -1693,7 +1693,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   that cannot be named by `fr1`; in that case, we will require\n     ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n     ///   be satisfied. (See `add_incompatible_universe`.)\n-    crate fn provides_universal_region(\n+    pub(crate) fn provides_universal_region(\n         &self,\n         r: RegionVid,\n         fr1: RegionVid,\n@@ -1712,7 +1712,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// If `r2` represents a placeholder region, then this returns\n     /// `true` if `r1` cannot name that placeholder in its\n     /// value; otherwise, returns `false`.\n-    crate fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+    pub(crate) fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n         debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n \n         match self.definitions[r2].origin {\n@@ -1731,7 +1731,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    crate fn retrieve_closure_constraint_info(\n+    pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n         _body: &Body<'tcx>,\n         constraint: &OutlivesConstraint<'tcx>,\n@@ -1766,7 +1766,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Finds a good `ObligationCause` to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(\n+    pub(crate) fn find_outlives_blame_span(\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n@@ -1788,7 +1788,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///\n     /// Returns: a series of constraints as well as the region `R`\n     /// that passed the target test.\n-    crate fn find_constraint_paths_between_regions(\n+    pub(crate) fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n@@ -1882,7 +1882,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n     #[instrument(skip(self), level = \"trace\")]\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+    pub(crate) fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         trace!(scc = ?self.constraint_sccs.scc(fr1));\n         trace!(universe = ?self.scc_universes[self.constraint_sccs.scc(fr1)]);\n         self.find_constraint_paths_between_regions(fr1, |r| {\n@@ -1919,7 +1919,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Get the region outlived by `longer_fr` and live at `element`.\n-    crate fn region_from_element(\n+    pub(crate) fn region_from_element(\n         &self,\n         longer_fr: RegionVid,\n         element: &RegionElement,\n@@ -1939,17 +1939,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Get the region definition of `r`.\n-    crate fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n+    pub(crate) fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n         &self.definitions[r]\n     }\n \n     /// Check if the SCC of `r` contains `upper`.\n-    crate fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n+    pub(crate) fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n         let r_scc = self.constraint_sccs.scc(r);\n         self.scc_values.contains(r_scc, upper)\n     }\n \n-    crate fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n+    pub(crate) fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n         self.universal_regions.as_ref()\n     }\n \n@@ -1959,7 +1959,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// creating a constraint path that forces `R` to outlive\n     /// `from_region`, and then finding the best choices within that\n     /// path to blame.\n-    crate fn best_blame_constraint(\n+    pub(crate) fn best_blame_constraint(\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n@@ -2171,7 +2171,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         categorized_path.remove(0)\n     }\n \n-    crate fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+    pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         self.universe_causes[&universe].clone()\n     }\n }"}, {"sha": "1e6798eee3df8b056cf4379d05c8e294f2e54df7", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::RegionVid;\n use std::ops::Range;\n use std::rc::Rc;\n \n-crate struct ReverseSccGraph {\n+pub(crate) struct ReverseSccGraph {\n     graph: VecGraph<ConstraintSccIndex>,\n     /// For each SCC, the range of `universal_regions` that use that SCC as\n     /// their value."}, {"sha": "c81ef10f7c74008ac300cd421274285ada3a0a53", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,7 +10,7 @@ use std::fmt::Debug;\n use std::rc::Rc;\n \n /// Maps between a `Location` and a `PointIndex` (and vice versa).\n-crate struct RegionValueElements {\n+pub(crate) struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n \n@@ -22,7 +22,7 @@ crate struct RegionValueElements {\n }\n \n impl RegionValueElements {\n-    crate fn new(body: &Body<'_>) -> Self {\n+    pub(crate) fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block: IndexVec<BasicBlock, usize> = body\n             .basic_blocks()\n@@ -45,30 +45,30 @@ impl RegionValueElements {\n     }\n \n     /// Total number of point indices\n-    crate fn num_points(&self) -> usize {\n+    pub(crate) fn num_points(&self) -> usize {\n         self.num_points\n     }\n \n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    crate fn point_from_location(&self, location: Location) -> PointIndex {\n+    pub(crate) fn point_from_location(&self, location: Location) -> PointIndex {\n         let Location { block, statement_index } = location;\n         let start_index = self.statements_before_block[block];\n         PointIndex::new(start_index + statement_index)\n     }\n \n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    crate fn entry_point(&self, block: BasicBlock) -> PointIndex {\n+    pub(crate) fn entry_point(&self, block: BasicBlock) -> PointIndex {\n         let start_index = self.statements_before_block[block];\n         PointIndex::new(start_index)\n     }\n \n     /// Return the PointIndex for the block start of this index.\n-    crate fn to_block_start(&self, index: PointIndex) -> PointIndex {\n+    pub(crate) fn to_block_start(&self, index: PointIndex) -> PointIndex {\n         PointIndex::new(self.statements_before_block[self.basic_blocks[index]])\n     }\n \n     /// Converts a `PointIndex` back to a location. O(1).\n-    crate fn to_location(&self, index: PointIndex) -> Location {\n+    pub(crate) fn to_location(&self, index: PointIndex) -> Location {\n         assert!(index.index() < self.num_points);\n         let block = self.basic_blocks[index];\n         let start_index = self.statements_before_block[block];\n@@ -80,7 +80,7 @@ impl RegionValueElements {\n     /// out of range (because they round up to the nearest 2^N number\n     /// of bits). Use this function to filter such points out if you\n     /// like.\n-    crate fn point_in_range(&self, index: PointIndex) -> bool {\n+    pub(crate) fn point_in_range(&self, index: PointIndex) -> bool {\n         index.index() < self.num_points\n     }\n }\n@@ -99,7 +99,7 @@ rustc_index::newtype_index! {\n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n #[derive(Debug, Clone)]\n-crate enum RegionElement {\n+pub(crate) enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n@@ -114,7 +114,7 @@ crate enum RegionElement {\n \n /// When we initially compute liveness, we use an interval matrix storing\n /// liveness ranges for each region-vid.\n-crate struct LivenessValues<N: Idx> {\n+pub(crate) struct LivenessValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     points: SparseIntervalMatrix<N, PointIndex>,\n }\n@@ -123,43 +123,43 @@ impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: Rc<RegionValueElements>) -> Self {\n+    pub(crate) fn new(elements: Rc<RegionValueElements>) -> Self {\n         Self { points: SparseIntervalMatrix::new(elements.num_points), elements }\n     }\n \n     /// Iterate through each region that has a value in this set.\n-    crate fn rows(&self) -> impl Iterator<Item = N> {\n+    pub(crate) fn rows(&self) -> impl Iterator<Item = N> {\n         self.points.rows()\n     }\n \n     /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(&mut self, row: N, location: Location) -> bool {\n+    pub(crate) fn add_element(&mut self, row: N, location: Location) -> bool {\n         debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n         let index = self.elements.point_from_location(location);\n         self.points.insert(row, index)\n     }\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns whether any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n+    pub(crate) fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_row(row, locations)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n-    crate fn add_all_points(&mut self, row: N) {\n+    pub(crate) fn add_all_points(&mut self, row: N) {\n         self.points.insert_all_into_row(row);\n     }\n \n     /// Returns `true` if the region `r` contains the given element.\n-    crate fn contains(&self, row: N, location: Location) -> bool {\n+    pub(crate) fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n         self.points.row(row).map_or(false, |r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`\n-    crate fn get_elements(&self, row: N) -> impl Iterator<Item = Location> + '_ {\n+    pub(crate) fn get_elements(&self, row: N) -> impl Iterator<Item = Location> + '_ {\n         self.points\n             .row(row)\n             .into_iter()\n@@ -169,7 +169,7 @@ impl<N: Idx> LivenessValues<N> {\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    crate fn region_value_str(&self, r: N) -> String {\n+    pub(crate) fn region_value_str(&self, r: N) -> String {\n         region_value_str(self.get_elements(r).map(RegionElement::Location))\n     }\n }\n@@ -178,25 +178,28 @@ impl<N: Idx> LivenessValues<N> {\n /// rustc to the internal `PlaceholderIndex` values that are used in\n /// NLL.\n #[derive(Default)]\n-crate struct PlaceholderIndices {\n+pub(crate) struct PlaceholderIndices {\n     indices: FxIndexSet<ty::PlaceholderRegion>,\n }\n \n impl PlaceholderIndices {\n-    crate fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n+    pub(crate) fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         let (index, _) = self.indices.insert_full(placeholder);\n         index.into()\n     }\n \n-    crate fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n+    pub(crate) fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n         self.indices.get_index_of(&placeholder).unwrap().into()\n     }\n \n-    crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::PlaceholderRegion {\n+    pub(crate) fn lookup_placeholder(\n+        &self,\n+        placeholder: PlaceholderIndex,\n+    ) -> ty::PlaceholderRegion {\n         self.indices[placeholder.index()]\n     }\n \n-    crate fn len(&self) -> usize {\n+    pub(crate) fn len(&self) -> usize {\n         self.indices.len()\n     }\n }\n@@ -220,7 +223,7 @@ impl PlaceholderIndices {\n /// because (since it is returned) it must live for at least `'a`. But\n /// it would also contain various points from within the function.\n #[derive(Clone)]\n-crate struct RegionValues<N: Idx> {\n+pub(crate) struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     placeholder_indices: Rc<PlaceholderIndices>,\n     points: SparseIntervalMatrix<N, PointIndex>,\n@@ -235,7 +238,7 @@ impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(\n+    pub(crate) fn new(\n         elements: &Rc<RegionValueElements>,\n         num_universal_regions: usize,\n         placeholder_indices: &Rc<PlaceholderIndices>,\n@@ -252,41 +255,41 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Adds the given element to the value for the given region. Returns whether\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n+    pub(crate) fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n         elem.add_to_row(self, r)\n     }\n \n     /// Adds all the control-flow points to the values for `r`.\n-    crate fn add_all_points(&mut self, r: N) {\n+    pub(crate) fn add_all_points(&mut self, r: N) {\n         self.points.insert_all_into_row(r);\n     }\n \n     /// Adds all elements in `r_from` to `r_to` (because e.g., `r_to:\n     /// r_from`).\n-    crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n+    pub(crate) fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n         self.points.union_rows(r_from, r_to)\n             | self.free_regions.union_rows(r_from, r_to)\n             | self.placeholders.union_rows(r_from, r_to)\n     }\n \n     /// Returns `true` if the region `r` contains the given element.\n-    crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n+    pub(crate) fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n         elem.contained_in_row(self, r)\n     }\n \n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`.\n-    crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n+    pub(crate) fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n         if let Some(set) = values.points.row(from) {\n             self.points.union_row(to, set);\n         }\n     }\n \n     /// Returns `true` if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n+    pub(crate) fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         if let Some(sub_row) = self.points.row(sub_region) {\n             if let Some(sup_row) = self.points.row(sup_region) {\n                 sup_row.superset(sub_row)\n@@ -301,7 +304,7 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns the locations contained within a given region `r`.\n-    crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n+    pub(crate) fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n         self.points.row(r).into_iter().flat_map(move |set| {\n             set.iter()\n                 .take_while(move |&p| self.elements.point_in_range(p))\n@@ -310,15 +313,15 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n-    crate fn universal_regions_outlived_by<'a>(\n+    pub(crate) fn universal_regions_outlived_by<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n         self.free_regions.row(r).into_iter().flat_map(|set| set.iter())\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn placeholders_contained_in<'a>(\n+    pub(crate) fn placeholders_contained_in<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = ty::PlaceholderRegion> + 'a {\n@@ -330,7 +333,10 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n+    pub(crate) fn elements_contained_in<'a>(\n+        &'a self,\n+        r: N,\n+    ) -> impl Iterator<Item = RegionElement> + 'a {\n         let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n \n         let free_regions_iter =\n@@ -343,12 +349,12 @@ impl<N: Idx> RegionValues<N> {\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n-    crate fn region_value_str(&self, r: N) -> String {\n+    pub(crate) fn region_value_str(&self, r: N) -> String {\n         region_value_str(self.elements_contained_in(r))\n     }\n }\n \n-crate trait ToElementIndex: Debug + Copy {\n+pub(crate) trait ToElementIndex: Debug + Copy {\n     fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool;\n \n     fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool;\n@@ -388,7 +394,7 @@ impl ToElementIndex for ty::PlaceholderRegion {\n     }\n }\n \n-crate fn location_set_str(\n+pub(crate) fn location_set_str(\n     elements: &RegionValueElements,\n     points: impl IntoIterator<Item = PointIndex>,\n ) -> String {"}, {"sha": "f11a94d7ddd2333d815a5292926ba145282fb7b6", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -18,7 +18,7 @@ use crate::{\n     universal_regions::UniversalRegions,\n };\n \n-crate struct ConstraintConversion<'a, 'tcx> {\n+pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n@@ -32,7 +32,7 @@ crate struct ConstraintConversion<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,"}, {"sha": "670b5549afc1d7a9c3cab156261e98e7f7fc8859", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -19,7 +19,7 @@ use crate::{\n };\n \n #[derive(Debug)]\n-crate struct UniversalRegionRelations<'tcx> {\n+pub(crate) struct UniversalRegionRelations<'tcx> {\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Stores the outlives relations that are known to hold from the\n@@ -52,13 +52,13 @@ type RegionBoundPairs<'tcx> = Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>;\n /// then the output type as the last element.\n type NormalizedInputsAndOutput<'tcx> = Vec<Ty<'tcx>>;\n \n-crate struct CreateResult<'tcx> {\n-    crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate region_bound_pairs: RegionBoundPairs<'tcx>,\n-    crate normalized_inputs_and_output: NormalizedInputsAndOutput<'tcx>,\n+pub(crate) struct CreateResult<'tcx> {\n+    pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n+    pub(crate) region_bound_pairs: RegionBoundPairs<'tcx>,\n+    pub(crate) normalized_inputs_and_output: NormalizedInputsAndOutput<'tcx>,\n }\n \n-crate fn create<'tcx>(\n+pub(crate) fn create<'tcx>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n@@ -96,7 +96,7 @@ impl UniversalRegionRelations<'_> {\n     ///\n     /// (See `TransitiveRelation::postdom_upper_bound` for details on\n     /// the postdominating upper bound in general.)\n-    crate fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n+    pub(crate) fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n         assert!(self.universal_regions.is_universal_region(fr1));\n         assert!(self.universal_regions.is_universal_region(fr2));\n         self.inverse_outlives\n@@ -109,7 +109,7 @@ impl UniversalRegionRelations<'_> {\n     /// outlives `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we return all of them.\n-    crate fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n+    pub(crate) fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n         let res = self.non_local_bounds(&self.inverse_outlives, fr);\n         assert!(!res.is_empty(), \"can't find an upper bound!?\");\n@@ -118,7 +118,7 @@ impl UniversalRegionRelations<'_> {\n \n     /// Returns the \"postdominating\" bound of the set of\n     /// `non_local_upper_bounds` for the given region.\n-    crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n         let upper_bounds = self.non_local_upper_bounds(fr);\n \n         // In case we find more than one, reduce to one for\n@@ -147,7 +147,7 @@ impl UniversalRegionRelations<'_> {\n     ///\n     /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n-    crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+    pub(crate) fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n         let lower_bounds = self.non_local_bounds(&self.outlives, fr);\n \n@@ -203,18 +203,18 @@ impl UniversalRegionRelations<'_> {\n     /// Returns `true` if fr1 is known to outlive fr2.\n     ///\n     /// This will only ever be true for universally quantified regions.\n-    crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+    pub(crate) fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n         self.outlives.contains(fr1, fr2)\n     }\n \n     /// Returns a vector of free regions `x` such that `fr1: x` is\n     /// known to hold.\n-    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<RegionVid> {\n+    pub(crate) fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<RegionVid> {\n         self.outlives.reachable_from(fr1)\n     }\n \n     /// Returns the _non-transitive_ set of known `outlives` constraints between free regions.\n-    crate fn known_outlives(&self) -> impl Iterator<Item = (RegionVid, RegionVid)> + '_ {\n+    pub(crate) fn known_outlives(&self) -> impl Iterator<Item = (RegionVid, RegionVid)> + '_ {\n         self.outlives.base_edges()\n     }\n }\n@@ -232,7 +232,7 @@ struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n }\n \n impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n-    crate fn create(mut self) -> CreateResult<'tcx> {\n+    pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n         let unnormalized_input_output_tys = self\n             .universal_regions\n             .unnormalized_input_tys"}, {"sha": "b88f6e689cc80c4a334bbf3879db4dbaf9c6b4d9", "filename": "compiler/rustc_borrowck/src/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -18,7 +18,7 @@ use crate::region_infer::values::{PointIndex, RegionValueElements};\n /// (and code simplicity) was favored. The rationale is that we only keep\n /// a small number of `IndexVec`s throughout the entire analysis while, in\n /// contrast, we're accessing each `Local` *many* times.\n-crate struct LocalUseMap {\n+pub(crate) struct LocalUseMap {\n     /// Head of a linked list of **definitions** of each variable --\n     /// definition in this context means assignment, e.g., `x` is\n     /// defined in `x = y` but not `y`; that first def is the head of\n@@ -58,7 +58,11 @@ impl vll::LinkElem for Appearance {\n }\n \n impl LocalUseMap {\n-    crate fn build(live_locals: &[Local], elements: &RegionValueElements, body: &Body<'_>) -> Self {\n+    pub(crate) fn build(\n+        live_locals: &[Local],\n+        elements: &RegionValueElements,\n+        body: &Body<'_>,\n+    ) -> Self {\n         let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),\n@@ -81,17 +85,17 @@ impl LocalUseMap {\n         local_use_map\n     }\n \n-    crate fn defs(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn defs(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_def_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn uses(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn uses(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_use_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }\n \n-    crate fn drops(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n+    pub(crate) fn drops(&self, local: Local) -> impl Iterator<Item = PointIndex> + '_ {\n         vll::iter(self.first_drop_at[local], &self.appearances)\n             .map(move |aa| self.appearances[aa].point_index)\n     }"}, {"sha": "405fd9198d354a1dffee44bdb4247704ca9cf3e9", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -94,7 +94,7 @@ mod canonical;\n mod constraint_conversion;\n pub mod free_region_relations;\n mod input_output;\n-crate mod liveness;\n+pub(crate) mod liveness;\n mod relate_tys;\n \n /// Type checks the given `mir` in the context of the inference\n@@ -897,28 +897,29 @@ struct BorrowCheckContext<'a, 'tcx> {\n     upvars: &'a [Upvar<'tcx>],\n }\n \n-crate struct MirTypeckResults<'tcx> {\n-    crate constraints: MirTypeckRegionConstraints<'tcx>,\n-    crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+pub(crate) struct MirTypeckResults<'tcx> {\n+    pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n+    pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n+    pub(crate) opaque_type_values:\n+        VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n /// program to be considered well-typed.\n-crate struct MirTypeckRegionConstraints<'tcx> {\n+pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     /// Maps from a `ty::Placeholder` to the corresponding\n     /// `PlaceholderIndex` bit that we will use for it.\n     ///\n     /// To keep everything in sync, do not insert this set\n     /// directly. Instead, use the `placeholder_region` helper.\n-    crate placeholder_indices: PlaceholderIndices,\n+    pub(crate) placeholder_indices: PlaceholderIndices,\n \n     /// Each time we add a placeholder to `placeholder_indices`, we\n     /// also create a corresponding \"representative\" region vid for\n     /// that wraps it. This vector tracks those. This way, when we\n     /// convert the same `ty::RePlaceholder(p)` twice, we can map to\n     /// the same underlying `RegionVid`.\n-    crate placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n+    pub(crate) placeholder_index_to_region: IndexVec<PlaceholderIndex, ty::Region<'tcx>>,\n \n     /// In general, the type-checker is not responsible for enforcing\n     /// liveness constraints; this job falls to the region inferencer,\n@@ -927,18 +928,18 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_constraints: LivenessValues<RegionVid>,\n+    pub(crate) liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: OutlivesConstraintSet<'tcx>,\n+    pub(crate) outlives_constraints: OutlivesConstraintSet<'tcx>,\n \n-    crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n+    pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    crate closure_bounds_mapping:\n+    pub(crate) closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n-    crate universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n-    crate type_tests: Vec<TypeTest<'tcx>>,\n+    pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n }\n \n impl<'tcx> MirTypeckRegionConstraints<'tcx> {"}, {"sha": "7b63ec516b8c44c4561190cf9be2558bde94bb63", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -336,7 +336,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// that this region imposes on others. The methods in this file\n     /// handle the part about dumping the inference context internal\n     /// state.\n-    crate fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n+    pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         match self.defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 err.note(&format!("}, {"sha": "cdbb60b878a6cfd04210928a74d5533a8cdcfa35", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -22,7 +22,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///  been assigned to - this set is used as a proxy for locals that were not initialized due to\n     ///  unreachable code. These locals are then considered \"used\" to silence the lint for them.\n     ///  See #55344 for context.\n-    crate fn gather_used_muts(\n+    pub(crate) fn gather_used_muts(\n         &mut self,\n         temporary_used_locals: FxHashSet<Local>,\n         mut never_initialized_mut_locals: FxHashSet<Local>,"}, {"sha": "cb5359dd1e27e6b6bfc9c58337ccf0c07ce5b417", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,7 @@ use rustc_parse::validate_attr;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-crate struct Expander;\n+pub(crate) struct Expander;\n \n fn validate_input<'a>(ecx: &mut ExtCtxt<'_>, mi: &'a ast::MetaItem) -> Option<&'a ast::Path> {\n     match mi.meta_item_list() {"}, {"sha": "6485c82a119e2c00d0ce8e25abd5fcb38d1ea42a", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -19,7 +19,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use smallvec::SmallVec;\n \n-crate fn expand(\n+pub(crate) fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     _span: Span,\n     meta_item: &ast::MetaItem,\n@@ -30,7 +30,7 @@ crate fn expand(\n     vec![cfg_eval(ecx.sess, ecx.ecfg.features, annotatable, ecx.current_expansion.lint_node_id)]\n }\n \n-crate fn cfg_eval(\n+pub(crate) fn cfg_eval(\n     sess: &Session,\n     features: Option<&Features>,\n     annotatable: Annotatable,"}, {"sha": "7f25b23734b3eb20a9e3b6c483e69bba4300c835", "filename": "compiler/rustc_builtin_macros/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderive.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,7 +10,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n-crate struct Expander;\n+pub(crate) struct Expander;\n \n impl MultiItemModifier for Expander {\n     fn expand("}, {"sha": "c678c8cbd159ee8f54e138f2b7dc8d33fbc05b1e", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -38,8 +38,8 @@ pub mod partial_ord;\n \n pub mod generic;\n \n-crate struct BuiltinDerive(\n-    crate fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n+pub(crate) struct BuiltinDerive(\n+    pub(crate) fn(&mut ExtCtxt<'_>, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable)),\n );\n \n impl MultiItemModifier for BuiltinDerive {"}, {"sha": "0c9e3c22bcf3c43a875b91559b2bcc44e45733bd", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -4,7 +4,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(is_sorted)]\n #![feature(nll)]"}, {"sha": "c7497bfd355e5f042192ca9e067bf5a3929e2df4", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -354,14 +354,14 @@ fn fat_lto(\n     Ok(LtoModuleCodegen::Fat { module, _serialized_bitcode: serialized_bitcode })\n }\n \n-crate struct Linker<'a>(&'a mut llvm::Linker<'a>);\n+pub(crate) struct Linker<'a>(&'a mut llvm::Linker<'a>);\n \n impl<'a> Linker<'a> {\n-    crate fn new(llmod: &'a llvm::Module) -> Self {\n+    pub(crate) fn new(llmod: &'a llvm::Module) -> Self {\n         unsafe { Linker(llvm::LLVMRustLinkerNew(llmod)) }\n     }\n \n-    crate fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n+    pub(crate) fn add(&mut self, bytecode: &[u8]) -> Result<(), ()> {\n         unsafe {\n             if llvm::LLVMRustLinkerAdd(\n                 self.0,"}, {"sha": "839018e2a759f880289c8608eba7524f19aa9cb1", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1412,7 +1412,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildVAArg(self.llbuilder, list, ty, UNNAMED) }\n     }\n \n-    crate fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n+    pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n         self.call(ty, f, args, None)\n     }"}, {"sha": "5bbbfe9a4ab781ae7843bf9b955c7fe713097271", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -212,11 +212,11 @@ pub fn ptrcast<'ll>(val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+    pub(crate) fn const_bitcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {\n         unsafe { llvm::LLVMConstBitCast(val, ty) }\n     }\n \n-    crate fn static_addr_of_mut(\n+    pub(crate) fn static_addr_of_mut(\n         &self,\n         cv: &'ll Value,\n         align: Align,\n@@ -241,7 +241,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn get_static(&self, def_id: DefId) -> &'ll Value {\n+    pub(crate) fn get_static(&self, def_id: DefId) -> &'ll Value {\n         let instance = Instance::mono(self.tcx, def_id);\n         if let Some(&g) = self.instances.borrow().get(&instance) {\n             return g;"}, {"sha": "5544f0d3f6058c0ebe9384d35bb66fe87cd94197", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -330,7 +330,7 @@ pub unsafe fn create_module<'ll>(\n }\n \n impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         codegen_unit: &'tcx CodegenUnit<'tcx>,\n         llvm_module: &'ll crate::ModuleLlvm,\n@@ -447,7 +447,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    crate fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n+    pub(crate) fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n         &self.statics_to_rauw\n     }\n \n@@ -599,7 +599,7 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn get_intrinsic(&self, key: &str) -> (&'ll Type, &'ll Value) {\n+    pub(crate) fn get_intrinsic(&self, key: &str) -> (&'ll Type, &'ll Value) {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n@@ -890,7 +890,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         None\n     }\n \n-    crate fn eh_catch_typeinfo(&self) -> &'ll Value {\n+    pub(crate) fn eh_catch_typeinfo(&self) -> &'ll Value {\n         if let Some(eh_catch_typeinfo) = self.eh_catch_typeinfo.get() {\n             return eh_catch_typeinfo;\n         }"}, {"sha": "2b5154a2cf97787b24ea9f7880689f3da1b8f181", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(extern_types)]"}, {"sha": "37409dbb447005486acc686409a8f1271e2b5ee5", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -775,7 +775,7 @@ pub mod coverageinfo {\n     }\n \n     impl CounterMappingRegion {\n-        crate fn code_region(\n+        pub(crate) fn code_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,\n@@ -799,7 +799,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn branch_region(\n+        pub(crate) fn branch_region(\n             counter: coverage_map::Counter,\n             false_counter: coverage_map::Counter,\n             file_id: u32,\n@@ -824,7 +824,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn expansion_region(\n+        pub(crate) fn expansion_region(\n             file_id: u32,\n             expanded_file_id: u32,\n             start_line: u32,\n@@ -848,7 +848,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn skipped_region(\n+        pub(crate) fn skipped_region(\n             file_id: u32,\n             start_line: u32,\n             start_col: u32,\n@@ -871,7 +871,7 @@ pub mod coverageinfo {\n         // This function might be used in the future; the LLVM API is still evolving, as is coverage\n         // support.\n         #[allow(dead_code)]\n-        crate fn gap_region(\n+        pub(crate) fn gap_region(\n             counter: coverage_map::Counter,\n             file_id: u32,\n             start_line: u32,"}, {"sha": "cf2d3c423c335f6e1a674efcd7907e6c7ce994f1", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -39,33 +39,33 @@ impl fmt::Debug for Type {\n }\n \n impl<'ll> CodegenCx<'ll, '_> {\n-    crate fn type_named_struct(&self, name: &str) -> &'ll Type {\n+    pub(crate) fn type_named_struct(&self, name: &str) -> &'ll Type {\n         let name = SmallCStr::new(name);\n         unsafe { llvm::LLVMStructCreateNamed(self.llcx, name.as_ptr()) }\n     }\n \n-    crate fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n+    pub(crate) fn set_struct_body(&self, ty: &'ll Type, els: &[&'ll Type], packed: bool) {\n         unsafe { llvm::LLVMStructSetBody(ty, els.as_ptr(), els.len() as c_uint, packed as Bool) }\n     }\n \n-    crate fn type_void(&self) -> &'ll Type {\n+    pub(crate) fn type_void(&self) -> &'ll Type {\n         unsafe { llvm::LLVMVoidTypeInContext(self.llcx) }\n     }\n \n-    crate fn type_metadata(&self) -> &'ll Type {\n+    pub(crate) fn type_metadata(&self) -> &'ll Type {\n         unsafe { llvm::LLVMRustMetadataTypeInContext(self.llcx) }\n     }\n \n     ///x Creates an integer type with the given number of bits, e.g., i24\n-    crate fn type_ix(&self, num_bits: u64) -> &'ll Type {\n+    pub(crate) fn type_ix(&self, num_bits: u64) -> &'ll Type {\n         unsafe { llvm::LLVMIntTypeInContext(self.llcx, num_bits as c_uint) }\n     }\n \n-    crate fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    pub(crate) fn type_vector(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe { llvm::LLVMVectorType(ty, len as c_uint) }\n     }\n \n-    crate fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n+    pub(crate) fn func_params_types(&self, ty: &'ll Type) -> Vec<&'ll Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(ty) as usize;\n             let mut args = Vec::with_capacity(n_args);\n@@ -75,11 +75,11 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_bool(&self) -> &'ll Type {\n+    pub(crate) fn type_bool(&self) -> &'ll Type {\n         self.type_i8()\n     }\n \n-    crate fn type_int_from_ty(&self, t: ty::IntTy) -> &'ll Type {\n+    pub(crate) fn type_int_from_ty(&self, t: ty::IntTy) -> &'ll Type {\n         match t {\n             ty::IntTy::Isize => self.type_isize(),\n             ty::IntTy::I8 => self.type_i8(),\n@@ -90,7 +90,7 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_uint_from_ty(&self, t: ty::UintTy) -> &'ll Type {\n+    pub(crate) fn type_uint_from_ty(&self, t: ty::UintTy) -> &'ll Type {\n         match t {\n             ty::UintTy::Usize => self.type_isize(),\n             ty::UintTy::U8 => self.type_i8(),\n@@ -101,34 +101,34 @@ impl<'ll> CodegenCx<'ll, '_> {\n         }\n     }\n \n-    crate fn type_float_from_ty(&self, t: ty::FloatTy) -> &'ll Type {\n+    pub(crate) fn type_float_from_ty(&self, t: ty::FloatTy) -> &'ll Type {\n         match t {\n             ty::FloatTy::F32 => self.type_f32(),\n             ty::FloatTy::F64 => self.type_f64(),\n         }\n     }\n \n-    crate fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n+    pub(crate) fn type_pointee_for_align(&self, align: Align) -> &'ll Type {\n         // FIXME(eddyb) We could find a better approximation if ity.align < align.\n         let ity = Integer::approximate_align(self, align);\n         self.type_from_integer(ity)\n     }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    crate fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n+    pub(crate) fn type_padding_filler(&self, size: Size, align: Align) -> &'ll Type {\n         let unit = Integer::approximate_align(self, align);\n         let size = size.bytes();\n         let unit_size = unit.size().bytes();\n         assert_eq!(size % unit_size, 0);\n         self.type_array(self.type_from_integer(unit), size / unit_size)\n     }\n \n-    crate fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n+    pub(crate) fn type_variadic_func(&self, args: &[&'ll Type], ret: &'ll Type) -> &'ll Type {\n         unsafe { llvm::LLVMFunctionType(ret, args.as_ptr(), args.len() as c_uint, True) }\n     }\n \n-    crate fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n+    pub(crate) fn type_array(&self, ty: &'ll Type, len: u64) -> &'ll Type {\n         unsafe { llvm::LLVMRustArrayType(ty, len) }\n     }\n }"}, {"sha": "9e5b00462f3a6e1008c5b3b3077194243661e006", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -163,7 +163,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n+pub(crate) type CompileTimeEvalContext<'mir, 'tcx> =\n     InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]"}, {"sha": "5e0d1abd6c1df2639bb1edc66ed1de5da74141e4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -44,7 +44,7 @@ fn numeric_intrinsic<Tag>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<T\n \n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n /// inside an `InterpCx` and instead have their value computed directly from rustc internal info.\n-crate fn eval_nullary_intrinsic<'tcx>(\n+pub(crate) fn eval_nullary_intrinsic<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     def_id: DefId,"}, {"sha": "e66cb9837c999d9ef02b780ea24a9d99f386a5dc", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,7 +15,7 @@ use crate::interpret::{\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Walks up the callstack from the intrinsic's callsite, searching for the first callsite in a\n     /// frame which is not `#[track_caller]`.\n-    crate fn find_closest_untracked_caller_location(&self) -> Span {\n+    pub(crate) fn find_closest_untracked_caller_location(&self) -> Span {\n         for frame in self.stack().iter().rev() {\n             debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n \n@@ -74,7 +74,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Allocate a `const core::panic::Location` with the provided filename and line/column numbers.\n-    crate fn alloc_caller_location(\n+    pub(crate) fn alloc_caller_location(\n         &mut self,\n         filename: Symbol,\n         line: u32,\n@@ -113,7 +113,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    crate fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n+    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "f9847742f0883c8af1e53b5fa3895e0bdf6c658d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -189,7 +189,7 @@ impl Write for AbsolutePathPrinter<'_> {\n }\n \n /// Directly returns an `Allocation` containing an absolute path representation of the given type.\n-crate fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n+pub(crate) fn alloc_type_name<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ConstAllocation<'tcx> {\n     let path = AbsolutePathPrinter { tcx, path: String::new() }.print_type(ty).unwrap().path;\n     let alloc = Allocation::from_bytes_byte_aligned_immutable(path.into_bytes());\n     tcx.intern_const_alloc(alloc)"}, {"sha": "2b73ad568e0eedc8fa8953edb1d4836bdb37be4f", "filename": "compiler/rustc_const_eval/src/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -29,5 +29,5 @@ pub use self::place::{MPlaceTy, MemPlace, MemPlaceMeta, Place, PlaceTy};\n pub use self::validity::{CtfeValidationMode, RefTracking};\n pub use self::visitor::{MutValueVisitor, Value, ValueVisitor};\n \n-crate use self::intrinsics::eval_nullary_intrinsic;\n+pub(crate) use self::intrinsics::eval_nullary_intrinsic;\n use eval_context::{from_known_layout, mir_assign_valid_types};"}, {"sha": "f5e1ee4e233153a65aa56b626f61adebe5e22b15", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -643,7 +643,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    crate fn const_val_to_op(\n+    pub(crate) fn const_val_to_op(\n         &self,\n         val_val: ConstValue<'tcx>,\n         ty: Ty<'tcx>,"}, {"sha": "1940b573db0d6e4842b33117d45d1f0ffa846db3", "filename": "compiler/rustc_const_eval/src/interpret/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Futil.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use std::ops::ControlFlow;\n /// In case it does, returns a `TooGeneric` const eval error. Note that due to polymorphization\n /// types may be \"concrete enough\" even though they still contain generic parameters in\n /// case these parameters are unused.\n-crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n+pub(crate) fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n where\n     T: TypeFoldable<'tcx>,\n {"}, {"sha": "eacb5978d993a18dcc76afd0abd17c025689fd5e", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(let_else)]"}, {"sha": "f130b5aa9a6b17244d4e140ea76709dba39c016d", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -90,7 +90,7 @@ pub trait AddSubdiagnostic {\n pub struct Diagnostic {\n     // NOTE(eddyb) this is private to disallow arbitrary after-the-fact changes,\n     // outside of what methods in this crate themselves allow.\n-    crate level: Level,\n+    pub(crate) level: Level,\n \n     pub message: Vec<(DiagnosticMessage, Style)>,\n     pub code: Option<DiagnosticId>,"}, {"sha": "6ef2c832c6526166f9a41e6bdda16d4412756ed2", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -88,7 +88,7 @@ mod sealed_level_is_error {\n     use crate::Level;\n \n     /// Sealed helper trait for statically checking that a `Level` is an error.\n-    crate trait IsError<const L: Level> {}\n+    pub(crate) trait IsError<const L: Level> {}\n \n     impl IsError<{ Level::Bug }> for () {}\n     impl IsError<{ Level::DelayedBug }> for () {}\n@@ -101,7 +101,7 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n+    pub(crate) fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n         handler: &'a Handler,\n         message: M,\n     ) -> Self\n@@ -168,7 +168,7 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new<M: Into<DiagnosticMessage>>(\n+    pub(crate) fn new<M: Into<DiagnosticMessage>>(\n         handler: &'a Handler,\n         level: Level,\n         message: M,\n@@ -179,7 +179,7 @@ impl<'a> DiagnosticBuilder<'a, ()> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+    pub(crate) fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n             inner: DiagnosticBuilderInner {\n@@ -210,14 +210,14 @@ impl EmissionGuarantee for () {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+    pub(crate) fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)\n     }\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    crate fn new_diagnostic_fatal(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+    pub(crate) fn new_diagnostic_fatal(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n         debug!(\"Created new diagnostic\");\n         Self {\n             inner: DiagnosticBuilderInner {"}, {"sha": "d2f50d5df54655aed349625e87a4df56f7050409", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,7 +3,6 @@\n //! This module contains the code for creating and emitting diagnostics.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(backtrace)]\n #![feature(if_let_guard)]"}, {"sha": "6ef03d1243d1d060b60882feb20b733396dc9a87", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -28,7 +28,7 @@ use std::iter;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n-crate use rustc_span::hygiene::MacroKind;\n+pub(crate) use rustc_span::hygiene::MacroKind;\n \n // When adding new variants, make sure to\n // adjust the `visit_*` / `flat_map_*` calls in `InvocationCollector`"}, {"sha": "3cada372570851c44e7dfe48c5fd640061ca286d", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -347,7 +347,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    crate fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n+    pub(crate) fn expand_cfg_attr(&self, attr: Attribute, recursive: bool) -> Vec<Attribute> {\n         let Some((cfg_predicate, expanded_attrs)) =\n             rustc_parse::parse_cfg_attr(&attr, &self.sess.parse_sess) else {\n                 return vec![];\n@@ -451,7 +451,7 @@ impl<'a> StripUnconfigured<'a> {\n         attrs.iter().all(|attr| !is_cfg(attr) || self.cfg_true(attr))\n     }\n \n-    crate fn cfg_true(&self, attr: &Attribute) -> bool {\n+    pub(crate) fn cfg_true(&self, attr: &Attribute) -> bool {\n         let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n             Ok(meta_item) => meta_item,\n             Err(mut err) => {\n@@ -465,7 +465,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    crate fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n+    pub(crate) fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n                 &self.sess.parse_sess,"}, {"sha": "676abc92b633fd77b948cd06f4ab1c73ae2f7cdc", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -214,7 +214,7 @@ pub enum SupportsMacroExpansion {\n }\n \n impl AstFragmentKind {\n-    crate fn dummy(self, span: Span) -> AstFragment {\n+    pub(crate) fn dummy(self, span: Span) -> AstFragment {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n "}, {"sha": "7043ad5464530391711ebf3658520d4d3dced6f3", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]\n@@ -21,7 +20,7 @@ mod placeholders;\n mod proc_macro_server;\n \n pub use mbe::macro_rules::compile_declarative_macro;\n-crate use rustc_span::hygiene;\n+pub(crate) use rustc_span::hygiene;\n pub mod base;\n pub mod build;\n #[macro_use]\n@@ -30,7 +29,7 @@ pub mod expand;\n pub mod module;\n pub mod proc_macro;\n \n-crate mod mbe;\n+pub(crate) mod mbe;\n \n // HACK(Centril, #64197): These shouldn't really be here.\n // Rather, they should be with their respective modules which are defined in other crates."}, {"sha": "f42576b16f5204d13f2a2ed69c6d34b8c0eb0e19", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,12 +3,12 @@\n //! why we call this module `mbe`. For external documentation, prefer the\n //! official terminology: \"declarative macros\".\n \n-crate mod macro_check;\n-crate mod macro_parser;\n-crate mod macro_rules;\n-crate mod metavar_expr;\n-crate mod quoted;\n-crate mod transcribe;\n+pub(crate) mod macro_check;\n+pub(crate) mod macro_parser;\n+pub(crate) mod macro_rules;\n+pub(crate) mod metavar_expr;\n+pub(crate) mod quoted;\n+pub(crate) mod transcribe;\n \n use metavar_expr::MetaVarExpr;\n use rustc_ast::token::{Delimiter, NonterminalKind, Token, TokenKind};"}, {"sha": "0631a5e42c25d730bd282165d718b1ef25176566", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -70,8 +70,8 @@\n //! eof: [a $( a )* a b \u00b7]\n //! ```\n \n-crate use NamedMatch::*;\n-crate use ParseResult::*;\n+pub(crate) use NamedMatch::*;\n+pub(crate) use ParseResult::*;\n \n use crate::mbe::{KleeneOp, TokenTree};\n \n@@ -262,7 +262,7 @@ enum EofMatcherPositions {\n }\n \n /// Represents the possible results of an attempted parse.\n-crate enum ParseResult<T> {\n+pub(crate) enum ParseResult<T> {\n     /// Parsed successfully.\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n@@ -276,7 +276,7 @@ crate enum ParseResult<T> {\n /// A `ParseResult` where the `Success` variant contains a mapping of\n /// `MacroRulesNormalizedIdent`s to `NamedMatch`es. This represents the mapping\n /// of metavars to the token trees they bind to.\n-crate type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n+pub(crate) type NamedParseResult = ParseResult<FxHashMap<MacroRulesNormalizedIdent, NamedMatch>>;\n \n /// Count how many metavars declarations are in `matcher`.\n pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n@@ -340,7 +340,7 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n /// ])\n /// ```\n #[derive(Debug, Clone)]\n-crate enum NamedMatch {\n+pub(crate) enum NamedMatch {\n     MatchedSeq(Vec<NamedMatch>),\n \n     // A metavar match of type `tt`."}, {"sha": "b16fa7111c51941236bf430345260128aee3d66b", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -33,7 +33,7 @@ use std::collections::hash_map::Entry;\n use std::{mem, slice};\n use tracing::debug;\n \n-crate struct ParserAnyMacro<'a> {\n+pub(crate) struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n     /// Span of the expansion site of the macro this parser is for\n@@ -47,7 +47,7 @@ crate struct ParserAnyMacro<'a> {\n     is_local: bool,\n }\n \n-crate fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n+pub(crate) fn annotate_err_with_kind(err: &mut Diagnostic, kind: AstFragmentKind, span: Span) {\n     match kind {\n         AstFragmentKind::Ty => {\n             err.span_label(span, \"this macro call doesn't expand to a type\");\n@@ -113,7 +113,7 @@ fn emit_frag_parse_err(\n }\n \n impl<'a> ParserAnyMacro<'a> {\n-    crate fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n+    pub(crate) fn make(mut self: Box<ParserAnyMacro<'a>>, kind: AstFragmentKind) -> AstFragment {\n         let ParserAnyMacro {\n             site_span,\n             macro_ident,"}, {"sha": "ccc1c2b2ca05b37d81b27c23b08adf4dd9d2595c", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::Span;\n \n /// A meta-variable expression, for expansions based on properties of meta-variables.\n #[derive(Debug, Clone, PartialEq, Encodable, Decodable)]\n-crate enum MetaVarExpr {\n+pub(crate) enum MetaVarExpr {\n     /// The number of repetitions of an identifier, optionally limited to a number\n     /// of outer-most repetition depths. If the depth limit is `None` then the depth is unlimited.\n     Count(Ident, Option<usize>),\n@@ -28,7 +28,7 @@ crate enum MetaVarExpr {\n \n impl MetaVarExpr {\n     /// Attempt to parse a meta-variable expression from a token stream.\n-    crate fn parse<'sess>(\n+    pub(crate) fn parse<'sess>(\n         input: &TokenStream,\n         outer_span: Span,\n         sess: &'sess ParseSess,\n@@ -62,7 +62,7 @@ impl MetaVarExpr {\n         Ok(rslt)\n     }\n \n-    crate fn ident(&self) -> Option<Ident> {\n+    pub(crate) fn ident(&self) -> Option<Ident> {\n         match *self {\n             MetaVarExpr::Count(ident, _) | MetaVarExpr::Ignore(ident) => Some(ident),\n             MetaVarExpr::Index(..) | MetaVarExpr::Length(..) => None,"}, {"sha": "876faad33b678d2e4aa9bc6a3008080e9e63ccd6", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -26,7 +26,7 @@ pub struct ModulePathSuccess {\n     pub dir_ownership: DirOwnership,\n }\n \n-crate struct ParsedExternalMod {\n+pub(crate) struct ParsedExternalMod {\n     pub items: Vec<P<Item>>,\n     pub spans: ModSpans,\n     pub file_path: PathBuf,\n@@ -42,7 +42,7 @@ pub enum ModError<'a> {\n     ParserError(DiagnosticBuilder<'a, ErrorGuaranteed>),\n }\n \n-crate fn parse_external_mod(\n+pub(crate) fn parse_external_mod(\n     sess: &Session,\n     ident: Ident,\n     span: Span, // The span to blame on errors.\n@@ -78,7 +78,7 @@ crate fn parse_external_mod(\n     ParsedExternalMod { items, spans, file_path, dir_path, dir_ownership }\n }\n \n-crate fn mod_dir_path(\n+pub(crate) fn mod_dir_path(\n     sess: &Session,\n     ident: Ident,\n     attrs: &[Attribute],"}, {"sha": "8b7153776e4dc6580aef89db7bc4afa6973aada3", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -22,7 +22,7 @@ fn string_to_parser(ps: &ParseSess, source_str: String) -> Parser<'_> {\n     new_parser_from_source_str(ps, PathBuf::from(\"bogofile\").into(), source_str)\n }\n \n-crate fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n+pub(crate) fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n where\n     F: FnOnce(&mut Parser<'a>) -> PResult<'a, T>,\n {\n@@ -33,7 +33,7 @@ where\n }\n \n /// Maps a string to tts, using a made-up filename.\n-crate fn string_to_stream(source_str: String) -> TokenStream {\n+pub(crate) fn string_to_stream(source_str: String) -> TokenStream {\n     let ps = ParseSess::new(FilePathMapping::empty());\n     source_file_to_stream(\n         &ps,\n@@ -44,7 +44,7 @@ crate fn string_to_stream(source_str: String) -> TokenStream {\n }\n \n /// Parses a string, returns a crate.\n-crate fn string_to_crate(source_str: String) -> ast::Crate {\n+pub(crate) fn string_to_crate(source_str: String) -> ast::Crate {\n     let ps = ParseSess::new(FilePathMapping::empty());\n     with_error_checking_parse(source_str, &ps, |p| p.parse_crate_mod())\n }\n@@ -53,7 +53,7 @@ crate fn string_to_crate(source_str: String) -> ast::Crate {\n /// may be deleted or replaced with other whitespace to match the pattern.\n /// This function is relatively Unicode-ignorant; fortunately, the careful design\n /// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n-crate fn matches_codepattern(a: &str, b: &str) -> bool {\n+pub(crate) fn matches_codepattern(a: &str, b: &str) -> bool {\n     let mut a_iter = a.chars().peekable();\n     let mut b_iter = b.chars().peekable();\n \n@@ -109,7 +109,7 @@ struct SpanLabel {\n     label: &'static str,\n }\n \n-crate struct Shared<T: Write> {\n+pub(crate) struct Shared<T: Write> {\n     pub data: Arc<Mutex<T>>,\n }\n "}, {"sha": "2e077ae2440724db16c84b379fa2313723009e30", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-crate use crate::hir_id::{HirId, ItemLocalId};\n+pub(crate) use crate::hir_id::{HirId, ItemLocalId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n "}, {"sha": "7833571f88d4348efdf242cbdcd1859a2b1a7d3d", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -4,7 +4,6 @@\n \n #![feature(associated_type_defaults)]\n #![feature(const_btree_new)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(min_specialization)]"}, {"sha": "3d50ed2096e50e1da474c1a17e5515fbb092b825", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2705,7 +2705,7 @@ impl SymbolName {\n }\n \n impl ClashingExternDeclarations {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         ClashingExternDeclarations { seen_decls: FxHashMap::default() }\n     }\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists"}, {"sha": "772ab7fe22608248949ac523d3907b14e18df8b9", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -34,7 +34,7 @@ use tracing::debug;\n \n /// Extract the `LintStore` from the query context.\n /// This function exists because we've erased `LintStore` as `dyn Any` in the context.\n-crate fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n+pub(crate) fn unerased_lint_store(tcx: TyCtxt<'_>) -> &LintStore {\n     let store: &dyn Any = &*tcx.lint_store;\n     store.downcast_ref().unwrap()\n }"}, {"sha": "7c68429e1e902dc2b5277340e14526253e9688cd", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -30,7 +30,6 @@\n #![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(iter_intersperse)]\n #![feature(iter_order_by)]"}, {"sha": "55b1ba9cd964a5b80cf987d0767ff0ca049dd785", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -651,7 +651,7 @@ declare_lint! {\n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n #[derive(Clone, Copy)]\n-crate enum CItemKind {\n+pub(crate) enum CItemKind {\n     Declaration,\n     Definition,\n }\n@@ -667,7 +667,10 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+pub(crate) fn nonnull_optimization_guaranteed<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def: ty::AdtDef<'tcx>,\n+) -> bool {\n     tcx.has_attr(def.did(), sym::rustc_nonnull_optimization_guaranteed)\n }\n \n@@ -766,7 +769,7 @@ fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n /// FIXME: This duplicates code in codegen.\n-crate fn repr_nullable_ptr<'tcx>(\n+pub(crate) fn repr_nullable_ptr<'tcx>(\n     cx: &LateContext<'tcx>,\n     ty: Ty<'tcx>,\n     ckind: CItemKind,"}, {"sha": "dfc675a0494b125c6d0463d5f8bda51356a8c767", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -70,7 +70,7 @@ pub enum LoadedMacro {\n     ProcMacro(SyntaxExtension),\n }\n \n-crate struct Library {\n+pub(crate) struct Library {\n     pub source: CrateSource,\n     pub metadata: MetadataBlob,\n }\n@@ -82,7 +82,7 @@ enum LoadResult {\n \n /// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n #[derive(Clone, Copy)]\n-crate struct CrateMetadataRef<'a> {\n+pub(crate) struct CrateMetadataRef<'a> {\n     pub cdata: &'a CrateMetadata,\n     pub cstore: &'a CStore,\n }\n@@ -133,7 +133,7 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n+    pub(crate) fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n         let cdata = self.metas[cnum]\n             .as_ref()\n             .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum));\n@@ -145,7 +145,7 @@ impl CStore {\n         self.metas[cnum] = Some(Lrc::new(data));\n     }\n \n-    crate fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n+    pub(crate) fn iter_crate_data(&self) -> impl Iterator<Item = (CrateNum, &CrateMetadata)> {\n         self.metas\n             .iter_enumerated()\n             .filter_map(|(cnum, data)| data.as_ref().map(|data| (cnum, &**data)))\n@@ -164,7 +164,7 @@ impl CStore {\n         }\n     }\n \n-    crate fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n+    pub(crate) fn crate_dependencies_in_postorder(&self, cnum: CrateNum) -> Vec<CrateNum> {\n         let mut deps = Vec::new();\n         if cnum == LOCAL_CRATE {\n             for (cnum, _) in self.iter_crate_data() {\n@@ -182,15 +182,15 @@ impl CStore {\n         deps\n     }\n \n-    crate fn injected_panic_runtime(&self) -> Option<CrateNum> {\n+    pub(crate) fn injected_panic_runtime(&self) -> Option<CrateNum> {\n         self.injected_panic_runtime\n     }\n \n-    crate fn allocator_kind(&self) -> Option<AllocatorKind> {\n+    pub(crate) fn allocator_kind(&self) -> Option<AllocatorKind> {\n         self.allocator_kind\n     }\n \n-    crate fn has_global_allocator(&self) -> bool {\n+    pub(crate) fn has_global_allocator(&self) -> bool {\n         self.has_global_allocator\n     }\n "}, {"sha": "245b2076ebca96bbadcfda0bbd9bd05162c38ce4", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -62,7 +62,7 @@ use rustc_session::cstore::CrateDepKind;\n use rustc_session::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n use rustc_target::spec::PanicStrategy;\n \n-crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+pub(crate) fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess\n         .crate_types()\n         .iter()"}, {"sha": "2ca4cd17fdf09fed0ff6ae79ba70e6049ae39f86", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::def::DefKind;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::cstore::ForeignModule;\n \n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n+pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut modules = Vec::new();\n     for id in tcx.hir().items() {\n         if !matches!(tcx.def_kind(id.def_id), DefKind::ForeignMod) {"}, {"sha": "3df18098a07fdd8b869d0120734b348a919b999f", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,4 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(generators)]"}, {"sha": "dbe53224e2aaa7180b3b2d64e5d186c328ca7409", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -239,7 +239,7 @@ use std::{cmp, fmt, fs};\n use tracing::{debug, info};\n \n #[derive(Clone)]\n-crate struct CrateLocator<'a> {\n+pub(crate) struct CrateLocator<'a> {\n     // Immutable per-session configuration.\n     only_needs_metadata: bool,\n     sysroot: &'a Path,\n@@ -260,19 +260,19 @@ crate struct CrateLocator<'a> {\n }\n \n #[derive(Clone)]\n-crate struct CratePaths {\n+pub(crate) struct CratePaths {\n     name: Symbol,\n     source: CrateSource,\n }\n \n impl CratePaths {\n-    crate fn new(name: Symbol, source: CrateSource) -> CratePaths {\n+    pub(crate) fn new(name: Symbol, source: CrateSource) -> CratePaths {\n         CratePaths { name, source }\n     }\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-crate enum CrateFlavor {\n+pub(crate) enum CrateFlavor {\n     Rlib,\n     Rmeta,\n     Dylib,\n@@ -289,7 +289,7 @@ impl fmt::Display for CrateFlavor {\n }\n \n impl<'a> CrateLocator<'a> {\n-    crate fn new(\n+    pub(crate) fn new(\n         sess: &'a Session,\n         metadata_loader: &'a dyn MetadataLoader,\n         crate_name: Symbol,\n@@ -344,7 +344,7 @@ impl<'a> CrateLocator<'a> {\n         }\n     }\n \n-    crate fn reset(&mut self) {\n+    pub(crate) fn reset(&mut self) {\n         self.crate_rejections.via_hash.clear();\n         self.crate_rejections.via_triple.clear();\n         self.crate_rejections.via_kind.clear();\n@@ -353,7 +353,7 @@ impl<'a> CrateLocator<'a> {\n         self.crate_rejections.via_invalid.clear();\n     }\n \n-    crate fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n+    pub(crate) fn maybe_load_library_crate(&mut self) -> Result<Option<Library>, CrateError> {\n         if !self.exact_paths.is_empty() {\n             return self.find_commandline_library();\n         }\n@@ -728,7 +728,7 @@ impl<'a> CrateLocator<'a> {\n         Ok(self.extract_lib(rlibs, rmetas, dylibs)?.map(|(_, lib)| lib))\n     }\n \n-    crate fn into_error(self, root: Option<CratePaths>) -> CrateError {\n+    pub(crate) fn into_error(self, root: Option<CratePaths>) -> CrateError {\n         CrateError::LocatorCombined(CombinedLocatorError {\n             crate_name: self.crate_name,\n             root,\n@@ -894,7 +894,7 @@ struct CrateRejections {\n /// Candidate rejection reasons collected during crate search.\n /// If no candidate is accepted, then these reasons are presented to the user,\n /// otherwise they are ignored.\n-crate struct CombinedLocatorError {\n+pub(crate) struct CombinedLocatorError {\n     crate_name: Symbol,\n     root: Option<CratePaths>,\n     triple: TargetTriple,\n@@ -903,7 +903,7 @@ crate struct CombinedLocatorError {\n     crate_rejections: CrateRejections,\n }\n \n-crate enum CrateError {\n+pub(crate) enum CrateError {\n     NonAsciiName(Symbol),\n     ExternLocationNotExist(Symbol, PathBuf),\n     ExternLocationNotFile(Symbol, PathBuf),\n@@ -937,7 +937,7 @@ impl fmt::Display for MetadataError<'_> {\n }\n \n impl CrateError {\n-    crate fn report(self, sess: &Session, span: Span, missing_core: bool) {\n+    pub(crate) fn report(self, sess: &Session, span: Span, missing_core: bool) {\n         let mut diag = match self {\n             CrateError::NonAsciiName(crate_name) => sess.struct_span_err(\n                 span,"}, {"sha": "8d044be195ae6113f4a1821217d12816ed72236a", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,7 +12,7 @@ use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n-crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n+pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     let mut collector = Collector { tcx, libs: Vec::new() };\n     for id in tcx.hir().items() {\n         collector.process_item(id);\n@@ -21,7 +21,7 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<NativeLib> {\n     collector.libs\n }\n \n-crate fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n+pub(crate) fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     match lib.cfg {\n         Some(ref cfg) => attr::cfg_matches(cfg, &sess.parse_sess, CRATE_NODE_ID, None),\n         None => true,"}, {"sha": "4038af38a2cbe898fdba1c24d6ad90717486f157", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -57,7 +57,7 @@ mod cstore_impl;\n /// A `MetadataBlob` internally is just a reference counted pointer to\n /// the actual data, so cloning it is cheap.\n #[derive(Clone)]\n-crate struct MetadataBlob(Lrc<MetadataRef>);\n+pub(crate) struct MetadataBlob(Lrc<MetadataRef>);\n \n // This is needed so we can create an OwningRef into the blob.\n // The data behind a `MetadataBlob` has a stable address because it is\n@@ -78,9 +78,9 @@ impl std::ops::Deref for MetadataBlob {\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-crate type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n+pub(crate) type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n \n-crate struct CrateMetadata {\n+pub(crate) struct CrateMetadata {\n     /// The primary crate data - binary metadata blob.\n     blob: MetadataBlob,\n \n@@ -744,20 +744,20 @@ where\n implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n impl<'tcx> MetadataBlob {\n-    crate fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n+    pub(crate) fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n         MetadataBlob(Lrc::new(metadata_ref))\n     }\n \n-    crate fn is_compatible(&self) -> bool {\n+    pub(crate) fn is_compatible(&self) -> bool {\n         self.blob().starts_with(METADATA_HEADER)\n     }\n \n-    crate fn get_rustc_version(&self) -> String {\n+    pub(crate) fn get_rustc_version(&self) -> String {\n         Lazy::<String>::from_position(NonZeroUsize::new(METADATA_HEADER.len() + 4).unwrap())\n             .decode(self)\n     }\n \n-    crate fn get_root(&self) -> CrateRoot<'tcx> {\n+    pub(crate) fn get_root(&self) -> CrateRoot<'tcx> {\n         let slice = &self.blob()[..];\n         let offset = METADATA_HEADER.len();\n         let pos = (((slice[offset + 0] as u32) << 24)\n@@ -767,7 +767,7 @@ impl<'tcx> MetadataBlob {\n         Lazy::<CrateRoot<'tcx>>::from_position(NonZeroUsize::new(pos).unwrap()).decode(self)\n     }\n \n-    crate fn list_crate_metadata(&self, out: &mut dyn io::Write) -> io::Result<()> {\n+    pub(crate) fn list_crate_metadata(&self, out: &mut dyn io::Write) -> io::Result<()> {\n         let root = self.get_root();\n         writeln!(out, \"Crate info:\")?;\n         writeln!(out, \"name {}{}\", root.name, root.extra_filename)?;\n@@ -792,27 +792,27 @@ impl<'tcx> MetadataBlob {\n }\n \n impl CrateRoot<'_> {\n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    pub(crate) fn is_proc_macro_crate(&self) -> bool {\n         self.proc_macro_data.is_some()\n     }\n \n-    crate fn name(&self) -> Symbol {\n+    pub(crate) fn name(&self) -> Symbol {\n         self.name\n     }\n \n-    crate fn hash(&self) -> Svh {\n+    pub(crate) fn hash(&self) -> Svh {\n         self.hash\n     }\n \n-    crate fn stable_crate_id(&self) -> StableCrateId {\n+    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n         self.stable_crate_id\n     }\n \n-    crate fn triple(&self) -> &TargetTriple {\n+    pub(crate) fn triple(&self) -> &TargetTriple {\n         &self.triple\n     }\n \n-    crate fn decode_crate_deps<'a>(\n+    pub(crate) fn decode_crate_deps<'a>(\n         &self,\n         metadata: &'a MetadataBlob,\n     ) -> impl ExactSizeIterator<Item = CrateDep> + Captures<'a> {\n@@ -1759,7 +1759,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n }\n \n impl CrateMetadata {\n-    crate fn new(\n+    pub(crate) fn new(\n         sess: &Session,\n         cstore: &CStore,\n         blob: MetadataBlob,\n@@ -1819,15 +1819,15 @@ impl CrateMetadata {\n         cdata\n     }\n \n-    crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n+    pub(crate) fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n         self.dependencies.borrow()\n     }\n \n-    crate fn add_dependency(&self, cnum: CrateNum) {\n+    pub(crate) fn add_dependency(&self, cnum: CrateNum) {\n         self.dependencies.borrow_mut().push(cnum);\n     }\n \n-    crate fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {\n+    pub(crate) fn update_extern_crate(&self, new_extern_crate: ExternCrate) -> bool {\n         let mut extern_crate = self.extern_crate.borrow_mut();\n         let update = Some(new_extern_crate.rank()) > extern_crate.as_ref().map(ExternCrate::rank);\n         if update {\n@@ -1836,59 +1836,59 @@ impl CrateMetadata {\n         update\n     }\n \n-    crate fn source(&self) -> &CrateSource {\n+    pub(crate) fn source(&self) -> &CrateSource {\n         &*self.source\n     }\n \n-    crate fn dep_kind(&self) -> CrateDepKind {\n+    pub(crate) fn dep_kind(&self) -> CrateDepKind {\n         *self.dep_kind.lock()\n     }\n \n-    crate fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n+    pub(crate) fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n \n-    crate fn panic_strategy(&self) -> PanicStrategy {\n+    pub(crate) fn panic_strategy(&self) -> PanicStrategy {\n         self.root.panic_strategy\n     }\n \n-    crate fn needs_panic_runtime(&self) -> bool {\n+    pub(crate) fn needs_panic_runtime(&self) -> bool {\n         self.root.needs_panic_runtime\n     }\n \n-    crate fn is_panic_runtime(&self) -> bool {\n+    pub(crate) fn is_panic_runtime(&self) -> bool {\n         self.root.panic_runtime\n     }\n \n-    crate fn is_profiler_runtime(&self) -> bool {\n+    pub(crate) fn is_profiler_runtime(&self) -> bool {\n         self.root.profiler_runtime\n     }\n \n-    crate fn needs_allocator(&self) -> bool {\n+    pub(crate) fn needs_allocator(&self) -> bool {\n         self.root.needs_allocator\n     }\n \n-    crate fn has_global_allocator(&self) -> bool {\n+    pub(crate) fn has_global_allocator(&self) -> bool {\n         self.root.has_global_allocator\n     }\n \n-    crate fn has_default_lib_allocator(&self) -> bool {\n+    pub(crate) fn has_default_lib_allocator(&self) -> bool {\n         self.root.has_default_lib_allocator\n     }\n \n-    crate fn is_proc_macro_crate(&self) -> bool {\n+    pub(crate) fn is_proc_macro_crate(&self) -> bool {\n         self.root.is_proc_macro_crate()\n     }\n \n-    crate fn name(&self) -> Symbol {\n+    pub(crate) fn name(&self) -> Symbol {\n         self.root.name\n     }\n \n-    crate fn stable_crate_id(&self) -> StableCrateId {\n+    pub(crate) fn stable_crate_id(&self) -> StableCrateId {\n         self.root.stable_crate_id\n     }\n \n-    crate fn hash(&self) -> Svh {\n+    pub(crate) fn hash(&self) -> Svh {\n         self.root.hash\n     }\n "}, {"sha": "06045bb3e3d977ecb06fc1b53b2b44a807bae6a6", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n use rustc_span::def_id::{DefIndex, DefPathHash};\n \n-crate enum DefPathHashMapRef<'tcx> {\n+pub(crate) enum DefPathHashMapRef<'tcx> {\n     OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n     BorrowedFromTcx(&'tcx DefPathHashMap),\n }"}, {"sha": "7ae177c3a563afaf763724d6b98357196037b9c2", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -36,7 +36,7 @@ use std::num::NonZeroUsize;\n \n pub use decoder::provide_extern;\n use decoder::DecodeContext;\n-crate use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n+pub(crate) use decoder::{CrateMetadata, CrateNumMap, MetadataBlob};\n use encoder::EncodeContext;\n pub use encoder::{encode_metadata, EncodedMetadata};\n use rustc_span::hygiene::SyntaxContextData;\n@@ -46,7 +46,7 @@ mod def_path_hash_map;\n mod encoder;\n mod table;\n \n-crate fn rustc_version() -> String {\n+pub(crate) fn rustc_version() -> String {\n     format!(\"rustc {}\", option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n }\n \n@@ -169,7 +169,7 @@ type ExpnDataTable = Lazy<Table<ExpnIndex, Lazy<ExpnData>>>;\n type ExpnHashTable = Lazy<Table<ExpnIndex, Lazy<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct ProcMacroData {\n+pub(crate) struct ProcMacroData {\n     proc_macro_decls_static: DefIndex,\n     stability: Option<attr::Stability>,\n     macros: Lazy<[DefIndex]>,\n@@ -192,7 +192,7 @@ crate struct ProcMacroData {\n /// a normal crate, much of what we serialized would be unusable in addition\n /// to being unused.\n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct CrateRoot<'tcx> {\n+pub(crate) struct CrateRoot<'tcx> {\n     name: Symbol,\n     triple: TargetTriple,\n     extra_filename: String,\n@@ -245,7 +245,7 @@ crate struct CrateRoot<'tcx> {\n /// This creates a type-safe way to enforce that we remap the CrateNum between the on-disk\n /// representation and the compilation session.\n #[derive(Copy, Clone)]\n-crate struct RawDefId {\n+pub(crate) struct RawDefId {\n     krate: u32,\n     index: u32,\n }\n@@ -265,7 +265,7 @@ impl RawDefId {\n }\n \n #[derive(Encodable, Decodable)]\n-crate struct CrateDep {\n+pub(crate) struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n@@ -274,13 +274,13 @@ crate struct CrateDep {\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct TraitImpls {\n+pub(crate) struct TraitImpls {\n     trait_id: (u32, DefIndex),\n     impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n }\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n-crate struct IncoherentImpls {\n+pub(crate) struct IncoherentImpls {\n     self_ty: SimplifiedType,\n     impls: Lazy<[DefIndex]>,\n }\n@@ -289,7 +289,7 @@ crate struct IncoherentImpls {\n macro_rules! define_tables {\n     ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n-        crate struct LazyTables<'tcx> {\n+        pub(crate) struct LazyTables<'tcx> {\n             $($name: Lazy!(Table<$IDX, $T>)),+\n         }\n "}, {"sha": "555baae35f506a647d601db0b3d457c3cf056d47", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -195,13 +195,16 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n // WARNING: `construct` is generic and does not know that `CompileCodegenUnit` takes `Symbol`s as keys.\n // Be very careful changing this type signature!\n-crate fn make_compile_codegen_unit(tcx: TyCtxt<'_>, name: Symbol) -> DepNode {\n+pub(crate) fn make_compile_codegen_unit(tcx: TyCtxt<'_>, name: Symbol) -> DepNode {\n     DepNode::construct(tcx, DepKind::CompileCodegenUnit, &name)\n }\n \n // WARNING: `construct` is generic and does not know that `CompileMonoItem` takes `MonoItem`s as keys.\n // Be very careful changing this type signature!\n-crate fn make_compile_mono_item<'tcx>(tcx: TyCtxt<'tcx>, mono_item: &MonoItem<'tcx>) -> DepNode {\n+pub(crate) fn make_compile_mono_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mono_item: &MonoItem<'tcx>,\n+) -> DepNode {\n     DepNode::construct(tcx, DepKind::CompileMonoItem, mono_item)\n }\n "}, {"sha": "e335cb395f84f3b9d4305975cd7835e37928d621", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,7 +12,7 @@ pub use rustc_query_system::dep_graph::{\n };\n \n pub use dep_node::{label_strs, DepKind, DepKindStruct, DepNode, DepNodeExt};\n-crate use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n+pub(crate) use dep_node::{make_compile_codegen_unit, make_compile_mono_item};\n \n pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;"}, {"sha": "b4dd253b83914a1628ddc4104dee98c04a34c103", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -46,7 +46,6 @@\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(type_alias_impl_trait)]\n-#![feature(crate_visibility_modifier)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n #![feature(half_open_range_patterns)]"}, {"sha": "16ef8d68be3a3b0fc1339c5ce5f99e3a301baa99", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -414,7 +414,7 @@ impl<'tcx> GlobalAlloc<'tcx> {\n     }\n }\n \n-crate struct AllocMap<'tcx> {\n+pub(crate) struct AllocMap<'tcx> {\n     /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n@@ -430,7 +430,7 @@ crate struct AllocMap<'tcx> {\n }\n \n impl<'tcx> AllocMap<'tcx> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         AllocMap {\n             alloc_map: Default::default(),\n             dedup: Default::default(),"}, {"sha": "31e131182cc63a2132f2b9d5f5a9de0bde2888e8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1230,7 +1230,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    crate fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n+    pub(crate) fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct {\n         &self.query_kinds[k as usize]\n     }\n "}, {"sha": "8efa1621adede247e94e63d4da81148706f58774", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -409,7 +409,7 @@ pub struct CReaderCacheKey {\n ///   of the relevant methods.\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n #[allow(rustc::usage_of_ty_tykind)]\n-crate struct TyS<'tcx> {\n+pub(crate) struct TyS<'tcx> {\n     /// This field shouldn't be used directly and may be removed in the future.\n     /// Use `Ty::kind()` instead.\n     kind: TyKind<'tcx>,\n@@ -500,7 +500,7 @@ impl ty::EarlyBoundRegion {\n /// See comments on `TyS`, which apply here too (albeit for\n /// `PredicateS`/`Predicate` rather than `TyS`/`Ty`).\n #[derive(Debug)]\n-crate struct PredicateS<'tcx> {\n+pub(crate) struct PredicateS<'tcx> {\n     kind: Binder<'tcx, PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS]."}, {"sha": "a83328c0cabc63c9e679271525f10b86402e8edb", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::{mir::*, ty};\n use rustc_span::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn ast_block(\n+    pub(crate) fn ast_block(\n         &mut self,\n         destination: Place<'tcx>,\n         block: BasicBlock,"}, {"sha": "d7b4b1f731a677b24b07e974ec922d69b83f5e2c", "filename": "compiler/rustc_mir_build/src/build/cfg.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcfg.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,33 +5,33 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n \n impl<'tcx> CFG<'tcx> {\n-    crate fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n+    pub(crate) fn block_data(&self, blk: BasicBlock) -> &BasicBlockData<'tcx> {\n         &self.basic_blocks[blk]\n     }\n \n-    crate fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n+    pub(crate) fn block_data_mut(&mut self, blk: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks[blk]\n     }\n \n     // llvm.org/PR32488 makes this function use an excess of stack space. Mark\n     // it as #[inline(never)] to keep rustc's stack use in check.\n     #[inline(never)]\n-    crate fn start_new_block(&mut self) -> BasicBlock {\n+    pub(crate) fn start_new_block(&mut self) -> BasicBlock {\n         self.basic_blocks.push(BasicBlockData::new(None))\n     }\n \n-    crate fn start_new_cleanup_block(&mut self) -> BasicBlock {\n+    pub(crate) fn start_new_cleanup_block(&mut self) -> BasicBlock {\n         let bb = self.start_new_block();\n         self.block_data_mut(bb).is_cleanup = true;\n         bb\n     }\n \n-    crate fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n+    pub(crate) fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    crate fn push_assign(\n+    pub(crate) fn push_assign(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -44,7 +44,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_assign_constant(\n+    pub(crate) fn push_assign_constant(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -59,7 +59,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_assign_unit(\n+    pub(crate) fn push_assign_unit(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -78,7 +78,7 @@ impl<'tcx> CFG<'tcx> {\n         );\n     }\n \n-    crate fn push_fake_read(\n+    pub(crate) fn push_fake_read(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -90,7 +90,7 @@ impl<'tcx> CFG<'tcx> {\n         self.push(block, stmt);\n     }\n \n-    crate fn terminate(\n+    pub(crate) fn terminate(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -107,7 +107,7 @@ impl<'tcx> CFG<'tcx> {\n     }\n \n     /// In the `origin` block, push a `goto -> target` terminator.\n-    crate fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n+    pub(crate) fn goto(&mut self, origin: BasicBlock, source_info: SourceInfo, target: BasicBlock) {\n         self.terminate(origin, source_info, TerminatorKind::Goto { target })\n     }\n }"}, {"sha": "035e94eecee230acaa1a52621f94f27618c6fcb2", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, TyCtxt};\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n-    crate fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n+    pub(crate) fn as_constant(&mut self, expr: &Expr<'tcx>) -> Constant<'tcx> {\n         let create_uneval_from_def_id =\n             |tcx: TyCtxt<'tcx>, def_id: DefId, ty: Ty<'tcx>, substs: SubstsRef<'tcx>| {\n                 let uneval = ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs);"}, {"sha": "e707c373f0dde9faf7c1499fe48bc056c446f4f8", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// after the current enclosing `ExprKind::Scope` has ended, so\n     /// please do *not* return it from functions to avoid bad\n     /// miscompiles.\n-    crate fn as_local_operand(\n+    pub(crate) fn as_local_operand(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// value to the stack.\n     ///\n     /// See #68034 for more details.\n-    crate fn as_local_call_operand(\n+    pub(crate) fn as_local_call_operand(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Like `as_local_call_operand`, except that the argument will\n     /// not be valid once `scope` ends.\n     #[instrument(level = \"debug\", skip(self, scope))]\n-    crate fn as_operand(\n+    pub(crate) fn as_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -132,7 +132,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn as_call_operand(\n+    pub(crate) fn as_call_operand(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,"}, {"sha": "045d6eb1c3021d8df34301ac37a85b2fd9533d73", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ use std::iter;\n \n /// The \"outermost\" place that holds this value.\n #[derive(Copy, Clone, Debug, PartialEq)]\n-crate enum PlaceBase {\n+pub(crate) enum PlaceBase {\n     /// Denotes the start of a `Place`.\n     Local(Local),\n \n@@ -71,7 +71,7 @@ crate enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-crate struct PlaceBuilder<'tcx> {\n+pub(crate) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -283,7 +283,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    crate fn into_place<'a>(\n+    pub(crate) fn into_place<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n@@ -314,35 +314,35 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    crate fn try_upvars_resolved<'a>(\n+    pub(crate) fn try_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results)\n     }\n \n-    crate fn base(&self) -> PlaceBase {\n+    pub(crate) fn base(&self) -> PlaceBase {\n         self.base\n     }\n \n-    crate fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n+    pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n         self.project(PlaceElem::Field(f, ty))\n     }\n \n-    crate fn deref(self) -> Self {\n+    pub(crate) fn deref(self) -> Self {\n         self.project(PlaceElem::Deref)\n     }\n \n-    crate fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx) -> Self {\n+    pub(crate) fn downcast(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx) -> Self {\n         self.project(PlaceElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index))\n     }\n \n     fn index(self, index: Local) -> Self {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    crate fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n+    pub(crate) fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n         self.projection.push(elem);\n         self\n     }\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Extra care is needed if any user code is allowed to run between calling\n     /// this method and using it, as is the case for `match` and index\n     /// expressions.\n-    crate fn as_place(\n+    pub(crate) fn as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -384,7 +384,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n     /// intermediate `Place` values until we know the full set of projections.\n-    crate fn as_place_builder(\n+    pub(crate) fn as_place_builder(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// place. The place itself may or may not be mutable:\n     /// * If this expr is a place expr like a.b, then we will return that place.\n     /// * Otherwise, a temporary is created: in that event, it will be an immutable temporary.\n-    crate fn as_read_only_place(\n+    pub(crate) fn as_read_only_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "0fd67f15b7501396ebcddafeffba1d6c4bc7b550", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// The operand returned from this function will *not be valid* after\n     /// an ExprKind::Scope is passed, so please do *not* return it from\n     /// functions to avoid bad miscompiles.\n-    crate fn as_local_rvalue(\n+    pub(crate) fn as_local_rvalue(\n         &mut self,\n         block: BasicBlock,\n         expr: &Expr<'tcx>,\n@@ -31,7 +31,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    crate fn as_rvalue(\n+    pub(crate) fn as_rvalue(\n         &mut self,\n         mut block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn build_binary_op(\n+    pub(crate) fn build_binary_op(\n         &mut self,\n         mut block: BasicBlock,\n         op: BinOp,"}, {"sha": "724b72f8769b8bc8bd460880f3a3cb90a5fc2d44", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::thir::*;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    crate fn as_temp(\n+    pub(crate) fn as_temp(\n         &mut self,\n         block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,"}, {"sha": "b1a706439342ebbdfe5365b174bcf225f106f8af", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,7 @@\n use rustc_middle::thir::*;\n \n #[derive(Debug, PartialEq)]\n-crate enum Category {\n+pub(crate) enum Category {\n     // An assignable memory location like `x`, `x.f`, `foo()[3]`, that\n     // sort of thing. Something that could appear on the LHS of an `=`\n     // sign.\n@@ -19,7 +19,7 @@ crate enum Category {\n // Rvalues fall into different \"styles\" that will determine which fn\n // is best suited to generate them.\n #[derive(Debug, PartialEq)]\n-crate enum RvalueFunc {\n+pub(crate) enum RvalueFunc {\n     // Best generated by `into`. This is generally exprs that\n     // cause branching, like `match`, but also includes calls.\n     Into,\n@@ -31,7 +31,7 @@ crate enum RvalueFunc {\n /// Determines the category for a given expression. Note that scope\n /// and paren expressions have no category.\n impl Category {\n-    crate fn of(ek: &ExprKind<'_>) -> Option<Category> {\n+    pub(crate) fn of(ek: &ExprKind<'_>) -> Option<Category> {\n         match *ek {\n             ExprKind::Scope { .. } => None,\n "}, {"sha": "e912501d55f2255e740158910cef105dd7216e6d", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,7 +15,7 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n-    crate fn expr_into_dest(\n+    pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,"}, {"sha": "f5ae060d603f6eca5d68b61657eda725319a15fc", "filename": "compiler/rustc_mir_build/src/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -60,7 +60,7 @@\n //! basically the point where the \"by value\" operations are bridged\n //! over to the \"by reference\" mode (`as_place`).\n \n-crate mod as_constant;\n+pub(crate) mod as_constant;\n mod as_operand;\n pub mod as_place;\n mod as_rvalue;"}, {"sha": "a7e1331aabca3f7aa7a5416dfc2b8ce22e4394af", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,7 +10,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n     /// The scope is used if a statement temporary must be dropped.\n-    crate fn stmt_expr(\n+    pub(crate) fn stmt_expr(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "83ecd185b3c6054895ff88194db248505f7c354a", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// * From each pre-binding block to the next pre-binding block.\n     /// * From each otherwise block to the next pre-binding block.\n-    crate fn match_expr(\n+    pub(crate) fn match_expr(\n         &mut self,\n         destination: Place<'tcx>,\n         span: Span,\n@@ -577,7 +577,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    crate fn place_into_pattern(\n+    pub(crate) fn place_into_pattern(\n         &mut self,\n         block: BasicBlock,\n         irrefutable_pat: Pat<'tcx>,\n@@ -653,7 +653,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    crate fn declare_bindings(\n+    pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n         scope_span: Span,\n@@ -690,7 +690,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         visibility_scope\n     }\n \n-    crate fn storage_live_binding(\n+    pub(crate) fn storage_live_binding(\n         &mut self,\n         block: BasicBlock,\n         var: HirId,\n@@ -709,7 +709,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         Place::from(local_id)\n     }\n \n-    crate fn schedule_drop_for_binding(&mut self, var: HirId, span: Span, for_guard: ForGuard) {\n+    pub(crate) fn schedule_drop_for_binding(\n+        &mut self,\n+        var: HirId,\n+        span: Span,\n+        for_guard: ForGuard,\n+    ) {\n         let local_id = self.var_local_id(var, for_guard);\n         if let Some(region_scope) = self.region_scope_tree.var_scope(var.local_id) {\n             self.schedule_drop(span, region_scope, local_id, DropKind::Value);\n@@ -934,7 +939,7 @@ struct Ascription<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-crate struct MatchPair<'pat, 'tcx> {\n+pub(crate) struct MatchPair<'pat, 'tcx> {\n     // this place...\n     place: PlaceBuilder<'tcx>,\n \n@@ -991,15 +996,15 @@ enum TestKind<'tcx> {\n /// [`Test`] is just the test to perform; it does not include the value\n /// to be tested.\n #[derive(Debug)]\n-crate struct Test<'tcx> {\n+pub(crate) struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }\n \n /// `ArmHasGuard` is a wrapper around a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n-crate struct ArmHasGuard(crate bool);\n+pub(crate) struct ArmHasGuard(pub(crate) bool);\n \n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n@@ -1769,7 +1774,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n // Pat binding - used for `let` and function parameters as well.\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn lower_let_expr(\n+    pub(crate) fn lower_let_expr(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,"}, {"sha": "9a1e98d3bb18ddc8d6b6e646a1de00610ae4ae33", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use smallvec::SmallVec;\n use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    crate fn field_match_pairs<'pat>(\n+    pub(crate) fn field_match_pairs<'pat>(\n         &mut self,\n         place: PlaceBuilder<'tcx>,\n         subpatterns: &'pat [FieldPat<'tcx>],\n@@ -22,7 +22,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             .collect()\n     }\n \n-    crate fn prefix_slice_suffix<'pat>(\n+    pub(crate) fn prefix_slice_suffix<'pat>(\n         &mut self,\n         match_pairs: &mut SmallVec<[MatchPair<'pat, 'tcx>; 1]>,\n         place: &PlaceBuilder<'tcx>,\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates a false edge to `imaginary_target` and a real edge to\n     /// real_target. If `imaginary_target` is none, or is the same as the real\n     /// target, a Goto is generated instead to simplify the generated MIR.\n-    crate fn false_edges(\n+    pub(crate) fn false_edges(\n         &mut self,\n         from_block: BasicBlock,\n         real_target: BasicBlock,\n@@ -100,7 +100,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    crate fn new(place: PlaceBuilder<'tcx>, pattern: &'pat Pat<'tcx>) -> MatchPair<'pat, 'tcx> {\n+    pub(crate) fn new(\n+        place: PlaceBuilder<'tcx>,\n+        pattern: &'pat Pat<'tcx>,\n+    ) -> MatchPair<'pat, 'tcx> {\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "86f466ff7672e8def0b7787494bdda78372c10e3", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -14,7 +14,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// N.B., **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    crate fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n+    pub(crate) fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         // Mark this local as internal to avoid temporaries with types not present in the\n         // user's code resulting in ICEs from the generator transform.\n         let temp = self.local_decls.push(LocalDecl::new(ty, span).internal());\n@@ -25,20 +25,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience function for creating a literal operand, one\n     /// without any user type annotation.\n-    crate fn literal_operand(&mut self, span: Span, literal: ConstantKind<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn literal_operand(\n+        &mut self,\n+        span: Span,\n+        literal: ConstantKind<'tcx>,\n+    ) -> Operand<'tcx> {\n         let constant = Box::new(Constant { span, user_ty: None, literal });\n         Operand::Constant(constant)\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n     // bool, char and integers.\n-    crate fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = ConstantKind::from_bits(self.tcx, 0, ty::ParamEnv::empty().and(ty));\n \n         self.literal_operand(span, literal)\n     }\n \n-    crate fn push_usize(\n+    pub(crate) fn push_usize(\n         &mut self,\n         block: BasicBlock,\n         source_info: SourceInfo,\n@@ -59,7 +63,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         temp\n     }\n \n-    crate fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n+    pub(crate) fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {"}, {"sha": "4ae74433df63dc7051cb9ad61169ac4437b13b15", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::lints;\n \n-crate fn mir_built<'tcx>(\n+pub(crate) fn mir_built<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> &'tcx rustc_data_structures::steal::Steal<Body<'tcx>> {"}, {"sha": "2d14a78accf9cef5d15d3794713f0c33e4e0713d", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -177,7 +177,7 @@ struct IfThenScope {\n \n /// The target of an expression that breaks out of a scope\n #[derive(Clone, Copy, Debug)]\n-crate enum BreakableTarget {\n+pub(crate) enum BreakableTarget {\n     Continue(region::Scope),\n     Break(region::Scope),\n     Return,\n@@ -445,7 +445,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // ==========================\n     //  Start a breakable scope, which tracks where `continue`, `break` and\n     //  `return` should branch to.\n-    crate fn in_breakable_scope<F>(\n+    pub(crate) fn in_breakable_scope<F>(\n         &mut self,\n         loop_block: Option<BasicBlock>,\n         break_destination: Place<'tcx>,\n@@ -507,7 +507,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// - We don't need to keep a stack of scopes in the `Builder` because the\n     ///   'else' paths will only leave the innermost scope.\n     /// - This is also used for match guards.\n-    crate fn in_if_then_scope<F>(\n+    pub(crate) fn in_if_then_scope<F>(\n         &mut self,\n         region_scope: region::Scope,\n         f: F,\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         (then_block, else_block)\n     }\n \n-    crate fn in_opt_scope<F, R>(\n+    pub(crate) fn in_opt_scope<F, R>(\n         &mut self,\n         opt_scope: Option<(region::Scope, SourceInfo)>,\n         f: F,\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n-    crate fn in_scope<F, R>(\n+    pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         lint_level: LintLevel,\n@@ -597,14 +597,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    crate fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n+    pub(crate) fn push_scope(&mut self, region_scope: (region::Scope, SourceInfo)) {\n         self.scopes.push_scope(region_scope, self.source_scope);\n     }\n \n     /// Pops a scope, which should have region scope `region_scope`,\n     /// adding any drops onto the end of `block` that are needed.\n     /// This must match 1-to-1 with `push_scope`.\n-    crate fn pop_scope(\n+    pub(crate) fn pop_scope(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n         mut block: BasicBlock,\n@@ -619,7 +619,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Sets up the drops for breaking from `block` to `target`.\n-    crate fn break_scope(\n+    pub(crate) fn break_scope(\n         &mut self,\n         mut block: BasicBlock,\n         value: Option<&Expr<'tcx>>,\n@@ -698,7 +698,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.cfg.start_new_block().unit()\n     }\n \n-    crate fn break_for_else(\n+    pub(crate) fn break_for_else(\n         &mut self,\n         block: BasicBlock,\n         target: region::Scope,\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Creates a new source scope, nested in the current one.\n-    crate fn new_source_scope(\n+    pub(crate) fn new_source_scope(\n         &mut self,\n         span: Span,\n         lint_level: LintLevel,\n@@ -791,7 +791,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Given a span and the current source scope, make a SourceInfo.\n-    crate fn source_info(&self, span: Span) -> SourceInfo {\n+    pub(crate) fn source_info(&self, span: Span) -> SourceInfo {\n         SourceInfo { span, scope: self.source_scope }\n     }\n \n@@ -816,13 +816,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// We would allocate the box but then free it on the unwinding\n     /// path; we would also emit a free on the 'success' path from\n     /// panic, but that will turn out to be removed as dead-code.\n-    crate fn local_scope(&self) -> region::Scope {\n+    pub(crate) fn local_scope(&self) -> region::Scope {\n         self.scopes.topmost()\n     }\n \n     // Scheduling drops\n     // ================\n-    crate fn schedule_drop_storage_and_value(\n+    pub(crate) fn schedule_drop_storage_and_value(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -836,7 +836,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// When called with `DropKind::Storage`, `place` shouldn't be the return\n     /// place, or a function parameter.\n-    crate fn schedule_drop(\n+    pub(crate) fn schedule_drop(\n         &mut self,\n         span: Span,\n         region_scope: region::Scope,\n@@ -969,7 +969,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// spurious borrow-check errors -- the problem, ironically, is\n     /// not the `DROP(_X)` itself, but the (spurious) unwind pathways\n     /// that it creates. See #64391 for an example.\n-    crate fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n+    pub(crate) fn record_operands_moved(&mut self, operands: &[Operand<'tcx>]) {\n         let local_scope = self.local_scope();\n         let scope = self.scopes.scopes.last_mut().unwrap();\n \n@@ -1026,7 +1026,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This path terminates in Resume. The path isn't created until after all\n     /// of the non-unwind paths in this item have been lowered.\n-    crate fn diverge_from(&mut self, start: BasicBlock) {\n+    pub(crate) fn diverge_from(&mut self, start: BasicBlock) {\n         debug_assert!(\n             matches!(\n                 self.cfg.block_data(start).terminator().kind,\n@@ -1048,7 +1048,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// [TerminatorKind::Yield].\n     ///\n     /// This path terminates in GeneratorDrop.\n-    crate fn generator_drop_cleanup(&mut self, yield_block: BasicBlock) {\n+    pub(crate) fn generator_drop_cleanup(&mut self, yield_block: BasicBlock) {\n         debug_assert!(\n             matches!(\n                 self.cfg.block_data(yield_block).terminator().kind,\n@@ -1078,7 +1078,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Utility function for *non*-scope code to build their own drops\n-    crate fn build_drop_and_replace(\n+    pub(crate) fn build_drop_and_replace(\n         &mut self,\n         block: BasicBlock,\n         span: Span,\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Creates an `Assert` terminator and return the success block.\n     /// If the boolean condition operand is not the expected value,\n     /// a runtime panic will be caused with the given message.\n-    crate fn assert(\n+    pub(crate) fn assert(\n         &mut self,\n         block: BasicBlock,\n         cond: Operand<'tcx>,\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// This is only needed for `match` arm scopes, because they have one\n     /// entrance per pattern, but only one exit.\n-    crate fn clear_top_scope(&mut self, region_scope: region::Scope) {\n+    pub(crate) fn clear_top_scope(&mut self, region_scope: region::Scope) {\n         let top_scope = self.scopes.scopes.last_mut().unwrap();\n \n         assert_eq!(top_scope.region_scope, region_scope);\n@@ -1262,7 +1262,7 @@ impl<'a, 'tcx: 'a> Builder<'a, 'tcx> {\n     }\n \n     /// Build the unwind and generator drop trees.\n-    crate fn build_drop_trees(&mut self) {\n+    pub(crate) fn build_drop_trees(&mut self) {\n         if self.generator_kind.is_some() {\n             self.build_generator_drop_trees();\n         } else {"}, {"sha": "94b2722dca86d1e2884bae852307fe68a1cf0082", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -678,15 +678,15 @@ pub fn check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def: ty::WithOptConstParam<LocalD\n     visitor.visit_expr(&thir[expr]);\n }\n \n-crate fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n+pub(crate) fn thir_check_unsafety<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n     if let Some(def) = ty::WithOptConstParam::try_lookup(def_id, tcx) {\n         tcx.thir_check_unsafety_for_const_arg(def)\n     } else {\n         check_unsafety(tcx, ty::WithOptConstParam::unknown(def_id))\n     }\n }\n \n-crate fn thir_check_unsafety_for_const_arg<'tcx>(\n+pub(crate) fn thir_check_unsafety_for_const_arg<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (did, param_did): (LocalDefId, DefId),\n ) {"}, {"sha": "11cd2a9aa4dea9b03ed61d3e6658aa0ad15084fe", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -4,7 +4,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "5470cc1262e8451d071319f0b759bb95e51a5a71", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n use std::ops::ControlFlow;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n+pub(crate) fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n \n     if let Some(fn_kind) = tcx.hir().get_by_def_id(def_id).fn_kind() {"}, {"sha": "d82e6688633d01667f91a144b85fac711a41e008", "filename": "compiler/rustc_mir_build/src/thir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fconstant.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use rustc_span::symbol::Symbol;\n use rustc_target::abi::Size;\n \n // FIXME Once valtrees are available, get rid of this function and the query\n-crate fn lit_to_const<'tcx>(\n+pub(crate) fn lit_to_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     lit_input: LitToConstInput<'tcx>,\n ) -> Result<ty::Const<'tcx>, LitToConstError> {"}, {"sha": "72ce8c24cdd5b3484f506da2cde8fc6aaaa52192", "filename": "compiler/rustc_mir_build/src/thir/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fblock.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_index::vec::Idx;\n \n impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block {\n+    pub(crate) fn mirror_block(&mut self, block: &'tcx hir::Block<'tcx>) -> Block {\n         // We have to eagerly lower the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = self.mirror_stmts(block.hir_id.local_id, block.stmts);"}, {"sha": "b9879b9159fb363ba5feea20bf59ac2452537a4e", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -22,12 +22,12 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n impl<'tcx> Cx<'tcx> {\n-    crate fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n+    pub(crate) fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n         // `mirror_expr` is recursing very deep. Make sure the stack doesn't overflow.\n         ensure_sufficient_stack(|| self.mirror_expr_inner(expr))\n     }\n \n-    crate fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Box<[ExprId]> {\n+    pub(crate) fn mirror_exprs(&mut self, exprs: &'tcx [hir::Expr<'tcx>]) -> Box<[ExprId]> {\n         exprs.iter().map(|expr| self.mirror_expr_inner(expr)).collect()\n     }\n "}, {"sha": "81eb7efad371fc4caefb4b094ea389877ed75b02", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::thir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n \n-crate fn thir_body<'tcx>(\n+pub(crate) fn thir_body<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n ) -> Result<(&'tcx Steal<Thir<'tcx>>, ExprId), ErrorGuaranteed> {\n@@ -33,7 +33,7 @@ crate fn thir_body<'tcx>(\n     Ok((tcx.alloc_steal_thir(cx.thir), expr))\n }\n \n-crate fn thir_tree<'tcx>(\n+pub(crate) fn thir_tree<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n ) -> String {\n@@ -47,10 +47,10 @@ struct Cx<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     thir: Thir<'tcx>,\n \n-    crate param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n-    crate region_scope_tree: &'tcx region::ScopeTree,\n-    crate typeck_results: &'tcx ty::TypeckResults<'tcx>,\n+    pub(crate) region_scope_tree: &'tcx region::ScopeTree,\n+    pub(crate) typeck_results: &'tcx ty::TypeckResults<'tcx>,\n \n     /// When applying adjustments to the expression\n     /// with the given `HirId`, use the given `Span`,\n@@ -79,7 +79,7 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    crate fn const_eval_literal(\n+    pub(crate) fn const_eval_literal(\n         &mut self,\n         lit: &'tcx ast::LitKind,\n         ty: Ty<'tcx>,\n@@ -96,7 +96,7 @@ impl<'tcx> Cx<'tcx> {\n         }\n     }\n \n-    crate fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n+    pub(crate) fn pattern_from_hir(&mut self, p: &hir::Pat<'_>) -> Pat<'tcx> {\n         let p = match self.tcx.hir().get(p.hir_id) {\n             Node::Pat(p) | Node::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node),"}, {"sha": "e0e6ac26654ab174bdb413de9b79b3539beb1b06", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -4,10 +4,10 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-crate mod constant;\n+pub(crate) mod constant;\n \n-crate mod cx;\n+pub(crate) mod cx;\n \n-crate mod pattern;\n+pub(crate) mod pattern;\n \n mod util;"}, {"sha": "dc204eb47aefa670a633712ddebc6e1e03eeafda", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -23,7 +23,7 @@ use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::{BytePos, DesugaringKind, ExpnKind, Span};\n \n-crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n         Some(id) => tcx.hir().body_owned_by(tcx.hir().local_def_id_to_hir_id(id)),\n@@ -880,7 +880,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     err.emit();\n }\n \n-crate fn joined_uncovered_patterns<'p, 'tcx>(\n+pub(crate) fn joined_uncovered_patterns<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     witnesses: &[DeconstructedPat<'p, 'tcx>],\n ) -> String {\n@@ -901,7 +901,7 @@ crate fn joined_uncovered_patterns<'p, 'tcx>(\n     }\n }\n \n-crate fn pattern_not_covered_label(\n+pub(crate) fn pattern_not_covered_label(\n     witnesses: &[DeconstructedPat<'_, '_>],\n     joined_patterns: &str,\n ) -> String {"}, {"sha": "1f152549a63f03bf48792a6202ec3b677715b495", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -27,22 +27,22 @@ use rustc_span::{Span, Symbol};\n use std::cmp::Ordering;\n \n #[derive(Clone, Debug)]\n-crate enum PatternError {\n+pub(crate) enum PatternError {\n     AssocConstInPattern(Span),\n     ConstParamInPattern(Span),\n     StaticInPattern(Span),\n     NonConstPath(Span),\n }\n \n-crate struct PatCtxt<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n-    crate param_env: ty::ParamEnv<'tcx>,\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n-    crate errors: Vec<PatternError>,\n+pub(crate) struct PatCtxt<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) typeck_results: &'a ty::TypeckResults<'tcx>,\n+    pub(crate) errors: Vec<PatternError>,\n     include_lint_checks: bool,\n }\n \n-crate fn pat_from_hir<'a, 'tcx>(\n+pub(crate) fn pat_from_hir<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n@@ -59,20 +59,20 @@ crate fn pat_from_hir<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Self {\n         PatCtxt { tcx, param_env, typeck_results, errors: vec![], include_lint_checks: false }\n     }\n \n-    crate fn include_lint_checks(&mut self) -> &mut Self {\n+    pub(crate) fn include_lint_checks(&mut self) -> &mut Self {\n         self.include_lint_checks = true;\n         self\n     }\n \n-    crate fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n+    pub(crate) fn lower_pattern(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n         // pattern has the type that results *after* dereferencing. For example, in this code:\n         //\n@@ -608,15 +608,15 @@ impl<'tcx> UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {\n     }\n }\n \n-crate trait PatternFoldable<'tcx>: Sized {\n+pub(crate) trait PatternFoldable<'tcx>: Sized {\n     fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n-crate trait PatternFolder<'tcx>: Sized {\n+pub(crate) trait PatternFolder<'tcx>: Sized {\n     fn fold_pattern(&mut self, pattern: &Pat<'tcx>) -> Pat<'tcx> {\n         pattern.super_fold_with(self)\n     }\n@@ -746,7 +746,7 @@ impl<'tcx> PatternFoldable<'tcx> for PatKind<'tcx> {\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n-crate fn compare_const_vals<'tcx>(\n+pub(crate) fn compare_const_vals<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     a: mir::ConstantKind<'tcx>,\n     b: mir::ConstantKind<'tcx>,"}, {"sha": "9e7a267ecbd7fc86dd9d057324d9595f21ac5b74", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -309,16 +309,16 @@ use smallvec::{smallvec, SmallVec};\n use std::fmt;\n use std::iter::once;\n \n-crate struct MatchCheckCtxt<'p, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// The module in which the match occurs. This is necessary for\n     /// checking inhabited-ness of types because whether a type is (visibly)\n     /// inhabited can depend on whether it was defined in the current module or\n     /// not. E.g., `struct Foo { _private: ! }` cannot be seen to be empty\n     /// outside its module and should not be matchable with an empty match statement.\n-    crate module: DefId,\n-    crate param_env: ty::ParamEnv<'tcx>,\n-    crate pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    pub(crate) module: DefId,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -691,7 +691,7 @@ enum ArmType {\n ///\n /// The final `Pair(Some(_), true)` is then the resulting witness.\n #[derive(Debug)]\n-crate struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n+pub(crate) struct Witness<'p, 'tcx>(Vec<DeconstructedPat<'p, 'tcx>>);\n \n impl<'p, 'tcx> Witness<'p, 'tcx> {\n     /// Asserts that the witness contains a single pattern, and returns it.\n@@ -908,16 +908,16 @@ fn is_useful<'p, 'tcx>(\n \n /// The arm of a match expression.\n #[derive(Clone, Copy, Debug)]\n-crate struct MatchArm<'p, 'tcx> {\n+pub(crate) struct MatchArm<'p, 'tcx> {\n     /// The pattern must have been lowered through `check_match::MatchVisitor::lower_pattern`.\n-    crate pat: &'p DeconstructedPat<'p, 'tcx>,\n-    crate hir_id: HirId,\n-    crate has_guard: bool,\n+    pub(crate) pat: &'p DeconstructedPat<'p, 'tcx>,\n+    pub(crate) hir_id: HirId,\n+    pub(crate) has_guard: bool,\n }\n \n /// Indicates whether or not a given arm is reachable.\n #[derive(Clone, Debug)]\n-crate enum Reachability {\n+pub(crate) enum Reachability {\n     /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n     /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n     /// of or-patterns, otherwise it stays empty.\n@@ -927,12 +927,12 @@ crate enum Reachability {\n }\n \n /// The output of checking a match for exhaustiveness and arm reachability.\n-crate struct UsefulnessReport<'p, 'tcx> {\n+pub(crate) struct UsefulnessReport<'p, 'tcx> {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n-    crate arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n+    pub(crate) arm_usefulness: Vec<(MatchArm<'p, 'tcx>, Reachability)>,\n     /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n     /// exhaustiveness.\n-    crate non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n+    pub(crate) non_exhaustiveness_witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n }\n \n /// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n@@ -941,7 +941,7 @@ crate struct UsefulnessReport<'p, 'tcx> {\n /// Note: the input patterns must have been lowered through\n /// `check_match::MatchVisitor::lower_pattern`.\n #[instrument(skip(cx, arms), level = \"debug\")]\n-crate fn compute_match_usefulness<'p, 'tcx>(\n+pub(crate) fn compute_match_usefulness<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     arms: &[MatchArm<'p, 'tcx>],\n     scrut_hir_id: HirId,"}, {"sha": "c58ed1ac0b89119197c36d08f28746d8f8d253a7", "filename": "compiler/rustc_mir_build/src/thir/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Futil.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,7 @@\n use rustc_hir as hir;\n use rustc_middle::ty::{self, CanonicalUserType, TyCtxt, UserType};\n \n-crate trait UserAnnotatedTyHelpers<'tcx> {\n+pub(crate) trait UserAnnotatedTyHelpers<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n     fn typeck_results(&self) -> &ty::TypeckResults<'tcx>;"}, {"sha": "017d9e74dc4bc3b529bd97cc9efe4c217c0a511c", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,7 @@ use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n \n-crate mod cycle;\n+pub(crate) mod cycle;\n \n const INSTR_COST: usize = 5;\n const CALL_PENALTY: usize = 25;"}, {"sha": "fd7de2bd1dcf86347665d2ac5396b39b874befb6", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,7 @@ use rustc_session::Limit;\n // FIXME: check whether it is cheaper to precompute the entire call graph instead of invoking\n // this query ridiculously often.\n #[instrument(level = \"debug\", skip(tcx, root, target))]\n-crate fn mir_callgraph_reachable<'tcx>(\n+pub(crate) fn mir_callgraph_reachable<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (root, target): (ty::Instance<'tcx>, LocalDefId),\n ) -> bool {\n@@ -136,7 +136,7 @@ crate fn mir_callgraph_reachable<'tcx>(\n     )\n }\n \n-crate fn mir_inliner_callees<'tcx>(\n+pub(crate) fn mir_inliner_callees<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n ) -> &'tcx [(DefId, SubstsRef<'tcx>)] {"}, {"sha": "1e8c373a411feecddcdd4cb38700163efe78d413", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_chains)]\n #![feature(let_else)]\n #![feature(map_try_insert)]"}, {"sha": "ef4560b5ec48edc153a3ad9fc553491b678bdf6e", "filename": "compiler/rustc_monomorphize/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,4 @@\n #![feature(array_windows)]\n-#![feature(crate_visibility_modifier)]\n #![feature(control_flow_enum)]\n #![feature(let_else)]\n #![recursion_limit = \"256\"]"}, {"sha": "d3aaad46015619dd97d027dd49bacb11d23811a9", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,7 @@ use std::io::prelude::*;\n ///\n /// During the same compile all closures dump the information in the same file\n /// \"closure_profile_XXXXX.csv\", which is created in the directory where the compiler is invoked.\n-crate fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instance<'tcx>) {\n+pub(crate) fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instance<'tcx>) {\n     let Ok(mut file) = OpenOptions::new()\n         .create(true)\n         .append(true)"}, {"sha": "e9701ec2d7f456f3b85158c29f481b8be0539e91", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -31,7 +31,7 @@ pub struct UnmatchedBrace {\n     pub candidate_span: Option<Span>,\n }\n \n-crate fn parse_token_trees<'a>(\n+pub(crate) fn parse_token_trees<'a>(\n     sess: &'a ParseSess,\n     src: &'a str,\n     start_pos: BytePos,"}, {"sha": "c46a8b58c293606fdcc08597be8e5ab97d9b8915", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(array_windows)]\n #![feature(box_patterns)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "3ae8bb07cd07002019784b33715493b32ef4124a", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -284,7 +284,7 @@ impl<'a> Parser<'a> {\n     /// terminated by a semicolon.\n     ///\n     /// Matches `inner_attrs*`.\n-    crate fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n+    pub(crate) fn parse_inner_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             let start_pos: u32 = self.token_cursor.num_next_calls.try_into().unwrap();\n@@ -322,7 +322,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    crate fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    pub(crate) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n@@ -358,7 +358,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `COMMASEP(meta_item_inner)`.\n-    crate fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+    pub(crate) fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n         // Presumably, the majority of the time there will only be one attr.\n         let mut nmis = Vec::with_capacity(1);\n         while self.token.kind != token::Eof {\n@@ -401,7 +401,7 @@ impl<'a> Parser<'a> {\n         Ok(ast::MetaItem { path, kind, span })\n     }\n \n-    crate fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n+    pub(crate) fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {"}, {"sha": "69e12063cc134ad59094b001b9f11c129f4e308f", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -132,7 +132,7 @@ impl RecoverQPath for Expr {\n }\n \n /// Control whether the closing delimiter should be consumed when calling `Parser::consume_block`.\n-crate enum ConsumeClosingDelim {\n+pub(crate) enum ConsumeClosingDelim {\n     Yes,\n     No,\n }\n@@ -2459,7 +2459,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    crate fn maybe_recover_colon_colon_in_pat_typo(\n+    pub(crate) fn maybe_recover_colon_colon_in_pat_typo(\n         &mut self,\n         mut first_pat: P<Pat>,\n         ra: RecoverColon,\n@@ -2575,7 +2575,7 @@ impl<'a> Parser<'a> {\n         first_pat\n     }\n \n-    crate fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n+    pub(crate) fn maybe_recover_unexpected_block_label(&mut self) -> bool {\n         let Some(label) = self.eat_label().filter(|_| {\n             self.eat(&token::Colon) && self.token.kind == token::OpenDelim(Delimiter::Brace)\n         }) else {\n@@ -2596,7 +2596,7 @@ impl<'a> Parser<'a> {\n \n     /// Some special error handling for the \"top-level\" patterns in a match arm,\n     /// `for` loop, `let`, &c. (in contrast to subpatterns within such).\n-    crate fn maybe_recover_unexpected_comma(\n+    pub(crate) fn maybe_recover_unexpected_comma(\n         &mut self,\n         lo: Span,\n         rc: RecoverComma,\n@@ -2643,7 +2643,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    crate fn maybe_recover_bounds_doubled_colon(&mut self, ty: &Ty) -> PResult<'a, ()> {\n+    pub(crate) fn maybe_recover_bounds_doubled_colon(&mut self, ty: &Ty) -> PResult<'a, ()> {\n         let TyKind::Path(qself, path) = &ty.kind else { return Ok(()) };\n         let qself_position = qself.as_ref().map(|qself| qself.position);\n         for (i, segments) in path.segments.windows(2).enumerate() {"}, {"sha": "b5467c659a205a2db8e0ebf2b47b8bae123fda47", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2380,7 +2380,7 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::Loop(body, opt_label), attrs))\n     }\n \n-    crate fn eat_label(&mut self) -> Option<Label> {\n+    pub(crate) fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n             self.bump();\n             Label { ident }\n@@ -3049,7 +3049,7 @@ impl<'a> Parser<'a> {\n         await_expr\n     }\n \n-    crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n+    pub(crate) fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {\n         P(Expr { kind, span, attrs, id: DUMMY_NODE_ID, tokens: None })\n     }\n "}, {"sha": "1930dec8c3b227c1c7616925b5b507caefae1b4d", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -51,7 +51,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    crate fn parse_const_param(\n+    pub(crate) fn parse_const_param(\n         &mut self,\n         preceding_attrs: Vec<Attribute>,\n     ) -> PResult<'a, GenericParam> {"}, {"sha": "5bd07c31c0e7b3777d13b888f3cbac0380e2e474", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1415,7 +1415,7 @@ impl<'a> Parser<'a> {\n     }\n }\n \n-crate fn make_unclosed_delims_error(\n+pub(crate) fn make_unclosed_delims_error(\n     unmatched: UnmatchedBrace,\n     sess: &ParseSess,\n ) -> Option<DiagnosticBuilder<'_, ErrorGuaranteed>> {"}, {"sha": "27a6a48747408f959bb312f409cd951ea65c4e1a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -36,7 +36,7 @@ impl<'a> Parser<'a> {\n \n     /// If `force_capture` is true, forces collection of tokens regardless of whether\n     /// or not we have attributes\n-    crate fn parse_stmt_without_recovery(\n+    pub(crate) fn parse_stmt_without_recovery(\n         &mut self,\n         capture_semi: bool,\n         force_collect: ForceCollect,\n@@ -500,7 +500,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses the rest of a block expression or function body.\n     /// Precondition: already parsed the '{'.\n-    crate fn parse_block_tail(\n+    pub(crate) fn parse_block_tail(\n         &mut self,\n         lo: Span,\n         s: BlockCheckMode,"}, {"sha": "2c79ac49b36da3556272560686bf0f3041d76efa", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -6,7 +6,6 @@\n \n #![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(iter_intersperse)]\n #![feature(let_else)]\n #![feature(let_chains)]"}, {"sha": "83f728d407667ba8f2402d7b880af157b1d7ff84", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     tcx.hir().deep_visit_item_likes_in_module(module_def_id, &mut CheckNakedFunctions { tcx });\n }\n \n-crate fn provide(providers: &mut Providers) {\n+pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n "}, {"sha": "bfc51dedbc7fc45d38f69b6eca3796e954e07f0b", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,6 @@\n //! Support for serializing the dep-graph and reloading it.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(crate_visibility_modifier)]\n #![feature(nll)]\n #![feature(min_specialization)]\n #![feature(once_cell)]"}, {"sha": "634236c0dac75089e25869cb6b36f14d1489c1ef", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -129,7 +129,7 @@ impl<'tcx> QueryCtxt<'tcx> {\n         QueryCtxt { tcx, queries }\n     }\n \n-    crate fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n+    pub(crate) fn on_disk_cache(self) -> Option<&'tcx on_disk_cache::OnDiskCache<'tcx>> {\n         self.queries.on_disk_cache.as_ref()\n     }\n "}, {"sha": "3879779635b32ffe689668768c0bc27c3d5576f4", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -81,7 +81,7 @@ impl<'a> ToNameBinding<'a> for (Res, ty::Visibility, Span, LocalExpnId, IsMacroE\n impl<'a> Resolver<'a> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n-    crate fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n+    pub(crate) fn define<T>(&mut self, parent: Module<'a>, ident: Ident, ns: Namespace, def: T)\n     where\n         T: ToNameBinding<'a>,\n     {\n@@ -127,7 +127,7 @@ impl<'a> Resolver<'a> {\n     /// If `def_id` refers to a module (in resolver's sense, i.e. a module item, crate root, enum,\n     /// or trait), then this function returns that module's resolver representation, otherwise it\n     /// returns `None`.\n-    crate fn get_module(&mut self, def_id: DefId) -> Option<Module<'a>> {\n+    pub(crate) fn get_module(&mut self, def_id: DefId) -> Option<Module<'a>> {\n         if let module @ Some(..) = self.module_map.get(&def_id) {\n             return module.copied();\n         }\n@@ -162,7 +162,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n+    pub(crate) fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         match expn_id.expn_data().macro_def_id {\n             Some(def_id) => self.macro_def_scope(def_id),\n             None => expn_id\n@@ -172,23 +172,23 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn macro_def_scope(&mut self, def_id: DefId) -> Module<'a> {\n+    pub(crate) fn macro_def_scope(&mut self, def_id: DefId) -> Module<'a> {\n         if let Some(id) = def_id.as_local() {\n             self.local_macro_def_scopes[&id]\n         } else {\n             self.get_nearest_non_block_module(def_id)\n         }\n     }\n \n-    crate fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n+    pub(crate) fn get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         match res {\n             Res::Def(DefKind::Macro(..), def_id) => Some(self.get_macro_by_def_id(def_id)),\n             Res::NonMacroAttr(_) => Some(self.non_macro_attr.clone()),\n             _ => None,\n         }\n     }\n \n-    crate fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n+    pub(crate) fn get_macro_by_def_id(&mut self, def_id: DefId) -> Lrc<SyntaxExtension> {\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return ext.clone();\n         }\n@@ -202,7 +202,7 @@ impl<'a> Resolver<'a> {\n         ext\n     }\n \n-    crate fn build_reduced_graph(\n+    pub(crate) fn build_reduced_graph(\n         &mut self,\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n@@ -213,7 +213,7 @@ impl<'a> Resolver<'a> {\n         visitor.parent_scope.macro_rules\n     }\n \n-    crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n+    pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n         for child in self.cstore().module_children_untracked(module.def_id(), self.session) {\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }"}, {"sha": "5dc720e0abc9fa50925f256eb0957691e93d8936", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -224,7 +224,7 @@ fn calc_unused_spans(\n }\n \n impl Resolver<'_> {\n-    crate fn check_unused(&mut self, krate: &ast::Crate) {\n+    pub(crate) fn check_unused(&mut self, krate: &ast::Crate) {\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {\n                 _ if import.used.get()"}, {"sha": "f9aff7fd68685e6a37d75604166cc2e87c364695", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -11,7 +11,7 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use tracing::debug;\n \n-crate fn collect_definitions(\n+pub(crate) fn collect_definitions(\n     resolver: &mut Resolver<'_>,\n     fragment: &AstFragment,\n     expansion: LocalExpnId,"}, {"sha": "c199cff2038729e3ce0aa59961e8fcfb1b9f78bc", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -41,36 +41,36 @@ mod tests;\n type Res = def::Res<ast::NodeId>;\n \n /// A vector of spans and replacements, a message and applicability.\n-crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n+pub(crate) type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n /// Potential candidate for an undeclared or out-of-scope label - contains the ident of a\n /// similarly named label and whether or not it is reachable.\n-crate type LabelSuggestion = (Ident, bool);\n+pub(crate) type LabelSuggestion = (Ident, bool);\n \n-crate enum SuggestionTarget {\n+pub(crate) enum SuggestionTarget {\n     /// The target has a similar name as the name used by the programmer (probably a typo)\n     SimilarlyNamed,\n     /// The target is the only valid item that can be used in the corresponding context\n     SingleItem,\n }\n \n-crate struct TypoSuggestion {\n+pub(crate) struct TypoSuggestion {\n     pub candidate: Symbol,\n     pub res: Res,\n     pub target: SuggestionTarget,\n }\n \n impl TypoSuggestion {\n-    crate fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    pub(crate) fn typo_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         Self { candidate, res, target: SuggestionTarget::SimilarlyNamed }\n     }\n-    crate fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    pub(crate) fn single_item_from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         Self { candidate, res, target: SuggestionTarget::SingleItem }\n     }\n }\n \n /// A free importable items suggested in case of resolution failure.\n-crate struct ImportSuggestion {\n+pub(crate) struct ImportSuggestion {\n     pub did: Option<DefId>,\n     pub descr: &'static str,\n     pub path: Path,\n@@ -92,7 +92,7 @@ fn reduce_impl_span_to_impl_keyword(sm: &SourceMap, impl_span: Span) -> Span {\n }\n \n impl<'a> Resolver<'a> {\n-    crate fn report_errors(&mut self, krate: &Crate) {\n+    pub(crate) fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n         for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n@@ -147,7 +147,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_conflict<'b>(\n+    pub(crate) fn report_conflict<'b>(\n         &mut self,\n         parent: Module<'_>,\n         ident: Ident,\n@@ -419,7 +419,7 @@ impl<'a> Resolver<'a> {\n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);\n     }\n \n-    crate fn lint_if_path_starts_with_module(\n+    pub(crate) fn lint_if_path_starts_with_module(\n         &mut self,\n         finalize: Option<Finalize>,\n         path: &[Segment],\n@@ -475,7 +475,7 @@ impl<'a> Resolver<'a> {\n         );\n     }\n \n-    crate fn add_module_candidates(\n+    pub(crate) fn add_module_candidates(\n         &mut self,\n         module: Module<'a>,\n         names: &mut Vec<TypoSuggestion>,\n@@ -495,11 +495,11 @@ impl<'a> Resolver<'a> {\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n     /// error and emits it.\n-    crate fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n+    pub(crate) fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n         self.into_struct_error(span, resolution_error).emit();\n     }\n \n-    crate fn into_struct_error(\n+    pub(crate) fn into_struct_error(\n         &mut self,\n         span: Span,\n         resolution_error: ResolutionError<'a>,\n@@ -1052,7 +1052,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_vis_error(\n+    pub(crate) fn report_vis_error(\n         &mut self,\n         vis_resolution_error: VisResolutionError<'_>,\n     ) -> ErrorGuaranteed {\n@@ -1413,7 +1413,7 @@ impl<'a> Resolver<'a> {\n     ///\n     /// N.B., the method does not look into imports, but this is not a problem,\n     /// since we report the definitions (thus, the de-aliased imports).\n-    crate fn lookup_import_candidates<FilterFn>(\n+    pub(crate) fn lookup_import_candidates<FilterFn>(\n         &mut self,\n         lookup_ident: Ident,\n         namespace: Namespace,\n@@ -1460,7 +1460,7 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    crate fn unresolved_macro_suggestions(\n+    pub(crate) fn unresolved_macro_suggestions(\n         &mut self,\n         err: &mut Diagnostic,\n         macro_kind: MacroKind,\n@@ -1551,7 +1551,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn add_typo_suggestion(\n+    pub(crate) fn add_typo_suggestion(\n         &self,\n         err: &mut Diagnostic,\n         suggestion: Option<TypoSuggestion>,\n@@ -1780,7 +1780,7 @@ impl<'a> Resolver<'a> {\n         err.emit();\n     }\n \n-    crate fn find_similarly_named_module_or_crate(\n+    pub(crate) fn find_similarly_named_module_or_crate(\n         &mut self,\n         ident: Symbol,\n         current_module: &Module<'a>,\n@@ -1807,7 +1807,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn report_path_resolution_error(\n+    pub(crate) fn report_path_resolution_error(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -2680,7 +2680,7 @@ fn is_span_suitable_for_use_injection(s: Span) -> bool {\n }\n \n /// Convert the given number into the corresponding ordinal\n-crate fn ordinalize(v: usize) -> String {\n+pub(crate) fn ordinalize(v: usize) -> String {\n     let suffix = match ((11..=13).contains(&(v % 100)), v % 10) {\n         (false, 1) => \"st\",\n         (false, 2) => \"nd\","}, {"sha": "b25393c3ed8e4daccfbff4a072b1f6d520cf792a", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -28,7 +28,7 @@ impl<'a> Resolver<'a> {\n     /// A generic scope visitor.\n     /// Visits scopes in order to resolve some identifier in them or perform other actions.\n     /// If the callback returns `Some` result, we stop visiting scopes and return it.\n-    crate fn visit_scopes<T>(\n+    pub(crate) fn visit_scopes<T>(\n         &mut self,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n@@ -274,7 +274,7 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     #[tracing::instrument(level = \"debug\", skip(self, ribs))]\n-    crate fn resolve_ident_in_lexical_scope(\n+    pub(crate) fn resolve_ident_in_lexical_scope(\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n@@ -368,7 +368,7 @@ impl<'a> Resolver<'a> {\n     /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n     /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n     #[tracing::instrument(level = \"debug\", skip(self, scope_set))]\n-    crate fn early_resolve_ident_in_lexical_scope(\n+    pub(crate) fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n@@ -717,7 +717,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn maybe_resolve_ident_in_module(\n+    pub(crate) fn maybe_resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n@@ -729,7 +729,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn resolve_ident_in_module(\n+    pub(crate) fn resolve_ident_in_module(\n         &mut self,\n         module: ModuleOrUniformRoot<'a>,\n         ident: Ident,\n@@ -1303,7 +1303,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn maybe_resolve_path(\n+    pub(crate) fn maybe_resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -1313,7 +1313,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n-    crate fn resolve_path(\n+    pub(crate) fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n@@ -1324,7 +1324,7 @@ impl<'a> Resolver<'a> {\n         self.resolve_path_with_ribs(path, opt_ns, parent_scope, finalize, None, ignore_binding)\n     }\n \n-    crate fn resolve_path_with_ribs(\n+    pub(crate) fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import"}, {"sha": "a8c8c674d2dd0ff4c0baa1fff96bc5b510a67a99", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -64,7 +64,7 @@ pub enum ImportKind<'a> {\n \n /// One import.\n #[derive(Debug, Clone)]\n-crate struct Import<'a> {\n+pub(crate) struct Import<'a> {\n     pub kind: ImportKind<'a>,\n \n     /// The ID of the `extern crate`, `UseTree` etc that imported this `Import`.\n@@ -125,7 +125,7 @@ impl<'a> Import<'a> {\n \n /// Records information about the resolution of a name in a namespace of a module.\n #[derive(Clone, Default, Debug)]\n-crate struct NameResolution<'a> {\n+pub(crate) struct NameResolution<'a> {\n     /// Single imports that may define the name in the namespace.\n     /// Imports are arena-allocated, so it's ok to use pointers as keys.\n     pub single_imports: FxHashSet<Interned<'a, Import<'a>>>,\n@@ -146,7 +146,7 @@ impl<'a> NameResolution<'a> {\n         })\n     }\n \n-    crate fn add_single_import(&mut self, import: &'a Import<'a>) {\n+    pub(crate) fn add_single_import(&mut self, import: &'a Import<'a>) {\n         self.single_imports.insert(Interned::new_unchecked(import));\n     }\n }\n@@ -169,7 +169,7 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n impl<'a> Resolver<'a> {\n     // Given a binding and an import that resolves to it,\n     // return the corresponding binding defined by the import.\n-    crate fn import(\n+    pub(crate) fn import(\n         &self,\n         binding: &'a NameBinding<'a>,\n         import: &'a Import<'a>,\n@@ -198,7 +198,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n-    crate fn try_define(\n+    pub(crate) fn try_define(\n         &mut self,\n         module: Module<'a>,\n         key: BindingKey,"}, {"sha": "ff87baeef3e66ea6ef522ca69145970ddfcde3df", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -37,7 +37,7 @@ use std::mem::{replace, take};\n use tracing::debug;\n \n mod diagnostics;\n-crate mod lifetimes;\n+pub(crate) mod lifetimes;\n \n type Res = def::Res<NodeId>;\n \n@@ -90,7 +90,7 @@ enum PatBoundCtx {\n \n /// Does this the item (from the item rib scope) allow generic parameters?\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum HasGenericParams {\n+pub(crate) enum HasGenericParams {\n     Yes,\n     No,\n }\n@@ -102,15 +102,15 @@ impl HasGenericParams {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-crate enum ConstantItemKind {\n+pub(crate) enum ConstantItemKind {\n     Const,\n     Static,\n }\n \n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n-crate enum RibKind<'a> {\n+pub(crate) enum RibKind<'a> {\n     /// No restriction needs to be applied.\n     NormalRibKind,\n \n@@ -159,7 +159,7 @@ crate enum RibKind<'a> {\n impl RibKind<'_> {\n     /// Whether this rib kind contains generic parameters, as opposed to local\n     /// variables.\n-    crate fn contains_params(&self) -> bool {\n+    pub(crate) fn contains_params(&self) -> bool {\n         match self {\n             NormalRibKind\n             | ClosureOrAsyncRibKind\n@@ -187,7 +187,7 @@ impl RibKind<'_> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-crate struct Rib<'a, R = Res> {\n+pub(crate) struct Rib<'a, R = Res> {\n     pub bindings: IdentMap<R>,\n     pub kind: RibKind<'a>,\n }\n@@ -278,13 +278,13 @@ impl LifetimeRib {\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum AliasPossibility {\n+pub(crate) enum AliasPossibility {\n     No,\n     Maybe,\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum PathSource<'a> {\n+pub(crate) enum PathSource<'a> {\n     // Type paths `Path`.\n     Type,\n     // Trait paths in bounds or impls.\n@@ -366,7 +366,7 @@ impl<'a> PathSource<'a> {\n         matches!(self, PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })))\n     }\n \n-    crate fn is_expected(self, res: Res) -> bool {\n+    pub(crate) fn is_expected(self, res: Res) -> bool {\n         match self {\n             PathSource::Type => matches!(\n                 res,"}, {"sha": "673b2e3a55a35f22df2ef43d5cd4f9f043251487", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -59,28 +59,28 @@ impl AssocSuggestion {\n     }\n }\n \n-crate enum MissingLifetimeSpot<'tcx> {\n+pub(crate) enum MissingLifetimeSpot<'tcx> {\n     Generics(&'tcx hir::Generics<'tcx>),\n     HigherRanked { span: Span, span_type: ForLifetimeSpanType },\n     Static,\n }\n \n-crate enum ForLifetimeSpanType {\n+pub(crate) enum ForLifetimeSpanType {\n     BoundEmpty,\n     BoundTail,\n     TypeEmpty,\n     TypeTail,\n }\n \n impl ForLifetimeSpanType {\n-    crate fn descr(&self) -> &'static str {\n+    pub(crate) fn descr(&self) -> &'static str {\n         match self {\n             Self::BoundEmpty | Self::BoundTail => \"bound\",\n             Self::TypeEmpty | Self::TypeTail => \"type\",\n         }\n     }\n \n-    crate fn suggestion(&self, sugg: &str) -> String {\n+    pub(crate) fn suggestion(&self, sugg: &str) -> String {\n         match self {\n             Self::BoundEmpty | Self::TypeEmpty => format!(\"for<{}> \", sugg),\n             Self::BoundTail | Self::TypeTail => format!(\", {}\", sugg),\n@@ -1221,7 +1221,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     /// Given the target `ident` and `kind`, search for the similarly named associated item\n     /// in `self.current_trait_ref`.\n-    crate fn find_similarly_named_assoc_item(\n+    pub(crate) fn find_similarly_named_assoc_item(\n         &mut self,\n         ident: Symbol,\n         kind: &AssocItemKind,\n@@ -1729,7 +1729,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    crate fn report_missing_type_error(\n+    pub(crate) fn report_missing_type_error(\n         &self,\n         path: &[Segment],\n     ) -> Option<(Span, &'static str, String, Applicability)> {\n@@ -1809,7 +1809,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n     /// Given the target `label`, search the `rib_index`th label rib for similarly named labels,\n     /// optionally returning the closest match and whether it is reachable.\n-    crate fn suggestion_for_label_in_rib(\n+    pub(crate) fn suggestion_for_label_in_rib(\n         &self,\n         rib_index: usize,\n         label: Ident,\n@@ -1834,7 +1834,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         })\n     }\n \n-    crate fn maybe_report_lifetime_uses(\n+    pub(crate) fn maybe_report_lifetime_uses(\n         &mut self,\n         generics_span: Span,\n         params: &[ast::GenericParam],\n@@ -1904,7 +1904,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n     }\n \n-    crate fn emit_undeclared_lifetime_error(\n+    pub(crate) fn emit_undeclared_lifetime_error(\n         &self,\n         lifetime_ref: &ast::Lifetime,\n         outer_lifetime_ref: Option<Ident>,\n@@ -2000,7 +2000,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         err.emit();\n     }\n \n-    crate fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n+    pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n         struct_span_err!(\n             self.r.session,\n             lifetime_ref.ident.span,\n@@ -2018,7 +2018,10 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     /// Non-static lifetimes are prohibited in anonymous constants under `min_const_generics`.\n     /// This function will emit an error if `generic_const_exprs` is not enabled, the body identified by\n     /// `body_id` is an anonymous constant and `lifetime_ref` is non-static.\n-    crate fn maybe_emit_forbidden_non_static_lifetime_error(&self, lifetime_ref: &ast::Lifetime) {\n+    pub(crate) fn maybe_emit_forbidden_non_static_lifetime_error(\n+        &self,\n+        lifetime_ref: &ast::Lifetime,\n+    ) {\n         let feature_active = self.r.session.features_untracked().generic_const_exprs;\n         if !feature_active {\n             feature_err(\n@@ -2033,7 +2036,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n }\n \n impl<'tcx> LifetimeContext<'_, 'tcx> {\n-    crate fn report_missing_lifetime_specifiers(\n+    pub(crate) fn report_missing_lifetime_specifiers(\n         &self,\n         spans: Vec<Span>,\n         count: usize,\n@@ -2048,7 +2051,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     }\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n-    crate fn report_elision_failure(\n+    pub(crate) fn report_elision_failure(\n         &mut self,\n         diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n@@ -2126,7 +2129,10 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         }\n     }\n \n-    crate fn is_trait_ref_fn_scope(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) -> bool {\n+    pub(crate) fn is_trait_ref_fn_scope(\n+        &mut self,\n+        trait_ref: &'tcx hir::PolyTraitRef<'tcx>,\n+    ) -> bool {\n         if let def::Res::Def(_, did) = trait_ref.trait_ref.path.res {\n             if [\n                 self.tcx.lang_items().fn_once_trait(),\n@@ -2147,7 +2153,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         false\n     }\n \n-    crate fn add_missing_lifetime_specifiers_label(\n+    pub(crate) fn add_missing_lifetime_specifiers_label(\n         &self,\n         err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,"}, {"sha": "2fe65441ac90e8e6da53b35dd4a06157744e1627", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -151,8 +151,8 @@ struct NamedRegionMap {\n     scope_for_path: Option<FxHashMap<LocalDefId, FxHashMap<ItemLocalId, LifetimeScopeForPath>>>,\n }\n \n-crate struct LifetimeContext<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct LifetimeContext<'a, 'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n@@ -169,7 +169,7 @@ crate struct LifetimeContext<'a, 'tcx> {\n \n     /// When encountering an undefined named lifetime, we will suggest introducing it in these\n     /// places.\n-    crate missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n+    pub(crate) missing_named_lifetime_spots: Vec<MissingLifetimeSpot<'tcx>>,\n }\n \n #[derive(Debug)]\n@@ -335,14 +335,14 @@ enum Elide {\n }\n \n #[derive(Clone, Debug)]\n-crate struct ElisionFailureInfo {\n+pub(crate) struct ElisionFailureInfo {\n     /// Where we can find the argument pattern.\n-    crate parent: Option<hir::BodyId>,\n+    pub(crate) parent: Option<hir::BodyId>,\n     /// The index of the argument in the original definition.\n-    crate index: usize,\n-    crate lifetime_count: usize,\n-    crate have_bound_regions: bool,\n-    crate span: Span,\n+    pub(crate) index: usize,\n+    pub(crate) lifetime_count: usize,\n+    pub(crate) have_bound_regions: bool,\n+    pub(crate) span: Span,\n }\n \n type ScopeRef<'a> = &'a Scope<'a>;"}, {"sha": "73c8a9d28bd5f4372d364ea95d657086a8b6ec4c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "7e6375968aeb64b58fab58e84b148d185de5b4c0", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -41,10 +41,10 @@ type Res = def::Res<NodeId>;\n /// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n pub struct MacroRulesBinding<'a> {\n-    crate binding: &'a NameBinding<'a>,\n+    pub(crate) binding: &'a NameBinding<'a>,\n     /// `macro_rules` scope into which the `macro_rules` item was planted.\n-    crate parent_macro_rules_scope: MacroRulesScopeRef<'a>,\n-    crate ident: Ident,\n+    pub(crate) parent_macro_rules_scope: MacroRulesScopeRef<'a>,\n+    pub(crate) ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n@@ -74,7 +74,10 @@ pub(crate) type MacroRulesScopeRef<'a> = Interned<'a, Cell<MacroRulesScope<'a>>>\n /// Macro namespace is separated into two sub-namespaces, one for bang macros and\n /// one for attribute-like macros (attributes, derives).\n /// We ignore resolutions from one sub-namespace when searching names in scope for another.\n-crate fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKind>) -> bool {\n+pub(crate) fn sub_namespace_match(\n+    candidate: Option<MacroKind>,\n+    requirement: Option<MacroKind>,\n+) -> bool {\n     #[derive(PartialEq)]\n     enum SubNS {\n         Bang,\n@@ -140,7 +143,7 @@ fn registered_idents(\n     registered\n }\n \n-crate fn registered_attrs_and_tools(\n+pub(crate) fn registered_attrs_and_tools(\n     sess: &Session,\n     attrs: &[ast::Attribute],\n ) -> (FxHashSet<Ident>, FxHashSet<Ident>) {\n@@ -651,7 +654,7 @@ impl<'a> Resolver<'a> {\n         res.map(|res| (self.get_macro(res), res))\n     }\n \n-    crate fn finalize_macro_resolutions(&mut self) {\n+    pub(crate) fn finalize_macro_resolutions(&mut self) {\n         let check_consistency = |this: &mut Self,\n                                  path: &[Segment],\n                                  span,\n@@ -839,7 +842,7 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n+    pub(crate) fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n         // Reserve some names that are not quite covered by the general check\n         // performed on `Resolver::builtin_attrs`.\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n@@ -856,7 +859,7 @@ impl<'a> Resolver<'a> {\n     /// Compile the macro into a `SyntaxExtension` and its rule spans.\n     ///\n     /// Possibly replace its expander to a pre-defined one for built-in macros.\n-    crate fn compile_macro(\n+    pub(crate) fn compile_macro(\n         &mut self,\n         item: &ast::Item,\n         edition: Edition,"}, {"sha": "997f361737b349236d4e36039674a3c12356da2b", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1912,7 +1912,7 @@ fn select_debuginfo(\n     }\n }\n \n-crate fn parse_assert_incr_state(\n+pub(crate) fn parse_assert_incr_state(\n     opt_assertion: &Option<String>,\n     error_format: ErrorOutputType,\n ) -> Option<IncrementalStateAssertion> {\n@@ -2755,7 +2755,7 @@ impl PpMode {\n /// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n-crate mod dep_tracking {\n+pub(crate) mod dep_tracking {\n     use super::{\n         BranchProtection, CFGuard, CFProtection, CrateType, DebugInfo, ErrorOutputType,\n         InstrumentCoverage, LdImpl, LinkerPluginLto, LocationDetail, LtoCli, OomStrategy, OptLevel,\n@@ -2933,7 +2933,7 @@ crate mod dep_tracking {\n     }\n \n     // This is a stable hash because BTreeMap is a sorted container\n-    crate fn stable_hash(\n+    pub(crate) fn stable_hash(\n         sub_hashes: BTreeMap<&'static str, &dyn DepTrackingHash>,\n         hasher: &mut DefaultHasher,\n         error_format: ErrorOutputType,"}, {"sha": "f84a154950f646925e2e8106e9df16372396518b", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,4 +1,3 @@\n-#![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![cfg_attr(bootstrap, feature(derive_default_enum))]"}, {"sha": "12e00ef51140bbacf89dc612ed2f10d8ab6a3564", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 72, "deletions": 48, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -421,12 +421,12 @@ mod desc {\n }\n \n mod parse {\n-    crate use super::*;\n+    pub(crate) use super::*;\n     use std::str::FromStr;\n \n     /// This is for boolean options that don't take a value and start with\n     /// `no-`. This style of option is deprecated.\n-    crate fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_no_flag(slot: &mut bool, v: Option<&str>) -> bool {\n         match v {\n             None => {\n                 *slot = true;\n@@ -437,7 +437,7 @@ mod parse {\n     }\n \n     /// Use this for any boolean option that has a static default.\n-    crate fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n         match v {\n             Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n                 *slot = true;\n@@ -454,7 +454,7 @@ mod parse {\n     /// Use this for any boolean option that lacks a static default. (The\n     /// actions taken when such an option is not specified will depend on\n     /// other factors, such as other options, or target options.)\n-    crate fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n         match v {\n             Some(\"y\") | Some(\"yes\") | Some(\"on\") | None => {\n                 *slot = Some(true);\n@@ -469,7 +469,7 @@ mod parse {\n     }\n \n     /// Use this for any string option that has a static default.\n-    crate fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.to_string();\n@@ -480,7 +480,7 @@ mod parse {\n     }\n \n     /// Use this for any string option that lacks a static default.\n-    crate fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = Some(s.to_string());\n@@ -491,7 +491,7 @@ mod parse {\n     }\n \n     /// Parse an optional language identifier, e.g. `en-US` or `zh-CN`.\n-    crate fn parse_opt_langid(slot: &mut Option<LanguageIdentifier>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_langid(slot: &mut Option<LanguageIdentifier>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = rustc_errors::LanguageIdentifier::from_str(s).ok();\n@@ -501,7 +501,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = Some(PathBuf::from(s));\n@@ -511,7 +511,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 slot.push(s.to_string());\n@@ -521,7 +521,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_list(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_list(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 slot.extend(s.split_whitespace().map(|s| s.to_string()));\n@@ -531,7 +531,10 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_list_with_polarity(slot: &mut Vec<(String, bool)>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_list_with_polarity(\n+        slot: &mut Vec<(String, bool)>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 for s in s.split(\",\") {\n@@ -544,7 +547,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_location_detail(ld: &mut LocationDetail, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_location_detail(ld: &mut LocationDetail, v: Option<&str>) -> bool {\n         if let Some(v) = v {\n             ld.line = false;\n             ld.file = false;\n@@ -563,7 +566,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 let mut v: Vec<_> = s.split(',').map(|s| s.to_string()).collect();\n@@ -575,7 +578,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n         match v.and_then(|s| s.parse().ok()) {\n             Some(0) => {\n                 *slot = std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get);\n@@ -590,7 +593,7 @@ mod parse {\n     }\n \n     /// Use this for any numeric option that has a static default.\n-    crate fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_number<T: Copy + FromStr>(slot: &mut T, v: Option<&str>) -> bool {\n         match v.and_then(|s| s.parse().ok()) {\n             Some(i) => {\n                 *slot = i;\n@@ -601,7 +604,10 @@ mod parse {\n     }\n \n     /// Use this for any numeric option that lacks a static default.\n-    crate fn parse_opt_number<T: Copy + FromStr>(slot: &mut Option<T>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_number<T: Copy + FromStr>(\n+        slot: &mut Option<T>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.parse().ok();\n@@ -611,7 +617,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n         match v {\n             Some(\"all\") => {\n                 *slot = Passes::All;\n@@ -629,7 +635,10 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_opt_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_opt_panic_strategy(\n+        slot: &mut Option<PanicStrategy>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n             Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n@@ -638,7 +647,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_panic_strategy(slot: &mut PanicStrategy, v: Option<&str>) -> bool {\n         match v {\n             Some(\"unwind\") => *slot = PanicStrategy::Unwind,\n             Some(\"abort\") => *slot = PanicStrategy::Abort,\n@@ -647,7 +656,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_oom_strategy(slot: &mut OomStrategy, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_oom_strategy(slot: &mut OomStrategy, v: Option<&str>) -> bool {\n         match v {\n             Some(\"panic\") => *slot = OomStrategy::Panic,\n             Some(\"abort\") => *slot = OomStrategy::Abort,\n@@ -656,7 +665,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => match s.parse::<RelroLevel>() {\n                 Ok(level) => *slot = Some(level),\n@@ -667,7 +676,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_sanitizers(slot: &mut SanitizerSet, v: Option<&str>) -> bool {\n         if let Some(v) = v {\n             for s in v.split(',') {\n                 *slot |= match s {\n@@ -687,7 +696,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n         match v {\n             Some(\"2\") | None => {\n                 *slot = 2;\n@@ -705,7 +714,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_strip(slot: &mut Strip, v: Option<&str>) -> bool {\n         match v {\n             Some(\"none\") => *slot = Strip::None,\n             Some(\"debuginfo\") => *slot = Strip::Debuginfo,\n@@ -715,7 +724,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_cfguard(slot: &mut CFGuard, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -733,7 +742,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_cfprotection(slot: &mut CFProtection, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_cfprotection(slot: &mut CFProtection, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -752,15 +761,18 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_linker_flavor(slot: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_linker_flavor(slot: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n         match v.and_then(LinkerFlavor::from_str) {\n             Some(lf) => *slot = Some(lf),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_optimization_fuel(\n+        slot: &mut Option<(String, u64)>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             None => false,\n             Some(s) => {\n@@ -779,7 +791,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n         match v {\n             None => false,\n             Some(s) if s.split('=').count() <= 2 => {\n@@ -790,7 +802,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -813,7 +825,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_instrument_coverage(\n+    pub(crate) fn parse_instrument_coverage(\n         slot: &mut Option<InstrumentCoverage>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -844,7 +856,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_treat_err_as_bug(slot: &mut Option<NonZeroUsize>, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 *slot = s.parse().ok();\n@@ -857,7 +869,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -875,7 +887,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n         if v.is_some() {\n             let mut bool_arg = None;\n             if parse_opt_bool(&mut bool_arg, v) {\n@@ -895,23 +907,29 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_switch_with_opt_path(\n+        slot: &mut SwitchWithOptPath,\n+        v: Option<&str>,\n+    ) -> bool {\n         *slot = match v {\n             None => SwitchWithOptPath::Enabled(None),\n             Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n         };\n         true\n     }\n \n-    crate fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_merge_functions(\n+        slot: &mut Option<MergeFunctions>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n             Some(mergefunc) => *slot = Some(mergefunc),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_relocation_model(slot: &mut Option<RelocModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| RelocModel::from_str(s).ok()) {\n             Some(relocation_model) => *slot = Some(relocation_model),\n             None if v == Some(\"default\") => *slot = None,\n@@ -920,23 +938,23 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_code_model(slot: &mut Option<CodeModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| CodeModel::from_str(s).ok()) {\n             Some(code_model) => *slot = Some(code_model),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_tls_model(slot: &mut Option<TlsModel>, v: Option<&str>) -> bool {\n         match v.and_then(|s| TlsModel::from_str(s).ok()) {\n             Some(tls_model) => *slot = Some(tls_model),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_symbol_mangling_version(\n+    pub(crate) fn parse_symbol_mangling_version(\n         slot: &mut Option<SymbolManglingVersion>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -948,7 +966,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_src_file_hash(\n+    pub(crate) fn parse_src_file_hash(\n         slot: &mut Option<SourceFileHashAlgorithm>,\n         v: Option<&str>,\n     ) -> bool {\n@@ -959,7 +977,7 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_target_feature(slot: &mut String, v: Option<&str>) -> bool {\n         match v {\n             Some(s) => {\n                 if !slot.is_empty() {\n@@ -972,7 +990,7 @@ mod parse {\n         }\n     }\n \n-    crate fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_wasi_exec_model(slot: &mut Option<WasiExecModel>, v: Option<&str>) -> bool {\n         match v {\n             Some(\"command\") => *slot = Some(WasiExecModel::Command),\n             Some(\"reactor\") => *slot = Some(WasiExecModel::Reactor),\n@@ -981,23 +999,26 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_split_debuginfo(slot: &mut Option<SplitDebuginfo>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_split_debuginfo(\n+        slot: &mut Option<SplitDebuginfo>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v.and_then(|s| SplitDebuginfo::from_str(s).ok()) {\n             Some(e) => *slot = Some(e),\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n         match v.and_then(|s| SplitDwarfKind::from_str(s).ok()) {\n             Some(e) => *slot = e,\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n         match v {\n             None => *slot = None,\n             Some(\"lld\") => *slot = Some(LdImpl::Lld),\n@@ -1006,15 +1027,18 @@ mod parse {\n         true\n     }\n \n-    crate fn parse_stack_protector(slot: &mut StackProtector, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_stack_protector(slot: &mut StackProtector, v: Option<&str>) -> bool {\n         match v.and_then(|s| StackProtector::from_str(s).ok()) {\n             Some(ssp) => *slot = ssp,\n             _ => return false,\n         }\n         true\n     }\n \n-    crate fn parse_branch_protection(slot: &mut Option<BranchProtection>, v: Option<&str>) -> bool {\n+    pub(crate) fn parse_branch_protection(\n+        slot: &mut Option<BranchProtection>,\n+        v: Option<&str>,\n+    ) -> bool {\n         match v {\n             Some(s) => {\n                 let slot = slot.get_or_insert_default();"}, {"sha": "59f2badbabbf62df56e8af0aa6b61592e2202d7f", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -352,7 +352,7 @@ pub struct HygieneData {\n }\n \n impl HygieneData {\n-    crate fn new(edition: Edition) -> Self {\n+    pub(crate) fn new(edition: Edition) -> Self {\n         let root_data = ExpnData::default(\n             ExpnKind::Root,\n             DUMMY_SP,\n@@ -668,17 +668,17 @@ impl SyntaxContext {\n     }\n \n     #[inline]\n-    crate fn as_u32(self) -> u32 {\n+    pub(crate) fn as_u32(self) -> u32 {\n         self.0\n     }\n \n     #[inline]\n-    crate fn from_u32(raw: u32) -> SyntaxContext {\n+    pub(crate) fn from_u32(raw: u32) -> SyntaxContext {\n         SyntaxContext(raw)\n     }\n \n     /// Extend a syntax context with a given expansion and transparency.\n-    crate fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+    pub(crate) fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n "}, {"sha": "8737e45487e9088bca701491341b0141b1e611c2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,7 +15,6 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(if_let_guard)]\n #![feature(negative_impls)]"}, {"sha": "f46e8ff000423b9288c90686d33baeff689285a7", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -14,7 +14,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![cfg_attr(bootstrap, feature(derive_default_enum))]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]"}, {"sha": "452b0d73c97cacff6bef0b4c64215ab288b33717", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -500,7 +500,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits.\n #[instrument(skip(tcx, predicates), level = \"debug\")]\n-crate fn required_region_bounds<'tcx>(\n+pub(crate) fn required_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     erased_self_ty: Ty<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,"}, {"sha": "592b0ab477a393056420847aada1759498d4eaf1", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,7 @@ pub struct FulfillmentContext<'tcx> {\n }\n \n impl FulfillmentContext<'_> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         FulfillmentContext {\n             obligations: FxIndexSet::default(),\n             relationships: FxHashMap::default(),"}, {"sha": "a51e6e58f67a984349ca44d61e313df2cdef3d83", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1488,7 +1488,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         expected_ref: ty::PolyTraitRef<'tcx>,\n         found: ty::PolyTraitRef<'tcx>,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        crate fn build_fn_sig_string<'tcx>(\n+        pub(crate) fn build_fn_sig_string<'tcx>(\n             tcx: TyCtxt<'tcx>,\n             trait_ref: ty::PolyTraitRef<'tcx>,\n         ) -> String {"}, {"sha": "a71621a4d52c0b90572d4adab0626af53008cb8e", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2116,7 +2116,7 @@ fn assoc_def(\n     }\n }\n \n-crate trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n+pub(crate) trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n         predicate: ty::PolyProjectionPredicate<'tcx>,"}, {"sha": "b0b17d0f9e6673b28e3909f4d9c2a59d9d89ac53", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -332,7 +332,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    crate fn select_from_obligation(\n+    pub(crate) fn select_from_obligation(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {"}, {"sha": "95f1e224a4c7f2ae66ba02d1113c22c13d49fdca", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -486,7 +486,7 @@ fn report_conflicting_impls(\n \n /// Recovers the \"impl X for Y\" signature from `impl_def_id` and returns it as a\n /// string.\n-crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n+pub(crate) fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String> {\n     use std::fmt::Write;\n \n     let trait_ref = tcx.impl_trait_ref(impl_def_id)?;"}, {"sha": "2b7ba22c4de38c1d29b22733101173faaf81a15c", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -44,7 +44,7 @@ use std::collections::btree_map::{BTreeMap, Entry};\n use std::ops::ControlFlow;\n \n /// Essentially an `Into` with a `&RustInterner` parameter\n-crate trait LowerInto<'tcx, T> {\n+pub(crate) trait LowerInto<'tcx, T> {\n     /// Lower a rustc construct (e.g., `ty::TraitPredicate`) to a chalk type, consuming `self`.\n     fn lower_into(self, interner: RustInterner<'tcx>) -> T;\n }\n@@ -836,7 +836,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n /// It's important to note that because of prior substitution, we may have\n /// late-bound regions, even outside of fn contexts, since this is the best way\n /// to prep types for chalk lowering.\n-crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n+pub(crate) fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     interner: RustInterner<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     ty: Binder<'tcx, T>,\n@@ -870,14 +870,14 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     (new_ty, binders, named_parameters)\n }\n \n-crate struct BoundVarsCollector<'tcx> {\n+pub(crate) struct BoundVarsCollector<'tcx> {\n     binder_index: ty::DebruijnIndex,\n-    crate parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n-    crate named_parameters: Vec<DefId>,\n+    pub(crate) parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n+    pub(crate) named_parameters: Vec<DefId>,\n }\n \n impl<'tcx> BoundVarsCollector<'tcx> {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         BoundVarsCollector {\n             binder_index: ty::INNERMOST,\n             parameters: BTreeMap::new(),\n@@ -1001,17 +1001,17 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n \n /// Used to substitute `Param`s with placeholders. We do this since Chalk\n /// have a notion of `Param`s.\n-crate struct ParamsSubstitutor<'tcx> {\n+pub(crate) struct ParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n     next_ty_placeholder: usize,\n-    crate params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n-    crate named_regions: BTreeMap<DefId, u32>,\n+    pub(crate) params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    pub(crate) named_regions: BTreeMap<DefId, u32>,\n }\n \n impl<'tcx> ParamsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, next_ty_placeholder: usize) -> Self {\n         ParamsSubstitutor {\n             tcx,\n             binder_index: ty::INNERMOST,\n@@ -1083,13 +1083,13 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n     }\n }\n \n-crate struct ReverseParamsSubstitutor<'tcx> {\n+pub(crate) struct ReverseParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n }\n \n impl<'tcx> ReverseParamsSubstitutor<'tcx> {\n-    crate fn new(\n+    pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n         params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n     ) -> Self {\n@@ -1117,14 +1117,14 @@ impl<'tcx> TypeFolder<'tcx> for ReverseParamsSubstitutor<'tcx> {\n }\n \n /// Used to collect `Placeholder`s.\n-crate struct PlaceholdersCollector {\n+pub(crate) struct PlaceholdersCollector {\n     universe_index: ty::UniverseIndex,\n-    crate next_ty_placeholder: usize,\n-    crate next_anon_region_placeholder: u32,\n+    pub(crate) next_ty_placeholder: usize,\n+    pub(crate) next_anon_region_placeholder: u32,\n }\n \n impl PlaceholdersCollector {\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         PlaceholdersCollector {\n             universe_index: ty::UniverseIndex::ROOT,\n             next_ty_placeholder: 0,"}, {"sha": "59cf37fee9c4327ad3a7f05c76519e0a73367964", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,8 +3,8 @@\n //! In order to call `chalk-solve`, this file must convert a `CanonicalChalkEnvironmentAndGoal` into\n //! a Chalk uncanonical goal. It then calls Chalk, and converts the answer back into rustc solution.\n \n-crate mod db;\n-crate mod lowering;\n+pub(crate) mod db;\n+pub(crate) mod lowering;\n \n use rustc_data_structures::fx::FxHashMap;\n \n@@ -27,11 +27,11 @@ use crate::chalk::lowering::{ParamsSubstitutor, PlaceholdersCollector, ReversePa\n \n use chalk_solve::Solution;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { evaluate_goal, ..*p };\n }\n \n-crate fn evaluate_goal<'tcx>(\n+pub(crate) fn evaluate_goal<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     obligation: CanonicalChalkEnvironmentAndGoal<'tcx>,\n ) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, ()>>, traits::query::NoSolution> {"}, {"sha": "a20de08b4eff28c947f5026f24b7c00c82533d1b", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,7 @@ use rustc_trait_selection::traits::{\n     Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n };\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };\n }\n \n@@ -304,7 +304,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n }\n \n /// Calculates the dtorck constraint for a type.\n-crate fn adt_dtorck_constraint(\n+pub(crate) fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> Result<&DropckConstraint<'_>, NoSolution> {"}, {"sha": "3fc141471b92ab31264e12876115542c33c0be92", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,7 @@ use rustc_trait_selection::traits::{\n     EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n };\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { evaluate_obligation, ..*p };\n }\n "}, {"sha": "965324113d526edaa2b1c49adbbd601b0ae3c75d", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -18,7 +18,7 @@ use rustc_trait_selection::traits::FulfillmentContext;\n use rustc_trait_selection::traits::TraitEngine;\n use smallvec::{smallvec, SmallVec};\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { implied_outlives_bounds, ..*p };\n }\n "}, {"sha": "6489bd2202deba0734346ab58031480d806b5a97", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,6 @@\n //! New recursive solver modeled on Chalk's recursive solver. Most of\n //! the guts are broken up into modules; see the comments in those modules.\n \n-#![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]"}, {"sha": "a8a324dec97ba7045f440a3703f9f307b13e3417", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -6,7 +6,7 @@ use rustc_trait_selection::traits::query::normalize::AtExt;\n use rustc_trait_selection::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n         try_normalize_generic_arg_after_erasing_regions: |tcx, goal| {\n             debug!(\"try_normalize_generic_arg_after_erasing_regions(goal={:#?}\", goal);"}, {"sha": "98bb42c9afda1cf0566ed535bb2c3e033dd129b0", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::query::{\n use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers { normalize_projection_ty, ..*p };\n }\n "}, {"sha": "f8bac1d7b263f65c42a577b251fbbb4118f735c6", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -23,7 +23,7 @@ use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n \n-crate fn provide(p: &mut Providers) {\n+pub(crate) fn provide(p: &mut Providers) {\n     *p = Providers {\n         type_op_ascribe_user_type,\n         type_op_eq,"}, {"sha": "96d083bb94f3c9353d7d55e85a3ae0e317d03989", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -640,7 +640,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         assoc_bindings\n     }\n \n-    crate fn create_substs_for_associated_item(\n+    pub(crate) fn create_substs_for_associated_item(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         span: Span,"}, {"sha": "a17b13d49fd7f2cd42f1f678967e99d76b0bf423", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1351,7 +1351,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n     /// is a forced-unit case, and hence `expression_ty` must be\n     /// `Nil`.\n     #[instrument(skip(self, fcx, augment_error, label_expression_as_expected), level = \"debug\")]\n-    crate fn coerce_inner<'a>(\n+    pub(crate) fn coerce_inner<'a>(\n         &mut self,\n         fcx: &FnCtxt<'a, 'tcx>,\n         cause: &ObligationCause<'tcx>,"}, {"sha": "277bc1cf0f06514abfdf23df83dc4f9d49f81275", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -28,7 +28,7 @@ use super::{potentially_plural_count, FnCtxt, Inherited};\n /// - `impl_m_span`: span to use for reporting errors\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n-crate fn compare_impl_method<'tcx>(\n+pub(crate) fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n@@ -1038,7 +1038,7 @@ fn compare_generic_param_kinds<'tcx>(\n     Ok(())\n }\n \n-crate fn compare_const_impl<'tcx>(\n+pub(crate) fn compare_const_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_c: &ty::AssocItem,\n     impl_c_span: Span,\n@@ -1144,7 +1144,7 @@ crate fn compare_const_impl<'tcx>(\n     });\n }\n \n-crate fn compare_ty_impl<'tcx>(\n+pub(crate) fn compare_ty_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_ty: &ty::AssocItem,\n     impl_ty_span: Span,"}, {"sha": "ceb57386e300f177059de32a0ad9f0d149f0d9eb", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn maybe_get_struct_pattern_shorthand_field(\n+    pub(crate) fn maybe_get_struct_pattern_shorthand_field(\n         &self,\n         expr: &hir::Expr<'_>,\n     ) -> Option<Symbol> {\n@@ -539,15 +539,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// If the given `HirId` corresponds to a block with a trailing expression, return that expression\n-    crate fn maybe_get_block_expr(&self, expr: &hir::Expr<'tcx>) -> Option<&'tcx hir::Expr<'tcx>> {\n+    pub(crate) fn maybe_get_block_expr(\n+        &self,\n+        expr: &hir::Expr<'tcx>,\n+    ) -> Option<&'tcx hir::Expr<'tcx>> {\n         match expr {\n             hir::Expr { kind: hir::ExprKind::Block(block, ..), .. } => block.expr,\n             _ => None,\n         }\n     }\n \n     /// Returns whether the given expression is an `else if`.\n-    crate fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n+    pub(crate) fn is_else_if_block(&self, expr: &hir::Expr<'_>) -> bool {\n         if let hir::ExprKind::If(..) = expr.kind {\n             let parent_id = self.tcx.hir().get_parent_node(expr.hir_id);\n             if let Some(Node::Expr(hir::Expr {"}, {"sha": "307064327c5a35bf804de8d0e42aaba93af0cd5b", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -231,7 +231,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n /// This function is not only checking that the dropck obligations are met for\n /// the given type, but it's also currently preventing non-regular recursion in\n /// types from causing stack overflows (dropck_no_diverge_on_nonregular_*.rs).\n-crate fn check_drop_obligations<'a, 'tcx>(\n+pub(crate) fn check_drop_obligations<'a, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'tcx>,\n     ty: Ty<'tcx>,\n     span: Span,\n@@ -248,7 +248,7 @@ crate fn check_drop_obligations<'a, 'tcx>(\n // This is an implementation of the TypeRelation trait with the\n // aim of simply comparing for equality (without side-effects).\n // It is not intended to be used anywhere else other than here.\n-crate struct SimpleEqRelation<'tcx> {\n+pub(crate) struct SimpleEqRelation<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }"}, {"sha": "09b0dc0a0ea2ed24837b681e30f424b7ed8b2671", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2430,7 +2430,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n-    crate fn get_field_candidates(\n+    pub(crate) fn get_field_candidates(\n         &self,\n         span: Span,\n         base_t: Ty<'tcx>,\n@@ -2455,7 +2455,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// This method is called after we have encountered a missing field error to recursively\n     /// search for the field\n-    crate fn check_for_nested_field_satisfying(\n+    pub(crate) fn check_for_nested_field_satisfying(\n         &self,\n         span: Span,\n         matches: &impl Fn(&ty::FieldDef, Ty<'tcx>) -> bool,"}, {"sha": "3249157c4f4541cb465a34ee0c3d94aa230696e8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1486,7 +1486,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Add all the obligations that are required, substituting and normalized appropriately.\n-    crate fn add_required_obligations(&self, span: Span, def_id: DefId, substs: &SubstsRef<'tcx>) {\n+    pub(crate) fn add_required_obligations(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        substs: &SubstsRef<'tcx>,\n+    ) {\n         self.add_required_obligations_with_code(\n             span,\n             def_id,"}, {"sha": "d4c5caa6e92925d105fc8fbf6ddce6b67e470e1c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Adds a suggestion to call the given method to the provided diagnostic.\n     #[instrument(level = \"debug\", skip(self, err, call_expr))]\n-    crate fn suggest_method_call(\n+    pub(crate) fn suggest_method_call(\n         &self,\n         err: &mut Diagnostic,\n         msg: &str,"}, {"sha": "f9c0ea82e02f1a0f3ec6c36a552e0b268177331d", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1343,7 +1343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    crate fn note_unmet_impls_on_type(\n+    pub(crate) fn note_unmet_impls_on_type(\n         &self,\n         err: &mut Diagnostic,\n         errors: Vec<FulfillmentError<'tcx>>,"}, {"sha": "583958ade625dc5155474bdc90331c2548994c4a", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -646,7 +646,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-crate trait Locatable {\n+pub(crate) trait Locatable {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span;\n }\n "}, {"sha": "c7823b444bfa5dcc953b0f40065302a9c00b2721", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -110,7 +110,7 @@ pub struct ItemCtxt<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n #[derive(Default)]\n-crate struct HirPlaceholderCollector(crate Vec<Span>);\n+pub(crate) struct HirPlaceholderCollector(pub(crate) Vec<Span>);\n \n impl<'v> Visitor<'v> for HirPlaceholderCollector {\n     fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n@@ -144,7 +144,7 @@ struct CollectItemTypesVisitor<'tcx> {\n /// If there are any placeholder types (`_`), emit an error explaining that this is not allowed\n /// and suggest adding type parameters in the appropriate place, taking into consideration any and\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n-crate fn placeholder_type_error<'tcx>(\n+pub(crate) fn placeholder_type_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n@@ -160,7 +160,7 @@ crate fn placeholder_type_error<'tcx>(\n         .emit();\n }\n \n-crate fn placeholder_type_error_diag<'tcx>(\n+pub(crate) fn placeholder_type_error_diag<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,"}, {"sha": "4ffd199b133ad080f8efeb88540a7e7b9dbd575c", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -59,7 +59,6 @@ This API is completely unstable and subject to change.\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(control_flow_enum)]\n-#![feature(crate_visibility_modifier)]\n #![feature(drain_filter)]\n #![feature(hash_drain_filter)]\n #![feature(if_let_guard)]"}, {"sha": "21916352532b1698231bc935415ad7594aa53d14", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -65,7 +65,7 @@ use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-crate trait HirNode {\n+pub(crate) trait HirNode {\n     fn hir_id(&self) -> hir::HirId;\n     fn span(&self) -> Span;\n }\n@@ -89,19 +89,19 @@ impl HirNode for hir::Pat<'_> {\n }\n \n #[derive(Clone)]\n-crate struct MemCategorizationContext<'a, 'tcx> {\n-    crate typeck_results: &'a ty::TypeckResults<'tcx>,\n+pub(crate) struct MemCategorizationContext<'a, 'tcx> {\n+    pub(crate) typeck_results: &'a ty::TypeckResults<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_owner: LocalDefId,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n }\n \n-crate type McResult<T> = Result<T, ()>;\n+pub(crate) type McResult<T> = Result<T, ()>;\n \n impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     /// Creates a `MemCategorizationContext`.\n-    crate fn new(\n+    pub(crate) fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body_owner: LocalDefId,\n@@ -116,11 +116,11 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn tcx(&self) -> TyCtxt<'tcx> {\n+    pub(crate) fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    crate fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n     }\n \n@@ -162,15 +162,15 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn node_ty(&self, hir_id: hir::HirId) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(hir_id, self.typeck_results.node_type_opt(hir_id))\n     }\n \n     fn expr_ty(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_opt(expr))\n     }\n \n-    crate fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn expr_ty_adjusted(&self, expr: &hir::Expr<'_>) -> McResult<Ty<'tcx>> {\n         self.resolve_type_vars_or_error(expr.hir_id, self.typeck_results.expr_ty_adjusted_opt(expr))\n     }\n \n@@ -184,7 +184,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     ///   implicit deref patterns attached (e.g., it is really\n     ///   `&Some(x)`). In that case, we return the \"outermost\" type\n     ///   (e.g., `&Option<T>).\n-    crate fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n+    pub(crate) fn pat_ty_adjusted(&self, pat: &hir::Pat<'_>) -> McResult<Ty<'tcx>> {\n         // Check for implicit `&` types wrapping the pattern; note\n         // that these are never attached to binding patterns, so\n         // actually this is somewhat \"disjoint\" from the code below\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret_ty)\n     }\n \n-    crate fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n+    pub(crate) fn cat_expr(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n         // This recursion helper avoids going through *too many*\n         // adjustments, since *only* non-overloaded deref recurses.\n         fn helper<'a, 'tcx>(\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         helper(self, expr, self.typeck_results.expr_adjustments(expr))\n     }\n \n-    crate fn cat_expr_adjusted(\n+    pub(crate) fn cat_expr_adjusted(\n         &self,\n         expr: &hir::Expr<'_>,\n         previous: PlaceWithHirId<'tcx>,\n@@ -298,7 +298,10 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_expr_unadjusted(&self, expr: &hir::Expr<'_>) -> McResult<PlaceWithHirId<'tcx>> {\n+    pub(crate) fn cat_expr_unadjusted(\n+        &self,\n+        expr: &hir::Expr<'_>,\n+    ) -> McResult<PlaceWithHirId<'tcx>> {\n         debug!(\"cat_expr: id={} expr={:?}\", expr.hir_id, expr);\n \n         let expr_ty = self.expr_ty(expr)?;\n@@ -383,7 +386,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    crate fn cat_res(\n+    pub(crate) fn cat_res(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n@@ -440,7 +443,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_rvalue(\n+    pub(crate) fn cat_rvalue(\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n@@ -452,7 +455,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         ret\n     }\n \n-    crate fn cat_projection<N: HirNode>(\n+    pub(crate) fn cat_projection<N: HirNode>(\n         &self,\n         node: &N,\n         base_place: PlaceWithHirId<'tcx>,\n@@ -521,7 +524,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         Ok(ret)\n     }\n \n-    crate fn cat_pattern<F>(\n+    pub(crate) fn cat_pattern<F>(\n         &self,\n         place: PlaceWithHirId<'tcx>,\n         pat: &hir::Pat<'_>,"}, {"sha": "dccfee19960c50d28243529417bdeabf3fdb2905", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,7 @@ use rustc_span::Span;\n \n mod explicit;\n mod implicit_infer;\n-crate mod outlives_bounds;\n+pub(crate) mod outlives_bounds;\n /// Code to write unit test for outlives.\n pub mod test;\n mod utils;"}, {"sha": "f1dc3cbbac459f72305b4ebe5d09d318d5536289", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,28 +15,28 @@ use GenericArgsInfo::*;\n \n /// Handles the `wrong number of type / lifetime / ... arguments` family of error messages.\n pub struct WrongNumberOfGenericArgs<'a, 'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n \n-    crate angle_brackets: AngleBrackets,\n+    pub(crate) angle_brackets: AngleBrackets,\n \n-    crate gen_args_info: GenericArgsInfo,\n+    pub(crate) gen_args_info: GenericArgsInfo,\n \n     /// Offending path segment\n-    crate path_segment: &'a hir::PathSegment<'a>,\n+    pub(crate) path_segment: &'a hir::PathSegment<'a>,\n \n     /// Generic parameters as expected by type or trait\n-    crate gen_params: &'a ty::Generics,\n+    pub(crate) gen_params: &'a ty::Generics,\n \n     /// Index offset into parameters. Depends on whether `Self` is included and on\n     /// number of lifetime parameters in case we're processing missing or redundant\n     /// type or constant arguments.\n-    crate params_offset: usize,\n+    pub(crate) params_offset: usize,\n \n     /// Generic arguments as provided by user\n-    crate gen_args: &'a hir::GenericArgs<'a>,\n+    pub(crate) gen_args: &'a hir::GenericArgs<'a>,\n \n     /// DefId of the generic type\n-    crate def_id: DefId,\n+    pub(crate) def_id: DefId,\n }\n \n // Provides information about the kind of arguments that were provided for"}, {"sha": "27fb4709982bdbc96f94574fbfda96e5bc88e2c6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -20,12 +20,12 @@ struct RegionDeps<'tcx> {\n     smaller: FxHashSet<RegionTarget<'tcx>>,\n }\n \n-crate struct AutoTraitFinder<'a, 'tcx> {\n-    crate cx: &'a mut core::DocContext<'tcx>,\n+pub(crate) struct AutoTraitFinder<'a, 'tcx> {\n+    pub(crate) cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n-    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> Self {\n+    pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> Self {\n         AutoTraitFinder { cx }\n     }\n \n@@ -130,7 +130,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         })\n     }\n \n-    crate fn get_auto_trait_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n+    pub(crate) fn get_auto_trait_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let tcx = self.cx.tcx;\n         let param_env = tcx.param_env(item_def_id);\n         let ty = tcx.type_of(item_def_id);"}, {"sha": "c591c591331117b45d51db11d695a7f62d207a06", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,12 +8,12 @@ use rustc_span::DUMMY_SP;\n \n use super::*;\n \n-crate struct BlanketImplFinder<'a, 'tcx> {\n-    crate cx: &'a mut core::DocContext<'tcx>,\n+pub(crate) struct BlanketImplFinder<'a, 'tcx> {\n+    pub(crate) cx: &'a mut core::DocContext<'tcx>,\n }\n \n impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n-    crate fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n+    pub(crate) fn get_blanket_impls(&mut self, item_def_id: DefId) -> Vec<Item> {\n         let param_env = self.cx.tcx.param_env(item_def_id);\n         let ty = self.cx.tcx.bound_type_of(item_def_id);\n "}, {"sha": "deac1723b26208d48deb1137074d762a1a5f6822", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ use crate::html::escape::Escape;\n mod tests;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-crate enum Cfg {\n+pub(crate) enum Cfg {\n     /// Accepts all configurations.\n     True,\n     /// Denies all configurations.\n@@ -37,9 +37,9 @@ crate enum Cfg {\n }\n \n #[derive(PartialEq, Debug)]\n-crate struct InvalidCfgError {\n-    crate msg: &'static str,\n-    crate span: Span,\n+pub(crate) struct InvalidCfgError {\n+    pub(crate) msg: &'static str,\n+    pub(crate) span: Span,\n }\n \n impl Cfg {\n@@ -56,7 +56,7 @@ impl Cfg {\n         }\n     }\n \n-    crate fn parse_without(\n+    pub(crate) fn parse_without(\n         cfg: &MetaItem,\n         exclude: &FxHashSet<Cfg>,\n     ) -> Result<Option<Cfg>, InvalidCfgError> {\n@@ -117,15 +117,15 @@ impl Cfg {\n     ///\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n-    crate fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+    pub(crate) fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n         Self::parse_without(cfg, &FxHashSet::default()).map(|ret| ret.unwrap())\n     }\n \n     /// Checks whether the given configuration can be matched in the current session.\n     ///\n     /// Equivalent to `attr::cfg_matches`.\n     // FIXME: Actually make use of `features`.\n-    crate fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+    pub(crate) fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n         match *self {\n             Cfg::False => false,\n             Cfg::True => true,"}, {"sha": "1b6658bb4cab8f4c3775c9779778fdc532addea0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -38,7 +38,7 @@ type Attrs<'hir> = &'hir [ast::Attribute];\n /// and `Some` of a vector of items if it was successfully expanded.\n ///\n /// `parent_module` refers to the parent of the *re-export*, not the original item.\n-crate fn try_inline(\n+pub(crate) fn try_inline(\n     cx: &mut DocContext<'_>,\n     parent_module: DefId,\n     import_def_id: Option<DefId>,\n@@ -134,7 +134,7 @@ crate fn try_inline(\n     Some(ret)\n }\n \n-crate fn try_inline_glob(\n+pub(crate) fn try_inline_glob(\n     cx: &mut DocContext<'_>,\n     res: Res,\n     visited: &mut FxHashSet<DefId>,\n@@ -154,15 +154,15 @@ crate fn try_inline_glob(\n     }\n }\n \n-crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n+pub(crate) fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n     cx.tcx.get_attrs_unchecked(did)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n+pub(crate) fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n     let crate_name = cx.tcx.crate_name(did.krate);\n \n     let relative =\n@@ -190,7 +190,7 @@ crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType)\n     }\n }\n \n-crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Trait {\n+pub(crate) fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Trait {\n     let trait_items = cx\n         .tcx\n         .associated_items(did)\n@@ -274,7 +274,7 @@ fn build_type_alias(cx: &mut DocContext<'_>, did: DefId) -> clean::Typedef {\n }\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n-crate fn build_impls(\n+pub(crate) fn build_impls(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n@@ -318,7 +318,7 @@ fn merge_attrs(\n }\n \n /// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n-crate fn build_impl(\n+pub(crate) fn build_impl(\n     cx: &mut DocContext<'_>,\n     parent_module: Option<DefId>,\n     did: DefId,\n@@ -565,7 +565,7 @@ fn build_module(\n     clean::Module { items, span }\n }\n \n-crate fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n+pub(crate) fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n     if let Some(did) = did.as_local() {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n         rustc_hir_pretty::id_to_string(&tcx.hir(), hir_id)\n@@ -670,7 +670,7 @@ fn separate_supertrait_bounds(\n     (g, ty_bounds)\n }\n \n-crate fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n+pub(crate) fn record_extern_trait(cx: &mut DocContext<'_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "4f66b4a240c391f9d041a7001100d581bcd57667", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -3,12 +3,12 @@\n \n mod auto_trait;\n mod blanket_impl;\n-crate mod cfg;\n-crate mod inline;\n+pub(crate) mod cfg;\n+pub(crate) mod inline;\n mod render_macro_matchers;\n mod simplify;\n-crate mod types;\n-crate mod utils;\n+pub(crate) mod types;\n+pub(crate) mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n@@ -41,10 +41,10 @@ use crate::visit_ast::Module as DocModule;\n \n use utils::*;\n \n-crate use self::types::*;\n-crate use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n+pub(crate) use self::types::*;\n+pub(crate) use self::utils::{get_auto_trait_and_blanket_impls, krate, register_res};\n \n-crate trait Clean<T> {\n+pub(crate) trait Clean<T> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> T;\n }\n "}, {"sha": "af7813a77409238ef7d4abf6ff1a1dfcab0e19a1", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ use crate::clean::GenericArgs as PP;\n use crate::clean::WherePredicate as WP;\n use crate::core::DocContext;\n \n-crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n+pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components.\n     //\n     // We use `FxIndexMap` so that the insertion order is preserved to prevent messing up to\n@@ -79,7 +79,7 @@ crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses\n }\n \n-crate fn merge_bounds(\n+pub(crate) fn merge_bounds(\n     cx: &clean::DocContext<'_>,\n     bounds: &mut Vec<clean::GenericBound>,\n     trait_did: DefId,"}, {"sha": "edf7ddb30dbf9779f6894fafb7d439b9635a572b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 294, "deletions": 290, "changes": 584, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -44,22 +44,22 @@ use crate::formats::item_type::ItemType;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n-crate use self::FnRetTy::*;\n-crate use self::ItemKind::*;\n-crate use self::SelfTy::*;\n-crate use self::Type::{\n+pub(crate) use self::FnRetTy::*;\n+pub(crate) use self::ItemKind::*;\n+pub(crate) use self::SelfTy::*;\n+pub(crate) use self::Type::{\n     Array, BareFunction, BorrowedRef, DynTrait, Generic, ImplTrait, Infer, Primitive, QPath,\n     RawPointer, Slice, Tuple,\n };\n-crate use self::Visibility::{Inherited, Public};\n+pub(crate) use self::Visibility::{Inherited, Public};\n \n #[cfg(test)]\n mod tests;\n \n-crate type ItemIdSet = FxHashSet<ItemId>;\n+pub(crate) type ItemIdSet = FxHashSet<ItemId>;\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, Copy)]\n-crate enum ItemId {\n+pub(crate) enum ItemId {\n     /// A \"normal\" item that uses a [`DefId`] for identification.\n     DefId(DefId),\n     /// Identifier that is used for auto traits.\n@@ -72,7 +72,7 @@ crate enum ItemId {\n \n impl ItemId {\n     #[inline]\n-    crate fn is_local(self) -> bool {\n+    pub(crate) fn is_local(self) -> bool {\n         match self {\n             ItemId::Auto { for_: id, .. }\n             | ItemId::Blanket { for_: id, .. }\n@@ -83,21 +83,21 @@ impl ItemId {\n \n     #[inline]\n     #[track_caller]\n-    crate fn expect_def_id(self) -> DefId {\n+    pub(crate) fn expect_def_id(self) -> DefId {\n         self.as_def_id()\n             .unwrap_or_else(|| panic!(\"ItemId::expect_def_id: `{:?}` isn't a DefId\", self))\n     }\n \n     #[inline]\n-    crate fn as_def_id(self) -> Option<DefId> {\n+    pub(crate) fn as_def_id(self) -> Option<DefId> {\n         match self {\n             ItemId::DefId(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     #[inline]\n-    crate fn krate(self) -> CrateNum {\n+    pub(crate) fn krate(self) -> CrateNum {\n         match self {\n             ItemId::Auto { for_: id, .. }\n             | ItemId::Blanket { for_: id, .. }\n@@ -115,57 +115,57 @@ impl From<DefId> for ItemId {\n \n /// The crate currently being documented.\n #[derive(Clone, Debug)]\n-crate struct Crate {\n-    crate module: Item,\n-    crate primitives: ThinVec<(DefId, PrimitiveType)>,\n+pub(crate) struct Crate {\n+    pub(crate) module: Item,\n+    pub(crate) primitives: ThinVec<(DefId, PrimitiveType)>,\n     /// Only here so that they can be filtered through the rustdoc passes.\n-    crate external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n+    pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, TraitWithExtraInfo>>>,\n }\n \n // `Crate` is frequently moved by-value. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Crate, 72);\n \n impl Crate {\n-    crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n+    pub(crate) fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         ExternalCrate::LOCAL.name(tcx)\n     }\n \n-    crate fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n+    pub(crate) fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n         ExternalCrate::LOCAL.src(tcx)\n     }\n }\n \n /// This struct is used to wrap additional information added by rustdoc on a `trait` item.\n #[derive(Clone, Debug)]\n-crate struct TraitWithExtraInfo {\n-    crate trait_: Trait,\n-    crate is_notable: bool,\n+pub(crate) struct TraitWithExtraInfo {\n+    pub(crate) trait_: Trait,\n+    pub(crate) is_notable: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate struct ExternalCrate {\n-    crate crate_num: CrateNum,\n+pub(crate) struct ExternalCrate {\n+    pub(crate) crate_num: CrateNum,\n }\n \n impl ExternalCrate {\n     const LOCAL: Self = Self { crate_num: LOCAL_CRATE };\n \n     #[inline]\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         self.crate_num.as_def_id()\n     }\n \n-    crate fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n+    pub(crate) fn src(&self, tcx: TyCtxt<'_>) -> FileName {\n         let krate_span = tcx.def_span(self.def_id());\n         tcx.sess.source_map().span_to_filename(krate_span)\n     }\n \n-    crate fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n+    pub(crate) fn name(&self, tcx: TyCtxt<'_>) -> Symbol {\n         tcx.crate_name(self.crate_num)\n     }\n \n-    crate fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n+    pub(crate) fn src_root(&self, tcx: TyCtxt<'_>) -> PathBuf {\n         match self.src(tcx) {\n             FileName::Real(ref p) => match p.local_path_if_available().parent() {\n                 Some(p) => p.to_path_buf(),\n@@ -177,7 +177,7 @@ impl ExternalCrate {\n \n     /// Attempts to find where an external crate is located, given that we're\n     /// rendering in to the specified source destination.\n-    crate fn location(\n+    pub(crate) fn location(\n         &self,\n         extern_url: Option<&str>,\n         extern_url_takes_precedence: bool,\n@@ -221,7 +221,7 @@ impl ExternalCrate {\n             .unwrap_or(Unknown) // Well, at least we tried.\n     }\n \n-    crate fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n+    pub(crate) fn keywords(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, Symbol)> {\n         let root = self.def_id();\n \n         let as_keyword = |res: Res<!>| {\n@@ -268,7 +268,7 @@ impl ExternalCrate {\n         }\n     }\n \n-    crate fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n+    pub(crate) fn primitives(&self, tcx: TyCtxt<'_>) -> ThinVec<(DefId, PrimitiveType)> {\n         let root = self.def_id();\n \n         // Collect all inner modules which are tagged as implementations of\n@@ -341,7 +341,7 @@ impl ExternalCrate {\n \n /// Indicates where an external crate can be found.\n #[derive(Debug)]\n-crate enum ExternalLocation {\n+pub(crate) enum ExternalLocation {\n     /// Remote URL root of the external crate\n     Remote(String),\n     /// This external crate can be found in the local doc/ folder\n@@ -354,18 +354,18 @@ crate enum ExternalLocation {\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n #[derive(Clone)]\n-crate struct Item {\n+pub(crate) struct Item {\n     /// The name of this item.\n     /// Optional because not every item has a name, e.g. impls.\n-    crate name: Option<Symbol>,\n-    crate attrs: Box<Attributes>,\n-    crate visibility: Visibility,\n+    pub(crate) name: Option<Symbol>,\n+    pub(crate) attrs: Box<Attributes>,\n+    pub(crate) visibility: Visibility,\n     /// Information about this item that is specific to what kind of item it is.\n     /// E.g., struct vs enum vs function.\n-    crate kind: Box<ItemKind>,\n-    crate item_id: ItemId,\n+    pub(crate) kind: Box<ItemKind>,\n+    pub(crate) item_id: ItemId,\n \n-    crate cfg: Option<Arc<Cfg>>,\n+    pub(crate) cfg: Option<Arc<Cfg>>,\n }\n \n /// NOTE: this does NOT unconditionally print every item, to avoid thousands of lines of logs.\n@@ -393,7 +393,7 @@ impl fmt::Debug for Item {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Item, 56);\n \n-crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n+pub(crate) fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n     Span::new(def_id.as_local().map_or_else(\n         || tcx.def_span(def_id),\n         |local| {\n@@ -404,26 +404,26 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n }\n \n impl Item {\n-    crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n+    pub(crate) fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n-    crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n+    pub(crate) fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n-    crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n+    pub(crate) fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {\n         self.item_id.as_def_id().and_then(|did| tcx.lookup_deprecation(did))\n     }\n \n-    crate fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn inner_docs(&self, tcx: TyCtxt<'_>) -> bool {\n         self.item_id\n             .as_def_id()\n             .map(|did| tcx.get_attrs_unchecked(did).inner_docs())\n             .unwrap_or(false)\n     }\n \n-    crate fn span(&self, tcx: TyCtxt<'_>) -> Span {\n+    pub(crate) fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         let kind = match &*self.kind {\n             ItemKind::StrippedItem(k) => k,\n             _ => &*self.kind,\n@@ -444,19 +444,19 @@ impl Item {\n         }\n     }\n \n-    crate fn attr_span(&self, tcx: TyCtxt<'_>) -> rustc_span::Span {\n+    pub(crate) fn attr_span(&self, tcx: TyCtxt<'_>) -> rustc_span::Span {\n         crate::passes::span_of_attrs(&self.attrs).unwrap_or_else(|| self.span(tcx).inner())\n     }\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<String> {\n+    pub(crate) fn doc_value(&self) -> Option<String> {\n         self.attrs.doc_value()\n     }\n \n     /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n     /// `hir_id` to a [`DefId`]\n-    crate fn from_hir_id_and_parts(\n+    pub(crate) fn from_hir_id_and_parts(\n         hir_id: hir::HirId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -465,7 +465,7 @@ impl Item {\n         Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n     }\n \n-    crate fn from_def_id_and_parts(\n+    pub(crate) fn from_def_id_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -483,7 +483,7 @@ impl Item {\n         )\n     }\n \n-    crate fn from_def_id_and_attrs_and_parts(\n+    pub(crate) fn from_def_id_and_attrs_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n         kind: ItemKind,\n@@ -508,11 +508,11 @@ impl Item {\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    crate fn collapsed_doc_value(&self) -> Option<String> {\n+    pub(crate) fn collapsed_doc_value(&self) -> Option<String> {\n         self.attrs.collapsed_doc_value()\n     }\n \n-    crate fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n+    pub(crate) fn links(&self, cx: &Context<'_>) -> Vec<RenderedLink> {\n         use crate::html::format::href;\n \n         cx.cache()\n@@ -544,7 +544,7 @@ impl Item {\n     /// This is used for generating summary text, which does not include\n     /// the link text, but does need to know which `[]`-bracketed names\n     /// are actually links.\n-    crate fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n+    pub(crate) fn link_names(&self, cache: &Cache) -> Vec<RenderedLink> {\n         cache\n             .intra_doc_links\n             .get(&self.item_id)\n@@ -558,68 +558,68 @@ impl Item {\n             .collect()\n     }\n \n-    crate fn is_crate(&self) -> bool {\n+    pub(crate) fn is_crate(&self) -> bool {\n         self.is_mod() && self.item_id.as_def_id().map_or(false, |did| did.is_crate_root())\n     }\n-    crate fn is_mod(&self) -> bool {\n+    pub(crate) fn is_mod(&self) -> bool {\n         self.type_() == ItemType::Module\n     }\n-    crate fn is_trait(&self) -> bool {\n+    pub(crate) fn is_trait(&self) -> bool {\n         self.type_() == ItemType::Trait\n     }\n-    crate fn is_struct(&self) -> bool {\n+    pub(crate) fn is_struct(&self) -> bool {\n         self.type_() == ItemType::Struct\n     }\n-    crate fn is_enum(&self) -> bool {\n+    pub(crate) fn is_enum(&self) -> bool {\n         self.type_() == ItemType::Enum\n     }\n-    crate fn is_variant(&self) -> bool {\n+    pub(crate) fn is_variant(&self) -> bool {\n         self.type_() == ItemType::Variant\n     }\n-    crate fn is_associated_type(&self) -> bool {\n+    pub(crate) fn is_associated_type(&self) -> bool {\n         matches!(&*self.kind, AssocTypeItem(..) | StrippedItem(box AssocTypeItem(..)))\n     }\n-    crate fn is_ty_associated_type(&self) -> bool {\n+    pub(crate) fn is_ty_associated_type(&self) -> bool {\n         matches!(&*self.kind, TyAssocTypeItem(..) | StrippedItem(box TyAssocTypeItem(..)))\n     }\n-    crate fn is_associated_const(&self) -> bool {\n+    pub(crate) fn is_associated_const(&self) -> bool {\n         matches!(&*self.kind, AssocConstItem(..) | StrippedItem(box AssocConstItem(..)))\n     }\n-    crate fn is_ty_associated_const(&self) -> bool {\n+    pub(crate) fn is_ty_associated_const(&self) -> bool {\n         matches!(&*self.kind, TyAssocConstItem(..) | StrippedItem(box TyAssocConstItem(..)))\n     }\n-    crate fn is_method(&self) -> bool {\n+    pub(crate) fn is_method(&self) -> bool {\n         self.type_() == ItemType::Method\n     }\n-    crate fn is_ty_method(&self) -> bool {\n+    pub(crate) fn is_ty_method(&self) -> bool {\n         self.type_() == ItemType::TyMethod\n     }\n-    crate fn is_typedef(&self) -> bool {\n+    pub(crate) fn is_typedef(&self) -> bool {\n         self.type_() == ItemType::Typedef\n     }\n-    crate fn is_primitive(&self) -> bool {\n+    pub(crate) fn is_primitive(&self) -> bool {\n         self.type_() == ItemType::Primitive\n     }\n-    crate fn is_union(&self) -> bool {\n+    pub(crate) fn is_union(&self) -> bool {\n         self.type_() == ItemType::Union\n     }\n-    crate fn is_import(&self) -> bool {\n+    pub(crate) fn is_import(&self) -> bool {\n         self.type_() == ItemType::Import\n     }\n-    crate fn is_extern_crate(&self) -> bool {\n+    pub(crate) fn is_extern_crate(&self) -> bool {\n         self.type_() == ItemType::ExternCrate\n     }\n-    crate fn is_keyword(&self) -> bool {\n+    pub(crate) fn is_keyword(&self) -> bool {\n         self.type_() == ItemType::Keyword\n     }\n-    crate fn is_stripped(&self) -> bool {\n+    pub(crate) fn is_stripped(&self) -> bool {\n         match *self.kind {\n             StrippedItem(..) => true,\n             ImportItem(ref i) => !i.should_be_displayed,\n             _ => false,\n         }\n     }\n-    crate fn has_stripped_fields(&self) -> Option<bool> {\n+    pub(crate) fn has_stripped_fields(&self) -> Option<bool> {\n         match *self.kind {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n             UnionItem(ref union) => Some(union.fields_stripped),\n@@ -628,7 +628,7 @@ impl Item {\n         }\n     }\n \n-    crate fn stability_class(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn stability_class(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         self.stability(tcx).as_ref().and_then(|s| {\n             let mut classes = Vec::with_capacity(2);\n \n@@ -645,30 +645,30 @@ impl Item {\n         })\n     }\n \n-    crate fn stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n+    pub(crate) fn stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n         match self.stability(tcx)?.level {\n             StabilityLevel::Stable { since, .. } => Some(since),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    crate fn const_stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n+    pub(crate) fn const_stable_since(&self, tcx: TyCtxt<'_>) -> Option<Symbol> {\n         match self.const_stability(tcx)?.level {\n             StabilityLevel::Stable { since, .. } => Some(since),\n             StabilityLevel::Unstable { .. } => None,\n         }\n     }\n \n-    crate fn is_non_exhaustive(&self) -> bool {\n+    pub(crate) fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter().any(|a| a.has_name(sym::non_exhaustive))\n     }\n \n     /// Returns a documentation-level item type from the item.\n-    crate fn type_(&self) -> ItemType {\n+    pub(crate) fn type_(&self) -> ItemType {\n         ItemType::from(self)\n     }\n \n-    crate fn is_default(&self) -> bool {\n+    pub(crate) fn is_default(&self) -> bool {\n         match *self.kind {\n             ItemKind::MethodItem(_, Some(defaultness)) => {\n                 defaultness.has_value() && !defaultness.is_final()\n@@ -678,7 +678,7 @@ impl Item {\n     }\n \n     /// Returns a `FnHeader` if `self` is a function item, otherwise returns `None`.\n-    crate fn fn_header(&self, tcx: TyCtxt<'_>) -> Option<hir::FnHeader> {\n+    pub(crate) fn fn_header(&self, tcx: TyCtxt<'_>) -> Option<hir::FnHeader> {\n         fn build_fn_header(\n             def_id: DefId,\n             tcx: TyCtxt<'_>,\n@@ -721,7 +721,7 @@ impl Item {\n }\n \n #[derive(Clone, Debug)]\n-crate enum ItemKind {\n+pub(crate) enum ItemKind {\n     ExternCrateItem {\n         /// The crate's name, *not* the name it's imported as.\n         src: Option<Symbol>,\n@@ -774,7 +774,7 @@ crate enum ItemKind {\n impl ItemKind {\n     /// Some items contain others such as structs (for their fields) and Enums\n     /// (for their variants). This method returns those contained items.\n-    crate fn inner_items(&self) -> impl Iterator<Item = &Item> {\n+    pub(crate) fn inner_items(&self) -> impl Iterator<Item = &Item> {\n         match self {\n             StructItem(s) => s.fields.iter(),\n             UnionItem(u) => u.fields.iter(),\n@@ -813,12 +813,12 @@ impl ItemKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Module {\n-    crate items: Vec<Item>,\n-    crate span: Span,\n+pub(crate) struct Module {\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) span: Span,\n }\n \n-crate trait AttributesExt {\n+pub(crate) trait AttributesExt {\n     type AttributeIterator<'a>: Iterator<Item = ast::NestedMetaItem>\n     where\n         Self: 'a;\n@@ -949,7 +949,7 @@ impl AttributesExt for [ast::Attribute] {\n     }\n }\n \n-crate trait NestedAttributesExt {\n+pub(crate) trait NestedAttributesExt {\n     /// Returns `true` if the attribute list contains a specific `word`\n     fn has_word(self, word: Symbol) -> bool\n     where\n@@ -978,24 +978,24 @@ impl<I: Iterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-crate struct DocFragment {\n-    crate span: rustc_span::Span,\n+pub(crate) struct DocFragment {\n+    pub(crate) span: rustc_span::Span,\n     /// The module this doc-comment came from.\n     ///\n     /// This allows distinguishing between the original documentation and a pub re-export.\n     /// If it is `None`, the item was not re-exported.\n-    crate parent_module: Option<DefId>,\n-    crate doc: Symbol,\n-    crate kind: DocFragmentKind,\n-    crate indent: usize,\n+    pub(crate) parent_module: Option<DefId>,\n+    pub(crate) doc: Symbol,\n+    pub(crate) kind: DocFragmentKind,\n+    pub(crate) indent: usize,\n }\n \n // `DocFragment` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(DocFragment, 32);\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-crate enum DocFragmentKind {\n+pub(crate) enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n     SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n@@ -1027,7 +1027,7 @@ fn add_doc_fragment(out: &mut String, frag: &DocFragment) {\n \n /// Collapse a collection of [`DocFragment`]s into one string,\n /// handling indentation and newlines as needed.\n-crate fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n+pub(crate) fn collapse_doc_fragments(doc_strings: &[DocFragment]) -> String {\n     let mut acc = String::new();\n     for frag in doc_strings {\n         add_doc_fragment(&mut acc, frag);\n@@ -1120,44 +1120,44 @@ fn unindent_doc_fragments(docs: &mut Vec<DocFragment>) {\n ///\n /// This link will be turned into a rendered link by [`Item::links`].\n #[derive(Clone, Debug, PartialEq, Eq)]\n-crate struct ItemLink {\n+pub(crate) struct ItemLink {\n     /// The original link written in the markdown\n-    crate link: String,\n+    pub(crate) link: String,\n     /// The link text displayed in the HTML.\n     ///\n     /// This may not be the same as `link` if there was a disambiguator\n     /// in an intra-doc link (e.g. \\[`fn@f`\\])\n-    crate link_text: String,\n-    crate did: DefId,\n+    pub(crate) link_text: String,\n+    pub(crate) did: DefId,\n     /// The url fragment to append to the link\n-    crate fragment: Option<UrlFragment>,\n+    pub(crate) fragment: Option<UrlFragment>,\n }\n \n pub struct RenderedLink {\n     /// The text the link was original written as.\n     ///\n     /// This could potentially include disambiguators and backticks.\n-    crate original_text: String,\n+    pub(crate) original_text: String,\n     /// The text to display in the HTML\n-    crate new_text: String,\n+    pub(crate) new_text: String,\n     /// The URL to put in the `href`\n-    crate href: String,\n+    pub(crate) href: String,\n }\n \n /// The attributes on an [`Item`], including attributes like `#[derive(...)]` and `#[inline]`,\n /// as well as doc comments.\n #[derive(Clone, Debug, Default)]\n-crate struct Attributes {\n-    crate doc_strings: Vec<DocFragment>,\n-    crate other_attrs: Vec<ast::Attribute>,\n+pub(crate) struct Attributes {\n+    pub(crate) doc_strings: Vec<DocFragment>,\n+    pub(crate) other_attrs: Vec<ast::Attribute>,\n }\n \n impl Attributes {\n-    crate fn lists(&self, name: Symbol) -> impl Iterator<Item = ast::NestedMetaItem> + '_ {\n+    pub(crate) fn lists(&self, name: Symbol) -> impl Iterator<Item = ast::NestedMetaItem> + '_ {\n         self.other_attrs.lists(name)\n     }\n \n-    crate fn has_doc_flag(&self, flag: Symbol) -> bool {\n+    pub(crate) fn has_doc_flag(&self, flag: Symbol) -> bool {\n         for attr in &self.other_attrs {\n             if !attr.has_name(sym::doc) {\n                 continue;\n@@ -1173,7 +1173,7 @@ impl Attributes {\n         false\n     }\n \n-    crate fn from_ast(\n+    pub(crate) fn from_ast(\n         attrs: &[ast::Attribute],\n         additional_attrs: Option<(&[ast::Attribute], DefId)>,\n     ) -> Attributes {\n@@ -1185,7 +1185,7 @@ impl Attributes {\n         Attributes::from_ast_iter(attrs1.chain(attrs2), false)\n     }\n \n-    crate fn from_ast_iter<'a>(\n+    pub(crate) fn from_ast_iter<'a>(\n         attrs: impl Iterator<Item = (&'a ast::Attribute, Option<DefId>)>,\n         doc_only: bool,\n     ) -> Attributes {\n@@ -1214,7 +1214,7 @@ impl Attributes {\n \n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n-    crate fn doc_value(&self) -> Option<String> {\n+    pub(crate) fn doc_value(&self) -> Option<String> {\n         let mut iter = self.doc_strings.iter();\n \n         let ori = iter.next()?;\n@@ -1232,7 +1232,7 @@ impl Attributes {\n     ///\n     /// The last newline is not trimmed so the produced strings are reusable between\n     /// early and late doc link resolution regardless of their position.\n-    crate fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n+    pub(crate) fn prepare_to_doc_link_resolution(&self) -> FxHashMap<Option<DefId>, String> {\n         let mut res = FxHashMap::default();\n         for fragment in &self.doc_strings {\n             let out_str = res.entry(fragment.parent_module).or_default();\n@@ -1243,15 +1243,15 @@ impl Attributes {\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined\n     /// with newlines.\n-    crate fn collapsed_doc_value(&self) -> Option<String> {\n+    pub(crate) fn collapsed_doc_value(&self) -> Option<String> {\n         if self.doc_strings.is_empty() {\n             None\n         } else {\n             Some(collapse_doc_fragments(&self.doc_strings))\n         }\n     }\n \n-    crate fn get_doc_aliases(&self) -> Box<[Symbol]> {\n+    pub(crate) fn get_doc_aliases(&self) -> Box<[Symbol]> {\n         let mut aliases = FxHashSet::default();\n \n         for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n@@ -1286,13 +1286,13 @@ impl PartialEq for Attributes {\n impl Eq for Attributes {}\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericBound {\n+pub(crate) enum GenericBound {\n     TraitBound(PolyTrait, hir::TraitBoundModifier),\n     Outlives(Lifetime),\n }\n \n impl GenericBound {\n-    crate fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n+    pub(crate) fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, did, false, vec![], empty);\n@@ -1303,7 +1303,7 @@ impl GenericBound {\n         )\n     }\n \n-    crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n+    pub(crate) fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if Some(trait_.def_id()) == cx.tcx.lang_items().sized_trait() {\n@@ -1313,14 +1313,14 @@ impl GenericBound {\n         false\n     }\n \n-    crate fn get_poly_trait(&self) -> Option<PolyTrait> {\n+    pub(crate) fn get_poly_trait(&self) -> Option<PolyTrait> {\n         if let GenericBound::TraitBound(ref p, _) = *self {\n             return Some(p.clone());\n         }\n         None\n     }\n \n-    crate fn get_trait_path(&self) -> Option<Path> {\n+    pub(crate) fn get_trait_path(&self) -> Option<Path> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n             Some(trait_.clone())\n         } else {\n@@ -1330,27 +1330,27 @@ impl GenericBound {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Lifetime(pub Symbol);\n+pub(crate) struct Lifetime(pub Symbol);\n \n impl Lifetime {\n-    crate fn statik() -> Lifetime {\n+    pub(crate) fn statik() -> Lifetime {\n         Lifetime(kw::StaticLifetime)\n     }\n \n-    crate fn elided() -> Lifetime {\n+    pub(crate) fn elided() -> Lifetime {\n         Lifetime(kw::UnderscoreLifetime)\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate enum WherePredicate {\n+pub(crate) enum WherePredicate {\n     BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Term },\n }\n \n impl WherePredicate {\n-    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    pub(crate) fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match *self {\n             WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n             WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n@@ -1360,41 +1360,41 @@ impl WherePredicate {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericParamDefKind {\n+pub(crate) enum GenericParamDefKind {\n     Lifetime { outlives: Vec<Lifetime> },\n     Type { did: DefId, bounds: Vec<GenericBound>, default: Option<Box<Type>>, synthetic: bool },\n     Const { did: DefId, ty: Box<Type>, default: Option<Box<String>> },\n }\n \n impl GenericParamDefKind {\n-    crate fn is_type(&self) -> bool {\n+    pub(crate) fn is_type(&self) -> bool {\n         matches!(self, GenericParamDefKind::Type { .. })\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct GenericParamDef {\n-    crate name: Symbol,\n-    crate kind: GenericParamDefKind,\n+pub(crate) struct GenericParamDef {\n+    pub(crate) name: Symbol,\n+    pub(crate) kind: GenericParamDefKind,\n }\n \n // `GenericParamDef` is used in many places. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(GenericParamDef, 56);\n \n impl GenericParamDef {\n-    crate fn is_synthetic_type_param(&self) -> bool {\n+    pub(crate) fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime { .. } | GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { synthetic, .. } => synthetic,\n         }\n     }\n \n-    crate fn is_type(&self) -> bool {\n+    pub(crate) fn is_type(&self) -> bool {\n         self.kind.is_type()\n     }\n \n-    crate fn get_bounds(&self) -> Option<&[GenericBound]> {\n+    pub(crate) fn get_bounds(&self) -> Option<&[GenericBound]> {\n         match self.kind {\n             GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n             _ => None,\n@@ -1404,26 +1404,26 @@ impl GenericParamDef {\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, Debug, Default)]\n-crate struct Generics {\n-    crate params: Vec<GenericParamDef>,\n-    crate where_predicates: Vec<WherePredicate>,\n+pub(crate) struct Generics {\n+    pub(crate) params: Vec<GenericParamDef>,\n+    pub(crate) where_predicates: Vec<WherePredicate>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Function {\n-    crate decl: FnDecl,\n-    crate generics: Generics,\n+pub(crate) struct Function {\n+    pub(crate) decl: FnDecl,\n+    pub(crate) generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct FnDecl {\n-    crate inputs: Arguments,\n-    crate output: FnRetTy,\n-    crate c_variadic: bool,\n+pub(crate) struct FnDecl {\n+    pub(crate) inputs: Arguments,\n+    pub(crate) output: FnRetTy,\n+    pub(crate) c_variadic: bool,\n }\n \n impl FnDecl {\n-    crate fn self_type(&self) -> Option<SelfTy> {\n+    pub(crate) fn self_type(&self) -> Option<SelfTy> {\n         self.inputs.values.get(0).and_then(|v| v.to_self())\n     }\n \n@@ -1436,7 +1436,7 @@ impl FnDecl {\n     ///\n     /// This function will panic if the return type does not match the expected sugaring for async\n     /// functions.\n-    crate fn sugared_async_return_type(&self) -> FnRetTy {\n+    pub(crate) fn sugared_async_return_type(&self) -> FnRetTy {\n         match &self.output {\n             FnRetTy::Return(Type::ImplTrait(bounds)) => match &bounds[0] {\n                 GenericBound::TraitBound(PolyTrait { trait_, .. }, ..) => {\n@@ -1453,28 +1453,28 @@ impl FnDecl {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Arguments {\n-    crate values: Vec<Argument>,\n+pub(crate) struct Arguments {\n+    pub(crate) values: Vec<Argument>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Argument {\n-    crate type_: Type,\n-    crate name: Symbol,\n+pub(crate) struct Argument {\n+    pub(crate) type_: Type,\n+    pub(crate) name: Symbol,\n     /// This field is used to represent \"const\" arguments from the `rustc_legacy_const_generics`\n     /// feature. More information in <https://github.com/rust-lang/rust/issues/83167>.\n-    crate is_const: bool,\n+    pub(crate) is_const: bool,\n }\n \n #[derive(Clone, PartialEq, Debug)]\n-crate enum SelfTy {\n+pub(crate) enum SelfTy {\n     SelfValue,\n     SelfBorrowed(Option<Lifetime>, Mutability),\n     SelfExplicit(Type),\n }\n \n impl Argument {\n-    crate fn to_self(&self) -> Option<SelfTy> {\n+    pub(crate) fn to_self(&self) -> Option<SelfTy> {\n         if self.name != kw::SelfLower {\n             return None;\n         }\n@@ -1491,13 +1491,13 @@ impl Argument {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum FnRetTy {\n+pub(crate) enum FnRetTy {\n     Return(Type),\n     DefaultReturn,\n }\n \n impl FnRetTy {\n-    crate fn as_return(&self) -> Option<&Type> {\n+    pub(crate) fn as_return(&self) -> Option<&Type> {\n         match self {\n             Return(ret) => Some(ret),\n             DefaultReturn => None,\n@@ -1506,30 +1506,30 @@ impl FnRetTy {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Trait {\n-    crate unsafety: hir::Unsafety,\n-    crate items: Vec<Item>,\n-    crate generics: Generics,\n-    crate bounds: Vec<GenericBound>,\n-    crate is_auto: bool,\n+pub(crate) struct Trait {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) generics: Generics,\n+    pub(crate) bounds: Vec<GenericBound>,\n+    pub(crate) is_auto: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct TraitAlias {\n-    crate generics: Generics,\n-    crate bounds: Vec<GenericBound>,\n+pub(crate) struct TraitAlias {\n+    pub(crate) generics: Generics,\n+    pub(crate) bounds: Vec<GenericBound>,\n }\n \n /// A trait reference, which may have higher ranked lifetimes.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct PolyTrait {\n-    crate trait_: Path,\n-    crate generic_params: Vec<GenericParamDef>,\n+pub(crate) struct PolyTrait {\n+    pub(crate) trait_: Path,\n+    pub(crate) generic_params: Vec<GenericParamDef>,\n }\n \n /// Rustdoc's representation of types, mostly based on the [`hir::Ty`].\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum Type {\n+pub(crate) enum Type {\n     /// A named type, which could be a trait.\n     ///\n     /// This is mostly Rustdoc's version of [`hir::Path`].\n@@ -1580,7 +1580,7 @@ rustc_data_structures::static_assert_size!(Type, 80);\n \n impl Type {\n     /// When comparing types for equality, it can help to ignore `&` wrapping.\n-    crate fn without_borrowed_ref(&self) -> &Type {\n+    pub(crate) fn without_borrowed_ref(&self) -> &Type {\n         let mut result = self;\n         while let Type::BorrowedRef { type_, .. } = result {\n             result = &*type_;\n@@ -1591,7 +1591,7 @@ impl Type {\n     /// Check if two types are \"potentially the same\".\n     /// This is different from `Eq`, because it knows that things like\n     /// `Placeholder` are possible matches for everything.\n-    crate fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n+    pub(crate) fn is_same(&self, other: &Self, cache: &Cache) -> bool {\n         match (self, other) {\n             // Recursive cases.\n             (Type::Tuple(a), Type::Tuple(b)) => {\n@@ -1618,7 +1618,7 @@ impl Type {\n         }\n     }\n \n-    crate fn primitive_type(&self) -> Option<PrimitiveType> {\n+    pub(crate) fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), .. } => Some(p),\n             Slice(..) | BorrowedRef { type_: box Slice(..), .. } => Some(PrimitiveType::Slice),\n@@ -1637,36 +1637,36 @@ impl Type {\n     }\n \n     /// Checks if this is a `T::Name` path for an associated type.\n-    crate fn is_assoc_ty(&self) -> bool {\n+    pub(crate) fn is_assoc_ty(&self) -> bool {\n         match self {\n             Type::Path { path, .. } => path.is_assoc_ty(),\n             _ => false,\n         }\n     }\n \n-    crate fn is_self_type(&self) -> bool {\n+    pub(crate) fn is_self_type(&self) -> bool {\n         match *self {\n             Generic(name) => name == kw::SelfUpper,\n             _ => false,\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<&Type>> {\n+    pub(crate) fn generics(&self) -> Option<Vec<&Type>> {\n         match self {\n             Type::Path { path, .. } => path.generics(),\n             _ => None,\n         }\n     }\n \n-    crate fn is_full_generic(&self) -> bool {\n+    pub(crate) fn is_full_generic(&self) -> bool {\n         matches!(self, Type::Generic(_))\n     }\n \n-    crate fn is_primitive(&self) -> bool {\n+    pub(crate) fn is_primitive(&self) -> bool {\n         self.primitive_type().is_some()\n     }\n \n-    crate fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n+    pub(crate) fn projection(&self) -> Option<(&Type, DefId, PathSegment)> {\n         if let QPath { self_type, trait_, assoc, .. } = self {\n             Some((&self_type, trait_.def_id(), *assoc.clone()))\n         } else {\n@@ -1701,7 +1701,7 @@ impl Type {\n     /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n     ///\n     /// [clean]: crate::clean\n-    crate fn def_id(&self, cache: &Cache) -> Option<DefId> {\n+    pub(crate) fn def_id(&self, cache: &Cache) -> Option<DefId> {\n         self.inner_def_id(Some(cache))\n     }\n }\n@@ -1713,7 +1713,7 @@ impl Type {\n /// N.B. This has to be different from [`hir::PrimTy`] because it also includes types that aren't\n /// paths, like [`Self::Unit`].\n #[derive(Clone, PartialEq, Eq, Hash, Copy, Debug)]\n-crate enum PrimitiveType {\n+pub(crate) enum PrimitiveType {\n     Isize,\n     I8,\n     I16,\n@@ -1743,7 +1743,7 @@ crate enum PrimitiveType {\n \n type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 2>>;\n impl PrimitiveType {\n-    crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n+    pub(crate) fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         use ast::{FloatTy, IntTy, UintTy};\n         match prim {\n             hir::PrimTy::Int(IntTy::Isize) => PrimitiveType::Isize,\n@@ -1766,7 +1766,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n+    pub(crate) fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n             sym::isize => Some(PrimitiveType::Isize),\n             sym::i8 => Some(PrimitiveType::I8),\n@@ -1797,7 +1797,7 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn simplified_types() -> &'static SimplifiedTypes {\n+    pub(crate) fn simplified_types() -> &'static SimplifiedTypes {\n         use ty::fast_reject::SimplifiedTypeGen::*;\n         use ty::{FloatTy, IntTy, UintTy};\n         use PrimitiveType::*;\n@@ -1842,7 +1842,7 @@ impl PrimitiveType {\n         })\n     }\n \n-    crate fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n+    pub(crate) fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n         Self::simplified_types()\n             .get(self)\n             .into_iter()\n@@ -1851,15 +1851,15 @@ impl PrimitiveType {\n             .copied()\n     }\n \n-    crate fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n+    pub(crate) fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n         Self::simplified_types()\n             .values()\n             .flatten()\n             .flat_map(move |&simp| tcx.incoherent_impls(simp))\n             .copied()\n     }\n \n-    crate fn as_sym(&self) -> Symbol {\n+    pub(crate) fn as_sym(&self) -> Symbol {\n         use PrimitiveType::*;\n         match self {\n             Isize => sym::isize,\n@@ -1897,7 +1897,7 @@ impl PrimitiveType {\n     /// but otherwise, if multiple crates define the same primitive, there is no guarantee of which will be picked.\n     /// In particular, if a crate depends on both `std` and another crate that also defines `doc(primitive)`, then\n     /// it's entirely random whether `std` or the other crate is picked. (no_std crates are usually fine unless multiple dependencies define a primitive.)\n-    crate fn primitive_locations(tcx: TyCtxt<'_>) -> &FxHashMap<PrimitiveType, DefId> {\n+    pub(crate) fn primitive_locations(tcx: TyCtxt<'_>) -> &FxHashMap<PrimitiveType, DefId> {\n         static PRIMITIVE_LOCATIONS: OnceCell<FxHashMap<PrimitiveType, DefId>> = OnceCell::new();\n         PRIMITIVE_LOCATIONS.get_or_init(|| {\n             let mut primitive_locations = FxHashMap::default();\n@@ -2008,7 +2008,7 @@ impl From<hir::PrimTy> for PrimitiveType {\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum Visibility {\n+pub(crate) enum Visibility {\n     /// `pub`\n     Public,\n     /// Visibility inherited from parent.\n@@ -2020,45 +2020,45 @@ crate enum Visibility {\n }\n \n impl Visibility {\n-    crate fn is_public(&self) -> bool {\n+    pub(crate) fn is_public(&self) -> bool {\n         matches!(self, Visibility::Public)\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate struct Struct {\n-    crate struct_type: CtorKind,\n-    crate generics: Generics,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct Struct {\n+    pub(crate) struct_type: CtorKind,\n+    pub(crate) generics: Generics,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Union {\n-    crate generics: Generics,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct Union {\n+    pub(crate) generics: Generics,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n #[derive(Clone, Debug)]\n-crate struct VariantStruct {\n-    crate struct_type: CtorKind,\n-    crate fields: Vec<Item>,\n-    crate fields_stripped: bool,\n+pub(crate) struct VariantStruct {\n+    pub(crate) struct_type: CtorKind,\n+    pub(crate) fields: Vec<Item>,\n+    pub(crate) fields_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Enum {\n-    crate variants: IndexVec<VariantIdx, Item>,\n-    crate generics: Generics,\n-    crate variants_stripped: bool,\n+pub(crate) struct Enum {\n+    pub(crate) variants: IndexVec<VariantIdx, Item>,\n+    pub(crate) generics: Generics,\n+    pub(crate) variants_stripped: bool,\n }\n \n #[derive(Clone, Debug)]\n-crate enum Variant {\n+pub(crate) enum Variant {\n     CLike,\n     Tuple(Vec<Item>),\n     Struct(VariantStruct),\n@@ -2067,63 +2067,63 @@ crate enum Variant {\n /// Small wrapper around [`rustc_span::Span`] that adds helper methods\n /// and enforces calling [`rustc_span::Span::source_callsite()`].\n #[derive(Copy, Clone, Debug)]\n-crate struct Span(rustc_span::Span);\n+pub(crate) struct Span(rustc_span::Span);\n \n impl Span {\n     /// Wraps a [`rustc_span::Span`]. In case this span is the result of a macro expansion, the\n     /// span will be updated to point to the macro invocation instead of the macro definition.\n     ///\n     /// (See rust-lang/rust#39726)\n-    crate fn new(sp: rustc_span::Span) -> Self {\n+    pub(crate) fn new(sp: rustc_span::Span) -> Self {\n         Self(sp.source_callsite())\n     }\n \n-    crate fn inner(&self) -> rustc_span::Span {\n+    pub(crate) fn inner(&self) -> rustc_span::Span {\n         self.0\n     }\n \n-    crate fn dummy() -> Self {\n+    pub(crate) fn dummy() -> Self {\n         Self(rustc_span::DUMMY_SP)\n     }\n \n-    crate fn is_dummy(&self) -> bool {\n+    pub(crate) fn is_dummy(&self) -> bool {\n         self.0.is_dummy()\n     }\n \n-    crate fn filename(&self, sess: &Session) -> FileName {\n+    pub(crate) fn filename(&self, sess: &Session) -> FileName {\n         sess.source_map().span_to_filename(self.0)\n     }\n \n-    crate fn lo(&self, sess: &Session) -> Loc {\n+    pub(crate) fn lo(&self, sess: &Session) -> Loc {\n         sess.source_map().lookup_char_pos(self.0.lo())\n     }\n \n-    crate fn hi(&self, sess: &Session) -> Loc {\n+    pub(crate) fn hi(&self, sess: &Session) -> Loc {\n         sess.source_map().lookup_char_pos(self.0.hi())\n     }\n \n-    crate fn cnum(&self, sess: &Session) -> CrateNum {\n+    pub(crate) fn cnum(&self, sess: &Session) -> CrateNum {\n         // FIXME: is there a time when the lo and hi crate would be different?\n         self.lo(sess).file.cnum\n     }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct Path {\n-    crate res: Res,\n-    crate segments: Vec<PathSegment>,\n+pub(crate) struct Path {\n+    pub(crate) res: Res,\n+    pub(crate) segments: Vec<PathSegment>,\n }\n \n impl Path {\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         self.res.def_id()\n     }\n \n-    crate fn last(&self) -> Symbol {\n+    pub(crate) fn last(&self) -> Symbol {\n         self.segments.last().expect(\"segments were empty\").name\n     }\n \n-    crate fn whole_name(&self) -> String {\n+    pub(crate) fn whole_name(&self) -> String {\n         self.segments\n             .iter()\n             .map(|s| if s.name == kw::PathRoot { String::new() } else { s.name.to_string() })\n@@ -2132,7 +2132,7 @@ impl Path {\n     }\n \n     /// Checks if this is a `T::Name` path for an associated type.\n-    crate fn is_assoc_ty(&self) -> bool {\n+    pub(crate) fn is_assoc_ty(&self) -> bool {\n         match self.res {\n             Res::SelfTy { .. } if self.segments.len() != 1 => true,\n             Res::Def(DefKind::TyParam, _) if self.segments.len() != 1 => true,\n@@ -2141,7 +2141,7 @@ impl Path {\n         }\n     }\n \n-    crate fn generics(&self) -> Option<Vec<&Type>> {\n+    pub(crate) fn generics(&self) -> Option<Vec<&Type>> {\n         self.segments.last().and_then(|seg| {\n             if let GenericArgs::AngleBracketed { ref args, .. } = seg.args {\n                 Some(\n@@ -2158,7 +2158,7 @@ impl Path {\n         })\n     }\n \n-    crate fn bindings(&self) -> Option<&[TypeBinding]> {\n+    pub(crate) fn bindings(&self) -> Option<&[TypeBinding]> {\n         self.segments.last().and_then(|seg| {\n             if let GenericArgs::AngleBracketed { ref bindings, .. } = seg.args {\n                 Some(&**bindings)\n@@ -2170,7 +2170,7 @@ impl Path {\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericArg {\n+pub(crate) enum GenericArg {\n     Lifetime(Lifetime),\n     Type(Type),\n     Const(Box<Constant>),\n@@ -2183,7 +2183,7 @@ crate enum GenericArg {\n rustc_data_structures::static_assert_size!(GenericArg, 88);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum GenericArgs {\n+pub(crate) enum GenericArgs {\n     AngleBracketed { args: Vec<GenericArg>, bindings: ThinVec<TypeBinding> },\n     Parenthesized { inputs: Vec<Type>, output: Option<Box<Type>> },\n }\n@@ -2194,9 +2194,9 @@ crate enum GenericArgs {\n rustc_data_structures::static_assert_size!(GenericArgs, 40);\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct PathSegment {\n-    crate name: Symbol,\n-    crate args: GenericArgs,\n+pub(crate) struct PathSegment {\n+    pub(crate) name: Symbol,\n+    pub(crate) args: GenericArgs,\n }\n \n // `PathSegment` usually occurs multiple times in every `Path`, so its size can\n@@ -2205,53 +2205,53 @@ crate struct PathSegment {\n rustc_data_structures::static_assert_size!(PathSegment, 48);\n \n #[derive(Clone, Debug)]\n-crate struct Typedef {\n-    crate type_: Type,\n-    crate generics: Generics,\n+pub(crate) struct Typedef {\n+    pub(crate) type_: Type,\n+    pub(crate) generics: Generics,\n     /// `type_` can come from either the HIR or from metadata. If it comes from HIR, it may be a type\n     /// alias instead of the final type. This will always have the final type, regardless of whether\n     /// `type_` came from HIR or from metadata.\n     ///\n     /// If `item_type.is_none()`, `type_` is guaranteed to come from metadata (and therefore hold the\n     /// final type).\n-    crate item_type: Option<Type>,\n+    pub(crate) item_type: Option<Type>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct OpaqueTy {\n-    crate bounds: Vec<GenericBound>,\n-    crate generics: Generics,\n+pub(crate) struct OpaqueTy {\n+    pub(crate) bounds: Vec<GenericBound>,\n+    pub(crate) generics: Generics,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct BareFunctionDecl {\n-    crate unsafety: hir::Unsafety,\n-    crate generic_params: Vec<GenericParamDef>,\n-    crate decl: FnDecl,\n-    crate abi: Abi,\n+pub(crate) struct BareFunctionDecl {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) generic_params: Vec<GenericParamDef>,\n+    pub(crate) decl: FnDecl,\n+    pub(crate) abi: Abi,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Static {\n-    crate type_: Type,\n-    crate mutability: Mutability,\n-    crate expr: Option<BodyId>,\n+pub(crate) struct Static {\n+    pub(crate) type_: Type,\n+    pub(crate) mutability: Mutability,\n+    pub(crate) expr: Option<BodyId>,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate struct Constant {\n-    crate type_: Type,\n-    crate kind: ConstantKind,\n+pub(crate) struct Constant {\n+    pub(crate) type_: Type,\n+    pub(crate) kind: ConstantKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate enum Term {\n+pub(crate) enum Term {\n     Type(Type),\n     Constant(Constant),\n }\n \n impl Term {\n-    crate fn ty(&self) -> Option<&Type> {\n+    pub(crate) fn ty(&self) -> Option<&Type> {\n         if let Term::Type(ty) = self { Some(ty) } else { None }\n     }\n }\n@@ -2263,7 +2263,7 @@ impl From<Type> for Term {\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n-crate enum ConstantKind {\n+pub(crate) enum ConstantKind {\n     /// This is the wrapper around `ty::Const` for a non-local constant. Because it doesn't have a\n     /// `BodyId`, we need to handle it on its own.\n     ///\n@@ -2281,21 +2281,21 @@ crate enum ConstantKind {\n }\n \n impl Constant {\n-    crate fn expr(&self, tcx: TyCtxt<'_>) -> String {\n+    pub(crate) fn expr(&self, tcx: TyCtxt<'_>) -> String {\n         self.kind.expr(tcx)\n     }\n \n-    crate fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         self.kind.value(tcx)\n     }\n \n-    crate fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         self.kind.is_literal(tcx)\n     }\n }\n \n impl ConstantKind {\n-    crate fn expr(&self, tcx: TyCtxt<'_>) -> String {\n+    pub(crate) fn expr(&self, tcx: TyCtxt<'_>) -> String {\n         match *self {\n             ConstantKind::TyConst { ref expr } => expr.clone(),\n             ConstantKind::Extern { def_id } => print_inlined_const(tcx, def_id),\n@@ -2305,7 +2305,7 @@ impl ConstantKind {\n         }\n     }\n \n-    crate fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n+    pub(crate) fn value(&self, tcx: TyCtxt<'_>) -> Option<String> {\n         match *self {\n             ConstantKind::TyConst { .. } | ConstantKind::Anonymous { .. } => None,\n             ConstantKind::Extern { def_id } | ConstantKind::Local { def_id, .. } => {\n@@ -2314,7 +2314,7 @@ impl ConstantKind {\n         }\n     }\n \n-    crate fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n+    pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n             ConstantKind::TyConst { .. } => false,\n             ConstantKind::Extern { def_id } => def_id.as_local().map_or(false, |def_id| {\n@@ -2328,18 +2328,18 @@ impl ConstantKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Impl {\n-    crate unsafety: hir::Unsafety,\n-    crate generics: Generics,\n-    crate trait_: Option<Path>,\n-    crate for_: Type,\n-    crate items: Vec<Item>,\n-    crate polarity: ty::ImplPolarity,\n-    crate kind: ImplKind,\n+pub(crate) struct Impl {\n+    pub(crate) unsafety: hir::Unsafety,\n+    pub(crate) generics: Generics,\n+    pub(crate) trait_: Option<Path>,\n+    pub(crate) for_: Type,\n+    pub(crate) items: Vec<Item>,\n+    pub(crate) polarity: ty::ImplPolarity,\n+    pub(crate) kind: ImplKind,\n }\n \n impl Impl {\n-    crate fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n+    pub(crate) fn provided_trait_methods(&self, tcx: TyCtxt<'_>) -> FxHashSet<Symbol> {\n         self.trait_\n             .as_ref()\n             .map(|t| t.def_id())\n@@ -2349,22 +2349,22 @@ impl Impl {\n }\n \n #[derive(Clone, Debug)]\n-crate enum ImplKind {\n+pub(crate) enum ImplKind {\n     Normal,\n     Auto,\n     Blanket(Box<Type>),\n }\n \n impl ImplKind {\n-    crate fn is_auto(&self) -> bool {\n+    pub(crate) fn is_auto(&self) -> bool {\n         matches!(self, ImplKind::Auto)\n     }\n \n-    crate fn is_blanket(&self) -> bool {\n+    pub(crate) fn is_blanket(&self) -> bool {\n         matches!(self, ImplKind::Blanket(_))\n     }\n \n-    crate fn as_blanket_ty(&self) -> Option<&Type> {\n+    pub(crate) fn as_blanket_ty(&self) -> Option<&Type> {\n         match self {\n             ImplKind::Blanket(ty) => Some(ty),\n             _ => None,\n@@ -2373,63 +2373,67 @@ impl ImplKind {\n }\n \n #[derive(Clone, Debug)]\n-crate struct Import {\n-    crate kind: ImportKind,\n-    crate source: ImportSource,\n-    crate should_be_displayed: bool,\n+pub(crate) struct Import {\n+    pub(crate) kind: ImportKind,\n+    pub(crate) source: ImportSource,\n+    pub(crate) should_be_displayed: bool,\n }\n \n impl Import {\n-    crate fn new_simple(name: Symbol, source: ImportSource, should_be_displayed: bool) -> Self {\n+    pub(crate) fn new_simple(\n+        name: Symbol,\n+        source: ImportSource,\n+        should_be_displayed: bool,\n+    ) -> Self {\n         Self { kind: ImportKind::Simple(name), source, should_be_displayed }\n     }\n \n-    crate fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n+    pub(crate) fn new_glob(source: ImportSource, should_be_displayed: bool) -> Self {\n         Self { kind: ImportKind::Glob, source, should_be_displayed }\n     }\n }\n \n #[derive(Clone, Debug)]\n-crate enum ImportKind {\n+pub(crate) enum ImportKind {\n     // use source as str;\n     Simple(Symbol),\n     // use source::*;\n     Glob,\n }\n \n #[derive(Clone, Debug)]\n-crate struct ImportSource {\n-    crate path: Path,\n-    crate did: Option<DefId>,\n+pub(crate) struct ImportSource {\n+    pub(crate) path: Path,\n+    pub(crate) did: Option<DefId>,\n }\n \n #[derive(Clone, Debug)]\n-crate struct Macro {\n-    crate source: String,\n+pub(crate) struct Macro {\n+    pub(crate) source: String,\n }\n \n #[derive(Clone, Debug)]\n-crate struct ProcMacro {\n-    crate kind: MacroKind,\n-    crate helpers: Vec<Symbol>,\n+pub(crate) struct ProcMacro {\n+    pub(crate) kind: MacroKind,\n+    pub(crate) helpers: Vec<Symbol>,\n }\n \n /// An type binding on an associated type (e.g., `A = Bar` in `Foo<A = Bar>` or\n /// `A: Send + Sync` in `Foo<A: Send + Sync>`).\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate struct TypeBinding {\n-    crate assoc: PathSegment,\n-    crate kind: TypeBindingKind,\n+pub(crate) struct TypeBinding {\n+    pub(crate) assoc: PathSegment,\n+    pub(crate) kind: TypeBindingKind,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-crate enum TypeBindingKind {\n+pub(crate) enum TypeBindingKind {\n     Equality { term: Term },\n     Constraint { bounds: Vec<GenericBound> },\n }\n \n impl TypeBinding {\n-    crate fn term(&self) -> &Term {\n+    pub(crate) fn term(&self) -> &Term {\n         match self.kind {\n             TypeBindingKind::Equality { ref term } => term,\n             _ => panic!(\"expected equality type binding for parenthesized generic args\"),\n@@ -2450,18 +2454,18 @@ impl TypeBinding {\n ///\n /// `public_fn`'s docs will show it as returning `Vec<i32>`, since `PrivAlias` is private.\n /// [`SubstParam`] is used to record that `T` should be mapped to `i32`.\n-crate enum SubstParam {\n+pub(crate) enum SubstParam {\n     Type(Type),\n     Lifetime(Lifetime),\n     Constant(Constant),\n }\n \n impl SubstParam {\n-    crate fn as_ty(&self) -> Option<&Type> {\n+    pub(crate) fn as_ty(&self) -> Option<&Type> {\n         if let Self::Type(ty) = self { Some(ty) } else { None }\n     }\n \n-    crate fn as_lt(&self) -> Option<&Lifetime> {\n+    pub(crate) fn as_lt(&self) -> Option<&Lifetime> {\n         if let Self::Lifetime(lt) = self { Some(lt) } else { None }\n     }\n }"}, {"sha": "7a12ea0d5c21569da4de0dc075800dfd99fb9b7f", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -25,7 +25,7 @@ use std::mem;\n #[cfg(test)]\n mod tests;\n \n-crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit();\n \n     for &cnum in cx.tcx.crates(()) {\n@@ -75,7 +75,7 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     Crate { module, primitives, external_traits: cx.external_traits.clone() }\n }\n \n-crate fn substs_to_args(\n+pub(crate) fn substs_to_args(\n     cx: &mut DocContext<'_>,\n     substs: &[ty::subst::GenericArg<'_>],\n     mut skip_first: bool,\n@@ -146,15 +146,15 @@ pub(super) fn external_path(\n }\n \n /// Remove the generic arguments from a path.\n-crate fn strip_path_generics(mut path: Path) -> Path {\n+pub(crate) fn strip_path_generics(mut path: Path) -> Path {\n     for ps in path.segments.iter_mut() {\n         ps.args = GenericArgs::AngleBracketed { args: vec![], bindings: ThinVec::new() }\n     }\n \n     path\n }\n \n-crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n+pub(crate) fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, path) => &path.segments,\n         hir::QPath::TypeRelative(_, segment) => return segment.ident.to_string(),\n@@ -173,7 +173,11 @@ crate fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n     s\n }\n \n-crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n+pub(crate) fn build_deref_target_impls(\n+    cx: &mut DocContext<'_>,\n+    items: &[Item],\n+    ret: &mut Vec<Item>,\n+) {\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -196,7 +200,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n     }\n }\n \n-crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n+pub(crate) fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     use rustc_hir::*;\n     debug!(\"trying to get a name from pattern: {:?}\", p);\n \n@@ -229,7 +233,7 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n     })\n }\n \n-crate fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n+pub(crate) fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n     match n.val() {\n         ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) => {\n             let mut s = if let Some(def) = def.as_local() {\n@@ -259,7 +263,7 @@ crate fn print_const(cx: &DocContext<'_>, n: ty::Const<'_>) -> String {\n     }\n }\n \n-crate fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n+pub(crate) fn print_evaluated_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<String> {\n     tcx.const_eval_poly(def_id).ok().and_then(|val| {\n         let ty = tcx.type_of(def_id);\n         match (val, ty.kind()) {\n@@ -323,7 +327,7 @@ fn print_const_with_custom_print_scalar(tcx: TyCtxt<'_>, ct: ty::Const<'_>) -> S\n     }\n }\n \n-crate fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+pub(crate) fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     if let hir::Node::Expr(expr) = tcx.hir().get(hir_id) {\n         if let hir::ExprKind::Lit(_) = &expr.kind {\n             return true;\n@@ -339,7 +343,7 @@ crate fn is_literal_expr(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     false\n }\n \n-crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n+pub(crate) fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n     let hir = tcx.hir();\n     let value = &hir.body(body).value;\n \n@@ -353,7 +357,7 @@ crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n+pub(crate) fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n     debug!(\"resolve_type({:?})\", path);\n \n     match path.res {\n@@ -367,7 +371,7 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n     }\n }\n \n-crate fn get_auto_trait_and_blanket_impls(\n+pub(crate) fn get_auto_trait_and_blanket_impls(\n     cx: &mut DocContext<'_>,\n     item_def_id: DefId,\n ) -> impl Iterator<Item = Item> {\n@@ -389,7 +393,7 @@ crate fn get_auto_trait_and_blanket_impls(\n /// This is later used by [`href()`] to determine the HTML link for the item.\n ///\n /// [`href()`]: crate::html::format::href\n-crate fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n+pub(crate) fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n     use DefKind::*;\n     debug!(\"register_res({:?})\", res);\n \n@@ -428,14 +432,14 @@ crate fn register_res(cx: &mut DocContext<'_>, res: Res) -> DefId {\n     did\n }\n \n-crate fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportSource {\n+pub(crate) fn resolve_use_source(cx: &mut DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.res.opt_def_id().is_none() { None } else { Some(register_res(cx, path.res)) },\n         path,\n     }\n }\n \n-crate fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n+pub(crate) fn enter_impl_trait<F, R>(cx: &mut DocContext<'_>, f: F) -> R\n where\n     F: FnOnce(&mut DocContext<'_>) -> R,\n {\n@@ -447,7 +451,7 @@ where\n }\n \n /// Find the nearest parent module of a [`DefId`].\n-crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+pub(crate) fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if def_id.is_top_level_module() {\n         // The crate root has no parent. Use it as the root instead.\n         Some(def_id)\n@@ -474,7 +478,7 @@ crate fn find_nearest_parent_module(tcx: TyCtxt<'_>, def_id: DefId) -> Option<De\n ///\n /// This function exists because it runs on `hir::Attributes` whereas the other is a\n /// `clean::Attributes` method.\n-crate fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n+pub(crate) fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n     tcx.get_attrs(did, sym::doc).any(|attr| {\n         attr.meta_item_list().map_or(false, |l| rustc_attr::list_contains_name(&l, flag))\n     })\n@@ -484,7 +488,7 @@ crate fn has_doc_flag(tcx: TyCtxt<'_>, did: DefId, flag: Symbol) -> bool {\n /// so that the channel is consistent.\n ///\n /// Set by `bootstrap::Builder::doc_rust_lang_org_channel` in order to keep tests passing on beta/stable.\n-crate const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n+pub(crate) const DOC_RUST_LANG_ORG_CHANNEL: &str = env!(\"DOC_RUST_LANG_ORG_CHANNEL\");\n \n /// Render a sequence of macro arms in a format suitable for displaying to the user\n /// as part of an item declaration."}, {"sha": "b934a1a59d717ac726917d3a309bbaf8a10b2895", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -31,7 +31,7 @@ use crate::scrape_examples::{AllCallLocations, ScrapeExamplesOptions};\n use crate::theme;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-crate enum OutputFormat {\n+pub(crate) enum OutputFormat {\n     Json,\n     Html,\n }\n@@ -43,7 +43,7 @@ impl Default for OutputFormat {\n }\n \n impl OutputFormat {\n-    crate fn is_json(&self) -> bool {\n+    pub(crate) fn is_json(&self) -> bool {\n         matches!(self, OutputFormat::Json)\n     }\n }\n@@ -62,100 +62,100 @@ impl TryFrom<&str> for OutputFormat {\n \n /// Configuration options for rustdoc.\n #[derive(Clone)]\n-crate struct Options {\n+pub(crate) struct Options {\n     // Basic options / Options passed directly to rustc\n     /// The crate root or Markdown file to load.\n-    crate input: PathBuf,\n+    pub(crate) input: PathBuf,\n     /// The name of the crate being documented.\n-    crate crate_name: Option<String>,\n+    pub(crate) crate_name: Option<String>,\n     /// Whether or not this is a proc-macro crate\n-    crate proc_macro_crate: bool,\n+    pub(crate) proc_macro_crate: bool,\n     /// How to format errors and warnings.\n-    crate error_format: ErrorOutputType,\n+    pub(crate) error_format: ErrorOutputType,\n     /// Library search paths to hand to the compiler.\n-    crate libs: Vec<SearchPath>,\n+    pub(crate) libs: Vec<SearchPath>,\n     /// Library search paths strings to hand to the compiler.\n-    crate lib_strs: Vec<String>,\n+    pub(crate) lib_strs: Vec<String>,\n     /// The list of external crates to link against.\n-    crate externs: Externs,\n+    pub(crate) externs: Externs,\n     /// The list of external crates strings to link against.\n-    crate extern_strs: Vec<String>,\n+    pub(crate) extern_strs: Vec<String>,\n     /// List of `cfg` flags to hand to the compiler. Always includes `rustdoc`.\n-    crate cfgs: Vec<String>,\n+    pub(crate) cfgs: Vec<String>,\n     /// List of check cfg flags to hand to the compiler.\n-    crate check_cfgs: Vec<String>,\n+    pub(crate) check_cfgs: Vec<String>,\n     /// Codegen options to hand to the compiler.\n-    crate codegen_options: CodegenOptions,\n+    pub(crate) codegen_options: CodegenOptions,\n     /// Codegen options strings to hand to the compiler.\n-    crate codegen_options_strs: Vec<String>,\n+    pub(crate) codegen_options_strs: Vec<String>,\n     /// Debugging (`-Z`) options to pass to the compiler.\n-    crate debugging_opts: DebuggingOptions,\n+    pub(crate) debugging_opts: DebuggingOptions,\n     /// Debugging (`-Z`) options strings to pass to the compiler.\n-    crate debugging_opts_strs: Vec<String>,\n+    pub(crate) debugging_opts_strs: Vec<String>,\n     /// The target used to compile the crate against.\n-    crate target: TargetTriple,\n+    pub(crate) target: TargetTriple,\n     /// Edition used when reading the crate. Defaults to \"2015\". Also used by default when\n     /// compiling doctests from the crate.\n-    crate edition: Edition,\n+    pub(crate) edition: Edition,\n     /// The path to the sysroot. Used during the compilation process.\n-    crate maybe_sysroot: Option<PathBuf>,\n+    pub(crate) maybe_sysroot: Option<PathBuf>,\n     /// Lint information passed over the command-line.\n-    crate lint_opts: Vec<(String, Level)>,\n+    pub(crate) lint_opts: Vec<(String, Level)>,\n     /// Whether to ask rustc to describe the lints it knows.\n-    crate describe_lints: bool,\n+    pub(crate) describe_lints: bool,\n     /// What level to cap lints at.\n-    crate lint_cap: Option<Level>,\n+    pub(crate) lint_cap: Option<Level>,\n \n     // Options specific to running doctests\n     /// Whether we should run doctests instead of generating docs.\n-    crate should_test: bool,\n+    pub(crate) should_test: bool,\n     /// List of arguments to pass to the test harness, if running tests.\n-    crate test_args: Vec<String>,\n+    pub(crate) test_args: Vec<String>,\n     /// The working directory in which to run tests.\n-    crate test_run_directory: Option<PathBuf>,\n+    pub(crate) test_run_directory: Option<PathBuf>,\n     /// Optional path to persist the doctest executables to, defaults to a\n     /// temporary directory if not set.\n-    crate persist_doctests: Option<PathBuf>,\n+    pub(crate) persist_doctests: Option<PathBuf>,\n     /// Runtool to run doctests with\n-    crate runtool: Option<String>,\n+    pub(crate) runtool: Option<String>,\n     /// Arguments to pass to the runtool\n-    crate runtool_args: Vec<String>,\n+    pub(crate) runtool_args: Vec<String>,\n     /// Whether to allow ignoring doctests on a per-target basis\n     /// For example, using ignore-foo to ignore running the doctest on any target that\n     /// contains \"foo\" as a substring\n-    crate enable_per_target_ignores: bool,\n+    pub(crate) enable_per_target_ignores: bool,\n     /// Do not run doctests, compile them if should_test is active.\n-    crate no_run: bool,\n+    pub(crate) no_run: bool,\n \n     /// The path to a rustc-like binary to build tests with. If not set, we\n     /// default to loading from `$sysroot/bin/rustc`.\n-    crate test_builder: Option<PathBuf>,\n+    pub(crate) test_builder: Option<PathBuf>,\n \n     // Options that affect the documentation process\n     /// Whether to run the `calculate-doc-coverage` pass, which counts the number of public items\n     /// with and without documentation.\n-    crate show_coverage: bool,\n+    pub(crate) show_coverage: bool,\n \n     // Options that alter generated documentation pages\n     /// Crate version to note on the sidebar of generated docs.\n-    crate crate_version: Option<String>,\n+    pub(crate) crate_version: Option<String>,\n     /// Collected options specific to outputting final pages.\n-    crate render_options: RenderOptions,\n+    pub(crate) render_options: RenderOptions,\n     /// The format that we output when rendering.\n     ///\n     /// Currently used only for the `--show-coverage` option.\n-    crate output_format: OutputFormat,\n+    pub(crate) output_format: OutputFormat,\n     /// If this option is set to `true`, rustdoc will only run checks and not generate\n     /// documentation.\n-    crate run_check: bool,\n+    pub(crate) run_check: bool,\n     /// Whether doctests should emit unused externs\n-    crate json_unused_externs: JsonUnusedExterns,\n+    pub(crate) json_unused_externs: JsonUnusedExterns,\n     /// Whether to skip capturing stdout and stderr of tests.\n-    crate nocapture: bool,\n+    pub(crate) nocapture: bool,\n \n     /// Configuration for scraping examples from the current crate. If this option is Some(..) then\n     /// the compiler will scrape examples and not generate documentation.\n-    crate scrape_examples_options: Option<ScrapeExamplesOptions>,\n+    pub(crate) scrape_examples_options: Option<ScrapeExamplesOptions>,\n }\n \n impl fmt::Debug for Options {\n@@ -205,83 +205,83 @@ impl fmt::Debug for Options {\n \n /// Configuration options for the HTML page-creation process.\n #[derive(Clone, Debug)]\n-crate struct RenderOptions {\n+pub(crate) struct RenderOptions {\n     /// Output directory to generate docs into. Defaults to `doc`.\n-    crate output: PathBuf,\n+    pub(crate) output: PathBuf,\n     /// External files to insert into generated pages.\n-    crate external_html: ExternalHtml,\n+    pub(crate) external_html: ExternalHtml,\n     /// A pre-populated `IdMap` with the default headings and any headings added by Markdown files\n     /// processed by `external_html`.\n-    crate id_map: IdMap,\n+    pub(crate) id_map: IdMap,\n     /// If present, playground URL to use in the \"Run\" button added to code samples.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n-    crate playground_url: Option<String>,\n+    pub(crate) playground_url: Option<String>,\n     /// Whether to sort modules alphabetically on a module page instead of using declaration order.\n     /// `true` by default.\n     //\n     // FIXME(misdreavus): the flag name is `--sort-modules-by-appearance` but the meaning is\n     // inverted once read.\n-    crate sort_modules_alphabetically: bool,\n+    pub(crate) sort_modules_alphabetically: bool,\n     /// List of themes to extend the docs with. Original argument name is included to assist in\n     /// displaying errors if it fails a theme check.\n-    crate themes: Vec<StylePath>,\n+    pub(crate) themes: Vec<StylePath>,\n     /// If present, CSS file that contains rules to add to the default CSS.\n-    crate extension_css: Option<PathBuf>,\n+    pub(crate) extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n-    crate extern_html_root_urls: BTreeMap<String, String>,\n+    pub(crate) extern_html_root_urls: BTreeMap<String, String>,\n     /// Whether to give precedence to `html_root_url` or `--exten-html-root-url`.\n-    crate extern_html_root_takes_precedence: bool,\n+    pub(crate) extern_html_root_takes_precedence: bool,\n     /// A map of the default settings (values are as for DOM storage API). Keys should lack the\n     /// `rustdoc-` prefix.\n-    crate default_settings: FxHashMap<String, String>,\n+    pub(crate) default_settings: FxHashMap<String, String>,\n     /// If present, suffix added to CSS/JavaScript files when referencing them in generated pages.\n-    crate resource_suffix: String,\n+    pub(crate) resource_suffix: String,\n     /// Whether to run the static CSS/JavaScript through a minifier when outputting them. `true` by\n     /// default.\n     //\n     // FIXME(misdreavus): the flag name is `--disable-minification` but the meaning is inverted\n     // once read.\n-    crate enable_minification: bool,\n+    pub(crate) enable_minification: bool,\n     /// Whether to create an index page in the root of the output directory. If this is true but\n     /// `enable_index_page` is None, generate a static listing of crates instead.\n-    crate enable_index_page: bool,\n+    pub(crate) enable_index_page: bool,\n     /// A file to use as the index page at the root of the output directory. Overrides\n     /// `enable_index_page` to be true if set.\n-    crate index_page: Option<PathBuf>,\n+    pub(crate) index_page: Option<PathBuf>,\n     /// An optional path to use as the location of static files. If not set, uses combinations of\n     /// `../` to reach the documentation root.\n-    crate static_root_path: Option<String>,\n+    pub(crate) static_root_path: Option<String>,\n \n     // Options specific to reading standalone Markdown files\n     /// Whether to generate a table of contents on the output file when reading a standalone\n     /// Markdown file.\n-    crate markdown_no_toc: bool,\n+    pub(crate) markdown_no_toc: bool,\n     /// Additional CSS files to link in pages generated from standalone Markdown files.\n-    crate markdown_css: Vec<String>,\n+    pub(crate) markdown_css: Vec<String>,\n     /// If present, playground URL to use in the \"Run\" button added to code samples generated from\n     /// standalone Markdown files. If not present, `playground_url` is used.\n-    crate markdown_playground_url: Option<String>,\n+    pub(crate) markdown_playground_url: Option<String>,\n     /// Document items that have lower than `pub` visibility.\n-    crate document_private: bool,\n+    pub(crate) document_private: bool,\n     /// Document items that have `doc(hidden)`.\n-    crate document_hidden: bool,\n+    pub(crate) document_hidden: bool,\n     /// If `true`, generate a JSON file in the crate folder instead of HTML redirection files.\n-    crate generate_redirect_map: bool,\n+    pub(crate) generate_redirect_map: bool,\n     /// Show the memory layout of types in the docs.\n-    crate show_type_layout: bool,\n-    crate unstable_features: rustc_feature::UnstableFeatures,\n-    crate emit: Vec<EmitType>,\n+    pub(crate) show_type_layout: bool,\n+    pub(crate) unstable_features: rustc_feature::UnstableFeatures,\n+    pub(crate) emit: Vec<EmitType>,\n     /// If `true`, HTML source pages will generate links for items to their definition.\n-    crate generate_link_to_definition: bool,\n+    pub(crate) generate_link_to_definition: bool,\n     /// Set of function-call locations to include as examples\n-    crate call_locations: AllCallLocations,\n+    pub(crate) call_locations: AllCallLocations,\n     /// If `true`, Context::init will not emit shared files.\n-    crate no_emit_shared: bool,\n+    pub(crate) no_emit_shared: bool,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-crate enum EmitType {\n+pub(crate) enum EmitType {\n     Unversioned,\n     Toolchain,\n     InvocationSpecific,\n@@ -302,15 +302,15 @@ impl FromStr for EmitType {\n }\n \n impl RenderOptions {\n-    crate fn should_emit_crate(&self) -> bool {\n+    pub(crate) fn should_emit_crate(&self) -> bool {\n         self.emit.is_empty() || self.emit.contains(&EmitType::InvocationSpecific)\n     }\n }\n \n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n-    crate fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n+    pub(crate) fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n         nightly_options::check_nightly_options(matches, &opts());\n \n@@ -745,7 +745,7 @@ impl Options {\n     }\n \n     /// Returns `true` if the file given as `self.input` is a Markdown file.\n-    crate fn markdown_input(&self) -> bool {\n+    pub(crate) fn markdown_input(&self) -> bool {\n         self.input.extension().map_or(false, |e| e == \"md\" || e == \"markdown\")\n     }\n }"}, {"sha": "53281bfde2e4f104f265ba766f29b3ef64d65bcc", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 42, "deletions": 34, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -32,70 +32,74 @@ use crate::formats::cache::Cache;\n use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n use crate::passes::{self, Condition::*};\n \n-crate use rustc_session::config::{DebuggingOptions, Input, Options};\n+pub(crate) use rustc_session::config::{DebuggingOptions, Input, Options};\n \n-crate struct ResolverCaches {\n-    crate markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n-    crate doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n+pub(crate) struct ResolverCaches {\n+    pub(crate) markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n+    pub(crate) doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n-    crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n-    crate all_traits: Option<Vec<DefId>>,\n-    crate all_trait_impls: Option<Vec<DefId>>,\n-    crate all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n+    pub(crate) traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n+    pub(crate) all_traits: Option<Vec<DefId>>,\n+    pub(crate) all_trait_impls: Option<Vec<DefId>>,\n+    pub(crate) all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n }\n \n-crate struct DocContext<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct DocContext<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// Name resolver. Used for intra-doc links.\n     ///\n     /// The `Rc<RefCell<...>>` wrapping is needed because that is what's returned by\n     /// [`rustc_interface::Queries::expansion()`].\n     // FIXME: see if we can get rid of this RefCell somehow\n-    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    crate resolver_caches: ResolverCaches,\n+    pub(crate) resolver: Rc<RefCell<interface::BoxedResolver>>,\n+    pub(crate) resolver_caches: ResolverCaches,\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n-    crate param_env: ParamEnv<'tcx>,\n+    pub(crate) param_env: ParamEnv<'tcx>,\n     /// Later on moved through `clean::Crate` into `cache`\n-    crate external_traits: Rc<RefCell<FxHashMap<DefId, clean::TraitWithExtraInfo>>>,\n+    pub(crate) external_traits: Rc<RefCell<FxHashMap<DefId, clean::TraitWithExtraInfo>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n-    crate active_extern_traits: FxHashSet<DefId>,\n+    pub(crate) active_extern_traits: FxHashSet<DefId>,\n     // The current set of parameter substitutions,\n     // for expanding type aliases at the HIR level:\n     /// Table `DefId` of type, lifetime, or const parameter -> substituted type, lifetime, or const\n-    crate substs: FxHashMap<DefId, clean::SubstParam>,\n+    pub(crate) substs: FxHashMap<DefId, clean::SubstParam>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n-    crate impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n+    pub(crate) impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n-    crate generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n-    crate auto_traits: Vec<DefId>,\n+    pub(crate) generated_synthetics: FxHashSet<(Ty<'tcx>, DefId)>,\n+    pub(crate) auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n-    crate render_options: RenderOptions,\n+    pub(crate) render_options: RenderOptions,\n     /// This same cache is used throughout rustdoc, including in [`crate::html::render`].\n-    crate cache: Cache,\n+    pub(crate) cache: Cache,\n     /// Used by [`clean::inline`] to tell if an item has already been inlined.\n-    crate inlined: FxHashSet<ItemId>,\n+    pub(crate) inlined: FxHashSet<ItemId>,\n     /// Used by `calculate_doc_coverage`.\n-    crate output_format: OutputFormat,\n+    pub(crate) output_format: OutputFormat,\n }\n \n impl<'tcx> DocContext<'tcx> {\n-    crate fn sess(&self) -> &'tcx Session {\n+    pub(crate) fn sess(&self) -> &'tcx Session {\n         self.tcx.sess\n     }\n \n-    crate fn with_param_env<T, F: FnOnce(&mut Self) -> T>(&mut self, def_id: DefId, f: F) -> T {\n+    pub(crate) fn with_param_env<T, F: FnOnce(&mut Self) -> T>(\n+        &mut self,\n+        def_id: DefId,\n+        f: F,\n+    ) -> T {\n         let old_param_env = mem::replace(&mut self.param_env, self.tcx.param_env(def_id));\n         let ret = f(self);\n         self.param_env = old_param_env;\n         ret\n     }\n \n-    crate fn enter_resolver<F, R>(&self, f: F) -> R\n+    pub(crate) fn enter_resolver<F, R>(&self, f: F) -> R\n     where\n         F: FnOnce(&mut resolve::Resolver<'_>) -> R,\n     {\n@@ -104,7 +108,11 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    crate fn enter_alias<F, R>(&mut self, substs: FxHashMap<DefId, clean::SubstParam>, f: F) -> R\n+    pub(crate) fn enter_alias<F, R>(\n+        &mut self,\n+        substs: FxHashMap<DefId, clean::SubstParam>,\n+        f: F,\n+    ) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n@@ -116,7 +124,7 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n-    crate fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n+    pub(crate) fn as_local_hir_id(tcx: TyCtxt<'_>, item_id: ItemId) -> Option<HirId> {\n         match item_id {\n             ItemId::DefId(real_id) => {\n                 real_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n@@ -126,13 +134,13 @@ impl<'tcx> DocContext<'tcx> {\n         }\n     }\n \n-    crate fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+    pub(crate) fn with_all_traits(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_traits = self.resolver_caches.all_traits.take();\n         f(self, all_traits.as_ref().expect(\"`all_traits` are already borrowed\"));\n         self.resolver_caches.all_traits = all_traits;\n     }\n \n-    crate fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n+    pub(crate) fn with_all_trait_impls(&mut self, f: impl FnOnce(&mut Self, &[DefId])) {\n         let all_trait_impls = self.resolver_caches.all_trait_impls.take();\n         f(self, all_trait_impls.as_ref().expect(\"`all_trait_impls` are already borrowed\"));\n         self.resolver_caches.all_trait_impls = all_trait_impls;\n@@ -143,7 +151,7 @@ impl<'tcx> DocContext<'tcx> {\n ///\n /// If the given `error_format` is `ErrorOutputType::Json` and no `SourceMap` is given, a new one\n /// will be created for the handler.\n-crate fn new_handler(\n+pub(crate) fn new_handler(\n     error_format: ErrorOutputType,\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n@@ -194,7 +202,7 @@ crate fn new_handler(\n }\n \n /// Parse, resolve, and typecheck the given crate.\n-crate fn create_config(\n+pub(crate) fn create_config(\n     RustdocOptions {\n         input,\n         crate_name,\n@@ -311,7 +319,7 @@ crate fn create_config(\n     }\n }\n \n-crate fn run_global_ctxt(\n+pub(crate) fn run_global_ctxt(\n     tcx: TyCtxt<'_>,\n     resolver: Rc<RefCell<interface::BoxedResolver>>,\n     resolver_caches: ResolverCaches,\n@@ -535,7 +543,7 @@ impl<'tcx> Visitor<'tcx> for EmitIgnoredResolutionErrors<'tcx> {\n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter\n /// for `impl Trait` in argument position.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-crate enum ImplTraitParam {\n+pub(crate) enum ImplTraitParam {\n     DefId(DefId),\n     ParamIndex(u32),\n }"}, {"sha": "be066bdafa14a1bcf2b9d7876f0a8c6b35728a08", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,38 +15,38 @@ use std::path::{Path, PathBuf};\n use std::string::ToString;\n use std::sync::mpsc::Sender;\n \n-crate trait PathError {\n+pub(crate) trait PathError {\n     fn new<S, P: AsRef<Path>>(e: S, path: P) -> Self\n     where\n         S: ToString + Sized;\n }\n \n-crate struct DocFS {\n+pub(crate) struct DocFS {\n     sync_only: bool,\n     errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    crate fn new(errors: Sender<String>) -> DocFS {\n+    pub(crate) fn new(errors: Sender<String>) -> DocFS {\n         DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n-    crate fn set_sync_only(&mut self, sync_only: bool) {\n+    pub(crate) fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n-    crate fn close(&mut self) {\n+    pub(crate) fn close(&mut self) {\n         self.errors = None;\n     }\n \n-    crate fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+    pub(crate) fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n         // and directory creation.\n         fs::create_dir_all(path)\n     }\n \n-    crate fn write<E>(\n+    pub(crate) fn write<E>(\n         &self,\n         path: PathBuf,\n         contents: impl 'static + Send + AsRef<[u8]>,"}, {"sha": "3005bd9e4a4dd4dbb7e32788402839d480083b96", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -40,14 +40,14 @@ use crate::passes::span_of_attrs;\n \n /// Options that apply to all doctests in a crate or Markdown file (for `rustdoc foo.md`).\n #[derive(Clone, Default)]\n-crate struct GlobalTestOptions {\n+pub(crate) struct GlobalTestOptions {\n     /// Whether to disable the default `extern crate my_crate;` when creating doctests.\n-    crate no_crate_inject: bool,\n+    pub(crate) no_crate_inject: bool,\n     /// Additional crate-level attributes to add to doctests.\n-    crate attrs: Vec<String>,\n+    pub(crate) attrs: Vec<String>,\n }\n \n-crate fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n+pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     let input = config::Input::File(options.input.clone());\n \n     let invalid_codeblock_attributes_name = crate::lint::INVALID_CODEBLOCK_ATTRIBUTES.name;\n@@ -207,7 +207,11 @@ crate fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n     Ok(())\n }\n \n-crate fn run_tests(mut test_args: Vec<String>, nocapture: bool, tests: Vec<test::TestDescAndFn>) {\n+pub(crate) fn run_tests(\n+    mut test_args: Vec<String>,\n+    nocapture: bool,\n+    tests: Vec<test::TestDescAndFn>,\n+) {\n     test_args.insert(0, \"rustdoctest\".to_string());\n     if nocapture {\n         test_args.push(\"--nocapture\".to_string());\n@@ -488,7 +492,7 @@ fn run_test(\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n /// lines before the test code begins as well as if the output stream supports colors or not.\n-crate fn make_test(\n+pub(crate) fn make_test(\n     s: &str,\n     crate_name: Option<&str>,\n     dont_insert_main: bool,\n@@ -840,16 +844,16 @@ fn partition_source(s: &str, edition: Edition) -> (String, String, String) {\n     (before, after, crates)\n }\n \n-crate trait Tester {\n+pub(crate) trait Tester {\n     fn add_test(&mut self, test: String, config: LangString, line: usize);\n     fn get_line(&self) -> usize {\n         0\n     }\n     fn register_header(&mut self, _name: &str, _level: u32) {}\n }\n \n-crate struct Collector {\n-    crate tests: Vec<test::TestDescAndFn>,\n+pub(crate) struct Collector {\n+    pub(crate) tests: Vec<test::TestDescAndFn>,\n \n     // The name of the test displayed to the user, separated by `::`.\n     //\n@@ -887,7 +891,7 @@ crate struct Collector {\n }\n \n impl Collector {\n-    crate fn new(\n+    pub(crate) fn new(\n         crate_name: Symbol,\n         rustdoc_options: RustdocOptions,\n         use_headers: bool,\n@@ -922,7 +926,7 @@ impl Collector {\n         format!(\"{} - {}(line {})\", filename.prefer_local(), item_path, line)\n     }\n \n-    crate fn set_position(&mut self, position: Span) {\n+    pub(crate) fn set_position(&mut self, position: Span) {\n         self.position = position;\n     }\n "}, {"sha": "6ed7eab1abae6ae3097b36979d8454b859d91938", "filename": "src/librustdoc/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,9 +5,9 @@ use std::path::{Path, PathBuf};\n use crate::docfs::PathError;\n \n #[derive(Debug)]\n-crate struct Error {\n-    crate file: PathBuf,\n-    crate error: String,\n+pub(crate) struct Error {\n+    pub(crate) file: PathBuf,\n+    pub(crate) error: String,\n }\n \n impl error::Error for Error {}"}, {"sha": "37fd909c93342aa33e6b4af93018112c05c4beb6", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,20 +7,20 @@ use std::str;\n use serde::Serialize;\n \n #[derive(Clone, Debug, Serialize)]\n-crate struct ExternalHtml {\n+pub(crate) struct ExternalHtml {\n     /// Content that will be included inline in the `<head>` section of a\n     /// rendered Markdown file or generated documentation\n-    crate in_header: String,\n+    pub(crate) in_header: String,\n     /// Content that will be included inline between `<body>` and the content of\n     /// a rendered Markdown file or generated documentation\n-    crate before_content: String,\n+    pub(crate) before_content: String,\n     /// Content that will be included inline between the content and `</body>` of\n     /// a rendered Markdown file or generated documentation\n-    crate after_content: String,\n+    pub(crate) after_content: String,\n }\n \n impl ExternalHtml {\n-    crate fn load(\n+    pub(crate) fn load(\n         in_header: &[String],\n         before_content: &[String],\n         after_content: &[String],\n@@ -70,12 +70,12 @@ impl ExternalHtml {\n     }\n }\n \n-crate enum LoadStringError {\n+pub(crate) enum LoadStringError {\n     ReadFail,\n     BadUtf8,\n }\n \n-crate fn load_string<P: AsRef<Path>>(\n+pub(crate) fn load_string<P: AsRef<Path>>(\n     file_path: P,\n     diag: &rustc_errors::Handler,\n ) -> Result<String, LoadStringError> {"}, {"sha": "f3e075bc12a344577a1b672820fe890af9cc4dfe", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,13 +1,13 @@\n use crate::clean::*;\n \n-crate fn strip_item(mut item: Item) -> Item {\n+pub(crate) fn strip_item(mut item: Item) -> Item {\n     if !matches!(*item.kind, StrippedItem(..)) {\n         item.kind = box StrippedItem(item.kind);\n     }\n     item\n }\n \n-crate trait DocFolder: Sized {\n+pub(crate) trait DocFolder: Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         Some(self.fold_item_recur(item))\n     }"}, {"sha": "f5c0b5e6762bfeef783316df6b4b96b1950b9307", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -26,25 +26,25 @@ use crate::html::render::IndexItem;\n /// to `Send` so it may be stored in an `Arc` instance and shared among the various\n /// rendering threads.\n #[derive(Default)]\n-crate struct Cache {\n+pub(crate) struct Cache {\n     /// Maps a type ID to all known implementations for that type. This is only\n     /// recognized for intra-crate [`clean::Type::Path`]s, and is used to print\n     /// out extra documentation on the page of an enum/struct.\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    crate impls: FxHashMap<DefId, Vec<Impl>>,\n+    pub(crate) impls: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    crate paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n+    pub(crate) paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    crate external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n+    pub(crate) external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -56,56 +56,56 @@ crate struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    crate exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n+    pub(crate) exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n     /// parent trait if no extra documentation is specified, and default methods\n     /// should show up in documentation about trait implementations.\n-    crate traits: FxHashMap<DefId, clean::TraitWithExtraInfo>,\n+    pub(crate) traits: FxHashMap<DefId, clean::TraitWithExtraInfo>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n     /// of trait ids to the list of known implementors of the trait\n-    crate implementors: FxHashMap<DefId, Vec<Impl>>,\n+    pub(crate) implementors: FxHashMap<DefId, Vec<Impl>>,\n \n     /// Cache of where external crate documentation can be found.\n-    crate extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n+    pub(crate) extern_locations: FxHashMap<CrateNum, ExternalLocation>,\n \n     /// Cache of where documentation for primitives can be found.\n-    crate primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+    pub(crate) primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n \n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n     // the access levels from the privacy check pass.\n-    crate access_levels: AccessLevels<DefId>,\n+    pub(crate) access_levels: AccessLevels<DefId>,\n \n     /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    crate crate_version: Option<String>,\n+    pub(crate) crate_version: Option<String>,\n \n     /// Whether to document private items.\n     /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    crate document_private: bool,\n+    pub(crate) document_private: bool,\n \n     /// Crates marked with [`#[doc(masked)]`][doc_masked].\n     ///\n     /// [doc_masked]: https://doc.rust-lang.org/nightly/unstable-book/language-features/doc-masked.html\n-    crate masked_crates: FxHashSet<CrateNum>,\n+    pub(crate) masked_crates: FxHashSet<CrateNum>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n     stack: Vec<Symbol>,\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     stripped_mod: bool,\n \n-    crate search_index: Vec<IndexItem>,\n+    pub(crate) search_index: Vec<IndexItem>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n     // then the fully qualified name of the structure isn't presented in `paths`\n     // yet when its implementation methods are being indexed. Caches such methods\n     // and their parent id here and indexes them at the end of crate parsing.\n-    crate orphan_impl_items: Vec<(DefId, clean::Item)>,\n+    pub(crate) orphan_impl_items: Vec<(DefId, clean::Item)>,\n \n     // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n     // even though the trait itself is not exported. This can happen if a trait\n@@ -119,9 +119,9 @@ crate struct Cache {\n     /// All intra-doc links resolved so far.\n     ///\n     /// Links are indexed by the DefId of the item they document.\n-    crate intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n+    pub(crate) intra_doc_links: FxHashMap<ItemId, Vec<clean::ItemLink>>,\n     /// Cfg that have been hidden via #![doc(cfg_hide(...))]\n-    crate hidden_cfg: FxHashSet<clean::cfg::Cfg>,\n+    pub(crate) hidden_cfg: FxHashSet<clean::cfg::Cfg>,\n }\n \n /// This struct is used to wrap the `cache` and `tcx` in order to run `DocFolder`.\n@@ -133,13 +133,13 @@ struct CacheBuilder<'a, 'tcx> {\n }\n \n impl Cache {\n-    crate fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n+    pub(crate) fn new(access_levels: AccessLevels<DefId>, document_private: bool) -> Self {\n         Cache { access_levels, document_private, ..Cache::default() }\n     }\n \n     /// Populates the `Cache` with more data. The returned `Crate` will be missing some data that was\n     /// in `krate` due to the data being moved into the `Cache`.\n-    crate fn populate(cx: &mut DocContext<'_>, mut krate: clean::Crate) -> clean::Crate {\n+    pub(crate) fn populate(cx: &mut DocContext<'_>, mut krate: clean::Crate) -> clean::Crate {\n         let tcx = cx.tcx;\n \n         // Crawl the crate to build various caches used for the output"}, {"sha": "eca5501cd339da075d8ba705db35adfdd75c9e79", "filename": "src/librustdoc/formats/item_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ use crate::clean;\n /// a heading, edit the listing in `html/render.rs`, function `sidebar_module`. This uses an\n /// ordering based on a helper function inside `item_module`, in the same file.\n #[derive(Copy, PartialEq, Eq, Hash, Clone, Debug, PartialOrd, Ord)]\n-crate enum ItemType {\n+pub(crate) enum ItemType {\n     Module = 0,\n     ExternCrate = 1,\n     Import = 2,\n@@ -147,7 +147,7 @@ impl From<DefKind> for ItemType {\n }\n \n impl ItemType {\n-    crate fn as_str(&self) -> &'static str {\n+    pub(crate) fn as_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module => \"mod\",\n             ItemType::ExternCrate => \"externcrate\","}, {"sha": "2367bde01671163f6fd54caafe8e5f0824ee342d", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,43 +1,43 @@\n-crate mod cache;\n-crate mod item_type;\n-crate mod renderer;\n+pub(crate) mod cache;\n+pub(crate) mod item_type;\n+pub(crate) mod renderer;\n \n use rustc_hir::def_id::DefId;\n \n-crate use renderer::{run_format, FormatRenderer};\n+pub(crate) use renderer::{run_format, FormatRenderer};\n \n use crate::clean::{self, ItemId};\n \n /// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n /// impl.\n-crate enum AssocItemRender<'a> {\n+pub(crate) enum AssocItemRender<'a> {\n     All,\n     DerefFor { trait_: &'a clean::Path, type_: &'a clean::Type, deref_mut_: bool },\n }\n \n /// For different handling of associated items from the Deref target of a type rather than the type\n /// itself.\n #[derive(Copy, Clone, PartialEq)]\n-crate enum RenderMode {\n+pub(crate) enum RenderMode {\n     Normal,\n     ForDeref { mut_: bool },\n }\n \n /// Metadata about implementations for a type or trait.\n #[derive(Clone, Debug)]\n-crate struct Impl {\n-    crate impl_item: clean::Item,\n+pub(crate) struct Impl {\n+    pub(crate) impl_item: clean::Item,\n }\n \n impl Impl {\n-    crate fn inner_impl(&self) -> &clean::Impl {\n+    pub(crate) fn inner_impl(&self) -> &clean::Impl {\n         match *self.impl_item.kind {\n             clean::ImplItem(ref impl_) => impl_,\n             _ => panic!(\"non-impl item found in impl\"),\n         }\n     }\n \n-    crate fn trait_did(&self) -> Option<DefId> {\n+    pub(crate) fn trait_did(&self) -> Option<DefId> {\n         self.inner_impl().trait_.as_ref().map(|t| t.def_id())\n     }\n \n@@ -47,7 +47,7 @@ impl Impl {\n     /// with blanket impls).\n     ///\n     /// It panics if `self` is a `ItemId::Primitive`.\n-    crate fn def_id(&self) -> DefId {\n+    pub(crate) fn def_id(&self) -> DefId {\n         match self.impl_item.item_id {\n             ItemId::Blanket { impl_id, .. } => impl_id,\n             ItemId::Auto { trait_, .. } => trait_,"}, {"sha": "62ba984acc9619a06b3c5b4b1578bf3dc40a0d4b", "filename": "src/librustdoc/formats/renderer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,7 +9,7 @@ use crate::formats::cache::Cache;\n /// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n /// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n /// module, and cleanup/finalizing output.\n-crate trait FormatRenderer<'tcx>: Sized {\n+pub(crate) trait FormatRenderer<'tcx>: Sized {\n     /// Gives a description of the renderer. Used for performance profiling.\n     fn descr() -> &'static str;\n \n@@ -48,7 +48,7 @@ crate trait FormatRenderer<'tcx>: Sized {\n }\n \n /// Main method for rendering a crate.\n-crate fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n+pub(crate) fn run_format<'tcx, T: FormatRenderer<'tcx>>(\n     krate: clean::Crate,\n     options: RenderOptions,\n     cache: Cache,"}, {"sha": "4a19d0a44c3655b4705f09f1a46c39bdb3ef741e", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,7 +7,7 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-crate struct Escape<'a>(pub &'a str);\n+pub(crate) struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Display for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "3c492f51786c1314a0911102f99102e553b188d3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 55, "deletions": 47, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -33,7 +33,7 @@ use crate::html::render::Context;\n use super::url_parts_builder::estimate_item_path_byte_length;\n use super::url_parts_builder::UrlPartsBuilder;\n \n-crate trait Print {\n+pub(crate) trait Print {\n     fn print(self, buffer: &mut Buffer);\n }\n \n@@ -59,7 +59,7 @@ impl Print for &'_ str {\n }\n \n #[derive(Debug, Clone)]\n-crate struct Buffer {\n+pub(crate) struct Buffer {\n     for_html: bool,\n     buffer: String,\n }\n@@ -82,63 +82,63 @@ impl core::fmt::Write for Buffer {\n }\n \n impl Buffer {\n-    crate fn empty_from(v: &Buffer) -> Buffer {\n+    pub(crate) fn empty_from(v: &Buffer) -> Buffer {\n         Buffer { for_html: v.for_html, buffer: String::new() }\n     }\n \n-    crate fn html() -> Buffer {\n+    pub(crate) fn html() -> Buffer {\n         Buffer { for_html: true, buffer: String::new() }\n     }\n \n-    crate fn new() -> Buffer {\n+    pub(crate) fn new() -> Buffer {\n         Buffer { for_html: false, buffer: String::new() }\n     }\n \n-    crate fn is_empty(&self) -> bool {\n+    pub(crate) fn is_empty(&self) -> bool {\n         self.buffer.is_empty()\n     }\n \n-    crate fn into_inner(self) -> String {\n+    pub(crate) fn into_inner(self) -> String {\n         self.buffer\n     }\n \n-    crate fn insert_str(&mut self, idx: usize, s: &str) {\n+    pub(crate) fn insert_str(&mut self, idx: usize, s: &str) {\n         self.buffer.insert_str(idx, s);\n     }\n \n-    crate fn push_str(&mut self, s: &str) {\n+    pub(crate) fn push_str(&mut self, s: &str) {\n         self.buffer.push_str(s);\n     }\n \n-    crate fn push_buffer(&mut self, other: Buffer) {\n+    pub(crate) fn push_buffer(&mut self, other: Buffer) {\n         self.buffer.push_str(&other.buffer);\n     }\n \n     // Intended for consumption by write! and writeln! (std::fmt) but without\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import).\n-    crate fn write_str(&mut self, s: &str) {\n+    pub(crate) fn write_str(&mut self, s: &str) {\n         self.buffer.push_str(s);\n     }\n \n     // Intended for consumption by write! and writeln! (std::fmt) but without\n     // the fmt::Result return type imposed by fmt::Write (and avoiding the trait\n     // import).\n-    crate fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n+    pub(crate) fn write_fmt(&mut self, v: fmt::Arguments<'_>) {\n         use fmt::Write;\n         self.buffer.write_fmt(v).unwrap();\n     }\n \n-    crate fn to_display<T: Print>(mut self, t: T) -> String {\n+    pub(crate) fn to_display<T: Print>(mut self, t: T) -> String {\n         t.print(&mut self);\n         self.into_inner()\n     }\n \n-    crate fn is_for_html(&self) -> bool {\n+    pub(crate) fn is_for_html(&self) -> bool {\n         self.for_html\n     }\n \n-    crate fn reserve(&mut self, additional: usize) {\n+    pub(crate) fn reserve(&mut self, additional: usize) {\n         self.buffer.reserve(additional)\n     }\n }\n@@ -158,7 +158,7 @@ fn comma_sep<T: fmt::Display>(\n     })\n }\n \n-crate fn print_generic_bounds<'a, 'tcx: 'a>(\n+pub(crate) fn print_generic_bounds<'a, 'tcx: 'a>(\n     bounds: &'a [clean::GenericBound],\n     cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -176,7 +176,7 @@ crate fn print_generic_bounds<'a, 'tcx: 'a>(\n }\n \n impl clean::GenericParamDef {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -239,7 +239,7 @@ impl clean::GenericParamDef {\n }\n \n impl clean::Generics {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -262,7 +262,7 @@ impl clean::Generics {\n /// * The Generics from which to emit a where-clause.\n /// * The number of spaces to indent each line with.\n /// * Whether the where-clause needs to add a comma and newline after the last bound.\n-crate fn print_where_clause<'a, 'tcx: 'a>(\n+pub(crate) fn print_where_clause<'a, 'tcx: 'a>(\n     gens: &'a clean::Generics,\n     cx: &'a Context<'tcx>,\n     indent: usize,\n@@ -372,13 +372,13 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n }\n \n impl clean::Lifetime {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self) -> impl fmt::Display + '_ {\n         self.0.as_str()\n     }\n }\n \n impl clean::Constant {\n-    crate fn print(&self, tcx: TyCtxt<'_>) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self, tcx: TyCtxt<'_>) -> impl fmt::Display + '_ {\n         let expr = self.expr(tcx);\n         display_fn(\n             move |f| {\n@@ -419,7 +419,7 @@ impl clean::PolyTrait {\n }\n \n impl clean::GenericBound {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -516,7 +516,7 @@ impl clean::GenericArgs {\n }\n \n // Possible errors when computing href link source for a `DefId`\n-crate enum HrefError {\n+pub(crate) enum HrefError {\n     /// This item is known to rustdoc, but from a crate that does not have documentation generated.\n     ///\n     /// This can only happen for non-local items.\n@@ -543,7 +543,7 @@ crate enum HrefError {\n }\n \n // Panics if `syms` is empty.\n-crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n+pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     let mut s = String::with_capacity(estimate_item_path_byte_length(syms.len()));\n     s.push_str(&syms[0].as_str());\n     for sym in &syms[1..] {\n@@ -553,7 +553,7 @@ crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n     s\n }\n \n-crate fn href_with_root_path(\n+pub(crate) fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n     root_path: Option<&str>,\n@@ -633,14 +633,17 @@ crate fn href_with_root_path(\n     Ok((url_parts.finish(), shortty, fqp.to_vec()))\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n+pub(crate) fn href(\n+    did: DefId,\n+    cx: &Context<'_>,\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     href_with_root_path(did, cx, None)\n }\n \n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n-crate fn href_relative_parts<'fqp>(\n+pub(crate) fn href_relative_parts<'fqp>(\n     fqp: &'fqp [Symbol],\n     relative_to_fqp: &[Symbol],\n ) -> Box<dyn Iterator<Item = Symbol> + 'fqp> {\n@@ -787,7 +790,7 @@ fn tybounds<'a, 'tcx: 'a>(\n     })\n }\n \n-crate fn anchor<'a, 'cx: 'a>(\n+pub(crate) fn anchor<'a, 'cx: 'a>(\n     did: DefId,\n     text: Symbol,\n     cx: &'cx Context<'_>,\n@@ -1031,7 +1034,7 @@ fn fmt_type<'cx>(\n }\n \n impl clean::Type {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1040,7 +1043,7 @@ impl clean::Type {\n }\n \n impl clean::Path {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1049,7 +1052,7 @@ impl clean::Path {\n }\n \n impl clean::Impl {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         use_absolute: bool,\n         cx: &'a Context<'tcx>,\n@@ -1083,7 +1086,7 @@ impl clean::Impl {\n }\n \n impl clean::Arguments {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1107,7 +1110,7 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1142,7 +1145,7 @@ impl clean::BareFunctionDecl {\n }\n \n impl clean::FnDecl {\n-    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n+    pub(crate) fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'b + Captures<'tcx> {\n@@ -1174,7 +1177,7 @@ impl clean::FnDecl {\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     /// * `asyncness`: Whether the function is async or not.\n-    crate fn full_print<'a, 'tcx: 'a>(\n+    pub(crate) fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n         header_len: usize,\n         indent: usize,\n@@ -1291,7 +1294,7 @@ impl clean::FnDecl {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'a, 'tcx: 'a>(\n+    pub(crate) fn print_with_space<'a, 'tcx: 'a>(\n         self,\n         item_did: ItemId,\n         cx: &'a Context<'tcx>,\n@@ -1339,7 +1342,7 @@ impl clean::Visibility {\n     /// This function is the same as print_with_space, except that it renders no links.\n     /// It's used for macros' rendered source view, which is syntax highlighted and cannot have\n     /// any HTML in it.\n-    crate fn to_src_with_space<'a, 'tcx: 'a>(\n+    pub(crate) fn to_src_with_space<'a, 'tcx: 'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         item_did: DefId,\n@@ -1374,7 +1377,7 @@ impl clean::Visibility {\n     }\n }\n \n-crate trait PrintWithSpace {\n+pub(crate) trait PrintWithSpace {\n     fn print_with_space(&self) -> &str;\n }\n \n@@ -1405,7 +1408,10 @@ impl PrintWithSpace for hir::Mutability {\n     }\n }\n \n-crate fn print_constness_with_space(c: &hir::Constness, s: Option<ConstStability>) -> &'static str {\n+pub(crate) fn print_constness_with_space(\n+    c: &hir::Constness,\n+    s: Option<ConstStability>,\n+) -> &'static str {\n     match (c, s) {\n         // const stable or when feature(staged_api) is not set\n         (\n@@ -1419,7 +1425,7 @@ crate fn print_constness_with_space(c: &hir::Constness, s: Option<ConstStability\n }\n \n impl clean::Import {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1443,7 +1449,7 @@ impl clean::Import {\n }\n \n impl clean::ImportSource {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1466,7 +1472,7 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1500,7 +1506,7 @@ impl clean::TypeBinding {\n     }\n }\n \n-crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n+pub(crate) fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n     display_fn(move |f| {\n         let quot = if f.alternate() { \"\\\"\" } else { \"&quot;\" };\n         match abi {\n@@ -1510,12 +1516,12 @@ crate fn print_abi_with_space(abi: Abi) -> impl fmt::Display {\n     })\n }\n \n-crate fn print_default_space<'a>(v: bool) -> &'a str {\n+pub(crate) fn print_default_space<'a>(v: bool) -> &'a str {\n     if v { \"default \" } else { \"\" }\n }\n \n impl clean::GenericArg {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1529,7 +1535,7 @@ impl clean::GenericArg {\n }\n \n impl clean::types::Term {\n-    crate fn print<'a, 'tcx: 'a>(\n+    pub(crate) fn print<'a, 'tcx: 'a>(\n         &'a self,\n         cx: &'a Context<'tcx>,\n     ) -> impl fmt::Display + 'a + Captures<'tcx> {\n@@ -1540,7 +1546,9 @@ impl clean::types::Term {\n     }\n }\n \n-crate fn display_fn(f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result) -> impl fmt::Display {\n+pub(crate) fn display_fn(\n+    f: impl FnOnce(&mut fmt::Formatter<'_>) -> fmt::Result,\n+) -> impl fmt::Display {\n     struct WithFormatter<F>(Cell<Option<F>>);\n \n     impl<F> fmt::Display for WithFormatter<F>"}, {"sha": "480728b179790e6e4be8a702497db0e195edb258", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -22,21 +22,21 @@ use super::format::{self, Buffer};\n use super::render::LinkFromSrc;\n \n /// This type is needed in case we want to render links on items to allow to go to their definition.\n-crate struct ContextInfo<'a, 'b, 'c> {\n-    crate context: &'a Context<'b>,\n+pub(crate) struct ContextInfo<'a, 'b, 'c> {\n+    pub(crate) context: &'a Context<'b>,\n     /// This span contains the current file we're going through.\n-    crate file_span: Span,\n+    pub(crate) file_span: Span,\n     /// This field is used to know \"how far\" from the top of the directory we are to link to either\n     /// documentation pages or other source pages.\n-    crate root_path: &'c str,\n+    pub(crate) root_path: &'c str,\n }\n \n /// Decorations are represented as a map from CSS class to vector of character ranges.\n /// Each range will be wrapped in a span with that class.\n-crate struct DecorationInfo(crate FxHashMap<&'static str, Vec<(u32, u32)>>);\n+pub(crate) struct DecorationInfo(pub(crate) FxHashMap<&'static str, Vec<(u32, u32)>>);\n \n /// Highlights `src`, returning the HTML output.\n-crate fn render_with_highlighting(\n+pub(crate) fn render_with_highlighting(\n     src: &str,\n     out: &mut Buffer,\n     class: Option<&str>,"}, {"sha": "de54347a0f74e0c7c889b49e540d12beb5e564f9", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,33 +10,33 @@ use crate::html::render::{ensure_trailing_slash, StylePath};\n use askama::Template;\n \n #[derive(Clone)]\n-crate struct Layout {\n-    crate logo: String,\n-    crate favicon: String,\n-    crate external_html: ExternalHtml,\n-    crate default_settings: FxHashMap<String, String>,\n-    crate krate: String,\n+pub(crate) struct Layout {\n+    pub(crate) logo: String,\n+    pub(crate) favicon: String,\n+    pub(crate) external_html: ExternalHtml,\n+    pub(crate) default_settings: FxHashMap<String, String>,\n+    pub(crate) krate: String,\n     /// The given user css file which allow to customize the generated\n     /// documentation theme.\n-    crate css_file_extension: Option<PathBuf>,\n+    pub(crate) css_file_extension: Option<PathBuf>,\n     /// If true, then scrape-examples.js will be included in the output HTML file\n-    crate scrape_examples_extension: bool,\n+    pub(crate) scrape_examples_extension: bool,\n }\n \n-crate struct Page<'a> {\n-    crate title: &'a str,\n-    crate css_class: &'a str,\n-    crate root_path: &'a str,\n-    crate static_root_path: Option<&'a str>,\n-    crate description: &'a str,\n-    crate keywords: &'a str,\n-    crate resource_suffix: &'a str,\n-    crate extra_scripts: &'a [&'a str],\n-    crate static_extra_scripts: &'a [&'a str],\n+pub(crate) struct Page<'a> {\n+    pub(crate) title: &'a str,\n+    pub(crate) css_class: &'a str,\n+    pub(crate) root_path: &'a str,\n+    pub(crate) static_root_path: Option<&'a str>,\n+    pub(crate) description: &'a str,\n+    pub(crate) keywords: &'a str,\n+    pub(crate) resource_suffix: &'a str,\n+    pub(crate) extra_scripts: &'a [&'a str],\n+    pub(crate) static_extra_scripts: &'a [&'a str],\n }\n \n impl<'a> Page<'a> {\n-    crate fn get_static_root_path(&self) -> &str {\n+    pub(crate) fn get_static_root_path(&self) -> &str {\n         self.static_root_path.unwrap_or(self.root_path)\n     }\n }\n@@ -51,10 +51,10 @@ struct PageLayout<'a> {\n     sidebar: String,\n     content: String,\n     krate_with_trailing_slash: String,\n-    crate rustdoc_version: &'a str,\n+    pub(crate) rustdoc_version: &'a str,\n }\n \n-crate fn render<T: Print, S: Print>(\n+pub(crate) fn render<T: Print, S: Print>(\n     layout: &Layout,\n     page: &Page<'_>,\n     sidebar: S,\n@@ -86,7 +86,7 @@ crate fn render<T: Print, S: Print>(\n     .unwrap()\n }\n \n-crate fn redirect(url: &str) -> String {\n+pub(crate) fn redirect(url: &str) -> String {\n     // <script> triggers a redirect before refresh, so this is fine.\n     format!(\n         r##\"<!DOCTYPE html>"}, {"sha": "8877f628332c981ffb97c8304b495a2761c9528a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -104,23 +104,23 @@ pub struct Markdown<'a> {\n     pub heading_offset: HeadingOffset,\n }\n /// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n-crate struct MarkdownWithToc<'a>(\n-    crate &'a str,\n-    crate &'a mut IdMap,\n-    crate ErrorCodes,\n-    crate Edition,\n-    crate &'a Option<Playground>,\n+pub(crate) struct MarkdownWithToc<'a>(\n+    pub(crate) &'a str,\n+    pub(crate) &'a mut IdMap,\n+    pub(crate) ErrorCodes,\n+    pub(crate) Edition,\n+    pub(crate) &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n-crate struct MarkdownHtml<'a>(\n-    crate &'a str,\n-    crate &'a mut IdMap,\n-    crate ErrorCodes,\n-    crate Edition,\n-    crate &'a Option<Playground>,\n+pub(crate) struct MarkdownHtml<'a>(\n+    pub(crate) &'a str,\n+    pub(crate) &'a mut IdMap,\n+    pub(crate) ErrorCodes,\n+    pub(crate) Edition,\n+    pub(crate) &'a Option<Playground>,\n );\n /// A tuple struct like `Markdown` that renders only the first paragraph.\n-crate struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n+pub(crate) struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [RenderedLink]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ErrorCodes {\n@@ -129,14 +129,14 @@ pub enum ErrorCodes {\n }\n \n impl ErrorCodes {\n-    crate fn from(b: bool) -> Self {\n+    pub(crate) fn from(b: bool) -> Self {\n         match b {\n             true => ErrorCodes::Yes,\n             false => ErrorCodes::No,\n         }\n     }\n \n-    crate fn as_bool(self) -> bool {\n+    pub(crate) fn as_bool(self) -> bool {\n         match self {\n             ErrorCodes::Yes => true,\n             ErrorCodes::No => false,\n@@ -716,7 +716,7 @@ impl<'a, I: Iterator<Item = SpannedEvent<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-crate fn find_testable_code<T: doctest::Tester>(\n+pub(crate) fn find_testable_code<T: doctest::Tester>(\n     doc: &str,\n     tests: &mut T,\n     error_codes: ErrorCodes,\n@@ -788,7 +788,7 @@ crate fn find_testable_code<T: doctest::Tester>(\n     }\n }\n \n-crate struct ExtraInfo<'tcx> {\n+pub(crate) struct ExtraInfo<'tcx> {\n     id: ExtraInfoId,\n     sp: Span,\n     tcx: TyCtxt<'tcx>,\n@@ -800,11 +800,11 @@ enum ExtraInfoId {\n }\n \n impl<'tcx> ExtraInfo<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { id: ExtraInfoId::Hir(hir_id), sp, tcx }\n     }\n \n-    crate fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n+    pub(crate) fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n         ExtraInfo { id: ExtraInfoId::Def(did), sp, tcx }\n     }\n \n@@ -835,20 +835,20 @@ impl<'tcx> ExtraInfo<'tcx> {\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-crate struct LangString {\n+pub(crate) struct LangString {\n     original: String,\n-    crate should_panic: bool,\n-    crate no_run: bool,\n-    crate ignore: Ignore,\n-    crate rust: bool,\n-    crate test_harness: bool,\n-    crate compile_fail: bool,\n-    crate error_codes: Vec<String>,\n-    crate edition: Option<Edition>,\n+    pub(crate) should_panic: bool,\n+    pub(crate) no_run: bool,\n+    pub(crate) ignore: Ignore,\n+    pub(crate) rust: bool,\n+    pub(crate) test_harness: bool,\n+    pub(crate) compile_fail: bool,\n+    pub(crate) error_codes: Vec<String>,\n+    pub(crate) edition: Option<Edition>,\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-crate enum Ignore {\n+pub(crate) enum Ignore {\n     All,\n     None,\n     Some(Vec<String>),\n@@ -1058,7 +1058,7 @@ impl Markdown<'_> {\n }\n \n impl MarkdownWithToc<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownWithToc(md, mut ids, codes, edition, playground) = self;\n \n         let p = Parser::new_ext(md, main_body_opts()).into_offset_iter();\n@@ -1080,7 +1080,7 @@ impl MarkdownWithToc<'_> {\n }\n \n impl MarkdownHtml<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownHtml(md, mut ids, codes, edition, playground) = self;\n \n         // This is actually common enough to special-case\n@@ -1108,7 +1108,7 @@ impl MarkdownHtml<'_> {\n }\n \n impl MarkdownSummaryLine<'_> {\n-    crate fn into_string(self) -> String {\n+    pub(crate) fn into_string(self) -> String {\n         let MarkdownSummaryLine(md, links) = self;\n         // This is actually common enough to special-case\n         if md.is_empty() {\n@@ -1207,7 +1207,7 @@ fn markdown_summary_with_limit(\n /// Will shorten to 59 or 60 characters, including an ellipsis (\u2026) if it was shortened.\n ///\n /// See [`markdown_summary_with_limit`] for details about what is rendered and what is not.\n-crate fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) -> String {\n+pub(crate) fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) -> String {\n     let (mut s, was_shortened) = markdown_summary_with_limit(markdown, link_names, 59);\n \n     if was_shortened {\n@@ -1223,7 +1223,7 @@ crate fn short_markdown_summary(markdown: &str, link_names: &[RenderedLink]) ->\n /// - Headings, links, and formatting are stripped.\n /// - Inline code is rendered as-is, surrounded by backticks.\n /// - HTML and code blocks are ignored.\n-crate fn plain_text_summary(md: &str) -> String {\n+pub(crate) fn plain_text_summary(md: &str) -> String {\n     if md.is_empty() {\n         return String::new();\n     }\n@@ -1250,13 +1250,16 @@ crate fn plain_text_summary(md: &str) -> String {\n }\n \n #[derive(Debug)]\n-crate struct MarkdownLink {\n+pub(crate) struct MarkdownLink {\n     pub kind: LinkType,\n     pub link: String,\n     pub range: Range<usize>,\n }\n \n-crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option<R>) -> Vec<R> {\n+pub(crate) fn markdown_links<R>(\n+    md: &str,\n+    filter_map: impl Fn(MarkdownLink) -> Option<R>,\n+) -> Vec<R> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1337,19 +1340,19 @@ crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option\n }\n \n #[derive(Debug)]\n-crate struct RustCodeBlock {\n+pub(crate) struct RustCodeBlock {\n     /// The range in the markdown that the code block occupies. Note that this includes the fences\n     /// for fenced code blocks.\n-    crate range: Range<usize>,\n+    pub(crate) range: Range<usize>,\n     /// The range in the markdown that the code within the code block occupies.\n-    crate code: Range<usize>,\n-    crate is_fenced: bool,\n-    crate lang_string: LangString,\n+    pub(crate) code: Range<usize>,\n+    pub(crate) is_fenced: bool,\n+    pub(crate) lang_string: LangString,\n }\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n /// untagged (and assumed to be rust).\n-crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeBlock> {\n+pub(crate) fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_>) -> Vec<RustCodeBlock> {\n     let mut code_blocks = vec![];\n \n     if md.is_empty() {\n@@ -1492,7 +1495,7 @@ impl IdMap {\n         IdMap { map: DEFAULT_ID_MAP.clone() }\n     }\n \n-    crate fn derive<S: AsRef<str> + ToString>(&mut self, candidate: S) -> String {\n+    pub(crate) fn derive<S: AsRef<str> + ToString>(&mut self, candidate: S) -> String {\n         let id = match self.map.get_mut(candidate.as_ref()) {\n             None => candidate.to_string(),\n             Some(a) => {"}, {"sha": "481ed16c05f7e0775051d947457eb278dab53379", "filename": "src/librustdoc/html/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,14 +1,14 @@\n-crate mod escape;\n-crate mod format;\n-crate mod highlight;\n-crate mod layout;\n+pub(crate) mod escape;\n+pub(crate) mod format;\n+pub(crate) mod highlight;\n+pub(crate) mod layout;\n mod length_limit;\n // used by the error-index generator, so it needs to be public\n pub mod markdown;\n-crate mod render;\n-crate mod sources;\n-crate mod static_files;\n-crate mod toc;\n+pub(crate) mod render;\n+pub(crate) mod sources;\n+pub(crate) mod static_files;\n+pub(crate) mod toc;\n mod url_parts_builder;\n \n #[cfg(test)]"}, {"sha": "76377c438e832d3f59770ef68967a98b8836f472", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -42,13 +42,13 @@ use crate::try_err;\n /// It is intended that this context is a lightweight object which can be fairly\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n-crate struct Context<'tcx> {\n+pub(crate) struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub(crate) current: Vec<Symbol>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n-    crate dst: PathBuf,\n+    pub(crate) dst: PathBuf,\n     /// A flag, which when `true`, will render pages which redirect to the\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n@@ -63,28 +63,28 @@ crate struct Context<'tcx> {\n     /// Issue for improving the situation: [#82381][]\n     ///\n     /// [#82381]: https://github.com/rust-lang/rust/issues/82381\n-    crate shared: Rc<SharedContext<'tcx>>,\n+    pub(crate) shared: Rc<SharedContext<'tcx>>,\n     /// This flag indicates whether source links should be generated or not. If\n     /// the source files are present in the html rendering, then this will be\n     /// `true`.\n-    crate include_sources: bool,\n+    pub(crate) include_sources: bool,\n }\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Context<'_>, 144);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n-crate struct SharedContext<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n+pub(crate) struct SharedContext<'tcx> {\n+    pub(crate) tcx: TyCtxt<'tcx>,\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n-    crate src_root: PathBuf,\n+    pub(crate) src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n-    crate layout: layout::Layout,\n+    pub(crate) layout: layout::Layout,\n     /// The local file sources we've emitted and their respective url-paths.\n-    crate local_sources: FxHashMap<PathBuf, String>,\n+    pub(crate) local_sources: FxHashMap<PathBuf, String>,\n     /// Show the memory layout of types in the docs.\n     pub(super) show_type_layout: bool,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -97,15 +97,15 @@ crate struct SharedContext<'tcx> {\n     /// should be ordered alphabetically or in order of appearance (in the source code).\n     pub(super) sort_modules_alphabetically: bool,\n     /// Additional CSS files to be added to the generated docs.\n-    crate style_files: Vec<StylePath>,\n+    pub(crate) style_files: Vec<StylePath>,\n     /// Suffix to be added on resource files (if suffix is \"-v2\" then \"light.css\" becomes\n     /// \"light-v2.css\").\n-    crate resource_suffix: String,\n+    pub(crate) resource_suffix: String,\n     /// Optional path string to be used to load static files on output pages. If not set, uses\n     /// combinations of `../` to reach the documentation root.\n-    crate static_root_path: Option<String>,\n+    pub(crate) static_root_path: Option<String>,\n     /// The fs handle we are working with.\n-    crate fs: DocFS,\n+    pub(crate) fs: DocFS,\n     pub(super) codes: ErrorCodes,\n     pub(super) playground: Option<markdown::Playground>,\n     all: RefCell<AllTypes>,\n@@ -119,15 +119,15 @@ crate struct SharedContext<'tcx> {\n \n     /// Correspondance map used to link types used in the source code pages to allow to click on\n     /// links to jump to the type's definition.\n-    crate span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n+    pub(crate) span_correspondance_map: FxHashMap<rustc_span::Span, LinkFromSrc>,\n     /// The [`Cache`] used during rendering.\n-    crate cache: Cache,\n+    pub(crate) cache: Cache,\n \n-    crate call_locations: AllCallLocations,\n+    pub(crate) call_locations: AllCallLocations,\n }\n \n impl SharedContext<'_> {\n-    crate fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n+    pub(crate) fn ensure_dir(&self, dst: &Path) -> Result<(), Error> {\n         let mut dirs = self.created_dirs.borrow_mut();\n         if !dirs.contains(dst) {\n             try_err!(self.fs.create_dir_all(dst), dst);\n@@ -137,7 +137,7 @@ impl SharedContext<'_> {\n         Ok(())\n     }\n \n-    crate fn edition(&self) -> Edition {\n+    pub(crate) fn edition(&self) -> Edition {\n         self.tcx.sess.edition()\n     }\n }\n@@ -301,7 +301,7 @@ impl<'tcx> Context<'tcx> {\n         self.href_from_span(item.span(self.tcx()), true)\n     }\n \n-    crate fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n+    pub(crate) fn href_from_span(&self, span: clean::Span, with_lines: bool) -> Option<String> {\n         if span.is_dummy() {\n             return None;\n         }"}, {"sha": "0de50c60facb31e223235db2e66c6ff328d6e415", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -23,7 +23,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-crate mod search_index;\n+pub(crate) mod search_index;\n \n #[cfg(test)]\n mod tests;\n@@ -33,8 +33,8 @@ mod print_item;\n mod span_map;\n mod write_shared;\n \n-crate use self::context::*;\n-crate use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n+pub(crate) use self::context::*;\n+pub(crate) use self::span_map::{collect_spans_and_sources, LinkFromSrc};\n \n use std::collections::VecDeque;\n use std::default::Default;\n@@ -81,9 +81,9 @@ use crate::try_none;\n use crate::DOC_RUST_LANG_ORG_CHANNEL;\n \n /// A pair of name and its optional document.\n-crate type NameDoc = (String, Option<String>);\n+pub(crate) type NameDoc = (String, Option<String>);\n \n-crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n+pub(crate) fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     crate::html::format::display_fn(move |f| {\n         if !v.ends_with('/') && !v.is_empty() { write!(f, \"{}/\", v) } else { f.write_str(v) }\n     })\n@@ -95,27 +95,27 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-crate struct IndexItem {\n-    crate ty: ItemType,\n-    crate name: String,\n-    crate path: String,\n-    crate desc: String,\n-    crate parent: Option<DefId>,\n-    crate parent_idx: Option<usize>,\n-    crate search_type: Option<IndexItemFunctionType>,\n-    crate aliases: Box<[Symbol]>,\n+pub(crate) struct IndexItem {\n+    pub(crate) ty: ItemType,\n+    pub(crate) name: String,\n+    pub(crate) path: String,\n+    pub(crate) desc: String,\n+    pub(crate) parent: Option<DefId>,\n+    pub(crate) parent_idx: Option<usize>,\n+    pub(crate) search_type: Option<IndexItemFunctionType>,\n+    pub(crate) aliases: Box<[Symbol]>,\n }\n \n /// A type used for the search index.\n #[derive(Debug)]\n-crate struct RenderType {\n+pub(crate) struct RenderType {\n     name: Option<String>,\n     generics: Option<Vec<TypeWithKind>>,\n }\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-crate struct IndexItemFunctionType {\n+pub(crate) struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Vec<TypeWithKind>,\n }\n@@ -143,7 +143,7 @@ impl Serialize for IndexItemFunctionType {\n }\n \n #[derive(Debug)]\n-crate struct TypeWithKind {\n+pub(crate) struct TypeWithKind {\n     ty: RenderType,\n     kind: ItemType,\n }\n@@ -170,13 +170,13 @@ impl Serialize for TypeWithKind {\n }\n \n #[derive(Debug, Clone)]\n-crate struct StylePath {\n+pub(crate) struct StylePath {\n     /// The path to the theme\n-    crate path: PathBuf,\n+    pub(crate) path: PathBuf,\n }\n \n impl StylePath {\n-    crate fn basename(&self) -> Result<String, Error> {\n+    pub(crate) fn basename(&self) -> Result<String, Error> {\n         Ok(try_none!(try_none!(self.path.file_stem(), &self.path).to_str(), &self.path).to_string())\n     }\n }\n@@ -203,7 +203,7 @@ impl ItemEntry {\n }\n \n impl ItemEntry {\n-    crate fn print(&self) -> impl fmt::Display + '_ {\n+    pub(crate) fn print(&self) -> impl fmt::Display + '_ {\n         crate::html::format::display_fn(move |f| {\n             write!(f, \"<a href=\\\"{}\\\">{}</a>\", self.url, Escape(&self.name))\n         })\n@@ -2580,7 +2580,7 @@ fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-crate const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n+pub(crate) const BASIC_KEYWORDS: &str = \"rust, rustlang, rust-lang\";\n \n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls"}, {"sha": "12e6115e6fec7df955cac4d5e02e2ebed85d5a61", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -246,14 +246,14 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n     // This call is to remove re-export duplicates in cases such as:\n     //\n     // ```\n-    // crate mod foo {\n-    //     crate mod bar {\n-    //         crate trait Double { fn foo(); }\n+    // pub(crate) mod foo {\n+    //     pub(crate) mod bar {\n+    //         pub(crate) trait Double { fn foo(); }\n     //     }\n     // }\n     //\n-    // crate use foo::bar::*;\n-    // crate use foo::*;\n+    // pub(crate) use foo::bar::*;\n+    // pub(crate) use foo::*;\n     // ```\n     //\n     // `Double` will appear twice in the generated docs.\n@@ -1473,7 +1473,7 @@ fn item_keyword(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item) {\n }\n \n /// Compare two strings treating multi-digit numbers as single units (i.e. natural sort order).\n-crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n+pub(crate) fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n     /// Takes a non-numeric and a numeric part from the given &str.\n     fn take_parts<'a>(s: &mut &'a str) -> (&'a str, &'a str) {\n         let i = s.find(|c: char| c.is_ascii_digit());"}, {"sha": "4e53ba4dc0cf6702a9feb844f4da05eac96d9070", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -15,7 +15,11 @@ use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Builds the search index from the collected metadata\n-crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n+pub(crate) fn build_index<'tcx>(\n+    krate: &clean::Crate,\n+    cache: &mut Cache,\n+    tcx: TyCtxt<'tcx>,\n+) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_paths = vec![];\n \n@@ -185,7 +189,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     )\n }\n \n-crate fn get_function_type_for_search<'tcx>(\n+pub(crate) fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n     cache: &Cache,"}, {"sha": "287ce9611d75e107d90cb6f051414f0dcd9221e1", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -20,7 +20,7 @@ use std::path::{Path, PathBuf};\n /// Otherwise, we store the definition `DefId` and will generate a link to the documentation page\n /// instead of the source code directly.\n #[derive(Debug)]\n-crate enum LinkFromSrc {\n+pub(crate) enum LinkFromSrc {\n     Local(clean::Span),\n     External(DefId),\n     Primitive(PrimitiveType),\n@@ -36,7 +36,7 @@ crate enum LinkFromSrc {\n /// Note about the `span` correspondance map: the keys are actually `(lo, hi)` of `span`s. We don't\n /// need the `span` context later on, only their position, so instead of keep a whole `Span`, we\n /// only keep the `lo` and `hi`.\n-crate fn collect_spans_and_sources(\n+pub(crate) fn collect_spans_and_sources(\n     tcx: TyCtxt<'_>,\n     krate: &clean::Crate,\n     src_root: &Path,\n@@ -57,8 +57,8 @@ crate fn collect_spans_and_sources(\n }\n \n struct SpanMapVisitor<'tcx> {\n-    crate tcx: TyCtxt<'tcx>,\n-    crate matches: FxHashMap<Span, LinkFromSrc>,\n+    pub(crate) tcx: TyCtxt<'tcx>,\n+    pub(crate) matches: FxHashMap<Span, LinkFromSrc>,\n }\n \n impl<'tcx> SpanMapVisitor<'tcx> {"}, {"sha": "0bbdc37ea8972d20d95cd4d46b4bfc57e6037ad2", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -16,7 +16,7 @@ use std::ffi::OsStr;\n use std::fs;\n use std::path::{Component, Path, PathBuf};\n \n-crate fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n+pub(crate) fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error> {\n     info!(\"emitting source files\");\n \n     let dst = cx.dst.join(\"src\").join(krate.name(cx.tcx()).as_str());\n@@ -27,7 +27,7 @@ crate fn render(cx: &mut Context<'_>, krate: &clean::Crate) -> Result<(), Error>\n     Ok(())\n }\n \n-crate fn collect_local_sources<'tcx>(\n+pub(crate) fn collect_local_sources<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     src_root: &Path,\n     krate: &clean::Crate,\n@@ -231,7 +231,7 @@ impl SourceCollector<'_, '_> {\n /// static HTML tree. Each component in the cleaned path will be passed as an\n /// argument to `f`. The very last component of the path (ie the file name) will\n /// be passed to `f` if `keep_filename` is true, and ignored otherwise.\n-crate fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n+pub(crate) fn clean_path<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F)\n where\n     F: FnMut(&OsStr),\n {\n@@ -253,14 +253,14 @@ where\n     }\n }\n \n-crate enum SourceContext {\n+pub(crate) enum SourceContext {\n     Standalone,\n     Embedded { offset: usize },\n }\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-crate fn print_src(\n+pub(crate) fn print_src(\n     buf: &mut Buffer,\n     s: &str,\n     edition: Edition,"}, {"sha": "75f2b7e3570d5627e4b2d47d6b01a569b4081d5e", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 48, "deletions": 45, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,131 +8,134 @@\n //! directly written to a `Write` handle.\n \n /// The file contents of the main `rustdoc.css` file, responsible for the core layout of the page.\n-crate static RUSTDOC_CSS: &str = include_str!(\"static/css/rustdoc.css\");\n+pub(crate) static RUSTDOC_CSS: &str = include_str!(\"static/css/rustdoc.css\");\n \n /// The file contents of `settings.css`, responsible for the items on the settings page.\n-crate static SETTINGS_CSS: &str = include_str!(\"static/css/settings.css\");\n+pub(crate) static SETTINGS_CSS: &str = include_str!(\"static/css/settings.css\");\n \n /// The file contents of the `noscript.css` file, used in case JS isn't supported or is disabled.\n-crate static NOSCRIPT_CSS: &str = include_str!(\"static/css/noscript.css\");\n+pub(crate) static NOSCRIPT_CSS: &str = include_str!(\"static/css/noscript.css\");\n \n /// The file contents of `normalize.css`, included to even out standard elements between browser\n /// implementations.\n-crate static NORMALIZE_CSS: &str = include_str!(\"static/css/normalize.css\");\n+pub(crate) static NORMALIZE_CSS: &str = include_str!(\"static/css/normalize.css\");\n \n /// The file contents of `main.js`, which contains the core JavaScript used on documentation pages,\n /// including search behavior and docblock folding, among others.\n-crate static MAIN_JS: &str = include_str!(\"static/js/main.js\");\n+pub(crate) static MAIN_JS: &str = include_str!(\"static/js/main.js\");\n \n /// The file contents of `search.js`, which contains the search behavior.\n-crate static SEARCH_JS: &str = include_str!(\"static/js/search.js\");\n+pub(crate) static SEARCH_JS: &str = include_str!(\"static/js/search.js\");\n \n /// The file contents of `settings.js`, which contains the JavaScript used to handle the settings\n /// page.\n-crate static SETTINGS_JS: &str = include_str!(\"static/js/settings.js\");\n+pub(crate) static SETTINGS_JS: &str = include_str!(\"static/js/settings.js\");\n \n /// The file contents of `storage.js`, which contains functionality related to browser Local\n /// Storage, used to store documentation settings.\n-crate static STORAGE_JS: &str = include_str!(\"static/js/storage.js\");\n+pub(crate) static STORAGE_JS: &str = include_str!(\"static/js/storage.js\");\n \n /// The file contents of `scraped-examples.js`, which contains functionality related to the\n /// --scrape-examples flag that inserts automatically-found examples of usages of items.\n-crate static SCRAPE_EXAMPLES_JS: &str = include_str!(\"static/js/scrape-examples.js\");\n+pub(crate) static SCRAPE_EXAMPLES_JS: &str = include_str!(\"static/js/scrape-examples.js\");\n \n-crate static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");\n+pub(crate) static SCRAPE_EXAMPLES_HELP_MD: &str = include_str!(\"static/scrape-examples-help.md\");\n \n /// The file contents of `wheel.svg`, the icon used for the settings button.\n-crate static WHEEL_SVG: &[u8] = include_bytes!(\"static/images/wheel.svg\");\n+pub(crate) static WHEEL_SVG: &[u8] = include_bytes!(\"static/images/wheel.svg\");\n \n /// The file contents of `clipboard.svg`, the icon used for the \"copy path\" button.\n-crate static CLIPBOARD_SVG: &[u8] = include_bytes!(\"static/images/clipboard.svg\");\n+pub(crate) static CLIPBOARD_SVG: &[u8] = include_bytes!(\"static/images/clipboard.svg\");\n \n /// The file contents of `down-arrow.svg`, the icon used for the crate choice combobox.\n-crate static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/images/down-arrow.svg\");\n+pub(crate) static DOWN_ARROW_SVG: &[u8] = include_bytes!(\"static/images/down-arrow.svg\");\n \n /// The file contents of `toggle-minus.svg`, the icon used for opened toggles.\n-crate static TOGGLE_MINUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-minus.svg\");\n+pub(crate) static TOGGLE_MINUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-minus.svg\");\n \n /// The file contents of `toggle-plus.svg`, the icon used for closed toggles.\n-crate static TOGGLE_PLUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-plus.svg\");\n+pub(crate) static TOGGLE_PLUS_PNG: &[u8] = include_bytes!(\"static/images/toggle-plus.svg\");\n \n /// The contents of `COPYRIGHT.txt`, the license listing for files distributed with documentation\n /// output.\n-crate static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n+pub(crate) static COPYRIGHT: &[u8] = include_bytes!(\"static/COPYRIGHT.txt\");\n \n /// The contents of `LICENSE-APACHE.txt`, the text of the Apache License, version 2.0.\n-crate static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n+pub(crate) static LICENSE_APACHE: &[u8] = include_bytes!(\"static/LICENSE-APACHE.txt\");\n \n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n-crate static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n+pub(crate) static LICENSE_MIT: &[u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n /// The contents of `rust-logo.svg`, the default icon of the documentation.\n-crate static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n+pub(crate) static RUST_LOGO_SVG: &[u8] = include_bytes!(\"static/images/rust-logo.svg\");\n \n /// The default documentation favicons (SVG and PNG fallbacks)\n-crate static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n-crate static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");\n-crate static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/images/favicon-32x32.png\");\n+pub(crate) static RUST_FAVICON_SVG: &[u8] = include_bytes!(\"static/images/favicon.svg\");\n+pub(crate) static RUST_FAVICON_PNG_16: &[u8] = include_bytes!(\"static/images/favicon-16x16.png\");\n+pub(crate) static RUST_FAVICON_PNG_32: &[u8] = include_bytes!(\"static/images/favicon-32x32.png\");\n \n /// The built-in themes given to every documentation site.\n-crate mod themes {\n+pub(crate) mod themes {\n     /// The \"light\" theme, selected by default when no setting is available. Used as the basis for\n     /// the `--check-theme` functionality.\n-    crate static LIGHT: &str = include_str!(\"static/css/themes/light.css\");\n+    pub(crate) static LIGHT: &str = include_str!(\"static/css/themes/light.css\");\n \n     /// The \"dark\" theme.\n-    crate static DARK: &str = include_str!(\"static/css/themes/dark.css\");\n+    pub(crate) static DARK: &str = include_str!(\"static/css/themes/dark.css\");\n \n     /// The \"ayu\" theme.\n-    crate static AYU: &str = include_str!(\"static/css/themes/ayu.css\");\n+    pub(crate) static AYU: &str = include_str!(\"static/css/themes/ayu.css\");\n }\n \n /// Files related to the Fira Sans font.\n-crate mod fira_sans {\n+pub(crate) mod fira_sans {\n     /// The file `FiraSans-Regular.woff2`, the Regular variant of the Fira Sans font in woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/FiraSans-Regular.woff2\");\n+    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/FiraSans-Regular.woff2\");\n \n     /// The file `FiraSans-Medium.woff2`, the Medium variant of the Fira Sans font in woff2.\n-    crate static MEDIUM: &[u8] = include_bytes!(\"static/fonts/FiraSans-Medium.woff2\");\n+    pub(crate) static MEDIUM: &[u8] = include_bytes!(\"static/fonts/FiraSans-Medium.woff2\");\n \n     /// The file `FiraSans-LICENSE.txt`, the license text for the Fira Sans font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/FiraSans-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/FiraSans-LICENSE.txt\");\n }\n \n /// Files related to the Source Serif 4 font.\n-crate mod source_serif_4 {\n+pub(crate) mod source_serif_4 {\n     /// The file `SourceSerif4-Regular.ttf.woff2`, the Regular variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Regular.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] =\n+        include_bytes!(\"static/fonts/SourceSerif4-Regular.ttf.woff2\");\n \n     /// The file `SourceSerif4-Bold.ttf.woff2`, the Bold variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static BOLD: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Bold.ttf.woff2\");\n+    pub(crate) static BOLD: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-Bold.ttf.woff2\");\n \n     /// The file `SourceSerif4-It.ttf.woff2`, the Italic variant of the Source Serif 4 font in\n     /// woff2.\n-    crate static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-It.ttf.woff2\");\n+    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-It.ttf.woff2\");\n \n     /// The file `SourceSerif4-LICENSE.txt`, the license text for the Source Serif 4 font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-LICENSE.md\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceSerif4-LICENSE.md\");\n }\n \n /// Files related to the Source Code Pro font.\n-crate mod source_code_pro {\n+pub(crate) mod source_code_pro {\n     /// The file `SourceCodePro-Regular.ttf.woff2`, the Regular variant of the Source Code Pro font\n     /// in woff2.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-Regular.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] =\n+        include_bytes!(\"static/fonts/SourceCodePro-Regular.ttf.woff2\");\n \n     /// The file `SourceCodePro-Semibold.ttf.woff2`, the Semibold variant of the Source Code Pro\n     /// font in woff2.\n-    crate static SEMIBOLD: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-Semibold.ttf.woff2\");\n+    pub(crate) static SEMIBOLD: &[u8] =\n+        include_bytes!(\"static/fonts/SourceCodePro-Semibold.ttf.woff2\");\n \n     /// The file `SourceCodePro-It.ttf.woff2`, the Italic variant of the Source Code Pro font in\n     /// woff2.\n-    crate static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-It.ttf.woff2\");\n+    pub(crate) static ITALIC: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-It.ttf.woff2\");\n \n     /// The file `SourceCodePro-LICENSE.txt`, the license text of the Source Code Pro font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/SourceCodePro-LICENSE.txt\");\n }\n \n /// Files related to the Nanum Barun Gothic font.\n@@ -150,16 +153,16 @@ crate mod source_code_pro {\n /// --unicodes=U+AC00-D7AF,U+1100-11FF,U+3130-318F,U+A960-A97F,U+D7B0-D7FF \\\n /// --output-file=NanumBarunGothic.ttf.woff2 --flavor=woff2\n /// ```\n-crate mod nanum_barun_gothic {\n+pub(crate) mod nanum_barun_gothic {\n     /// The file `NanumBarunGothic.ttf.woff2`, the Regular variant of the Nanum Barun Gothic font.\n-    crate static REGULAR: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic.ttf.woff2\");\n+    pub(crate) static REGULAR: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic.ttf.woff2\");\n \n     /// The file `NanumBarunGothic-LICENSE.txt`, the license text of the Nanum Barun Gothic font.\n-    crate static LICENSE: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic-LICENSE.txt\");\n+    pub(crate) static LICENSE: &[u8] = include_bytes!(\"static/fonts/NanumBarunGothic-LICENSE.txt\");\n }\n \n /// Files related to the sidebar in rustdoc sources.\n-crate mod sidebar {\n+pub(crate) mod sidebar {\n     /// File script to handle sidebar.\n-    crate static SOURCE_SCRIPT: &str = include_str!(\"static/js/source-script.js\");\n+    pub(crate) static SOURCE_SCRIPT: &str = include_str!(\"static/js/source-script.js\");\n }"}, {"sha": "07e33052aa7c3540292e9da520181c16c0401b4b", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2,7 +2,7 @@\n \n /// A (recursive) table of contents\n #[derive(Debug, PartialEq)]\n-crate struct Toc {\n+pub(crate) struct Toc {\n     /// The levels are strictly decreasing, i.e.\n     ///\n     /// `entries[0].level >= entries[1].level >= ...`\n@@ -26,7 +26,7 @@ impl Toc {\n }\n \n #[derive(Debug, PartialEq)]\n-crate struct TocEntry {\n+pub(crate) struct TocEntry {\n     level: u32,\n     sec_number: String,\n     name: String,\n@@ -36,7 +36,7 @@ crate struct TocEntry {\n \n /// Progressive construction of a table of contents.\n #[derive(PartialEq)]\n-crate struct TocBuilder {\n+pub(crate) struct TocBuilder {\n     top_level: Toc,\n     /// The current hierarchy of parent headings, the levels are\n     /// strictly increasing (i.e., `chain[0].level < chain[1].level <\n@@ -50,12 +50,12 @@ crate struct TocBuilder {\n }\n \n impl TocBuilder {\n-    crate fn new() -> TocBuilder {\n+    pub(crate) fn new() -> TocBuilder {\n         TocBuilder { top_level: Toc { entries: Vec::new() }, chain: Vec::new() }\n     }\n \n     /// Converts into a true `Toc` struct.\n-    crate fn into_toc(mut self) -> Toc {\n+    pub(crate) fn into_toc(mut self) -> Toc {\n         // we know all levels are >= 1.\n         self.fold_until(0);\n         self.top_level\n@@ -115,7 +115,7 @@ impl TocBuilder {\n     /// Push a level `level` heading into the appropriate place in the\n     /// hierarchy, returning a string containing the section number in\n     /// `<num>.<num>.<num>` format.\n-    crate fn push(&mut self, level: u32, name: String, id: String) -> &str {\n+    pub(crate) fn push(&mut self, level: u32, name: String, id: String) -> &str {\n         assert!(level >= 1);\n \n         // collapse all previous sections into their parents until we\n@@ -177,7 +177,7 @@ impl Toc {\n         }\n         v.push_str(\"</ul>\");\n     }\n-    crate fn print(&self) -> String {\n+    pub(crate) fn print(&self) -> String {\n         let mut v = String::new();\n         self.print_inner(&mut v);\n         v"}, {"sha": "1e6af6af63cc469154b6a6c825b152eec594cf49", "filename": "src/librustdoc/html/url_parts_builder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,14 +8,14 @@ use rustc_span::Symbol;\n /// This type is a wrapper around the final `String` buffer,\n /// but its API is like that of a `Vec` of URL components.\n #[derive(Debug)]\n-crate struct UrlPartsBuilder {\n+pub(crate) struct UrlPartsBuilder {\n     buf: String,\n }\n \n impl UrlPartsBuilder {\n     /// Create an empty buffer.\n     #[allow(dead_code)]\n-    crate fn new() -> Self {\n+    pub(crate) fn new() -> Self {\n         Self { buf: String::new() }\n     }\n \n@@ -43,7 +43,7 @@ impl UrlPartsBuilder {\n     /// builder.push_front(\"nightly\");\n     /// assert_eq!(builder.finish(), \"nightly/core/str\");\n     /// ```\n-    crate fn singleton(part: &str) -> Self {\n+    pub(crate) fn singleton(part: &str) -> Self {\n         Self { buf: part.to_owned() }\n     }\n \n@@ -60,7 +60,7 @@ impl UrlPartsBuilder {\n     /// builder.push(\"struct.Bytes.html\");\n     /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push(&mut self, part: &str) {\n+    pub(crate) fn push(&mut self, part: &str) {\n         if !self.buf.is_empty() {\n             self.buf.push('/');\n         }\n@@ -80,7 +80,7 @@ impl UrlPartsBuilder {\n     /// builder.push_fmt(format_args!(\"{}.{}.html\", \"struct\", \"Bytes\"));\n     /// assert_eq!(builder.finish(), \"core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n+    pub(crate) fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n         if !self.buf.is_empty() {\n             self.buf.push('/');\n         }\n@@ -101,7 +101,7 @@ impl UrlPartsBuilder {\n     /// builder.push(\"struct.Bytes.html\");\n     /// assert_eq!(builder.finish(), \"nightly/core/str/struct.Bytes.html\");\n     /// ```\n-    crate fn push_front(&mut self, part: &str) {\n+    pub(crate) fn push_front(&mut self, part: &str) {\n         let is_empty = self.buf.is_empty();\n         self.buf.reserve(part.len() + if !is_empty { 1 } else { 0 });\n         self.buf.insert_str(0, part);\n@@ -111,7 +111,7 @@ impl UrlPartsBuilder {\n     }\n \n     /// Get the final `String` buffer.\n-    crate fn finish(self) -> String {\n+    pub(crate) fn finish(self) -> String {\n         self.buf\n     }\n }\n@@ -134,7 +134,7 @@ const AVG_PART_LENGTH: usize = 8;\n ///\n /// **Note:** This is only to be used with, e.g., [`String::with_capacity()`];\n /// the return value is just a rough estimate.\n-crate const fn estimate_item_path_byte_length(segment_count: usize) -> usize {\n+pub(crate) const fn estimate_item_path_byte_length(segment_count: usize) -> usize {\n     AVG_PART_LENGTH * segment_count\n }\n "}, {"sha": "6f6f7e375a425a0e01da9aae67f6f0fdda340fae", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -91,11 +91,11 @@ impl JsonRenderer<'_> {\n     }\n }\n \n-crate trait FromWithTcx<T> {\n+pub(crate) trait FromWithTcx<T> {\n     fn from_tcx(f: T, tcx: TyCtxt<'_>) -> Self;\n }\n \n-crate trait IntoWithTcx<T> {\n+pub(crate) trait IntoWithTcx<T> {\n     fn into_tcx(self, tcx: TyCtxt<'_>) -> T;\n }\n \n@@ -108,7 +108,7 @@ where\n     }\n }\n \n-crate fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n+pub(crate) fn from_deprecation(deprecation: rustc_attr::Deprecation) -> Deprecation {\n     #[rustfmt::skip]\n     let rustc_attr::Deprecation { since, note, is_since_rustc_version: _, suggestion: _ } = deprecation;\n     Deprecation { since: since.map(|s| s.to_string()), note: note.map(|s| s.to_string()) }\n@@ -173,7 +173,7 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-crate fn from_item_id(item_id: ItemId) -> Id {\n+pub(crate) fn from_item_id(item_id: ItemId) -> Id {\n     struct DisplayDefId(DefId);\n \n     impl fmt::Display for DisplayDefId {\n@@ -272,15 +272,15 @@ impl FromWithTcx<clean::Union> for Union {\n     }\n }\n \n-crate fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n+pub(crate) fn from_ctor_kind(struct_type: CtorKind) -> StructType {\n     match struct_type {\n         CtorKind::Fictive => StructType::Plain,\n         CtorKind::Fn => StructType::Tuple,\n         CtorKind::Const => StructType::Unit,\n     }\n }\n \n-crate fn from_fn_header(header: &rustc_hir::FnHeader) -> Header {\n+pub(crate) fn from_fn_header(header: &rustc_hir::FnHeader) -> Header {\n     Header {\n         async_: header.is_async(),\n         const_: header.is_const(),\n@@ -390,7 +390,9 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n     }\n }\n \n-crate fn from_trait_bound_modifier(modifier: rustc_hir::TraitBoundModifier) -> TraitBoundModifier {\n+pub(crate) fn from_trait_bound_modifier(\n+    modifier: rustc_hir::TraitBoundModifier,\n+) -> TraitBoundModifier {\n     use rustc_hir::TraitBoundModifier::*;\n     match modifier {\n         None => TraitBoundModifier::None,\n@@ -554,7 +556,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n     }\n }\n \n-crate fn from_function(\n+pub(crate) fn from_function(\n     function: clean::Function,\n     header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n@@ -567,7 +569,7 @@ crate fn from_function(\n     }\n }\n \n-crate fn from_function_method(\n+pub(crate) fn from_function_method(\n     function: clean::Function,\n     has_body: bool,\n     header: rustc_hir::FnHeader,\n@@ -658,7 +660,7 @@ impl FromWithTcx<clean::ProcMacro> for ProcMacro {\n     }\n }\n \n-crate fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n+pub(crate) fn from_macro_kind(kind: rustc_span::hygiene::MacroKind) -> MacroKind {\n     use rustc_span::hygiene::MacroKind::*;\n     match kind {\n         Bang => MacroKind::Bang,"}, {"sha": "08f61056d853f7952ae53f08ab02c3f8b85d3b49", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -29,7 +29,7 @@ use crate::json::conversions::{from_item_id, IntoWithTcx};\n use crate::{clean, try_err};\n \n #[derive(Clone)]\n-crate struct JsonRenderer<'tcx> {\n+pub(crate) struct JsonRenderer<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob."}, {"sha": "61acf2de90d481f5631c2160b4d73df37004491d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -13,7 +13,6 @@\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]\n-#![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![feature(once_cell)]\n #![feature(type_ascription)]\n@@ -121,7 +120,7 @@ mod formats;\n // used by the error-index generator, so it needs to be public\n pub mod html;\n mod json;\n-crate mod lint;\n+pub(crate) mod lint;\n mod markdown;\n mod passes;\n mod scrape_examples;"}, {"sha": "08a1a868521f428cde748875dd5f3e025ce22950", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -169,7 +169,7 @@ declare_rustdoc_lint! {\n    \"codeblock could not be parsed as valid Rust or is empty\"\n }\n \n-crate static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n+pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     vec![\n         BROKEN_INTRA_DOC_LINKS,\n         PRIVATE_INTRA_DOC_LINKS,\n@@ -183,7 +183,7 @@ crate static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     ]\n });\n \n-crate fn register_lints(_sess: &Session, lint_store: &mut LintStore) {\n+pub(crate) fn register_lints(_sess: &Session, lint_store: &mut LintStore) {\n     lint_store.register_lints(&**RUSTDOC_LINTS);\n     lint_store.register_group(\n         true,"}, {"sha": "0b557ef244e94003a5b38292d8314a996bb5e7d4", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -36,7 +36,7 @@ fn extract_leading_metadata(s: &str) -> (Vec<&str>, &str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-crate fn render<P: AsRef<Path>>(\n+pub(crate) fn render<P: AsRef<Path>>(\n     input: P,\n     options: RenderOptions,\n     edition: Edition,\n@@ -127,7 +127,7 @@ crate fn render<P: AsRef<Path>>(\n }\n \n /// Runs any tests/code examples in the markdown file `input`.\n-crate fn test(options: Options) -> Result<(), String> {\n+pub(crate) fn test(options: Options) -> Result<(), String> {\n     let input_str = read_to_string(&options.input)\n         .map_err(|err| format!(\"{}: {}\", options.input.display(), err))?;\n     let mut opts = GlobalTestOptions::default();"}, {"sha": "e9e810658ef85c5ea7e38d932d674781fcc4d1ab", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,7 +12,7 @@ use rustc_errors::Applicability;\n use std::lazy::SyncLazy;\n use std::mem;\n \n-crate const CHECK_BARE_URLS: Pass = Pass {\n+pub(crate) const CHECK_BARE_URLS: Pass = Pass {\n     name: \"check-bare-urls\",\n     run: check_bare_urls,\n     description: \"detects URLs that are not hyperlinks\",\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> BareUrlsLinter<'a, 'tcx> {\n     }\n }\n \n-crate fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_bare_urls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     BareUrlsLinter { cx }.visit_crate(&krate);\n     krate\n }"}, {"sha": "3981d49a8a904f74148b97111505991778f9402b", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -16,7 +16,7 @@ use serde::Serialize;\n use std::collections::BTreeMap;\n use std::ops;\n \n-crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n+pub(crate) const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n     run: calculate_doc_coverage,\n     description: \"counts the number of items with and without documentation\","}, {"sha": "8a50938f82b0a66f6f4cbdb3ca858b55c5cacd86", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -14,13 +14,16 @@ use crate::html::markdown::{self, RustCodeBlock};\n use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n-crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n+pub(crate) const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n     run: check_code_block_syntax,\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-crate fn check_code_block_syntax(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn check_code_block_syntax(\n+    krate: clean::Crate,\n+    cx: &mut DocContext<'_>,\n+) -> clean::Crate {\n     SyntaxChecker { cx }.visit_crate(&krate);\n     krate\n }"}, {"sha": "0fb0c7dbdd7ca46c705035a3f1e6e0daaa8b0d97", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::lint::LintLevelSource;\n use rustc_session::lint;\n use rustc_span::symbol::sym;\n \n-crate const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n+pub(crate) const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n     name: \"check_doc_test_visibility\",\n     run: check_doc_test_visibility,\n     description: \"run various visibility-related lints on doctests\",\n@@ -27,7 +27,7 @@ struct DocTestVisibilityLinter<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n }\n \n-crate fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_doc_test_visibility(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     let mut coll = DocTestVisibilityLinter { cx };\n     coll.visit_crate(&krate);\n     krate\n@@ -55,7 +55,7 @@ impl crate::doctest::Tester for Tests {\n     }\n }\n \n-crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n+pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> bool {\n     if !cx.cache.access_levels.is_public(item.item_id.expect_def_id())\n         || matches!(\n             *item.kind,\n@@ -106,7 +106,7 @@ crate fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -> boo\n     level != lint::Level::Allow || matches!(source, LintLevelSource::Default)\n }\n \n-crate fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n+pub(crate) fn look_for_tests<'tcx>(cx: &DocContext<'tcx>, dox: &str, item: &Item) {\n     let Some(hir_id) = DocContext::as_local_hir_id(cx.tcx, item.item_id)\n     else {\n         // If non-local, no need to check anything."}, {"sha": "ea0f5102539f6ccf780eda2ec5a88362d69d71b3", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -33,9 +33,9 @@ use crate::passes::Pass;\n use crate::visit::DocVisitor;\n \n mod early;\n-crate use early::early_resolve_intra_doc_links;\n+pub(crate) use early::early_resolve_intra_doc_links;\n \n-crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n+pub(crate) const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"resolves intra-doc links\",\n@@ -219,14 +219,14 @@ enum MalformedGenerics {\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-crate enum UrlFragment {\n+pub(crate) enum UrlFragment {\n     Item(ItemFragment),\n     UserWritten(String),\n }\n \n impl UrlFragment {\n     /// Render the fragment, including the leading `#`.\n-    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         match self {\n             UrlFragment::Item(frag) => frag.render(s, tcx),\n             UrlFragment::UserWritten(raw) => write!(s, \"#{}\", raw),\n@@ -235,10 +235,10 @@ impl UrlFragment {\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-crate struct ItemFragment(FragmentKind, DefId);\n+pub(crate) struct ItemFragment(FragmentKind, DefId);\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-crate enum FragmentKind {\n+pub(crate) enum FragmentKind {\n     Method,\n     TyMethod,\n     AssociatedConstant,\n@@ -276,7 +276,7 @@ impl FragmentKind {\n \n impl ItemFragment {\n     /// Render the fragment, including the leading `#`.\n-    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+    pub(crate) fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n         write!(s, \"#\")?;\n         match *self {\n             ItemFragment(kind, def_id) => {\n@@ -954,7 +954,10 @@ struct PreprocessingInfo {\n }\n \n // Not a typedef to avoid leaking several private structures from this module.\n-crate struct PreprocessedMarkdownLink(Result<PreprocessingInfo, PreprocessingError>, MarkdownLink);\n+pub(crate) struct PreprocessedMarkdownLink(\n+    Result<PreprocessingInfo, PreprocessingError>,\n+    MarkdownLink,\n+);\n \n /// Returns:\n /// - `None` if the link should be ignored."}, {"sha": "a38c44bc888556d8daaf382c4e8c0367fd4e11e9", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,7 +21,7 @@ use rustc_span::{Symbol, SyntaxContext};\n use std::collections::hash_map::Entry;\n use std::mem;\n \n-crate fn early_resolve_intra_doc_links(\n+pub(crate) fn early_resolve_intra_doc_links(\n     resolver: &mut Resolver<'_>,\n     sess: &Session,\n     krate: &ast::Crate,"}, {"sha": "aa7028247bed49d739712b5a4b74b0ad2606a35a", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -12,13 +12,13 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n-crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n+pub(crate) const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n     run: collect_trait_impls,\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     let synth_impls = cx.sess().time(\"collect_synthetic_impls\", || {\n         let mut synth = SyntheticImplCollector { cx, impls: Vec::new() };\n         synth.visit_crate(&krate);"}, {"sha": "3012db0cad66206939e48007c0f64e55c444484b", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -11,7 +11,7 @@ use std::iter::Peekable;\n use std::ops::Range;\n use std::str::CharIndices;\n \n-crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n+pub(crate) const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n     name: \"check-invalid-html-tags\",\n     run: check_invalid_html_tags,\n     description: \"detects invalid HTML tags in doc comments\",\n@@ -21,7 +21,7 @@ struct InvalidHtmlTagsLinter<'a, 'tcx> {\n     cx: &'a mut DocContext<'tcx>,\n }\n \n-crate fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if cx.tcx.sess.is_nightly_build() {\n         let mut coll = InvalidHtmlTagsLinter { cx };\n         coll.visit_crate(&krate);"}, {"sha": "f81b38ea39574f1c08ccad79ac4c550d85222d8e", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -10,61 +10,61 @@ use crate::clean::{self, DocFragmentKind};\n use crate::core::DocContext;\n \n mod stripper;\n-crate use stripper::*;\n+pub(crate) use stripper::*;\n \n mod bare_urls;\n-crate use self::bare_urls::CHECK_BARE_URLS;\n+pub(crate) use self::bare_urls::CHECK_BARE_URLS;\n \n mod strip_hidden;\n-crate use self::strip_hidden::STRIP_HIDDEN;\n+pub(crate) use self::strip_hidden::STRIP_HIDDEN;\n \n mod strip_private;\n-crate use self::strip_private::STRIP_PRIVATE;\n+pub(crate) use self::strip_private::STRIP_PRIVATE;\n \n mod strip_priv_imports;\n-crate use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n+pub(crate) use self::strip_priv_imports::STRIP_PRIV_IMPORTS;\n \n mod propagate_doc_cfg;\n-crate use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n+pub(crate) use self::propagate_doc_cfg::PROPAGATE_DOC_CFG;\n \n-crate mod collect_intra_doc_links;\n-crate use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n+pub(crate) mod collect_intra_doc_links;\n+pub(crate) use self::collect_intra_doc_links::COLLECT_INTRA_DOC_LINKS;\n \n mod check_doc_test_visibility;\n-crate use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n+pub(crate) use self::check_doc_test_visibility::CHECK_DOC_TEST_VISIBILITY;\n \n mod collect_trait_impls;\n-crate use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n+pub(crate) use self::collect_trait_impls::COLLECT_TRAIT_IMPLS;\n \n mod check_code_block_syntax;\n-crate use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n+pub(crate) use self::check_code_block_syntax::CHECK_CODE_BLOCK_SYNTAX;\n \n mod calculate_doc_coverage;\n-crate use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n+pub(crate) use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n \n mod html_tags;\n-crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n+pub(crate) use self::html_tags::CHECK_INVALID_HTML_TAGS;\n \n /// A single pass over the cleaned documentation.\n ///\n /// Runs in the compiler context, so it has access to types and traits and the like.\n #[derive(Copy, Clone)]\n-crate struct Pass {\n-    crate name: &'static str,\n-    crate run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n-    crate description: &'static str,\n+pub(crate) struct Pass {\n+    pub(crate) name: &'static str,\n+    pub(crate) run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n+    pub(crate) description: &'static str,\n }\n \n /// In a list of passes, a pass that may or may not need to be run depending on options.\n #[derive(Copy, Clone)]\n-crate struct ConditionalPass {\n-    crate pass: Pass,\n-    crate condition: Condition,\n+pub(crate) struct ConditionalPass {\n+    pub(crate) pass: Pass,\n+    pub(crate) condition: Condition,\n }\n \n /// How to decide whether to run a conditional pass.\n #[derive(Copy, Clone)]\n-crate enum Condition {\n+pub(crate) enum Condition {\n     Always,\n     /// When `--document-private-items` is passed.\n     WhenDocumentPrivate,\n@@ -75,7 +75,7 @@ crate enum Condition {\n }\n \n /// The full list of passes.\n-crate const PASSES: &[Pass] = &[\n+pub(crate) const PASSES: &[Pass] = &[\n     CHECK_DOC_TEST_VISIBILITY,\n     STRIP_HIDDEN,\n     STRIP_PRIVATE,\n@@ -90,7 +90,7 @@ crate const PASSES: &[Pass] = &[\n ];\n \n /// The list of passes run by default.\n-crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n+pub(crate) const DEFAULT_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n     ConditionalPass::always(CHECK_DOC_TEST_VISIBILITY),\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n@@ -104,29 +104,29 @@ crate const DEFAULT_PASSES: &[ConditionalPass] = &[\n ];\n \n /// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-crate const COVERAGE_PASSES: &[ConditionalPass] = &[\n+pub(crate) const COVERAGE_PASSES: &[ConditionalPass] = &[\n     ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n     ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n     ConditionalPass::always(CALCULATE_DOC_COVERAGE),\n ];\n \n impl ConditionalPass {\n-    crate const fn always(pass: Pass) -> Self {\n+    pub(crate) const fn always(pass: Pass) -> Self {\n         Self::new(pass, Always)\n     }\n \n-    crate const fn new(pass: Pass, condition: Condition) -> Self {\n+    pub(crate) const fn new(pass: Pass, condition: Condition) -> Self {\n         ConditionalPass { pass, condition }\n     }\n }\n \n /// Returns the given default set of passes.\n-crate fn defaults(show_coverage: bool) -> &'static [ConditionalPass] {\n+pub(crate) fn defaults(show_coverage: bool) -> &'static [ConditionalPass] {\n     if show_coverage { COVERAGE_PASSES } else { DEFAULT_PASSES }\n }\n \n /// Returns a span encompassing all the given attributes.\n-crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n+pub(crate) fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n     if attrs.doc_strings.is_empty() {\n         return None;\n     }\n@@ -143,7 +143,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n /// This method will return `None` if we cannot construct a span from the source map or if the\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n-crate fn source_span_for_markdown_range(\n+pub(crate) fn source_span_for_markdown_range(\n     tcx: TyCtxt<'_>,\n     markdown: &str,\n     md_range: &Range<usize>,"}, {"sha": "0c5d836551823ca322cd5b99f8e38730c1b92ffe", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,13 +7,13 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n-crate const PROPAGATE_DOC_CFG: Pass = Pass {\n+pub(crate) const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n     run: propagate_doc_cfg,\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-crate fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n+pub(crate) fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "ab5526e0612b7b12bb37e5b62c076bbd382a8ed8", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,14 +8,14 @@ use crate::core::DocContext;\n use crate::fold::{strip_item, DocFolder};\n use crate::passes::{ImplStripper, Pass};\n \n-crate const STRIP_HIDDEN: Pass = Pass {\n+pub(crate) const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n     run: strip_hidden,\n     description: \"strips all `#[doc(hidden)]` items from the output\",\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = ItemIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "85be8fa109a7e078fb71394b43e5e5ec42158798", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,12 +5,12 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImportStripper, Pass};\n \n-crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n+pub(crate) const STRIP_PRIV_IMPORTS: Pass = Pass {\n     name: \"strip-priv-imports\",\n     run: strip_priv_imports,\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-crate fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "6c94912bc536811821154b043f1169d28e90c7d6", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -5,7 +5,7 @@ use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n \n-crate const STRIP_PRIVATE: Pass = Pass {\n+pub(crate) const STRIP_PRIVATE: Pass = Pass {\n     name: \"strip-private\",\n     run: strip_private,\n     description: \"strips all private items from a crate which cannot be seen externally, \\\n@@ -14,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n+pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = ItemIdSet::default();\n "}, {"sha": "d5db919dc4b2abee4a14f35771daf64938051219", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -7,10 +7,10 @@ use crate::clean::{self, Item, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n \n-crate struct Stripper<'a> {\n-    crate retained: &'a mut ItemIdSet,\n-    crate access_levels: &'a AccessLevels<DefId>,\n-    crate update_retained: bool,\n+pub(crate) struct Stripper<'a> {\n+    pub(crate) retained: &'a mut ItemIdSet,\n+    pub(crate) access_levels: &'a AccessLevels<DefId>,\n+    pub(crate) update_retained: bool,\n }\n \n impl<'a> DocFolder for Stripper<'a> {\n@@ -116,9 +116,9 @@ impl<'a> DocFolder for Stripper<'a> {\n }\n \n /// This stripper discards all impls which reference stripped items\n-crate struct ImplStripper<'a> {\n-    crate retained: &'a ItemIdSet,\n-    crate cache: &'a Cache,\n+pub(crate) struct ImplStripper<'a> {\n+    pub(crate) retained: &'a ItemIdSet,\n+    pub(crate) cache: &'a Cache,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -159,7 +159,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n }\n \n /// This stripper discards all private import statements (`use`, `extern crate`)\n-crate struct ImportStripper;\n+pub(crate) struct ImportStripper;\n \n impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {"}, {"sha": "0fa492af1ad0adfb471377f28c7fa6e6748d6437", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -31,14 +31,14 @@ use std::fs;\n use std::path::PathBuf;\n \n #[derive(Debug, Clone)]\n-crate struct ScrapeExamplesOptions {\n+pub(crate) struct ScrapeExamplesOptions {\n     output_path: PathBuf,\n     target_crates: Vec<String>,\n-    crate scrape_tests: bool,\n+    pub(crate) scrape_tests: bool,\n }\n \n impl ScrapeExamplesOptions {\n-    crate fn new(\n+    pub(crate) fn new(\n         matches: &getopts::Matches,\n         diag: &rustc_errors::Handler,\n     ) -> Result<Option<Self>, i32> {\n@@ -65,9 +65,9 @@ impl ScrapeExamplesOptions {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct SyntaxRange {\n-    crate byte_span: (u32, u32),\n-    crate line_span: (usize, usize),\n+pub(crate) struct SyntaxRange {\n+    pub(crate) byte_span: (u32, u32),\n+    pub(crate) line_span: (usize, usize),\n }\n \n impl SyntaxRange {\n@@ -83,10 +83,10 @@ impl SyntaxRange {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct CallLocation {\n-    crate call_expr: SyntaxRange,\n-    crate call_ident: SyntaxRange,\n-    crate enclosing_item: SyntaxRange,\n+pub(crate) struct CallLocation {\n+    pub(crate) call_expr: SyntaxRange,\n+    pub(crate) call_ident: SyntaxRange,\n+    pub(crate) enclosing_item: SyntaxRange,\n }\n \n impl CallLocation {\n@@ -105,15 +105,15 @@ impl CallLocation {\n }\n \n #[derive(Encodable, Decodable, Debug, Clone)]\n-crate struct CallData {\n-    crate locations: Vec<CallLocation>,\n-    crate url: String,\n-    crate display_name: String,\n-    crate edition: Edition,\n+pub(crate) struct CallData {\n+    pub(crate) locations: Vec<CallLocation>,\n+    pub(crate) url: String,\n+    pub(crate) display_name: String,\n+    pub(crate) edition: Edition,\n }\n \n-crate type FnCallLocations = FxHashMap<PathBuf, CallData>;\n-crate type AllCallLocations = FxHashMap<DefPathHash, FnCallLocations>;\n+pub(crate) type FnCallLocations = FxHashMap<PathBuf, CallData>;\n+pub(crate) type AllCallLocations = FxHashMap<DefPathHash, FnCallLocations>;\n \n /// Visitor for traversing a crate and finding instances of function calls.\n struct FindCalls<'a, 'tcx> {\n@@ -270,7 +270,7 @@ where\n     }\n }\n \n-crate fn run(\n+pub(crate) fn run(\n     krate: clean::Crate,\n     mut renderopts: config::RenderOptions,\n     cache: formats::cache::Cache,\n@@ -328,7 +328,7 @@ crate fn run(\n }\n \n // Note: the Handler must be passed in explicitly because sess isn't available while parsing options\n-crate fn load_call_locations(\n+pub(crate) fn load_call_locations(\n     with_examples: Vec<String>,\n     diag: &rustc_errors::Handler,\n ) -> Result<AllCallLocations, i32> {"}, {"sha": "20258c3b1dc1c67d01c57e7f17a0c13f8fec7157", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -9,9 +9,9 @@ use rustc_errors::Handler;\n mod tests;\n \n #[derive(Debug, Clone, Eq)]\n-crate struct CssPath {\n-    crate name: String,\n-    crate children: FxHashSet<CssPath>,\n+pub(crate) struct CssPath {\n+    pub(crate) name: String,\n+    pub(crate) children: FxHashSet<CssPath>,\n }\n \n // This PartialEq implementation IS NOT COMMUTATIVE!!!\n@@ -214,7 +214,7 @@ fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {\n     paths.iter().cloned().collect()\n }\n \n-crate fn load_css_paths(v: &[u8]) -> CssPath {\n+pub(crate) fn load_css_paths(v: &[u8]) -> CssPath {\n     let events = load_css_events(v);\n     let mut pos = 0;\n \n@@ -223,7 +223,7 @@ crate fn load_css_paths(v: &[u8]) -> CssPath {\n     parent\n }\n \n-crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n+pub(crate) fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>) {\n     if against.name == other.name {\n         for child in &against.children {\n             let mut found = false;\n@@ -250,7 +250,7 @@ crate fn get_differences(against: &CssPath, other: &CssPath, v: &mut Vec<String>\n     }\n }\n \n-crate fn test_theme_against<P: AsRef<Path>>(\n+pub(crate) fn test_theme_against<P: AsRef<Path>>(\n     f: &P,\n     against: &CssPath,\n     diag: &Handler,"}, {"sha": "fa8be9a97c5a3df39099234e8e5d6b75f0834f03", "filename": "src/librustdoc/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,6 +1,6 @@\n use crate::clean::*;\n \n-crate trait DocVisitor: Sized {\n+pub(crate) trait DocVisitor: Sized {\n     fn visit_item(&mut self, item: &Item) {\n         self.visit_item_recur(item)\n     }"}, {"sha": "519ace7b89a3009222e6a945de34908c304a2157", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -21,22 +21,22 @@ use crate::core;\n /// This module is used to store stuff from Rust's AST in a more convenient\n /// manner (and with prettier names) before cleaning.\n #[derive(Debug)]\n-crate struct Module<'hir> {\n-    crate name: Symbol,\n-    crate where_inner: Span,\n-    crate mods: Vec<Module<'hir>>,\n-    crate id: hir::HirId,\n+pub(crate) struct Module<'hir> {\n+    pub(crate) name: Symbol,\n+    pub(crate) where_inner: Span,\n+    pub(crate) mods: Vec<Module<'hir>>,\n+    pub(crate) id: hir::HirId,\n     // (item, renamed)\n-    crate items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n-    crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n+    pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'_> {\n-    crate fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n+    pub(crate) fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n         Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n     }\n \n-    crate fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n+    pub(crate) fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.hir().span(self.id)\n     }\n }\n@@ -48,7 +48,7 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-crate fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n     while let Some(id) = tcx.hir().get_enclosing_scope(node) {\n         node = id;\n         if tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n@@ -61,7 +61,7 @@ crate fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n-crate struct RustdocVisitor<'a, 'tcx> {\n+pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<hir::HirId>,\n     inlining: bool,\n@@ -71,7 +71,7 @@ crate struct RustdocVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    crate fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n+    pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(hir::CRATE_HIR_ID);\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         self.exact_paths.entry(did).or_insert_with(|| def_id_to_path(tcx, did));\n     }\n \n-    crate fn visit(mut self) -> Module<'tcx> {\n+    pub(crate) fn visit(mut self) -> Module<'tcx> {\n         let mut top_level_module = self.visit_mod_contents(\n             hir::CRATE_HIR_ID,\n             self.cx.tcx.hir().root_module(),"}, {"sha": "f01ec38665c015e8fd65fe3e7d825ace57168029", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::TyCtxt;\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-crate struct LibEmbargoVisitor<'a, 'tcx> {\n+pub(crate) struct LibEmbargoVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: &'a mut AccessLevels<DefId>,\n@@ -19,7 +19,7 @@ crate struct LibEmbargoVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n-    crate fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n+    pub(crate) fn new(cx: &'a mut crate::core::DocContext<'tcx>) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             tcx: cx.tcx,\n             access_levels: &mut cx.cache.access_levels,\n@@ -28,7 +28,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    crate fn visit_lib(&mut self, cnum: CrateNum) {\n+    pub(crate) fn visit_lib(&mut self, cnum: CrateNum) {\n         let did = cnum.as_def_id();\n         self.update(did, Some(AccessLevel::Public));\n         self.visit_mod(did);\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    crate fn visit_mod(&mut self, def_id: DefId) {\n+    pub(crate) fn visit_mod(&mut self, def_id: DefId) {\n         if !self.visited_mods.insert(def_id) {\n             return;\n         }"}, {"sha": "4099b54f0815209706ddcf6750221c3e17df23da", "filename": "src/test/rustdoc/visibility.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Frustdoc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Frustdoc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fvisibility.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,15 +1,13 @@\n // compile-flags: --document-private-items\n \n-#![feature(crate_visibility_modifier)]\n-\n #![crate_name = \"foo\"]\n \n // @!has 'foo/index.html' '//a[@href=\"struct.FooPublic.html\"]/..' 'FooPublic \ud83d\udd12'\n // @has 'foo/struct.FooPublic.html' '//pre' 'pub struct FooPublic'\n pub struct FooPublic;\n // @has 'foo/index.html' '//a[@href=\"struct.FooJustCrate.html\"]/..' 'FooJustCrate \ud83d\udd12'\n // @has 'foo/struct.FooJustCrate.html' '//pre' 'pub(crate) struct FooJustCrate'\n-crate struct FooJustCrate;\n+pub(crate) struct FooJustCrate;\n // @has 'foo/index.html' '//a[@href=\"struct.FooPubCrate.html\"]/..' 'FooPubCrate \ud83d\udd12'\n // @has 'foo/struct.FooPubCrate.html' '//pre' 'pub(crate) struct FooPubCrate'\n pub(crate) struct FooPubCrate;"}, {"sha": "871dde91a3e6b9267626eafd09e60409fdf367b9", "filename": "src/test/ui/lint/dead-code/issue-85255.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -2,7 +2,6 @@\n // check-pass\n \n #![warn(dead_code)]\n-#![feature(crate_visibility_modifier)]\n \n struct Foo {\n     a: i32, //~ WARNING: field is never read\n@@ -28,12 +27,12 @@ impl Bar1 {\n     pub fn b(&self) -> i32 { 6 } //~ WARNING: associated function is never used\n }\n \n-crate struct Foo2 {\n+pub(crate) struct Foo2 {\n     a: i32, //~ WARNING: field is never read\n     pub b: i32, //~ WARNING: field is never read\n }\n \n-crate struct Bar2;\n+pub(crate) struct Bar2;\n \n impl Bar2 {\n     fn a(&self) -> i32 { 5 } //~ WARNING: associated function is never used"}, {"sha": "5f786d5a2a847db0183851363b59feee5ea0a659", "filename": "src/test/ui/lint/dead-code/issue-85255.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fissue-85255.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,5 @@\n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:8:5\n+  --> $DIR/issue-85255.rs:7:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n@@ -11,67 +11,67 @@ LL | #![warn(dead_code)]\n    |         ^^^^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:9:5\n+  --> $DIR/issue-85255.rs:8:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:15:8\n+  --> $DIR/issue-85255.rs:14:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:16:12\n+  --> $DIR/issue-85255.rs:15:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^\n \n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:20:5\n+  --> $DIR/issue-85255.rs:19:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:21:5\n+  --> $DIR/issue-85255.rs:20:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:27:8\n+  --> $DIR/issue-85255.rs:26:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:28:12\n+  --> $DIR/issue-85255.rs:27:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^\n \n warning: field is never read: `a`\n-  --> $DIR/issue-85255.rs:32:5\n+  --> $DIR/issue-85255.rs:31:5\n    |\n LL |     a: i32,\n    |     ^^^^^^\n \n warning: field is never read: `b`\n-  --> $DIR/issue-85255.rs:33:5\n+  --> $DIR/issue-85255.rs:32:5\n    |\n LL |     pub b: i32,\n    |     ^^^^^^^^^^\n \n warning: associated function is never used: `a`\n-  --> $DIR/issue-85255.rs:39:8\n+  --> $DIR/issue-85255.rs:38:8\n    |\n LL |     fn a(&self) -> i32 { 5 }\n    |        ^\n \n warning: associated function is never used: `b`\n-  --> $DIR/issue-85255.rs:40:12\n+  --> $DIR/issue-85255.rs:39:12\n    |\n LL |     pub fn b(&self) -> i32 { 6 }\n    |            ^"}, {"sha": "af2bd84bd53bedc9ff227eb6f666051e94c4136f", "filename": "src/test/ui/lint/unnecessary-extern-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funnecessary-extern-crate.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n \n #![deny(unused_extern_crates)]\n-#![feature(test, rustc_private, crate_visibility_modifier)]\n+#![feature(test, rustc_private)]\n \n extern crate libc;\n //~^ ERROR unused extern crate\n@@ -21,7 +21,7 @@ pub extern crate alloc;\n \n pub(crate) extern crate alloc as a;\n \n-crate extern crate alloc as b;\n+pub(crate) extern crate alloc as b;\n \n mod foo {\n     pub(in crate::foo) extern crate alloc as c;"}, {"sha": "4dc951985ae4d14a398d223b9ade6a4eb71f9bfb", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.rs?ref=3b64fe953c23b7d56dd5ebf61b6dbd82b345f880", "patch": "@@ -1,72 +0,0 @@\n-// This is just like unreachable_pub.rs, but without the\n-// `crate_visibility_modifier` feature (so that we can test the suggestions to\n-// use `pub(crate)` that are given when that feature is off, as opposed to the\n-// suggestions to use `crate` given when it is on). When that feature becomes\n-// stable, this test can be deleted.\n-\n-// check-pass\n-\n-\n-#![warn(unreachable_pub)]\n-\n-mod private_mod {\n-    // non-leaked `pub` items in private module should be linted\n-    pub use std::fmt; //~ WARNING unreachable_pub\n-    pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-    //~^ WARNING unreachable_pub\n-\n-    pub struct Hydrogen { //~ WARNING unreachable_pub\n-        // `pub` struct fields, too\n-        pub neutrons: usize, //~ WARNING unreachable_pub\n-        // (... but not more-restricted fields)\n-        pub(crate) electrons: usize\n-    }\n-    impl Hydrogen {\n-        // impls, too\n-        pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n-        pub(crate) fn count_electrons(&self) -> usize { self.electrons }\n-    }\n-    impl Clone for Hydrogen {\n-        fn clone(&self) -> Hydrogen {\n-            Hydrogen { neutrons: self.neutrons, electrons: self.electrons }\n-        }\n-    }\n-\n-    pub enum Helium {} //~ WARNING unreachable_pub\n-    pub union Lithium { c1: usize, c2: u8 } //~ WARNING unreachable_pub\n-    pub fn beryllium() {} //~ WARNING unreachable_pub\n-    pub trait Boron {} //~ WARNING unreachable_pub\n-    pub const CARBON: usize = 1; //~ WARNING unreachable_pub\n-    pub static NITROGEN: usize = 2; //~ WARNING unreachable_pub\n-    pub type Oxygen = bool; //~ WARNING unreachable_pub\n-\n-    macro_rules! define_empty_struct_with_visibility {\n-        ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-        //~^ WARNING unreachable_pub\n-    }\n-    define_empty_struct_with_visibility!(pub, Fluorine);\n-\n-    extern \"C\" {\n-        pub fn catalyze() -> bool; //~ WARNING unreachable_pub\n-    }\n-\n-    // items leaked through signatures (see `get_neon` below) are OK\n-    pub struct Neon {}\n-\n-    // crate-visible items are OK\n-    pub(crate) struct Sodium {}\n-}\n-\n-pub mod public_mod {\n-    // module is public: these are OK, too\n-    pub struct Magnesium {}\n-    pub(crate) struct Aluminum {}\n-}\n-\n-pub fn get_neon() -> private_mod::Neon {\n-    private_mod::Neon {}\n-}\n-\n-fn main() {\n-    let _ = get_neon();\n-}"}, {"sha": "6c05a030138bc04bdd72ba4b85eccc720a7d3e1f", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.stderr", "status": "removed", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b64fe953c23b7d56dd5ebf61b6dbd82b345f880/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr?ref=3b64fe953c23b7d56dd5ebf61b6dbd82b345f880", "patch": "@@ -1,148 +0,0 @@\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:14:5\n-   |\n-LL |     pub use std::fmt;\n-   |     ---^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/unreachable_pub-pub_crate.rs:10:9\n-   |\n-LL | #![warn(unreachable_pub)]\n-   |         ^^^^^^^^^^^^^^^\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:15:24\n-   |\n-LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-   |     ---                ^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:18:5\n-   |\n-LL |     pub struct Hydrogen {\n-   |     ---^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` field\n-  --> $DIR/unreachable_pub-pub_crate.rs:20:9\n-   |\n-LL |         pub neutrons: usize,\n-   |         ---^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:26:9\n-   |\n-LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n-   |         ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:35:5\n-   |\n-LL |     pub enum Helium {}\n-   |     ---^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:36:5\n-   |\n-LL |     pub union Lithium { c1: usize, c2: u8 }\n-   |     ---^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:37:5\n-   |\n-LL |     pub fn beryllium() {}\n-   |     ---^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:38:5\n-   |\n-LL |     pub trait Boron {}\n-   |     ---^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:39:5\n-   |\n-LL |     pub const CARBON: usize = 1;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:40:5\n-   |\n-LL |     pub static NITROGEN: usize = 2;\n-   |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:41:5\n-   |\n-LL |     pub type Oxygen = bool;\n-   |     ---^^^^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:44:47\n-   |\n-LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n-...\n-LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n-   |     ---------------------------------------------------\n-   |     |                                    |\n-   |     |                                    help: consider restricting its visibility: `pub(crate)`\n-   |     in this macro invocation\n-   |\n-   = help: or consider exporting it for use by other crates\n-   = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub-pub_crate.rs:50:9\n-   |\n-LL |         pub fn catalyze() -> bool;\n-   |         ---^^^^^^^^^^^^^^^^^^^^^^^\n-   |         |\n-   |         help: consider restricting its visibility: `pub(crate)`\n-   |\n-   = help: or consider exporting it for use by other crates\n-\n-warning: 14 warnings emitted\n-"}, {"sha": "a50467ce82daf14e8367fd7bca5e501109087ebb", "filename": "src/test/ui/lint/unreachable_pub.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(crate_visibility_modifier)]\n-\n #![allow(unused)]\n #![warn(unreachable_pub)]\n \n@@ -15,12 +13,12 @@ mod private_mod {\n         // `pub` struct fields, too\n         pub neutrons: usize, //~ WARNING unreachable_pub\n         // (... but not more-restricted fields)\n-        crate electrons: usize\n+        pub(crate) electrons: usize\n     }\n     impl Hydrogen {\n         // impls, too\n         pub fn count_neutrons(&self) -> usize { self.neutrons } //~ WARNING unreachable_pub\n-        crate fn count_electrons(&self) -> usize { self.electrons }\n+        pub(crate) fn count_electrons(&self) -> usize { self.electrons }\n     }\n     impl Clone for Hydrogen {\n         fn clone(&self) -> Hydrogen {\n@@ -50,13 +48,13 @@ mod private_mod {\n     pub struct Neon {}\n \n     // crate-visible items are OK\n-    crate struct Sodium {}\n+    pub(crate) struct Sodium {}\n }\n \n pub mod public_mod {\n     // module is public: these are OK, too\n     pub struct Magnesium {}\n-    crate struct Aluminum {}\n+    pub(crate) struct Aluminum {}\n }\n \n pub fn get_neon() -> private_mod::Neon {"}, {"sha": "ce22eca1b8ce61e89eb795e6d9d17a7717bc22f1", "filename": "src/test/ui/lint/unreachable_pub.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,146 +1,146 @@\n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:10:5\n+  --> $DIR/unreachable_pub.rs:8:5\n    |\n LL |     pub use std::fmt;\n    |     ---^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n note: the lint level is defined here\n-  --> $DIR/unreachable_pub.rs:6:9\n+  --> $DIR/unreachable_pub.rs:4:9\n    |\n LL | #![warn(unreachable_pub)]\n    |         ^^^^^^^^^^^^^^^\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:11:24\n+  --> $DIR/unreachable_pub.rs:9:24\n    |\n LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n    |     ---                ^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:14:5\n+  --> $DIR/unreachable_pub.rs:12:5\n    |\n LL |     pub struct Hydrogen {\n    |     ---^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` field\n-  --> $DIR/unreachable_pub.rs:16:9\n+  --> $DIR/unreachable_pub.rs:14:9\n    |\n LL |         pub neutrons: usize,\n    |         ---^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:22:9\n+  --> $DIR/unreachable_pub.rs:20:9\n    |\n LL |         pub fn count_neutrons(&self) -> usize { self.neutrons }\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:31:5\n+  --> $DIR/unreachable_pub.rs:29:5\n    |\n LL |     pub enum Helium {}\n    |     ---^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:32:5\n+  --> $DIR/unreachable_pub.rs:30:5\n    |\n LL |     pub union Lithium { c1: usize, c2: u8 }\n    |     ---^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:33:5\n+  --> $DIR/unreachable_pub.rs:31:5\n    |\n LL |     pub fn beryllium() {}\n    |     ---^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:34:5\n+  --> $DIR/unreachable_pub.rs:32:5\n    |\n LL |     pub trait Boron {}\n    |     ---^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:35:5\n+  --> $DIR/unreachable_pub.rs:33:5\n    |\n LL |     pub const CARBON: usize = 1;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:36:5\n+  --> $DIR/unreachable_pub.rs:34:5\n    |\n LL |     pub static NITROGEN: usize = 2;\n    |     ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:37:5\n+  --> $DIR/unreachable_pub.rs:35:5\n    |\n LL |     pub type Oxygen = bool;\n    |     ---^^^^^^^^^^^^^^^^^^^^\n    |     |\n-   |     help: consider restricting its visibility: `crate`\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:40:47\n+  --> $DIR/unreachable_pub.rs:38:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n    |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n    |     ---------------------------------------------------\n    |     |                                    |\n-   |     |                                    help: consider restricting its visibility: `crate`\n+   |     |                                    help: consider restricting its visibility: `pub(crate)`\n    |     in this macro invocation\n    |\n    = help: or consider exporting it for use by other crates\n    = note: this warning originates in the macro `define_empty_struct_with_visibility` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: unreachable `pub` item\n-  --> $DIR/unreachable_pub.rs:46:9\n+  --> $DIR/unreachable_pub.rs:44:9\n    |\n LL |         pub fn catalyze() -> bool;\n    |         ---^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n-   |         help: consider restricting its visibility: `crate`\n+   |         help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n "}, {"sha": "7b02a70be0942c2009bdf229025ec457c11dea0f", "filename": "src/test/ui/macros/macro-pub-matcher.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-pub-matcher.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![allow(dead_code, unused_imports, unused_macro_rules)]\n-#![feature(crate_visibility_modifier)]\n \n /**\n Ensure that `:vis` matches can be captured in existing positions, and passed\n@@ -56,15 +55,15 @@ mod with_pub_restricted {\n }\n \n mod with_crate {\n-    vis_passthru! { crate const A: i32 = 0; }\n-    vis_passthru! { crate enum B {} }\n-    vis_passthru! { crate extern \"C\" fn c() {} }\n-    vis_passthru! { crate mod d {} }\n-    vis_passthru! { crate static E: i32 = 0; }\n-    vis_passthru! { crate struct F; }\n-    vis_passthru! { crate trait G {} }\n-    vis_passthru! { crate type H = i32; }\n-    vis_passthru! { crate use A as I; }\n+    vis_passthru! { pub(crate) const A: i32 = 0; }\n+    vis_passthru! { pub(crate) enum B {} }\n+    vis_passthru! { pub(crate) extern \"C\" fn c() {} }\n+    vis_passthru! { pub(crate) mod d {} }\n+    vis_passthru! { pub(crate) static E: i32 = 0; }\n+    vis_passthru! { pub(crate) struct F; }\n+    vis_passthru! { pub(crate) trait G {} }\n+    vis_passthru! { pub(crate) type H = i32; }\n+    vis_passthru! { pub(crate) use A as I; }\n }\n \n mod garden {"}, {"sha": "6f115e78e147b38cf52de11c24bc98084f3838a5", "filename": "src/test/ui/privacy/issue-46209-private-enum-variant-reexport.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,3 @@\n-#![feature(crate_visibility_modifier)]\n-\n #[deny(unused_imports)]\n mod rank {\n     pub use self::Professor::*;\n@@ -31,7 +29,7 @@ mod rank {\n         MasterChief\n     }\n \n-    crate enum Crewman {\n+    pub(crate) enum Crewman {\n         Recruit,\n         Apprentice,\n         Full"}, {"sha": "59b181fab40012e0a4a6b99dca480529d92e09a2", "filename": "src/test/ui/privacy/issue-46209-private-enum-variant-reexport.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-46209-private-enum-variant-reexport.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,47 +1,47 @@\n error[E0364]: `JuniorGrade` is private, and cannot be re-exported\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:32\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:32\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                ^^^^^^^^^^^\n    |\n note: consider marking `JuniorGrade` as `pub` in the imported module\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:32\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:32\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                ^^^^^^^^^^^\n \n error[E0364]: `Full` is private, and cannot be re-exported\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:45\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:45\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                             ^^^^\n    |\n note: consider marking `Full` as `pub` in the imported module\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:7:45\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:45\n    |\n LL |     pub use self::Lieutenant::{JuniorGrade, Full};\n    |                                             ^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:5:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:3:13\n    |\n LL |     pub use self::Professor::*;\n    |             ^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:3:8\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:1:8\n    |\n LL | #[deny(unused_imports)]\n    |        ^^^^^^^^^^^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:10:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:8:13\n    |\n LL |     pub use self::PettyOfficer::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^\n \n error: glob import doesn't reexport anything because no candidate is public enough\n-  --> $DIR/issue-46209-private-enum-variant-reexport.rs:12:13\n+  --> $DIR/issue-46209-private-enum-variant-reexport.rs:10:13\n    |\n LL |     pub use self::Crewman::*;\n    |             ^^^^^^^^^^^^^^^^"}, {"sha": "a4013e6ac60b29cee26433f87c2236d08103bc40", "filename": "src/test/ui/privacy/restricted/auxiliary/pub_restricted.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fauxiliary%2Fpub_restricted.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,16 +1,14 @@\n-#![feature(crate_visibility_modifier)]\n-\n pub(crate) struct Crate;\n \n #[derive(Default)]\n pub struct Universe {\n     pub x: i32,\n     pub(crate) y: i32,\n-    crate z: i32,\n+    pub(crate) z: i32,\n }\n \n impl Universe {\n     pub fn f(&self) {}\n     pub(crate) fn g(&self) {}\n-    crate fn h(&self) {}\n+    pub(crate) fn h(&self) {}\n }"}, {"sha": "1e3dbdf73b96c93bed0428b9ec6c139ca3adaec6", "filename": "src/test/ui/privacy/restricted/private-in-public.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,12 +1,10 @@\n-#![feature(crate_visibility_modifier)]\n-\n mod foo {\n     struct Priv;\n     mod bar {\n         use foo::Priv;\n         pub(super) fn f(_: Priv) {}\n         pub(crate) fn g(_: Priv) {} //~ ERROR E0446\n-        crate fn h(_: Priv) {} //~ ERROR E0446\n+        pub(crate) fn h(_: Priv) {} //~ ERROR E0446\n     }\n }\n "}, {"sha": "ee9c031ebff231752494c1997c9c8127d82cbfa7", "filename": "src/test/ui/privacy/restricted/private-in-public.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Fprivate-in-public.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,5 @@\n error[E0446]: private type `Priv` in public interface\n-  --> $DIR/private-in-public.rs:8:9\n+  --> $DIR/private-in-public.rs:6:9\n    |\n LL |     struct Priv;\n    |     ------------ `Priv` declared as private\n@@ -8,13 +8,13 @@ LL |         pub(crate) fn g(_: Priv) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error[E0446]: private type `Priv` in public interface\n-  --> $DIR/private-in-public.rs:9:9\n+  --> $DIR/private-in-public.rs:7:9\n    |\n LL |     struct Priv;\n    |     ------------ `Priv` declared as private\n ...\n-LL |         crate fn h(_: Priv) {}\n-   |         ^^^^^^^^^^^^^^^^^^^ can't leak private type\n+LL |         pub(crate) fn h(_: Priv) {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5a85aef2b175b4539bdb77b319b48ce75115be4e", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -29,7 +29,7 @@ LL |     use pub_restricted::Crate;\n    |                         ^^^^^ private struct\n    |\n note: the struct `Crate` is defined here\n-  --> $DIR/auxiliary/pub_restricted.rs:3:1\n+  --> $DIR/auxiliary/pub_restricted.rs:1:1\n    |\n LL | pub(crate) struct Crate;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -88,7 +88,7 @@ error[E0624]: associated function `g` is private\n LL |     u.g();\n    |       ^ private associated function\n    |\n-  ::: $DIR/auxiliary/pub_restricted.rs:14:5\n+  ::: $DIR/auxiliary/pub_restricted.rs:12:5\n    |\n LL |     pub(crate) fn g(&self) {}\n    |     ---------------------- private associated function defined here\n@@ -99,10 +99,10 @@ error[E0624]: associated function `h` is private\n LL |     u.h();\n    |       ^ private associated function\n    |\n-  ::: $DIR/auxiliary/pub_restricted.rs:15:5\n+  ::: $DIR/auxiliary/pub_restricted.rs:13:5\n    |\n-LL |     crate fn h(&self) {}\n-   |     ----------------- private associated function defined here\n+LL |     pub(crate) fn h(&self) {}\n+   |     ---------------------- private associated function defined here\n \n error: aborting due to 12 previous errors\n "}, {"sha": "7ebd259189d6d8f236546f0757c148d88c8a3345", "filename": "src/test/ui/resolve/crate-in-paths.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,9 +1,7 @@\n // edition:2018\n \n-#![feature(crate_visibility_modifier)]\n-\n mod bar {\n-    crate struct Foo;\n+    pub(crate) struct Foo;\n }\n \n fn main() {"}, {"sha": "b7cf4950759e36bb0454e605ca1cf4304ef03404", "filename": "src/test/ui/resolve/crate-in-paths.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fcrate-in-paths.stderr?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,5 +1,5 @@\n error[E0425]: cannot find value `Foo` in this scope\n-  --> $DIR/crate-in-paths.rs:10:5\n+  --> $DIR/crate-in-paths.rs:8:5\n    |\n LL |     Foo;\n    |     ^^^ not found in this scope"}, {"sha": "85d106bc11f68aff502f36ed20e66719920667b1", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.fixed?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,14 +1,14 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n mod foo {\n-    crate trait Foo {\n+    pub(crate) trait Foo {\n         type Bar;\n     }\n \n-    crate struct Baz {}\n+    pub(crate) struct Baz {}\n \n     impl Foo for Baz {\n         type Bar = ();"}, {"sha": "9ff3c2e5fcff44f87b228d178cf7f9fcb016c0bf", "filename": "src/test/ui/rust-2018/edition-lint-fully-qualified-paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-fully-qualified-paths.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,14 +1,14 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n mod foo {\n-    crate trait Foo {\n+    pub(crate) trait Foo {\n         type Bar;\n     }\n \n-    crate struct Baz {}\n+    pub(crate) struct Baz {}\n \n     impl Foo for Baz {\n         type Bar = ();"}, {"sha": "f25d46ce30d0a2c16487d3e266d4f0d3537d760f", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.fixed", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.fixed?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,16 +1,16 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n #![allow(unused_imports)]\n #![allow(dead_code)]\n \n-crate mod foo {\n-    crate mod bar {\n-        crate mod baz { }\n-        crate mod baz1 { }\n+pub(crate) mod foo {\n+    pub(crate) mod bar {\n+        pub(crate) mod baz { }\n+        pub(crate) mod baz1 { }\n \n-        crate struct XX;\n+        pub(crate) struct XX;\n     }\n }\n "}, {"sha": "9be1680c1ce74594b2bb2285aff8e10cfc980f7c", "filename": "src/test/ui/rust-2018/edition-lint-nested-empty-paths.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-empty-paths.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,16 +1,16 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n #![allow(unused_imports)]\n #![allow(dead_code)]\n \n-crate mod foo {\n-    crate mod bar {\n-        crate mod baz { }\n-        crate mod baz1 { }\n+pub(crate) mod foo {\n+    pub(crate) mod bar {\n+        pub(crate) mod baz { }\n+        pub(crate) mod baz1 { }\n \n-        crate struct XX;\n+        pub(crate) struct XX;\n     }\n }\n "}, {"sha": "a04937ae8ee3b38cf2dab74b7672c154f89e226a", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.fixed", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.fixed?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n use crate::foo::{a, b};\n@@ -10,9 +10,9 @@ use crate::foo::{a, b};\n //~| this is accepted in the current edition\n \n mod foo {\n-    crate fn a() {}\n-    crate fn b() {}\n-    crate fn c() {}\n+    pub(crate) fn a() {}\n+    pub(crate) fn b() {}\n+    pub(crate) fn c() {}\n }\n \n fn main() {"}, {"sha": "e622a8e24be633632d2cc62d446a6bbc6c72bdb9", "filename": "src/test/ui/rust-2018/edition-lint-nested-paths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-nested-paths.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![feature(rust_2018_preview, crate_visibility_modifier)]\n+#![feature(rust_2018_preview)]\n #![deny(absolute_paths_not_starting_with_crate)]\n \n use foo::{a, b};\n@@ -10,9 +10,9 @@ use foo::{a, b};\n //~| this is accepted in the current edition\n \n mod foo {\n-    crate fn a() {}\n-    crate fn b() {}\n-    crate fn c() {}\n+    pub(crate) fn a() {}\n+    pub(crate) fn b() {}\n+    pub(crate) fn c() {}\n }\n \n fn main() {"}, {"sha": "12a50c013a91f3ccca9dc88084191525b6a6dac8", "filename": "src/tools/rustfmt/tests/source/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Ffn-simple.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -63,7 +63,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "5683acbf3aa936dd622a536906c06a6faf9a9d39", "filename": "src/tools/rustfmt/tests/source/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fpub-restricted.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -24,19 +24,6 @@ pub(  crate  ) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-  crate   enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in  ::global::  path :: to::some_mod  ) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}, {"sha": "e725269360d2cf23b8c4fd6b162e72bf74be7c47", "filename": "src/tools/rustfmt/tests/target/fn-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Ffn-simple.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -105,7 +105,7 @@ mod foo {\n // #2082\n pub(crate) fn init() {}\n \n-crate fn init() {}\n+pub(crate) fn init() {}\n \n // #2630\n fn make_map<T, F: (Fn(&T) -> String)>(records: &Vec<T>, key_fn: F) -> HashMap<String, usize> {}"}, {"sha": "0e178ef10136e3965f7185ef1998b329b5982da5", "filename": "src/tools/rustfmt/tests/target/pub-restricted.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f372b14dea58cbff1dd76bb651f9c035d3f6e7b/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Ftarget%2Fpub-restricted.rs?ref=4f372b14dea58cbff1dd76bb651f9c035d3f6e7b", "patch": "@@ -24,19 +24,6 @@ pub(crate) enum WriteState<D> {\n     WriteData(Writer<D>),\n }\n \n-crate enum WriteState<D> {\n-    WriteId {\n-        id: U64Writer,\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteSize {\n-        size: U64Writer,\n-        payload: Option<Writer<D>>,\n-    },\n-    WriteData(Writer<D>),\n-}\n-\n pub(in global::path::to::some_mod) enum WriteState<D> {\n     WriteId {\n         id: U64Writer,"}]}