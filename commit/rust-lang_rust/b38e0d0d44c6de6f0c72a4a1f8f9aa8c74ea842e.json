{"sha": "b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOGUwZDBkNDRjNmRlNmYwYzcyYTRhMWY4ZjlhYThjNzRlYTg0MmU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-26T12:59:58Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-07-08T14:42:47Z"}, "message": "Build SymbolMap for symbol name conflict checking and caching.", "tree": {"sha": "822d2a1489d3ba81c3b550caefb63090e34dee35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822d2a1489d3ba81c3b550caefb63090e34dee35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "html_url": "https://github.com/rust-lang/rust/commit/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87c1c87dd7389466333a976d9c536c083c311443", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c1c87dd7389466333a976d9c536c083c311443", "html_url": "https://github.com/rust-lang/rust/commit/87c1c87dd7389466333a976d9c536c083c311443"}], "stats": {"total": 291, "additions": 237, "deletions": 54}, "files": [{"sha": "3fc7fe5128877cca4eca0934be2ca208d004fb25", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -80,6 +80,7 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n+use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::TransItem;\n use tvec;\n@@ -97,6 +98,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n+use std::rc::Rc;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -2588,14 +2590,18 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n-    let codegen_units = collect_and_partition_translation_items(&shared_ccx);\n+    let (codegen_units, symbol_map) =\n+        collect_and_partition_translation_items(&shared_ccx);\n     let codegen_unit_count = codegen_units.len();\n \n     assert!(tcx.sess.opts.cg.codegen_units == codegen_unit_count ||\n             tcx.sess.opts.debugging_opts.incremental.is_some());\n \n-    let crate_context_list = CrateContextList::new(&shared_ccx, codegen_units);\n+    let symbol_map = Rc::new(symbol_map);\n \n+    let crate_context_list = CrateContextList::new(&shared_ccx,\n+                                                   codegen_units,\n+                                                   symbol_map.clone());\n     let modules = crate_context_list.iter()\n         .map(|ccx| ModuleTranslation {\n             name: String::from(&ccx.codegen_unit().name[..]),\n@@ -2693,8 +2699,9 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let sess = shared_ccx.sess();\n     let mut reachable_symbols = shared_ccx.reachable().iter().map(|&id| {\n         let def_id = shared_ccx.tcx().map.local_def_id(id);\n-        Instance::mono(&shared_ccx, def_id).symbol_name(&shared_ccx)\n+        symbol_for_def_id(def_id, &shared_ccx, &symbol_map)\n     }).collect::<Vec<_>>();\n+\n     if sess.entry_fn.borrow().is_some() {\n         reachable_symbols.push(\"main\".to_string());\n     }\n@@ -2716,7 +2723,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.extend(syms.into_iter().filter(|did| {\n             sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n         }).map(|did| {\n-            Instance::mono(&shared_ccx, did).symbol_name(&shared_ccx)\n+            symbol_for_def_id(did, &shared_ccx, &symbol_map)\n         }));\n     }\n \n@@ -2810,7 +2817,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TransItemsWithinModVisitor<'a, 'tcx> {\n }\n \n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n-                                                     -> Vec<CodegenUnit<'tcx>> {\n+                                                     -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -2833,10 +2840,13 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(&scx, collection_mode)\n+    let (items, inlining_map) =\n+        time(time_passes, \"translation item collection\", || {\n+            collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n+    let symbol_map = SymbolMap::build(scx, items.iter().cloned());\n+\n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n     } else {\n@@ -2910,5 +2920,24 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    codegen_units\n+    (codegen_units, symbol_map)\n+}\n+\n+fn symbol_for_def_id<'a, 'tcx>(def_id: DefId,\n+                               scx: &SharedCrateContext<'a, 'tcx>,\n+                               symbol_map: &SymbolMap<'tcx>)\n+                               -> String {\n+    // Just try to look things up in the symbol map. If nothing's there, we\n+    // recompute.\n+    if let Some(node_id) = scx.tcx().map.as_local_node_id(def_id) {\n+        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n+            return sym.to_owned();\n+        }\n+    }\n+\n+    let instance = Instance::mono(scx, def_id);\n+\n+    symbol_map.get(TransItem::Fn(instance))\n+              .map(str::to_owned)\n+              .unwrap_or_else(|| instance.symbol_name(scx))\n }"}, {"sha": "b7cf43a437169a937a64670778145475c1c295f5", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -46,6 +46,7 @@ use intrinsic;\n use machine::llalign_of_min;\n use meth;\n use monomorphize::{self, Instance};\n+use trans_item::TransItem;\n use type_::Type;\n use type_of;\n use value::Value;\n@@ -536,11 +537,18 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n \n-    let sym = instance.symbol_name(ccx.shared());\n+    // Let's see if we can get the symbol name from the symbol_map, so we don't\n+    // have to recompute it.\n+    let mut sym_data = String::new();\n+    let sym = ccx.symbol_map().get(TransItem::Fn(instance)).unwrap_or_else(|| {\n+        sym_data = instance.symbol_name(ccx.shared());\n+        &sym_data[..]\n+    });\n+\n     let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, &sym) {\n+    let llfn = if let Some(llfn) = declare::get_declared_value(ccx, sym) {\n         if let Some(span) = local_item {\n-            if declare::get_defined_value(ccx, &sym).is_some() {\n+            if declare::get_defined_value(ccx, sym).is_some() {\n                 ccx.sess().span_fatal(span,\n                     &format!(\"symbol `{}` is already defined\", sym));\n             }\n@@ -558,7 +566,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             llfn\n         }\n     } else {\n-        let llfn = declare::declare_fn(ccx, &sym, ty);\n+        let llfn = declare::declare_fn(ccx, sym, ty);\n         assert_eq!(common::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n "}, {"sha": "3f18c61fbd26caada391283588bcc08ebfb6ae20", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -1013,38 +1013,41 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }\n \n-    let sym = instance.symbol_name(ccx.shared());\n-\n     let g = if let Some(id) = ccx.tcx().map.as_local_node_id(def_id) {\n+\n         let llty = type_of::type_of(ccx, ty);\n         let (g, attrs) = match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n                 ref attrs, span, node: hir::ItemStatic(..), ..\n             }) => {\n+                let sym = ccx.symbol_map()\n+                             .get(TransItem::Static(id))\n+                             .expect(\"Local statics should always be in the SymbolMap\");\n                 // Make sure that this is never executed for something inlined.\n                 assert!(!ccx.external_srcs().borrow().contains_key(&id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items\n                                                          .contains_key(&TransItem::Static(id));\n                 if defined_in_current_codegen_unit {\n-                    if declare::get_declared_value(ccx, &sym).is_none() {\n+                    if declare::get_declared_value(ccx, sym).is_none() {\n                         span_bug!(span, \"trans: Static not properly pre-defined?\");\n                     }\n                 } else {\n-                    if declare::get_declared_value(ccx, &sym).is_some() {\n+                    if declare::get_declared_value(ccx, sym).is_some() {\n                         span_bug!(span, \"trans: Conflicting symbol names for static?\");\n                     }\n                 }\n \n-                let g = declare::define_global(ccx, &sym, llty).unwrap();\n+                let g = declare::define_global(ccx, sym, llty).unwrap();\n \n                 (g, attrs)\n             }\n \n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n+                let sym = instance.symbol_name(ccx.shared());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -1079,7 +1082,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                         real_name.push_str(&sym);\n                         let g2 = declare::define_global(ccx, &real_name, llty).unwrap_or_else(||{\n                             ccx.sess().span_fatal(span,\n-                                &format!(\"symbol `{}` is already defined\", sym))\n+                                &format!(\"symbol `{}` is already defined\", &sym))\n                         });\n                         llvm::SetLinkage(g2, llvm::InternalLinkage);\n                         llvm::LLVMSetInitializer(g2, g1);\n@@ -1104,6 +1107,8 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n \n         g\n     } else {\n+        let sym = instance.symbol_name(ccx.shared());\n+\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n         let g = declare::declare_global(ccx, &sym, type_of::type_of(ccx, ty));"}, {"sha": "64e0351610f24441a12c7aa45b9899ad6c0ca49f", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -35,6 +35,7 @@ use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n+use symbol_map::SymbolMap;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap};\n \n@@ -171,6 +172,8 @@ pub struct LocalCrateContext<'tcx> {\n \n     /// Depth of the current type-of computation - used to bail out\n     type_of_depth: Cell<usize>,\n+\n+    symbol_map: Rc<SymbolMap<'tcx>>,\n }\n \n // Implement DepTrackingMapConfig for `trait_cache`\n@@ -197,12 +200,13 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n \n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n-               codegen_units: Vec<CodegenUnit<'tcx>>)\n+               codegen_units: Vec<CodegenUnit<'tcx>>,\n+               symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n             local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n-                LocalCrateContext::new(shared_ccx, codegen_unit)\n+                LocalCrateContext::new(shared_ccx, codegen_unit, symbol_map.clone())\n             }).collect()\n         }\n     }\n@@ -512,7 +516,8 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n \n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n-               codegen_unit: CodegenUnit<'tcx>)\n+               codegen_unit: CodegenUnit<'tcx>,\n+               symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n             // Append \".rs\" to LLVM module identifier.\n@@ -571,6 +576,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n+                symbol_map: symbol_map,\n             };\n \n             let (int_type, opaque_vec_type, str_slice_ty, mut local_ccx) = {\n@@ -890,6 +896,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.get_mir(def_id)\n     }\n \n+    pub fn symbol_map(&self) -> &SymbolMap<'tcx> {\n+        &*self.local().symbol_map\n+    }\n+\n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n         &self.shared.translation_items\n     }"}, {"sha": "fa0a1fdc37523dbff9f012d6a0bb33f82baf93a1", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -122,6 +122,7 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n+mod symbol_map;\n mod symbol_names_test;\n mod trans_item;\n mod tvec;"}, {"sha": "8a2cc53432d86e1f55621e62987df52bde35cef3", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -84,19 +84,24 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let symbol = instance.symbol_name(ccx.shared());\n+    // Let's see if we can get the symbol name from the symbol_map, so we don't\n+    // have to recompute it.\n+    let mut sym_data = String::new();\n+    let symbol = ccx.symbol_map().get(TransItem::Fn(instance)).unwrap_or_else(|| {\n+        sym_data = instance.symbol_name(ccx.shared());\n+        &sym_data[..]\n+    });\n \n     debug!(\"monomorphize_fn mangled to {}\", symbol);\n-    assert!(declare::get_defined_value(ccx, &symbol).is_none());\n+    assert!(declare::get_defined_value(ccx, symbol).is_none());\n \n     // FIXME(nagisa): perhaps needs a more fine grained selection?\n-    let lldecl = declare::define_internal_fn(ccx, &symbol, mono_ty);\n+    let lldecl = declare::define_internal_fn(ccx, symbol, mono_ty);\n     // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n     attributes::unwind(lldecl, true);\n \n     ccx.instances().borrow_mut().insert(instance, lldecl);\n \n-\n     // we can only monomorphize things in this crate (or inlined into it)\n     let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n     let map_node = errors::expect("}, {"sha": "4f82b54c76b02328c709245337fa7ba8ede98843", "filename": "src/librustc_trans/symbol_map.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use context::SharedCrateContext;\n+use monomorphize::Instance;\n+use rustc::ty::TyCtxt;\n+use syntax::codemap::Span;\n+use trans_item::TransItem;\n+use util::nodemap::FnvHashMap;\n+\n+\n+// In the SymbolMap we collect the symbol names of all translation items of\n+// the current crate.\n+\n+pub struct SymbolMap<'tcx> {\n+    index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n+    arena: String,\n+}\n+\n+impl<'tcx> SymbolMap<'tcx> {\n+\n+    pub fn build<'a, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+                        trans_items: I)\n+                        -> SymbolMap<'tcx>\n+        where I: Iterator<Item=TransItem<'tcx>>\n+    {\n+        // Check for duplicate symbol names\n+        let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n+            (trans_item, trans_item.compute_symbol_name(scx))\n+        }).collect();\n+\n+        (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n+            sym1.cmp(sym2)\n+        });\n+\n+        for pair in (&symbols[..]).windows(2) {\n+            let sym1 = &pair[0].1;\n+            let sym2 = &pair[1].1;\n+\n+            if *sym1 == *sym2 {\n+                let trans_item1 = pair[0].0;\n+                let trans_item2 = pair[1].0;\n+\n+                let span1 = get_span(scx.tcx(), trans_item1);\n+                let span2 = get_span(scx.tcx(), trans_item2);\n+\n+                // Deterministically select one of the spans for error reporting\n+                let span = match (span1, span2) {\n+                    (Some(span1), Some(span2)) => {\n+                        Some(if span1.lo.0 > span2.lo.0 {\n+                            span1\n+                        } else {\n+                            span2\n+                        })\n+                    }\n+                    (Some(span), None) |\n+                    (None, Some(span)) => Some(span),\n+                    _ => None\n+                };\n+\n+                let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+                if let Some(span) = span {\n+                    scx.sess().span_fatal(span, &error_message)\n+                } else {\n+                    scx.sess().fatal(&error_message)\n+                }\n+            }\n+        }\n+\n+        let mut symbol_map = SymbolMap {\n+            index: FnvHashMap(),\n+            arena: String::with_capacity(1024),\n+        };\n+\n+        for (trans_item, symbol) in symbols {\n+            let start_index = symbol_map.arena.len();\n+            symbol_map.arena.push_str(&symbol[..]);\n+            let end_index = symbol_map.arena.len();\n+            let prev_entry = symbol_map.index.insert(trans_item,\n+                                                     (start_index, end_index));\n+            if prev_entry.is_some() {\n+                bug!(\"TransItem encountered twice?\")\n+            }\n+        }\n+\n+        fn get_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              trans_item: TransItem<'tcx>) -> Option<Span> {\n+            match trans_item {\n+                TransItem::Fn(Instance { def, .. }) => {\n+                    tcx.map.as_local_node_id(def)\n+                }\n+                TransItem::Static(node_id) => Some(node_id),\n+                TransItem::DropGlue(_) => None,\n+            }.map(|node_id| {\n+                tcx.map.span(node_id)\n+            })\n+        }\n+\n+        symbol_map\n+    }\n+\n+    pub fn get(&self, trans_item: TransItem<'tcx>) -> Option<&str> {\n+        self.index.get(&trans_item).map(|&(start_index, end_index)| {\n+            &self.arena[start_index .. end_index]\n+        })\n+    }\n+}"}, {"sha": "4fa0ba03005abb80fa7ccc81c5e2f8eee5673464", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b38e0d0d44c6de6f0c72a4a1f8f9aa8c74ea842e", "patch": "@@ -17,7 +17,7 @@\n use attributes;\n use base;\n use consts;\n-use context::CrateContext;\n+use context::{CrateContext, SharedCrateContext};\n use declare;\n use glue::DropGlueKind;\n use llvm;\n@@ -64,7 +64,6 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n-\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -108,15 +107,20 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                self.to_raw_string(),\n                ccx.codegen_unit().name);\n \n+        let symbol_name = ccx.symbol_map()\n+                             .get(*self)\n+                             .expect(\"Name not present in SymbolMap?\");\n+        debug!(\"symbol {}\", symbol_name);\n+\n         match *self {\n             TransItem::Static(node_id) => {\n-                TransItem::predefine_static(ccx, node_id, linkage);\n+                TransItem::predefine_static(ccx, node_id, linkage, symbol_name);\n             }\n             TransItem::Fn(instance) => {\n-                TransItem::predefine_fn(ccx, instance, linkage);\n+                TransItem::predefine_fn(ccx, instance, linkage, symbol_name);\n             }\n             TransItem::DropGlue(dg) => {\n-                TransItem::predefine_drop_glue(ccx, dg, linkage);\n+                TransItem::predefine_drop_glue(ccx, dg, linkage, symbol_name);\n             }\n         }\n \n@@ -128,7 +132,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,\n                         node_id: ast::NodeId,\n-                        linkage: llvm::Linkage) {\n+                        linkage: llvm::Linkage,\n+                        symbol_name: &str) {\n         let def_id = ccx.tcx().map.local_def_id(node_id);\n         let ty = ccx.tcx().lookup_item_type(def_id).ty;\n         let llty = type_of::type_of(ccx, ty);\n@@ -137,13 +142,9 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             hir::map::NodeItem(&hir::Item {\n                 span, node: hir::ItemStatic(..), ..\n             }) => {\n-                let instance = Instance::mono(ccx.shared(), def_id);\n-                let sym = instance.symbol_name(ccx.shared());\n-                debug!(\"symbol {}\", sym);\n-\n-                let g = declare::define_global(ccx, &sym, llty).unwrap_or_else(|| {\n+                let g = declare::define_global(ccx, symbol_name, llty).unwrap_or_else(|| {\n                     ccx.sess().span_fatal(span,\n-                        &format!(\"symbol `{}` is already defined\", sym))\n+                        &format!(\"symbol `{}` is already defined\", symbol_name))\n                 });\n \n                 llvm::SetLinkage(g, linkage);\n@@ -155,7 +156,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     fn predefine_fn(ccx: &CrateContext<'a, 'tcx>,\n                     instance: Instance<'tcx>,\n-                    linkage: llvm::Linkage) {\n+                    linkage: llvm::Linkage,\n+                    symbol_name: &str) {\n         assert!(!instance.substs.types.needs_infer() &&\n                 !instance.substs.types.has_param_types());\n \n@@ -186,10 +188,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             hir_map::NodeImplItem(&hir::ImplItem {\n                 ref attrs, node: hir::ImplItemKind::Method(..), ..\n             }) => {\n-                let symbol = instance.symbol_name(ccx.shared());\n-                debug!(\"symbol {}\", symbol);\n-\n-                let lldecl = declare::declare_fn(ccx, &symbol, mono_ty);\n+                let lldecl = declare::declare_fn(ccx, symbol_name, mono_ty);\n                 llvm::SetLinkage(lldecl, linkage);\n                 attributes::from_fn_attrs(ccx, attrs, lldecl);\n                 base::set_link_section(ccx, lldecl, attrs);\n@@ -203,7 +202,8 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n     fn predefine_drop_glue(ccx: &CrateContext<'a, 'tcx>,\n                            dg: glue::DropGlueKind<'tcx>,\n-                           linkage: llvm::Linkage) {\n+                           linkage: llvm::Linkage,\n+                           symbol_name: &str) {\n         let tcx = ccx.tcx();\n         assert_eq!(dg.ty(), glue::get_drop_glue_type(tcx, dg.ty()));\n         let t = dg.ty();\n@@ -220,21 +220,31 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         fn_ty.args[0].original_ty = type_of::type_of(ccx, t).ptr_to();\n         let llfnty = fn_ty.llvm_type(ccx);\n \n-        let prefix = match dg {\n-            DropGlueKind::Ty(_) => \"drop\",\n-            DropGlueKind::TyContents(_) => \"drop_contents\",\n-        };\n-\n-        let symbol =\n-            symbol_names::exported_name_from_type_and_prefix(ccx.shared(), t, prefix);\n-        debug!(\" symbol: {}\", symbol);\n-        assert!(declare::get_defined_value(ccx, &symbol).is_none());\n-        let llfn = declare::declare_cfn(ccx, &symbol, llfnty);\n+        assert!(declare::get_defined_value(ccx, symbol_name).is_none());\n+        let llfn = declare::declare_cfn(ccx, symbol_name, llfnty);\n+\tllvm::SetLinkage(llfn, linkage);\n         attributes::set_frame_pointer_elimination(ccx, llfn);\n-        llvm::SetLinkage(llfn, linkage);\n         ccx.drop_glues().borrow_mut().insert(dg, (llfn, fn_ty));\n     }\n \n+    pub fn compute_symbol_name(&self,\n+                               scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+        match *self {\n+            TransItem::Fn(instance) => instance.symbol_name(scx),\n+            TransItem::Static(node_id) => {\n+                let def_id = scx.tcx().map.local_def_id(node_id);\n+                Instance::mono(scx, def_id).symbol_name(scx)\n+            }\n+            TransItem::DropGlue(dg) => {\n+                let prefix = match dg {\n+                    DropGlueKind::Ty(_) => \"drop\",\n+                    DropGlueKind::TyContents(_) => \"drop_contents\",\n+                };\n+                symbol_names::exported_name_from_type_and_prefix(scx, dg.ty(), prefix)\n+            }\n+        }\n+    }\n+\n     pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {"}]}