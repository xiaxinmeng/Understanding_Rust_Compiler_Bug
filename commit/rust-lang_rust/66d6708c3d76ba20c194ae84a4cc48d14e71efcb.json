{"sha": "66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZDY3MDhjM2Q3NmJhMjBjMTk0YWU4NGE0Y2M0OGQxNGU3MWVmY2I=", "commit": {"author": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-10-07T22:08:01Z"}, "committer": {"name": "Waffle", "email": "waffle.lapkin@gmail.com", "date": "2020-11-21T23:39:21Z"}, "message": "Split iterator sources into different modules", "tree": {"sha": "c872a9a160ddc395af9c8020a749cf6e61de4e25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c872a9a160ddc395af9c8020a749cf6e61de4e25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "html_url": "https://github.com/rust-lang/rust/commit/66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "773b73c66c653f66ae056cecf9798de0686ef4ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/773b73c66c653f66ae056cecf9798de0686ef4ad", "html_url": "https://github.com/rust-lang/rust/commit/773b73c66c653f66ae056cecf9798de0686ef4ad"}], "stats": {"total": 1258, "additions": 644, "deletions": 614}, "files": [{"sha": "de0663141e25274cb5e95d1039047e58297c60a7", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 16, "deletions": 614, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -1,625 +1,27 @@\n-use crate::fmt;\n-use crate::marker;\n+mod empty;\n+mod from_fn;\n+mod once;\n+mod once_with;\n+mod repeat;\n+mod repeat_with;\n+mod successors;\n \n-use super::{FusedIterator, TrustedLen};\n+pub use self::repeat::{repeat, Repeat};\n \n-/// An iterator that repeats an element endlessly.\n-///\n-/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Repeat<A> {\n-    element: A,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Iterator for Repeat<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A: Clone> FusedIterator for Repeat<A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n-\n-/// Creates a new iterator that endlessly repeats a single element.\n-///\n-/// The `repeat()` function repeats a single value over and over again.\n-///\n-/// Infinite iterators like `repeat()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need does not implement `Clone`,\n-/// or if you do not want to keep the repeated element in memory, you can\n-/// instead use the [`repeat_with()`] function.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // the number four 4ever:\n-/// let mut fours = iter::repeat(4);\n-///\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-///\n-/// // yup, still four\n-/// assert_eq!(Some(4), fours.next());\n-/// ```\n-///\n-/// Going finite with [`Iterator::take()`]:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // that last example was too many fours. Let's only have four fours.\n-/// let mut four_fours = iter::repeat(4).take(4);\n-///\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, four_fours.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat { element: elt }\n-}\n-\n-/// An iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure `F: FnMut() -> A`.\n-///\n-/// This `struct` is created by the [`repeat_with()`] function.\n-/// See its documentation for more.\n-#[derive(Copy, Clone, Debug)]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub struct RepeatWith<F> {\n-    repeater: F,\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some((self.repeater)())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n-\n-/// Creates a new iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n-///\n-/// The `repeat_with()` function calls the repeater over and over again.\n-///\n-/// Infinite iterators like `repeat_with()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need implements [`Clone`], and\n-/// it is OK to keep the source element in memory, you should instead use\n-/// the [`repeat()`] function.\n-///\n-/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n-/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n-/// please open a GitHub issue explaining your use case.\n-///\n-/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // let's assume we have some value of a type that is not `Clone`\n-/// // or which don't want to have in memory just yet because it is expensive:\n-/// #[derive(PartialEq, Debug)]\n-/// struct Expensive;\n-///\n-/// // a particular value forever:\n-/// let mut things = iter::repeat_with(|| Expensive);\n-///\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// ```\n-///\n-/// Using mutation and going finite:\n-///\n-/// ```rust\n-/// use std::iter;\n-///\n-/// // From the zeroth to the third power of two:\n-/// let mut curr = 1;\n-/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n-///                     .take(4);\n-///\n-/// assert_eq!(Some(1), pow2.next());\n-/// assert_eq!(Some(2), pow2.next());\n-/// assert_eq!(Some(4), pow2.next());\n-/// assert_eq!(Some(8), pow2.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, pow2.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n-    RepeatWith { repeater }\n-}\n-\n-/// An iterator that yields nothing.\n-///\n-/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub struct Empty<T>(marker::PhantomData<T>);\n-\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Send for Empty<T> {}\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Sync for Empty<T> {}\n+pub use self::empty::{empty, Empty};\n \n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<T> fmt::Debug for Empty<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"Empty\")\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Iterator for Empty<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(0))\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Empty<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        None\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Empty<T> {\n-    fn len(&self) -> usize {\n-        0\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Empty<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Empty<T> {}\n-\n-// not #[derive] because that adds a Clone bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Clone for Empty<T> {\n-    fn clone(&self) -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-// not #[derive] because that adds a Default bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Default for Empty<T> {\n-    fn default() -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-/// Creates an iterator that yields nothing.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // this could have been an iterator over i32, but alas, it's just not.\n-/// let mut nope = iter::empty::<i32>();\n-///\n-/// assert_eq!(None, nope.next());\n-/// ```\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n-pub const fn empty<T>() -> Empty<T> {\n-    Empty(marker::PhantomData)\n-}\n-\n-/// An iterator that yields an element exactly once.\n-///\n-/// This `struct` is created by the [`once()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>,\n-}\n+pub use self::once::{once, Once};\n \n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> Iterator for Once<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.inner.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Once<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Once<T> {\n-    fn len(&self) -> usize {\n-        self.inner.len()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Once<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Once<T> {}\n-\n-/// Creates an iterator that yields an element exactly once.\n-///\n-/// This is commonly used to adapt a single value into a [`chain()`] of other\n-/// kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once(1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once(PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub fn once<T>(value: T) -> Once<T> {\n-    Once { inner: Some(value).into_iter() }\n-}\n-\n-/// An iterator that yields a single element of type `A` by\n-/// applying the provided closure `F: FnOnce() -> A`.\n-///\n-/// This `struct` is created by the [`once_with()`] function.\n-/// See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub struct OnceWith<F> {\n-    gen: Option<F>,\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let f = self.gen.take()?;\n-        Some(f())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.gen.iter().size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n-    fn next_back(&mut self) -> Option<A> {\n-        self.next()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n-    fn len(&self) -> usize {\n-        self.gen.iter().len()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n-\n-/// Creates an iterator that lazily generates a value exactly once by invoking\n-/// the provided closure.\n-///\n-/// This is commonly used to adapt a single value generator into a [`chain()`] of\n-/// other kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// Unlike [`once()`], this function will lazily generate the value on request.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once_with(|| 1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n-    OnceWith { gen: Some(gen) }\n-}\n-\n-/// Creates a new iterator where each iteration calls the provided closure\n-/// `F: FnMut() -> Option<T>`.\n-///\n-/// This allows creating a custom iterator with any behavior\n-/// without using the more verbose syntax of creating a dedicated type\n-/// and implementing the [`Iterator`] trait for it.\n-///\n-/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n-/// and therefore conservatively does not implement [`FusedIterator`],\n-/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n-///\n-/// The closure can use captures and its environment to track state across iterations. Depending on\n-/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n-///\n-/// [`move`]: ../../std/keyword.move.html\n-///\n-/// # Examples\n-///\n-/// Let\u2019s re-implement the counter iterator from the [module-level documentation]:\n-///\n-/// [module-level documentation]: super\n-///\n-/// ```\n-/// let mut count = 0;\n-/// let counter = std::iter::from_fn(move || {\n-///     // Increment our count. This is why we started at zero.\n-///     count += 1;\n-///\n-///     // Check to see if we've finished counting or not.\n-///     if count < 6 {\n-///         Some(count)\n-///     } else {\n-///         None\n-///     }\n-/// });\n-/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    FromFn(f)\n-}\n-\n-/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n-///\n-/// This `struct` is created by the [`iter::from_fn()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::from_fn()`]: from_fn\n-#[derive(Clone)]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub struct FromFn<F>(F);\n-\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<T, F> Iterator for FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        (self.0)()\n-    }\n-}\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub use self::repeat_with::{repeat_with, RepeatWith};\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<F> fmt::Debug for FromFn<F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FromFn\").finish()\n-    }\n-}\n+pub use self::from_fn::{from_fn, FromFn};\n \n-/// Creates a new iterator where each successive item is computed based on the preceding one.\n-///\n-/// The iterator starts with the given first item (if any)\n-/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n-///\n-/// ```\n-/// use std::iter::successors;\n-///\n-/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n-/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n-/// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    // If this function returned `impl Iterator<Item=T>`\n-    // it could be based on `unfold` and not need a dedicated type.\n-    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors { next: first, succ }\n-}\n+pub use self::successors::{successors, Successors};\n \n-/// An new iterator where each successive item is computed based on the preceding one.\n-///\n-/// This `struct` is created by the [`iter::successors()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::successors()`]: successors\n-#[derive(Clone)]\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub struct Successors<T, F> {\n-    next: Option<T>,\n-    succ: F,\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> Iterator for Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let item = self.next.take()?;\n-        self.next = (self.succ)(&item);\n-        Some(item)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n-    }\n-}\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub use self::once_with::{once_with, OnceWith};"}, {"sha": "364c8394d83047a0839c770a7274b1824968512f", "filename": "library/core/src/iter/sources/empty.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,90 @@\n+use crate::{fmt, iter::{FusedIterator, TrustedLen}, marker};\n+\n+/// Creates an iterator that yields nothing.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n+pub const fn empty<T>() -> Empty<T> {\n+    Empty(marker::PhantomData)\n+}\n+\n+/// An iterator that yields nothing.\n+///\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub struct Empty<T>(marker::PhantomData<T>);\n+\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Send for Empty<T> {}\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Sync for Empty<T> {}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Iterator for Empty<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Empty<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Empty<T> {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Empty<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Empty<T> {}\n+\n+// not #[derive] because that adds a Clone bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Clone for Empty<T> {\n+    fn clone(&self) -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+// not #[derive] because that adds a Default bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Default for Empty<T> {\n+    fn default() -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}"}, {"sha": "f646aa236a17fc719c7020a81bb4fb8776a7be07", "filename": "library/core/src/iter/sources/from_fn.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,77 @@\n+use crate::fmt;\n+\n+/// Creates a new iterator where each iteration calls the provided closure\n+/// `F: FnMut() -> Option<T>`.\n+///\n+/// This allows creating a custom iterator with any behavior\n+/// without using the more verbose syntax of creating a dedicated type\n+/// and implementing the [`Iterator`] trait for it.\n+///\n+/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n+/// and therefore conservatively does not implement [`FusedIterator`],\n+/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n+///\n+/// The closure can use captures and its environment to track state across iterations. Depending on\n+/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n+///\n+/// [`move`]: ../../std/keyword.move.html\n+///\n+/// # Examples\n+///\n+/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+///\n+/// [module-level documentation]: crate::iter\n+///\n+/// ```\n+/// let mut count = 0;\n+/// let counter = std::iter::from_fn(move || {\n+///     // Increment our count. This is why we started at zero.\n+///     count += 1;\n+///\n+///     // Check to see if we've finished counting or not.\n+///     if count < 6 {\n+///         Some(count)\n+///     } else {\n+///         None\n+///     }\n+/// });\n+/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub fn from_fn<T, F>(f: F) -> FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    FromFn(f)\n+}\n+\n+/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n+///\n+/// This `struct` is created by the [`iter::from_fn()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::from_fn()`]: from_fn\n+#[derive(Clone)]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub struct FromFn<F>(F);\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<T, F> Iterator for FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.0)()\n+    }\n+}\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<F> fmt::Debug for FromFn<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FromFn\").finish()\n+    }\n+}"}, {"sha": "27bc3dcfd79e092c40765099519d3aee6a242e0a", "filename": "library/core/src/iter/sources/once.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,99 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: Iterator::chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub fn once<T>(value: T) -> Once<T> {\n+    Once { inner: Some(value).into_iter() }\n+}\n+\n+/// An iterator that yields an element exactly once.\n+///\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub struct Once<T> {\n+    inner: crate::option::IntoIter<T>,\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> Iterator for Once<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Once<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Once<T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Once<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Once<T> {}"}, {"sha": "36f476a574aae5f3eee48af476c9ccda699f87e6", "filename": "library/core/src/iter/sources/once_with.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,108 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that lazily generates a value exactly once by invoking\n+/// the provided closure.\n+///\n+/// This is commonly used to adapt a single value generator into a [`chain()`] of\n+/// other kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// Unlike [`once()`], this function will lazily generate the value on request.\n+///\n+/// [`chain()`]: Iterator::chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once_with(|| 1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n+    OnceWith { gen: Some(gen) }\n+}\n+\n+/// An iterator that yields a single element of type `A` by\n+/// applying the provided closure `F: FnOnce() -> A`.\n+///\n+/// This `struct` is created by the [`once_with()`] function.\n+/// See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub struct OnceWith<F> {\n+    gen: Option<F>,\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let f = self.gen.take()?;\n+        Some(f())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.gen.iter().size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n+    fn next_back(&mut self) -> Option<A> {\n+        self.next()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n+    fn len(&self) -> usize {\n+        self.gen.iter().len()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}"}, {"sha": "8448626ce94c05decf4227d87583c055383e3254", "filename": "library/core/src/iter/sources/repeat.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,91 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over again.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need does not implement `Clone`,\n+/// or if you do not want to keep the repeated element in memory, you can\n+/// instead use the [`repeat_with()`] function.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`Iterator::take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+    Repeat { element: elt }\n+}\n+\n+/// An iterator that repeats an element endlessly.\n+///\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Repeat<A> {\n+    element: A,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A: Clone> FusedIterator for Repeat<A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Clone> TrustedLen for Repeat<A> {}"}, {"sha": "7e2d134368f0fce0dd0d17db245a303003e51912", "filename": "library/core/src/iter/sources/repeat_with.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,97 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n+///\n+/// The `repeat_with()` function calls the repeater over and over again.\n+///\n+/// Infinite iterators like `repeat_with()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need implements [`Clone`], and\n+/// it is OK to keep the source element in memory, you should instead use\n+/// the [`repeat()`] function.\n+///\n+/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n+/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n+/// please open a GitHub issue explaining your use case.\n+///\n+/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // let's assume we have some value of a type that is not `Clone`\n+/// // or which don't want to have in memory just yet because it is expensive:\n+/// #[derive(PartialEq, Debug)]\n+/// struct Expensive;\n+///\n+/// // a particular value forever:\n+/// let mut things = iter::repeat_with(|| Expensive);\n+///\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// ```\n+///\n+/// Using mutation and going finite:\n+///\n+/// ```rust\n+/// use std::iter;\n+///\n+/// // From the zeroth to the third power of two:\n+/// let mut curr = 1;\n+/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+///                     .take(4);\n+///\n+/// assert_eq!(Some(1), pow2.next());\n+/// assert_eq!(Some(2), pow2.next());\n+/// assert_eq!(Some(4), pow2.next());\n+/// assert_eq!(Some(8), pow2.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, pow2.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n+    RepeatWith { repeater }\n+}\n+\n+/// An iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure `F: FnMut() -> A`.\n+///\n+/// This `struct` is created by the [`repeat_with()`] function.\n+/// See its documentation for more.\n+#[derive(Copy, Clone, Debug)]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub struct RepeatWith<F> {\n+    repeater: F,\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}"}, {"sha": "99f058a901a3103f3c8e069a4cebd54d88ccf076", "filename": "library/core/src/iter/sources/successors.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66d6708c3d76ba20c194ae84a4cc48d14e71efcb/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs?ref=66d6708c3d76ba20c194ae84a4cc48d14e71efcb", "patch": "@@ -0,0 +1,66 @@\n+use crate::{fmt, iter::FusedIterator};\n+\n+/// Creates a new iterator where each successive item is computed based on the preceding one.\n+///\n+/// The iterator starts with the given first item (if any)\n+/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n+///\n+/// ```\n+/// use std::iter::successors;\n+///\n+/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+/// ```\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    // If this function returned `impl Iterator<Item=T>`\n+    // it could be based on `unfold` and not need a dedicated type.\n+    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n+    Successors { next: first, succ }\n+}\n+\n+/// An new iterator where each successive item is computed based on the preceding one.\n+///\n+/// This `struct` is created by the [`iter::successors()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::successors()`]: successors\n+#[derive(Clone)]\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub struct Successors<T, F> {\n+    next: Option<T>,\n+    succ: F,\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> Iterator for Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n+    }\n+}"}]}