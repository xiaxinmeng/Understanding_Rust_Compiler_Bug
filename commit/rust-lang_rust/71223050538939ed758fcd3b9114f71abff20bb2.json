{"sha": "71223050538939ed758fcd3b9114f71abff20bb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMjIzMDUwNTM4OTM5ZWQ3NThmY2QzYjkxMTRmNzFhYmZmMjBiYjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-27T17:38:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-27T23:05:04Z"}, "message": "Merge remote-tracking branch 'rust-lang/master'\n\nConflicts:\n\tsrc/libcore/cell.rs\n\tsrc/librustc_driver/test.rs\n\tsrc/libstd/old_io/net/tcp.rs\n\tsrc/libstd/old_io/process.rs", "tree": {"sha": "43ddd18223904fa86601f1a0e16ebcbaddead270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ddd18223904fa86601f1a0e16ebcbaddead270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71223050538939ed758fcd3b9114f71abff20bb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71223050538939ed758fcd3b9114f71abff20bb2", "html_url": "https://github.com/rust-lang/rust/commit/71223050538939ed758fcd3b9114f71abff20bb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71223050538939ed758fcd3b9114f71abff20bb2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c172392cf0c86ffd1d7b39d3f44de98f77afc44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c172392cf0c86ffd1d7b39d3f44de98f77afc44", "html_url": "https://github.com/rust-lang/rust/commit/3c172392cf0c86ffd1d7b39d3f44de98f77afc44"}, {"sha": "777435990e0e91df6b72ce80c9b6fa485eeb5daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/777435990e0e91df6b72ce80c9b6fa485eeb5daa", "html_url": "https://github.com/rust-lang/rust/commit/777435990e0e91df6b72ce80c9b6fa485eeb5daa"}], "stats": {"total": 3322, "additions": 1891, "deletions": 1431}, "files": [{"sha": "eedff1d11760ca70ac9160593dc5ae4b9779f9a8", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -32,8 +32,8 @@ extern crate getopts;\n extern crate log;\n \n use std::os;\n-use std::io;\n-use std::io::fs;\n+use std::old_io;\n+use std::old_io::fs;\n use std::str::FromStr;\n use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n@@ -245,7 +245,7 @@ pub fn run_tests(config: &Config) {\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n-    io::test::raise_fd_limit();\n+    old_io::test::raise_fd_limit();\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n     os::setenv(\"__COMPAT_LAYER\", \"RunAsInvoker\");"}, {"sha": "868512c7943fa98be841c60dd74a3a5d738a11a7", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n use self::WhichLine::*;\n \n-use std::io::{BufferedReader, File};\n+use std::old_io::{BufferedReader, File};\n \n pub struct ExpectedError {\n     pub line: uint,"}, {"sha": "8458d880d05a180a447dac49c54756abe6f259fa", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -223,7 +223,7 @@ pub fn is_test_ignored(config: &Config, testfile: &Path) -> bool {\n fn iter_header<F>(testfile: &Path, mut it: F) -> bool where\n     F: FnMut(&str) -> bool,\n {\n-    use std::io::{BufferedReader, File};\n+    use std::old_io::{BufferedReader, File};\n \n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n     for ln in rdr.lines() {"}, {"sha": "7f3865308da1ec158f73d854822b7db565fa893f", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::process::{ProcessExit, Command, Process, ProcessOutput};\n+use std::old_io::process::{ProcessExit, Command, Process, ProcessOutput};\n use std::dynamic_lib::DynamicLibrary;\n \n fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n@@ -47,7 +47,7 @@ pub fn run(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n             let ProcessOutput { status, output, error } =\n                 process.wait_with_output().unwrap();\n@@ -79,7 +79,7 @@ pub fn run_background(lib_path: &str,\n     match cmd.spawn() {\n         Ok(mut process) => {\n             for input in input.iter() {\n-                process.stdin.as_mut().unwrap().write(input.as_bytes()).unwrap();\n+                process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n             }\n \n             Some(process)"}, {"sha": "0ae32bd00a4a101876f08509049c508f33812998", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -23,14 +23,14 @@ use util;\n \n #[cfg(target_os = \"windows\")]\n use std::ascii::AsciiExt;\n-use std::io::File;\n-use std::io::fs::PathExtensions;\n-use std::io::fs;\n-use std::io::net::tcp;\n-use std::io::process::ProcessExit;\n-use std::io::process;\n-use std::io::timer;\n-use std::io;\n+use std::old_io::File;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::fs;\n+use std::old_io::net::tcp;\n+use std::old_io::process::ProcessExit;\n+use std::old_io::process;\n+use std::old_io::timer;\n+use std::old_io;\n use std::os;\n use std::iter::repeat;\n use std::str;\n@@ -619,7 +619,7 @@ fn find_rust_src_root(config: &Config) -> Option<Path> {\n }\n \n fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path) {\n-    use std::io::process::{Command, ProcessOutput};\n+    use std::old_io::process::{Command, ProcessOutput};\n \n     if config.lldb_python_dir.is_none() {\n         fatal(\"Can't run LLDB test because LLDB's python path is not set.\");\n@@ -764,7 +764,7 @@ struct DebuggerCommands {\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                            -> DebuggerCommands {\n-    use std::io::{BufferedReader, File};\n+    use std::old_io::{BufferedReader, File};\n \n     let command_directive = format!(\"{}-command\", debugger_prefix);\n     let check_directive = format!(\"{}-check\", debugger_prefix);\n@@ -1224,7 +1224,7 @@ fn compose_and_run_compiler(\n \n fn ensure_dir(path: &Path) {\n     if path.is_dir() { return; }\n-    fs::mkdir(path, io::USER_RWX).unwrap();\n+    fs::mkdir(path, old_io::USER_RWX).unwrap();\n }\n \n fn compose_and_run(config: &Config, testfile: &Path,\n@@ -1401,7 +1401,7 @@ fn dump_output(config: &Config, testfile: &Path, out: &str, err: &str) {\n fn dump_output_file(config: &Config, testfile: &Path,\n                     out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n-    File::create(&outfile).write(out.as_bytes()).unwrap();\n+    File::create(&outfile).write_all(out.as_bytes()).unwrap();\n }\n \n fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {"}, {"sha": "f01b62223ca813b7123cb76e360b2ac850e4e0cc", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -75,14 +75,14 @@ Let's get to it! The first thing we need to do for our guessing game is\n allow our player to input a guess. Put this in your `src/main.rs`:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n \n fn main() {\n     println!(\"Guess the number!\");\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -121,7 +121,7 @@ explanatory text, and then an example. Let's try to modify our code to add in th\n `random` function and see what happens:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n use std::rand;\n \n fn main() {\n@@ -133,7 +133,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -180,7 +180,7 @@ This says \"please give me a random `i32` value.\" We can change our code to use\n this hint:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n \n fn main() {\n@@ -192,7 +192,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -233,7 +233,7 @@ unsigned integer approach. If we want a random positive number, we should ask fo\n a random positive number. Our code looks like this now:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n \n fn main() {\n@@ -245,7 +245,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -276,7 +276,7 @@ two numbers. Let's add that in, along with a `match` statement to compare our\n guess to the secret number:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -289,7 +289,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -331,7 +331,7 @@ but we've given it unsigned integers. In this case, the fix is easy, because\n we wrote the `cmp` function! Let's change it to take `u32`s:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -344,7 +344,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n \n@@ -397,7 +397,7 @@ Anyway, we have a `String`, but we need a `u32`. What to do? Well, there's\n a function for that:\n \n ```{rust,ignore}\n-let input = io::stdin().read_line()\n+let input = old_io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n let input_num: Option<u32> = input.parse();\n@@ -429,7 +429,7 @@ let input_num: Option<u32> = \"5\".parse(); // input_num: Option<u32>\n Anyway, with us now converting our input to a number, our code looks like this:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -442,7 +442,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n     let input_num: Option<u32> = input.parse();\n@@ -479,7 +479,7 @@ need to unwrap the Option. If you remember from before, `match` is a great way\n to do that. Try this code:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -492,7 +492,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n     let input_num: Option<u32> = input.parse();\n@@ -546,7 +546,7 @@ method we can use defined on them: `trim()`. One small modification, and our\n code looks like this:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -559,7 +559,7 @@ fn main() {\n \n     println!(\"Please input your guess.\");\n \n-    let input = io::stdin().read_line()\n+    let input = old_io::stdin().read_line()\n                            .ok()\n                            .expect(\"Failed to read line\");\n     let input_num: Option<u32> = input.trim().parse();\n@@ -620,7 +620,7 @@ As we already discussed, the `loop` keyword gives us an infinite loop.\n Let's add that in:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -635,7 +635,7 @@ fn main() {\n \n         println!(\"Please input your guess.\");\n \n-        let input = io::stdin().read_line()\n+        let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n         let input_num: Option<u32> = input.trim().parse();\n@@ -696,7 +696,7 @@ Ha! `quit` actually quits. As does any other non-number input. Well, this is\n suboptimal to say the least. First, let's actually quit when you win the game:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -711,7 +711,7 @@ fn main() {\n \n         println!(\"Please input your guess.\");\n \n-        let input = io::stdin().read_line()\n+        let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n         let input_num: Option<u32> = input.trim().parse();\n@@ -752,7 +752,7 @@ we don't want to quit, we just want to ignore it. Change that `return` to\n \n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -767,7 +767,7 @@ fn main() {\n \n         println!(\"Please input your guess.\");\n \n-        let input = io::stdin().read_line()\n+        let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n         let input_num: Option<u32> = input.trim().parse();\n@@ -831,7 +831,7 @@ think of what it is? That's right, we don't want to print out the secret number.\n It was good for testing, but it kind of ruins the game. Here's our final source:\n \n ```{rust,no_run}\n-use std::io;\n+use std::old_io;\n use std::rand;\n use std::cmp::Ordering;\n \n@@ -844,7 +844,7 @@ fn main() {\n \n         println!(\"Please input your guess.\");\n \n-        let input = io::stdin().read_line()\n+        let input = old_io::stdin().read_line()\n                                .ok()\n                                .expect(\"Failed to read line\");\n         let input_num: Option<u32> = input.trim().parse();"}, {"sha": "0c26fb2b44fa4d9509df78a791a6c5b84b9894f8", "filename": "src/doc/trpl/standard-input.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fdoc%2Ftrpl%2Fstandard-input.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstandard-input.md?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@ and then prints it back out:\n fn main() {\n     println!(\"Type something!\");\n \n-    let input = std::io::stdin().read_line().ok().expect(\"Failed to read line\");\n+    let input = std::old_io::stdin().read_line().ok().expect(\"Failed to read line\");\n \n     println!(\"{}\", input);\n }\n@@ -17,7 +17,7 @@ fn main() {\n Let's go over these chunks, one by one:\n \n ```{rust,ignore}\n-std::io::stdin();\n+std::old_io::stdin();\n ```\n \n This calls a function, `stdin()`, that lives inside the `std::io` module. As\n@@ -28,7 +28,7 @@ Since writing the fully qualified name all the time is annoying, we can use\n the `use` statement to import it in:\n \n ```{rust}\n-use std::io::stdin;\n+use std::old_io::stdin;\n \n stdin();\n ```\n@@ -37,20 +37,20 @@ However, it's considered better practice to not import individual functions, but\n to import the module, and only use one level of qualification:\n \n ```{rust}\n-use std::io;\n+use std::old_io;\n \n-io::stdin();\n+old_io::stdin();\n ```\n \n Let's update our example to use this style:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n \n fn main() {\n     println!(\"Type something!\");\n \n-    let input = io::stdin().read_line().ok().expect(\"Failed to read line\");\n+    let input = old_io::stdin().read_line().ok().expect(\"Failed to read line\");\n \n     println!(\"{}\", input);\n }\n@@ -121,12 +121,12 @@ For now, this gives you enough of a basic understanding to work with.\n Back to the code we were working on! Here's a refresher:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n \n fn main() {\n     println!(\"Type something!\");\n \n-    let input = io::stdin().read_line().ok().expect(\"Failed to read line\");\n+    let input = old_io::stdin().read_line().ok().expect(\"Failed to read line\");\n \n     println!(\"{}\", input);\n }\n@@ -136,14 +136,14 @@ With long lines like this, Rust gives you some flexibility with the whitespace.\n We _could_ write the example like this:\n \n ```{rust,ignore}\n-use std::io;\n+use std::old_io;\n \n fn main() {\n     println!(\"Type something!\");\n \n     // here, we'll show the types at each step\n \n-    let input = io::stdin() // std::io::stdio::StdinReader\n+    let input = old_io::stdin() // std::old_io::stdio::StdinReader\n                   .read_line() // IoResult<String>\n                   .ok() // Option<String>\n                   .expect(\"Failed to read line\"); // String"}, {"sha": "02cc4038a69bc7b140bcf527a81d58d87bb4374a", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 209, "deletions": 84, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,55 +10,44 @@\n \n //! Shareable mutable containers.\n //!\n-//! Values of the `Cell` and `RefCell` types may be mutated through\n-//! shared references (i.e. the common `&T` type), whereas most Rust\n-//! types can only be mutated through unique (`&mut T`) references. We\n-//! say that `Cell` and `RefCell` provide *interior mutability*, in\n-//! contrast with typical Rust types that exhibit *inherited\n-//! mutability*.\n+//! Values of the `Cell<T>` and `RefCell<T>` types may be mutated through shared references (i.e.\n+//! the common `&T` type), whereas most Rust types can only be mutated through unique (`&mut T`)\n+//! references. We say that `Cell<T>` and `RefCell<T>` provide 'interior mutability', in contrast\n+//! with typical Rust types that exhibit 'inherited mutability'.\n //!\n-//! Cell types come in two flavors: `Cell` and `RefCell`. `Cell`\n-//! provides `get` and `set` methods that change the\n-//! interior value with a single method call. `Cell` though is only\n-//! compatible with types that implement `Copy`. For other types,\n-//! one must use the `RefCell` type, acquiring a write lock before\n-//! mutating.\n+//! Cell types come in two flavors: `Cell<T>` and `RefCell<T>`. `Cell<T>` provides `get` and `set`\n+//! methods that change the interior value with a single method call. `Cell<T>` though is only\n+//! compatible with types that implement `Copy`. For other types, one must use the `RefCell<T>`\n+//! type, acquiring a write lock before mutating.\n //!\n-//! `RefCell` uses Rust's lifetimes to implement *dynamic borrowing*,\n-//! a process whereby one can claim temporary, exclusive, mutable\n-//! access to the inner value. Borrows for `RefCell`s are tracked *at\n-//! runtime*, unlike Rust's native reference types which are entirely\n-//! tracked statically, at compile time. Because `RefCell` borrows are\n-//! dynamic it is possible to attempt to borrow a value that is\n-//! already mutably borrowed; when this happens it results in task\n-//! panic.\n+//! `RefCell<T>` uses Rust's lifetimes to implement 'dynamic borrowing', a process whereby one can\n+//! claim temporary, exclusive, mutable access to the inner value. Borrows for `RefCell<T>`s are\n+//! tracked 'at runtime', unlike Rust's native reference types which are entirely tracked\n+//! statically, at compile time. Because `RefCell<T>` borrows are dynamic it is possible to attempt\n+//! to borrow a value that is already mutably borrowed; when this happens it results in task panic.\n //!\n //! # When to choose interior mutability\n //!\n-//! The more common inherited mutability, where one must have unique\n-//! access to mutate a value, is one of the key language elements that\n-//! enables Rust to reason strongly about pointer aliasing, statically\n-//! preventing crash bugs. Because of that, inherited mutability is\n-//! preferred, and interior mutability is something of a last\n-//! resort. Since cell types enable mutation where it would otherwise\n-//! be disallowed though, there are occasions when interior\n-//! mutability might be appropriate, or even *must* be used, e.g.\n+//! The more common inherited mutability, where one must have unique access to mutate a value, is\n+//! one of the key language elements that enables Rust to reason strongly about pointer aliasing,\n+//! statically preventing crash bugs. Because of that, inherited mutability is preferred, and\n+//! interior mutability is something of a last resort. Since cell types enable mutation where it\n+//! would otherwise be disallowed though, there are occasions when interior mutability might be\n+//! appropriate, or even *must* be used, e.g.\n //!\n //! * Introducing inherited mutability roots to shared types.\n //! * Implementation details of logically-immutable methods.\n //! * Mutating implementations of `clone`.\n //!\n //! ## Introducing inherited mutability roots to shared types\n //!\n-//! Shared smart pointer types, including `Rc` and `Arc`, provide\n-//! containers that can be cloned and shared between multiple parties.\n-//! Because the contained values may be multiply-aliased, they can\n-//! only be borrowed as shared references, not mutable references.\n-//! Without cells it would be impossible to mutate data inside of\n-//! shared boxes at all!\n+//! Shared smart pointer types, including `Rc<T>` and `Arc<T>`, provide containers that can be\n+//! cloned and shared between multiple parties. Because the contained values may be\n+//! multiply-aliased, they can only be borrowed as shared references, not mutable references.\n+//! Without cells it would be impossible to mutate data inside of shared boxes at all!\n //!\n-//! It's very common then to put a `RefCell` inside shared pointer\n-//! types to reintroduce mutability:\n+//! It's very common then to put a `RefCell<T>` inside shared pointer types to reintroduce\n+//! mutability:\n //!\n //! ```\n //! use std::collections::HashMap;\n@@ -80,12 +69,10 @@\n //!\n //! ## Implementation details of logically-immutable methods\n //!\n-//! Occasionally it may be desirable not to expose in an API that\n-//! there is mutation happening \"under the hood\". This may be because\n-//! logically the operation is immutable, but e.g. caching forces the\n-//! implementation to perform mutation; or because you must employ\n-//! mutation to implement a trait method that was originally defined\n-//! to take `&self`.\n+//! Occasionally it may be desirable not to expose in an API that there is mutation happening\n+//! \"under the hood\". This may be because logically the operation is immutable, but e.g. caching\n+//! forces the implementation to perform mutation; or because you must employ mutation to implement\n+//! a trait method that was originally defined to take `&self`.\n //!\n //! ```\n //! use std::cell::RefCell;\n@@ -123,13 +110,11 @@\n //!\n //! ## Mutating implementations of `clone`\n //!\n-//! This is simply a special - but common - case of the previous:\n-//! hiding mutability for operations that appear to be immutable.\n-//! The `clone` method is expected to not change the source value, and\n-//! is declared to take `&self`, not `&mut self`. Therefore any\n-//! mutation that happens in the `clone` method must use cell\n-//! types. For example, `Rc` maintains its reference counts within a\n-//! `Cell`.\n+//! This is simply a special - but common - case of the previous: hiding mutability for operations\n+//! that appear to be immutable. The `clone` method is expected to not change the source value, and\n+//! is declared to take `&self`, not `&mut self`. Therefore any mutation that happens in the\n+//! `clone` method must use cell types. For example, `Rc<T>` maintains its reference counts within a\n+//! `Cell<T>`.\n //!\n //! ```\n //! use std::cell::Cell;\n@@ -153,10 +138,6 @@\n //! }\n //! ```\n //!\n-// FIXME: Explain difference between Cell and RefCell\n-// FIXME: Downsides to interior mutability\n-// FIXME: Can't be shared between threads. Dynamic borrows\n-// FIXME: Relationship to Atomic types and RWLock\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -169,13 +150,23 @@ use option::Option;\n use option::Option::{None, Some};\n \n /// A mutable memory location that admits only `Copy` data.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {\n     value: UnsafeCell<T>,\n }\n \n impl<T:Copy> Cell<T> {\n     /// Creates a new `Cell` containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Cell<T> {\n         Cell {\n@@ -184,13 +175,33 @@ impl<T:Copy> Cell<T> {\n     }\n \n     /// Returns a copy of the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let five = c.get();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n         unsafe{ *self.value.get() }\n     }\n \n     /// Sets the contained value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// c.set(10);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set(&self, value: T) {\n@@ -201,9 +212,19 @@ impl<T:Copy> Cell<T> {\n \n     /// Get a reference to the underlying `UnsafeCell`.\n     ///\n-    /// This can be used to circumvent `Cell`'s safety checks.\n+    /// # Unsafety\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::Cell;\n+    ///\n+    /// let c = Cell::new(5);\n+    ///\n+    /// let uc = unsafe { c.as_unsafe_cell() };\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n@@ -237,6 +258,8 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n }\n \n /// A mutable memory location with dynamically checked borrow rules\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T> {\n     value: UnsafeCell<T>,\n@@ -250,7 +273,15 @@ const UNUSED: BorrowFlag = 0;\n const WRITING: BorrowFlag = -1;\n \n impl<T> RefCell<T> {\n-    /// Create a new `RefCell` containing `value`\n+    /// Creates a new `RefCell` containing `value`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> RefCell<T> {\n         RefCell {\n@@ -260,6 +291,16 @@ impl<T> RefCell<T> {\n     }\n \n     /// Consumes the `RefCell`, returning the wrapped value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let five = c.into_inner();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T {\n         // Since this function takes `self` (the `RefCell`) by value, the\n@@ -285,12 +326,39 @@ impl<T> RefCell<T> {\n \n     /// Immutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n+    /// The borrow lasts until the returned `Ref` exits scope. Multiple immutable borrows can be\n+    /// taken out at the same time.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the value is currently mutably borrowed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let borrowed_five = c.borrow();\n+    /// let borrowed_five2 = c.borrow();\n+    /// ```\n+    ///\n+    /// An example of panic:\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    /// use std::thread::Thread;\n+    ///\n+    /// let result = Thread::scoped(move || {\n+    ///    let c = RefCell::new(5);\n+    ///    let m = c.borrow_mut();\n+    ///\n+    ///    let b = c.borrow(); // this causes a panic\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow<'a>(&'a self) -> Ref<'a, T> {\n         match self.try_borrow() {\n@@ -315,12 +383,38 @@ impl<T> RefCell<T> {\n \n     /// Mutably borrows the wrapped value.\n     ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n+    /// The borrow lasts until the returned `RefMut` exits scope. The value cannot be borrowed\n+    /// while this borrow is active.\n     ///\n     /// # Panics\n     ///\n     /// Panics if the value is currently borrowed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    ///\n+    /// let c = RefCell::new(5);\n+    ///\n+    /// let borrowed_five = c.borrow_mut();\n+    /// ```\n+    ///\n+    /// An example of panic:\n+    ///\n+    /// ```\n+    /// use std::cell::RefCell;\n+    /// use std::thread::Thread;\n+    ///\n+    /// let result = Thread::scoped(move || {\n+    ///    let c = RefCell::new(5);\n+    ///    let m = c.borrow_mut();\n+    ///\n+    ///    let b = c.borrow_mut(); // this causes a panic\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn borrow_mut<'a>(&'a self) -> RefMut<'a, T> {\n         match self.try_borrow_mut() {\n@@ -403,6 +497,9 @@ impl<'b> Clone for BorrowRef<'b> {\n }\n \n /// Wraps a borrowed reference to a value in a `RefCell` box.\n+/// A wrapper type for an immutably borrowed value from a `RefCell<T>`.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ref<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -461,7 +558,9 @@ impl<'b> BorrowRefMut<'b> {\n     }\n }\n \n-/// Wraps a mutable borrowed reference to a value in a `RefCell` box.\n+/// A wrapper type for a mutably borrowed value from a `RefCell<T>`.\n+///\n+/// See the [module-level documentation](../index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefMut<'b, T:'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -490,28 +589,25 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n \n /// The core primitive for interior mutability in Rust.\n ///\n-/// `UnsafeCell` type that wraps a type T and indicates unsafe interior\n-/// operations on the wrapped type. Types with an `UnsafeCell<T>` field are\n-/// considered to have an *unsafe interior*. The `UnsafeCell` type is the only\n-/// legal way to obtain aliasable data that is considered mutable. In general,\n-/// transmuting an &T type into an &mut T is considered undefined behavior.\n+/// `UnsafeCell<T>` is a type that wraps some `T` and indicates unsafe interior operations on the\n+/// wrapped type. Types with an `UnsafeCell<T>` field are considered to have an 'unsafe interior'.\n+/// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n+/// mutable. In general, transmuting an `&T` type into an `&mut T` is considered undefined behavior.\n ///\n-/// Although it is possible to put an `UnsafeCell<T>` into static item, it is\n-/// not permitted to take the address of the static item if the item is not\n-/// declared as mutable. This rule exists because immutable static items are\n-/// stored in read-only memory, and thus any attempt to mutate their interior\n-/// can cause segfaults. Immutable static items containing `UnsafeCell<T>`\n-/// instances are still useful as read-only initializers, however, so we do not\n-/// forbid them altogether.\n+/// Although it is possible to put an `UnsafeCell<T>` into static item, it is not permitted to take\n+/// the address of the static item if the item is not declared as mutable. This rule exists because\n+/// immutable static items are stored in read-only memory, and thus any attempt to mutate their\n+/// interior can cause segfaults. Immutable static items containing `UnsafeCell<T>` instances are\n+/// still useful as read-only initializers, however, so we do not forbid them altogether.\n ///\n-/// Types like `Cell` and `RefCell` use this type to wrap their internal data.\n+/// Types like `Cell<T>` and `RefCell<T>` use this type to wrap their internal data.\n ///\n-/// `UnsafeCell` doesn't opt-out from any kind, instead, types with an\n-/// `UnsafeCell` interior are expected to opt-out from kinds themselves.\n+/// `UnsafeCell<T>` doesn't opt-out from any marker traits, instead, types with an `UnsafeCell<T>`\n+/// interior are expected to opt-out from those traits themselves.\n ///\n-/// # Example:\n+/// # Examples\n ///\n-/// ```rust\n+/// ```\n /// use std::cell::UnsafeCell;\n /// use std::marker::Sync;\n ///\n@@ -522,9 +618,8 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// unsafe impl<T> Sync for NotThreadSafe<T> {}\n /// ```\n ///\n-/// **NOTE:** `UnsafeCell<T>` fields are public to allow static initializers. It\n-/// is not recommended to access its fields directly, `get` should be used\n-/// instead.\n+/// **NOTE:** `UnsafeCell<T>`'s fields are public to allow static initializers. It is not\n+/// recommended to access its fields directly, `get` should be used instead.\n #[lang=\"unsafe\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct UnsafeCell<T> {\n@@ -540,22 +635,52 @@ impl<T> UnsafeCell<T> {\n     /// Construct a new instance of `UnsafeCell` which will wrap the specified\n     /// value.\n     ///\n-    /// All access to the inner value through methods is `unsafe`, and it is\n-    /// highly discouraged to access the fields directly.\n+    /// All access to the inner value through methods is `unsafe`, and it is highly discouraged to\n+    /// access the fields directly.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n     /// Gets a mutable pointer to the wrapped value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    ///\n+    /// let five = uc.get();\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n \n     /// Unwraps the value\n     ///\n-    /// This function is unsafe because there is no guarantee that this or other\n-    /// tasks are currently inspecting the inner value.\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because there is no guarantee that this or other threads are\n+    /// currently inspecting the inner value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cell::UnsafeCell;\n+    ///\n+    /// let uc = UnsafeCell::new(5);\n+    ///\n+    /// let five = unsafe { uc.into_inner() };\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn into_inner(self) -> T { self.value }"}, {"sha": "71d5e88cccff70e9cd647e3bacf66ff9476eab09", "filename": "src/libcore/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -49,7 +49,7 @@\n //!\n //! ```\n //! use std::error::FromError;\n-//! use std::io::{File, IoError};\n+//! use std::old_io::{File, IoError};\n //! use std::os::{MemoryMap, MapError};\n //! use std::path::Path;\n //!"}, {"sha": "06428ad2f39a66e23b43e53c17c431bff45e8381", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -238,7 +238,7 @@ impl<'a> Display for Arguments<'a> {\n     }\n }\n \n-/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n@@ -249,7 +249,7 @@ pub trait Show {\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n-/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// Format trait for the `:?` format. Useful for debugging, all types\n /// should implement this.\n #[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]"}, {"sha": "ade257165c6ad0f24e1bdde4e62a18f9247ea8e0", "filename": "src/libcore/result.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -95,7 +95,7 @@\n //! by the [`Writer`](../io/trait.Writer.html) trait:\n //!\n //! ```\n-//! use std::io::IoError;\n+//! use std::old_io::IoError;\n //!\n //! trait Writer {\n //!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n@@ -110,7 +110,7 @@\n //! something like this:\n //!\n //! ```{.ignore}\n-//! use std::io::{File, Open, Write};\n+//! use std::old_io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! // If `write_line` errors, then we'll never know, because the return\n@@ -128,7 +128,7 @@\n //! a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n-//! use std::io::{File, Open, Write};\n+//! use std::old_io::{File, Open, Write};\n //!\n //! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n@@ -138,7 +138,7 @@\n //! You might also simply assert success:\n //!\n //! ```{.no_run}\n-//! # use std::io::{File, Open, Write};\n+//! # use std::old_io::{File, Open, Write};\n //!\n //! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //! assert!(file.write_line(\"important message\").is_ok());\n@@ -148,7 +148,7 @@\n //! Or propagate the error up the call stack with `try!`:\n //!\n //! ```\n-//! # use std::io::{File, Open, Write, IoError};\n+//! # use std::old_io::{File, Open, Write, IoError};\n //! fn write_message() -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n //!     try!(file.write_line(\"important message\"));\n@@ -167,7 +167,7 @@\n //! It replaces this:\n //!\n //! ```\n-//! use std::io::{File, Open, Write, IoError};\n+//! use std::old_io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n //!     name: String,\n@@ -191,7 +191,7 @@\n //! With this:\n //!\n //! ```\n-//! use std::io::{File, Open, Write, IoError};\n+//! use std::old_io::{File, Open, Write, IoError};\n //!\n //! struct Info {\n //!     name: String,\n@@ -445,7 +445,7 @@ impl<T, E> Result<T, E> {\n     /// ignoring I/O and parse errors:\n     ///\n     /// ```\n-    /// use std::io::IoResult;\n+    /// use std::old_io::IoResult;\n     ///\n     /// let mut buffer = &mut b\"1\\n2\\n3\\n4\\n\";\n     ///"}, {"sha": "dba355373ce64256d5bdc6b9e1163137d7b3c430", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -170,7 +170,7 @@ mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::io::util::NullWriter;\n+    use std::old_io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n@@ -213,7 +213,7 @@ mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n     use std::rand::{weak_rng, Rng};\n-    use std::io::util::NullWriter;\n+    use std::old_io::util::NullWriter;\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {"}, {"sha": "171b4ec2097b090d0d273deaa2d9957363b95d25", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -96,7 +96,7 @@\n //! ```no_run\n //! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!     let mut f = File::create(&Path::new(\"example1.dot\"));\n //!     render_to(&mut f)\n //! }\n@@ -188,7 +188,7 @@\n //! ```no_run\n //! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!     let mut f = File::create(&Path::new(\"example2.dot\"));\n //!     render_to(&mut f)\n //! }\n@@ -252,7 +252,7 @@\n //! ```no_run\n //! # pub fn render_to<W:Writer>(output: &mut W) { unimplemented!() }\n //! pub fn main() {\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!     let mut f = File::create(&Path::new(\"example3.dot\"));\n //!     render_to(&mut f)\n //! }\n@@ -283,7 +283,7 @@\n use self::LabelText::*;\n \n use std::borrow::IntoCow;\n-use std::io;\n+use std::old_io;\n use std::string::CowString;\n use std::vec::CowVec;\n \n@@ -536,7 +536,7 @@ pub fn default_options() -> Vec<RenderOption> { vec![] }\n /// (Simple wrapper around `render_opts` that passes a default set of options.)\n pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n               g: &'a G,\n-              w: &mut W) -> io::IoResult<()> {\n+              w: &mut W) -> old_io::IoResult<()> {\n     render_opts(g, w, &[])\n }\n \n@@ -545,14 +545,14 @@ pub fn render<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>,\n pub fn render_opts<'a, N:Clone+'a, E:Clone+'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n               g: &'a G,\n               w: &mut W,\n-              options: &[RenderOption]) -> io::IoResult<()>\n+              options: &[RenderOption]) -> old_io::IoResult<()>\n {\n-    fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> io::IoResult<()> {\n+    fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> old_io::IoResult<()> {\n         for &s in arg.iter() { try!(w.write_str(s)); }\n         w.write_char('\\n')\n     }\n \n-    fn indent<W:Writer>(w: &mut W) -> io::IoResult<()> {\n+    fn indent<W:Writer>(w: &mut W) -> old_io::IoResult<()> {\n         w.write_str(\"    \")\n     }\n \n@@ -594,7 +594,7 @@ mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render};\n     use super::LabelText::{self, LabelStr, EscStr};\n-    use std::io::IoResult;\n+    use std::old_io::IoResult;\n     use std::borrow::IntoCow;\n     use std::iter::repeat;\n "}, {"sha": "dfec2c18816e407ce7bf4a8fd34b6a1c0f888806", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -181,8 +181,8 @@\n \n use std::cell::RefCell;\n use std::fmt;\n-use std::io::LineBufferedWriter;\n-use std::io;\n+use std::old_io::LineBufferedWriter;\n+use std::old_io;\n use std::mem;\n use std::os;\n use std::ptr;\n@@ -239,7 +239,7 @@ pub trait Logger {\n }\n \n struct DefaultLogger {\n-    handle: LineBufferedWriter<io::stdio::StdWriter>,\n+    handle: LineBufferedWriter<old_io::stdio::StdWriter>,\n }\n \n /// Wraps the log level with fmt implementations.\n@@ -301,7 +301,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     let mut logger = LOCAL_LOGGER.with(|s| {\n         s.borrow_mut().take()\n     }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n+        box DefaultLogger { handle: old_io::stderr() } as Box<Logger + Send>\n     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),"}, {"sha": "13ddad1fee256c8589949569bd3ae898fb85fc65", "filename": "src/librbml/io.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::{IoError, IoResult, SeekStyle};\n-use std::io;\n+use std::old_io::{IoError, IoResult, SeekStyle};\n+use std::old_io;\n use std::slice;\n use std::iter::repeat;\n \n@@ -18,14 +18,14 @@ static BUF_CAPACITY: uint = 128;\n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n-        io::SeekSet => 0,\n-        io::SeekEnd => end,\n-        io::SeekCur => cur,\n+        old_io::SeekSet => 0,\n+        old_io::SeekEnd => end,\n+        old_io::SeekCur => cur,\n     } as i64;\n \n     if offset + pos < 0 {\n         Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"invalid seek to a negative offset\",\n             detail: None\n         })\n@@ -80,7 +80,7 @@ impl SeekableMemWriter {\n \n impl Writer for SeekableMemWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos == self.buf.len() {\n             self.buf.push_all(buf)\n         } else {\n@@ -132,7 +132,7 @@ impl Seek for SeekableMemWriter {\n mod tests {\n     extern crate test;\n     use super::SeekableMemWriter;\n-    use std::io;\n+    use std::old_io;\n     use std::iter::repeat;\n     use test::Bencher;\n \n@@ -148,23 +148,23 @@ mod tests {\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n-        writer.seek(0, io::SeekSet).unwrap();\n+        writer.seek(0, old_io::SeekSet).unwrap();\n         assert_eq!(writer.tell(), Ok(0));\n         writer.write(&[3, 4]).unwrap();\n         let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n-        writer.seek(1, io::SeekCur).unwrap();\n+        writer.seek(1, old_io::SeekCur).unwrap();\n         writer.write(&[0, 1]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n-        writer.seek(-1, io::SeekEnd).unwrap();\n+        writer.seek(-1, old_io::SeekEnd).unwrap();\n         writer.write(&[1, 2]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n         assert_eq!(writer.get_ref(), b);\n \n-        writer.seek(1, io::SeekEnd).unwrap();\n+        writer.seek(1, old_io::SeekEnd).unwrap();\n         writer.write(&[1]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n         assert_eq!(writer.get_ref(), b);\n@@ -173,14 +173,14 @@ mod tests {\n     #[test]\n     fn seek_past_end() {\n         let mut r = SeekableMemWriter::new();\n-        r.seek(10, io::SeekSet).unwrap();\n+        r.seek(10, old_io::SeekSet).unwrap();\n         assert!(r.write(&[3]).is_ok());\n     }\n \n     #[test]\n     fn seek_before_0() {\n         let mut r = SeekableMemWriter::new();\n-        assert!(r.seek(-1, io::SeekSet).is_err());\n+        assert!(r.seek(-1, old_io::SeekSet).is_err());\n     }\n \n     fn do_bench_seekable_mem_writer(b: &mut Bencher, times: uint, len: uint) {"}, {"sha": "2500cb864632e27a24fa8c1c5dd628123ade3a89", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -115,7 +115,7 @@ pub enum EbmlEncoderTag {\n pub enum Error {\n     IntTooBig(uint),\n     Expected(String),\n-    IoError(std::io::IoError),\n+    IoError(std::old_io::IoError),\n     ApplicationError(String)\n }\n \n@@ -131,7 +131,7 @@ pub mod reader {\n     use std::char;\n \n     use std::int;\n-    use std::io::extensions::u64_from_be_bytes;\n+    use std::old_io::extensions::u64_from_be_bytes;\n     use std::mem::transmute;\n     use std::num::Int;\n     use std::option::Option;\n@@ -689,9 +689,9 @@ pub mod reader {\n \n pub mod writer {\n     use std::clone::Clone;\n-    use std::io::extensions::u64_to_be_bytes;\n-    use std::io::{Writer, Seek};\n-    use std::io;\n+    use std::old_io::extensions::u64_to_be_bytes;\n+    use std::old_io::{Writer, Seek};\n+    use std::old_io;\n     use std::mem;\n \n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n@@ -702,7 +702,7 @@ pub mod writer {\n     use serialize;\n \n \n-    pub type EncodeResult = io::IoResult<()>;\n+    pub type EncodeResult = old_io::IoResult<()>;\n \n     // rbml writing\n     pub struct Encoder<'a, W:'a> {\n@@ -712,14 +712,14 @@ pub mod writer {\n \n     fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n-            1u => w.write(&[0x80u8 | (n as u8)]),\n-            2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n-            3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+            1u => w.write_all(&[0x80u8 | (n as u8)]),\n+            2u => w.write_all(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+            3u => w.write_all(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n                             n as u8]),\n-            4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+            4u => w.write_all(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => Err(io::IoError {\n-                kind: io::OtherIoError,\n+            _ => Err(old_io::IoError {\n+                kind: old_io::OtherIoError,\n                 desc: \"int too big\",\n                 detail: Some(format!(\"{}\", n))\n             })\n@@ -731,8 +731,8 @@ pub mod writer {\n         if n < 0x4000_u { return write_sized_vuint(w, n, 2u); }\n         if n < 0x200000_u { return write_sized_vuint(w, n, 3u); }\n         if n < 0x10000000_u { return write_sized_vuint(w, n, 4u); }\n-        Err(io::IoError {\n-            kind: io::OtherIoError,\n+        Err(old_io::IoError {\n+            kind: old_io::OtherIoError,\n             desc: \"int too big\",\n             detail: Some(format!(\"{}\", n))\n         })\n@@ -764,16 +764,16 @@ pub mod writer {\n             // Write a placeholder four-byte size.\n             self.size_positions.push(try!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            self.writer.write(zeroes)\n+            self.writer.write_all(zeroes)\n         }\n \n         pub fn end_tag(&mut self) -> EncodeResult {\n             let last_size_pos = self.size_positions.pop().unwrap();\n             let cur_pos = try!(self.writer.tell());\n-            try!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n+            try!(self.writer.seek(last_size_pos as i64, old_io::SeekSet));\n             let size = cur_pos as uint - last_size_pos - 4;\n             try!(write_sized_vuint(self.writer, size, 4u));\n-            let r = try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n+            let r = try!(self.writer.seek(cur_pos as i64, old_io::SeekSet));\n \n             debug!(\"End tag (size = {:?})\", size);\n             Ok(r)\n@@ -790,7 +790,7 @@ pub mod writer {\n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n             try!(write_vuint(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n-            self.writer.write(b)\n+            self.writer.write_all(b)\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n@@ -843,12 +843,12 @@ pub mod writer {\n \n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n             debug!(\"Write {:?} bytes\", b.len());\n-            self.writer.write(b)\n+            self.writer.write_all(b)\n         }\n \n         pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n             debug!(\"Write str: {:?}\", s);\n-            self.writer.write(s.as_bytes())\n+            self.writer.write_all(s.as_bytes())\n         }\n     }\n \n@@ -890,7 +890,7 @@ pub mod writer {\n     }\n \n     impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n-        type Error = io::IoError;\n+        type Error = old_io::IoError;\n \n         fn emit_nil(&mut self) -> EncodeResult {\n             Ok(())"}, {"sha": "e6f76dedca95f55ae4cce36a2535956992b27c3f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -34,8 +34,8 @@ use middle::astencode::vtable_decoder_helpers;\n \n use std::collections::HashMap;\n use std::hash::{self, Hash, SipHasher};\n-use std::io::extensions::u64_from_be_bytes;\n-use std::io;\n+use std::old_io::extensions::u64_from_be_bytes;\n+use std::old_io;\n use std::num::FromPrimitive;\n use std::rc::Rc;\n use std::str;\n@@ -1178,7 +1178,7 @@ fn get_attributes(md: rbml::Doc) -> Vec<ast::Attribute> {\n }\n \n fn list_crate_attributes(md: rbml::Doc, hash: &Svh,\n-                         out: &mut io::Writer) -> io::IoResult<()> {\n+                         out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     try!(write!(out, \"=Crate Attributes ({})=\\n\", *hash));\n \n     let r = get_attributes(md);\n@@ -1223,7 +1223,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     return deps;\n }\n \n-fn list_crate_deps(data: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n+fn list_crate_deps(data: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     try!(write!(out, \"=External Dependencies=\\n\"));\n     for dep in get_crate_deps(data).iter() {\n         try!(write!(out, \"{} {}-{}\\n\", dep.cnum, dep.name, dep.hash));\n@@ -1262,7 +1262,7 @@ pub fn get_crate_name(data: &[u8]) -> String {\n     maybe_get_crate_name(data).expect(\"no crate name in crate\")\n }\n \n-pub fn list_crate_metadata(bytes: &[u8], out: &mut io::Writer) -> io::IoResult<()> {\n+pub fn list_crate_metadata(bytes: &[u8], out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     let hash = get_crate_hash(bytes);\n     let md = rbml::Doc::new(bytes);\n     try!(list_crate_attributes(md, &hash, out));"}, {"sha": "f6c5ba4b52bc8c84da3bf399a8b8881d79472eae", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -122,7 +122,7 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n // Item info table encoding\n fn encode_family(rbml_w: &mut Encoder, c: char) {\n     rbml_w.start_tag(tag_items_data_item_family);\n-    rbml_w.writer.write(&[c as u8]);\n+    rbml_w.writer.write_all(&[c as u8]);\n     rbml_w.end_tag();\n }\n \n@@ -149,7 +149,7 @@ fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_string(vid);\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n@@ -259,7 +259,7 @@ fn encode_symbol(ecx: &EncodeContext,\n     match ecx.item_symbols.borrow().get(&id) {\n         Some(x) => {\n             debug!(\"encode_symbol(id={}, str={})\", id, *x);\n-            rbml_w.writer.write(x.as_bytes());\n+            rbml_w.writer.write_all(x.as_bytes());\n         }\n         None => {\n             ecx.diag.handler().bug(\n@@ -274,14 +274,14 @@ fn encode_disr_val(_: &EncodeContext,\n                    disr_val: ty::Disr) {\n     rbml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_string();\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n     rbml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_string(id);\n-    rbml_w.writer.write(s.as_bytes());\n+    rbml_w.writer.write_all(s.as_bytes());\n     rbml_w.end_tag();\n }\n \n@@ -299,7 +299,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         encode_def_id(rbml_w, f.id);\n         rbml_w.start_tag(tag_item_field_origin);\n         let s = def_to_string(origin);\n-        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n     }\n@@ -636,17 +636,17 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     // Encode the base self type.\n     match *explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ 's' as u8 ]);\n+            rbml_w.writer.write_all(&[ 's' as u8 ]);\n         }\n         ty::ByValueExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ 'v' as u8 ]);\n+            rbml_w.writer.write_all(&[ 'v' as u8 ]);\n         }\n         ty::ByBoxExplicitSelfCategory => {\n-            rbml_w.writer.write(&[ '~' as u8 ]);\n+            rbml_w.writer.write_all(&[ '~' as u8 ]);\n         }\n         ty::ByReferenceExplicitSelfCategory(_, m) => {\n             // FIXME(#4846) encode custom lifetime\n-            rbml_w.writer.write(&['&' as u8]);\n+            rbml_w.writer.write_all(&['&' as u8]);\n             encode_mutability(rbml_w, m);\n         }\n     }\n@@ -656,21 +656,21 @@ fn encode_explicit_self(rbml_w: &mut Encoder,\n     fn encode_mutability(rbml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n-            ast::MutImmutable => { rbml_w.writer.write(&[ 'i' as u8 ]); }\n-            ast::MutMutable => { rbml_w.writer.write(&[ 'm' as u8 ]); }\n+            ast::MutImmutable => { rbml_w.writer.write_all(&[ 'i' as u8 ]); }\n+            ast::MutMutable => { rbml_w.writer.write_all(&[ 'm' as u8 ]); }\n         }\n     }\n }\n \n fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.start_tag(tag_item_trait_item_sort);\n-    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.writer.write_all(&[ sort as u8 ]);\n     rbml_w.end_tag();\n }\n \n fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.start_tag(tag_item_trait_parent_sort);\n-    rbml_w.writer.write(&[ sort as u8 ]);\n+    rbml_w.writer.write_all(&[ sort as u8 ]);\n     rbml_w.end_tag();\n }\n \n@@ -679,7 +679,7 @@ fn encode_provided_source(rbml_w: &mut Encoder,\n     for source in source_opt.iter() {\n         rbml_w.start_tag(tag_item_method_provided_source);\n         let s = def_to_string(*source);\n-        rbml_w.writer.write(s.as_bytes());\n+        rbml_w.writer.write_all(s.as_bytes());\n         rbml_w.end_tag();\n     }\n }\n@@ -926,7 +926,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_method_argument_name);\n         if let ast::PatIdent(_, ref path1, _) = arg.pat.node {\n             let name = token::get_ident(path1.node);\n-            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.get().as_bytes());\n         }\n         rbml_w.end_tag();\n     }\n@@ -1646,7 +1646,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaWord(ref name) => {\n         rbml_w.start_tag(tag_meta_item_word);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n         rbml_w.end_tag();\n       }\n@@ -1655,10 +1655,10 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n           ast::LitStr(ref value, _) => {\n             rbml_w.start_tag(tag_meta_item_name_value);\n             rbml_w.start_tag(tag_meta_item_name);\n-            rbml_w.writer.write(name.get().as_bytes());\n+            rbml_w.writer.write_all(name.get().as_bytes());\n             rbml_w.end_tag();\n             rbml_w.start_tag(tag_meta_item_value);\n-            rbml_w.writer.write(value.get().as_bytes());\n+            rbml_w.writer.write_all(value.get().as_bytes());\n             rbml_w.end_tag();\n             rbml_w.end_tag();\n           }\n@@ -1668,7 +1668,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n       ast::MetaList(ref name, ref items) => {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.start_tag(tag_meta_item_name);\n-        rbml_w.writer.write(name.get().as_bytes());\n+        rbml_w.writer.write_all(name.get().as_bytes());\n         rbml_w.end_tag();\n         for inner_item in items.iter() {\n             encode_meta_item(rbml_w, &**inner_item);\n@@ -1800,7 +1800,7 @@ fn encode_native_libraries(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n                 rbml_w.end_tag();\n \n                 rbml_w.start_tag(tag_native_libraries_name);\n-                rbml_w.writer.write(lib.as_bytes());\n+                rbml_w.writer.write_all(lib.as_bytes());\n                 rbml_w.end_tag();\n \n                 rbml_w.end_tag();\n@@ -1975,29 +1975,29 @@ fn encode_crate_dep(rbml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     rbml_w.start_tag(tag_crate_dep);\n     rbml_w.start_tag(tag_crate_dep_crate_name);\n-    rbml_w.writer.write(dep.name.as_bytes());\n+    rbml_w.writer.write_all(dep.name.as_bytes());\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_crate_dep_hash);\n-    rbml_w.writer.write(dep.hash.as_str().as_bytes());\n+    rbml_w.writer.write_all(dep.hash.as_str().as_bytes());\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n \n fn encode_hash(rbml_w: &mut Encoder, hash: &Svh) {\n     rbml_w.start_tag(tag_crate_hash);\n-    rbml_w.writer.write(hash.as_str().as_bytes());\n+    rbml_w.writer.write_all(hash.as_str().as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_crate_name(rbml_w: &mut Encoder, crate_name: &str) {\n     rbml_w.start_tag(tag_crate_crate_name);\n-    rbml_w.writer.write(crate_name.as_bytes());\n+    rbml_w.writer.write_all(crate_name.as_bytes());\n     rbml_w.end_tag();\n }\n \n fn encode_crate_triple(rbml_w: &mut Encoder, triple: &str) {\n     rbml_w.start_tag(tag_crate_triple);\n-    rbml_w.writer.write(triple.as_bytes());\n+    rbml_w.writer.write_all(triple.as_bytes());\n     rbml_w.end_tag();\n }\n \n@@ -2011,7 +2011,7 @@ fn encode_dylib_dependency_formats(rbml_w: &mut Encoder, ecx: &EncodeContext) {\n                     cstore::RequireStatic => \"s\",\n                 })).to_string())\n             }).collect::<Vec<String>>();\n-            rbml_w.writer.write(s.connect(\",\").as_bytes());\n+            rbml_w.writer.write_all(s.connect(\",\").as_bytes());\n         }\n         None => {}\n     }"}, {"sha": "26046cfb43d8a410cb5d021b5634b7998a258547", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,8 +13,8 @@\n pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n-use std::io::fs::PathExtensions;\n-use std::io::fs;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::fs;\n use std::os;\n \n use util::fs as myfs;"}, {"sha": "3ee4017292c4c7f1251454952591e73d0362b0e3", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -231,8 +231,8 @@ use rustc_back::target::Target;\n use std::ffi::CString;\n use std::cmp;\n use std::collections::HashMap;\n-use std::io::fs::PathExtensions;\n-use std::io;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io;\n use std::ptr;\n use std::slice;\n use std::time::Duration;\n@@ -796,7 +796,7 @@ pub fn read_meta_section_name(is_osx: bool) -> &'static str {\n \n // A diagnostic function for dumping crate metadata to an output stream\n pub fn list_file_metadata(is_osx: bool, path: &Path,\n-                          out: &mut io::Writer) -> io::IoResult<()> {\n+                          out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     match get_metadata_section(is_osx, path) {\n         Ok(bytes) => decoder::list_crate_metadata(bytes.as_slice(), out),\n         Err(msg) => {"}, {"sha": "2ee4b6fbbd4ad676134f65d678c56a6ac8b38f32", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -377,6 +377,14 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n             let node_id = parse_uint(st) as ast::NodeId;\n             region::CodeExtent::Misc(node_id)\n         }\n+        'B' => {\n+            let node_id = parse_uint(st) as ast::NodeId;\n+            let first_stmt_index = parse_uint(st);\n+            let block_remainder = region::BlockRemainder {\n+                block: node_id, first_statement_index: first_stmt_index,\n+            };\n+            region::CodeExtent::Remainder(block_remainder)\n+        }\n         _ => panic!(\"parse_scope: bad input\")\n     }\n }"}, {"sha": "2dc334bfe95fceb039557116d9f3b79c03a30717", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -51,7 +51,7 @@ pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.write(a.s.as_bytes()); return; }\n+        Some(a) => { w.write_all(a.s.as_bytes()); return; }\n         None => {}\n     }\n     let pos = w.tell().unwrap();\n@@ -276,7 +276,9 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n \n fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n-        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id)\n+        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+        region::CodeExtent::Remainder(region::BlockRemainder {\n+            block: b, first_statement_index: i }) => mywrite!(w, \"B{}{}\", b, i),\n     }\n }\n "}, {"sha": "091ef9d52eb40e9aef1fdc9d7017f8b7e3b724d9", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -37,7 +37,7 @@ use syntax::parse::token;\n use syntax::ptr::P;\n use syntax;\n \n-use std::io::Seek;\n+use std::old_io::Seek;\n use std::rc::Rc;\n \n use rbml::io::SeekableMemWriter;"}, {"sha": "d3c843d1d50c3112dc7d8f3c7988bb5dca5ea169", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,7 +19,7 @@ pub use self::EntryOrExit::*;\n use middle::cfg;\n use middle::cfg::CFGIndex;\n use middle::ty;\n-use std::io;\n+use std::old_io;\n use std::uint;\n use std::iter::repeat;\n use syntax::ast;\n@@ -105,7 +105,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O> {\n     fn pre(&self,\n            ps: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::IoResult<()> {\n+           node: pprust::AnnNode) -> old_io::IoResult<()> {\n         let id = match node {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => 0,\n             pprust::NodeExpr(expr) => expr.id,\n@@ -457,13 +457,13 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n         debug!(\"{}\", {\n-            self.pretty_print_to(box io::stderr(), blk).unwrap();\n+            self.pretty_print_to(box old_io::stderr(), blk).unwrap();\n             \"\"\n         });\n     }\n \n-    fn pretty_print_to(&self, wr: Box<io::Writer+'static>,\n-                       blk: &ast::Block) -> io::IoResult<()> {\n+    fn pretty_print_to(&self, wr: Box<old_io::Writer+'static>,\n+                       blk: &ast::Block) -> old_io::IoResult<()> {\n         let mut ps = pprust::rust_printer_annotated(wr, self);\n         try!(ps.cbox(pprust::indent_unit));\n         try!(ps.ibox(0u));"}, {"sha": "cfef88a8deb4471ace63d15f69ed09b5144c343b", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -809,6 +809,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let scope_id = same_regions[0].scope_id;\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n+        let taken = lifetimes_in_scope(self.tcx, scope_id);\n+        let life_giver = LifeGiver::with_taken(&taken[]);\n         let node_inner = match parent_node {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n@@ -851,8 +853,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n-        let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();"}, {"sha": "8803fe7cf38a93ef9ae72cc9a41cf48a3b5cdedf", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -26,7 +26,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n use std::collections::hash_map::Entry::Vacant;\n-use std::io::{self, File};\n+use std::old_io::{self, File};\n use std::os;\n use std::sync::atomic::{AtomicBool, Ordering, ATOMIC_BOOL_INIT};\n use syntax::ast;\n@@ -217,7 +217,7 @@ pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'tcx:'a >(tcx: &'a ty::ctxt<'tcx>,\n                                             map: &ConstraintMap<'tcx>,\n-                                            path: &str) -> io::IoResult<()> {\n+                                            path: &str) -> old_io::IoResult<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\", map.len(), path);\n     let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n     let mut f = File::create(&Path::new(path));"}, {"sha": "00fa6546b4805e8fd2740e88ea39e4d7375434d1", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -118,7 +118,7 @@ use middle::ty::ClosureTyper;\n use lint;\n use util::nodemap::NodeMap;\n \n-use std::{fmt, io, uint};\n+use std::{fmt, old_io, uint};\n use std::rc::Rc;\n use std::iter::repeat;\n use syntax::ast::{self, NodeId, Expr};\n@@ -693,10 +693,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn write_vars<F>(&self,\n-                     wr: &mut io::Writer,\n+                     wr: &mut old_io::Writer,\n                      ln: LiveNode,\n                      mut test: F)\n-                     -> io::IoResult<()> where\n+                     -> old_io::IoResult<()> where\n         F: FnMut(uint) -> LiveNode,\n     {\n         let node_base_idx = self.idx(ln, Variable(0));\n@@ -740,7 +740,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn ln_str(&self, ln: LiveNode) -> String {\n         let mut wr = Vec::new();\n         {\n-            let wr = &mut wr as &mut io::Writer;\n+            let wr = &mut wr as &mut old_io::Writer;\n             write!(wr, \"[ln({:?}) of kind {:?} reads\", ln.get(), self.ir.lnk(ln));\n             self.write_vars(wr, ln, |idx| self.users[idx].reader);\n             write!(wr, \"  writes\");"}, {"sha": "9bba01f8af771b904b9dfe500072b9bb363da4b9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 238, "deletions": 51, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -26,6 +26,7 @@ use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n+use syntax::ast_map;\n use syntax::visit::{Visitor, FnKind};\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -38,7 +39,32 @@ use syntax::visit::{Visitor, FnKind};\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Show, Copy)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId)\n+    Misc(ast::NodeId),\n+    Remainder(BlockRemainder),\n+}\n+\n+/// Represents a subscope of `block` for a binding that is introduced\n+/// by `block.stmts[first_statement_index]`. Such subscopes represent\n+/// a suffix of the block. Note that each subscope does not include\n+/// the initializer expression, if any, for the statement indexed by\n+/// `first_statement_index`.\n+///\n+/// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+///\n+/// * the subscope with `first_statement_index == 0` is scope of both\n+///   `a` and `b`; it does not include EXPR_1, but does include\n+///   everything after that first `let`. (If you want a scope that\n+///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n+///   but instead another `CodeExtent` that encompasses the whole block,\n+///   e.g. `CodeExtent::Misc`.\n+///\n+/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+///   and thus does not include EXPR_2, but covers the `...`.\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+         RustcDecodable, Show, Copy)]\n+pub struct BlockRemainder {\n+    pub block: ast::NodeId,\n+    pub first_statement_index: uint,\n }\n \n impl CodeExtent {\n@@ -55,6 +81,7 @@ impl CodeExtent {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Remainder(br) => br.block,\n         }\n     }\n \n@@ -65,16 +92,50 @@ impl CodeExtent {\n     {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n+            CodeExtent::Remainder(br) =>\n+                CodeExtent::Remainder(BlockRemainder {\n+                    block: f_id(br.block), first_statement_index: br.first_statement_index }),\n         }\n     }\n+\n+    /// Returns the span of this CodeExtent.  Note that in general the\n+    /// returned span may not correspond to the span of any node id in\n+    /// the AST.\n+    pub fn span(&self, ast_map: &ast_map::Map) -> Option<Span> {\n+        match ast_map.find(self.node_id()) {\n+            Some(ast_map::NodeBlock(ref blk)) => {\n+                match *self {\n+                    CodeExtent::Misc(_) => Some(blk.span),\n+\n+                    CodeExtent::Remainder(r) => {\n+                        assert_eq!(r.block, blk.id);\n+                        // Want span for extent starting after the\n+                        // indexed statement and ending at end of\n+                        // `blk`; reuse span of `blk` and shift `lo`\n+                        // forward to end of indexed statement.\n+                        //\n+                        // (This is the special case aluded to in the\n+                        // doc-comment for this method)\n+                        let stmt_span = blk.stmts[r.first_statement_index].span;\n+                        Some(Span { lo: stmt_span.hi, ..blk.span })\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeExpr(ref expr)) => Some(expr.span),\n+            Some(ast_map::NodeStmt(ref stmt)) => Some(stmt.span),\n+            Some(ast_map::NodeItem(ref item)) => Some(item.span),\n+            Some(_) | None => None,\n+         }\n+    }\n }\n \n /// The region maps encode information about region relationships.\n ///\n /// - `scope_map` maps from a scope id to the enclosing scope id; this is\n ///   usually corresponding to the lexical nesting, though in the case of\n ///   closures the parent scope is the innermost conditional expression or repeating\n-///   block\n+///   block. (Note that the enclosing scope id for the block\n+///   associated with a closure is the closure itself.)\n ///\n /// - `var_map` maps from a variable or binding id to the block in which\n ///   that variable is declared.\n@@ -115,12 +176,77 @@ pub struct RegionMaps {\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n }\n \n-#[derive(Copy)]\n+/// Carries the node id for the innermost block or match expression,\n+/// for building up the `var_map` which maps ids to the blocks in\n+/// which they were declared.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostDeclaringBlock {\n+    None,\n+    Block(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+    Match(ast::NodeId),\n+}\n+\n+impl InnermostDeclaringBlock {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostDeclaringBlock::None => {\n+                return Option::None;\n+            }\n+            InnermostDeclaringBlock::Block(id) |\n+            InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n+            InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n+        };\n+        Option::Some(extent)\n+    }\n+}\n+\n+/// Contextual information for declarations introduced by a statement\n+/// (i.e. `let`). It carries node-id's for statement and enclosing\n+/// block both, as well as the statement's index within the block.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+struct DeclaringStatementContext {\n+    stmt_id: ast::NodeId,\n+    block_id: ast::NodeId,\n+    stmt_index: uint,\n+}\n+\n+impl DeclaringStatementContext {\n+    fn to_code_extent(&self) -> CodeExtent {\n+        CodeExtent::Remainder(BlockRemainder {\n+            block: self.block_id,\n+            first_statement_index: self.stmt_index,\n+        })\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostEnclosingExpr {\n+    None,\n+    Some(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+}\n+\n+impl InnermostEnclosingExpr {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostEnclosingExpr::None => {\n+                return Option::None;\n+            }\n+            InnermostEnclosingExpr::Statement(s) =>\n+                s.to_code_extent(),\n+            InnermostEnclosingExpr::Some(parent_id) =>\n+                CodeExtent::from_node_id(parent_id),\n+        };\n+        Some(extent)\n+    }\n+}\n+\n+#[derive(Show, Copy)]\n pub struct Context {\n-    var_parent: Option<ast::NodeId>,\n+    var_parent: InnermostDeclaringBlock,\n \n-    // Innermost enclosing expression\n-    parent: Option<ast::NodeId>,\n+    parent: InnermostEnclosingExpr,\n }\n \n struct RegionResolutionVisitor<'a> {\n@@ -381,16 +507,13 @@ impl RegionMaps {\n     }\n }\n \n-/// Records the current parent (if any) as the parent of `child_id`.\n+/// Records the current parent (if any) as the parent of `child_scope`.\n fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        child_id: ast::NodeId,\n+                        child_scope: CodeExtent,\n                         _sp: Span) {\n-    match visitor.cx.parent {\n-        Some(parent_id) => {\n-            let child_scope = CodeExtent::from_node_id(child_id);\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_encl_scope(child_scope, parent_scope);\n-        }\n+    match visitor.cx.parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_encl_scope(child_scope, parent_scope),\n         None => {}\n     }\n }\n@@ -399,11 +522,9 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match visitor.cx.var_parent {\n-        Some(parent_id) => {\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_var_scope(var_id, parent_scope);\n-        }\n+    match visitor.cx.var_parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_var_scope(var_id, parent_scope),\n         None => {\n             // this can happen in extern fn declarations like\n             //\n@@ -415,21 +536,72 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n-    // Record the parent of this block.\n-    record_superlifetime(visitor, blk.id, blk.span);\n+    let prev_cx = visitor.cx;\n+\n+    let blk_scope = CodeExtent::Misc(blk.id);\n+    record_superlifetime(visitor, blk_scope, blk.span);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n-    // temporary lifetimes. If the user writes:\n+    // temporary lifetimes. Consider the following:\n     //\n-    //   {\n-    //     ... (&foo()) ...\n-    //   }\n+    //    quux({\n+    //        let inner = ... (&bar()) ...;\n     //\n+    //        (... (&foo()) ...) // (the tail expression)\n+    //    }, other_argument());\n+    //\n+    // Each of the statements within the block is a terminating\n+    // scope, and thus a temporary (e.g. the result of calling\n+    // `bar()` in the initalizer expression for `let inner = ...;`)\n+    // will be cleaned up immediately after its corresponding\n+    // statement (i.e. `let inner = ...;`) executes.\n+    //\n+    // On the other hand, temporaries associated with evaluating the\n+    // tail expression for the block are assigned lifetimes so that\n+    // they will be cleaned up as part of the terminating scope\n+    // *surrounding* the block expression. Here, the terminating\n+    // scope for the block expression is the `quux(..)` call; so\n+    // those temporaries will only be cleaned up *after* both\n+    // `other_argument()` has run and also the call to `quux(..)`\n+    // itself has returned.\n+\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::Block(blk.id),\n+        parent: InnermostEnclosingExpr::Some(blk.id),\n+    };\n+\n+    {\n+        // This block should be kept approximately in sync with\n+        // `visit::walk_block`. (We manually walk the block, rather\n+        // than call `walk_block`, in order to maintain precise\n+        // `InnermostDeclaringBlock` information.)\n+\n+        for (i, statement) in blk.stmts.iter().enumerate() {\n+            if let ast::StmtDecl(_, stmt_id) = statement.node {\n+                // Each StmtDecl introduces a subscope for bindings\n+                // introduced by the declaration; this subscope covers\n+                // a suffix of the block . Each subscope in a block\n+                // has the previous subscope in the block as a parent,\n+                // except for the first such subscope, which has the\n+                // block itself as a parent.\n+                let declaring = DeclaringStatementContext {\n+                    stmt_id: stmt_id,\n+                    block_id: blk.id,\n+                    stmt_index: i,\n+                };\n+                record_superlifetime(\n+                    visitor, declaring.to_code_extent(), statement.span);\n+                visitor.cx = Context {\n+                    var_parent: InnermostDeclaringBlock::Statement(declaring),\n+                    parent: InnermostEnclosingExpr::Statement(declaring),\n+                };\n+            }\n+            visitor.visit_stmt(&**statement)\n+        }\n+        visit::walk_expr_opt(visitor, &blk.expr)\n+    }\n \n-    let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n-    visit::walk_block(visitor, blk);\n     visitor.cx = prev_cx;\n }\n \n@@ -449,7 +621,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n-    record_superlifetime(visitor, pat.id, pat.span);\n+    record_superlifetime(visitor, CodeExtent::from_node_id(pat.id), pat.span);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n@@ -468,22 +640,29 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     let stmt_scope = CodeExtent::from_node_id(stmt_id);\n+\n+    // Every statement will clean up the temporaries created during\n+    // execution of that statement. Therefore each statement has an\n+    // associated destruction scope that represents the extent of the\n+    // statement plus its destructors, and thus the extent for which\n+    // regions referenced by the destructors need to survive.\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    record_superlifetime(visitor, stmt_id, stmt.span);\n+    record_superlifetime(visitor, stmt_scope, stmt.span);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = Some(stmt_id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n     visit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    record_superlifetime(visitor, expr.id, expr.span);\n+    let expr_scope = CodeExtent::Misc(expr.id);\n+    record_superlifetime(visitor, expr_scope, expr.span);\n \n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = Some(expr.id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n \n     {\n         let region_maps = &mut visitor.region_maps;\n@@ -527,11 +706,11 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n                 // The variable parent of everything inside (most importantly, the\n                 // pattern) is the body.\n-                visitor.cx.var_parent = Some(body.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Block(body.id);\n             }\n \n             ast::ExprMatch(..) => {\n-                visitor.cx.var_parent = Some(expr.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n             }\n \n             ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -568,19 +747,13 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n-    let blk_id = match visitor.cx.var_parent {\n-        Some(id) => id,\n-        None => {\n-            visitor.sess.span_bug(\n-                local.span,\n-                \"local without enclosing block\");\n-        }\n-    };\n-\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    let blk_scope = CodeExtent::from_node_id(blk_id);\n+    let blk_scope = visitor.cx.var_parent.to_code_extent()\n+        .unwrap_or_else(|| visitor.sess.span_bug(\n+            local.span, \"local without enclosing block\"));\n+\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -803,7 +976,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: None, parent: None};\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::None,\n+        parent: InnermostEnclosingExpr::None\n+    };\n     visit::walk_item(visitor, item);\n     visitor.cx = prev_cx;\n }\n@@ -829,15 +1005,20 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     let outer_cx = visitor.cx;\n \n     // The arguments and `self` are parented to the body of the fn.\n-    visitor.cx = Context { parent: Some(body.id),\n-                           var_parent: Some(body.id) };\n+    visitor.cx = Context {\n+        parent: InnermostEnclosingExpr::Some(body.id),\n+        var_parent: InnermostDeclaringBlock::Block(body.id)\n+    };\n     visit::walk_fn_decl(visitor, decl);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     match fk {\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visitor.cx = Context { parent: None, var_parent: None };\n+            visitor.cx = Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None\n+            };\n             visitor.visit_block(body);\n             visitor.cx = outer_cx;\n         }\n@@ -898,7 +1079,10 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n-            cx: Context { parent: None, var_parent: None }\n+            cx: Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None,\n+            }\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -911,7 +1095,10 @@ pub fn resolve_inlined_item(sess: &Session,\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n-        cx: Context { parent: None, var_parent: None }\n+        cx: Context {\n+            parent: InnermostEnclosingExpr::None,\n+            var_parent: InnermostDeclaringBlock::None\n+        }\n     };\n     visit::walk_inlined_item(&mut visitor, item);\n }"}, {"sha": "86cf030c8288a51a4749df7720988788476c22b8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -3126,7 +3126,6 @@ pub fn type_is_scalar(ty: Ty) -> bool {\n       ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n-      ty_tup(ref tys) if tys.is_empty() => true,\n       _ => false\n     }\n }"}, {"sha": "5601898136c79d629773ed2c93d649322a3cd252", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,6 +10,7 @@\n \n \n use middle::def;\n+use middle::region;\n use middle::subst::{VecPerParamSpace,Subst};\n use middle::subst;\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n@@ -84,37 +85,41 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (String, Option<Span>) {\n     return match region {\n       ReScope(scope) => {\n-        match cx.map.find(scope.node_id()) {\n-          Some(ast_map::NodeBlock(ref blk)) => {\n-            explain_span(cx, \"block\", blk.span)\n-          }\n-          Some(ast_map::NodeExpr(expr)) => {\n-            match expr.node {\n-              ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n-              ast::ExprMethodCall(..) => {\n-                explain_span(cx, \"method call\", expr.span)\n-              },\n-              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) =>\n-                  explain_span(cx, \"if let\", expr.span),\n-              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) => {\n-                  explain_span(cx, \"while let\", expr.span)\n-              },\n-              ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n-              _ => explain_span(cx, \"expression\", expr.span)\n-            }\n-          }\n-          Some(ast_map::NodeStmt(stmt)) => {\n-              explain_span(cx, \"statement\", stmt.span)\n-          }\n-          Some(ast_map::NodeItem(it)) => {\n-              let tag = item_scope_tag(&*it);\n-              explain_span(cx, tag, it.span)\n-          }\n+        let new_string;\n+        let on_unknown_scope = |&:| {\n+          (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+        };\n+        let span = match scope.span(&cx.map) {\n+          Some(s) => s,\n+          None => return on_unknown_scope(),\n+        };\n+        let tag = match cx.map.find(scope.node_id()) {\n+          Some(ast_map::NodeBlock(_)) => \"block\",\n+          Some(ast_map::NodeExpr(expr)) => match expr.node {\n+              ast::ExprCall(..) => \"call\",\n+              ast::ExprMethodCall(..) => \"method call\",\n+              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(..) => \"match\",\n+              _ => \"expression\",\n+          },\n+          Some(ast_map::NodeStmt(_)) => \"statement\",\n+          Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+            return on_unknown_scope();\n           }\n-        }\n+        };\n+        let scope_decorated_tag = match scope {\n+            region::CodeExtent::Misc(_) => tag,\n+            region::CodeExtent::Remainder(r) => {\n+                new_string = format!(\"block suffix following statement {}\",\n+                                     r.first_statement_index);\n+                new_string.as_slice()\n+            }\n+        };\n+        explain_span(cx, scope_decorated_tag, span)\n+\n       }\n \n       ReFree(ref fr) => {\n@@ -867,6 +872,17 @@ impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for region::CodeExtent {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            region::CodeExtent::Misc(node_id) =>\n+                format!(\"Misc({})\", node_id),\n+            region::CodeExtent::Remainder(rem) =>\n+                format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print"}, {"sha": "ee8bc71668b357c34f650479223872dc272e5273", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,10 +10,10 @@\n \n //! A helper class for dealing with static archives\n \n-use std::io::fs::PathExtensions;\n-use std::io::process::{Command, ProcessOutput};\n-use std::io::{fs, TempDir};\n-use std::io;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::process::{Command, ProcessOutput};\n+use std::old_io::{fs, TempDir};\n+use std::old_io;\n use std::os;\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n@@ -172,7 +172,7 @@ impl<'a> ArchiveBuilder<'a> {\n \n     /// Adds all of the contents of a native library to this archive. This will\n     /// search in the relevant locations for a library named `name`.\n-    pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n+    pub fn add_native_library(&mut self, name: &str) -> old_io::IoResult<()> {\n         let location = find_library(name,\n                                     &self.archive.slib_prefix[],\n                                     &self.archive.slib_suffix[],\n@@ -187,7 +187,7 @@ impl<'a> ArchiveBuilder<'a> {\n     /// This ignores adding the bytecode from the rlib, and if LTO is enabled\n     /// then the object file also isn't added.\n     pub fn add_rlib(&mut self, rlib: &Path, name: &str,\n-                    lto: bool) -> io::IoResult<()> {\n+                    lto: bool) -> old_io::IoResult<()> {\n         // Ignoring obj file starting with the crate name\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n@@ -205,7 +205,7 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     /// Adds an arbitrary file to this archive\n-    pub fn add_file(&mut self, file: &Path) -> io::IoResult<()> {\n+    pub fn add_file(&mut self, file: &Path) -> old_io::IoResult<()> {\n         let filename = Path::new(file.filename().unwrap());\n         let new_file = self.work_dir.path().join(&filename);\n         try!(fs::copy(file, &new_file));\n@@ -274,8 +274,9 @@ impl<'a> ArchiveBuilder<'a> {\n         self.archive\n     }\n \n-    fn add_archive<F>(&mut self, archive: &Path, name: &str, mut skip: F) -> io::IoResult<()> where\n-        F: FnMut(&str) -> bool,\n+    fn add_archive<F>(&mut self, archive: &Path, name: &str,\n+                      mut skip: F) -> old_io::IoResult<()>\n+        where F: FnMut(&str) -> bool,\n     {\n         let loc = TempDir::new(\"rsar\").unwrap();\n "}, {"sha": "24f81b024789c1fdb19456cb9f584f4e957de4ca", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n-use std::io::fs;\n+use std::old_io;\n+use std::old_io::fs;\n use std::os;\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n-pub fn realpath(original: &Path) -> io::IoResult<Path> {\n+pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n     let original = os::make_absolute(original).unwrap();\n \n@@ -32,12 +32,12 @@ pub fn realpath(original: &Path) -> io::IoResult<Path> {\n \n         loop {\n             if followed == MAX_LINKS_FOLLOWED {\n-                return Err(io::standard_error(io::InvalidInput))\n+                return Err(old_io::standard_error(old_io::InvalidInput))\n             }\n \n             match fs::lstat(&result) {\n                 Err(..) => break,\n-                Ok(ref stat) if stat.kind != io::FileType::Symlink => break,\n+                Ok(ref stat) if stat.kind != old_io::FileType::Symlink => break,\n                 Ok(..) => {\n                     followed += 1;\n                     let path = try!(fs::readlink(&result));\n@@ -53,10 +53,10 @@ pub fn realpath(original: &Path) -> io::IoResult<Path> {\n \n #[cfg(all(not(windows), test))]\n mod test {\n-    use std::io;\n-    use std::io::fs::{File, symlink, mkdir, mkdir_recursive};\n+    use std::old_io;\n+    use std::old_io::fs::{File, symlink, mkdir, mkdir_recursive};\n     use super::realpath;\n-    use std::io::TempDir;\n+    use std::old_io::TempDir;\n \n     #[test]\n     fn realpath_works() {\n@@ -68,7 +68,7 @@ mod test {\n         let linkdir = tmpdir.join(\"test3\");\n \n         File::create(&file).unwrap();\n-        mkdir(&dir, io::USER_RWX).unwrap();\n+        mkdir(&dir, old_io::USER_RWX).unwrap();\n         symlink(&file, &link).unwrap();\n         symlink(&dir, &linkdir).unwrap();\n \n@@ -91,8 +91,8 @@ mod test {\n         let e = d.join(\"e\");\n         let f = a.join(\"f\");\n \n-        mkdir_recursive(&b, io::USER_RWX).unwrap();\n-        mkdir_recursive(&d, io::USER_RWX).unwrap();\n+        mkdir_recursive(&b, old_io::USER_RWX).unwrap();\n+        mkdir_recursive(&d, old_io::USER_RWX).unwrap();\n         File::create(&f).unwrap();\n         symlink(&Path::new(\"../d/e\"), &c).unwrap();\n         symlink(&Path::new(\"../f\"), &e).unwrap();"}, {"sha": "bafd5fbe94487784e3219c900acb04b8a496eb16", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n \n use std::collections::HashSet;\n use std::os;\n-use std::io::IoError;\n+use std::old_io::IoError;\n use syntax::ast;\n \n pub struct RPathConfig<F, G> where"}, {"sha": "715bcc4f36dd0375679b9b5f439a45235d75ccd3", "filename": "src/librustc_back/target/apple_ios_base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fapple_ios_base.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::{Command, IoError, OtherIoError};\n+use std::old_io::{Command, IoError, OtherIoError};\n use target::TargetOptions;\n \n use self::Arch::*;"}, {"sha": "fcea900283d2851d1d785b6661d22e4556fc9bc4", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n+    base.cpu = \"yonah\".to_string();\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "249f2d440e68155fd01960d9924930cadfe85a6d", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut options = super::windows_base::opts();\n+    options.cpu = \"pentium4\".to_string();\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64."}, {"sha": "4450d8d67782d48fc899cdd684d38f447ccd7caf", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::dragonfly_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "f21f6adfb4c0c2a03eb28a5e0aed816508b0e59a", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,6 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::linux_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n     base.pre_link_args.push(\"-m32\".to_string());\n \n     Target {"}, {"sha": "a63e8237b4bef01780b68125debe00955e18a111", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -48,7 +48,7 @@\n use serialize::json::Json;\n use syntax::{diagnostic, abi};\n use std::default::Default;\n-use std::io::fs::PathExtensions;\n+use std::old_io::fs::PathExtensions;\n \n mod windows_base;\n mod linux_base;\n@@ -302,7 +302,7 @@ impl Target {\n     /// JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n         use std::os;\n-        use std::io::File;\n+        use std::old_io::File;\n         use std::path::Path;\n         use serialize::json;\n "}, {"sha": "0b3b2bea62d777cc920f01c2b2776402367de433", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@ use target::Target;\n \n pub fn target() -> Target {\n     let mut base = super::apple_base::opts();\n-    base.cpu = \"x86-64\".to_string();\n+    base.cpu = \"core2\".to_string();\n     base.eliminate_frame_pointer = false;\n     base.pre_link_args.push(\"-m64\".to_string());\n "}, {"sha": "6e76519ce23607fdbaf1b6567febd5f45b2e44c0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -30,8 +30,8 @@ use rustc_privacy;\n \n use serialize::json;\n \n-use std::io;\n-use std::io::fs;\n+use std::old_io;\n+use std::old_io::fs;\n use std::os;\n use syntax::ast;\n use syntax::ast_map;\n@@ -100,6 +100,7 @@ pub fn compile_input(sess: Session,\n                                                                  &id[]));\n \n         let mut forest = ast_map::Forest::new(expanded_crate);\n+        let arenas = ty::CtxtArenas::new();\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n         write_out_deps(&sess, input, &outputs, &id[]);\n@@ -111,7 +112,6 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map,\n                                                                      &id[]));\n \n-        let arenas = ty::CtxtArenas::new();\n         let analysis = phase_3_run_analysis_passes(sess,\n                                                    ast_map,\n                                                    &arenas,\n@@ -794,14 +794,14 @@ fn write_out_deps(sess: &Session,\n         _ => return,\n     };\n \n-    let result = (|&:| -> io::IoResult<()> {\n+    let result = (|&:| -> old_io::IoResult<()> {\n         // Build a list of files used to compile the output and\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n                                    .map(|fmap| escape_dep_filename(&fmap.name[]))\n                                    .collect();\n-        let mut file = try!(io::File::create(&deps_filename));\n+        let mut file = try!(old_io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n             try!(write!(&mut file as &mut Writer,\n                           \"{}: {}\\n\\n\", path.display(), files.connect(\" \")));"}, {"sha": "727638c29c35fb196c4ee9c154031a5971baa319", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -73,7 +73,7 @@ use rustc::metadata::creader::CrateOrString::Str;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n-use std::io;\n+use std::old_io;\n use std::iter::repeat;\n use std::os;\n use std::sync::mpsc::channel;\n@@ -142,7 +142,7 @@ fn run_compiler(args: &[String]) {\n         1u => {\n             let ifile = &matches.free[0][];\n             if ifile == \"-\" {\n-                let contents = io::stdin().read_to_end().unwrap();\n+                let contents = old_io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n                 (Input::Str(src), None)\n             } else {\n@@ -196,7 +196,7 @@ fn run_compiler(args: &[String]) {\n     if r.contains(&(\"ls\".to_string())) {\n         match input {\n             Input::File(ref ifile) => {\n-                let mut stdout = io::stdout();\n+                let mut stdout = old_io::stdout();\n                 list_metadata(&sess, &(*ifile), &mut stdout).unwrap();\n             }\n             Input::Str(_) => {\n@@ -599,7 +599,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n }\n \n pub fn list_metadata(sess: &Session, path: &Path,\n-                     out: &mut io::Writer) -> io::IoResult<()> {\n+                     out: &mut old_io::Writer) -> old_io::IoResult<()> {\n     metadata::loader::list_file_metadata(sess.target.target.options.is_like_osx, path, out)\n }\n \n@@ -612,8 +612,8 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     static STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n \n     let (tx, rx) = channel();\n-    let w = io::ChanWriter::new(tx);\n-    let mut r = io::ChanReader::new(rx);\n+    let w = old_io::ChanWriter::new(tx);\n+    let mut r = old_io::ChanReader::new(rx);\n \n     let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n \n@@ -623,7 +623,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n         cfg = cfg.stack_size(STACK_SIZE);\n     }\n \n-    match cfg.scoped(move || { std::io::stdio::set_stderr(box w); f() }).join() {\n+    match cfg.scoped(move || { std::old_io::stdio::set_stderr(box w); f() }).join() {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Thread panicked without emitting a fatal diagnostic\n@@ -665,7 +665,7 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n             // Panic so the process returns a failure code, but don't pollute the\n             // output with some unnecessary panic messages, we've already\n             // printed everything that we needed to.\n-            io::stdio::set_stderr(box io::util::NullWriter);\n+            old_io::stdio::set_stderr(box old_io::util::NullWriter);\n             panic!();\n         }\n     }"}, {"sha": "b09e9f14357776125a8f1d003b2724d92d66f081", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -38,7 +38,7 @@ use syntax::ptr::P;\n \n use graphviz as dot;\n \n-use std::io::{self, MemReader};\n+use std::old_io::{self, MemReader};\n use std::option;\n use std::str::FromStr;\n \n@@ -208,15 +208,15 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     fn pre(&self,\n            s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::IoResult<()> {\n+           node: pprust::AnnNode) -> old_io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::IoResult<()> {\n+            node: pprust::AnnNode) -> old_io::IoResult<()> {\n         match node {\n             pprust::NodeIdent(_) | pprust::NodeName(_) => Ok(()),\n \n@@ -259,7 +259,7 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::IoResult<()> {\n+            node: pprust::AnnNode) -> old_io::IoResult<()> {\n         match node {\n             pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n                 try!(pp::space(&mut s.s));\n@@ -294,15 +294,15 @@ impl<'tcx> PrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n-           node: pprust::AnnNode) -> io::IoResult<()> {\n+           node: pprust::AnnNode) -> old_io::IoResult<()> {\n         match node {\n             pprust::NodeExpr(_) => s.popen(),\n             _ => Ok(())\n         }\n     }\n     fn post(&self,\n             s: &mut pprust::State,\n-            node: pprust::AnnNode) -> io::IoResult<()> {\n+            node: pprust::AnnNode) -> old_io::IoResult<()> {\n         let tcx = &self.analysis.ty_cx;\n         match node {\n             pprust::NodeExpr(expr) => {\n@@ -548,9 +548,9 @@ pub fn pretty_print_input(sess: Session,\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {\n-        None => box io::stdout() as Box<Writer+'static>,\n+        None => box old_io::stdout() as Box<Writer+'static>,\n         Some(p) => {\n-            let r = io::File::create(&p);\n+            let r = old_io::File::create(&p);\n             match r {\n                 Ok(w) => box w as Box<Writer+'static>,\n                 Err(e) => panic!(\"print-print failed to open {} due to {}\",\n@@ -643,11 +643,11 @@ pub fn pretty_print_input(sess: Session,\n     }.unwrap()\n }\n \n-fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n+fn print_flowgraph<W:old_io::Writer>(variants: Vec<borrowck_dot::Variant>,\n                                  analysis: ty::CrateAnalysis,\n                                  code: blocks::Code,\n                                  mode: PpFlowGraphMode,\n-                                 mut out: W) -> io::IoResult<()> {\n+                                 mut out: W) -> old_io::IoResult<()> {\n     let ty_cx = &analysis.ty_cx;\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(ty_cx, &*block),\n@@ -687,11 +687,11 @@ fn print_flowgraph<W:io::Writer>(variants: Vec<borrowck_dot::Variant>,\n         }\n     }\n \n-    fn expand_err_details(r: io::IoResult<()>) -> io::IoResult<()> {\n+    fn expand_err_details(r: old_io::IoResult<()>) -> old_io::IoResult<()> {\n         r.map_err(|ioerr| {\n             let orig_detail = ioerr.detail.clone();\n             let m = \"graphviz::render failed\";\n-            io::IoError {\n+            old_io::IoError {\n                 detail: Some(match orig_detail {\n                     None => m.to_string(),\n                     Some(d) => format!(\"{}: {}\", m, d)"}, {"sha": "52d7415a523df3467ea215b1a13f7a88327325b0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -103,7 +103,7 @@ fn test_env<F>(source_string: &str,\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler(emitter);\n+        diagnostic::mk_handler(true, emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -115,6 +115,7 @@ fn test_env<F>(source_string: &str,\n                     .expect(\"phase 2 aborted\");\n \n     let mut forest = ast_map::Forest::new(krate);\n+    let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n     let krate = ast_map.krate();\n \n@@ -125,7 +126,6 @@ fn test_env<F>(source_string: &str,\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(&sess, krate);\n-    let arenas = ty::CtxtArenas::new();\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,\n                           def_map,"}, {"sha": "f5a6f3d95a2c466054e3b81e303c9578af380b54", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -27,9 +27,9 @@ use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n \n-use std::io::fs::PathExtensions;\n-use std::io::{fs, TempDir, Command};\n-use std::io;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::{fs, TempDir, Command};\n+use std::old_io;\n use std::mem;\n use std::str;\n use std::string::String;\n@@ -425,7 +425,7 @@ pub fn invalid_output_for_target(sess: &Session,\n fn is_writeable(p: &Path) -> bool {\n     match p.stat() {\n         Err(..) => true,\n-        Ok(m) => m.perm & io::USER_WRITE == io::USER_WRITE\n+        Ok(m) => m.perm & old_io::USER_WRITE == old_io::USER_WRITE\n     }\n }\n \n@@ -586,8 +586,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(&trans.metadata\n-                                                    []) {\n+            match fs::File::create(&metadata).write_all(&trans.metadata[]) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(&format!(\"failed to write {}: {}\",\n@@ -671,13 +670,13 @@ fn link_rlib<'a>(sess: &'a Session,\n \n fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n                                             bc_data_deflated: &[u8])\n-                                         -> ::std::io::IoResult<()> {\n+                                         -> ::std::old_io::IoResult<()> {\n     let bc_data_deflated_size: u64 = bc_data_deflated.len() as u64;\n \n-    try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n+    try! { writer.write_all(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(&bc_data_deflated[]) };\n+    try! { writer.write_all(&bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -1201,7 +1200,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 // Fix up permissions of the copy, as fs::copy() preserves\n                 // permissions, but the original file may have been installed\n                 // by a package manager and may be read-only.\n-                match fs::chmod(&dst, io::USER_READ | io::USER_WRITE) {\n+                match fs::chmod(&dst, old_io::USER_READ | old_io::USER_WRITE) {\n                     Ok(..) => {}\n                     Err(e) => {\n                         sess.err(&format!(\"failed to chmod {} when preparing \\"}, {"sha": "15b9d6237ed4ce2db0041f39719d17c0269b82c1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -23,8 +23,8 @@ use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n use std::ffi::{self, CString};\n-use std::io::Command;\n-use std::io::fs;\n+use std::old_io::Command;\n+use std::old_io::fs;\n use std::iter::Unfold;\n use std::ptr;\n use std::str;\n@@ -728,9 +728,9 @@ pub fn run_passes(sess: &Session,\n             println!(\"{:?}\", &cmd);\n         }\n \n-        cmd.stdin(::std::io::process::Ignored)\n-           .stdout(::std::io::process::InheritFd(1))\n-           .stderr(::std::io::process::InheritFd(2));\n+        cmd.stdin(::std::old_io::process::Ignored)\n+           .stdout(::std::old_io::process::InheritFd(1))\n+           .stderr(::std::old_io::process::InheritFd(2));\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {"}, {"sha": "7e7176d661c6fa0781b79d82795af9dcc7d70d13", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -33,7 +33,7 @@ use middle::def;\n use middle::ty::{self, Ty};\n \n use std::cell::Cell;\n-use std::io::{self, File, fs};\n+use std::old_io::{self, File, fs};\n use std::os;\n \n use syntax::ast_util::{self, PostExpansionMethod};\n@@ -1532,7 +1532,7 @@ pub fn process_crate(sess: &Session,\n         },\n     };\n \n-    match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n+    match fs::mkdir_recursive(&root_path, old_io::USER_RWX) {\n         Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n                            root_path.display(), e)[]),\n         _ => (),"}, {"sha": "5a98bc4da3682384b3cd28089555918cc6f2461c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -1784,15 +1784,16 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n \n-    let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfndecl,\n-                          fn_ast_id,\n-                          closure_env.kind != closure::NotClosure,\n-                          output_type,\n-                          param_substs,\n-                          Some(body.span),\n-                          &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfndecl,\n+                      fn_ast_id,\n+                      closure_env.kind != closure::NotClosure,\n+                      output_type,\n+                      param_substs,\n+                      Some(body.span),\n+                      &arena);\n     let mut bcx = init_function(&fcx, false, output_type);\n \n     // cleanup scope for the incoming arguments\n@@ -2046,9 +2047,10 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                     ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n-    let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n-                          param_substs, None, &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n+                      param_substs, None, &arena);\n     let bcx = init_function(&fcx, false, result_ty);\n \n     assert!(!fcx.needs_ret_allocas);"}, {"sha": "d038407791ef6a8e7c4a613776fb4de480afaf6f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -322,16 +322,17 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                               &function_name[]);\n \n     //\n-    let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          sig.output,\n-                          &empty_substs,\n-                          None,\n-                          &block_arena);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      &empty_substs,\n+                      None,\n+                      &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer"}, {"sha": "69d1922ab9adb3e271a2f51a4cd1eef04e5f19fb", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -540,11 +540,12 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let arena = TypedArena::new();\n     let empty_param_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                          ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                          &empty_param_substs, None, &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      &empty_param_substs, None, &arena);\n \n     let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n "}, {"sha": "187b73b1b0952fc0b49172506d94239a609e5458", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -601,17 +601,17 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n-    //\n-    let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          sig.output,\n-                          &empty_substs,\n-                          None,\n-                          &block_arena);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      &empty_substs,\n+                      None,\n+                      &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be a trait object"}, {"sha": "4c5a8144cbd064ead01dd46c4dcd90d774084cc2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -1049,8 +1049,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // if there are any.\n         assert_eq!(substs.types.len(subst::FnSpace), 0);\n         assert_eq!(substs.regions().len(subst::FnSpace), 0);\n-        let mut substs = substs;\n         let placeholder;\n+        let mut substs = substs;\n         if\n             !method.generics.types.is_empty_in(subst::FnSpace) ||\n             !method.generics.regions.is_empty_in(subst::FnSpace)"}, {"sha": "65560040f47c28e923d83017f4288ab48531f433", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 101, "deletions": 87, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -990,86 +990,65 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_cast(fcx: &FnCtxt,\n-              cast_expr: &ast::Expr,\n-              e: &ast::Expr,\n-              t: &ast::Ty) {\n-    let id = cast_expr.id;\n-    let span = cast_expr.span;\n-\n-    // Find the type of `e`. Supply hints based on the type we are casting to,\n-    // if appropriate.\n-    let t_1 = fcx.to_ty(t);\n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-\n-    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n-\n-    let t_e = fcx.expr_ty(e);\n-\n-    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n-    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n-\n-    if ty::type_is_error(t_e) {\n-        fcx.write_error(id);\n-        return\n-    }\n-\n-    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n-        let tstr = fcx.infcx().ty_to_string(t_1);\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, t_e, None);\n-        match t_e.sty {\n-            ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n-                let mtstr = match mt {\n-                    ast::MutMutable => \"mut \",\n-                    ast::MutImmutable => \"\"\n-                };\n-                if ty::type_is_trait(t_1) {\n-                    span_help!(fcx.tcx().sess, t.span, \"did you mean `&{}{}`?\", mtstr, tstr);\n-                } else {\n-                    span_help!(fcx.tcx().sess, span,\n-                               \"consider using an implicit coercion to `&{}{}` instead\",\n-                               mtstr, tstr);\n-                }\n-            }\n-            ty::ty_uniq(..) => {\n-                span_help!(fcx.tcx().sess, t.span, \"did you mean `Box<{}>`?\", tstr);\n-            }\n-            _ => {\n-                span_help!(fcx.tcx().sess, e.span,\n-                           \"consider using a box or reference as appropriate\");\n+fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                         span: Span,\n+                                         t_span: Span,\n+                                         e_span: Span,\n+                                         t_1: Ty<'tcx>,\n+                                         t_e: Ty<'tcx>,\n+                                         id: ast::NodeId) {\n+    let tstr = fcx.infcx().ty_to_string(t_1);\n+    fcx.type_error_message(span, |actual| {\n+        format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n+    }, t_e, None);\n+    match t_e.sty {\n+        ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n+            let mtstr = match mt {\n+                ast::MutMutable => \"mut \",\n+                ast::MutImmutable => \"\"\n+            };\n+            if ty::type_is_trait(t_1) {\n+                span_help!(fcx.tcx().sess, t_span, \"did you mean `&{}{}`?\", mtstr, tstr);\n+            } else {\n+                span_help!(fcx.tcx().sess, span,\n+                           \"consider using an implicit coercion to `&{}{}` instead\",\n+                           mtstr, tstr);\n             }\n         }\n-        fcx.write_error(id);\n-        return\n-    }\n-\n-    if ty::type_is_trait(t_1) {\n-        // This will be looked up later on.\n-        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n-        fcx.write_ty(id, t_1);\n-        return\n+        ty::ty_uniq(..) => {\n+            span_help!(fcx.tcx().sess, t_span, \"did you mean `Box<{}>`?\", tstr);\n+        }\n+        _ => {\n+            span_help!(fcx.tcx().sess, e_span,\n+                       \"consider using a box or reference as appropriate\");\n+        }\n     }\n+    fcx.write_error(id);\n+}\n \n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-    let t_e = structurally_resolved_type(fcx, span, t_e);\n \n-    if ty::type_is_nil(t_e) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cast from nil: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n-    } else if ty::type_is_nil(t_1) {\n+fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                              span: Span,\n+                              t_1: Ty<'tcx>,\n+                              t_e: Ty<'tcx>,\n+                              e: &ast::Expr) {\n+    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          t_1: Ty<'tcx>,\n+                                          t_e: Ty<'tcx>) {\n         fcx.type_error_message(span, |actual| {\n-            format!(\"cast to nil: `{}` as `{}`\",\n+            format!(\"illegal cast; cast through an \\\n+                    integer first: `{}` as `{}`\",\n                     actual,\n                     fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n     }\n \n     let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n+    let t_e_is_scalar = ty::type_is_scalar(t_e);\n+    let t_e_is_integral = ty::type_is_integral(t_e);\n+    let t_e_is_float = ty::type_is_floating_point(t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n \n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n@@ -1078,18 +1057,9 @@ fn check_cast(fcx: &FnCtxt,\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n+\n     if t_e_is_bare_fn_item && t_1_is_bare_fn {\n         demand::coerce(fcx, e.span, t_1, &*e);\n-    } else if ty::type_is_c_like_enum(fcx.tcx(), t_e) && t_1_is_trivial {\n-        if t_1_is_float || ty::type_is_unsafe_ptr(t_1) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"illegal cast; cast through an \\\n-                         integer first: `{}` as `{}`\",\n-                        actual,\n-                        fcx.infcx().ty_to_string(t_1))\n-            }, t_e, None);\n-        }\n-        // casts from C-like enums are allowed\n     } else if t_1_is_char {\n         let t_e = fcx.infcx().shallow_resolve(t_e);\n         if t_e.sty != ty::ty_uint(ast::TyU8) {\n@@ -1101,6 +1071,16 @@ fn check_cast(fcx: &FnCtxt,\n     } else if t_1.sty == ty::ty_bool {\n         span_err!(fcx.tcx().sess, span, E0054,\n             \"cannot cast as `bool`, compare with zero instead\");\n+    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n+        t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n+        // Casts to float must go through an integer or boolean\n+        cast_through_integer_err(fcx, span, t_1, t_e)\n+    } else if t_e_is_c_enum && t_1_is_trivial {\n+        if ty::type_is_unsafe_ptr(t_1) {\n+            // ... and likewise with C enum -> *T\n+            cast_through_integer_err(fcx, span, t_1, t_e)\n+        }\n+        // casts from C-like enums are allowed\n     } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n         fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n                                       t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n@@ -1142,7 +1122,7 @@ fn check_cast(fcx: &FnCtxt,\n                 demand::coerce(fcx, e.span, t_1, &*e);\n             }\n         }\n-    } else if !(ty::type_is_scalar(t_e) && t_1_is_trivial) {\n+    } else if !(t_e_is_scalar && t_1_is_trivial) {\n         /*\n         If more type combinations should be supported than are\n         supported here, then file an enhancement issue and\n@@ -1153,15 +1133,49 @@ fn check_cast(fcx: &FnCtxt,\n                     actual,\n                     fcx.infcx().ty_to_string(t_1))\n         }, t_e, None);\n-    } else if ty::type_is_unsafe_ptr(t_e) && t_1_is_float {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cannot cast from pointer to float directly: `{}` as `{}`; cast through an \\\n-                     integer first\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n     }\n+}\n+\n+fn check_cast(fcx: &FnCtxt,\n+              cast_expr: &ast::Expr,\n+              e: &ast::Expr,\n+              t: &ast::Ty) {\n+    let id = cast_expr.id;\n+    let span = cast_expr.span;\n+\n+    // Find the type of `e`. Supply hints based on the type we are casting to,\n+    // if appropriate.\n+    let t_1 = fcx.to_ty(t);\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+\n+    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n \n+    let t_e = fcx.expr_ty(e);\n+\n+    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n+    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n+\n+    if ty::type_is_error(t_e) {\n+        fcx.write_error(id);\n+        return\n+    }\n+\n+    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n+        report_cast_to_unsized_type(fcx, span, t.span, e.span, t_1, t_e, id);\n+        return\n+    }\n+\n+    if ty::type_is_trait(t_1) {\n+        // This will be looked up later on.\n+        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n+        fcx.write_ty(id, t_1);\n+        return\n+    }\n+\n+    let t_1 = structurally_resolved_type(fcx, span, t_1);\n+    let t_e = structurally_resolved_type(fcx, span, t_e);\n+\n+    check_cast_inner(fcx, span, t_1, t_e, e);\n     fcx.write_ty(id, t_1);\n }\n \n@@ -3087,8 +3101,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let name = ident.get();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let mut best = None;\n         let fields = ty::lookup_struct_fields(tcx, id);\n+        let mut best = None;\n         for elem in fields.iter() {\n             let n = elem.name.as_str();\n             // ignore already set fields"}, {"sha": "fc3d6f5912ffb566c1a88f73001fc21551192c87", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -126,9 +126,9 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let mut forest = ast_map::Forest::new(krate);\n+    let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let arenas = ty::CtxtArenas::new();\n     let ty::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = driver::phase_3_run_analysis_passes(sess,"}, {"sha": "79ca24a18d4d02cb1971f765d3be929d3f47b687", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{io, str};\n+use std::{old_io, str};\n \n #[derive(Clone)]\n pub struct ExternalHtml{\n@@ -33,8 +33,8 @@ impl ExternalHtml {\n     }\n }\n \n-pub fn load_string(input: &Path) -> io::IoResult<Option<String>> {\n-    let mut f = try!(io::File::open(input));\n+pub fn load_string(input: &Path) -> old_io::IoResult<Option<String>> {\n+    let mut f = try!(old_io::File::open(input));\n     let d = try!(f.read_to_end());\n     Ok(str::from_utf8(d.as_slice()).map(|s| s.to_string()).ok())\n }\n@@ -45,12 +45,12 @@ macro_rules! load_or_return {\n             let input = Path::new($input);\n             match ::externalfiles::load_string(&input) {\n                 Err(e) => {\n-                    let _ = writeln!(&mut io::stderr(),\n+                    let _ = writeln!(&mut old_io::stderr(),\n                                      \"error reading `{}`: {}\", input.display(), e);\n                     return $cant_read;\n                 }\n                 Ok(None) => {\n-                    let _ = writeln!(&mut io::stderr(),\n+                    let _ = writeln!(&mut old_io::stderr(),\n                                      \"error reading `{}`: not UTF-8\", input.display());\n                     return $not_utf8;\n                 }"}, {"sha": "38b191846f1985229c1f494731a884738a63fd6a", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@\n \n use html::escape::Escape;\n \n-use std::io;\n+use std::old_io;\n use syntax::parse::lexer;\n use syntax::parse::token;\n use syntax::parse;\n@@ -46,7 +46,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n /// source.\n fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n         class: Option<&str>, id: Option<&str>,\n-        out: &mut Writer) -> io::IoResult<()> {\n+        out: &mut Writer) -> old_io::IoResult<()> {\n     use syntax::parse::lexer::Reader;\n \n     try!(write!(out, \"<pre \"));"}, {"sha": "c537e370723d7ca2526e0fc2cbbac25c9f7eeb19", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::fmt;\n-use std::io;\n+use std::old_io;\n \n use externalfiles::ExternalHtml;\n \n@@ -31,8 +31,8 @@ pub struct Page<'a> {\n }\n \n pub fn render<T: fmt::Display, S: fmt::Display>(\n-    dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n-    -> io::IoResult<()>\n+    dst: &mut old_io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n+    -> old_io::IoResult<()>\n {\n     write!(dst,\n r##\"<!DOCTYPE html>\n@@ -159,7 +159,7 @@ r##\"<!DOCTYPE html>\n     )\n }\n \n-pub fn redirect(dst: &mut io::Writer, url: &str) -> io::IoResult<()> {\n+pub fn redirect(dst: &mut old_io::Writer, url: &str) -> old_io::IoResult<()> {\n     // <script> triggers a redirect before refresh, so this is fine.\n     write!(dst,\n r##\"<!DOCTYPE html>"}, {"sha": "956d50efd697b9890d6b1c584c8a21eedb0955c4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -39,9 +39,9 @@ use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;\n-use std::io::fs::PathExtensions;\n-use std::io::{fs, File, BufferedWriter, BufferedReader};\n-use std::io;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::{fs, File, BufferedWriter, BufferedReader};\n+use std::old_io;\n use std::iter::repeat;\n use std::str;\n use std::sync::Arc;\n@@ -257,7 +257,7 @@ thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: Path,\n-           passes: HashSet<String>) -> io::IoResult<()> {\n+           passes: HashSet<String>) -> old_io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         src_root: krate.src.dir_path(),\n@@ -391,7 +391,7 @@ pub fn run(mut krate: clean::Crate,\n     cx.krate(krate, summary)\n }\n \n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String> {\n+fn build_index(krate: &clean::Crate, cache: &mut Cache) -> old_io::IoResult<String> {\n     // Build the search index from the collected metadata\n     let mut nodeid_to_pathid = HashMap::new();\n     let mut pathid_to_nodeid = Vec::new();\n@@ -485,7 +485,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n fn write_shared(cx: &Context,\n                 krate: &clean::Crate,\n                 cache: &Cache,\n-                search_index: String) -> io::IoResult<()> {\n+                search_index: String) -> old_io::IoResult<()> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n     // operation with respect to all other rustdocs running around.\n@@ -517,7 +517,7 @@ fn write_shared(cx: &Context,\n                include_bytes!(\"static/SourceCodePro-Semibold.woff\")));\n \n     fn collect(path: &Path, krate: &str,\n-               key: &str) -> io::IoResult<Vec<String>> {\n+               key: &str) -> old_io::IoResult<Vec<String>> {\n         let mut ret = Vec::new();\n         if path.exists() {\n             for line in BufferedReader::new(File::open(path)).lines() {\n@@ -607,7 +607,7 @@ fn write_shared(cx: &Context,\n }\n \n fn render_sources(cx: &mut Context,\n-                  krate: clean::Crate) -> io::IoResult<clean::Crate> {\n+                  krate: clean::Crate) -> old_io::IoResult<clean::Crate> {\n     info!(\"emitting source files\");\n     let dst = cx.dst.join(\"src\");\n     try!(mkdir(&dst));\n@@ -625,15 +625,15 @@ fn render_sources(cx: &mut Context,\n \n /// Writes the entire contents of a string to a destination, not attempting to\n /// catch any errors.\n-fn write(dst: Path, contents: &[u8]) -> io::IoResult<()> {\n-    File::create(&dst).write(contents)\n+fn write(dst: Path, contents: &[u8]) -> old_io::IoResult<()> {\n+    File::create(&dst).write_all(contents)\n }\n \n /// Makes a directory on the filesystem, failing the task if an error occurs and\n /// skipping if the directory already exists.\n-fn mkdir(path: &Path) -> io::IoResult<()> {\n+fn mkdir(path: &Path) -> old_io::IoResult<()> {\n     if !path.exists() {\n-        fs::mkdir(path, io::USER_RWX)\n+        fs::mkdir(path, old_io::USER_RWX)\n     } else {\n         Ok(())\n     }\n@@ -736,7 +736,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &str) -> io::IoResult<()> {\n+    fn emit_source(&mut self, filename: &str) -> old_io::IoResult<()> {\n         let p = Path::new(filename);\n \n         // If we couldn't open this file, then just returns because it\n@@ -1084,7 +1084,7 @@ impl Context {\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n     fn krate(mut self, mut krate: clean::Crate,\n-             stability: stability_summary::ModuleSummary) -> io::IoResult<()> {\n+             stability: stability_summary::ModuleSummary) -> old_io::IoResult<()> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n@@ -1134,11 +1134,11 @@ impl Context {\n     /// all sub-items which need to be rendered.\n     ///\n     /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, mut f: F) -> io::IoResult<()> where\n+    fn item<F>(&mut self, item: clean::Item, mut f: F) -> old_io::IoResult<()> where\n         F: FnMut(&mut Context, clean::Item),\n     {\n-        fn render(w: io::File, cx: &Context, it: &clean::Item,\n-                  pushname: bool) -> io::IoResult<()> {\n+        fn render(w: old_io::File, cx: &Context, it: &clean::Item,\n+                  pushname: bool) -> old_io::IoResult<()> {\n             info!(\"Rendering an item to {}\", w.path().display());\n             // A little unfortunate that this is done like this, but it sure\n             // does make formatting *a lot* nicer."}, {"sha": "75812a2803c07fad4598fe01189a4b7de607aa51", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -49,8 +49,8 @@ extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::io::File;\n-use std::io;\n+use std::old_io::File;\n+use std::old_io;\n use std::rc::Rc;\n use externalfiles::ExternalHtml;\n use serialize::Decodable;\n@@ -487,7 +487,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n /// Outputs the crate/plugin json as a giant json blob at the specified\n /// destination.\n fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n-               dst: Path) -> io::IoResult<()> {\n+               dst: Path) -> old_io::IoResult<()> {\n     // {\n     //   \"schema\": version,\n     //   \"crate\": { parsed crate ... },"}, {"sha": "7f932b6ca21d97dd5888dc1ed02e540ec4b221a5", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::old_io;\n \n use core;\n use getopts;\n@@ -59,9 +59,9 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n     }\n     let playground = playground.unwrap_or(\"\".to_string());\n \n-    let mut out = match io::File::create(&output) {\n+    let mut out = match old_io::File::create(&output) {\n         Err(e) => {\n-            let _ = writeln!(&mut io::stderr(),\n+            let _ = writeln!(&mut old_io::stderr(),\n                              \"error opening `{}` for writing: {}\",\n                              output.display(), e);\n             return 4;\n@@ -71,7 +71,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n \n     let (metadata, text) = extract_leading_metadata(input_str.as_slice());\n     if metadata.len() == 0 {\n-        let _ = writeln!(&mut io::stderr(),\n+        let _ = writeln!(&mut old_io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;\n     }\n@@ -126,7 +126,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches,\n \n     match err {\n         Err(e) => {\n-            let _ = writeln!(&mut io::stderr(),\n+            let _ = writeln!(&mut old_io::stderr(),\n                              \"error writing to `{}`: {}\",\n                              output.display(), e);\n             6"}, {"sha": "2f692fe99cda7f61275a4f204a1fd1946bbf512b", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,8 +11,8 @@\n use std::cell::RefCell;\n use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n-use std::io::{Command, TempDir};\n-use std::io;\n+use std::old_io::{Command, TempDir};\n+use std::old_io;\n use std::os;\n use std::str;\n use std::thread::Thread;\n@@ -145,20 +145,20 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     // The basic idea is to not use a default_handler() for rustc, and then also\n     // not print things by default to the actual stderr.\n     let (tx, rx) = channel();\n-    let w1 = io::ChanWriter::new(tx);\n+    let w1 = old_io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n-    let old = io::stdio::set_stderr(box w1);\n+    let old = old_io::stdio::set_stderr(box w1);\n     Thread::spawn(move |:| {\n-        let mut p = io::ChanReader::new(rx);\n+        let mut p = old_io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {\n                 // Chop off the `Send` bound.\n                 let old: Box<Writer> = old;\n                 old\n             }\n-            None => box io::stderr() as Box<Writer>,\n+            None => box old_io::stderr() as Box<Writer>,\n         };\n-        io::util::copy(&mut p, &mut err).unwrap();\n+        old_io::util::copy(&mut p, &mut err).unwrap();\n     });\n     let emitter = diagnostic::EmitterWriter::new(box w2, None);\n \n@@ -200,7 +200,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n \n     match cmd.output() {\n         Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n-                        if e.kind == io::PermissionDenied {\n+                        if e.kind == old_io::PermissionDenied {\n                             \" - maybe your tempdir is mounted with noexec?\"\n                         } else { \"\" }),\n         Ok(out) => {"}, {"sha": "dad72fbd0e30b15d488a93646cb1c492da5c5dc0", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -201,7 +201,7 @@ use self::InternalStackElement::*;\n \n use std;\n use std::collections::{HashMap, BTreeMap};\n-use std::{char, f64, fmt, io, num, str};\n+use std::{char, f64, fmt, old_io, num, str};\n use std::mem::{swap};\n use std::num::{Float, Int};\n use std::num::FpCategory as Fp;\n@@ -260,7 +260,7 @@ pub enum ErrorCode {\n pub enum ParserError {\n     /// msg, line, col\n     SyntaxError(ErrorCode, uint, uint),\n-    IoError(io::IoErrorKind, &'static str),\n+    IoError(old_io::IoErrorKind, &'static str),\n }\n \n // Builder and Parser have the same errors.\n@@ -331,7 +331,7 @@ impl fmt::Display for ErrorCode {\n     }\n }\n \n-fn io_error_to_error(io: io::IoError) -> ParserError {\n+fn io_error_to_error(io: old_io::IoError) -> ParserError {\n     IoError(io.kind, io.desc)\n }\n \n@@ -2057,8 +2057,8 @@ impl<T: Iterator<Item=char>> Builder<T> {\n     }\n }\n \n-/// Decodes a json value from an `&mut io::Reader`\n-pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, BuilderError> {\n+/// Decodes a json value from an `&mut old_io::Reader`\n+pub fn from_reader(rdr: &mut old_io::Reader) -> Result<Json, BuilderError> {\n     let contents = match rdr.read_to_end() {\n         Ok(c)  => c,\n         Err(e) => return Err(io_error_to_error(e))\n@@ -2618,7 +2618,7 @@ mod tests {\n     use super::JsonEvent::*;\n     use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Decoder, Encoder, EncoderError};\n-    use std::{i64, u64, f32, f64, io};\n+    use std::{i64, u64, f32, f64, old_io};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n     use std::string;\n@@ -3456,7 +3456,7 @@ mod tests {\n     #[test]\n     fn test_encode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::io::Writer;\n+        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n@@ -3472,7 +3472,7 @@ mod tests {\n     #[test]\n     fn test_prettyencode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::io::Writer;\n+        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<uint, bool> = HashMap::new();\n         hm.insert(1, true);\n@@ -3929,7 +3929,7 @@ mod tests {\n     #[test]\n     fn test_encode_hashmap_with_arbitrary_key() {\n         use std::str::from_utf8;\n-        use std::io::Writer;\n+        use std::old_io::Writer;\n         use std::collections::HashMap;\n         use std::fmt;\n         #[derive(PartialEq, Eq, Hash, RustcEncodable)]"}, {"sha": "c184d3f4661f16e519ae356771f5d7b824e14b4a", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,20 +14,20 @@ use prelude::v1::*;\n \n use any::Any;\n use cell::RefCell;\n-use io::IoResult;\n+use old_io::IoResult;\n use rt::{backtrace, unwind};\n use rt::util::{Stderr, Stdio};\n use thread::Thread;\n \n-// Defined in this module instead of io::stdio so that the unwinding\n+// Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n     pub static LOCAL_STDERR: RefCell<Option<Box<Writer + Send>>> = {\n         RefCell::new(None)\n     }\n }\n \n impl Writer for Stdio {\n-    fn write(&mut self, bytes: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, bytes: &[u8]) -> IoResult<()> {\n         let _ = self.write_bytes(bytes);\n         Ok(())\n     }"}, {"sha": "4ab43e875cdffad9d8033bbf50e7c95e43b4f719", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -238,7 +238,7 @@\n //!\n //! ```ignore\n //! format!      // described above\n-//! write!       // first argument is a &mut io::Writer, the destination\n+//! write!       // first argument is a &mut old_io::Writer, the destination\n //! writeln!     // same as write but appends a newline\n //! print!       // the format string is printed to the standard output\n //! println!     // same as print but appends a newline\n@@ -255,10 +255,8 @@\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io;\n-//!\n //! let mut w = Vec::new();\n-//! write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n+//! write!(&mut w, \"Hello {}!\", \"world\");\n //! ```\n //!\n //! #### `print!`\n@@ -282,15 +280,15 @@\n //!\n //! ```\n //! use std::fmt;\n-//! use std::io;\n+//! use std::old_io;\n //!\n //! fmt::format(format_args!(\"this returns {}\", \"String\"));\n //!\n-//! let some_writer: &mut io::Writer = &mut io::stdout();\n-//! write!(some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n+//! let mut some_writer = old_io::stdout();\n+//! write!(&mut some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n //!\n //! fn my_fmt_fn(args: fmt::Arguments) {\n-//!     write!(&mut io::stdout(), \"{}\", args);\n+//!     write!(&mut old_io::stdout(), \"{}\", args);\n //! }\n //! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n //! ```"}, {"sha": "3a745389e1e719f83d8d7159c864efe4275b5c1e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -79,7 +79,8 @@\n //! memory types, including [`atomic`](sync/atomic/index.html).\n //!\n //! Common types of I/O, including files, TCP, UDP, pipes, Unix domain sockets,\n-//! timers, and process spawning, are defined in the [`io`](io/index.html) module.\n+//! timers, and process spawning, are defined in the\n+//! [`old_io`](old_io/index.html) module.\n //!\n //! Rust's I/O and concurrency depends on a small runtime interface\n //! that lives, along with its support code, in mod [`rt`](rt/index.html).\n@@ -247,7 +248,7 @@ pub mod thread_local;\n pub mod dynamic_lib;\n pub mod ffi;\n pub mod fmt;\n-pub mod io;\n+pub mod old_io;\n pub mod os;\n pub mod path;\n pub mod rand;\n@@ -292,7 +293,7 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    pub use io; // used for println!()\n+    pub use old_io; // used for println!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]"}, {"sha": "9c3285a9d0890b701300603b0599a45100b8035c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -81,14 +81,14 @@ macro_rules! format {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! print {\n-    ($($arg:tt)*) => ($crate::io::stdio::print_args(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::old_io::stdio::print_args(format_args!($($arg)*)))\n }\n \n /// Macro for printing to a task's stdout handle.\n ///\n-/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// Each task can override its stdout handle via `std::old_io::stdio::set_stdout`.\n /// The syntax of this macro is the same as that used for `format!`. For more\n-/// information, see `std::fmt` and `std::io::stdio`.\n+/// information, see `std::fmt` and `std::old_io::stdio`.\n ///\n /// # Example\n ///\n@@ -99,7 +99,7 @@ macro_rules! print {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! println {\n-    ($($arg:tt)*) => ($crate::io::stdio::println_args(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::old_io::stdio::println_args(format_args!($($arg)*)))\n }\n \n /// Helper macro for unwrapping `Result` values while returning early with an"}, {"sha": "1590598c0b8a76a5d7993c4bc1168cf896c078a1", "filename": "src/libstd/old_io/buffered.rs", "status": "renamed", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,7 +14,7 @@\n \n use cmp;\n use fmt;\n-use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n+use old_io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::{IteratorExt, ExactSizeIterator, repeat};\n use ops::Drop;\n use option::Option;\n@@ -34,7 +34,7 @@ use vec::Vec;\n /// # Example\n ///\n /// ```rust\n-/// use std::io::{BufferedReader, File};\n+/// use std::old_io::{BufferedReader, File};\n ///\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut reader = BufferedReader::new(file);\n@@ -137,7 +137,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::{BufferedWriter, File};\n+/// use std::old_io::{BufferedWriter, File};\n ///\n /// let file = File::create(&Path::new(\"message.txt\")).unwrap();\n /// let mut writer = BufferedWriter::new(file);\n@@ -184,7 +184,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(&self.buf[..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write_all(&self.buf[..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -213,13 +213,13 @@ impl<W: Writer> BufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         if self.pos + buf.len() > self.buf.len() {\n             try!(self.flush_buf());\n         }\n \n         if buf.len() > self.buf.len() {\n-            self.inner.as_mut().unwrap().write(buf)\n+            self.inner.as_mut().unwrap().write_all(buf)\n         } else {\n             let dst = &mut self.buf[self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n@@ -281,15 +281,15 @@ impl<W: Writer> LineBufferedWriter<W> {\n }\n \n impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(&buf[..i + 1]));\n+                try!(self.inner.write_all(&buf[..i + 1]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(&buf[i + 1..]));\n+                try!(self.inner.write_all(&buf[i + 1..]));\n                 Ok(())\n             }\n-            None => self.inner.write(buf),\n+            None => self.inner.write_all(buf),\n         }\n     }\n \n@@ -324,12 +324,12 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::{BufferedStream, File};\n+/// use std::old_io::{BufferedStream, File};\n ///\n /// let file = File::open(&Path::new(\"message.txt\"));\n /// let mut stream = BufferedStream::new(file);\n ///\n-/// stream.write(\"hello, world\".as_bytes());\n+/// stream.write_all(\"hello, world\".as_bytes());\n /// stream.flush();\n ///\n /// let mut buf = [0; 100];\n@@ -412,8 +412,8 @@ impl<S: Stream> Reader for BufferedStream<S> {\n }\n \n impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.inner.get_mut().write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.inner.inner.get_mut().write_all(buf)\n     }\n     fn flush(&mut self) -> IoResult<()> {\n         self.inner.inner.get_mut().flush()\n@@ -423,7 +423,7 @@ impl<S: Stream> Writer for BufferedStream<S> {\n #[cfg(test)]\n mod test {\n     extern crate test;\n-    use io;\n+    use old_io;\n     use prelude::v1::*;\n     use super::*;\n     use super::super::{IoResult, EndOfFile};\n@@ -437,13 +437,13 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::EndOfFile))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     impl Writer for NullStream {\n-        fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n+        fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n     }\n \n     /// A dummy reader intended at testing short-reads propagation.\n@@ -452,9 +452,9 @@ mod test {\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.lengths.is_empty() {\n-                Err(io::standard_error(io::EndOfFile))\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             } else {\n                 Ok(self.lengths.remove(0))\n             }\n@@ -503,34 +503,34 @@ mod test {\n         let inner = Vec::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n-        writer.write(&[0, 1]).unwrap();\n+        writer.write_all(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(&writer.get_ref()[], b);\n \n-        writer.write(&[2]).unwrap();\n+        writer.write_all(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(&writer.get_ref()[], b);\n \n-        writer.write(&[3]).unwrap();\n+        writer.write_all(&[3]).unwrap();\n         assert_eq!(&writer.get_ref()[], b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[4]).unwrap();\n-        writer.write(&[5]).unwrap();\n+        writer.write_all(&[4]).unwrap();\n+        writer.write_all(&[5]).unwrap();\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[6]).unwrap();\n+        writer.write_all(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[7, 8]).unwrap();\n+        writer.write_all(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n         assert_eq!(a, &writer.get_ref()[]);\n \n-        writer.write(&[9, 10, 11]).unwrap();\n+        writer.write_all(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n         assert_eq!(a, &writer.get_ref()[]);\n \n@@ -541,7 +541,7 @@ mod test {\n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, Vec::new());\n-        w.write(&[0, 1]).unwrap();\n+        w.write_all(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n         assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n@@ -555,20 +555,20 @@ mod test {\n     fn test_buffered_stream() {\n         struct S;\n \n-        impl io::Writer for S {\n-            fn write(&mut self, _: &[u8]) -> io::IoResult<()> { Ok(()) }\n+        impl old_io::Writer for S {\n+            fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n         }\n \n-        impl io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-                Err(io::standard_error(io::EndOfFile))\n+        impl old_io::Reader for S {\n+            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }\n \n         let mut stream = BufferedStream::new(S);\n         let mut buf = [];\n         assert!(stream.read(&mut buf).is_err());\n-        stream.write(&buf).unwrap();\n+        stream.write_all(&buf).unwrap();\n         stream.flush().unwrap();\n     }\n \n@@ -586,21 +586,21 @@ mod test {\n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(Vec::new());\n-        writer.write(&[0]).unwrap();\n+        writer.write_all(&[0]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[1]).unwrap();\n+        writer.write_all(&[1]).unwrap();\n         assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n+        writer.write_all(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n         assert_eq!(&writer.get_ref()[], b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n         assert_eq!(&writer.get_ref()[], b);\n-        writer.write(&[3, b'\\n']).unwrap();\n+        writer.write_all(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n         assert_eq!(&writer.get_ref()[], b);\n     }\n@@ -663,8 +663,8 @@ mod test {\n         struct FailFlushWriter;\n \n         impl Writer for FailFlushWriter {\n-            fn write(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n-            fn flush(&mut self) -> IoResult<()> { Err(io::standard_error(EndOfFile)) }\n+            fn write_all(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n+            fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }\n         }\n \n         let writer = FailFlushWriter;", "previous_filename": "src/libstd/io/buffered.rs"}, {"sha": "feb2ef6f4f3ca1d94bba0ad555e7d47b27032f93", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n use clone::Clone;\n use cmp;\n use sync::mpsc::{Sender, Receiver};\n-use io;\n+use old_io;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n use slice::{bytes, SliceExt};\n@@ -24,7 +24,7 @@ use vec::Vec;\n ///\n /// ```\n /// use std::sync::mpsc::channel;\n-/// use std::io::ChanReader;\n+/// use std::old_io::ChanReader;\n ///\n /// let (tx, rx) = channel();\n /// # drop(tx);\n@@ -70,7 +70,7 @@ impl Buffer for ChanReader {\n             }\n         }\n         if self.closed {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(&self.buf[self.pos..])\n         }\n@@ -102,7 +102,7 @@ impl Reader for ChanReader {\n             }\n         }\n         if self.closed && num_read == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(num_read)\n         }\n@@ -116,7 +116,7 @@ impl Reader for ChanReader {\n /// ```\n /// # #![allow(unused_must_use)]\n /// use std::sync::mpsc::channel;\n-/// use std::io::ChanWriter;\n+/// use std::old_io::ChanWriter;\n ///\n /// let (tx, rx) = channel();\n /// # drop(rx);\n@@ -142,10 +142,10 @@ impl Clone for ChanWriter {\n }\n \n impl Writer for ChanWriter {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.tx.send(buf.to_vec()).map_err(|_| {\n-            io::IoError {\n-                kind: io::BrokenPipe,\n+            old_io::IoError {\n+                kind: old_io::BrokenPipe,\n                 desc: \"Pipe closed\",\n                 detail: None\n             }\n@@ -160,7 +160,7 @@ mod test {\n \n     use sync::mpsc::channel;\n     use super::*;\n-    use io;\n+    use old_io;\n     use thread::Thread;\n \n     #[test]\n@@ -193,14 +193,14 @@ mod test {\n \n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         assert_eq!(a, buf);\n \n         // Ensure it continues to panic in the same way.\n         match reader.read(buf.as_mut_slice()) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         assert_eq!(a, buf);\n     }\n@@ -223,7 +223,7 @@ mod test {\n         assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n         match reader.read_line() {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n     }\n \n@@ -242,7 +242,7 @@ mod test {\n \n         match writer.write_u8(1) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::BrokenPipe),\n+            Err(e) => assert_eq!(e.kind, old_io::BrokenPipe),\n         }\n     }\n }", "previous_filename": "src/libstd/io/comm_adapters.rs"}, {"sha": "826271a9f834e8d0fa387a3d746ca24fbc5b0706", "filename": "src/libstd/old_io/extensions.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,8 +15,8 @@\n // FIXME: Not sure how this should be structured\n // FIXME: Iteration should probably be considered separately\n \n-use io::{IoError, IoResult, Reader};\n-use io;\n+use old_io::{IoError, IoResult, Reader};\n+use old_io;\n use iter::Iterator;\n use num::Int;\n use ops::FnOnce;\n@@ -59,7 +59,7 @@ impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n     fn next(&mut self) -> Option<IoResult<u8>> {\n         match self.reader.read_byte() {\n             Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: io::EndOfFile, .. }) => None,\n+            Err(IoError { kind: old_io::EndOfFile, .. }) => None,\n             Err(e) => Some(Err(e))\n         }\n     }\n@@ -178,15 +178,15 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n #[cfg(test)]\n mod test {\n     use prelude::v1::*;\n-    use io;\n-    use io::{MemReader, BytesReader};\n+    use old_io;\n+    use old_io::{MemReader, BytesReader};\n \n     struct InitialZeroByteReader {\n         count: int,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 Ok(0)\n@@ -200,16 +200,16 @@ mod test {\n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::EndOfFile))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            Err(io::standard_error(io::InvalidInput))\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            Err(old_io::standard_error(old_io::InvalidInput))\n         }\n     }\n \n@@ -218,7 +218,7 @@ mod test {\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -237,13 +237,13 @@ mod test {\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n                 Ok(1)\n             } else {\n-                Err(io::standard_error(io::InvalidInput))\n+                Err(old_io::standard_error(old_io::InvalidInput))\n             }\n         }\n     }\n@@ -253,7 +253,7 @@ mod test {\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -265,7 +265,7 @@ mod test {\n                 buf[1] = 13;\n                 Ok(2)\n             } else {\n-                Err(io::standard_error(io::EndOfFile))\n+                Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }\n     }", "previous_filename": "src/libstd/io/extensions.rs"}, {"sha": "a1ac5d2eab02b39d1387c4fe57b9237ed16c690d", "filename": "src/libstd/old_io/fs.rs", "status": "renamed", "additions": 101, "deletions": 100, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,21 +18,21 @@\n //! At the top-level of the module are a set of freestanding functions, associated\n //! with various filesystem operations. They all operate on `Path` objects.\n //!\n-//! All operations in this module, including those as part of `File` et al\n-//! block the task during execution. In the event of failure, all functions/methods\n+//! All operations in this module, including those as part of `File` et al block\n+//! the task during execution. In the event of failure, all functions/methods\n //! will return an `IoResult` type with an `Err` value.\n //!\n //! Also included in this module is an implementation block on the `Path` object\n-//! defined in `std::path::Path`. The impl adds useful methods about inspecting the\n-//! metadata of a file. This includes getting the `stat` information, reading off\n-//! particular bits of it, etc.\n+//! defined in `std::path::Path`. The impl adds useful methods about inspecting\n+//! the metadata of a file. This includes getting the `stat` information,\n+//! reading off particular bits of it, etc.\n //!\n //! # Example\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io::fs::PathExtensions;\n-//! use std::io::{File, fs};\n+//! use std::old_io::fs::PathExtensions;\n+//! use std::old_io::{File, fs};\n //!\n //! let path = Path::new(\"foo.txt\");\n //!\n@@ -51,13 +51,13 @@\n //! ```\n \n use clone::Clone;\n-use io::standard_error;\n-use io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n-use io::{IoResult, IoError, InvalidInput};\n-use io::{FileStat, SeekStyle, Seek, Writer, Reader};\n-use io::{Read, Truncate, ReadWrite, Append};\n-use io::UpdateIoError;\n-use io;\n+use old_io::standard_error;\n+use old_io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n+use old_io::{IoResult, IoError, InvalidInput};\n+use old_io::{FileStat, SeekStyle, Seek, Writer, Reader};\n+use old_io::{Read, Truncate, ReadWrite, Append};\n+use old_io::UpdateIoError;\n+use old_io;\n use iter::{Iterator, Extend};\n use option::Option;\n use option::Option::{Some, None};\n@@ -101,7 +101,7 @@ impl File {\n     /// # Example\n     ///\n     /// ```rust,should_fail\n-    /// use std::io::{File, Open, ReadWrite};\n+    /// use std::old_io::{File, Open, ReadWrite};\n     ///\n     /// let p = Path::new(\"/some/file/path.txt\");\n     ///\n@@ -170,7 +170,7 @@ impl File {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::File;\n+    /// use std::old_io::File;\n     ///\n     /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n     /// ```\n@@ -188,12 +188,12 @@ impl File {\n     ///\n     /// ```rust\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::File;\n+    /// use std::old_io::File;\n     ///\n     /// let mut f = File::create(&Path::new(\"foo.txt\"));\n     /// f.write(b\"This is a sample file\");\n     /// # drop(f);\n-    /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n+    /// # ::std::old_io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n@@ -265,7 +265,7 @@ impl File {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n /// fs::unlink(&p);\n@@ -293,7 +293,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/file/path.txt\");\n /// match fs::stat(&p) {\n@@ -333,7 +333,7 @@ pub fn lstat(path: &Path) -> IoResult<FileStat> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n /// ```\n@@ -359,7 +359,7 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n /// ```\n@@ -386,7 +386,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n \n     if !from.is_file() {\n         return update_err(Err(IoError {\n-            kind: io::MismatchedFileTypeForOperation,\n+            kind: old_io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n             detail: None\n         }), from, to)\n@@ -407,21 +407,21 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io;\n-/// use std::io::fs;\n+/// use std::old_io;\n+/// use std::old_io::fs;\n ///\n-/// fs::chmod(&Path::new(\"file.txt\"), io::USER_FILE);\n-/// fs::chmod(&Path::new(\"file.txt\"), io::USER_READ | io::USER_WRITE);\n-/// fs::chmod(&Path::new(\"dir\"),      io::USER_DIR);\n-/// fs::chmod(&Path::new(\"file.exe\"), io::USER_EXEC);\n+/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_FILE);\n+/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_READ | old_io::USER_WRITE);\n+/// fs::chmod(&Path::new(\"dir\"),      old_io::USER_DIR);\n+/// fs::chmod(&Path::new(\"file.exe\"), old_io::USER_EXEC);\n /// ```\n ///\n /// # Error\n ///\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n-pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n     fs_imp::chmod(path, mode.bits() as uint)\n            .update_err(\"couldn't chmod path\", |e|\n                format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n@@ -469,11 +469,11 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io;\n-/// use std::io::fs;\n+/// use std::old_io;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/dir\");\n-/// fs::mkdir(&p, io::USER_RWX);\n+/// fs::mkdir(&p, old_io::USER_RWX);\n /// ```\n ///\n /// # Error\n@@ -492,7 +492,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::fs;\n+/// use std::old_io::fs;\n ///\n /// let p = Path::new(\"/some/dir\");\n /// fs::rmdir(&p);\n@@ -513,12 +513,12 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// # Example\n ///\n /// ```rust\n-/// use std::io::fs::PathExtensions;\n-/// use std::io::fs;\n-/// use std::io;\n+/// use std::old_io::fs::PathExtensions;\n+/// use std::old_io::fs;\n+/// use std::old_io;\n ///\n /// // one possible implementation of fs::walk_dir only visiting files\n-/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> io::IoResult<()> where\n+/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> old_io::IoResult<()> where\n ///     F: FnMut(&Path),\n /// {\n ///     if dir.is_dir() {\n@@ -532,7 +532,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n ///         }\n ///         Ok(())\n ///     } else {\n-///         Err(io::standard_error(io::InvalidInput))\n+///         Err(old_io::standard_error(old_io::InvalidInput))\n ///     }\n /// }\n /// ```\n@@ -664,7 +664,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n                 // (eg: deleted by someone else since readdir)\n                 match update_err(unlink(&child), path) {\n                     Ok(()) => (),\n-                    Err(ref e) if e.kind == io::FileNotFound => (),\n+                    Err(ref e) if e.kind == old_io::FileNotFound => (),\n                     Err(e) => return Err(e)\n                 }\n             }\n@@ -675,7 +675,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n             let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n             match result {\n                 Ok(()) => (),\n-                Err(ref e) if e.kind == io::FileNotFound => (),\n+                Err(ref e) if e.kind == old_io::FileNotFound => (),\n                 Err(e) => return Err(e)\n             }\n         }\n@@ -709,7 +709,7 @@ impl Reader for File {\n             Ok(read) => {\n                 self.last_nread = read as int;\n                 match read {\n-                    0 => update_err(Err(standard_error(io::EndOfFile)), self),\n+                    0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n                 }\n             },\n@@ -719,7 +719,7 @@ impl Reader for File {\n }\n \n impl Writer for File {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.fd.write(buf)\n             .update_err(\"couldn't write to file\",\n                         |e| format!(\"{}; path={}\", e, self.path.display()))\n@@ -824,10 +824,10 @@ fn access_string(access: FileAccess) -> &'static str {\n #[allow(unused_mut)]\n mod test {\n     use prelude::v1::*;\n-    use io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n-    use io;\n+    use old_io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n+    use old_io;\n     use str;\n-    use io::fs::*;\n+    use old_io::fs::*;\n \n     macro_rules! check { ($e:expr) => (\n         match $e {\n@@ -863,15 +863,15 @@ mod test {\n             // Gee, seeing how we're testing the fs module I sure hope that we\n             // at least implement this correctly!\n             let TempDir(ref p) = *self;\n-            check!(io::fs::rmdir_recursive(p));\n+            check!(old_io::fs::rmdir_recursive(p));\n         }\n     }\n \n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n-        check!(io::fs::mkdir(&ret, io::USER_RWX));\n+        check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n         TempDir(ret)\n     }\n \n@@ -1055,7 +1055,7 @@ mod test {\n     fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(mkdir(filename, io::USER_RWX));\n+        check!(mkdir(filename, old_io::USER_RWX));\n         let stat_res_fn = check!(stat(filename));\n         assert!(stat_res_fn.kind == FileType::Directory);\n         let stat_res_meth = check!(filename.stat());\n@@ -1067,7 +1067,7 @@ mod test {\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         assert!(dir.is_file() == false);\n         check!(rmdir(dir));\n     }\n@@ -1087,7 +1087,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         assert!(dir.exists());\n         assert!(dir.is_dir());\n         check!(rmdir(dir));\n@@ -1099,7 +1099,7 @@ mod test {\n         use str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n         let prefix = \"foo\";\n         for n in range(0i,3) {\n             let f = dir.join(format!(\"{}.txt\", n));\n@@ -1130,14 +1130,14 @@ mod test {\n     fn file_test_walk_dir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"walk_dir\");\n-        check!(mkdir(dir, io::USER_RWX));\n+        check!(mkdir(dir, old_io::USER_RWX));\n \n         let dir1 = &dir.join(\"01/02/03\");\n-        check!(mkdir_recursive(dir1, io::USER_RWX));\n+        check!(mkdir_recursive(dir1, old_io::USER_RWX));\n         check!(File::create(&dir1.join(\"04\")));\n \n         let dir2 = &dir.join(\"11/12/13\");\n-        check!(mkdir_recursive(dir2, io::USER_RWX));\n+        check!(mkdir_recursive(dir2, old_io::USER_RWX));\n         check!(File::create(&dir2.join(\"14\")));\n \n         let mut files = check!(walk_dir(dir));\n@@ -1155,12 +1155,12 @@ mod test {\n \n     #[test]\n     fn mkdir_path_already_exists_error() {\n-        use io::{IoError, PathAlreadyExists};\n+        use old_io::{IoError, PathAlreadyExists};\n \n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"mkdir_error_twice\");\n-        check!(mkdir(dir, io::USER_RWX));\n-        match mkdir(dir, io::USER_RWX) {\n+        check!(mkdir(dir, old_io::USER_RWX));\n+        match mkdir(dir, old_io::USER_RWX) {\n             Err(IoError{kind:PathAlreadyExists,..}) => (),\n             _ => assert!(false)\n         };\n@@ -1170,7 +1170,7 @@ mod test {\n     fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");\n-        check!(mkdir_recursive(&dir, io::USER_RWX));\n+        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n         assert!(dir.is_dir())\n     }\n \n@@ -1180,10 +1180,10 @@ mod test {\n         let dir = tmpdir.join(\"d1\");\n         let file = dir.join(\"f1\");\n \n-        check!(mkdir_recursive(&dir, io::USER_RWX));\n+        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n         check!(File::create(&file));\n \n-        let result = mkdir_recursive(&file, io::USER_RWX);\n+        let result = mkdir_recursive(&file, old_io::USER_RWX);\n \n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n@@ -1193,7 +1193,7 @@ mod test {\n \n     #[test]\n     fn recursive_mkdir_slash() {\n-        check!(mkdir_recursive(&Path::new(\"/\"), io::USER_RWX));\n+        check!(mkdir_recursive(&Path::new(\"/\"), old_io::USER_RWX));\n     }\n \n     // FIXME(#12795) depends on lstat to work on windows\n@@ -1206,8 +1206,8 @@ mod test {\n         let dtt = dt.join(\"t\");\n         let d2 = tmpdir.join(\"d2\");\n         let canary = d2.join(\"do_not_delete\");\n-        check!(mkdir_recursive(&dtt, io::USER_RWX));\n-        check!(mkdir_recursive(&d2, io::USER_RWX));\n+        check!(mkdir_recursive(&dtt, old_io::USER_RWX));\n+        check!(mkdir_recursive(&d2, old_io::USER_RWX));\n         check!(File::create(&canary).write(b\"foo\"));\n         check!(symlink(&d2, &dt.join(\"d2\")));\n         check!(rmdir_recursive(&d1));\n@@ -1225,7 +1225,7 @@ mod test {\n \n         let mut dirpath = tmpdir.path().clone();\n         dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        check!(mkdir(&dirpath, io::USER_RWX));\n+        check!(mkdir(&dirpath, old_io::USER_RWX));\n         assert!(dirpath.is_dir());\n \n         let mut filepath = dirpath;\n@@ -1243,7 +1243,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let unicode = tmpdir.path();\n         let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        check!(mkdir(&unicode, io::USER_RWX));\n+        check!(mkdir(&unicode, old_io::USER_RWX));\n         assert!(unicode.exists());\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     }\n@@ -1324,12 +1324,12 @@ mod test {\n         let out = tmpdir.join(\"out.txt\");\n \n         check!(File::create(&input));\n-        check!(chmod(&input, io::USER_READ));\n+        check!(chmod(&input, old_io::USER_READ));\n         check!(copy(&input, &out));\n-        assert!(!check!(out.stat()).perm.intersects(io::USER_WRITE));\n+        assert!(!check!(out.stat()).perm.intersects(old_io::USER_WRITE));\n \n-        check!(chmod(&input, io::USER_FILE));\n-        check!(chmod(&out, io::USER_FILE));\n+        check!(chmod(&input, old_io::USER_FILE));\n+        check!(chmod(&out, old_io::USER_FILE));\n     }\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n@@ -1405,24 +1405,24 @@ mod test {\n         let file = tmpdir.join(\"in.txt\");\n \n         check!(File::create(&file));\n-        assert!(check!(stat(&file)).perm.contains(io::USER_WRITE));\n-        check!(chmod(&file, io::USER_READ));\n-        assert!(!check!(stat(&file)).perm.contains(io::USER_WRITE));\n+        assert!(check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n+        check!(chmod(&file, old_io::USER_READ));\n+        assert!(!check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n \n-        match chmod(&tmpdir.join(\"foo\"), io::USER_RWX) {\n+        match chmod(&tmpdir.join(\"foo\"), old_io::USER_RWX) {\n             Ok(..) => panic!(\"wanted a panic\"),\n             Err(..) => {}\n         }\n \n-        check!(chmod(&file, io::USER_FILE));\n+        check!(chmod(&file, old_io::USER_FILE));\n     }\n \n     #[test]\n     fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n         check!(file.fsync());\n         check!(file.datasync());\n         check!(file.write(b\"foo\"));\n@@ -1436,7 +1436,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n-        let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n+        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n         check!(file.write(b\"foo\"));\n         check!(file.fsync());\n \n@@ -1467,57 +1467,57 @@ mod test {\n     fn open_flavors() {\n         let tmpdir = tmpdir();\n \n-        match File::open_mode(&tmpdir.join(\"a\"), io::Open, io::Read) {\n+        match File::open_mode(&tmpdir.join(\"a\"), old_io::Open, old_io::Read) {\n             Ok(..) => panic!(), Err(..) => {}\n         }\n \n         // Perform each one twice to make sure that it succeeds the second time\n         // (where the file exists)\n-        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n         assert!(tmpdir.join(\"b\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n         assert!(tmpdir.join(\"c\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n \n-        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n         assert!(tmpdir.join(\"d\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"d\"), io::Append, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n         assert!(tmpdir.join(\"e\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"e\"), io::Append, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n \n-        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n         assert!(tmpdir.join(\"f\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"f\"), io::Truncate, io::Write));\n+        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n \n-        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n         assert!(tmpdir.join(\"g\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"g\"), io::Truncate, io::ReadWrite));\n+        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n \n         check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n-        check!(File::open_mode(&tmpdir.join(\"h\"), io::Open, io::Read));\n+        check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open, old_io::Read));\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Open,\n-                                               io::Read));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open,\n+                                               old_io::Read));\n             match f.write(\"wut\".as_bytes()) {\n                 Ok(..) => panic!(), Err(..) => {}\n             }\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n                 \"write/stat failed\");\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Append,\n-                                               io::Write));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Append,\n+                                               old_io::Write));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n                 \"append didn't append\");\n         {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), io::Truncate,\n-                                               io::Write));\n+            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Truncate,\n+                                               old_io::Write));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n@@ -1529,8 +1529,9 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"a\");\n         check!(File::create(&path));\n-        // These numbers have to be bigger than the time in the day to account for timezones\n-        // Windows in particular will fail in certain timezones with small enough values\n+        // These numbers have to be bigger than the time in the day to account\n+        // for timezones Windows in particular will fail in certain timezones\n+        // with small enough values\n         check!(change_file_times(&path, 100000, 200000));\n         assert_eq!(check!(path.stat()).accessed, 100000);\n         assert_eq!(check!(path.stat()).modified, 200000);\n@@ -1565,7 +1566,7 @@ mod test {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"file\");\n         check!(File::create(&path));\n-        check!(chmod(&path, io::USER_READ));\n+        check!(chmod(&path, old_io::USER_READ));\n         check!(unlink(&path));\n     }\n }", "previous_filename": "src/libstd/io/fs.rs"}, {"sha": "254daf3202a9e2cb1ff3b10157574192a65d41fc", "filename": "src/libstd/old_io/mem.rs", "status": "renamed", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,8 +15,8 @@\n use cmp::min;\n use option::Option::None;\n use result::Result::{Err, Ok};\n-use io;\n-use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n+use old_io;\n+use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice::{self, AsSlice, SliceExt};\n use vec::Vec;\n \n@@ -25,14 +25,14 @@ const BUF_CAPACITY: uint = 128;\n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n-        io::SeekSet => 0,\n-        io::SeekEnd => end,\n-        io::SeekCur => cur,\n+        old_io::SeekSet => 0,\n+        old_io::SeekEnd => end,\n+        old_io::SeekCur => cur,\n     } as i64;\n \n     if offset + pos < 0 {\n         Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"invalid seek to a negative offset\",\n             detail: None\n         })\n@@ -43,7 +43,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n \n impl Writer for Vec<u8> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.push_all(buf);\n         Ok(())\n     }\n@@ -55,7 +55,7 @@ impl Writer for Vec<u8> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::MemWriter;\n+/// use std::old_io::MemWriter;\n ///\n /// let mut w = MemWriter::new();\n /// w.write(&[0, 1, 2]);\n@@ -101,7 +101,7 @@ impl MemWriter {\n \n impl Writer for MemWriter {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.buf.push_all(buf);\n         Ok(())\n     }\n@@ -113,7 +113,7 @@ impl Writer for MemWriter {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::MemReader;\n+/// use std::old_io::MemReader;\n ///\n /// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n@@ -157,7 +157,7 @@ impl MemReader {\n impl Reader for MemReader {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n+        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -191,7 +191,7 @@ impl Buffer for MemReader {\n         if self.pos < self.buf.len() {\n             Ok(&self.buf[self.pos..])\n         } else {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n@@ -202,7 +202,7 @@ impl Buffer for MemReader {\n impl<'a> Reader for &'a [u8] {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.is_empty() { return Err(io::standard_error(io::EndOfFile)); }\n+        if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n \n         let write_len = min(buf.len(), self.len());\n         {\n@@ -221,7 +221,7 @@ impl<'a> Buffer for &'a [u8] {\n     #[inline]\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.is_empty() {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(*self)\n         }\n@@ -243,7 +243,7 @@ impl<'a> Buffer for &'a [u8] {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::BufWriter;\n+/// use std::old_io::BufWriter;\n ///\n /// let mut buf = [0; 4];\n /// {\n@@ -271,12 +271,12 @@ impl<'a> BufWriter<'a> {\n \n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n-    fn write(&mut self, src: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, src: &[u8]) -> IoResult<()> {\n         let dst = &mut self.buf[self.pos..];\n         let dst_len = dst.len();\n \n         if dst_len == 0 {\n-            return Err(io::standard_error(io::EndOfFile));\n+            return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n \n         let src_len = src.len();\n@@ -292,7 +292,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             self.pos += dst_len;\n \n-            Err(io::standard_error(io::ShortWrite(dst_len)))\n+            Err(old_io::standard_error(old_io::ShortWrite(dst_len)))\n         }\n     }\n }\n@@ -315,7 +315,7 @@ impl<'a> Seek for BufWriter<'a> {\n ///\n /// ```rust\n /// # #![allow(unused_must_use)]\n-/// use std::io::BufReader;\n+/// use std::old_io::BufReader;\n ///\n /// let buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(&buf);\n@@ -347,7 +347,7 @@ impl<'a> BufReader<'a> {\n impl<'a> Reader for BufReader<'a> {\n     #[inline]\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        if self.eof() { return Err(io::standard_error(io::EndOfFile)) }\n+        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n@@ -381,7 +381,7 @@ impl<'a> Buffer for BufReader<'a> {\n         if self.pos < self.buf.len() {\n             Ok(&self.buf[self.pos..])\n         } else {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n@@ -392,10 +392,10 @@ impl<'a> Buffer for BufReader<'a> {\n #[cfg(test)]\n mod test {\n     extern crate \"test\" as test_crate;\n-    use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n+    use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n     use prelude::v1::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt};\n     use prelude::v1::IteratorExt;\n-    use io;\n+    use old_io;\n     use iter::repeat;\n     use self::test_crate::Bencher;\n     use super::*;\n@@ -434,8 +434,8 @@ mod test {\n             writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n \n-            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, io::ShortWrite(1));\n-            assert_eq!(writer.write(&[10]).err().unwrap().kind, io::EndOfFile);\n+            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, old_io::ShortWrite(1));\n+            assert_eq!(writer.write(&[10]).err().unwrap().kind, old_io::EndOfFile);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n         assert_eq!(buf, b);\n@@ -478,7 +478,7 @@ mod test {\n \n         match writer.write(&[0, 0]) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::ShortWrite(1)),\n+            Err(e) => assert_eq!(e.kind, old_io::ShortWrite(1)),\n         }\n     }\n ", "previous_filename": "src/libstd/io/mem.rs"}, {"sha": "6c5ce129a33cf9fab28e193c78429a39da236646", "filename": "src/libstd/old_io/mod.rs", "status": "renamed", "additions": 76, "deletions": 53, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,6 +18,24 @@\n \n //! I/O, including files, networking, timers, and processes\n //!\n+//! > **Warning**: This module is currently called `old_io` for a reason! The\n+//! > module is currently being redesigned in a number of RFCs. For more details\n+//! > follow the RFC repository in connection with [RFC 517][base] or follow\n+//! > some of these sub-RFCs\n+//! >\n+//! > * [String handling][osstr]\n+//! > * [Core I/O support][core]\n+//! > * [Deadlines][deadlines]\n+//! > * [std::env][env]\n+//! > * [std::process][process]\n+//!\n+//! [base]: https://github.com/rust-lang/rfcs/blob/master/text/0517-io-os-reform.md\n+//! [osstr]: https://github.com/rust-lang/rfcs/pull/575\n+//! [core]: https://github.com/rust-lang/rfcs/pull/576\n+//! [deadlines]: https://github.com/rust-lang/rfcs/pull/577\n+//! [env]: https://github.com/rust-lang/rfcs/pull/578\n+//! [process]: https://github.com/rust-lang/rfcs/pull/579\n+//!\n //! `std::io` provides Rust's basic I/O types,\n //! for reading and writing to files, TCP, UDP,\n //! and other types of sockets and pipes,\n@@ -30,7 +48,7 @@\n //! * Read lines from stdin\n //!\n //!     ```rust\n-//!     use std::io;\n+//!     use std::old_io as io;\n //!\n //!     for line in io::stdin().lock().lines() {\n //!         print!(\"{}\", line.unwrap());\n@@ -40,7 +58,7 @@\n //! * Read a complete file\n //!\n //!     ```rust\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!\n //!     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n //!     ```\n@@ -49,19 +67,19 @@\n //!\n //!     ```rust\n //!     # #![allow(unused_must_use)]\n-//!     use std::io::File;\n+//!     use std::old_io::File;\n //!\n //!     let mut file = File::create(&Path::new(\"message.txt\"));\n-//!     file.write(b\"hello, file!\\n\");\n+//!     file.write_all(b\"hello, file!\\n\");\n //!     # drop(file);\n-//!     # ::std::io::fs::unlink(&Path::new(\"message.txt\"));\n+//!     # ::std::old_io::fs::unlink(&Path::new(\"message.txt\"));\n //!     ```\n //!\n //! * Iterate over the lines of a file\n //!\n //!     ```rust,no_run\n-//!     use std::io::BufferedReader;\n-//!     use std::io::File;\n+//!     use std::old_io::BufferedReader;\n+//!     use std::old_io::File;\n //!\n //!     let path = Path::new(\"message.txt\");\n //!     let mut file = BufferedReader::new(File::open(&path));\n@@ -73,8 +91,8 @@\n //! * Pull the lines of a file into a vector of strings\n //!\n //!     ```rust,no_run\n-//!     use std::io::BufferedReader;\n-//!     use std::io::File;\n+//!     use std::old_io::BufferedReader;\n+//!     use std::old_io::File;\n //!\n //!     let path = Path::new(\"message.txt\");\n //!     let mut file = BufferedReader::new(File::open(&path));\n@@ -85,14 +103,14 @@\n //!\n //!     ```rust\n //!     # #![allow(unused_must_use)]\n-//!     use std::io::TcpStream;\n+//!     use std::old_io::TcpStream;\n //!\n //!     # // connection doesn't fail if a server is running on 8080\n //!     # // locally, we still want to be type checking this code, so lets\n //!     # // just stop it running (#11576)\n //!     # if false {\n //!     let mut socket = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n-//!     socket.write(b\"GET / HTTP/1.0\\n\\n\");\n+//!     socket.write_all(b\"GET / HTTP/1.0\\n\\n\");\n //!     let response = socket.read_to_end();\n //!     # }\n //!     ```\n@@ -103,8 +121,8 @@\n //!     # fn main() { }\n //!     # fn foo() {\n //!     # #![allow(dead_code)]\n-//!     use std::io::{TcpListener, TcpStream};\n-//!     use std::io::{Acceptor, Listener};\n+//!     use std::old_io::{TcpListener, TcpStream};\n+//!     use std::old_io::{Acceptor, Listener};\n //!     use std::thread::Thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n@@ -156,7 +174,7 @@\n //!   to be 'unwrapped' before use.\n //!\n //! These features combine in the API to allow for expressions like\n-//! `File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\")`\n+//! `File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\")`\n //! without having to worry about whether \"diary.txt\" exists or whether\n //! the write succeeds. As written, if either `new` or `write_line`\n //! encounters an error then the result of the entire expression will\n@@ -166,14 +184,14 @@\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io::File;\n+//! use std::old_io::File;\n //!\n-//! match File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\") {\n+//! match File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\") {\n //!     Ok(()) => (), // succeeded\n //!     Err(e) => println!(\"failed to write to my diary: {}\", e),\n //! }\n //!\n-//! # ::std::io::fs::unlink(&Path::new(\"diary.txt\"));\n+//! # ::std::old_io::fs::unlink(&Path::new(\"diary.txt\"));\n //! ```\n //!\n //! So what actually happens if `create` encounters an error?\n@@ -199,7 +217,7 @@\n //! If you wanted to read several `u32`s from a file and return their product:\n //!\n //! ```rust\n-//! use std::io::{File, IoResult};\n+//! use std::old_io::{File, IoResult};\n //!\n //! fn file_product(p: &Path) -> IoResult<u32> {\n //!     let mut f = File::open(p);\n@@ -925,9 +943,9 @@ unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -\n /// # Examples\n ///\n /// ```\n-/// use std::io;\n-/// use std::io::ByRefReader;\n-/// use std::io::util::LimitReader;\n+/// use std::old_io as io;\n+/// use std::old_io::ByRefReader;\n+/// use std::old_io::util::LimitReader;\n ///\n /// fn process_input<R: Reader>(r: R) {}\n ///\n@@ -979,7 +997,12 @@ pub trait Writer {\n     /// `Err`. Note that it is considered an error if the entire buffer could\n     /// not be written, and if an error is returned then it is unknown how much\n     /// data (if any) was actually written.\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()>;\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;\n+\n+    /// Deprecated, this method was renamed to `write_all`\n+    #[unstable(feature = \"io\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_all`\")]\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }\n \n     /// Flush this output stream, ensuring that all intermediately buffered\n     /// contents reach their destination.\n@@ -1008,7 +1031,7 @@ pub trait Writer {\n \n         impl<'a, T: ?Sized + Writer> fmt::Writer for Adaptor<'a, T> {\n             fn write_str(&mut self, s: &str) -> fmt::Result {\n-                match self.inner.write(s.as_bytes()) {\n+                match self.inner.write_all(s.as_bytes()) {\n                     Ok(()) => Ok(()),\n                     Err(e) => {\n                         self.error = Err(e);\n@@ -1034,7 +1057,7 @@ pub trait Writer {\n     /// converted byte-array instead.\n     #[inline]\n     fn write_str(&mut self, s: &str) -> IoResult<()> {\n-        self.write(s.as_bytes())\n+        self.write_all(s.as_bytes())\n     }\n \n     /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n@@ -1046,15 +1069,15 @@ pub trait Writer {\n     /// that the `write` method is used specifically instead.\n     #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write(&[b'\\n']))\n+        self.write_str(s).and_then(|()| self.write_all(&[b'\\n']))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(&buf[..n])\n+        self.write_all(&buf[..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1072,61 +1095,61 @@ pub trait Writer {\n     /// Write a little-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_le_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian uint (number of bytes depends on system).\n     #[inline]\n     fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, uint::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian int (number of bytes depends on system).\n     #[inline]\n     fn write_be_int(&mut self, n: int) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, int::BYTES, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u64 (8 bytes).\n     #[inline]\n     fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n, 8u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u32 (4 bytes).\n     #[inline]\n     fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian u16 (2 bytes).\n     #[inline]\n     fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i64 (8 bytes).\n     #[inline]\n     fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i32 (4 bytes).\n     #[inline]\n     fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian i16 (2 bytes).\n     #[inline]\n     fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_be_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n@@ -1148,37 +1171,37 @@ pub trait Writer {\n     /// Write a little-endian u64 (8 bytes).\n     #[inline]\n     fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n, 8u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian u32 (4 bytes).\n     #[inline]\n     fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian u16 (2 bytes).\n     #[inline]\n     fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i64 (8 bytes).\n     #[inline]\n     fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 8u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i32 (4 bytes).\n     #[inline]\n     fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 4u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian i16 (2 bytes).\n     #[inline]\n     fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n+        extensions::u64_to_le_bytes(n as u64, 2u, |v| self.write_all(v))\n     }\n \n     /// Write a little-endian IEEE754 double-precision floating-point\n@@ -1202,13 +1225,13 @@ pub trait Writer {\n     /// Write a u8 (1 byte).\n     #[inline]\n     fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        self.write(&[n])\n+        self.write_all(&[n])\n     }\n \n     /// Write an i8 (1 byte).\n     #[inline]\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        self.write(&[n as u8])\n+        self.write_all(&[n as u8])\n     }\n }\n \n@@ -1230,8 +1253,8 @@ impl<T: Writer> ByRefWriter for T {\n \n impl<'a> Writer for Box<Writer+'a> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        (&mut **self).write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        (&mut **self).write_all(buf)\n     }\n \n     #[inline]\n@@ -1242,7 +1265,7 @@ impl<'a> Writer for Box<Writer+'a> {\n \n impl<'a> Writer for &'a mut (Writer+'a) {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write(buf) }\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write_all(buf) }\n \n     #[inline]\n     fn flush(&mut self) -> IoResult<()> { (**self).flush() }\n@@ -1254,8 +1277,8 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n /// # Example\n ///\n /// ```\n-/// use std::io::util::TeeReader;\n-/// use std::io::{stdin, ByRefWriter};\n+/// use std::old_io::util::TeeReader;\n+/// use std::old_io::{stdin, ByRefWriter};\n ///\n /// fn process_input<R: Reader>(r: R) {}\n ///\n@@ -1277,7 +1300,7 @@ pub struct RefWriter<'a, W:'a> {\n \n impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write(buf) }\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write_all(buf) }\n \n     #[inline]\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n@@ -1379,7 +1402,7 @@ pub trait Buffer: Reader {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::BufReader;\n+    /// use std::old_io::BufReader;\n     ///\n     /// let mut reader = BufReader::new(b\"hello\\nworld\");\n     /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n@@ -1601,7 +1624,7 @@ impl<'a, T, A: ?Sized + Acceptor<T>> Iterator for IncomingConnections<'a, A> {\n /// # Example\n ///\n /// ```\n-/// use std::io;\n+/// use std::old_io as io;\n ///\n /// let eof = io::standard_error(io::EndOfFile);\n /// let einval = io::standard_error(io::InvalidInput);\n@@ -1690,7 +1713,7 @@ pub enum FileType {\n ///\n /// ```no_run\n ///\n-/// use std::io::fs::PathExtensions;\n+/// use std::old_io::fs::PathExtensions;\n ///\n /// let info = match Path::new(\"foo.txt\").stat() {\n ///     Ok(stat) => stat,", "previous_filename": "src/libstd/io/mod.rs"}, {"sha": "9800cc6829ea09ead390633364bd598485159ecb", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,8 +20,8 @@ pub use self::Flag::*;\n pub use self::Protocol::*;\n \n use iter::IteratorExt;\n-use io::{IoResult};\n-use io::net::ip::{SocketAddr, IpAddr};\n+use old_io::{IoResult};\n+use old_io::net::ip::{SocketAddr, IpAddr};\n use option::Option;\n use option::Option::{Some, None};\n use string::String;\n@@ -114,7 +114,7 @@ fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n mod test {\n     use prelude::v1::*;\n     use super::*;\n-    use io::net::ip::*;\n+    use old_io::net::ip::*;\n \n     #[test]\n     fn dns_smoke_test() {", "previous_filename": "src/libstd/io/net/addrinfo.rs"}, {"sha": "e60b455aecda6cce7b763942bfc10342aa5e08d1", "filename": "src/libstd/old_io/net/ip.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,8 +19,8 @@ pub use self::IpAddr::*;\n \n use boxed::Box;\n use fmt;\n-use io::{self, IoResult, IoError};\n-use io::net;\n+use old_io::{self, IoResult, IoError};\n+use old_io::net;\n use iter::{Iterator, IteratorExt};\n use ops::{FnOnce, FnMut};\n use option::Option;\n@@ -406,9 +406,9 @@ impl FromStr for SocketAddr {\n /// ```rust,no_run\n /// # #![allow(unused_must_use)]\n ///\n-/// use std::io::{TcpStream, TcpListener};\n-/// use std::io::net::udp::UdpSocket;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// use std::old_io::{TcpStream, TcpListener};\n+/// use std::old_io::net::udp::UdpSocket;\n+/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n ///\n /// fn main() {\n ///     // The following lines are equivalent modulo possible \"localhost\" name resolution\n@@ -438,7 +438,7 @@ pub trait ToSocketAddr {\n     fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n         self.to_socket_addr_all()\n             .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n-                kind: io::InvalidInput,\n+                kind: old_io::InvalidInput,\n                 desc: \"no address available\",\n                 detail: None\n             }))\n@@ -481,7 +481,7 @@ fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n             match $e {\n                 Some(r) => r,\n                 None => return Err(IoError {\n-                    kind: io::InvalidInput,\n+                    kind: old_io::InvalidInput,\n                     desc: $msg,\n                     detail: None\n                 })\n@@ -526,7 +526,7 @@ impl<'a> ToSocketAddr for &'a str {\n         parse_and_resolve_socket_addr(*self)\n             .and_then(|v| v.into_iter().next()\n                 .ok_or_else(|| IoError {\n-                    kind: io::InvalidInput,\n+                    kind: old_io::InvalidInput,\n                     desc: \"no address available\",\n                     detail: None\n                 })", "previous_filename": "src/libstd/io/net/ip.rs"}, {"sha": "d8394aa8b6a44b4c8e54e7f19ed84970fac85f77", "filename": "src/libstd/old_io/net/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n //! Networking I/O\n \n-use io::{IoError, IoResult, InvalidInput};\n+use old_io::{IoError, IoResult, InvalidInput};\n use ops::FnMut;\n use option::Option::None;\n use result::Result::{Ok, Err};", "previous_filename": "src/libstd/io/net/mod.rs"}, {"sha": "71b77adcd964de8b7ce2af065dcb68dd8c2ece2b", "filename": "src/libstd/old_io/net/pipe.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -24,7 +24,7 @@ use prelude::v1::*;\n \n use ffi::CString;\n use path::BytesContainer;\n-use io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n+use old_io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n use sys::pipe::UnixListener as UnixListenerImp;\n use sys::pipe::UnixStream as UnixStreamImp;\n@@ -48,7 +48,7 @@ impl UnixStream {\n     ///\n     /// ```rust\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::net::pipe::UnixStream;\n+    /// use std::old_io::net::pipe::UnixStream;\n     ///\n     /// let server = Path::new(\"path/to/my/socket\");\n     /// let mut stream = UnixStream::connect(&server);\n@@ -146,7 +146,7 @@ impl Reader for UnixStream {\n }\n \n impl Writer for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }\n@@ -173,8 +173,8 @@ impl UnixListener {\n     ///\n     /// ```\n     /// # fn foo() {\n-    /// use std::io::net::pipe::UnixListener;\n-    /// use std::io::{Listener, Acceptor};\n+    /// use std::old_io::net::pipe::UnixListener;\n+    /// use std::old_io::{Listener, Acceptor};\n     ///\n     /// let server = Path::new(\"/path/to/my/socket\");\n     /// let stream = UnixListener::bind(&server);\n@@ -275,11 +275,11 @@ impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n mod tests {\n     use prelude::v1::*;\n \n-    use io::fs::PathExtensions;\n-    use io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n-    use io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n-    use io::{PermissionDenied, Acceptor, Listener};\n-    use io::test::*;\n+    use old_io::fs::PathExtensions;\n+    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n+    use old_io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n+    use old_io::{PermissionDenied, Acceptor, Listener};\n+    use old_io::test::*;\n     use super::*;\n     use sync::mpsc::channel;\n     use thread::Thread;", "previous_filename": "src/libstd/io/net/pipe.rs"}, {"sha": "1e76bb3ab0dffa4f60a7a441bb924b6d8afae5a0", "filename": "src/libstd/old_io/net/tcp.rs", "status": "renamed", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,11 +18,11 @@\n //! listener (socket server) implements the `Listener` and `Acceptor` traits.\n \n use clone::Clone;\n-use io::IoResult;\n+use old_io::IoResult;\n use result::Result::Err;\n-use io::net::ip::{SocketAddr, ToSocketAddr};\n-use io::{Reader, Writer, Listener, Acceptor};\n-use io::{standard_error, TimedOut};\n+use old_io::net::ip::{SocketAddr, ToSocketAddr};\n+use old_io::{Reader, Writer, Listener, Acceptor};\n+use old_io::{standard_error, TimedOut};\n use option::Option;\n use option::Option::{None, Some};\n use time::Duration;\n@@ -41,7 +41,7 @@ use sys_common;\n /// # Example\n ///\n /// ```no_run\n-/// use std::io::TcpStream;\n+/// use std::old_io::TcpStream;\n ///\n /// {\n ///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n@@ -134,8 +134,8 @@ impl TcpStream {\n     ///\n     /// ```no_run\n     /// # #![allow(unused_must_use)]\n-    /// use std::io::timer;\n-    /// use std::io::TcpStream;\n+    /// use std::old_io::timer;\n+    /// use std::old_io::TcpStream;\n     /// use std::time::Duration;\n     /// use std::thread::Thread;\n     ///\n@@ -262,7 +262,7 @@ impl Reader for TcpStream {\n }\n \n impl Writer for TcpStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }\n@@ -280,8 +280,8 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::{TcpListener, TcpStream};\n-/// use std::io::{Acceptor, Listener};\n+/// use std::old_io::{TcpListener, TcpStream};\n+/// use std::old_io::{Acceptor, Listener};\n /// use std::thread::Thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n@@ -376,8 +376,8 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// use std::io::TcpListener;\n-    /// use std::io::{Listener, Acceptor, TimedOut};\n+    /// use std::old_io::TcpListener;\n+    /// use std::old_io::{Listener, Acceptor, TimedOut};\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     ///\n@@ -420,7 +420,7 @@ impl TcpAcceptor {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n+    /// use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile};\n     /// use std::thread::Thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n@@ -488,13 +488,13 @@ mod test {\n \n     use sync::mpsc::channel;\n     use thread::Thread;\n-    use io::net::tcp::*;\n-    use io::net::ip::*;\n-    use io::test::*;\n-    use io::{EndOfFile, TimedOut, ShortWrite, IoError};\n-    use io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n-    use io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n-    use io::{Acceptor, Listener};\n+    use old_io::net::tcp::*;\n+    use old_io::net::ip::*;\n+    use old_io::test::*;\n+    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError};\n+    use old_io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n+    use old_io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n+    use old_io::{Acceptor, Listener};\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]", "previous_filename": "src/libstd/io/net/tcp.rs"}, {"sha": "9055a089eec7f3fde3e672338172dfcfd7b17db4", "filename": "src/libstd/old_io/net/udp.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,8 +16,8 @@\n //! datagram protocol.\n \n use clone::Clone;\n-use io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use io::IoResult;\n+use old_io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n+use old_io::IoResult;\n use option::Option;\n use sys::udp::UdpSocket as UdpSocketImp;\n use sys_common;\n@@ -34,8 +34,8 @@ use sys_common;\n /// # #![allow(unused_must_use)]\n /// #![feature(slicing_syntax)]\n ///\n-/// use std::io::net::udp::UdpSocket;\n-/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// use std::old_io::net::udp::UdpSocket;\n+/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n /// fn main() {\n ///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n ///     let mut socket = match UdpSocket::bind(addr) {\n@@ -183,9 +183,9 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use io::net::ip::*;\n-    use io::test::*;\n-    use io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n+    use old_io::net::ip::*;\n+    use old_io::test::*;\n+    use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n     use super::*;\n     use thread::Thread;\n ", "previous_filename": "src/libstd/io/net/udp.rs"}, {"sha": "5843b1ba1b13f377c70264035099ea7db8e2d9e5", "filename": "src/libstd/old_io/pipe.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::v1::*;\n \n-use io::IoResult;\n+use old_io::IoResult;\n use libc;\n use sync::Arc;\n \n@@ -49,7 +49,7 @@ impl PipeStream {\n     /// # #![allow(unused_must_use)]\n     /// extern crate libc;\n     ///\n-    /// use std::io::pipe::PipeStream;\n+    /// use std::old_io::pipe::PipeStream;\n     ///\n     /// fn main() {\n     ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n@@ -105,7 +105,7 @@ impl Reader for PipeStream {\n }\n \n impl Writer for PipeStream {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner.write(buf)\n     }\n }\n@@ -120,7 +120,7 @@ mod test {\n     #[test]\n     fn partial_read() {\n         use os;\n-        use io::pipe::PipeStream;\n+        use old_io::pipe::PipeStream;\n \n         let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n         let out = PipeStream::open(writer);", "previous_filename": "src/libstd/io/pipe.rs"}, {"sha": "78910882467290789c5c3bb7b6702ad0032f60bc", "filename": "src/libstd/old_io/process.rs", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,9 +20,9 @@ use prelude::v1::*;\n use collections::HashMap;\n use ffi::CString;\n use fmt;\n-use io::pipe::{PipeStream, PipePair};\n-use io::{IoResult, IoError};\n-use io;\n+use old_io::pipe::{PipeStream, PipePair};\n+use old_io::{IoResult, IoError};\n+use old_io;\n use libc;\n use os;\n use path::BytesContainer;\n@@ -57,7 +57,7 @@ use thread::Thread;\n /// # Example\n ///\n /// ```should_fail\n-/// use std::io::Command;\n+/// use std::old_io::Command;\n ///\n /// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n ///     Ok(child) => child,\n@@ -158,7 +158,7 @@ pub type EnvMap = HashMap<EnvKey, CString>;\n /// to be changed (for example, by adding arguments) prior to spawning:\n ///\n /// ```\n-/// use std::io::Command;\n+/// use std::old_io::Command;\n ///\n /// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n ///   Ok(p) => p,\n@@ -358,7 +358,7 @@ impl Command {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::io::Command;\n+    /// use std::old_io::Command;\n     ///\n     /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n     ///     Ok(output) => output,\n@@ -379,7 +379,7 @@ impl Command {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::io::Command;\n+    /// use std::old_io::Command;\n     ///\n     /// let status = match Command::new(\"ls\").status() {\n     ///     Ok(status) => status,\n@@ -582,7 +582,7 @@ impl Process {\n         // newer process that happens to have the same (re-used) id\n         if self.exit_code.is_some() {\n             return Err(IoError {\n-                kind: io::InvalidInput,\n+                kind: old_io::InvalidInput,\n                 desc: \"invalid argument: can't kill an exited process\",\n                 detail: None,\n             })\n@@ -652,8 +652,8 @@ impl Process {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// use std::io::{Command, IoResult};\n-    /// use std::io::process::ProcessExit;\n+    /// use std::old_io::{Command, IoResult};\n+    /// use std::old_io::process::ProcessExit;\n     ///\n     /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n     ///     let mut p = try!(Command::new(\"long-running-process\").spawn());\n@@ -697,7 +697,7 @@ impl Process {\n     /// fail.\n     pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n         drop(self.stdin.take());\n-        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n+        fn read(stream: Option<old_io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n@@ -751,12 +751,12 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n-    use io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n+    use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n     use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n     use prelude::v1::{Path, String, Reader, Writer, Clone};\n     use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n-    use io::fs::PathExtensions;\n-    use io::timer::*;\n+    use old_io::fs::PathExtensions;\n+    use old_io::timer::*;\n     use rt::running_on_valgrind;\n     use str;\n     use super::{CreatePipe};\n@@ -1078,13 +1078,13 @@ mod tests {\n     #[test]\n     fn test_override_env() {\n         use os;\n-        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n \n         // In some build environments (such as chrooted Nix builds), `env` can\n         // only be found in the explicitly-provided PATH env variable, not in\n         // default places such as /bin or /usr/bin. So we need to pass through\n         // PATH to our sub-process.\n         let path_val: String;\n+        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n         match os::getenv(\"PATH\") {\n             None => {}\n             Some(val) => {", "previous_filename": "src/libstd/io/process.rs"}, {"sha": "96b979860ae902fe571e226cb00fb3fdeb592a8e", "filename": "src/libstd/old_io/result.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,9 +19,9 @@ use result::Result::{Ok, Err};\n use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n \n impl<W: Writer> Writer for IoResult<W> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         match *self {\n-            Ok(ref mut writer) => writer.write(buf),\n+            Ok(ref mut writer) => writer.write_all(buf),\n             Err(ref e) => Err((*e).clone())\n         }\n     }\n@@ -80,34 +80,34 @@ impl<T, A: Acceptor<T>> Acceptor<T> for IoResult<A> {\n mod test {\n     use prelude::v1::*;\n     use super::super::mem::*;\n-    use io;\n+    use old_io;\n \n     #[test]\n     fn test_option_writer() {\n-        let mut writer: io::IoResult<Vec<u8>> = Ok(Vec::new());\n-        writer.write(&[0, 1, 2]).unwrap();\n+        let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n+        writer.write_all(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n         assert_eq!(writer.unwrap(), vec!(0, 1, 2));\n     }\n \n     #[test]\n     fn test_option_writer_error() {\n-        let mut writer: io::IoResult<Vec<u8>> =\n-            Err(io::standard_error(io::EndOfFile));\n+        let mut writer: old_io::IoResult<Vec<u8>> =\n+            Err(old_io::standard_error(old_io::EndOfFile));\n \n-        match writer.write(&[0, 0, 0]) {\n+        match writer.write_all(&[0, 0, 0]) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n         match writer.flush() {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n     }\n \n     #[test]\n     fn test_option_reader() {\n-        let mut reader: io::IoResult<MemReader> =\n+        let mut reader: old_io::IoResult<MemReader> =\n             Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n         reader.read(&mut buf).unwrap();\n@@ -117,13 +117,13 @@ mod test {\n \n     #[test]\n     fn test_option_reader_error() {\n-        let mut reader: io::IoResult<MemReader> =\n-            Err(io::standard_error(io::EndOfFile));\n+        let mut reader: old_io::IoResult<MemReader> =\n+            Err(old_io::standard_error(old_io::EndOfFile));\n         let mut buf = [];\n \n         match reader.read(&mut buf) {\n             Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, io::EndOfFile),\n+            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n         }\n     }\n }", "previous_filename": "src/libstd/io/result.rs"}, {"sha": "70400619bea7315ffc2d7968600d05ed604a94c3", "filename": "src/libstd/old_io/stdio.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,10 +19,10 @@\n //!\n //! ```rust\n //! # #![allow(unused_must_use)]\n-//! use std::io;\n+//! use std::old_io;\n //!\n-//! let mut out = io::stdout();\n-//! out.write(b\"Hello, world!\");\n+//! let mut out = old_io::stdout();\n+//! out.write_all(b\"Hello, world!\");\n //! ```\n \n use self::StdSource::*;\n@@ -32,7 +32,7 @@ use cell::RefCell;\n use clone::Clone;\n use failure::LOCAL_STDERR;\n use fmt;\n-use io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n+use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n          standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n use marker::{Sync, Send};\n use libc;\n@@ -141,9 +141,9 @@ impl StdinReader {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// use std::io;\n+    /// use std::old_io;\n     ///\n-    /// for line in io::stdin().lock().lines() {\n+    /// for line in old_io::stdin().lock().lines() {\n     ///     println!(\"{}\", line.unwrap());\n     /// }\n     /// ```\n@@ -370,14 +370,14 @@ pub fn flush() {\n /// Prints a string to the stdout of the current process. No newline is emitted\n /// after the string is printed.\n pub fn print(s: &str) {\n-    with_task_stdout(|io| io.write(s.as_bytes()))\n+    with_task_stdout(|io| io.write_all(s.as_bytes()))\n }\n \n /// Prints a string to the stdout of the current process. A literal\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes()).and_then(|()| io.write(&[b'\\n']))\n+        io.write_all(s.as_bytes()).and_then(|()| io.write_all(&[b'\\n']))\n     })\n }\n \n@@ -498,7 +498,7 @@ impl StdWriter {\n }\n \n impl Writer for StdWriter {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n         // As with stdin on windows, stdout often can't handle writes of large\n         // sizes. For an example, see #14940. For this reason, chunk the output\n         // buffer on windows, but on unix we can just write the whole buffer all\n@@ -539,7 +539,7 @@ mod tests {\n \n     #[test]\n     fn capture_stdout() {\n-        use io::{ChanReader, ChanWriter};\n+        use old_io::{ChanReader, ChanWriter};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n@@ -552,7 +552,7 @@ mod tests {\n \n     #[test]\n     fn capture_stderr() {\n-        use io::{ChanReader, ChanWriter, Reader};\n+        use old_io::{ChanReader, ChanWriter, Reader};\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));", "previous_filename": "src/libstd/io/stdio.rs"}, {"sha": "029fef7c19709184a21554a83e70568f9783c59d", "filename": "src/libstd/old_io/tempfile.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,8 +10,8 @@\n \n //! Temporary files and directories\n \n-use io::{fs, IoError, IoErrorKind, IoResult};\n-use io;\n+use old_io::{fs, IoError, IoErrorKind, IoResult};\n+use old_io;\n use iter::{IteratorExt, range};\n use ops::Drop;\n use option::Option;\n@@ -29,7 +29,7 @@ use string::String;\n /// # Examples\n ///\n /// ```no_run\n-/// use std::io::TempDir;\n+/// use std::old_io::TempDir;\n ///\n /// {\n ///     // create a temporary directory\n@@ -113,7 +113,7 @@ impl TempDir {\n                 suffix\n             };\n             let path = tmpdir.join(leaf);\n-            match fs::mkdir(&path, io::USER_RWX) {\n+            match fs::mkdir(&path, old_io::USER_RWX) {\n                 Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n                 Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n                 Err(e) => return Err(e)", "previous_filename": "src/libstd/io/tempfile.rs"}, {"sha": "f49e2397d4282b49fb2f8d0658268f6bf09e422a", "filename": "src/libstd/old_io/test.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,7 +14,7 @@ use prelude::v1::*;\n \n use libc;\n use os;\n-use std::io::net::ip::*;\n+use std::old_io::net::ip::*;\n use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n /// Get a port number, starting at 9600, for use in tests", "previous_filename": "src/libstd/io/test.rs"}, {"sha": "7e15c9ad7fcdba88237e30c2d1a4d8a54a697dcb", "filename": "src/libstd/old_io/timer.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -17,7 +17,7 @@\n \n use sync::mpsc::{Receiver, Sender, channel};\n use time::Duration;\n-use io::IoResult;\n+use old_io::IoResult;\n use sys::timer::Callback;\n use sys::timer::Timer as TimerImp;\n \n@@ -31,7 +31,7 @@ use sys::timer::Timer as TimerImp;\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::Timer;\n+/// use std::old_io::Timer;\n /// use std::time::Duration;\n ///\n /// let mut timer = Timer::new().unwrap();\n@@ -50,11 +50,11 @@ use sys::timer::Timer as TimerImp;\n /// ```\n ///\n /// If only sleeping is necessary, then a convenience API is provided through\n-/// the `io::timer` module.\n+/// the `old_io::timer` module.\n ///\n /// ```\n /// # fn foo() {\n-/// use std::io::timer;\n+/// use std::old_io::timer;\n /// use std::time::Duration;\n ///\n /// // Put this task to sleep for 5 seconds\n@@ -115,7 +115,7 @@ impl Timer {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n@@ -128,7 +128,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style:\n@@ -167,7 +167,7 @@ impl Timer {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// let mut timer = Timer::new().unwrap();\n@@ -186,7 +186,7 @@ impl Timer {\n     /// ```\n     ///\n     /// ```rust\n-    /// use std::io::Timer;\n+    /// use std::old_io::Timer;\n     /// use std::time::Duration;\n     ///\n     /// // Incorrect, method chaining-style.", "previous_filename": "src/libstd/io/timer.rs"}, {"sha": "4b6d9b08141a3c829e73b34f011157cf8266d770", "filename": "src/libstd/old_io/util.rs", "status": "renamed", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n use cmp;\n-use io;\n+use old_io;\n use slice::bytes::MutableByteVector;\n \n /// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n@@ -42,9 +42,9 @@ impl<R: Reader> LimitReader<R> {\n }\n \n impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         if self.limit == 0 {\n-            return Err(io::standard_error(io::EndOfFile));\n+            return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n@@ -58,11 +58,11 @@ impl<R: Reader> Reader for LimitReader<R> {\n }\n \n impl<R: Buffer> Buffer for LimitReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n         let buf = &amt[..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(buf)\n         }\n@@ -83,7 +83,7 @@ pub struct NullWriter;\n \n impl Writer for NullWriter {\n     #[inline]\n-    fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> { Ok(()) }\n+    fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n }\n \n /// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n@@ -92,14 +92,14 @@ pub struct ZeroReader;\n \n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         buf.set_memory(0);\n         Ok(buf.len())\n     }\n }\n \n impl Buffer for ZeroReader {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         static DATA: [u8; 64] = [0; 64];\n         Ok(DATA.as_slice())\n     }\n@@ -113,14 +113,14 @@ pub struct NullReader;\n \n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> io::IoResult<uint> {\n-        Err(io::standard_error(io::EndOfFile))\n+    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n \n impl Buffer for NullReader {\n-    fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n-        Err(io::standard_error(io::EndOfFile))\n+    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n     fn consume(&mut self, _amt: uint) {}\n }\n@@ -143,15 +143,15 @@ impl<W> MultiWriter<W> where W: Writer {\n \n impl<W> Writer for MultiWriter<W> where W: Writer {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n+    fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n         for writer in self.writers.iter_mut() {\n-            try!(writer.write(buf));\n+            try!(writer.write_all(buf));\n         }\n         Ok(())\n     }\n \n     #[inline]\n-    fn flush(&mut self) -> io::IoResult<()> {\n+    fn flush(&mut self) -> old_io::IoResult<()> {\n         for writer in self.writers.iter_mut() {\n             try!(writer.flush());\n         }\n@@ -176,13 +176,13 @@ impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n }\n \n impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         loop {\n             let err = match self.cur_reader {\n                 Some(ref mut r) => {\n                     match r.read(buf) {\n                         Ok(len) => return Ok(len),\n-                        Err(ref e) if e.kind == io::EndOfFile => None,\n+                        Err(ref e) if e.kind == old_io::EndOfFile => None,\n                         Err(e) => Some(e),\n                     }\n                 }\n@@ -194,7 +194,7 @@ impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n                 None => {}\n             }\n         }\n-        Err(io::standard_error(io::EndOfFile))\n+        Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n \n@@ -221,23 +221,23 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n }\n \n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(&mut buf[..len]).map(|()| len)\n+            self.writer.write_all(&mut buf[..len]).map(|()| len)\n         })\n     }\n }\n \n /// Copies all data from a `Reader` to a `Writer`.\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n+pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> {\n     let mut buf = [0; super::DEFAULT_BUF_SIZE];\n     loop {\n         let len = match r.read(&mut buf) {\n             Ok(len) => len,\n-            Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n+            Err(ref e) if e.kind == old_io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(&buf[..len]));\n+        try!(w.write_all(&buf[..len]));\n     }\n }\n \n@@ -257,14 +257,14 @@ impl<T: Iterator<Item=u8>> IterReader<T> {\n \n impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n         let mut len = 0;\n         for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n             *slot = elt;\n             len += 1;\n         }\n         if len == 0 && buf.len() != 0 {\n-            Err(io::standard_error(io::EndOfFile))\n+            Err(old_io::standard_error(old_io::EndOfFile))\n         } else {\n             Ok(len)\n         }\n@@ -275,8 +275,8 @@ impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n mod test {\n     use prelude::v1::*;\n \n-    use io::{MemReader, ByRefReader};\n-    use io;\n+    use old_io::{MemReader, ByRefReader};\n+    use old_io;\n     use super::*;\n \n     #[test]\n@@ -321,7 +321,7 @@ mod test {\n     fn test_null_writer() {\n         let mut s = NullWriter;\n         let buf = vec![0, 0, 0];\n-        s.write(buf.as_slice()).unwrap();\n+        s.write_all(buf.as_slice()).unwrap();\n         s.flush().unwrap();\n     }\n \n@@ -347,20 +347,20 @@ mod test {\n \n         struct TestWriter;\n         impl Writer for TestWriter {\n-            fn write(&mut self, _buf: &[u8]) -> io::IoResult<()> {\n+            fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n                 unsafe { writes += 1 }\n                 Ok(())\n             }\n \n-            fn flush(&mut self) -> io::IoResult<()> {\n+            fn flush(&mut self) -> old_io::IoResult<()> {\n                 unsafe { flushes += 1 }\n                 Ok(())\n             }\n         }\n \n         let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n                                               box TestWriter as Box<Writer>));\n-        multi.write(&[1, 2, 3]).unwrap();\n+        multi.write_all(&[1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n         multi.flush().unwrap();\n@@ -400,7 +400,7 @@ mod test {\n             let mut r = LimitReader::new(r.by_ref(), 3);\n             assert_eq!(r.read_line(), Ok(\"012\".to_string()));\n             assert_eq!(r.limit(), 0);\n-            assert_eq!(r.read_line().err().unwrap().kind, io::EndOfFile);\n+            assert_eq!(r.read_line().err().unwrap().kind, old_io::EndOfFile);\n         }\n         {\n             let mut r = LimitReader::new(r.by_ref(), 9);\n@@ -432,7 +432,7 @@ mod test {\n         assert_eq!(len, 2);\n         assert!(buf == [6, 7, 5]);\n \n-        assert_eq!(r.read(&mut buf).unwrap_err().kind, io::EndOfFile);\n+        assert_eq!(r.read(&mut buf).unwrap_err().kind, old_io::EndOfFile);\n     }\n \n     #[test]", "previous_filename": "src/libstd/io/util.rs"}, {"sha": "cd37a355e1db4722b427a1cec832c1927cab8cf5", "filename": "src/libstd/os.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,17 +10,19 @@\n \n //! Higher-level interfaces to libc::* functions and operating system services.\n //!\n-//! In general these take and return rust types, use rust idioms (enums, closures, vectors) rather\n-//! than C idioms, and do more extensive safety checks.\n+//! In general these take and return rust types, use rust idioms (enums,\n+//! closures, vectors) rather than C idioms, and do more extensive safety\n+//! checks.\n //!\n-//! This module is not meant to only contain 1:1 mappings to libc entries; any os-interface code\n-//! that is reasonably useful and broadly applicable can go here. Including utility routines that\n-//! merely build on other os code.\n+//! This module is not meant to only contain 1:1 mappings to libc entries; any\n+//! os-interface code that is reasonably useful and broadly applicable can go\n+//! here. Including utility routines that merely build on other os code.\n //!\n-//! We assume the general case is that users do not care, and do not want to be made to care, which\n-//! operating system they are on. While they may want to special case various special cases -- and\n-//! so we will not _hide_ the facts of which OS the user is on -- they should be given the\n-//! opportunity to write OS-ignorant code by default.\n+//! We assume the general case is that users do not care, and do not want to be\n+//! made to care, which operating system they are on. While they may want to\n+//! special case various special cases -- and so we will not _hide_ the facts of\n+//! which OS the user is on -- they should be given the opportunity to write\n+//! OS-ignorant code by default.\n \n #![unstable(feature = \"os\")]\n \n@@ -35,7 +37,7 @@ use self::MapError::*;\n use clone::Clone;\n use error::{FromError, Error};\n use fmt;\n-use io::{IoResult, IoError};\n+use old_io::{IoResult, IoError};\n use iter::{Iterator, IteratorExt};\n use marker::{Copy, Send};\n use libc::{c_void, c_int, c_char};\n@@ -374,7 +376,7 @@ pub struct Pipe {\n /// This function is also unsafe as there is no destructor associated with the\n /// `Pipe` structure will return. If it is not arranged for the returned file\n /// descriptors to be closed, the file descriptors will leak. For safe handling\n-/// of this scenario, use `std::io::PipeStream` instead.\n+/// of this scenario, use `std::old_io::PipeStream` instead.\n pub unsafe fn pipe() -> IoResult<Pipe> {\n     let (reader, writer) = try!(sys::os::pipe());\n     Ok(Pipe {\n@@ -1635,10 +1637,10 @@ mod tests {\n     fn memory_map_file() {\n         use libc;\n         use os::*;\n-        use io::fs::{File, unlink};\n-        use io::SeekStyle::SeekSet;\n-        use io::FileMode::Open;\n-        use io::FileAccess::ReadWrite;\n+        use old_io::fs::{File, unlink};\n+        use old_io::SeekStyle::SeekSet;\n+        use old_io::FileMode::Open;\n+        use old_io::FileAccess::ReadWrite;\n \n         #[cfg(not(windows))]\n         fn get_fd(file: &File) -> libc::c_int {"}, {"sha": "b42353e964c511993cd2d89612ca502632ca6a61", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -49,7 +49,7 @@\n //! ## Example\n //!\n //! ```rust\n-//! use std::io::fs::PathExtensions;\n+//! use std::old_io::fs::PathExtensions;\n //!\n //! let mut path = Path::new(\"/tmp/path\");\n //! println!(\"path: {}\", path.display());"}, {"sha": "39138e148032b96f5527e78fcb81a73ea8b63a9b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,7 +14,7 @@ use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use fmt;\n use hash;\n-use io::Writer;\n+use old_io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n use marker::Sized;"}, {"sha": "34faa65af75a199851c3f1f2a5b2b5672fa4dc3c", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,7 +20,7 @@ use clone::Clone;\n use cmp::{Ordering, Eq, Ord, PartialEq, PartialOrd};\n use fmt;\n use hash;\n-use io::Writer;\n+use old_io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;"}, {"sha": "51c9f9de83cc88e7fc210550665c7629186c7342", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -62,6 +62,6 @@\n // NB: remove when path reform lands\n #[doc(no_inline)] pub use path::{Path, GenericPath};\n // NB: remove when I/O reform lands\n-#[doc(no_inline)] pub use io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n+#[doc(no_inline)] pub use old_io::{Buffer, Writer, Reader, Seek, BufferPrelude};\n // NB: remove when range syntax lands\n #[doc(no_inline)] pub use iter::range;"}, {"sha": "8f5d0e22c888632085af47a3ccb1cc8b95b687c7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -223,7 +223,7 @@\n \n use cell::RefCell;\n use clone::Clone;\n-use io::IoResult;\n+use old_io::IoResult;\n use iter::{Iterator, IteratorExt};\n use mem;\n use rc::Rc;"}, {"sha": "547c813148621bbc9e29f36d5acb0eb1b456a17e", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,7 +19,7 @@ mod imp {\n \n     use self::OsRngInner::*;\n \n-    use io::{IoResult, File};\n+    use old_io::{IoResult, File};\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n@@ -187,7 +187,7 @@ mod imp {\n mod imp {\n     extern crate libc;\n \n-    use io::{IoResult};\n+    use old_io::{IoResult};\n     use marker::Sync;\n     use mem;\n     use os;\n@@ -259,7 +259,7 @@ mod imp {\n mod imp {\n     extern crate libc;\n \n-    use io::{IoResult, IoError};\n+    use old_io::{IoResult, IoError};\n     use mem;\n     use ops::Drop;\n     use os;"}, {"sha": "afacfeeaa3048a3ee38ec821f98f46a415b86519", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n //! A wrapper around any Reader to treat it as an RNG.\n \n-use io::Reader;\n+use old_io::Reader;\n use rand::Rng;\n use result::Result::{Ok, Err};\n use slice::SliceExt;\n@@ -26,7 +26,7 @@ use slice::SliceExt;\n ///\n /// ```rust\n /// use std::rand::{reader, Rng};\n-/// use std::io::MemReader;\n+/// use std::old_io::MemReader;\n ///\n /// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n /// println!(\"{:x}\", rng.gen::<uint>());\n@@ -77,7 +77,7 @@ mod test {\n     use prelude::v1::*;\n \n     use super::ReaderRng;\n-    use io::MemReader;\n+    use old_io::MemReader;\n     use num::Int;\n     use rand::Rng;\n "}, {"sha": "322c6137984abf27762cee60c2bff0bec0cc83da", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -120,7 +120,7 @@\n //!\n //! ```no_run\n //! use std::sync::mpsc::channel;\n-//! use std::io::timer::Timer;\n+//! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n //! let (tx, rx) = channel::<int>();\n@@ -144,7 +144,7 @@\n //!\n //! ```no_run\n //! use std::sync::mpsc::channel;\n-//! use std::io::timer::Timer;\n+//! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n //! let (tx, rx) = channel::<int>();"}, {"sha": "9b53ebf70a0fd7229148b82e134517967d77521e", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use io::IoResult;\n+use old_io::IoResult;\n \n #[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: uint = 18;"}, {"sha": "ae01586c7039effc671a3f1250f142b48238e26e", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n #![allow(missing_docs)]\n #![allow(dead_code)]\n \n-use io::{self, IoError, IoResult};\n+use old_io::{self, IoError, IoResult};\n use prelude::v1::*;\n use sys::{last_error, retry};\n use ffi::CString;\n@@ -35,31 +35,31 @@ pub mod wtf8;\n \n pub fn eof() -> IoError {\n     IoError {\n-        kind: io::EndOfFile,\n+        kind: old_io::EndOfFile,\n         desc: \"end of file\",\n         detail: None,\n     }\n }\n \n pub fn timeout(desc: &'static str) -> IoError {\n     IoError {\n-        kind: io::TimedOut,\n+        kind: old_io::TimedOut,\n         desc: desc,\n         detail: None,\n     }\n }\n \n pub fn short_write(n: uint, desc: &'static str) -> IoError {\n     IoError {\n-        kind: if n == 0 { io::TimedOut } else { io::ShortWrite(n) },\n+        kind: if n == 0 { old_io::TimedOut } else { old_io::ShortWrite(n) },\n         desc: desc,\n         detail: None,\n     }\n }\n \n pub fn unimpl() -> IoError {\n     IoError {\n-        kind: io::IoUnavailable,\n+        kind: old_io::IoUnavailable,\n         desc: \"operations not yet supported\",\n         detail: None,\n     }"}, {"sha": "e42db42dc602892d33a3cd28ccb5ba39ccc0e975", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,9 +14,9 @@ use self::InAddr::*;\n \n use ffi::CString;\n use ffi;\n-use io::net::addrinfo;\n-use io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n-use io::{IoResult, IoError};\n+use old_io::net::addrinfo;\n+use old_io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n+use old_io::{IoResult, IoError};\n use libc::{self, c_char, c_int};\n use mem;\n use num::Int;\n@@ -28,7 +28,7 @@ use sys::{self, retry, c, sock_t, last_error, last_net_error, last_gai_error, cl\n use sync::{Arc, Mutex, MutexGuard};\n use sys_common::{self, keep_going, short_write, timeout};\n use cmp;\n-use io;\n+use old_io;\n \n // FIXME: move uses of Arc and deadline tracking to std::io\n \n@@ -208,7 +208,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n         }\n         _ => {\n             Err(IoError {\n-                kind: io::InvalidInput,\n+                kind: old_io::InvalidInput,\n                 desc: \"invalid argument\",\n                 detail: None,\n             })\n@@ -458,7 +458,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n             match await(&[fd], deadline, Writable) {\n-                Err(ref e) if e.kind == io::EndOfFile && written > 0 => {\n+                Err(ref e) if e.kind == old_io::EndOfFile && written > 0 => {\n                     assert!(deadline.is_some());\n                     return Err(short_write(written, \"short write\"))\n                 }"}, {"sha": "ca1a16d8e173060cc3d5e61f7c2d21456c603cce", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -86,7 +86,7 @@\n use prelude::v1::*;\n \n use ffi;\n-use io::IoResult;\n+use old_io::IoResult;\n use libc;\n use mem;\n use str;\n@@ -136,7 +136,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n #[inline(never)] // if we know this is a function call, we can skip it when\n                  // tracing\n pub fn write(w: &mut Writer) -> IoResult<()> {\n-    use io::IoError;\n+    use old_io::IoError;\n \n     struct Context<'a> {\n         idx: int,\n@@ -375,7 +375,7 @@ fn output(w: &mut Writer, idx: int, addr: *mut libc::c_void,\n         Some(string) => try!(demangle(w, string)),\n         None => try!(write!(w, \"<unknown>\")),\n     }\n-    w.write(&['\\n' as u8])\n+    w.write_all(&['\\n' as u8])\n }\n \n /// Unwind library interface used for backtraces"}, {"sha": "4a82b2807e7a3c914ab58c220fb694b1c04dc33c", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,7 +18,7 @@\n //! ```rust,ignore\n //! #![feature(globs)]\n //!\n-//! use std::io::fs::File;\n+//! use std::old_io::fs::File;\n //! use std::os::unix::prelude::*;\n //!\n //! fn main() {\n@@ -37,7 +37,7 @@ use sys_common::{AsInner, IntoInner, FromInner};\n use ffi::{OsStr, OsString};\n use libc;\n \n-use io;\n+use old_io;\n \n /// Raw file descriptors.\n pub type Fd = libc::c_int;\n@@ -48,55 +48,55 @@ pub trait AsRawFd {\n     fn as_raw_fd(&self) -> Fd;\n }\n \n-impl AsRawFd for io::fs::File {\n+impl AsRawFd for old_io::fs::File {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::pipe::PipeStream {\n+impl AsRawFd for old_io::pipe::PipeStream {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::pipe::UnixStream {\n+impl AsRawFd for old_io::net::pipe::UnixStream {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::pipe::UnixListener {\n+impl AsRawFd for old_io::net::pipe::UnixListener {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::pipe::UnixAcceptor {\n+impl AsRawFd for old_io::net::pipe::UnixAcceptor {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::tcp::TcpStream {\n+impl AsRawFd for old_io::net::tcp::TcpStream {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::tcp::TcpListener {\n+impl AsRawFd for old_io::net::tcp::TcpListener {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::tcp::TcpAcceptor {\n+impl AsRawFd for old_io::net::tcp::TcpAcceptor {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawFd for io::net::udp::UdpSocket {\n+impl AsRawFd for old_io::net::udp::UdpSocket {\n     fn as_raw_fd(&self) -> Fd {\n         self.as_inner().fd()\n     }"}, {"sha": "66ae018cb36af96fb75b3105d2296ace9df33c76", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,10 +13,10 @@\n use prelude::v1::*;\n \n use ffi::{self, CString};\n-use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n-use io::{IoResult, FileStat, SeekStyle};\n-use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n-use io;\n+use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use old_io::{IoResult, FileStat, SeekStyle};\n+use old_io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use old_io;\n use libc::{self, c_int, c_void};\n use mem;\n use ptr;\n@@ -304,12 +304,12 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n     FileStat {\n         size: stat.st_size as u64,\n         kind: match (stat.st_mode as libc::mode_t) & libc::S_IFMT {\n-            libc::S_IFREG => io::FileType::RegularFile,\n-            libc::S_IFDIR => io::FileType::Directory,\n-            libc::S_IFIFO => io::FileType::NamedPipe,\n-            libc::S_IFBLK => io::FileType::BlockSpecial,\n-            libc::S_IFLNK => io::FileType::Symlink,\n-            _ => io::FileType::Unknown,\n+            libc::S_IFREG => old_io::FileType::RegularFile,\n+            libc::S_IFDIR => old_io::FileType::Directory,\n+            libc::S_IFIFO => old_io::FileType::NamedPipe,\n+            libc::S_IFBLK => old_io::FileType::BlockSpecial,\n+            libc::S_IFLNK => old_io::FileType::Symlink,\n+            _ => old_io::FileType::Unknown,\n         },\n         perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n         created: mktime(stat.st_ctime as u64, stat.st_ctime_nsec as u64),"}, {"sha": "f2f2e7436bfb7d7d0d6da1a2b677ea688c517d69", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,7 +18,7 @@\n use prelude::v1::*;\n \n use ffi;\n-use io::{self, IoResult, IoError};\n+use old_io::{self, IoResult, IoError};\n use libc;\n use num::{Int, SignedInt};\n use num;\n@@ -94,35 +94,35 @@ pub fn last_gai_error(s: libc::c_int) -> IoError {\n pub fn decode_error(errno: i32) -> IoError {\n     // FIXME: this should probably be a bit more descriptive...\n     let (kind, desc) = match errno {\n-        libc::EOF => (io::EndOfFile, \"end of file\"),\n-        libc::ECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-        libc::ECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::EOF => (old_io::EndOfFile, \"end of file\"),\n+        libc::ECONNREFUSED => (old_io::ConnectionRefused, \"connection refused\"),\n+        libc::ECONNRESET => (old_io::ConnectionReset, \"connection reset\"),\n         libc::EPERM | libc::EACCES =>\n-            (io::PermissionDenied, \"permission denied\"),\n-        libc::EPIPE => (io::BrokenPipe, \"broken pipe\"),\n-        libc::ENOTCONN => (io::NotConnected, \"not connected\"),\n-        libc::ECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-        libc::EADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-        libc::EADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-        libc::ENOENT => (io::FileNotFound, \"no such file or directory\"),\n-        libc::EISDIR => (io::InvalidInput, \"illegal operation on a directory\"),\n-        libc::ENOSYS => (io::IoUnavailable, \"function not implemented\"),\n-        libc::EINVAL => (io::InvalidInput, \"invalid argument\"),\n+            (old_io::PermissionDenied, \"permission denied\"),\n+        libc::EPIPE => (old_io::BrokenPipe, \"broken pipe\"),\n+        libc::ENOTCONN => (old_io::NotConnected, \"not connected\"),\n+        libc::ECONNABORTED => (old_io::ConnectionAborted, \"connection aborted\"),\n+        libc::EADDRNOTAVAIL => (old_io::ConnectionRefused, \"address not available\"),\n+        libc::EADDRINUSE => (old_io::ConnectionRefused, \"address in use\"),\n+        libc::ENOENT => (old_io::FileNotFound, \"no such file or directory\"),\n+        libc::EISDIR => (old_io::InvalidInput, \"illegal operation on a directory\"),\n+        libc::ENOSYS => (old_io::IoUnavailable, \"function not implemented\"),\n+        libc::EINVAL => (old_io::InvalidInput, \"invalid argument\"),\n         libc::ENOTTY =>\n-            (io::MismatchedFileTypeForOperation,\n+            (old_io::MismatchedFileTypeForOperation,\n              \"file descriptor is not a TTY\"),\n-        libc::ETIMEDOUT => (io::TimedOut, \"operation timed out\"),\n-        libc::ECANCELED => (io::TimedOut, \"operation aborted\"),\n+        libc::ETIMEDOUT => (old_io::TimedOut, \"operation timed out\"),\n+        libc::ECANCELED => (old_io::TimedOut, \"operation aborted\"),\n         libc::consts::os::posix88::EEXIST =>\n-            (io::PathAlreadyExists, \"path already exists\"),\n+            (old_io::PathAlreadyExists, \"path already exists\"),\n \n         // These two constants can have the same value on some systems,\n         // but different values on others, so we can't use a match\n         // clause\n         x if x == libc::EAGAIN || x == libc::EWOULDBLOCK =>\n-            (io::ResourceUnavailable, \"resource temporarily unavailable\"),\n+            (old_io::ResourceUnavailable, \"resource temporarily unavailable\"),\n \n-        _ => (io::OtherIoError, \"unknown error\")\n+        _ => (old_io::OtherIoError, \"unknown error\")\n     };\n     IoError { kind: kind, desc: desc, detail: None }\n }"}, {"sha": "5d5cda03f01a0ea894e0519a6b24dc477d5f31c7", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@ use prelude::v1::*;\n use error::{FromError, Error};\n use ffi::{self, CString};\n use fmt;\n-use io::{IoError, IoResult};\n+use old_io::{IoError, IoResult};\n use libc::{self, c_int, c_char, c_void};\n use os::TMPBUF_SZ;\n use os;\n@@ -198,17 +198,17 @@ pub fn load_self() -> Option<Vec<u8>> {\n pub fn load_self() -> Option<Vec<u8>> {\n     use std::io;\n \n-    match io::fs::readlink(&Path::new(\"/proc/curproc/file\")) {\n+    match old_io::fs::readlink(&Path::new(\"/proc/curproc/file\")) {\n         Ok(path) => Some(path.into_vec()),\n         Err(..) => None\n     }\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n pub fn load_self() -> Option<Vec<u8>> {\n-    use std::io;\n+    use old_io;\n \n-    match io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n+    match old_io::fs::readlink(&Path::new(\"/proc/self/exe\")) {\n         Ok(path) => Some(path.into_vec()),\n         Err(..) => None\n     }"}, {"sha": "16274a2ab0820a0112a90a3cad32288ed3f6beaa", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@ use libc;\n use mem;\n use sync::{Arc, Mutex};\n use sync::atomic::{AtomicBool, Ordering};\n-use io::{self, IoResult, IoError};\n+use old_io::{self, IoResult, IoError};\n \n use sys::{self, timer, retry, c, set_nonblocking, wouldblock};\n use sys::fs::{fd_t, FileDesc};\n@@ -41,7 +41,7 @@ fn addr_to_sockaddr_un(addr: &CString,\n     let len = addr.len();\n     if len > s.sun_path.len() - 1 {\n         return Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"invalid argument: path must be smaller than SUN_LEN\",\n             detail: None,\n         })"}, {"sha": "6e12432649f0f42fc6154e482d3dd546eaca0564", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,8 +15,8 @@ use collections::HashMap;\n use collections::hash_map::Hasher;\n use ffi::CString;\n use hash::Hash;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use io::{self, IoResult, IoError, EndOfFile};\n+use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use old_io::{self, IoResult, IoError, EndOfFile};\n use libc::{self, pid_t, c_void, c_int};\n use mem;\n use os;"}, {"sha": "c8f9d318482b09c39a3a2a9f993c2f1d27e11e83", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,8 +10,8 @@\n \n use prelude::v1::*;\n \n-use io::net::ip;\n-use io::IoResult;\n+use old_io::net::ip;\n+use old_io::IoResult;\n use libc;\n use mem;\n use ptr;"}, {"sha": "6a4e47f58ceea29608d825600cfc52f1b1a28982", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -49,7 +49,7 @@\n use prelude::v1::*;\n use self::Req::*;\n \n-use io::IoResult;\n+use old_io::IoResult;\n use libc;\n use mem;\n use os;"}, {"sha": "d414f70152da44b44934f174ebdd966deeab8112", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@ use prelude::v1::*;\n \n use sys::fs::FileDesc;\n use libc::{self, c_int, c_ulong, funcs};\n-use io::{self, IoResult, IoError};\n+use old_io::{self, IoResult, IoError};\n use sys::c;\n use sys_common;\n \n@@ -33,7 +33,7 @@ impl TTY {\n             Ok(TTY { fd: FileDesc::new(fd, true) })\n         } else {\n             Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n+                kind: old_io::MismatchedFileTypeForOperation,\n                 desc: \"file descriptor is not a TTY\",\n                 detail: None,\n             })\n@@ -67,7 +67,7 @@ impl TTY {\n             let mut size = winsize { ws_row: 0, ws_col: 0, ws_xpixel: 0, ws_ypixel: 0 };\n             if c::ioctl(self.fd.fd(), TIOCGWINSZ, &mut size) == -1 {\n                 Err(IoError {\n-                    kind: io::OtherIoError,\n+                    kind: old_io::OtherIoError,\n                     desc: \"Size of terminal could not be determined\",\n                     detail: None,\n                 })"}, {"sha": "a186465f234e3d6c4915f0044559c4da3e27fec9", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -25,7 +25,7 @@ use dynamic_lib::DynamicLibrary;\n use ffi;\n use core::ops::Index;\n use intrinsics;\n-use io::{IoResult, Writer};\n+use old_io::{IoResult, Writer};\n use libc;\n use mem;\n use ops::Drop;\n@@ -363,10 +363,10 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n             let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n             match str::from_utf8(bytes) {\n                 Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write(&bytes[..bytes.len()-1])),\n+                Err(..) => try!(w.write_all(&bytes[..bytes.len()-1])),\n             }\n         }\n-        try!(w.write(&['\\n' as u8]));\n+        try!(w.write_all(&['\\n' as u8]));\n     }\n \n     Ok(())"}, {"sha": "a3bbf5c5fe795d5c3c3c42abef13178884d90369", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -23,7 +23,7 @@ use sys_common::{AsInner, FromInner};\n use ffi::{OsStr, OsString};\n use libc;\n \n-use io;\n+use old_io;\n \n /// Raw HANDLEs.\n pub type Handle = libc::HANDLE;\n@@ -37,31 +37,31 @@ pub trait AsRawHandle {\n     fn as_raw_handle(&self) -> Handle;\n }\n \n-impl AsRawHandle for io::fs::File {\n+impl AsRawHandle for old_io::fs::File {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::pipe::PipeStream {\n+impl AsRawHandle for old_io::pipe::PipeStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixStream {\n+impl AsRawHandle for old_io::net::pipe::UnixStream {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixListener {\n+impl AsRawHandle for old_io::net::pipe::UnixListener {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n }\n \n-impl AsRawHandle for io::net::pipe::UnixAcceptor {\n+impl AsRawHandle for old_io::net::pipe::UnixAcceptor {\n     fn as_raw_handle(&self) -> Handle {\n         self.as_inner().handle()\n     }\n@@ -72,25 +72,25 @@ pub trait AsRawSocket {\n     fn as_raw_socket(&self) -> Socket;\n }\n \n-impl AsRawSocket for io::net::tcp::TcpStream {\n+impl AsRawSocket for old_io::net::tcp::TcpStream {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().fd()\n     }\n }\n \n-impl AsRawSocket for io::net::tcp::TcpListener {\n+impl AsRawSocket for old_io::net::tcp::TcpListener {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().socket()\n     }\n }\n \n-impl AsRawSocket for io::net::tcp::TcpAcceptor {\n+impl AsRawSocket for old_io::net::tcp::TcpAcceptor {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().socket()\n     }\n }\n \n-impl AsRawSocket for io::net::udp::UdpSocket {\n+impl AsRawSocket for old_io::net::udp::UdpSocket {\n     fn as_raw_socket(&self) -> Socket {\n         self.as_inner().fd()\n     }"}, {"sha": "d9d1a37465140f05708f9ea1178e36c432468183", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,16 +18,16 @@ use sys::os::fill_utf16_buf_and_decode;\n use path;\n use ptr;\n use str;\n-use io;\n+use old_io;\n \n use prelude::v1::*;\n use sys;\n use sys::os;\n use sys_common::{keep_going, eof, mkerr_libc};\n \n-use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n-use io::{IoResult, IoError, FileStat, SeekStyle};\n-use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n+use old_io::{IoResult, IoError, FileStat, SeekStyle};\n+use old_io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n \n pub type fd_t = libc::c_int;\n \n@@ -130,7 +130,7 @@ impl FileDesc {\n         return ret;\n     }\n \n-    pub fn fstat(&self) -> IoResult<io::FileStat> {\n+    pub fn fstat(&self) -> IoResult<old_io::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n@@ -268,7 +268,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n                         Err(..) => {\n                             assert!(libc::FindClose(find_handle) != 0);\n                             return Err(IoError {\n-                                kind: io::InvalidInput,\n+                                kind: old_io::InvalidInput,\n                                 desc: \"path was not valid UTF-16\",\n                                 detail: Some(format!(\"path was not valid UTF-16: {:?}\", filename)),\n                             })\n@@ -303,14 +303,14 @@ pub fn unlink(p: &Path) -> IoResult<()> {\n             // however, it cannot. To keep the two platforms in line with\n             // respect to their behavior, catch this case on windows, attempt to\n             // change it to read-write, and then remove the file.\n-            if e.kind == io::PermissionDenied {\n+            if e.kind == old_io::PermissionDenied {\n                 let stat = match stat(p) {\n                     Ok(stat) => stat,\n                     Err(..) => return Err(e),\n                 };\n-                if stat.perm.intersects(io::USER_WRITE) { return Err(e) }\n+                if stat.perm.intersects(old_io::USER_WRITE) { return Err(e) }\n \n-                match chmod(p, (stat.perm | io::USER_WRITE).bits() as uint) {\n+                match chmod(p, (stat.perm | old_io::USER_WRITE).bits() as uint) {\n                     Ok(()) => do_unlink(&p_utf16),\n                     Err(..) => {\n                         // Try to put it back as we found it\n@@ -406,12 +406,12 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n     FileStat {\n         size: stat.st_size as u64,\n         kind: match (stat.st_mode as libc::c_int) & libc::S_IFMT {\n-            libc::S_IFREG => io::FileType::RegularFile,\n-            libc::S_IFDIR => io::FileType::Directory,\n-            libc::S_IFIFO => io::FileType::NamedPipe,\n-            libc::S_IFBLK => io::FileType::BlockSpecial,\n-            libc::S_IFLNK => io::FileType::Symlink,\n-            _ => io::FileType::Unknown,\n+            libc::S_IFREG => old_io::FileType::RegularFile,\n+            libc::S_IFDIR => old_io::FileType::Directory,\n+            libc::S_IFIFO => old_io::FileType::NamedPipe,\n+            libc::S_IFBLK => old_io::FileType::BlockSpecial,\n+            libc::S_IFLNK => old_io::FileType::Symlink,\n+            _ => old_io::FileType::Unknown,\n         },\n         perm: FilePermission::from_bits_truncate(stat.st_mode as u32),\n         created: stat.st_ctime as u64,"}, {"sha": "e8b65c9b64ea36e189543d55c977ce942a3cf5d0", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -22,7 +22,7 @@ use prelude::v1::*;\n \n use num;\n use mem;\n-use io::{self, IoResult, IoError};\n+use old_io::{self, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -99,43 +99,43 @@ pub fn last_gai_error(_errno: i32) -> IoError {\n /// Convert an `errno` value into a high-level error variant and description.\n pub fn decode_error(errno: i32) -> IoError {\n     let (kind, desc) = match errno {\n-        libc::EOF => (io::EndOfFile, \"end of file\"),\n-        libc::ERROR_NO_DATA => (io::BrokenPipe, \"the pipe is being closed\"),\n-        libc::ERROR_FILE_NOT_FOUND => (io::FileNotFound, \"file not found\"),\n-        libc::ERROR_INVALID_NAME => (io::InvalidInput, \"invalid file name\"),\n-        libc::WSAECONNREFUSED => (io::ConnectionRefused, \"connection refused\"),\n-        libc::WSAECONNRESET => (io::ConnectionReset, \"connection reset\"),\n+        libc::EOF => (old_io::EndOfFile, \"end of file\"),\n+        libc::ERROR_NO_DATA => (old_io::BrokenPipe, \"the pipe is being closed\"),\n+        libc::ERROR_FILE_NOT_FOUND => (old_io::FileNotFound, \"file not found\"),\n+        libc::ERROR_INVALID_NAME => (old_io::InvalidInput, \"invalid file name\"),\n+        libc::WSAECONNREFUSED => (old_io::ConnectionRefused, \"connection refused\"),\n+        libc::WSAECONNRESET => (old_io::ConnectionReset, \"connection reset\"),\n         libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n-            (io::PermissionDenied, \"permission denied\"),\n+            (old_io::PermissionDenied, \"permission denied\"),\n         libc::WSAEWOULDBLOCK => {\n-            (io::ResourceUnavailable, \"resource temporarily unavailable\")\n+            (old_io::ResourceUnavailable, \"resource temporarily unavailable\")\n         }\n-        libc::WSAENOTCONN => (io::NotConnected, \"not connected\"),\n-        libc::WSAECONNABORTED => (io::ConnectionAborted, \"connection aborted\"),\n-        libc::WSAEADDRNOTAVAIL => (io::ConnectionRefused, \"address not available\"),\n-        libc::WSAEADDRINUSE => (io::ConnectionRefused, \"address in use\"),\n-        libc::ERROR_BROKEN_PIPE => (io::EndOfFile, \"the pipe has ended\"),\n+        libc::WSAENOTCONN => (old_io::NotConnected, \"not connected\"),\n+        libc::WSAECONNABORTED => (old_io::ConnectionAborted, \"connection aborted\"),\n+        libc::WSAEADDRNOTAVAIL => (old_io::ConnectionRefused, \"address not available\"),\n+        libc::WSAEADDRINUSE => (old_io::ConnectionRefused, \"address in use\"),\n+        libc::ERROR_BROKEN_PIPE => (old_io::EndOfFile, \"the pipe has ended\"),\n         libc::ERROR_OPERATION_ABORTED =>\n-            (io::TimedOut, \"operation timed out\"),\n-        libc::WSAEINVAL => (io::InvalidInput, \"invalid argument\"),\n+            (old_io::TimedOut, \"operation timed out\"),\n+        libc::WSAEINVAL => (old_io::InvalidInput, \"invalid argument\"),\n         libc::ERROR_CALL_NOT_IMPLEMENTED =>\n-            (io::IoUnavailable, \"function not implemented\"),\n+            (old_io::IoUnavailable, \"function not implemented\"),\n         libc::ERROR_INVALID_HANDLE =>\n-            (io::MismatchedFileTypeForOperation,\n+            (old_io::MismatchedFileTypeForOperation,\n              \"invalid handle provided to function\"),\n         libc::ERROR_NOTHING_TO_TERMINATE =>\n-            (io::InvalidInput, \"no process to kill\"),\n+            (old_io::InvalidInput, \"no process to kill\"),\n         libc::ERROR_ALREADY_EXISTS =>\n-            (io::PathAlreadyExists, \"path already exists\"),\n+            (old_io::PathAlreadyExists, \"path already exists\"),\n \n         // libuv maps this error code to EISDIR. we do too. if it is found\n         // to be incorrect, we can add in some more machinery to only\n         // return this message when ERROR_INVALID_FUNCTION after certain\n         // Windows calls.\n-        libc::ERROR_INVALID_FUNCTION => (io::InvalidInput,\n+        libc::ERROR_INVALID_FUNCTION => (old_io::InvalidInput,\n                                          \"illegal operation on a directory\"),\n \n-        _ => (io::OtherIoError, \"unknown error\")\n+        _ => (old_io::OtherIoError, \"unknown error\")\n     };\n     IoError { kind: kind, desc: desc, detail: None }\n }\n@@ -185,7 +185,7 @@ pub fn init_net() {\n \n pub fn unimpl() -> IoError {\n     IoError {\n-        kind: io::IoUnavailable,\n+        kind: old_io::IoUnavailable,\n         desc: \"operation is not implemented\",\n         detail: None,\n     }\n@@ -199,7 +199,7 @@ pub fn to_utf16(s: Option<&str>) -> IoResult<Vec<u16>> {\n             s\n         }),\n         None => Err(IoError {\n-            kind: io::InvalidInput,\n+            kind: old_io::InvalidInput,\n             desc: \"valid unicode input required\",\n             detail: None\n         })"}, {"sha": "a82259ad5ec57ee4af485cdf655df00b50885b31", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,7 +16,7 @@\n use prelude::v1::*;\n \n use fmt;\n-use io::{IoResult, IoError};\n+use old_io::{IoResult, IoError};\n use iter::repeat;\n use libc::{c_int, c_void};\n use libc;\n@@ -162,7 +162,7 @@ pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n pub fn getcwd() -> IoResult<Path> {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n-    use io::OtherIoError;\n+    use old_io::OtherIoError;\n \n     let mut buf = [0 as u16; BUF_BYTES];\n     unsafe {"}, {"sha": "dc9fb3253ffb8e5f4684eef148ee09848ef77bd9", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -88,7 +88,7 @@ use prelude::v1::*;\n \n use libc;\n use ffi::CString;\n-use io::{self, IoError, IoResult};\n+use old_io::{self, IoError, IoResult};\n use mem;\n use ptr;\n use str;\n@@ -202,7 +202,7 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n \n fn epipe() -> IoError {\n     IoError {\n-        kind: io::EndOfFile,\n+        kind: old_io::EndOfFile,\n         desc: \"the pipe has ended\",\n         detail: None,\n     }\n@@ -485,7 +485,7 @@ impl UnixStream {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n-                                kind: io::ShortWrite(amt),\n+                                kind: old_io::ShortWrite(amt),\n                                 desc: \"short write during write\",\n                                 detail: None,\n                             })"}, {"sha": "43f9e805db10c304f7d225b4642afe04699024ae", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,10 +14,10 @@ use collections;\n use ffi::CString;\n use hash::Hash;\n use collections::hash_map::Hasher;\n-use io::fs::PathExtensions;\n-use io::process::{ProcessExit, ExitStatus, ExitSignal};\n-use io::{IoResult, IoError};\n-use io;\n+use old_io::fs::PathExtensions;\n+use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n+use old_io::{IoResult, IoError};\n+use old_io;\n use libc::{pid_t, c_void, c_int};\n use libc;\n use mem;\n@@ -84,7 +84,7 @@ impl Process {\n                     Err(super::last_error())\n                 } else if status != libc::STILL_ACTIVE {\n                     Err(IoError {\n-                        kind: io::InvalidInput,\n+                        kind: old_io::InvalidInput,\n                         desc: \"no process to kill\",\n                         detail: None,\n                     })\n@@ -97,7 +97,7 @@ impl Process {\n                 super::mkerr_winbool(ret)\n             }\n             _ => Err(IoError {\n-                kind: io::IoUnavailable,\n+                kind: old_io::IoUnavailable,\n                 desc: \"unsupported signal on windows\",\n                 detail: None,\n             })\n@@ -133,7 +133,7 @@ impl Process {\n \n         if cfg.gid().is_some() || cfg.uid().is_some() {\n             return Err(IoError {\n-                kind: io::IoUnavailable,\n+                kind: old_io::IoUnavailable,\n                 desc: \"unsupported gid/uid requested on windows\",\n                 detail: None,\n             })"}, {"sha": "b7e27fb37f0c1de35ec967e32872ad83a5f7d8cc", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use io::net::ip;\n-use io::IoResult;\n+use old_io::net::ip;\n+use old_io::IoResult;\n use libc;\n use mem;\n use ptr;"}, {"sha": "34f3c418c558d5de67e0fe8be9299252ae8974fb", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -26,7 +26,7 @@ use prelude::v1::*;\n use libc;\n use ptr;\n \n-use io::IoResult;\n+use old_io::IoResult;\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n use sys::c;\n use sys::fs::FileDesc;"}, {"sha": "6ecabfa985304efabddfcf36b8ffd7ee2962f8a1", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -27,7 +27,7 @@\n \n use prelude::v1::*;\n \n-use io::{self, IoError, IoResult, MemReader};\n+use old_io::{self, IoError, IoResult, MemReader};\n use iter::repeat;\n use libc::types::os::arch::extra::LPCVOID;\n use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n@@ -44,7 +44,7 @@ use super::c::{GetConsoleScreenBufferInfo};\n \n fn invalid_encoding() -> IoError {\n     IoError {\n-        kind: io::InvalidInput,\n+        kind: old_io::InvalidInput,\n         desc: \"text was not valid unicode\",\n         detail: None,\n     }\n@@ -83,7 +83,7 @@ impl TTY {\n             })\n         } else {\n             Err(IoError {\n-                kind: io::MismatchedFileTypeForOperation,\n+                kind: old_io::MismatchedFileTypeForOperation,\n                 desc: \"invalid handle provided to function\",\n                 detail: None,\n             })"}, {"sha": "c19ec8ea25c641db80f09634b9a799b7a5ec2000", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -158,7 +158,7 @@ use sync::{Mutex, Condvar, Arc};\n use str::Str;\n use string::String;\n use rt::{self, unwind};\n-use io::{Writer, stdio};\n+use old_io::{Writer, stdio};\n use thunk::Thunk;\n \n use sys::thread as imp;\n@@ -516,7 +516,7 @@ mod test {\n     use sync::mpsc::{channel, Sender};\n     use boxed::BoxAny;\n     use result;\n-    use std::io::{ChanReader, ChanWriter};\n+    use std::old_io::{ChanReader, ChanWriter};\n     use super::{Thread, Builder};\n     use thunk::Thunk;\n "}, {"sha": "96476cabac5f8f172de3ceefc92c69fcec46a515", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -25,7 +25,7 @@ use visit::{self, Visitor};\n use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n-use std::io::IoResult;\n+use std::old_io::IoResult;\n use std::iter::{self, repeat};\n use std::mem;\n use std::slice;"}, {"sha": "e0d4f69a34cddb5dcc238acd7b1a53cefef8301c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -364,9 +364,10 @@ impl CodeMap {\n         };\n \n         // Append '\\n' in case it's not already there.\n-        // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n-        // overflowing into the next filemap in case the last byte of span is also the last\n-        // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n+        // This is a workaround to prevent CodeMap.lookup_filemap_idx from\n+        // accidentally overflowing into the next filemap in case the last byte\n+        // of span is also the last byte of filemap, which leads to incorrect\n+        // results from CodeMap.span_to_*.\n         if src.len() > 0 && !src.ends_with(\"\\n\") {\n             src.push('\\n');\n         }"}, {"sha": "f3e6689731656c5b46b800896bc8f074b1d585ef", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,7 +19,7 @@ use diagnostics;\n \n use std::cell::{RefCell, Cell};\n use std::fmt;\n-use std::io;\n+use std::old_io;\n use std::iter::range;\n use std::string::String;\n use term::WriterWrapper;\n@@ -272,7 +272,7 @@ impl Level {\n \n fn print_maybe_styled(w: &mut EmitterWriter,\n                       msg: &str,\n-                      color: term::attr::Attr) -> io::IoResult<()> {\n+                      color: term::attr::Attr) -> old_io::IoResult<()> {\n     match w.dst {\n         Terminal(ref mut t) => {\n             try!(t.attr(color));\n@@ -306,7 +306,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n }\n \n fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n-                    msg: &str, code: Option<&str>) -> io::IoResult<()> {\n+                    msg: &str, code: Option<&str>) -> old_io::IoResult<()> {\n     if !topic.is_empty() {\n         try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n@@ -342,7 +342,7 @@ enum Destination {\n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n                   registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n-        let stderr = io::stderr();\n+        let stderr = old_io::stderr();\n \n         let use_color = match color_config {\n             Always => true,\n@@ -368,10 +368,10 @@ impl EmitterWriter {\n }\n \n impl Writer for Destination {\n-    fn write(&mut self, bytes: &[u8]) -> io::IoResult<()> {\n+    fn write_all(&mut self, bytes: &[u8]) -> old_io::IoResult<()> {\n         match *self {\n-            Terminal(ref mut t) => t.write(bytes),\n-            Raw(ref mut w) => w.write(bytes),\n+            Terminal(ref mut t) => t.write_all(bytes),\n+            Raw(ref mut w) => w.write_all(bytes),\n         }\n     }\n }\n@@ -404,7 +404,7 @@ impl Emitter for EmitterWriter {\n }\n \n fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> io::IoResult<()> {\n+        msg: &str, code: Option<&str>, lvl: Level, custom: bool) -> old_io::IoResult<()> {\n     let sp = rsp.span();\n \n     // We cannot check equality directly with COMMAND_LINE_SP\n@@ -452,7 +452,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines) -> io::IoResult<()> {\n+                   lines: codemap::FileLines) -> old_io::IoResult<()> {\n     let fm = &*lines.file;\n \n     let mut elided = false;\n@@ -535,7 +535,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           sp: Span,\n                           lvl: Level,\n                           lines: codemap::FileLines)\n-                          -> io::IoResult<()> {\n+                          -> old_io::IoResult<()> {\n     let fm = &*lines.file;\n \n     let lines = &lines.lines[];\n@@ -576,7 +576,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n-                         -> io::IoResult<()> {\n+                         -> old_io::IoResult<()> {\n     let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| match expn_info {\n         Some(ei) => {\n             let ss = ei.callee.span.map_or(String::new(), |span| cm.span_to_string(span));"}, {"sha": "fbc591834d07f928e89463a053423a2b916da21b", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,7 +20,7 @@ use print::pprust;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n-use std::io::File;\n+use std::old_io::File;\n use std::rc::Rc;\n \n // These macros all relate to the file system; they either return\n@@ -135,7 +135,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let bytes = match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        &format!(\"couldn't read {:?}: {}\",\n+                        &format!(\"couldn't read {}: {}\",\n                                 file.display(),\n                                 e)[]);\n             return DummyResult::expr(sp);\n@@ -146,15 +146,15 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         Ok(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let filename = format!(\"{:?}\", file.display());\n+            let filename = format!(\"{}\", file.display());\n             let interned = token::intern_and_get_ident(&src[]);\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n-                        &format!(\"{:?} wasn't a utf-8 file\",\n+                        &format!(\"{} wasn't a utf-8 file\",\n                                 file.display())[]);\n             return DummyResult::expr(sp);\n         }\n@@ -171,7 +171,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        &format!(\"couldn't read {:?}: {}\", file.display(), e)[]);\n+                        &format!(\"couldn't read {}: {}\", file.display(), e)[]);\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "bf822599a8864347a29e06157bb3b75f9eb7d08b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -1430,7 +1430,7 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n \n #[cfg(test)]\n mod test {\n-    use std::io;\n+    use std::old_io;\n     use ast;\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n     use parse::token;\n@@ -1440,7 +1440,7 @@ mod test {\n \n     // this version doesn't care about getting comments or docstrings in.\n     fn fake_print_crate(s: &mut pprust::State,\n-                        krate: &ast::Crate) -> io::IoResult<()> {\n+                        krate: &ast::Crate) -> old_io::IoResult<()> {\n         s.print_mod(&krate.module, krate.attrs.as_slice())\n     }\n "}, {"sha": "926385ccd119e519c6727ef46710e78a990eb0b1", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,7 +19,7 @@ use parse::lexer::is_block_doc_comment;\n use parse::lexer;\n use print::pprust;\n \n-use std::io;\n+use std::old_io;\n use std::str;\n use std::string::String;\n use std::usize;\n@@ -337,7 +337,7 @@ pub struct Literal {\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic: &diagnostic::SpanHandler,\n                                     path: String,\n-                                    srdr: &mut io::Reader)\n+                                    srdr: &mut old_io::Reader)\n                                  -> (Vec<Comment>, Vec<Literal>) {\n     let src = srdr.read_to_end().unwrap();\n     let src = String::from_utf8(src).unwrap();"}, {"sha": "99be1b11b11cbc6ee2137a7b21e1b00c3dfa3fc3", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -1482,11 +1482,11 @@ mod test {\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n-    use std::io::util;\n+    use std::old_io::util;\n \n     fn mk_sh() -> diagnostic::SpanHandler {\n         let emitter = diagnostic::EmitterWriter::new(box util::NullWriter, None);\n-        let handler = diagnostic::mk_handler(box emitter);\n+        let handler = diagnostic::mk_handler(true, box emitter);\n         diagnostic::mk_span_handler(handler, CodeMap::new())\n     }\n "}, {"sha": "4bd476885a04cecd1b7f06ce05e4e79bf0e7c046", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,7 +18,7 @@ use parse::parser::Parser;\n use ptr::P;\n \n use std::cell::{Cell, RefCell};\n-use std::io::File;\n+use std::old_io::File;\n use std::rc::Rc;\n use std::num::Int;\n use std::str;"}, {"sha": "fbea265597c6a5b7a531b1c94c0690f1864b458d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -80,7 +80,7 @@ use ptr::P;\n use owned_slice::OwnedSlice;\n \n use std::collections::HashSet;\n-use std::io::fs::PathExtensions;\n+use std::old_io::fs::PathExtensions;\n use std::iter;\n use std::mem;\n use std::num::Float;"}, {"sha": "7fb2f9a80cc85a4d8f62bd353662b44f0cd41d51", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -59,7 +59,7 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n-use std::io;\n+use std::old_io;\n use std::string;\n use std::iter::repeat;\n \n@@ -161,7 +161,7 @@ pub struct PrintStackElem {\n \n static SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: usize) -> Printer {\n+pub fn mk_printer(out: Box<old_io::Writer+'static>, linewidth: usize) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: usize = 3 * linewidth;\n@@ -266,7 +266,7 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: usize) -> Printer {\n /// the method called 'pretty_print', and the 'PRINT' process is the method\n /// called 'print'.\n pub struct Printer {\n-    pub out: Box<io::Writer+'static>,\n+    pub out: Box<old_io::Writer+'static>,\n     buf_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n@@ -311,7 +311,7 @@ impl Printer {\n     pub fn replace_last_token(&mut self, t: Token) {\n         self.token[self.right] = t;\n     }\n-    pub fn pretty_print(&mut self, token: Token) -> io::IoResult<()> {\n+    pub fn pretty_print(&mut self, token: Token) -> old_io::IoResult<()> {\n         debug!(\"pp ~[{},{}]\", self.left, self.right);\n         match token {\n           Token::Eof => {\n@@ -385,7 +385,7 @@ impl Printer {\n           }\n         }\n     }\n-    pub fn check_stream(&mut self) -> io::IoResult<()> {\n+    pub fn check_stream(&mut self) -> old_io::IoResult<()> {\n         debug!(\"check_stream ~[{}, {}] with left_total={}, right_total={}\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -445,7 +445,7 @@ impl Printer {\n         self.right %= self.buf_len;\n         assert!((self.right != self.left));\n     }\n-    pub fn advance_left(&mut self) -> io::IoResult<()> {\n+    pub fn advance_left(&mut self) -> old_io::IoResult<()> {\n         debug!(\"advance_left ~[{},{}], sizeof({})={}\", self.left, self.right,\n                self.left, self.size[self.left]);\n \n@@ -506,7 +506,7 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_newline(&mut self, amount: isize) -> io::IoResult<()> {\n+    pub fn print_newline(&mut self, amount: isize) -> old_io::IoResult<()> {\n         debug!(\"NEWLINE {}\", amount);\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n@@ -529,14 +529,14 @@ impl Printer {\n             }\n         }\n     }\n-    pub fn print_str(&mut self, s: &str) -> io::IoResult<()> {\n+    pub fn print_str(&mut self, s: &str) -> old_io::IoResult<()> {\n         while self.pending_indentation > 0 {\n             try!(write!(self.out, \" \"));\n             self.pending_indentation -= 1;\n         }\n         write!(self.out, \"{}\", s)\n     }\n-    pub fn print(&mut self, token: Token, l: isize) -> io::IoResult<()> {\n+    pub fn print(&mut self, token: Token, l: isize) -> old_io::IoResult<()> {\n         debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.token[],\n@@ -620,61 +620,61 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::IoResult<()> {\n+pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> old_io::IoResult<()> {\n     p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as isize,\n         breaks: b\n     }))\n }\n \n-pub fn ibox(p: &mut Printer, indent: usize) -> io::IoResult<()> {\n+pub fn ibox(p: &mut Printer, indent: usize) -> old_io::IoResult<()> {\n     rbox(p, indent, Breaks::Inconsistent)\n }\n \n-pub fn cbox(p: &mut Printer, indent: usize) -> io::IoResult<()> {\n+pub fn cbox(p: &mut Printer, indent: usize) -> old_io::IoResult<()> {\n     rbox(p, indent, Breaks::Consistent)\n }\n \n-pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> io::IoResult<()> {\n+pub fn break_offset(p: &mut Printer, n: usize, off: isize) -> old_io::IoResult<()> {\n     p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as isize\n     }))\n }\n \n-pub fn end(p: &mut Printer) -> io::IoResult<()> {\n+pub fn end(p: &mut Printer) -> old_io::IoResult<()> {\n     p.pretty_print(Token::End)\n }\n \n-pub fn eof(p: &mut Printer) -> io::IoResult<()> {\n+pub fn eof(p: &mut Printer) -> old_io::IoResult<()> {\n     p.pretty_print(Token::Eof)\n }\n \n-pub fn word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+pub fn word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n }\n \n-pub fn huge_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+pub fn huge_word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n }\n \n-pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n+pub fn zero_word(p: &mut Printer, wrd: &str) -> old_io::IoResult<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n-pub fn spaces(p: &mut Printer, n: usize) -> io::IoResult<()> {\n+pub fn spaces(p: &mut Printer, n: usize) -> old_io::IoResult<()> {\n     break_offset(p, n, 0)\n }\n \n-pub fn zerobreak(p: &mut Printer) -> io::IoResult<()> {\n+pub fn zerobreak(p: &mut Printer) -> old_io::IoResult<()> {\n     spaces(p, 0us)\n }\n \n-pub fn space(p: &mut Printer) -> io::IoResult<()> {\n+pub fn space(p: &mut Printer) -> old_io::IoResult<()> {\n     spaces(p, 1us)\n }\n \n-pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n+pub fn hardbreak(p: &mut Printer) -> old_io::IoResult<()> {\n     spaces(p, SIZE_INFINITY as usize)\n }\n "}, {"sha": "ae3c4addf3883c9c324af0fc583c9c9c25db1ed0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -30,7 +30,7 @@ use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n \n use std::{ascii, mem};\n-use std::io::{self, IoResult};\n+use std::old_io::{self, IoResult};\n use std::iter;\n \n pub enum AnnNode<'a> {\n@@ -69,12 +69,12 @@ pub struct State<'a> {\n     encode_idents_with_hygiene: bool,\n }\n \n-pub fn rust_printer(writer: Box<io::Writer+'static>) -> State<'static> {\n+pub fn rust_printer(writer: Box<old_io::Writer+'static>) -> State<'static> {\n     static NO_ANN: NoAnn = NoAnn;\n     rust_printer_annotated(writer, &NO_ANN)\n }\n \n-pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n+pub fn rust_printer_annotated<'a>(writer: Box<old_io::Writer+'static>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, default_columns),\n@@ -104,8 +104,8 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        span_diagnostic: &diagnostic::SpanHandler,\n                        krate: &ast::Crate,\n                        filename: String,\n-                       input: &mut io::Reader,\n-                       out: Box<io::Writer+'static>,\n+                       input: &mut old_io::Reader,\n+                       out: Box<old_io::Writer+'static>,\n                        ann: &'a PpAnn,\n                        is_expanded: bool) -> IoResult<()> {\n     let mut s = State::new_from_input(cm,\n@@ -124,8 +124,8 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           span_diagnostic: &diagnostic::SpanHandler,\n                           filename: String,\n-                          input: &mut io::Reader,\n-                          out: Box<io::Writer+'static>,\n+                          input: &mut old_io::Reader,\n+                          out: Box<old_io::Writer+'static>,\n                           ann: &'a PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(\n@@ -145,7 +145,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<io::Writer+'static>,\n+               out: Box<old_io::Writer+'static>,\n                ann: &'a PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n@@ -173,7 +173,7 @@ pub fn to_string<F>(f: F) -> String where\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     let wr = unsafe {\n-        // FIXME(pcwalton): A nasty function to extract the string from an `io::Writer`\n+        // FIXME(pcwalton): A nasty function to extract the string from an `old_io::Writer`\n         // that we \"know\" to be a `Vec<u8>` that works around the lack of checked\n         // downcasts.\n         let obj: &TraitObject = mem::transmute(&s.s.out);\n@@ -421,7 +421,7 @@ thing_to_string_impls! { to_string }\n pub mod with_hygiene {\n     use abi;\n     use ast;\n-    use std::io::IoResult;\n+    use std::old_io::IoResult;\n     use super::indent_unit;\n \n     // This function is the trick that all the rest of the routines"}, {"sha": "aa3af76d46c1b7397b3842cc216b8101936af65c", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -70,7 +70,7 @@ pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]\n pub use win::WinConsole;\n \n-use std::io::IoResult;\n+use std::old_io::IoResult;\n \n pub mod terminfo;\n \n@@ -85,8 +85,8 @@ pub struct WriterWrapper {\n \n impl Writer for WriterWrapper {\n     #[inline]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.wrapped.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.wrapped.write_all(buf)\n     }\n \n     #[inline]\n@@ -100,7 +100,7 @@ impl Writer for WriterWrapper {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout() as Box<Writer + Send>,\n+        wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n     })\n }\n \n@@ -109,14 +109,14 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout() as Box<Writer + Send>,\n+        wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stdout() as Box<Writer + Send>,\n+                wrapped: box std::old_io::stdout() as Box<Writer + Send>,\n             })\n         }\n     }\n@@ -127,7 +127,7 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr() as Box<Writer + Send>,\n+        wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n     })\n }\n \n@@ -136,14 +136,14 @@ pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr() as Box<Writer + Send>,\n+        wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stderr() as Box<Writer + Send>,\n+                wrapped: box std::old_io::stderr() as Box<Writer + Send>,\n             })\n         }\n     }"}, {"sha": "a8df045e203ca9533ad20c614beae5b232be133b", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n //! Terminfo database interface.\n \n use std::collections::HashMap;\n-use std::io::IoResult;\n+use std::old_io::IoResult;\n use std::os;\n \n use attr;\n@@ -83,7 +83,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n+                try!(self.out.write_all(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -100,7 +100,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .as_slice(),\n                            &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n+                try!(self.out.write_all(s.unwrap().as_slice()));\n                 return Ok(true)\n             }\n         }\n@@ -119,7 +119,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                    &[],\n                                    &mut Variables::new());\n                     if s.is_ok() {\n-                        try!(self.out.write(s.unwrap().as_slice()));\n+                        try!(self.out.write_all(s.unwrap().as_slice()));\n                         return Ok(true)\n                     }\n                 }\n@@ -154,7 +154,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             expand(op.as_slice(), &[], &mut Variables::new())\n         });\n         if s.is_ok() {\n-            return self.out.write(s.unwrap().as_slice())\n+            return self.out.write_all(s.unwrap().as_slice())\n         }\n         Ok(())\n     }\n@@ -221,8 +221,8 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n \n \n impl<T: Writer> Writer for TerminfoTerminal<T> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.out.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.out.write_all(buf)\n     }\n \n     fn flush(&mut self) -> IoResult<()> {"}, {"sha": "f82c3ea2e7baf986e13778dfc64cb8a54767081d", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@\n //! ncurses-compatible compiled terminfo format parsing (term(5))\n \n use std::collections::HashMap;\n-use std::io;\n+use std::old_io;\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -158,7 +158,7 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: &mut io::Reader, longnames: bool)\n+pub fn parse(file: &mut old_io::Reader, longnames: bool)\n              -> Result<Box<TermInfo>, String> {\n     macro_rules! try { ($e:expr) => (\n         match $e {\n@@ -340,6 +340,6 @@ mod test {\n     #[ignore(reason = \"no ncurses on buildbots, needs a bundled terminfo file to test against\")]\n     fn test_parse() {\n         // FIXME #6870: Distribute a compiled file in src/tests and test there\n-        // parse(io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n+        // parse(old_io::fs_reader(&p(\"/usr/share/terminfo/r/rxvt-256color\")).unwrap(), false);\n     }\n }"}, {"sha": "1e84c0462d61ac19d035b5ad6388706fff7571ec", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,8 +12,8 @@\n //!\n //! Does not support hashed database, only filesystem!\n \n-use std::io::File;\n-use std::io::fs::PathExtensions;\n+use std::old_io::File;\n+use std::old_io::fs::PathExtensions;\n use std::os::getenv;\n use std::os;\n "}, {"sha": "a56613681c8ca0e7b213601003bfac9a7158b344", "filename": "src/libterm/win.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,7 +14,7 @@\n \n extern crate libc;\n \n-use std::io::IoResult;\n+use std::old_io::IoResult;\n \n use attr;\n use color;\n@@ -130,8 +130,8 @@ impl<T: Writer+Send> WinConsole<T> {\n }\n \n impl<T: Writer> Writer for WinConsole<T> {\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.write(buf)\n+    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.buf.write_all(buf)\n     }\n \n     fn flush(&mut self) -> IoResult<()> {"}, {"sha": "43a1bbd6c02ce2937d0efb8fec1090625263000e", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -68,9 +68,9 @@ use std::any::Any;\n use std::cmp;\n use std::collections::BTreeMap;\n use std::fmt;\n-use std::io::stdio::StdWriter;\n-use std::io::{File, ChanReader, ChanWriter};\n-use std::io;\n+use std::old_io::stdio::StdWriter;\n+use std::old_io::{File, ChanReader, ChanWriter};\n+use std::old_io;\n use std::iter::repeat;\n use std::num::{Float, Int};\n use std::os;\n@@ -451,13 +451,13 @@ struct ConsoleTestState<T> {\n \n impl<T: Writer> ConsoleTestState<T> {\n     pub fn new(opts: &TestOpts,\n-               _: Option<T>) -> io::IoResult<ConsoleTestState<StdWriter>> {\n+               _: Option<T>) -> old_io::IoResult<ConsoleTestState<StdWriter>> {\n         let log_out = match opts.logfile {\n             Some(ref path) => Some(try!(File::create(path))),\n             None => None\n         };\n         let out = match term::stdout() {\n-            None => Raw(io::stdio::stdout_raw()),\n+            None => Raw(old_io::stdio::stdout_raw()),\n             Some(t) => Pretty(t)\n         };\n \n@@ -476,64 +476,64 @@ impl<T: Writer> ConsoleTestState<T> {\n         })\n     }\n \n-    pub fn write_ok(&mut self) -> io::IoResult<()> {\n+    pub fn write_ok(&mut self) -> old_io::IoResult<()> {\n         self.write_pretty(\"ok\", term::color::GREEN)\n     }\n \n-    pub fn write_failed(&mut self) -> io::IoResult<()> {\n+    pub fn write_failed(&mut self) -> old_io::IoResult<()> {\n         self.write_pretty(\"FAILED\", term::color::RED)\n     }\n \n-    pub fn write_ignored(&mut self) -> io::IoResult<()> {\n+    pub fn write_ignored(&mut self) -> old_io::IoResult<()> {\n         self.write_pretty(\"ignored\", term::color::YELLOW)\n     }\n \n-    pub fn write_metric(&mut self) -> io::IoResult<()> {\n+    pub fn write_metric(&mut self) -> old_io::IoResult<()> {\n         self.write_pretty(\"metric\", term::color::CYAN)\n     }\n \n-    pub fn write_bench(&mut self) -> io::IoResult<()> {\n+    pub fn write_bench(&mut self) -> old_io::IoResult<()> {\n         self.write_pretty(\"bench\", term::color::CYAN)\n     }\n \n     pub fn write_pretty(&mut self,\n                         word: &str,\n-                        color: term::color::Color) -> io::IoResult<()> {\n+                        color: term::color::Color) -> old_io::IoResult<()> {\n         match self.out {\n             Pretty(ref mut term) => {\n                 if self.use_color {\n                     try!(term.fg(color));\n                 }\n-                try!(term.write(word.as_bytes()));\n+                try!(term.write_all(word.as_bytes()));\n                 if self.use_color {\n                     try!(term.reset());\n                 }\n                 Ok(())\n             }\n-            Raw(ref mut stdout) => stdout.write(word.as_bytes())\n+            Raw(ref mut stdout) => stdout.write_all(word.as_bytes())\n         }\n     }\n \n-    pub fn write_plain(&mut self, s: &str) -> io::IoResult<()> {\n+    pub fn write_plain(&mut self, s: &str) -> old_io::IoResult<()> {\n         match self.out {\n-            Pretty(ref mut term) => term.write(s.as_bytes()),\n-            Raw(ref mut stdout) => stdout.write(s.as_bytes())\n+            Pretty(ref mut term) => term.write_all(s.as_bytes()),\n+            Raw(ref mut stdout) => stdout.write_all(s.as_bytes())\n         }\n     }\n \n-    pub fn write_run_start(&mut self, len: uint) -> io::IoResult<()> {\n+    pub fn write_run_start(&mut self, len: uint) -> old_io::IoResult<()> {\n         self.total = len;\n         let noun = if len != 1 { \"tests\" } else { \"test\" };\n         self.write_plain(format!(\"\\nrunning {} {}\\n\", len, noun).as_slice())\n     }\n \n     pub fn write_test_start(&mut self, test: &TestDesc,\n-                            align: NamePadding) -> io::IoResult<()> {\n+                            align: NamePadding) -> old_io::IoResult<()> {\n         let name = test.padded_name(self.max_name_len, align);\n         self.write_plain(format!(\"test {} ... \", name).as_slice())\n     }\n \n-    pub fn write_result(&mut self, result: &TestResult) -> io::IoResult<()> {\n+    pub fn write_result(&mut self, result: &TestResult) -> old_io::IoResult<()> {\n         try!(match *result {\n             TrOk => self.write_ok(),\n             TrFailed => self.write_failed(),\n@@ -555,7 +555,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     }\n \n     pub fn write_log(&mut self, test: &TestDesc,\n-                     result: &TestResult) -> io::IoResult<()> {\n+                     result: &TestResult) -> old_io::IoResult<()> {\n         match self.log_out {\n             None => Ok(()),\n             Some(ref mut o) => {\n@@ -566,12 +566,12 @@ impl<T: Writer> ConsoleTestState<T> {\n                         TrMetrics(ref mm) => mm.fmt_metrics(),\n                         TrBench(ref bs) => fmt_bench_samples(bs)\n                     }, test.name.as_slice());\n-                o.write(s.as_bytes())\n+                o.write_all(s.as_bytes())\n             }\n         }\n     }\n \n-    pub fn write_failures(&mut self) -> io::IoResult<()> {\n+    pub fn write_failures(&mut self) -> old_io::IoResult<()> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = Vec::new();\n         let mut fail_out = String::new();\n@@ -599,7 +599,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         Ok(())\n     }\n \n-    pub fn write_run_finish(&mut self) -> io::IoResult<bool> {\n+    pub fn write_run_finish(&mut self) -> old_io::IoResult<bool> {\n         assert!(self.passed + self.failed + self.ignored + self.measured == self.total);\n \n         let success = self.failed == 0u;\n@@ -635,9 +635,10 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n }\n \n // A simple console test runner\n-pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoResult<bool> {\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> old_io::IoResult<bool> {\n \n-    fn callback<T: Writer>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::IoResult<()> {\n+    fn callback<T: Writer>(event: &TestEvent,\n+                           st: &mut ConsoleTestState<T>) -> old_io::IoResult<()> {\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n             TeWait(ref test, padding) => st.write_test_start(test, padding),\n@@ -735,7 +736,7 @@ fn should_sort_failures_before_printing_them() {\n \n fn use_color(opts: &TestOpts) -> bool {\n     match opts.color {\n-        AutoColor => get_concurrency() == 1 && io::stdout().get_ref().isatty(),\n+        AutoColor => get_concurrency() == 1 && old_io::stdout().get_ref().isatty(),\n         AlwaysColor => true,\n         NeverColor => false,\n     }\n@@ -753,8 +754,8 @@ pub type MonitorMsg = (TestDesc, TestResult, Vec<u8> );\n \n fn run_tests<F>(opts: &TestOpts,\n                 tests: Vec<TestDescAndFn> ,\n-                mut callback: F) -> io::IoResult<()> where\n-    F: FnMut(TestEvent) -> io::IoResult<()>,\n+                mut callback: F) -> old_io::IoResult<()> where\n+    F: FnMut(TestEvent) -> old_io::IoResult<()>,\n {\n     let filtered_tests = filter_tests(opts, tests);\n     let filtered_descs = filtered_tests.iter()\n@@ -1127,7 +1128,7 @@ mod tests {\n                TestDesc, TestDescAndFn, TestOpts, run_test,\n                Metric, MetricMap,\n                StaticTestName, DynTestName, DynTestFn, ShouldFail};\n-    use std::io::TempDir;\n+    use std::old_io::TempDir;\n     use std::thunk::Thunk;\n     use std::sync::mpsc::channel;\n "}, {"sha": "2f551bb7f49ec8b2d8b95ce37d82c617304a0441", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -351,7 +351,7 @@ pub fn freq_count<T, U>(mut iter: T) -> hash_map::HashMap<U, uint>\n mod tests {\n     use stats::Stats;\n     use stats::Summary;\n-    use std::io;\n+    use std::old_io;\n     use std::f64;\n \n     macro_rules! assert_approx_eq {\n@@ -367,7 +367,7 @@ mod tests {\n \n         let summ2 = Summary::new(samples);\n \n-        let mut w = io::stdout();\n+        let mut w = old_io::stdout();\n         let w = &mut w;\n         (write!(w, \"\\n\")).unwrap();\n "}, {"sha": "2707a6346c87fab6ffa079640b39ac8b594973b5", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n //! Basic data structures for representing a book.\n \n-use std::io::BufferedReader;\n+use std::old_io::BufferedReader;\n use std::iter;\n use std::iter::AdditiveIterator;\n "}, {"sha": "ccb572a113a4948560840a2eddf9e7b0f372631b", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,8 +11,8 @@\n //! Implementation of the `build` subcommand, used to compile a book.\n \n use std::os;\n-use std::io;\n-use std::io::{fs, File, BufferedWriter, TempDir, IoResult};\n+use std::old_io;\n+use std::old_io::{fs, File, BufferedWriter, TempDir, IoResult};\n \n use subcommand::Subcommand;\n use term::Term;\n@@ -119,7 +119,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n             try!(writeln!(&mut toc, \"</div></div>\"));\n         }\n \n-        try!(fs::mkdir_recursive(&out_path, io::USER_DIR));\n+        try!(fs::mkdir_recursive(&out_path, old_io::USER_DIR));\n \n         let rustdoc_args: &[String] = &[\n             \"\".to_string(),\n@@ -165,7 +165,7 @@ impl Subcommand for Build {\n             tgt = Path::new(os::args()[3].clone());\n         }\n \n-        try!(fs::mkdir(&tgt, io::USER_DIR));\n+        try!(fs::mkdir(&tgt, old_io::USER_DIR));\n \n         try!(File::create(&tgt.join(\"rust-book.css\")).write_str(css::STYLE));\n "}, {"sha": "d4829a2c391b801938a7bc0ea54a55f159a81804", "filename": "src/rustbook/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ferror.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@\n use std::fmt;\n use std::fmt::{Show, Formatter};\n \n-use std::io::IoError;\n+use std::old_io::IoError;\n \n pub type CliError = Box<Error + 'static>;\n pub type CliResult<T> = Result<T, CliError>;"}, {"sha": "b922bf1cdd3675fce2f370e6689094b7db1d33dd", "filename": "src/rustbook/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fterm.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@\n //! verbosity support. For now, just a wrapper around stdout/stderr.\n \n use std::os;\n-use std::io::stdio;\n+use std::old_io::stdio;\n \n pub struct Term {\n     err: Box<Writer + 'static>"}, {"sha": "db02481cb0297145e05e51374ce4c4eaabcf6630", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,7 +16,7 @@ use error::CommandResult;\n use error::Error;\n use term::Term;\n use book;\n-use std::io::{Command, File};\n+use std::old_io::{Command, File};\n use std::os;\n \n struct Test;"}, {"sha": "a20a649dfe9150ddd0bb1b5e0fa69585335c6d90", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@\n \n #![feature(unboxed_closures)]\n \n-use std::io::File;\n+use std::old_io::File;\n use std::iter::repeat;\n use std::mem::swap;\n use std::os;\n@@ -71,7 +71,7 @@ fn shift_push() {\n }\n \n fn read_line() {\n-    use std::io::BufferedReader;\n+    use std::old_io::BufferedReader;\n \n     let mut path = Path::new(env!(\"CFG_SRC_DIR\"));\n     path.push(\"src/test/bench/shootout-k-nucleotide.data\");"}, {"sha": "32242bee80121905ea89dfecd3eb16f461015981", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::cmp::min;\n-use std::io::{stdout, IoResult};\n+use std::old_io::{stdout, IoResult};\n use std::iter::repeat;\n use std::os;\n use std::slice::bytes::copy_memory;"}, {"sha": "193be04f80919913e58b158e21ac6236e145d7a3", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -39,8 +39,8 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::cmp::min;\n-use std::io::{BufferedWriter, File};\n-use std::io;\n+use std::old_io::{BufferedWriter, File};\n+use std::old_io;\n use std::num::Float;\n use std::os;\n \n@@ -86,7 +86,7 @@ impl<'a> Iterator for AAGen<'a> {\n \n fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n     wr: &mut W, header: &str, mut it: I, mut n: uint)\n-    -> std::io::IoResult<()>\n+    -> std::old_io::IoResult<()>\n {\n     try!(wr.write(header.as_bytes()));\n     let mut line = [0u8; LINE_LENGTH + 1];\n@@ -102,7 +102,7 @@ fn make_fasta<W: Writer, I: Iterator<Item=u8>>(\n     Ok(())\n }\n \n-fn run<W: Writer>(writer: &mut W) -> std::io::IoResult<()> {\n+fn run<W: Writer>(writer: &mut W) -> std::old_io::IoResult<()> {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if os::getenv(\"RUST_BENCH\").is_some() {\n@@ -147,7 +147,7 @@ fn main() {\n         let mut file = BufferedWriter::new(File::create(&Path::new(\"./shootout-fasta.data\")));\n         run(&mut file)\n     } else {\n-        run(&mut io::stdout())\n+        run(&mut old_io::stdout())\n     };\n     res.unwrap()\n }"}, {"sha": "377cb5c9bae2660b4ea1affb4111e07d241c26fa", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -146,7 +146,7 @@ fn make_sequence_processor(sz: uint,\n \n // given a FASTA file on stdin, process sequence THREE\n fn main() {\n-    use std::io::{stdio, MemReader, BufferedReader};\n+    use std::old_io::{stdio, MemReader, BufferedReader};\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bytes!(\"shootout-k-nucleotide.data\");"}, {"sha": "657ae537f21fb6795f042a5882e2c9c0795a600e", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -294,10 +294,10 @@ fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n \n fn main() {\n     let input = if std::os::getenv(\"RUST_BENCH\").is_some() {\n-        let fd = std::io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n-        get_sequence(&mut std::io::BufferedReader::new(fd), \">THREE\")\n+        let fd = std::old_io::File::open(&Path::new(\"shootout-k-nucleotide.data\"));\n+        get_sequence(&mut std::old_io::BufferedReader::new(fd), \">THREE\")\n     } else {\n-        get_sequence(&mut *std::io::stdin().lock(), \">THREE\")\n+        get_sequence(&mut *std::old_io::stdin().lock(), \">THREE\")\n     };\n     let input = Arc::new(input);\n "}, {"sha": "0bd69b73214c9b6f2209b5c141a49a26e439c6a4", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -42,7 +42,7 @@\n \n // ignore-pretty very bad with line comments\n \n-use std::io;\n+use std::old_io;\n use std::os;\n use std::simd::f64x2;\n use std::sync::Arc;\n@@ -53,7 +53,7 @@ const LIMIT: f64 = 2.0;\n const WORKERS: uint = 16;\n \n #[inline(always)]\n-fn mandelbrot<W: io::Writer>(w: uint, mut out: W) -> io::IoResult<()> {\n+fn mandelbrot<W: old_io::Writer>(w: uint, mut out: W) -> old_io::IoResult<()> {\n     assert!(WORKERS % 2 == 0);\n \n     // Ensure w and h are multiples of 8.\n@@ -202,9 +202,9 @@ fn main() {\n     let res = if args.len() < 2 {\n         println!(\"Test mode: do not dump the image because it's not utf8, \\\n                   which interferes with the test runner.\");\n-        mandelbrot(1000, io::util::NullWriter)\n+        mandelbrot(1000, old_io::util::NullWriter)\n     } else {\n-        mandelbrot(args[1].parse().unwrap(), io::stdout())\n+        mandelbrot(args[1].parse().unwrap(), old_io::stdout())\n     };\n     res.unwrap();\n }"}, {"sha": "6419ad551f4617051e1bf291728086b1c0f28c26", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -44,8 +44,8 @@\n \n extern crate libc;\n \n-use std::io::stdio::{stdin_raw, stdout_raw};\n-use std::io::{IoResult, EndOfFile};\n+use std::old_io::stdio::{stdin_raw, stdout_raw};\n+use std::old_io::{IoResult, EndOfFile};\n use std::ptr::{copy_memory, Unique};\n use std::thread::Thread;\n "}, {"sha": "30a0bd7bd91c6b319db5a73ca58c7acb7c0610ab", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,9 +13,9 @@\n #![feature(box_syntax)]\n #![allow(non_snake_case)]\n \n-use std::io::BufferedReader;\n-use std::io::stdio::StdReader;\n-use std::io;\n+use std::old_io::BufferedReader;\n+use std::old_io::stdio::StdReader;\n+use std::old_io;\n use std::iter::repeat;\n use std::num::Int;\n use std::os;\n@@ -80,7 +80,7 @@ impl Sudoku {\n         return Sudoku::new(g)\n     }\n \n-    pub fn write(&self, writer: &mut io::Writer) {\n+    pub fn write(&self, writer: &mut old_io::Writer) {\n         for row in range(0u8, 9u8) {\n             write!(writer, \"{}\", self.grid[row as uint][0]);\n             for col in range(1u8, 9u8) {\n@@ -274,8 +274,8 @@ fn main() {\n     let mut sudoku = if use_default {\n         Sudoku::from_vec(&DEFAULT_SUDOKU)\n     } else {\n-        Sudoku::read(&mut *io::stdin().lock())\n+        Sudoku::read(&mut *old_io::stdin().lock())\n     };\n     sudoku.solve();\n-    sudoku.write(&mut io::stdout());\n+    sudoku.write(&mut old_io::stdout());\n }"}, {"sha": "9c10f01e027557c7e9885d43574a62044cc5f27a", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,10 +16,11 @@ extern crate collections;\n use std::collections::HashMap;\n \n fn main() {\n+    let tmp;\n     let mut buggy_map: HashMap<usize, &usize> = HashMap::new();\n     buggy_map.insert(42, &*box 1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary\n-    let tmp = box 2;\n+    tmp = box 2;\n     buggy_map.insert(43, &*tmp);\n }"}, {"sha": "f551a2aa81155702af8fd7b698ad81ad21affb25", "filename": "src/test/compile-fail/borrowck-let-suggestion-suffixes.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let old = ['o'];         // statement 0\n+    let mut v1 = Vec::new(); // statement 1\n+\n+    let mut v2 = Vec::new(); // statement 2\n+    //~^ NOTE reference must be valid for the block suffix following statement 2\n+\n+    let young = ['y'];       // statement 3\n+    //~^ NOTE ...but borrowed value is only valid for the block suffix following statement 3\n+\n+    v2.push(&young[0]);      // statement 4\n+    //~^ ERROR `young[..]` does not live long enough\n+\n+    let mut v3 = Vec::new(); // statement 5\n+    //~^ NOTE reference must be valid for the block suffix following statement 5\n+\n+    v3.push(&'x');           // statement 6\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    {\n+\n+        let mut v4 = Vec::new(); // (sub) statement 0\n+        //~^ NOTE reference must be valid for the block suffix following statement 0\n+\n+        v4.push(&'y');\n+        //~^ ERROR borrowed value does not live long enough\n+        //~| NOTE ...but borrowed value is only valid for the statement\n+        //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    }                       // (statement 7)\n+\n+    let mut v5 = Vec::new(); // statement 8\n+    //~^ NOTE reference must be valid for the block suffix following statement 8\n+\n+    v5.push(&'z');\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    v1.push(&old[0]);\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "a08021919df8540d473f149e8c422c0820e38ef0", "filename": "src/test/compile-fail/borrowck-let-suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n fn f() {\n     let x = [1is].iter(); //~ ERROR borrowed value does not live long enough\n-                         //~^^ NOTE reference must be valid for the block\n+                         //~^ NOTE reference must be valid for the block suffix following statement\n                          //~^^ HELP consider using a `let` binding to increase its lifetime\n }\n "}, {"sha": "b106169c6fcf43f59e8788ca58cbb191b3fe102e", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     move|:| { x = 2; };\n     //~^ ERROR: cannot assign to immutable captured outer variable\n \n-    let s = std::io::stdin();\n+    let s = std::old_io::stdin();\n     move|:| { s.read_to_end(); };\n     //~^ ERROR: cannot borrow immutable captured outer variable\n }"}, {"sha": "4c6dcaccc9aed5347cb85f94cd456c982f56e724", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cast from nil: `()` as `u32`\n+// error-pattern: non-scalar cast: `()` as `u32`\n fn main() { let u = (assert!(true) as u32); }"}, {"sha": "e5fd5bb33eb908978d6f77f82b7354fabc6fdc17", "filename": "src/test/compile-fail/cast-to-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cast to nil: `u32` as `()`\n+// error-pattern: non-scalar cast: `u32` as `()`\n fn main() { let u = 0u32 as (); }"}, {"sha": "25060b94dcf37bec0354f1fd1c6e4bbaa714d7d4", "filename": "src/test/compile-fail/issue-10991.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10991.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     let nil = ();\n-    let _t = nil as usize; //~ ERROR: cast from nil: `()` as `usize`\n+    let _t = nil as usize; //~ ERROR: non-scalar cast: `()` as `usize`\n }"}, {"sha": "aa2a71ca2dbbf51bebdf9dec83476e707f16fc3e", "filename": "src/test/compile-fail/issue-11374.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11374.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::old_io;\n use std::vec;\n \n pub struct Container<'a> {\n@@ -26,7 +26,7 @@ impl<'a> Container<'a> {\n }\n \n pub fn for_stdin<'a>() -> Container<'a> {\n-    let mut r = io::stdin();\n+    let mut r = old_io::stdin();\n     Container::wrap(&mut r as &mut Reader)\n }\n "}, {"sha": "d26bf68cb5dfeb4a3fafe259ebb923ebd4e20cea", "filename": "src/test/compile-fail/issue-18783.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,16 +13,16 @@\n use std::cell::RefCell;\n \n fn main() {\n-    let c = RefCell::new(vec![]);\n     let mut y = 1us;\n+    let c = RefCell::new(vec![]);\n     c.push(box || y = 0);\n     c.push(box || y = 0);\n //~^ ERROR cannot borrow `y` as mutable more than once at a time\n }\n \n fn ufcs() {\n-    let c = RefCell::new(vec![]);\n     let mut y = 1us;\n+    let c = RefCell::new(vec![]);\n \n     Push::push(&c, box || y = 0);\n     Push::push(&c, box || y = 0);"}, {"sha": "a2cac55033c1f30b023b4f39dc1b9d19c66fd11c", "filename": "src/test/compile-fail/issue-21554.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Inches(i32);\n+\n+fn main() {\n+    Inches as f32; //~ ERROR illegal cast; cast through an integer first\n+}"}, {"sha": "057b8e3acc6e37224fbdab11cd4211cbc59a8d7a", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,8 +15,8 @@\n #![feature(path)]\n #![feature(io)]\n \n-use std::io::File;\n-use std::io::IoError;\n+use std::old_io::File;\n+use std::old_io::IoError;\n \n struct Something {\n     X: usize //~ ERROR structure field `X` should have a snake case name such as `x`\n@@ -36,7 +36,7 @@ fn main() {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n         Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {:?}\", EndOfFile),\n //~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`\n-//~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::io::IoErrorKind`\n+//~^^ WARN `EndOfFile` is named the same as one of the variants of the type `std::old_io::IoErrorKind`\n     }\n \n     test(1);"}, {"sha": "285a5dbee053dc8aa7ab8120627cfeedce248f82", "filename": "src/test/compile-fail/typeck-cast-pointer-to-float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let x : i16 = 22;\n     ((&x) as *const i16) as f32;\n-    //~^ ERROR: cannot cast from pointer to float directly: `*const i16` as `f32`\n+    //~^ ERROR illegal cast; cast through an integer first: `*const i16` as `f32`\n }"}, {"sha": "38875c7656ec0a7497d763ca70b15dbf8e6555cb", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -226,7 +226,7 @@\n #![omit_gdb_pretty_printer_section]\n \n fn immediate_args(a: int, b: bool, c: f64) {\n-    ::std::io::print(\"\") // #break\n+    ::std::old_io::print(\"\") // #break\n }\n \n struct BigStruct {\n@@ -241,21 +241,21 @@ struct BigStruct {\n }\n \n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    ::std::io::print(\"\") // #break\n+    ::std::old_io::print(\"\") // #break\n }\n \n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0i; // #break\n-    ::std::io::print(\"\")\n+    ::std::old_io::print(\"\")\n }\n \n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b; // #break\n-    ::std::io::print(\"\")\n+    ::std::old_io::print(\"\")\n }\n \n fn function_call(x: u64, y: u64, z: f64) {\n-    std::io::stdio::print(\"Hi!\") // #break\n+    std::old_io::stdio::print(\"Hi!\") // #break\n }\n \n fn identifier(x: u64, y: u64, z: f64) -> u64 {"}, {"sha": "4692318b98fd1beff848280e294d8266b1a54914", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -249,7 +249,7 @@\n \n #[no_stack_check]\n fn immediate_args(a: int, b: bool, c: f64) {\n-    ::std::io::print(\"\");\n+    ::std::old_io::print(\"\");\n }\n \n struct BigStruct {\n@@ -265,24 +265,24 @@ struct BigStruct {\n \n #[no_stack_check]\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    ::std::io::print(\"\");\n+    ::std::old_io::print(\"\");\n }\n \n #[no_stack_check]\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0i;\n-    ::std::io::print(\"\");\n+    ::std::old_io::print(\"\");\n }\n \n #[no_stack_check]\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n-    ::std::io::print(\"\");\n+    ::std::old_io::print(\"\");\n }\n \n #[no_stack_check]\n fn function_call(x: u64, y: u64, z: f64) {\n-    std::io::stdio::print(\"Hi!\")\n+    std::old_io::stdio::print(\"Hi!\")\n }\n \n #[no_stack_check]"}, {"sha": "799352911f605e66f9f70a4a9c7685069df5413e", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -156,7 +156,7 @@ fn assignment(mut a: u64, b: u64, c: f64) {\n }\n \n fn function_call(x: u64, y: u64, z: f64) {\n-    std::io::stdio::print(\"Hi!\")\n+    std::old_io::stdio::print(\"Hi!\")\n }\n \n fn identifier(x: u64, y: u64, z: f64) -> u64 {"}, {"sha": "dd61542b80050508feab5b53bb0ba9dd852f334f", "filename": "src/test/debuginfo/issue13213.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue13213.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -21,5 +21,5 @@ extern crate issue13213aux;\n // be available because they have been optimized out from the exporting crate.\n fn main() {\n     let b: issue13213aux::S = issue13213aux::A;\n-    ::std::io::println(\"Nothing to do here...\");\n+    ::std::old_io::println(\"Nothing to do here...\");\n }"}, {"sha": "3adb45798e41a002752c30b7c3723482774b45dc", "filename": "src/test/run-make/cannot-read-embedded-idents/create_and_compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcannot-read-embedded-idents%2Fcreate_and_compile.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::os;\n-use std::io::{File, Command};\n+use std::old_io::{File, Command};\n \n // creates broken.rs, which has the Ident \\x00name_0,ctxt_0\\x00\n // embedded within it, and then attempts to compile broken.rs with the"}, {"sha": "eda89f2344bc06db44082fd1510000775b633e6c", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::{char, os};\n-use std::io::{File, Command};\n+use std::old_io::{File, Command};\n use std::rand::{thread_rng, Rng};\n \n // creates unicode_input_multiple_files_{main,chars}.rs, where the"}, {"sha": "d387b9d71e37c648241467ae8d833f2120110509", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::{File, Command};\n+use std::old_io::{File, Command};\n use std::iter::repeat;\n use std::rand::{thread_rng, Rng};\n use std::{char, os};"}, {"sha": "c16f1f4c842ac1d1afacc0205d28635c7b224d9a", "filename": "src/test/run-pass-valgrind/cleanup-stdin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let _ = std::io::stdin();\n+    let _ = std::old_io::stdin();\n }"}, {"sha": "a71794149be48be09be762bf94fe99d4d24cde1e", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@\n #![feature(unsafe_destructor)]\n \n use std::os;\n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::str;\n use std::ops::{Drop, FnMut, FnOnce};\n "}, {"sha": "fd988d28778032452d4907905977ebf4becf0ffc", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,7 +20,7 @@ extern crate log;\n use log::{set_logger, Logger, LogRecord};\n use std::sync::mpsc::channel;\n use std::fmt;\n-use std::io::{ChanReader, ChanWriter};\n+use std::old_io::{ChanReader, ChanWriter};\n use std::thread::Thread;\n \n struct MyWriter(ChanWriter);"}, {"sha": "a4495c3c68e8b37f443d2e45619d5a02eff68906", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,7 +14,7 @@\n #![feature(unboxed_closures)]\n \n use std::mem;\n-use std::io::stdio::println;\n+use std::old_io::stdio::println;\n \n fn call_it<F>(f: F)\n     where F : FnOnce(String) -> String"}, {"sha": "bcb2e492041509a95e899f16f1b97ffebd822772", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n // no-pretty-expanded\n \n #![allow(unused_must_use, dead_code, deprecated)]\n-use std::io::MemWriter;\n+use std::old_io::MemWriter;\n use std::fmt;\n \n struct Foo<'a> {"}, {"sha": "88d5b74708e623804d7e348a8658259c39344044", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -19,7 +19,7 @@\n \n extern crate libc;\n \n-use std::io::{Process, Command, timer};\n+use std::old_io::{Process, Command, timer};\n use std::time::Duration;\n use std::str;\n use std::sync::mpsc::channel;\n@@ -56,8 +56,8 @@ fn test_destroy_twice() {\n }\n \n pub fn test_destroy_actually_kills(force: bool) {\n-    use std::io::process::{Command, ProcessOutput, ExitStatus, ExitSignal};\n-    use std::io::timer;\n+    use std::old_io::process::{Command, ProcessOutput, ExitStatus, ExitSignal};\n+    use std::old_io::timer;\n     use libc;\n     use std::str;\n "}, {"sha": "4b69e1595bd601c416b31471affebd1ecfba5a13", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@\n // that we don't die in a large ball of fire\n \n use std::os;\n-use std::io::process;\n+use std::old_io::process;\n \n pub fn main () {\n     let args = os::args();"}, {"sha": "10d694957f57e10101d7eea864cf81af06a458fc", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,9 +13,9 @@\n extern crate rbml;\n extern crate serialize;\n \n-use std::io;\n+use std::old_io;\n use std::fmt;\n-use std::io::{IoResult, SeekStyle};\n+use std::old_io::{IoResult, SeekStyle};\n use std::slice;\n \n use serialize::{Encodable, Encoder};"}, {"sha": "38731b8c8daeb579a9694d4280611685bff1b3c8", "filename": "src/test/run-pass/issue-12684.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-12684.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12684.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,7 +16,7 @@ fn main() {\n }\n \n fn customtask() {\n-    let mut timer = std::io::timer::Timer::new().unwrap();\n+    let mut timer = std::old_io::timer::Timer::new().unwrap();\n     let periodic = timer.periodic(Duration::milliseconds(10));\n     periodic.recv();\n }"}, {"sha": "b55d64777537ec4424f14a5fab03ac2725d36e52", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::timer;\n+use std::old_io::timer;\n use std::time::Duration;\n \n fn main() {"}, {"sha": "f2a8bc47db86ed27d47a9c9d53a521ccea6a9bb0", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n // ignore-fast\n \n use std::os;\n-use std::io;\n+use std::old_io;\n use std::str;\n \n fn main() {\n@@ -27,7 +27,7 @@ fn main() {\n fn parent() {\n     let args = os::args();\n     let args = args.as_slice();\n-    let mut p = io::process::Command::new(args[0].as_slice())\n+    let mut p = old_io::process::Command::new(args[0].as_slice())\n                                      .arg(\"child\").spawn().unwrap();\n     p.stdin.as_mut().unwrap().write_str(\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();\n@@ -37,7 +37,7 @@ fn parent() {\n }\n \n fn child() {\n-    for line in io::stdin().lock().lines() {\n+    for line in old_io::stdin().lock().lines() {\n         println!(\"{}\", line.unwrap());\n     }\n }"}, {"sha": "a41e57f10025d2e32dfa1429a03db8261783b397", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n \n-use std::io::process;\n-use std::io::Command;\n-use std::io;\n+use std::old_io::process;\n+use std::old_io::Command;\n+use std::old_io;\n use std::os;\n \n fn main() {\n@@ -25,9 +25,9 @@ fn main() {\n }\n \n fn child() {\n-    io::stdout().write_line(\"foo\").unwrap();\n-    io::stderr().write_line(\"bar\").unwrap();\n-    assert_eq!(io::stdin().lock().read_line().err().unwrap().kind, io::EndOfFile);\n+    old_io::stdout().write_line(\"foo\").unwrap();\n+    old_io::stderr().write_line(\"bar\").unwrap();\n+    assert_eq!(old_io::stdin().lock().read_line().err().unwrap().kind, old_io::EndOfFile);\n }\n \n fn test() {"}, {"sha": "abb15dae00df614e3a1451693de0e34e2b9a6415", "filename": "src/test/run-pass/issue-14901.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14901.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::Reader;\n+use std::old_io::Reader;\n \n enum Wrapper<'a> {\n     WrapReader(&'a (Reader + 'a))"}, {"sha": "5ae0ad6c3e97453231f00f4783e8d9cc9a901226", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::os;\n-use std::io::{stdio, Command};\n+use std::old_io::{stdio, Command};\n \n fn main() {\n     let args = os::args();"}, {"sha": "1d18f33fd18eecf7c666f6d872e5040a51ee23aa", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::slice::SliceExt;\n-use std::io::{Command, fs, USER_RWX};\n+use std::old_io::{Command, fs, USER_RWX};\n use std::os;\n use std::path::BytesContainer;\n use std::rand::random;"}, {"sha": "d73ca1b11a5555fef9b8d3aca29d3f0e5f65b6ae", "filename": "src/test/run-pass/issue-16272.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16272.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::{process, Command};\n+use std::old_io::{process, Command};\n use std::os;\n \n fn main() {"}, {"sha": "124b0205faeb5d39a7d6b1e4c3b20a4060ed23c1", "filename": "src/test/run-pass/issue-16671.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16671.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -21,7 +21,7 @@\n use std::thread::Thread;\n \n pub fn main() {\n-    let mut stdin = std::io::stdin();\n+    let mut stdin = std::old_io::stdin();\n     Thread::spawn(move|| {\n         let _ = stdin.read_to_end();\n     });"}, {"sha": "2f0b8c9f19beb1c0f57ded4062ceb73d33ca23bc", "filename": "src/test/run-pass/issue-17121.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-17121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17121.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::BufReader;\n-use std::io::BufferedReader;\n-use std::io::File;\n-use std::io::IoResult;\n+use std::old_io::BufReader;\n+use std::old_io::BufferedReader;\n+use std::old_io::File;\n+use std::old_io::IoResult;\n \n struct Lexer<R: Reader>\n {"}, {"sha": "dd1cfb5e342832e9b50f87bae8687cfd0aaeae18", "filename": "src/test/run-pass/issue-17322.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-17322.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-17322.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17322.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,13 +11,13 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::io;\n+use std::old_io;\n \n fn f(wr: &mut Writer) {\n     wr.write_str(\"hello\").ok().expect(\"failed\");\n }\n \n fn main() {\n-    let mut wr = box io::stdout() as Box<Writer + 'static>;\n+    let mut wr = box old_io::stdout() as Box<Writer + 'static>;\n     f(&mut wr);\n }"}, {"sha": "6b6296b0bd929f264fbd9c638189ad31f2f241ce", "filename": "src/test/run-pass/issue-18619.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18619.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::FileType;\n+use std::old_io::FileType;\n \n pub fn main() {\n     let _ = FileType::RegularFile.clone();"}, {"sha": "3ef63a53a6dea195780df58473d88e2c6b573b12", "filename": "src/test/run-pass/issue-20091.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20091.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-windows currently windows requires UTF-8 for spawning processes\n \n-use std::io::Command;\n+use std::old_io::Command;\n use std::os;\n \n fn main() {"}, {"sha": "0d482548cc0bf933241d8a6f7407b83e7cba93ec", "filename": "src/test/run-pass/issue-20644.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20644.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,7 +16,7 @@\n \n use std::iter;\n use std::os;\n-use std::io::File;\n+use std::old_io::File;\n \n #[allow(unused)]\n pub fn parse_summary<R: Reader>(_: R, _: &Path) {"}, {"sha": "049e08d2b94f5b9838a44f8e34c23f8b62e050ab", "filename": "src/test/run-pass/issue-20797.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,9 +14,9 @@\n // Regression test for #20797.\n \n use std::default::Default;\n-use std::io::IoResult;\n-use std::io::fs;\n-use std::io::fs::PathExtensions;\n+use std::old_io::IoResult;\n+use std::old_io::fs;\n+use std::old_io::fs::PathExtensions;\n \n /// A strategy for acquiring more subpaths to walk.\n pub trait Strategy {"}, {"sha": "27ac538b5b3a5bdbf390cc1637db1408aa1f0a55", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@\n \n /// Map representation\n \n-use std::io;\n+use std::old_io;\n use std::fmt;\n use square::{bot, wall, rock, lambda, closed_lift, open_lift, earth, empty};\n \n@@ -59,9 +59,9 @@ fn square_from_char(c: char) -> square {\n     }\n }\n \n-fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr)\n+fn read_board_grid<rdr:'static + old_io::Reader>(mut input: rdr)\n                    -> Vec<Vec<square>> {\n-    let mut input: &mut io::Reader = &mut input;\n+    let mut input: &mut old_io::Reader = &mut input;\n     let mut grid = Vec::new();\n     let mut line = [0; 10];\n     input.read(&mut line);"}, {"sha": "25663f2605fcb4233cc47bc27743d738068f188b", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -17,7 +17,8 @@ extern crate collections;\n use std::collections::HashMap;\n \n pub fn main() {\n+    let x;\n     let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n-    let x = box 1;\n+    x = box 1;\n     buggy_map.insert(42, &*x);\n }"}, {"sha": "28ab3c3ef12537956feed46fcdfdc587f12bde1b", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::old_io;\n \n pub fn main() {\n-    let stdout = &mut io::stdout() as &mut io::Writer;\n+    let stdout = &mut old_io::stdout() as &mut old_io::Writer;\n     stdout.write(b\"Hello!\");\n }"}, {"sha": "ec4cd02e9fd698ea3167e5f7aa889efdb298066a", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::println;\n+use std::old_io::println;\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n "}, {"sha": "1ad48d326eaca423d151628cc4a1b579c071e2e5", "filename": "src/test/run-pass/issue-5988.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-5988.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-5988.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5988.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::old_io;\n trait B {\n     fn f(&self);\n }\n@@ -19,7 +19,7 @@ trait T : B {\n struct A;\n \n impl<U: T> B for U {\n-    fn f(&self) { io::println(\"Hey, I'm a T!\"); }\n+    fn f(&self) { old_io::println(\"Hey, I'm a T!\"); }\n }\n \n impl T for A {"}, {"sha": "e52e3295c6e0b1d3241191dbd9c9c8dbb5cfbfc1", "filename": "src/test/run-pass/issue-8398.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8398.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io;\n+use std::old_io;\n \n-fn foo(a: &mut io::Writer) {\n+fn foo(a: &mut old_io::Writer) {\n     a.write(&[]).unwrap();\n }\n "}, {"sha": "a98d1aba04dfd716d65efe69e7caafebf34d69cc", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::sync::mpsc::{TryRecvError, channel};\n-use std::io::timer::Timer;\n+use std::old_io::timer::Timer;\n use std::thread::Thread;\n use std::time::Duration;\n "}, {"sha": "44daa52886cf85872156234107c813c6439bd79b", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@\n #[macro_use]\n extern crate log;\n \n-use std::io::Command;\n+use std::old_io::Command;\n use std::os;\n use std::str;\n "}, {"sha": "76895af099d6d0109f9216c3ad9cd3bb975e0fbc", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@\n use std::raw;\n use std::mem;\n use std::slice;\n-use std::io::IoResult;\n+use std::old_io::IoResult;\n \n trait MyWriter {\n     fn my_write(&mut self, buf: &[u8]) -> IoResult<()>;"}, {"sha": "5d180c3a2801b13edca25956d00608f859cddd54", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -15,7 +15,7 @@\n \n #![feature(asm)]\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::os;\n use std::thread::Thread;\n "}, {"sha": "8178a0d5a6cb5a067ea313df73493b922fe09b78", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,7 +16,7 @@\n \n #![feature(asm)]\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::os;\n \n // lifted from the test module"}, {"sha": "ef77f6e9901089edf3cc2709586aef8e5a47392f", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(asm)]\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::os;\n \n // lifted from the test module"}, {"sha": "e0fd0a1347399aa2fb9c741aa87daf3abfeac7fe", "filename": "src/test/run-pass/process-remove-from-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::Command;\n+use std::old_io::Command;\n use std::os;\n \n #[cfg(all(unix, not(target_os=\"android\")))]"}, {"sha": "5dcaa885e380c5aa46dad882789eb4a87773dde7", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -16,9 +16,9 @@\n // non-ASCII characters.  The child process ensures all the strings are\n // intact.\n \n-use std::io;\n-use std::io::fs;\n-use std::io::Command;\n+use std::old_io;\n+use std::old_io::fs;\n+use std::old_io::Command;\n use std::os;\n use std::path::Path;\n \n@@ -49,7 +49,7 @@ fn main() {\n         let child_path     = cwd.join(child_filename);\n \n         // make a separate directory for the child\n-        drop(fs::mkdir(&cwd, io::USER_RWX).is_ok());\n+        drop(fs::mkdir(&cwd, old_io::USER_RWX).is_ok());\n         assert!(fs::copy(&my_path, &child_path).is_ok());\n         let mut my_env = my_env;\n         my_env.push(env);\n@@ -62,8 +62,8 @@ fn main() {\n                         .spawn().unwrap().wait_with_output().unwrap();\n \n         // display the output\n-        assert!(io::stdout().write(p.output.as_slice()).is_ok());\n-        assert!(io::stderr().write(p.error.as_slice()).is_ok());\n+        assert!(old_io::stdout().write(p.output.as_slice()).is_ok());\n+        assert!(old_io::stderr().write(p.error.as_slice()).is_ok());\n \n         // make sure the child succeeded\n         assert!(p.status.success());"}, {"sha": "12e4f27a64f21f51924aadaa7f89fe32992aea1a", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -14,10 +14,10 @@\n extern crate libc;\n \n use std::ffi::CString;\n-use std::io::TempDir;\n-use std::io::fs::PathExtensions;\n-use std::io::fs;\n-use std::io;\n+use std::old_io::TempDir;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::fs;\n+use std::old_io;\n use std::os;\n \n fn rename_directory() {\n@@ -27,7 +27,7 @@ fn rename_directory() {\n         let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n         let old_path = tmpdir.join_many(&[\"foo\", \"bar\", \"baz\"]);\n-        fs::mkdir_recursive(&old_path, io::USER_RWX);\n+        fs::mkdir_recursive(&old_path, old_io::USER_RWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n@@ -45,7 +45,7 @@ fn rename_directory() {\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n         let new_path = tmpdir.join_many(&[\"quux\", \"blat\"]);\n-        fs::mkdir_recursive(&new_path, io::USER_RWX);\n+        fs::mkdir_recursive(&new_path, old_io::USER_RWX);\n         fs::rename(&old_path, &new_path.join(\"newdir\"));\n         assert!(new_path.join(\"newdir\").is_dir());\n         assert!(new_path.join_many(&[\"newdir\", \"temp.txt\"]).exists());"}, {"sha": "32f9de71d5307e770b9b1f981b08cb686e68638e", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n #![feature(start)]\n \n use std::ffi;\n-use std::io::process::{Command, ProcessOutput};\n+use std::old_io::process::{Command, ProcessOutput};\n use std::os;\n use std::rt::unwind::try;\n use std::rt;"}, {"sha": "160c9f2c9d5c2df103dd599260845bb011a0134f", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n use std::os;\n \n fn main() {"}, {"sha": "bf500bf041723068f43743630b574d942cecaeed", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n // ignore-windows\n \n use std::os;\n-use std::io::process::{Command, ExitSignal, ExitStatus};\n+use std::old_io::process::{Command, ExitSignal, ExitStatus};\n \n pub fn main() {\n     let args = os::args();"}, {"sha": "23a928571766181cb31478bc9a6fcbbecc107ce3", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,8 +12,8 @@\n // doesn't die in a ball of fire, but rather it's gracefully handled.\n \n use std::os;\n-use std::io::PipeStream;\n-use std::io::Command;\n+use std::old_io::PipeStream;\n+use std::old_io::Command;\n \n fn test() {\n     let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };"}, {"sha": "bf22fc3bd72efbfa4e156042c35fd94dc7c15d2c", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::io::fs::PathExtensions;\n-use std::io::{File, TempDir};\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::{File, TempDir};\n \n pub fn main() {\n     let dir = TempDir::new_in(&Path::new(\".\"), \"\").unwrap();"}, {"sha": "2bc7a5a88d577d9b2699218dbe27638c822a2c58", "filename": "src/test/run-pass/task-stderr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -12,7 +12,7 @@\n #![feature(box_syntax)]\n \n use std::sync::mpsc::channel;\n-use std::io::{ChanReader, ChanWriter};\n+use std::old_io::{ChanReader, ChanWriter};\n use std::thread;\n \n fn main() {"}, {"sha": "fbe2309964bacf70e70b4d32b4cbc6ae6f25773b", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -13,7 +13,7 @@\n //              quite quickly and it takes a few seconds for the sockets to get\n //              recycled.\n \n-use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n+use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n use std::sync::Arc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::mpsc::channel;"}, {"sha": "23c5501b4a40759cd3ec424444409e4e421d6e60", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -20,9 +20,9 @@\n \n #![allow(unused_imports)]\n \n-use std::io::*;\n-use std::io::test::*;\n-use std::io;\n+use std::old_io::*;\n+use std::old_io::test::*;\n+use std::old_io;\n use std::time::Duration;\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n@@ -44,7 +44,7 @@ fn eventual_timeout() {\n     for _ in range(0u, 10000) {\n         match TcpStream::connect_timeout(addr, Duration::milliseconds(100)) {\n             Ok(e) => v.push(e),\n-            Err(ref e) if e.kind == io::TimedOut => return,\n+            Err(ref e) if e.kind == old_io::TimedOut => return,\n             Err(e) => panic!(\"other error: {}\", e),\n         }\n     }"}, {"sha": "e23d1a6222530e96e9006787c464db2a8c1a29a4", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -17,15 +17,15 @@ extern crate log;\n extern crate libc;\n \n use std::sync::mpsc::channel;\n-use std::io::net::tcp::{TcpListener, TcpStream};\n-use std::io::{Acceptor, Listener};\n+use std::old_io::net::tcp::{TcpListener, TcpStream};\n+use std::old_io::{Acceptor, Listener};\n use std::thread::{Builder, Thread};\n use std::time::Duration;\n \n fn main() {\n     // This test has a chance to time out, try to not let it time out\n     Thread::spawn(move|| -> () {\n-        use std::io::timer;\n+        use std::old_io::timer;\n         timer::sleep(Duration::milliseconds(30 * 1000));\n         println!(\"timed out!\");\n         unsafe { libc::exit(1) }"}, {"sha": "6695920723aefeb6692346f0e83ce22afc10c29a", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -18,9 +18,9 @@\n // they're in a different location than before. Hence, these tests are all run\n // serially here.\n \n-use std::io::fs::PathExtensions;\n-use std::io::{fs, TempDir};\n-use std::io;\n+use std::old_io::fs::PathExtensions;\n+use std::old_io::{fs, TempDir};\n+use std::old_io;\n use std::os;\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n@@ -127,38 +127,38 @@ fn recursive_mkdir_rel() {\n     let cwd = os::getcwd().unwrap();\n     println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, io::USER_RWX);\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n     assert!(path.is_dir());\n-    fs::mkdir_recursive(&path, io::USER_RWX);\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n     assert!(path.is_dir());\n }\n \n fn recursive_mkdir_dot() {\n     let dot = Path::new(\".\");\n-    fs::mkdir_recursive(&dot, io::USER_RWX);\n+    fs::mkdir_recursive(&dot, old_io::USER_RWX);\n     let dotdot = Path::new(\"..\");\n-    fs::mkdir_recursive(&dotdot, io::USER_RWX);\n+    fs::mkdir_recursive(&dotdot, old_io::USER_RWX);\n }\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n     let cwd = os::getcwd().unwrap();\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, io::USER_RWX);\n+    fs::mkdir_recursive(&path, old_io::USER_RWX);\n     assert!(path.is_dir());\n     assert!(path.dir_path().is_dir());\n     let path2 = Path::new(\"quux/blat\");\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n            cwd.display());\n-    fs::mkdir_recursive(&path2, io::USER_RWX);\n+    fs::mkdir_recursive(&path2, old_io::USER_RWX);\n     assert!(path2.is_dir());\n     assert!(path2.dir_path().is_dir());\n }\n \n // Ideally this would be in core, but needs TempFile\n pub fn test_rmdir_recursive_ok() {\n-    let rwx = io::USER_RWX;\n+    let rwx = old_io::USER_RWX;\n \n     let tmpdir = TempDir::new(\"test\").ok().expect(\"test_rmdir_recursive_ok: \\\n                                                    couldn't create temp dir\");"}, {"sha": "11eaa4c99621ff5e58ddf455a6c739d1d20118f0", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -11,7 +11,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::io;\n+use std::old_io;\n \n trait Trait {\n     fn f(&self);\n@@ -41,7 +41,7 @@ pub fn main() {\n     let c: &Trait = &a;\n     c.f();\n \n-    let out = io::stdout();\n+    let out = old_io::stdout();\n     foo(box out);\n }\n "}, {"sha": "4e5d61f166cbebe1db829dc6f11968e517d8d2e6", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71223050538939ed758fcd3b9114f71abff20bb2/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=71223050538939ed758fcd3b9114f71abff20bb2", "patch": "@@ -10,7 +10,7 @@\n \n extern crate libc;\n \n-use std::io::process::Command;\n+use std::old_io::process::Command;\n \n use libc::funcs::posix88::unistd;\n "}]}