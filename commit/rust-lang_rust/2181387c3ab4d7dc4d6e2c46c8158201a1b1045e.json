{"sha": "2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "node_id": "C_kwDOAAsO6NoAKDIxODEzODdjM2FiNGQ3ZGM0ZDZlMmM0NmM4MTU4MjAxYTFiMTA0NWU", "commit": {"author": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-07T15:53:08Z"}, "committer": {"name": "Yechan Bae", "email": "yechan@gatech.edu", "date": "2021-10-09T09:47:07Z"}, "message": "Improved error message for set_len() on empty Vec", "tree": {"sha": "4b079caaf94d1dea395664faef65c5ee375b2d63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b079caaf94d1dea395664faef65c5ee375b2d63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "html_url": "https://github.com/rust-lang/rust/commit/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e/comments", "author": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Qwaz", "id": 5073807, "node_id": "MDQ6VXNlcjUwNzM4MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5073807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Qwaz", "html_url": "https://github.com/Qwaz", "followers_url": "https://api.github.com/users/Qwaz/followers", "following_url": "https://api.github.com/users/Qwaz/following{/other_user}", "gists_url": "https://api.github.com/users/Qwaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Qwaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Qwaz/subscriptions", "organizations_url": "https://api.github.com/users/Qwaz/orgs", "repos_url": "https://api.github.com/users/Qwaz/repos", "events_url": "https://api.github.com/users/Qwaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Qwaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de0d2b15008f0333e432aab9a7b7045ab0157897", "url": "https://api.github.com/repos/rust-lang/rust/commits/de0d2b15008f0333e432aab9a7b7045ab0157897", "html_url": "https://github.com/rust-lang/rust/commit/de0d2b15008f0333e432aab9a7b7045ab0157897"}], "stats": {"total": 113, "additions": 73, "deletions": 40}, "files": [{"sha": "15c79da6fa990ef1d8d72cd67db1762d5f260fef", "filename": "clippy_lints/src/uninit_vec.rs", "status": "modified", "additions": 70, "deletions": 31, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e/clippy_lints%2Fsrc%2Funinit_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e/clippy_lints%2Fsrc%2Funinit_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funinit_vec.rs?ref=2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "patch": "@@ -1,5 +1,5 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher::get_vec_init_kind;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::higher::{get_vec_init_kind, VecInitKind};\n use clippy_utils::ty::{is_type_diagnostic_item, is_uninit_value_valid_for_ty};\n use clippy_utils::{is_lint_allowed, path_to_local_id, peel_hir_expr_while, SpanlessEq};\n use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, PathSegment, Stmt, StmtKind};\n@@ -83,69 +83,108 @@ fn handle_uninit_vec_pair(\n     if_chain! {\n         if let Some(vec) = extract_init_or_reserve_target(cx, maybe_init_or_reserve);\n         if let Some((set_len_self, call_span)) = extract_set_len_self(cx, maybe_set_len);\n-        if vec.eq_expr(cx, set_len_self);\n+        if vec.location.eq_expr(cx, set_len_self);\n         if let ty::Ref(_, vec_ty, _) = cx.typeck_results().expr_ty_adjusted(set_len_self).kind();\n         if let ty::Adt(_, substs) = vec_ty.kind();\n-        // Check T of Vec<T>\n-        if !is_uninit_value_valid_for_ty(cx, substs.type_at(0));\n         // `#[allow(...)]` attribute can be set on enclosing unsafe block of `set_len()`\n         if !is_lint_allowed(cx, UNINIT_VEC, maybe_set_len.hir_id);\n         then {\n-            // FIXME: #7698, false positive of the internal lints\n-            #[allow(clippy::collapsible_span_lint_calls)]\n-            span_lint_and_then(\n-                cx,\n-                UNINIT_VEC,\n-                vec![call_span, maybe_init_or_reserve.span],\n-                \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n-                |diag| {\n-                    diag.help(\"initialize the buffer or wrap the content in `MaybeUninit`\");\n-                },\n-            );\n+            if vec.has_capacity() {\n+                // with_capacity / reserve -> set_len\n+\n+                // Check T of Vec<T>\n+                if !is_uninit_value_valid_for_ty(cx, substs.type_at(0)) {\n+                    // FIXME: #7698, false positive of the internal lints\n+                    #[allow(clippy::collapsible_span_lint_calls)]\n+                    span_lint_and_then(\n+                        cx,\n+                        UNINIT_VEC,\n+                        vec![call_span, maybe_init_or_reserve.span],\n+                        \"calling `set_len()` immediately after reserving a buffer creates uninitialized values\",\n+                        |diag| {\n+                            diag.help(\"initialize the buffer or wrap the content in `MaybeUninit`\");\n+                        },\n+                    );\n+                }\n+            } else {\n+                // new / default -> set_len\n+                span_lint(\n+                    cx,\n+                    UNINIT_VEC,\n+                    vec![call_span, maybe_init_or_reserve.span],\n+                    \"calling `set_len()` on empty `Vec` creates out-of-bound values\",\n+                )\n+            }\n         }\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n-enum LocalOrExpr<'tcx> {\n+/// The target `Vec` that is initialized or reserved\n+#[derive(Clone, Copy)]\n+struct TargetVec<'tcx> {\n+    location: VecLocation<'tcx>,\n+    /// `None` if `reserve()`\n+    init_kind: Option<VecInitKind>,\n+}\n+\n+impl TargetVec<'_> {\n+    pub fn has_capacity(self) -> bool {\n+        !matches!(self.init_kind, Some(VecInitKind::New | VecInitKind::Default))\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum VecLocation<'tcx> {\n     Local(HirId),\n     Expr(&'tcx Expr<'tcx>),\n }\n \n-impl<'tcx> LocalOrExpr<'tcx> {\n-    fn eq_expr(self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+impl<'tcx> VecLocation<'tcx> {\n+    pub fn eq_expr(self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n         match self {\n-            LocalOrExpr::Local(hir_id) => path_to_local_id(expr, hir_id),\n-            LocalOrExpr::Expr(self_expr) => SpanlessEq::new(cx).eq_expr(self_expr, expr),\n+            VecLocation::Local(hir_id) => path_to_local_id(expr, hir_id),\n+            VecLocation::Expr(self_expr) => SpanlessEq::new(cx).eq_expr(self_expr, expr),\n         }\n     }\n }\n \n /// Finds the target location where the result of `Vec` initialization is stored\n /// or `self` expression for `Vec::reserve()`.\n-fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> Option<LocalOrExpr<'tcx>> {\n+fn extract_init_or_reserve_target<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) -> Option<TargetVec<'tcx>> {\n     match stmt.kind {\n         StmtKind::Local(local) => {\n             if_chain! {\n                 if let Some(init_expr) = local.init;\n                 if let PatKind::Binding(_, hir_id, _, None) = local.pat.kind;\n-                if get_vec_init_kind(cx, init_expr).is_some();\n+                if let Some(init_kind) = get_vec_init_kind(cx, init_expr);\n                 then {\n-                    Some(LocalOrExpr::Local(hir_id))\n-                } else {\n-                    None\n+                    return Some(TargetVec {\n+                        location: VecLocation::Local(hir_id),\n+                        init_kind: Some(init_kind),\n+                    })\n                 }\n             }\n         },\n         StmtKind::Expr(expr) | StmtKind::Semi(expr) => match expr.kind {\n-            ExprKind::Assign(lhs, rhs, _span) if get_vec_init_kind(cx, rhs).is_some() => Some(LocalOrExpr::Expr(lhs)),\n+            ExprKind::Assign(lhs, rhs, _span) => {\n+                if let Some(init_kind) = get_vec_init_kind(cx, rhs) {\n+                    return Some(TargetVec {\n+                        location: VecLocation::Expr(lhs),\n+                        init_kind: Some(init_kind),\n+                    });\n+                }\n+            },\n             ExprKind::MethodCall(path, _, [self_expr, _], _) if is_reserve(cx, path, self_expr) => {\n-                Some(LocalOrExpr::Expr(self_expr))\n+                return Some(TargetVec {\n+                    location: VecLocation::Expr(self_expr),\n+                    init_kind: None,\n+                });\n             },\n-            _ => None,\n+            _ => (),\n         },\n-        StmtKind::Item(_) => None,\n+        StmtKind::Item(_) => (),\n     }\n+    None\n }\n \n fn is_reserve(cx: &LateContext<'_>, path: &PathSegment<'_>, self_expr: &Expr<'_>) -> bool {"}, {"sha": "520bfb26b62e1b7c23c521cb859113fb31aa540e", "filename": "tests/ui/uninit_vec.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e/tests%2Fui%2Funinit_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2181387c3ab4d7dc4d6e2c46c8158201a1b1045e/tests%2Fui%2Funinit_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit_vec.stderr?ref=2181387c3ab4d7dc4d6e2c46c8158201a1b1045e", "patch": "@@ -21,38 +21,32 @@ LL |         vec.set_len(200);\n    |\n    = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n-error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n   --> $DIR/uninit_vec.rs:24:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     unsafe {\n LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n-error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n   --> $DIR/uninit_vec.rs:30:5\n    |\n LL |     let mut vec: Vec<u8> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     unsafe {\n LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n-error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n+error: calling `set_len()` on empty `Vec` creates out-of-bound values\n   --> $DIR/uninit_vec.rs:35:5\n    |\n LL |     let mut vec: Vec<u8> = Vec::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     unsafe {\n LL |         vec.set_len(200);\n    |         ^^^^^^^^^^^^^^^^\n-   |\n-   = help: initialize the buffer or wrap the content in `MaybeUninit`\n \n error: calling `set_len()` immediately after reserving a buffer creates uninitialized values\n   --> $DIR/uninit_vec.rs:49:5"}]}