{"sha": "6a5b263503dce838c2a09619171b409c9f11bb9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNWIyNjM1MDNkY2U4MzhjMmEwOTYxOTE3MWI0MDljOWYxMWJiOWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T11:35:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-03T23:00:30Z"}, "message": "Add (and use) an analysis to determine which temps can forgo an alloca.", "tree": {"sha": "c398937eaa8ffe93bc7c3e95b308626cfcdfd0f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c398937eaa8ffe93bc7c3e95b308626cfcdfd0f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a5b263503dce838c2a09619171b409c9f11bb9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5b263503dce838c2a09619171b409c9f11bb9f", "html_url": "https://github.com/rust-lang/rust/commit/6a5b263503dce838c2a09619171b409c9f11bb9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a5b263503dce838c2a09619171b409c9f11bb9f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544b06d455a067ab54a850e34bdc7794f23c6734", "url": "https://api.github.com/repos/rust-lang/rust/commits/544b06d455a067ab54a850e34bdc7794f23c6734", "html_url": "https://github.com/rust-lang/rust/commit/544b06d455a067ab54a850e34bdc7794f23c6734"}], "stats": {"total": 185, "additions": 160, "deletions": 25}, "files": [{"sha": "acf6e53468ef552b666be874a319a8eefac16892", "filename": "src/librustc_trans/trans/mir/analyze.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fanalyze.rs?ref=6a5b263503dce838c2a09619171b409c9f11bb9f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An analysis to determine which temporaries require allocas and\n+//! which do not.\n+\n+use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_mir::repr as mir;\n+use rustc_mir::visit::{Visitor, LvalueContext};\n+use trans::common::{self, Block};\n+use super::rvalue;\n+\n+pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n+                               mir: &mir::Mir<'tcx>)\n+                               -> FnvHashSet<usize> {\n+    let mut analyzer = TempAnalyzer::new();\n+\n+    analyzer.visit_mir(mir);\n+\n+    for (index, temp_decl) in mir.temp_decls.iter().enumerate() {\n+        let ty = bcx.monomorphize(&temp_decl.ty);\n+        debug!(\"temp {:?} has type {:?}\", index, ty);\n+        if\n+            ty.is_scalar() ||\n+            ty.is_unique() ||\n+            ty.is_region_ptr() ||\n+            ty.is_simd()\n+        {\n+            // These sorts of types are immediates that we can store\n+            // in an ValueRef without an alloca.\n+            assert!(common::type_is_immediate(bcx.ccx(), ty));\n+        } else {\n+            // These sorts of types require an alloca. Note that\n+            // type_is_immediate() may *still* be true, particularly\n+            // for newtypes, but we currently force some types\n+            // (e.g. structs) into an alloca unconditionally, just so\n+            // that we don't have to deal with having two pathways\n+            // (gep vs getvalue etc).\n+            analyzer.mark_as_lvalue(index);\n+        }\n+    }\n+\n+    analyzer.lvalue_temps\n+}\n+\n+struct TempAnalyzer {\n+    lvalue_temps: FnvHashSet<usize>,\n+}\n+\n+impl TempAnalyzer {\n+    fn new() -> TempAnalyzer {\n+        TempAnalyzer { lvalue_temps: FnvHashSet() }\n+    }\n+\n+    fn mark_as_lvalue(&mut self, temp: usize) {\n+        debug!(\"marking temp {} as lvalue\", temp);\n+        self.lvalue_temps.insert(temp);\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n+    fn visit_assign(&mut self,\n+                    block: mir::BasicBlock,\n+                    lvalue: &mir::Lvalue<'tcx>,\n+                    rvalue: &mir::Rvalue<'tcx>) {\n+        debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n+\n+        match *lvalue {\n+            mir::Lvalue::Temp(index) => {\n+                if !rvalue::rvalue_creates_operand(rvalue) {\n+                    self.mark_as_lvalue(index as usize);\n+                }\n+            }\n+            _ => {\n+                self.visit_lvalue(lvalue, LvalueContext::Store);\n+            }\n+        }\n+\n+        self.visit_rvalue(rvalue);\n+    }\n+\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mir::Lvalue<'tcx>,\n+                    context: LvalueContext) {\n+        debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n+\n+        match *lvalue {\n+            mir::Lvalue::Temp(index) => {\n+                match context {\n+                    LvalueContext::Consume => {\n+                    }\n+                    LvalueContext::Store |\n+                    LvalueContext::Drop |\n+                    LvalueContext::Inspect |\n+                    LvalueContext::Borrow { .. } |\n+                    LvalueContext::Slice { .. } |\n+                    LvalueContext::Projection => {\n+                        self.mark_as_lvalue(index as usize);\n+                    }\n+                }\n+            }\n+            _ => {\n+            }\n+        }\n+\n+        self.super_lvalue(lvalue, context);\n+    }\n+}"}, {"sha": "353ac2e5f79ca58516f39e35dcb6741c5d054e50", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=6a5b263503dce838c2a09619171b409c9f11bb9f", "patch": "@@ -10,7 +10,6 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n-use rustc_data_structures::fnv::FnvHashSet;\n use rustc_mir::repr as mir;\n use rustc_mir::tcx::LvalueTy;\n use trans::base;\n@@ -79,7 +78,7 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>) {\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let lvalue_temps: FnvHashSet<usize> = (0..mir.temp_decls.len()).collect();\n+    let lvalue_temps = analyze::lvalue_temps(bcx, mir);\n \n     // Allocate variable and temp allocas\n     let vars = mir.var_decls.iter()\n@@ -183,6 +182,7 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: Block<'bcx, 'tcx>,\n        .collect()\n }\n \n+mod analyze;\n mod block;\n mod constant;\n mod lvalue;"}, {"sha": "a0308032ac07bb4e1e4a0438af3769bafaf4e394", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=6a5b263503dce838c2a09619171b409c9f11bb9f", "patch": "@@ -16,8 +16,9 @@ use trans::build;\n use trans::common::Block;\n use trans::datum;\n \n-use super::MirContext;\n+use super::{MirContext, TempRef};\n \n+#[derive(Copy, Clone)]\n pub struct OperandRef<'tcx> {\n     // This will be \"indirect\" if `appropriate_rvalue_mode` returns\n     // ByRef, and otherwise ByValue.\n@@ -37,6 +38,25 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n         match *operand {\n             mir::Operand::Consume(ref lvalue) => {\n+                // watch out for temporaries that do not have an\n+                // alloca; they are handled somewhat differently\n+                if let &mir::Lvalue::Temp(index) = lvalue {\n+                    match self.temps[index as usize] {\n+                        TempRef::Operand(Some(o)) => {\n+                            return o;\n+                        }\n+                        TempRef::Operand(None) => {\n+                            bcx.tcx().sess.bug(\n+                                &format!(\"use of {:?} before def\", lvalue));\n+                        }\n+                        TempRef::Lvalue(..) => {\n+                            // use path below\n+                        }\n+                    }\n+                }\n+\n+                // for most lvalues, to consume them we just load them\n+                // out from their home\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 debug!(\"trans_operand: tr_lvalue={} @ {:?}\","}, {"sha": "7c0912592b6fdc3fce186569b3b06019ec68b48e", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a5b263503dce838c2a09619171b409c9f11bb9f/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=6a5b263503dce838c2a09619171b409c9f11bb9f", "patch": "@@ -80,40 +80,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             _ => {\n-                assert!(self.rvalue_creates_operand(rvalue));\n+                assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n                 build::Store(bcx, temp.llval, lldest);\n                 bcx\n             }\n         }\n     }\n \n-    pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>) -> bool {\n-        match *rvalue {\n-            mir::Rvalue::Use(..) | // (*)\n-            mir::Rvalue::Ref(..) |\n-            mir::Rvalue::Len(..) |\n-            mir::Rvalue::Cast(..) | // (*)\n-            mir::Rvalue::BinaryOp(..) |\n-            mir::Rvalue::UnaryOp(..) |\n-            mir::Rvalue::Box(..) =>\n-                true,\n-            mir::Rvalue::Repeat(..) |\n-            mir::Rvalue::Aggregate(..) |\n-            mir::Rvalue::Slice { .. } |\n-            mir::Rvalue::InlineAsm(..) =>\n-                false,\n-        }\n-\n-        // (*) this is only true if the type is suitable\n-    }\n-\n     pub fn trans_rvalue_operand(&mut self,\n                                 bcx: Block<'bcx, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n                                 -> (Block<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n-        assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+        assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Use(ref operand) => {\n@@ -300,3 +280,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n }\n+\n+pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n+    match *rvalue {\n+        mir::Rvalue::Use(..) | // (*)\n+        mir::Rvalue::Ref(..) |\n+        mir::Rvalue::Len(..) |\n+        mir::Rvalue::Cast(..) | // (*)\n+        mir::Rvalue::BinaryOp(..) |\n+        mir::Rvalue::UnaryOp(..) |\n+        mir::Rvalue::Box(..) =>\n+            true,\n+        mir::Rvalue::Repeat(..) |\n+        mir::Rvalue::Aggregate(..) |\n+        mir::Rvalue::Slice { .. } |\n+        mir::Rvalue::InlineAsm(..) =>\n+            false,\n+    }\n+\n+    // (*) this is only true if the type is suitable\n+}"}]}