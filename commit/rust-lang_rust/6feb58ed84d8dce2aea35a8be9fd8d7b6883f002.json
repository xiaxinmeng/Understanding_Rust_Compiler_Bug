{"sha": "6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZWI1OGVkODRkOGRjZTJhZWEzNWE4YmU5ZmQ4ZDdiNjg4M2YwMDI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-10T20:38:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-13T06:18:51Z"}, "message": "Define integer formats for all widths\n\nCloses #1653", "tree": {"sha": "bff648e5d7b25990f46933195ae47732ef1e110f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bff648e5d7b25990f46933195ae47732ef1e110f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "html_url": "https://github.com/rust-lang/rust/commit/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9", "html_url": "https://github.com/rust-lang/rust/commit/b820748ff5a2bc09b58dd7ac511e0f607d55f2e9"}], "stats": {"total": 158, "additions": 121, "deletions": 37}, "files": [{"sha": "7085147aaeecb371593ee2bee585bb132baa9e29", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 56, "deletions": 37, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "patch": "@@ -17,7 +17,6 @@ use rt::io::mem::MemWriter;\n use rt::io;\n use str;\n use sys;\n-use uint;\n use util;\n use vec;\n \n@@ -238,7 +237,7 @@ impl<'self> Formatter<'self> {\n     }\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n-        do uint::to_str_bytes(value, 10) |buf| {\n+        do ::uint::to_str_bytes(value, 10) |buf| {\n             let valuestr = str::from_bytes_slice(buf);\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n@@ -314,7 +313,7 @@ impl<'self> Formatter<'self> {\n                 // case where the maximum length will matter.\n                 let char_len = s.char_len();\n                 if char_len >= max {\n-                    let nchars = uint::min(max, char_len);\n+                    let nchars = ::uint::min(max, char_len);\n                     self.buf.write(s.slice_chars(0, nchars).as_bytes());\n                     return\n                 }\n@@ -409,52 +408,72 @@ impl Char for char {\n     }\n }\n \n-impl Signed for int {\n-    fn fmt(c: &int, f: &mut Formatter) {\n-        do uint::to_str_bytes(c.abs() as uint, 10) |buf| {\n-            f.pad_integral(buf, \"\", *c >= 0);\n-        }\n-    }\n-}\n-\n-impl Unsigned for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        do uint::to_str_bytes(*c, 10) |buf| {\n-            f.pad_integral(buf, \"\", true);\n+macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n+                       $name:ident, $prefix:expr) => {\n+    impl $name for $ty {\n+        fn fmt(c: &$ty, f: &mut Formatter) {\n+            do ::$into::to_str_bytes(*c as $into, $base) |buf| {\n+                f.pad_integral(buf, $prefix, true);\n+            }\n         }\n     }\n-}\n-\n-impl Octal for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        do uint::to_str_bytes(*c, 8) |buf| {\n-            f.pad_integral(buf, \"0o\", true);\n+})\n+macro_rules! upper_hex(($ty:ident, $into:ident) => {\n+    impl UpperHex for $ty {\n+        fn fmt(c: &$ty, f: &mut Formatter) {\n+            do ::$into::to_str_bytes(*c as $into, 16) |buf| {\n+                upperhex(buf, f);\n+            }\n         }\n     }\n-}\n+})\n \n-impl LowerHex for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        do uint::to_str_bytes(*c, 16) |buf| {\n-            f.pad_integral(buf, \"0x\", true);\n+// Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n+// when inlined into the above macro...\n+#[doc(hidden)]\n+pub fn upperhex(buf: &[u8], f: &mut Formatter) {\n+    let mut local = [0u8, ..16];\n+    for i in ::iterator::range(0, buf.len()) {\n+        local[i] = match buf[i] as char {\n+            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n+            c => c as u8,\n         }\n     }\n+    f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n }\n \n-impl UpperHex for uint {\n-    fn fmt(c: &uint, f: &mut Formatter) {\n-        do uint::to_str_bytes(*c, 16) |buf| {\n-            let mut local = [0u8, ..16];\n-            for (l, &b) in local.mut_iter().zip(buf.iter()) {\n-                *l = match b as char {\n-                    'a' .. 'f' => (b - 'a' as u8) + 'A' as u8,\n-                    _ => b,\n-                };\n+// FIXME(#4375) shouldn't need an inner module\n+macro_rules! integer(($signed:ident, $unsigned:ident) => {\n+    mod $signed {\n+        use super::*;\n+\n+        // Signed is special because it actuall emits the negative sign,\n+        // nothing else should do that, however.\n+        impl Signed for $signed {\n+            fn fmt(c: &$signed, f: &mut Formatter) {\n+                do ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10) |buf| {\n+                    f.pad_integral(buf, \"\", *c >= 0);\n+                }\n             }\n-            f.pad_integral(local.slice_to(buf.len()), \"0x\", true);\n         }\n+        int_base!($signed, $unsigned, 2, Binary, \"0b\")\n+        int_base!($signed, $unsigned, 8, Octal, \"0o\")\n+        int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n+        upper_hex!($signed, $unsigned)\n+\n+        int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n+        int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n+        int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n+        int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n+        upper_hex!($unsigned, $unsigned)\n     }\n-}\n+})\n+\n+integer!(int, uint)\n+integer!(i8, u8)\n+integer!(i16, u16)\n+integer!(i32, u32)\n+integer!(i64, u64)\n \n impl<T> Poly for T {\n     fn fmt(t: &T, f: &mut Formatter) {"}, {"sha": "6dda3fc26e83261325158ea8d4a5506c8fbeb36b", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "patch": "@@ -638,6 +638,7 @@ impl Context {\n                     \"X\" => \"UpperHex\",\n                     \"s\" => \"String\",\n                     \"p\" => \"Pointer\",\n+                    \"t\" => \"Binary\",\n                     _ => {\n                         self.ecx.span_err(sp, fmt!(\"unknown format trait \\\n                                                     `%s`\", tyname));"}, {"sha": "adb19e23c037430db383fde0466315dc057c1a99", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "patch": "@@ -91,6 +91,70 @@ pub fn main() {\n     t!(ifmt!(\"{:-#s}\", \"a\"), \"a\");\n     t!(ifmt!(\"{:+#s}\", \"a\"), \"a\");\n \n+    // Formatting integers should select the right implementation based off the\n+    // type of the argument. Also, hex/octal/binary should be defined for\n+    // integers, but they shouldn't emit the negative sign.\n+    t!(ifmt!(\"{:d}\", -1i), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i8), \"1\");\n+    t!(ifmt!(\"{:d}\", -1i16), \"1\");\n+    t!(ifmt!(\"{:d}\", -1i32), \"1\");\n+    t!(ifmt!(\"{:d}\", -1i64), \"1\");\n+    t!(ifmt!(\"{:t}\", -1i), \"1\");\n+    t!(ifmt!(\"{:t}\", -1i8), \"1\");\n+    t!(ifmt!(\"{:t}\", -1i16), \"1\");\n+    t!(ifmt!(\"{:t}\", -1i32), \"1\");\n+    t!(ifmt!(\"{:t}\", -1i64), \"1\");\n+    t!(ifmt!(\"{:x}\", -1i), \"1\");\n+    t!(ifmt!(\"{:x}\", -1i8), \"1\");\n+    t!(ifmt!(\"{:x}\", -1i16), \"1\");\n+    t!(ifmt!(\"{:x}\", -1i32), \"1\");\n+    t!(ifmt!(\"{:x}\", -1i64), \"1\");\n+    t!(ifmt!(\"{:X}\", -1i), \"1\");\n+    t!(ifmt!(\"{:X}\", -1i8), \"1\");\n+    t!(ifmt!(\"{:X}\", -1i16), \"1\");\n+    t!(ifmt!(\"{:X}\", -1i32), \"1\");\n+    t!(ifmt!(\"{:X}\", -1i64), \"1\");\n+    t!(ifmt!(\"{:o}\", -1i), \"1\");\n+    t!(ifmt!(\"{:o}\", -1i8), \"1\");\n+    t!(ifmt!(\"{:o}\", -1i16), \"1\");\n+    t!(ifmt!(\"{:o}\", -1i32), \"1\");\n+    t!(ifmt!(\"{:o}\", -1i64), \"1\");\n+\n+    t!(ifmt!(\"{:d}\", 1u), \"1\");\n+    t!(ifmt!(\"{:d}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:d}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:d}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:d}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:t}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:x}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:X}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:o}\", 1u64), \"1\");\n+\n+    // Test the flags for formatting integers\n+    t!(ifmt!(\"{:3d}\", 1), \"1  \");\n+    t!(ifmt!(\"{:>3d}\", 1), \"  1\");\n+    t!(ifmt!(\"{:#d}\", 1), \"1\");\n+    t!(ifmt!(\"{:#x}\", 10u), \"0xa\");\n+    t!(ifmt!(\"{:#X}\", 10u), \"0xA\");\n+    t!(ifmt!(\"{:#5x}\", 10u), \"0xa  \");\n+    t!(ifmt!(\"{:#o}\", 10u), \"0o12\");\n+\n     // Precision overrides 0-padding\n     // FIXME #2481: Recent gcc's report some of these as warnings\n     /*t!(ifmt!(\"{:0>6.5d}\", 0), ~\" 00000\");*/"}]}