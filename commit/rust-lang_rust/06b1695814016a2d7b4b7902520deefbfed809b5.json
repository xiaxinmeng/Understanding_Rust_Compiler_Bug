{"sha": "06b1695814016a2d7b4b7902520deefbfed809b5", "node_id": "C_kwDOAAsO6NoAKDA2YjE2OTU4MTQwMTZhMmQ3YjRiNzkwMjUyMGRlZWZiZmVkODA5YjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T00:38:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-13T00:38:54Z"}, "message": "Auto merge of #8647 - Jarcho:mut_from_ref_6326, r=giraffate\n\nOnly lint `mut_from_ref` when unsafe code is used\n\nfixes #6326\n\nchangelog: Only lint `mut_from_ref` when unsafe code is used.", "tree": {"sha": "e799169df095c5f4fa40a0c72fd8bdc1024eb37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e799169df095c5f4fa40a0c72fd8bdc1024eb37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06b1695814016a2d7b4b7902520deefbfed809b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06b1695814016a2d7b4b7902520deefbfed809b5", "html_url": "https://github.com/rust-lang/rust/commit/06b1695814016a2d7b4b7902520deefbfed809b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06b1695814016a2d7b4b7902520deefbfed809b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8c97e6cf394498b7ae347fadac349fad04e7681", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c97e6cf394498b7ae347fadac349fad04e7681", "html_url": "https://github.com/rust-lang/rust/commit/d8c97e6cf394498b7ae347fadac349fad04e7681"}, {"sha": "19054251d350ccc81d4fe803821a7695b4518094", "url": "https://api.github.com/repos/rust-lang/rust/commits/19054251d350ccc81d4fe803821a7695b4518094", "html_url": "https://github.com/rust-lang/rust/commit/19054251d350ccc81d4fe803821a7695b4518094"}], "stats": {"total": 149, "additions": 105, "deletions": 44}, "files": [{"sha": "c35eeeac67a35c0567501ba3b38e7dcd1bc61f5e", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/06b1695814016a2d7b4b7902520deefbfed809b5/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b1695814016a2d7b4b7902520deefbfed809b5/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=06b1695814016a2d7b4b7902520deefbfed809b5", "patch": "@@ -3,16 +3,17 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n+use clippy_utils::visitors::contains_unsafe_block;\n use clippy_utils::{get_expr_use_or_unification_node, is_lint_allowed, path_def_id, path_to_local, paths};\n use if_chain::if_chain;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{\n-    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, FnRetTy, GenericArg,\n+    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnRetTy, FnSig, GenericArg,\n     ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n-    TraitItem, TraitItemKind, TyKind,\n+    TraitItem, TraitItemKind, TyKind, Unsafety,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n@@ -88,19 +89,26 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// This lint checks for functions that take immutable\n-    /// references and return mutable ones.\n+    /// This lint checks for functions that take immutable references and return\n+    /// mutable ones. This will not trigger if no unsafe code exists as there\n+    /// are multiple safe functions which will do this transformation\n+    ///\n+    /// To be on the conservative side, if there's at least one mutable\n+    /// reference with the output lifetime, this lint will not trigger.\n     ///\n     /// ### Why is this bad?\n-    /// This is trivially unsound, as one can create two\n-    /// mutable references from the same (immutable!) source.\n-    /// This [error](https://github.com/rust-lang/rust/issues/39465)\n-    /// actually lead to an interim Rust release 1.15.1.\n+    /// Creating a mutable reference which can be repeatably derived from an\n+    /// immutable reference is unsound as it allows creating multiple live\n+    /// mutable references to the same object.\n+    ///\n+    /// This [error](https://github.com/rust-lang/rust/issues/39465) actually\n+    /// lead to an interim Rust release 1.15.1.\n     ///\n     /// ### Known problems\n-    /// To be on the conservative side, if there's at least one\n-    /// mutable reference with the output lifetime, this lint will not trigger.\n-    /// In practice, this case is unlikely anyway.\n+    /// This pattern is used by memory allocators to allow allocating multiple\n+    /// objects while returning mutable references to each one. So long as\n+    /// different mutable references are returned each time such a function may\n+    /// be safe.\n     ///\n     /// ### Example\n     /// ```ignore\n@@ -145,7 +153,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                 return;\n             }\n \n-            check_mut_from_ref(cx, sig.decl);\n+            check_mut_from_ref(cx, sig, None);\n             for arg in check_fn_args(\n                 cx,\n                 cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n@@ -170,10 +178,10 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n         let hir = cx.tcx.hir();\n         let mut parents = hir.parent_iter(body.value.hir_id);\n-        let (item_id, decl, is_trait_item) = match parents.next() {\n+        let (item_id, sig, is_trait_item) = match parents.next() {\n             Some((_, Node::Item(i))) => {\n                 if let ItemKind::Fn(sig, ..) = &i.kind {\n-                    (i.def_id, sig.decl, false)\n+                    (i.def_id, sig, false)\n                 } else {\n                     return;\n                 }\n@@ -185,22 +193,23 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return;\n                 }\n                 if let ImplItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl, false)\n+                    (i.def_id, sig, false)\n                 } else {\n                     return;\n                 }\n             },\n             Some((_, Node::TraitItem(i))) => {\n                 if let TraitItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl, true)\n+                    (i.def_id, sig, true)\n                 } else {\n                     return;\n                 }\n             },\n             _ => return,\n         };\n \n-        check_mut_from_ref(cx, decl);\n+        check_mut_from_ref(cx, sig, Some(body));\n+        let decl = sig.decl;\n         let sig = cx.tcx.fn_sig(item_id).skip_binder();\n         let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params)\n             .filter(|arg| !is_trait_item || arg.mutability() == Mutability::Not)\n@@ -473,31 +482,31 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n         })\n }\n \n-fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n-    if let FnRetTy::Return(ty) = decl.output {\n-        if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n-            let mut immutables = vec![];\n-            for (_, mutbl, argspan) in decl\n-                .inputs\n-                .iter()\n-                .filter_map(get_rptr_lm)\n-                .filter(|&(lt, _, _)| lt.name == out.name)\n-            {\n-                if mutbl == Mutability::Mut {\n-                    return;\n-                }\n-                immutables.push(argspan);\n-            }\n-            if immutables.is_empty() {\n-                return;\n-            }\n+fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Option<&'tcx Body<'_>>) {\n+    if let FnRetTy::Return(ty) = sig.decl.output\n+        && let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty)\n+    {\n+        let args: Option<Vec<_>> = sig\n+            .decl\n+            .inputs\n+            .iter()\n+            .filter_map(get_rptr_lm)\n+            .filter(|&(lt, _, _)| lt.name == out.name)\n+            .map(|(_, mutability, span)| (mutability == Mutability::Not).then(|| span))\n+            .collect();\n+        if let Some(args) = args\n+            && !args.is_empty()\n+            && body.map_or(true, |body| {\n+                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, &body.value)\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MUT_FROM_REF,\n                 ty.span,\n                 \"mutable borrow from immutable input(s)\",\n                 |diag| {\n-                    let ms = MultiSpan::from_spans(immutables);\n+                    let ms = MultiSpan::from_spans(args);\n                     diag.span_note(ms, \"immutable borrow here\");\n                 },\n             );"}, {"sha": "3db64b2535398634e26a9824533a35fab18e0dd5", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/06b1695814016a2d7b4b7902520deefbfed809b5/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b1695814016a2d7b4b7902520deefbfed809b5/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=06b1695814016a2d7b4b7902520deefbfed809b5", "patch": "@@ -3,7 +3,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, Unsafety,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, UnsafeSource,\n+    Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -370,3 +371,34 @@ pub fn is_expr_unsafe<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     v.visit_expr(e);\n     v.is_unsafe\n }\n+\n+/// Checks if the given expression contains an unsafe block\n+pub fn contains_unsafe_block<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        found_unsafe: bool,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type NestedFilter = nested_filter::OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n+        fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+            if self.found_unsafe {\n+                return;\n+            }\n+            if b.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) {\n+                self.found_unsafe = true;\n+                return;\n+            }\n+            walk_block(self, b);\n+        }\n+    }\n+    let mut v = V {\n+        cx,\n+        found_unsafe: false,\n+    };\n+    v.visit_expr(e);\n+    v.found_unsafe\n+}"}, {"sha": "370dbd5882161c837c4ffd14a531c99aa7145f0d", "filename": "tests/ui/mut_from_ref.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06b1695814016a2d7b4b7902520deefbfed809b5/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b1695814016a2d7b4b7902520deefbfed809b5/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=06b1695814016a2d7b4b7902520deefbfed809b5", "patch": "@@ -5,7 +5,7 @@ struct Foo;\n \n impl Foo {\n     fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n-        unimplemented!()\n+        unsafe { unimplemented!() }\n     }\n }\n \n@@ -15,29 +15,37 @@ trait Ouch {\n \n impl Ouch for Foo {\n     fn ouch(x: &Foo) -> &mut Foo {\n-        unimplemented!()\n+        unsafe { unimplemented!() }\n     }\n }\n \n fn fail(x: &u32) -> &mut u16 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n // this is OK, because the result borrows y\n fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n // this is also OK, because the result could borrow y\n fn also_works<'a>(x: &'a u32, y: &'a mut u32) -> &'a mut u32 {\n+    unsafe { unimplemented!() }\n+}\n+\n+unsafe fn also_broken(x: &u32) -> &mut u32 {\n+    unimplemented!()\n+}\n+\n+fn without_unsafe(x: &u32) -> &mut u32 {\n     unimplemented!()\n }\n "}, {"sha": "b76d6a13ffb9cf312d2285886671a976549d18b6", "filename": "tests/ui/mut_from_ref.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06b1695814016a2d7b4b7902520deefbfed809b5/tests%2Fui%2Fmut_from_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06b1695814016a2d7b4b7902520deefbfed809b5/tests%2Fui%2Fmut_from_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.stderr?ref=06b1695814016a2d7b4b7902520deefbfed809b5", "patch": "@@ -59,5 +59,17 @@ note: immutable borrow here\n LL | fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n    |                           ^^^^^^^     ^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:44:35\n+   |\n+LL | unsafe fn also_broken(x: &u32) -> &mut u32 {\n+   |                                   ^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:44:26\n+   |\n+LL | unsafe fn also_broken(x: &u32) -> &mut u32 {\n+   |                          ^^^^\n+\n+error: aborting due to 6 previous errors\n "}]}