{"sha": "bb7442802abe354a0ed844ec237cd20969789224", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNzQ0MjgwMmFiZTM1NGEwZWQ4NDRlYzIzN2NkMjA5Njk3ODkyMjQ=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-07T20:53:48Z"}, "committer": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2018-10-08T12:48:15Z"}, "message": "rewrite_string: retain blank lines that are trailing", "tree": {"sha": "fdd81cafcca0fef68ca4ee1fc389511a41184cf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdd81cafcca0fef68ca4ee1fc389511a41184cf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb7442802abe354a0ed844ec237cd20969789224", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCgAdFiEEipi5pnt+pUplKNfibVYg2QghATMFAlu7Ug8ACgkQbVYg2Qgh\nATOBNgf/XNhVLbGvX87KcXV6iTimSj5Bv8GgZd5E6R6qMml3I5mGnH85dE9ERUnf\nXoZ18Lxm9UgCbOX9cgrKLO0uTWkWHpkD60vVp7uYm1v+kyJOzMJFHDiFU7SRA3pq\n4sX2Ykh60BYZyvRP9YDnGrvWboetVCBlA41cMIqtNmeD5Y8R8ISRLAMhgPmPzS3m\nF6RyIg9XS/IR85oSwnVYH3naWQVjR3kneBRg1zm+vuzn7hwmfgR0OVbT7BCfNUPu\n0UihH5OsiyfMnQ8qbzVuh0rmxCS75BTjSg7pPulZfnVW2XuhoSpju0BGI/Rhyo9f\nrIkpULGVp324xnUmTvv8pREuX2xN1Q==\n=r854\n-----END PGP SIGNATURE-----", "payload": "tree fdd81cafcca0fef68ca4ee1fc389511a41184cf0\nparent 1c6a2e3de8789a70007fe9bf85d4c945e1e15a93\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1538945628 +0200\ncommitter St\u00e9phane Campinas <stephane.campinas@gmail.com> 1539002895 +0200\n\nrewrite_string: retain blank lines that are trailing\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb7442802abe354a0ed844ec237cd20969789224", "html_url": "https://github.com/rust-lang/rust/commit/bb7442802abe354a0ed844ec237cd20969789224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb7442802abe354a0ed844ec237cd20969789224/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c6a2e3de8789a70007fe9bf85d4c945e1e15a93", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c6a2e3de8789a70007fe9bf85d4c945e1e15a93", "html_url": "https://github.com/rust-lang/rust/commit/1c6a2e3de8789a70007fe9bf85d4c945e1e15a93"}], "stats": {"total": 95, "additions": 65, "deletions": 30}, "files": [{"sha": "daca59e87021bf181866a6ee5d2eb200e2c10159", "filename": "src/string.rs", "status": "modified", "additions": 65, "deletions": 30, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/bb7442802abe354a0ed844ec237cd20969789224/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb7442802abe354a0ed844ec237cd20969789224/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=bb7442802abe354a0ed844ec237cd20969789224", "patch": "@@ -100,36 +100,20 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     loop {\n         // All the input starting at cur_start fits on the current line\n         if graphemes.len() - cur_start <= cur_max_chars {\n-            // trim trailing whitespaces\n-            let graphemes_minus_ws = if !fmt.trim_end {\n-                &graphemes[cur_start..]\n-            } else {\n-                match graphemes[cur_start..]\n-                    .iter()\n-                    .rposition(|grapheme| !is_whitespace(grapheme))\n-                {\n-                    Some(index) => &graphemes[cur_start..=cur_start + index],\n-                    None => &graphemes[cur_start..],\n-                }\n-            };\n-            if is_bareline_ok {\n-                // new lines don't need to start with line_start\n-                result.push_str(&graphemes_minus_ws.join(\"\"));\n-            } else {\n-                // new lines need to be indented and prefixed with line_start\n-                for grapheme in graphemes_minus_ws {\n-                    if is_line_feed(grapheme) {\n-                        // take care of blank lines\n-                        if fmt.trim_end && result.ends_with(' ') {\n-                            result = result.trim_right().to_string();\n-                        }\n-                        result.push_str(&indent_with_newline);\n+            for (i, grapheme) in graphemes[cur_start..].iter().enumerate() {\n+                if is_line_feed(grapheme) {\n+                    // take care of blank lines\n+                    result = trim_right_but_line_feed(fmt.trim_end, result);\n+                    result.push_str(\"\\n\");\n+                    if !is_bareline_ok && cur_start + i + 1 < graphemes.len() {\n+                        result.push_str(&indent_without_newline);\n                         result.push_str(fmt.line_start);\n-                    } else {\n-                        result.push_str(grapheme);\n                     }\n+                } else {\n+                    result.push_str(grapheme);\n                 }\n             }\n+            result = trim_right_but_line_feed(fmt.trim_end, result);\n             break;\n         }\n \n@@ -169,6 +153,18 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n+/// Trims whitespaces to the right except for the line feed character.\n+fn trim_right_but_line_feed(trim_end: bool, result: String) -> String {\n+    let whitespace_except_line_feed = |c: char| c.is_whitespace() && c != '\\n';\n+    if trim_end && result.ends_with(whitespace_except_line_feed) {\n+        result\n+            .trim_right_matches(whitespace_except_line_feed)\n+            .to_string()\n+    } else {\n+        result\n+    }\n+}\n+\n /// Result of breaking a string so it fits in a line and the state it ended in.\n /// The state informs about what to do with the snippet and how to continue the breaking process.\n #[derive(Debug, PartialEq)]\n@@ -198,17 +194,22 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n     let break_at = |index /* grapheme at index is included */| {\n         // Take in any whitespaces to the left/right of `input[index]` while\n         // preserving line feeds\n+        let not_whitespace_except_line_feed = |g| is_line_feed(g) || !is_whitespace(g);\n         let index_minus_ws = input[0..=index]\n             .iter()\n-            .rposition(|grapheme| !is_whitespace(grapheme))\n+            .rposition(|grapheme| not_whitespace_except_line_feed(grapheme))\n             .unwrap_or(index);\n         // Take into account newlines occuring in input[0..=index], i.e., the possible next new\n         // line. If there is one, then text after it could be rewritten in a way that the available\n         // space is fully used.\n         for (i, grapheme) in input[0..=index].iter().enumerate() {\n             if is_line_feed(grapheme) {\n-                if i < index_minus_ws || !trim_end {\n-                    return SnippetState::EndWithLineFeed(input[0..=i].join(\"\").to_string(), i + 1);\n+                if i <= index_minus_ws {\n+                    let mut line = input[0..i].join(\"\");\n+                    if trim_end {\n+                        line = line.trim_right().to_string();\n+                    }\n+                    return SnippetState::EndWithLineFeed(format!(\"{}\\n\", line), i + 1);\n                 }\n                 break;\n             }\n@@ -221,7 +222,7 @@ fn break_string(max_chars: usize, trim_end: bool, input: &[&str]) -> SnippetStat\n                     input[0..=index + 1 + i].join(\"\").to_string(),\n                     index + 2 + i,\n                 );\n-            } else if !is_whitespace(grapheme) {\n+            } else if not_whitespace_except_line_feed(grapheme) {\n                 index_plus_ws = index + i;\n                 break;\n             }\n@@ -524,4 +525,38 @@ mod test {\n             )\n         );\n     }\n+\n+    #[test]\n+    fn retain_blank_lines() {\n+        let config: Config = Default::default();\n+        let fmt = StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"// \",\n+            line_end: \"\",\n+            shape: Shape::legacy(20, Indent::from_width(&config, 4)),\n+            trim_end: true,\n+            config: &config,\n+        };\n+\n+        let comment = \"Aenean\\n\\nmetus. Vestibulum ac lacus.\\n\\n\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\n+                \"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\\n    //\\n\".to_string()\n+            )\n+        );\n+\n+        let comment = \"Aenean\\n\\nmetus. Vestibulum ac lacus.\\n\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\\n\".to_string())\n+        );\n+\n+        let comment = \"Aenean\\n        \\nmetus. Vestibulum ac lacus.\";\n+        assert_eq!(\n+            rewrite_string(comment, &fmt),\n+            Some(\"Aenean\\n    //\\n    // metus. Vestibulum ac\\n    // lacus.\".to_string())\n+        );\n+    }\n }"}]}