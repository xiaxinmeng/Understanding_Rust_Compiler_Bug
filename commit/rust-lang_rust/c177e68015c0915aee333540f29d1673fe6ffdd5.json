{"sha": "c177e68015c0915aee333540f29d1673fe6ffdd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzdlNjgwMTVjMDkxNWFlZTMzMzU0MGYyOWQxNjczZmU2ZmZkZDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-28T21:44:04Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-12-28T21:44:04Z"}, "message": "merge two match'es for more exhaustiveness", "tree": {"sha": "910eb975a622ea48c8c9fc6f8cc1537e0e10a2df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/910eb975a622ea48c8c9fc6f8cc1537e0e10a2df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c177e68015c0915aee333540f29d1673fe6ffdd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c177e68015c0915aee333540f29d1673fe6ffdd5", "html_url": "https://github.com/rust-lang/rust/commit/c177e68015c0915aee333540f29d1673fe6ffdd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c177e68015c0915aee333540f29d1673fe6ffdd5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "122e91c4fbba35a2331647f89a4f49e668e0cd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/122e91c4fbba35a2331647f89a4f49e668e0cd88", "html_url": "https://github.com/rust-lang/rust/commit/122e91c4fbba35a2331647f89a4f49e668e0cd88"}], "stats": {"total": 80, "additions": 41, "deletions": 39}, "files": [{"sha": "7cb80c78c8d2b4fb91966b28f322642c8895bb27", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c177e68015c0915aee333540f29d1673fe6ffdd5/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c177e68015c0915aee333540f29d1673fe6ffdd5/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=c177e68015c0915aee333540f29d1673fe6ffdd5", "patch": "@@ -90,7 +90,7 @@ pub enum TempState {\n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n         debug!(\"is_promotable: self={:?}\", self);\n-        matches!(self, TempState::Defined { .. } )\n+        matches!(self, TempState::Defined { .. })\n     }\n }\n \n@@ -329,7 +329,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             return Err(Unpromotable);\n                         }\n \n-\n                         Ok(())\n                     }\n                     _ => bug!(),\n@@ -583,18 +582,33 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n-        match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.body, self.tcx);\n-                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n-                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n-                    // ptr-to-int casts are not possible in consts and thus not promotable\n-                    return Err(Unpromotable);\n+        match rvalue {\n+            Rvalue::Use(operand) | Rvalue::Repeat(operand, _) | Rvalue::UnaryOp(_, operand) => {\n+                self.validate_operand(operand)?;\n+            }\n+\n+            Rvalue::Discriminant(place) | Rvalue::Len(place) => self.validate_place(place.as_ref())?,\n+\n+            Rvalue::ThreadLocalRef(_) => return Err(Unpromotable),\n+\n+            Rvalue::Cast(kind, operand, cast_ty) => {\n+                if matches!(kind, CastKind::Misc) {\n+                    let operand_ty = operand.ty(self.body, self.tcx);\n+                    let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                    let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+                    if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n+                        // ptr-to-int casts are not possible in consts and thus not promotable\n+                        return Err(Unpromotable);\n+                    }\n+                    // int-to-ptr casts are fine, they just use the integer value at pointer type.\n                 }\n+\n+                self.validate_operand(operand)?;\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) => {\n+            Rvalue::BinaryOp(op, lhs, rhs)\n+            | Rvalue::CheckedBinaryOp(op, lhs, rhs) => {\n+                let op = *op;\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).kind() {\n                     assert!(\n                         op == BinOp::Eq\n@@ -609,29 +623,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     // raw pointer operations are not allowed inside consts and thus not promotable\n                     return Err(Unpromotable);\n                 }\n-            }\n-\n-            Rvalue::NullaryOp(NullOp::Box, _) => return Err(Unpromotable),\n-\n-            // FIXME(RalfJung): the rest is *implicitly considered promotable*... that seems dangerous.\n-            _ => {}\n-        }\n-\n-        match rvalue {\n-            Rvalue::ThreadLocalRef(_) => Err(Unpromotable),\n-\n-            Rvalue::NullaryOp(..) => Ok(()),\n \n-            Rvalue::Discriminant(place) | Rvalue::Len(place) => self.validate_place(place.as_ref()),\n+                // FIXME: reject operations that can fail -- namely, division and modulo.\n \n-            Rvalue::Use(operand)\n-            | Rvalue::Repeat(operand, _)\n-            | Rvalue::UnaryOp(_, operand)\n-            | Rvalue::Cast(_, operand, _) => self.validate_operand(operand),\n-\n-            Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n                 self.validate_operand(lhs)?;\n-                self.validate_operand(rhs)\n+                self.validate_operand(rhs)?;\n+            }\n+\n+            Rvalue::NullaryOp(op, _) => {\n+                if matches!(op, NullOp::Box) {\n+                    return Err(Unpromotable);\n+                }\n             }\n \n             Rvalue::AddressOf(_, place) => {\n@@ -646,16 +648,18 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         });\n                     }\n                 }\n-                Err(Unpromotable)\n+                return Err(Unpromotable);\n             }\n \n             Rvalue::Ref(_, kind, place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 let mut place_simplified = place.as_ref();\n                 if let [proj_base @ .., ProjectionElem::Deref] = &place_simplified.projection {\n-                    let base_ty = Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n+                    let base_ty =\n+                        Place::ty_from(place_simplified.local, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind() {\n-                        place_simplified = PlaceRef { local: place_simplified.local, projection: proj_base };\n+                        place_simplified =\n+                            PlaceRef { local: place_simplified.local, projection: proj_base };\n                     }\n                 }\n \n@@ -664,18 +668,16 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // Check that the reference is fine (using the original place!).\n                 // (Needs to come after `validate_local` to avoid ICEs.)\n                 self.validate_ref(*kind, place)?;\n-\n-                Ok(())\n             }\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for o in operands {\n                     self.validate_operand(o)?;\n                 }\n-\n-                Ok(())\n             }\n         }\n+\n+        Ok(())\n     }\n \n     fn validate_call("}]}