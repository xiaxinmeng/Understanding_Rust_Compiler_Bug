{"sha": "f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOTE1MmUwN2JhZjAzZmMxZmY0YzhiMmMxNjc4YWM4NTdiNGE1MTI=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T02:54:11Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-04-24T04:18:01Z"}, "message": "Implement Natural trait\n\nThis adds the following methods to ints and uints:\n\n- div\n- modulo\n- div_mod\n- quot_rem\n- gcd\n- lcm\n- divisible_by\n- is_even\n- is_odd\n\nI have not implemented Natural for BigInt and BigUInt because they're a little over my head.", "tree": {"sha": "6faf560d767e64a0c71ae9330c15e0fb1d2e7998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6faf560d767e64a0c71ae9330c15e0fb1d2e7998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "html_url": "https://github.com/rust-lang/rust/commit/f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aef249056e55ad2bf3d658609c440fad4a9255eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/aef249056e55ad2bf3d658609c440fad4a9255eb", "html_url": "https://github.com/rust-lang/rust/commit/aef249056e55ad2bf3d658609c440fad4a9255eb"}], "stats": {"total": 337, "additions": 335, "deletions": 2}, "files": [{"sha": "61fbf98a7c61d2267764d18657879b72574b8207", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "patch": "@@ -105,7 +105,7 @@ pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};\n \n-pub use num::{Num, Signed, Unsigned, NumCast};\n+pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n pub use ptr::Ptr;\n pub use to_str::ToStr;\n pub use clone::Clone;"}, {"sha": "426ed8a8b0f6e5648c719fab3083dfb67bd17de8", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "patch": "@@ -191,6 +191,24 @@ impl Div<T,T> for T {\n #[cfg(stage2,notest)]\n #[cfg(stage3,notest)]\n impl Quot<T,T> for T {\n+    /**\n+     * Returns the integer quotient, truncated towards 0. As this behaviour reflects\n+     * the underlying machine implementation it is more efficient than `Natural::div`.\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!( 8 /  3 ==  2);\n+     * assert!( 8 / -3 == -2);\n+     * assert!(-8 /  3 == -2);\n+     * assert!(-8 / -3 ==  2);\n+\n+     * assert!( 1 /  2 ==  0);\n+     * assert!( 1 / -2 ==  0);\n+     * assert!(-1 /  2 ==  0);\n+     * assert!(-1 / -2 ==  0);\n+     * ~~~\n+     */\n     #[inline(always)]\n     fn quot(&self, other: &T) -> T { *self / *other }\n }\n@@ -205,6 +223,27 @@ impl Modulo<T,T> for T {\n #[cfg(stage2,notest)]\n #[cfg(stage3,notest)]\n impl Rem<T,T> for T {\n+    /**\n+     * Returns the integer remainder after division, satisfying:\n+     *\n+     * ~~~\n+     * assert!((n / d) * d + (n % d) == n)\n+     * ~~~\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!( 8 %  3 ==  2);\n+     * assert!( 8 % -3 ==  2);\n+     * assert!(-8 %  3 == -2);\n+     * assert!(-8 % -3 == -2);\n+\n+     * assert!( 1 %  2 ==  1);\n+     * assert!( 1 % -2 ==  1);\n+     * assert!(-1 %  2 == -1);\n+     * assert!(-1 % -2 == -1);\n+     * ~~~\n+     */\n     #[inline(always)]\n     fn rem(&self, other: &T) -> T { *self % *other }\n }\n@@ -247,6 +286,123 @@ impl Signed for T {\n     fn is_negative(&self) -> bool { *self < 0 }\n }\n \n+impl Natural for T {\n+    /**\n+     * Floored integer division\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!(( 8).div( 3) ==  2);\n+     * assert!(( 8).div(-3) == -3);\n+     * assert!((-8).div( 3) == -3);\n+     * assert!((-8).div(-3) ==  2);\n+     *\n+     * assert!(( 1).div( 2) ==  0);\n+     * assert!(( 1).div(-2) == -1);\n+     * assert!((-1).div( 2) == -1);\n+     * assert!((-1).div(-2) ==  0);\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn div(&self, other: T) -> T {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match self.quot_rem(other) {\n+            (q, r) if (r > 0 && other < 0)\n+                   || (r < 0 && other > 0) => q - 1,\n+            (q, _)                         => q,\n+        }\n+    }\n+\n+    /**\n+     * Integer modulo, satisfying:\n+     *\n+     * ~~~\n+     * assert!(n.div(d) * d + n.modulo(d) == n)\n+     * ~~~\n+     *\n+     * # Examples\n+     *\n+     * ~~~\n+     * assert!(( 8).modulo( 3) ==  2);\n+     * assert!(( 8).modulo(-3) == -1);\n+     * assert!((-8).modulo( 3) ==  1);\n+     * assert!((-8).modulo(-3) == -2);\n+     *\n+     * assert!(( 1).modulo( 2) ==  1);\n+     * assert!(( 1).modulo(-2) == -1);\n+     * assert!((-1).modulo( 2) ==  1);\n+     * assert!((-1).modulo(-2) == -1);\n+     * ~~~\n+     */\n+    #[inline(always)]\n+    fn modulo(&self, other: T) -> T {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match *self % other {\n+            r if (r > 0 && other < 0)\n+              || (r < 0 && other > 0) => r + other,\n+            r                         => r,\n+        }\n+    }\n+\n+    /// Calculates `div` and `modulo` simultaneously\n+    #[inline(always)]\n+    fn div_mod(&self, other: T) -> (T,T) {\n+        // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n+        // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n+        match self.quot_rem(other) {\n+            (q, r) if (r > 0 && other < 0)\n+                   || (r < 0 && other > 0) => (q - 1, r + other),\n+            (q, r)                         => (q, r),\n+        }\n+    }\n+\n+    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    #[inline(always)]\n+    fn quot_rem(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: T) -> T {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = other;\n+        while m != 0 {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        n.abs()\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: T) -> T {\n+        ((*self * other) / self.gcd(other)).abs() // should not have to recaluculate abs\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.divisible_by(2) }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -388,6 +544,95 @@ mod tests {\n         assert!((-1 as T).is_negative());\n     }\n \n+    /**\n+     * Checks that the division rule holds for:\n+     *\n+     * - `n`: numerator (dividend)\n+     * - `d`: denominator (divisor)\n+     * - `qr`: quotient and remainder\n+     */\n+    #[cfg(test)]\n+    fn test_division_rule(nd: (T,T), qr: (T,T)) {\n+        let (n,d) = nd,\n+            (q,r) = qr;\n+\n+        assert_eq!(d * q + r, n);\n+    }\n+\n+    #[test]\n+    fn test_quot_rem() {\n+        fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n+            let (n,d) = nd;\n+            let separate_quot_rem = (n / d, n % d);\n+            let combined_quot_rem = n.quot_rem(d);\n+\n+            assert_eq!(separate_quot_rem, qr);\n+            assert_eq!(combined_quot_rem, qr);\n+\n+            test_division_rule(nd, separate_quot_rem);\n+            test_division_rule(nd, combined_quot_rem);\n+        }\n+\n+        test_nd_qr(( 8,  3), ( 2,  2));\n+        test_nd_qr(( 8, -3), (-2,  2));\n+        test_nd_qr((-8,  3), (-2, -2));\n+        test_nd_qr((-8, -3), ( 2, -2));\n+\n+        test_nd_qr(( 1,  2), ( 0,  1));\n+        test_nd_qr(( 1, -2), ( 0,  1));\n+        test_nd_qr((-1,  2), ( 0, -1));\n+        test_nd_qr((-1, -2), ( 0, -1));\n+    }\n+\n+    #[test]\n+    fn test_div_mod() {\n+        fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n+            let (n,d) = nd;\n+            let separate_div_mod = (n.div(d), n.modulo(d));\n+            let combined_div_mod = n.div_mod(d);\n+\n+            assert_eq!(separate_div_mod, dm);\n+            assert_eq!(combined_div_mod, dm);\n+\n+            test_division_rule(nd, separate_div_mod);\n+            test_division_rule(nd, combined_div_mod);\n+        }\n+\n+        test_nd_dm(( 8,  3), ( 2,  2));\n+        test_nd_dm(( 8, -3), (-3, -1));\n+        test_nd_dm((-8,  3), (-3,  1));\n+        test_nd_dm((-8, -3), ( 2, -2));\n+\n+        test_nd_dm(( 1,  2), ( 0,  1));\n+        test_nd_dm(( 1, -2), (-1, -1));\n+        test_nd_dm((-1,  2), (-1,  1));\n+        test_nd_dm((-1, -2), ( 0, -1));\n+    }\n+\n+    #[test]\n+    fn test_gcd() {\n+        assert_eq!((10 as T).gcd(2), 2 as T);\n+        assert_eq!((10 as T).gcd(3), 1 as T);\n+        assert_eq!((0 as T).gcd(3), 3 as T);\n+        assert_eq!((3 as T).gcd(3), 3 as T);\n+        assert_eq!((56 as T).gcd(42), 14 as T);\n+        assert_eq!((3 as T).gcd(-3), 3 as T);\n+        assert_eq!((-6 as T).gcd(3), 3 as T);\n+        assert_eq!((-4 as T).gcd(-2), 2 as T);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        assert_eq!((1 as T).lcm(0), 0 as T);\n+        assert_eq!((0 as T).lcm(1), 0 as T);\n+        assert_eq!((1 as T).lcm(1), 1 as T);\n+        assert_eq!((-1 as T).lcm(1), 1 as T);\n+        assert_eq!((1 as T).lcm(-1), 1 as T);\n+        assert_eq!((-1 as T).lcm(-1), 1 as T);\n+        assert_eq!((8 as T).lcm(9), 72 as T);\n+        assert_eq!((11 as T).lcm(5), 55 as T);\n+    }\n+\n     #[test]\n     fn test_bitwise_ops() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "577bb3f0f150addf831af748a35fd9a5cbe334ec", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "patch": "@@ -75,6 +75,22 @@ pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n     if v < Zero::zero() { v.neg() } else { v }\n }\n \n+pub trait Natural: Num\n+                 + Ord\n+                 + Quot<Self,Self>\n+                 + Rem<Self,Self> {\n+    fn div(&self, other: Self) -> Self;\n+    fn modulo(&self, other: Self) -> Self;\n+    fn div_mod(&self, other: Self) -> (Self,Self);\n+    fn quot_rem(&self, other: Self) -> (Self,Self);\n+\n+    fn gcd(&self, other: Self) -> Self;\n+    fn lcm(&self, other: Self) -> Self;\n+    fn divisible_by(&self, other: Self) -> bool;\n+    fn is_even(&self) -> bool;\n+    fn is_odd(&self) -> bool;\n+}\n+\n pub trait Round {\n     fn round(&self, mode: RoundMode) -> Self;\n "}, {"sha": "a0da84a8c535980874a6c67c0d6d24810e8c267b", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "patch": "@@ -184,6 +184,59 @@ impl Neg<T> for T {\n \n impl Unsigned for T {}\n \n+impl Natural for T {\n+    /// Unsigned integer division. Returns the same result as `quot` (`/`).\n+    #[inline(always)]\n+    fn div(&self, other: T) -> T { *self / other }\n+\n+    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+    #[inline(always)]\n+    fn modulo(&self, other: T) -> T { *self / other }\n+\n+    /// Calculates `div` and `modulo` simultaneously\n+    #[inline(always)]\n+    fn div_mod(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    #[inline(always)]\n+    fn quot_rem(&self, other: T) -> (T,T) {\n+        (*self / other, *self % other)\n+    }\n+\n+    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+    #[inline(always)]\n+    fn gcd(&self, other: T) -> T {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = other;\n+        while m != 0 {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        n\n+    }\n+\n+    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+    #[inline(always)]\n+    fn lcm(&self, other: T) -> T {\n+        (*self * other) / self.gcd(other)\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: T) -> bool { *self % other == 0 }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.divisible_by(2) }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n #[cfg(notest)]\n impl BitOr<T,T> for T {\n     #[inline(always)]\n@@ -303,6 +356,25 @@ mod tests {\n     use super::inst::T;\n     use prelude::*;\n \n+    #[test]\n+    fn test_gcd() {\n+        assert_eq!((10 as T).gcd(2), 2 as T);\n+        assert_eq!((10 as T).gcd(3), 1 as T);\n+        assert_eq!((0 as T).gcd(3), 3 as T);\n+        assert_eq!((3 as T).gcd(3), 3 as T);\n+        assert_eq!((56 as T).gcd(42), 14 as T);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        assert_eq!((1 as T).lcm(0), 0 as T);\n+        assert_eq!((0 as T).lcm(1), 0 as T);\n+        assert_eq!((1 as T).lcm(1), 1 as T);\n+        assert_eq!((8 as T).lcm(9), 72 as T);\n+        assert_eq!((11 as T).lcm(5), 55 as T);\n+        assert_eq!((99 as T).lcm(17), 1683 as T);\n+    }\n+\n     #[test]\n     fn test_bitwise_ops() {\n         assert_eq!(0b1110 as T, (0b1100 as T).bitor(&(0b1010 as T)));"}, {"sha": "03e6065a85caa84b258cc9f57ea580d6ce640854", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f39152e07baf03fc1ff4c8b2c1678ac857b4a512/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=f39152e07baf03fc1ff4c8b2c1678ac857b4a512", "patch": "@@ -39,7 +39,7 @@ pub use hash::Hash;\n pub use iter::{BaseIter, ReverseIter, MutableIter, ExtendedIter, EqIter};\n pub use iter::{CopyableIter, CopyableOrderedIter, CopyableNonstrictIter};\n pub use iter::{Times, ExtendedMutableIter};\n-pub use num::{Num, Signed, Unsigned, NumCast};\n+pub use num::{Num, Signed, Unsigned, Natural, NumCast};\n pub use path::GenericPath;\n pub use path::Path;\n pub use path::PosixPath;"}]}