{"sha": "817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "node_id": "C_kwDOAAsO6NoAKDgxN2Y0NmJjNmMzNmU1NzU0ZWFmN2YyYWU0YThlOTZhMTk5MDI5MWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T09:21:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T09:21:13Z"}, "message": "Auto merge of #12580 - Veykril:completion, r=Veykril\n\ninternal: Move more things out of `CompletionContext::function_def` into more specific parts", "tree": {"sha": "67caaabd449fb4cf692cca9348d61e4a4b0d6226", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67caaabd449fb4cf692cca9348d61e4a4b0d6226"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "html_url": "https://github.com/rust-lang/rust/commit/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a87f810ca513bc3b1a915934d2ff2f81495e7d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a87f810ca513bc3b1a915934d2ff2f81495e7d9", "html_url": "https://github.com/rust-lang/rust/commit/7a87f810ca513bc3b1a915934d2ff2f81495e7d9"}, {"sha": "f271b18129f2faa93e0e1ac0de08062e5fd975a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f271b18129f2faa93e0e1ac0de08062e5fd975a1", "html_url": "https://github.com/rust-lang/rust/commit/f271b18129f2faa93e0e1ac0de08062e5fd975a1"}], "stats": {"total": 338, "additions": 226, "deletions": 112}, "files": [{"sha": "284372f7fc516025ae1f2bb8b28377a4d351570b", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -24,6 +24,7 @@ use std::iter;\n \n use hir::{db::HirDatabase, known, ScopeDef};\n use ide_db::SymbolKind;\n+use syntax::ast;\n \n use crate::{\n     context::Visible,\n@@ -110,12 +111,18 @@ impl Completions {\n         [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));\n     }\n \n-    pub(crate) fn add_keyword_snippet(&mut self, ctx: &CompletionContext, kw: &str, snippet: &str) {\n+    pub(crate) fn add_keyword_snippet_expr(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        kw: &str,\n+        snippet: &str,\n+        incomplete_let: bool,\n+    ) {\n         let mut item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw);\n \n         match ctx.config.snippet_cap {\n             Some(cap) => {\n-                if snippet.ends_with('}') && ctx.incomplete_let {\n+                if snippet.ends_with('}') && incomplete_let {\n                     // complete block expression snippets with a trailing semicolon, if inside an incomplete let\n                     cov_mark::hit!(let_semi);\n                     item.insert_snippet(cap, format!(\"{};\", snippet));\n@@ -130,6 +137,16 @@ impl Completions {\n         item.add_to(self);\n     }\n \n+    pub(crate) fn add_keyword_snippet(&mut self, ctx: &CompletionContext, kw: &str, snippet: &str) {\n+        let mut item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), kw);\n+\n+        match ctx.config.snippet_cap {\n+            Some(cap) => item.insert_snippet(cap, snippet),\n+            None => item.insert_text(if snippet.contains('$') { kw } else { snippet }),\n+        };\n+        item.add_to(self);\n+    }\n+\n     pub(crate) fn add_crate_roots(&mut self, ctx: &CompletionContext) {\n         ctx.process_all_names(&mut |name, res| match res {\n             ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n@@ -393,11 +410,12 @@ fn enum_variants_with_paths(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n     enum_: hir::Enum,\n+    impl_: &Option<ast::Impl>,\n     cb: impl Fn(&mut Completions, &CompletionContext, hir::Variant, hir::ModPath),\n ) {\n     let variants = enum_.variants(ctx.db);\n \n-    if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n+    if let Some(impl_) = impl_.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n         if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_)) {\n             for &variant in &variants {\n                 let self_path = hir::ModPath::from_segments("}, {"sha": "da26c2ad68241533dd45e8f193a940245d45682a", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -46,27 +46,26 @@ pub(crate) fn complete_undotted_self(\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    match path_ctx {\n-        PathCompletionCtx { qualified: Qualified::No, kind: PathKind::Expr { .. }, .. }\n-            if path_ctx.is_trivial_path() && ctx.qualifier_ctx.none() => {}\n+    let self_param = match path_ctx {\n+        PathCompletionCtx {\n+            qualified: Qualified::No,\n+            kind: PathKind::Expr { self_param: Some(self_param), .. },\n+            ..\n+        } if path_ctx.is_trivial_path() && ctx.qualifier_ctx.none() => self_param,\n         _ => return,\n-    }\n+    };\n \n-    if let Some(func) = ctx.function_def.as_ref().and_then(|fn_| ctx.sema.to_def(fn_)) {\n-        if let Some(self_) = func.self_param(ctx.db) {\n-            let ty = self_.ty(ctx.db);\n-            complete_fields(\n-                acc,\n-                ctx,\n-                &ty,\n-                |acc, field, ty| acc.add_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n-                |acc, field, ty| acc.add_tuple_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n-            );\n-            complete_methods(ctx, &ty, |func| {\n-                acc.add_method(ctx, func, Some(hir::known::SELF_PARAM), None)\n-            });\n-        }\n-    }\n+    let ty = self_param.ty(ctx.db);\n+    complete_fields(\n+        acc,\n+        ctx,\n+        &ty,\n+        |acc, field, ty| acc.add_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n+        |acc, field, ty| acc.add_tuple_field(ctx, Some(hir::known::SELF_PARAM), field, &ty),\n+    );\n+    complete_methods(ctx, &ty, |func| {\n+        acc.add_method(ctx, func, Some(hir::known::SELF_PARAM), None)\n+    });\n }\n \n fn complete_fields("}, {"sha": "83ecb51aaabd34139c373d97e159fd7e02484b38", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -14,7 +14,9 @@ pub(crate) fn complete_expr_path(\n     path_ctx: &PathCompletionCtx,\n ) {\n     let _p = profile::span(\"complete_expr_path\");\n-\n+    if !ctx.qualifier_ctx.none() {\n+        return;\n+    }\n     let (\n         qualified,\n         in_block_expr,\n@@ -23,6 +25,9 @@ pub(crate) fn complete_expr_path(\n         after_if_expr,\n         wants_mut_token,\n         in_condition,\n+        ty,\n+        incomplete_let,\n+        impl_,\n     ) = match path_ctx {\n         &PathCompletionCtx {\n             kind:\n@@ -31,19 +36,26 @@ pub(crate) fn complete_expr_path(\n                     in_loop_body,\n                     after_if_expr,\n                     in_condition,\n+                    incomplete_let,\n                     ref ref_expr_parent,\n                     ref is_func_update,\n+                    ref innermost_ret_ty,\n+                    ref impl_,\n+                    ..\n                 },\n             ref qualified,\n             ..\n-        } if ctx.qualifier_ctx.none() => (\n+        } => (\n             qualified,\n             in_block_expr,\n             in_loop_body,\n             is_func_update.is_some(),\n             after_if_expr,\n             ref_expr_parent.as_ref().map(|it| it.mut_token().is_none()).unwrap_or(false),\n             in_condition,\n+            innermost_ret_ty,\n+            incomplete_let,\n+            impl_,\n         ),\n         _ => return,\n     };\n@@ -172,8 +184,7 @@ pub(crate) fn complete_expr_path(\n             if let Some(adt) =\n                 ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n             {\n-                let self_ty =\n-                    (|| ctx.sema.to_def(ctx.impl_def.as_ref()?)?.self_ty(ctx.db).as_adt())();\n+                let self_ty = (|| ctx.sema.to_def(impl_.as_ref()?)?.self_ty(ctx.db).as_adt())();\n                 let complete_self = self_ty == Some(adt);\n \n                 match adt {\n@@ -201,9 +212,15 @@ pub(crate) fn complete_expr_path(\n                         }\n                     }\n                     hir::Adt::Enum(e) => {\n-                        super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                            acc.add_qualified_enum_variant(ctx, variant, path)\n-                        });\n+                        super::enum_variants_with_paths(\n+                            acc,\n+                            ctx,\n+                            e,\n+                            impl_,\n+                            |acc, ctx, variant, path| {\n+                                acc.add_qualified_enum_variant(ctx, variant, path)\n+                            },\n+                        );\n                     }\n                 }\n             }\n@@ -214,7 +231,8 @@ pub(crate) fn complete_expr_path(\n             });\n \n             if !is_func_update {\n-                let mut add_keyword = |kw, snippet| acc.add_keyword_snippet(ctx, kw, snippet);\n+                let mut add_keyword =\n+                    |kw, snippet| acc.add_keyword_snippet_expr(ctx, kw, snippet, incomplete_let);\n \n                 if !in_block_expr {\n                     add_keyword(\"unsafe\", \"unsafe {\\n    $0\\n}\");\n@@ -252,10 +270,10 @@ pub(crate) fn complete_expr_path(\n                     }\n                 }\n \n-                if let Some(fn_def) = &ctx.function_def {\n+                if let Some(ty) = ty {\n                     add_keyword(\n                         \"return\",\n-                        match (in_block_expr, fn_def.ret_type().is_some()) {\n+                        match (in_block_expr, ty.is_unit()) {\n                             (true, true) => \"return ;\",\n                             (true, false) => \"return;\",\n                             (false, true) => \"return $0\","}, {"sha": "94e2f489f57fa3b260685062d57f229a67b0ff30", "filename": "crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -24,8 +24,8 @@ pub(crate) fn complete_fn_param(\n     ctx: &CompletionContext,\n     pattern_ctx: &PatternContext,\n ) -> Option<()> {\n-    let (param_list, _, param_kind) = match pattern_ctx {\n-        PatternContext { param_ctx: Some(kind), .. } => kind,\n+    let ((param_list, _, param_kind), impl_) = match pattern_ctx {\n+        PatternContext { param_ctx: Some(kind), impl_, .. } => (kind, impl_),\n         _ => return None,\n     };\n \n@@ -45,7 +45,7 @@ pub(crate) fn complete_fn_param(\n \n     match param_kind {\n         ParamKind::Function(function) => {\n-            fill_fn_params(ctx, function, param_list, add_new_item_to_acc);\n+            fill_fn_params(ctx, function, param_list, impl_, add_new_item_to_acc);\n         }\n         ParamKind::Closure(closure) => {\n             let stmt_list = closure.syntax().ancestors().find_map(ast::StmtList::cast)?;\n@@ -62,6 +62,7 @@ fn fill_fn_params(\n     ctx: &CompletionContext,\n     function: &ast::Fn,\n     param_list: &ast::ParamList,\n+    impl_: &Option<ast::Impl>,\n     mut add_new_item_to_acc: impl FnMut(&str),\n ) {\n     let mut file_params = FxHashMap::default();\n@@ -104,7 +105,7 @@ fn fill_fn_params(\n     }\n     remove_duplicated(&mut file_params, param_list.params());\n     let self_completion_items = [\"self\", \"&self\", \"mut self\", \"&mut self\"];\n-    if should_add_self_completions(ctx, param_list) {\n+    if should_add_self_completions(param_list, impl_) {\n         self_completion_items.into_iter().for_each(|self_item| add_new_item_to_acc(self_item));\n     }\n \n@@ -155,11 +156,10 @@ fn remove_duplicated(\n     })\n }\n \n-fn should_add_self_completions(ctx: &CompletionContext, param_list: &ast::ParamList) -> bool {\n-    let inside_impl = ctx.impl_def.is_some();\n+fn should_add_self_completions(param_list: &ast::ParamList, impl_: &Option<ast::Impl>) -> bool {\n     let no_params = param_list.params().next().is_none() && param_list.self_param().is_none();\n \n-    inside_impl && no_params\n+    impl_.is_some() && no_params\n }\n \n fn comma_wrapper(ctx: &CompletionContext) -> Option<(impl Fn(&str) -> String, TextRange)> {"}, {"sha": "941273fa971c10767d6ce0f2453c8c30fd17deb5", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -66,7 +66,7 @@ fn add_keywords(acc: &mut Completions, ctx: &CompletionContext, kind: Option<&It\n     let in_assoc_non_trait_impl = matches!(kind, Some(ItemListKind::Impl | ItemListKind::Trait));\n     let in_extern_block = matches!(kind, Some(ItemListKind::ExternBlock));\n     let in_trait = matches!(kind, Some(ItemListKind::Trait));\n-    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl));\n+    let in_trait_impl = matches!(kind, Some(ItemListKind::TraitImpl(_)));\n     let in_inherent_impl = matches!(kind, Some(ItemListKind::Impl));\n     let no_qualifiers = ctx.qualifier_ctx.vis_node.is_none();\n     let in_block = matches!(kind, None);"}, {"sha": "58b894bdd4320ea0b7159712716c9837416082bc", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -81,7 +81,7 @@ pub(crate) fn complete_trait_impl_name(\n         kind,\n         replacement_range(ctx, &item),\n         // item -> ASSOC_ITEM_LIST -> IMPL\n-        ast::Impl::cast(item.parent()?.parent()?)?,\n+        &ast::Impl::cast(item.parent()?.parent()?)?,\n     );\n     Some(())\n }\n@@ -97,7 +97,7 @@ pub(crate) fn complete_trait_impl_name_ref(\n             kind:\n                 NameRefKind::Path(\n                     path_ctx @ PathCompletionCtx {\n-                        kind: PathKind::Item { kind: ItemListKind::TraitImpl },\n+                        kind: PathKind::Item { kind: ItemListKind::TraitImpl(Some(impl_)) },\n                         ..\n                     },\n                 ),\n@@ -109,7 +109,7 @@ pub(crate) fn complete_trait_impl_name_ref(\n                 Some(name) => name.syntax().text_range(),\n                 None => ctx.source_range(),\n             },\n-            ctx.impl_def.clone()?,\n+            impl_,\n         ),\n         _ => (),\n     }\n@@ -121,10 +121,10 @@ fn complete_trait_impl(\n     ctx: &CompletionContext,\n     kind: ImplCompletionKind,\n     replacement_range: TextRange,\n-    impl_def: ast::Impl,\n+    impl_def: &ast::Impl,\n ) {\n-    if let Some(hir_impl) = ctx.sema.to_def(&impl_def) {\n-        get_missing_assoc_items(&ctx.sema, &impl_def).into_iter().for_each(|item| {\n+    if let Some(hir_impl) = ctx.sema.to_def(impl_def) {\n+        get_missing_assoc_items(&ctx.sema, impl_def).into_iter().for_each(|item| {\n             use self::ImplCompletionKind::*;\n             match (item, kind) {\n                 (hir::AssocItem::Function(func), All | Fn) => {"}, {"sha": "149acb3c1becadeb4301aa82d1911b7cf5720e42", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -51,9 +51,15 @@ pub(crate) fn complete_pattern(\n         ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n     {\n         if refutable || single_variant_enum(e) {\n-            super::enum_variants_with_paths(acc, ctx, e, |acc, ctx, variant, path| {\n-                acc.add_qualified_variant_pat(ctx, variant, path);\n-            });\n+            super::enum_variants_with_paths(\n+                acc,\n+                ctx,\n+                e,\n+                &patctx.impl_,\n+                |acc, ctx, variant, path| {\n+                    acc.add_qualified_variant_pat(ctx, variant, path);\n+                },\n+            );\n         }\n     }\n "}, {"sha": "0c7c6ab5af6cd4203d03e64e4cd5bf4a8121ae03", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -93,8 +93,12 @@ pub(super) enum PathKind {\n         after_if_expr: bool,\n         /// Whether this expression is the direct condition of an if or while expression\n         in_condition: bool,\n+        incomplete_let: bool,\n         ref_expr_parent: Option<ast::RefExpr>,\n         is_func_update: Option<ast::RecordExpr>,\n+        self_param: Option<hir::SelfParam>,\n+        innermost_ret_ty: Option<hir::Type>,\n+        impl_: Option<ast::Impl>,\n     },\n     Type {\n         location: TypeLocation,\n@@ -140,12 +144,12 @@ pub(crate) enum TypeAscriptionTarget {\n }\n \n /// The kind of item list a [`PathKind::Item`] belongs to.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub(super) enum ItemListKind {\n     SourceFile,\n     Module,\n     Impl,\n-    TraitImpl,\n+    TraitImpl(Option<ast::Impl>),\n     Trait,\n     ExternBlock,\n }\n@@ -176,6 +180,7 @@ pub(super) struct PatternContext {\n     pub(super) mut_token: Option<SyntaxToken>,\n     /// The record pattern this name or ref is a field of\n     pub(super) record_pat: Option<ast::RecordPat>,\n+    pub(super) impl_: Option<ast::Impl>,\n }\n \n /// The state of the lifetime we are completing.\n@@ -317,16 +322,6 @@ pub(crate) struct CompletionContext<'a> {\n     /// The expected type of what we are completing.\n     pub(super) expected_type: Option<Type>,\n \n-    /// The parent function of the cursor position if it exists.\n-    // FIXME: This probably doesn't belong here\n-    pub(super) function_def: Option<ast::Fn>,\n-    /// The parent impl of the cursor position if it exists.\n-    // FIXME: This probably doesn't belong here\n-    pub(super) impl_def: Option<ast::Impl>,\n-    /// Are we completing inside a let statement with a missing semicolon?\n-    // FIXME: This should be part of PathKind::Expr\n-    pub(super) incomplete_let: bool,\n-\n     // FIXME: This shouldn't exist\n     pub(super) previous_token: Option<SyntaxToken>,\n \n@@ -500,9 +495,6 @@ impl<'a> CompletionContext<'a> {\n             module,\n             expected_name: None,\n             expected_type: None,\n-            function_def: None,\n-            impl_def: None,\n-            incomplete_let: false,\n             previous_token: None,\n             // dummy value, will be overwritten\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },"}, {"sha": "9ceb60f90f1666329c2a3ec6f3edc487b3db1f2e", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 129, "deletions": 48, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817f46bc6c36e5754eaf7f2ae4a8e96a1990291e/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=817f46bc6c36e5754eaf7f2ae4a8e96a1990291e", "patch": "@@ -330,11 +330,6 @@ impl<'a> CompletionContext<'a> {\n         self.previous_token =\n             syntax_element.clone().into_token().and_then(previous_non_trivia_token);\n \n-        self.incomplete_let =\n-            syntax_element.ancestors().take(6).find_map(ast::LetStmt::cast).map_or(false, |it| {\n-                it.syntax().text_range().end() == syntax_element.text_range().end()\n-            });\n-\n         (self.expected_type, self.expected_name) = self.expected_type_and_name();\n \n         // Overwrite the path kind for derives\n@@ -394,28 +389,6 @@ impl<'a> CompletionContext<'a> {\n                 return Some(());\n             }\n         };\n-        self.impl_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| it.kind() != SyntaxKind::SOURCE_FILE)\n-            .filter_map(ast::Item::cast)\n-            .take(2)\n-            .find_map(|it| match it {\n-                ast::Item::Impl(impl_) => Some(impl_),\n-                _ => None,\n-            });\n-        self.function_def = self\n-            .sema\n-            .token_ancestors_with_macros(self.token.clone())\n-            .take_while(|it| {\n-                it.kind() != SyntaxKind::SOURCE_FILE && it.kind() != SyntaxKind::MODULE\n-            })\n-            .filter_map(ast::Item::cast)\n-            .take(2)\n-            .find_map(|it| match it {\n-                ast::Item::Fn(fn_) => Some(fn_),\n-                _ => None,\n-            });\n \n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n@@ -469,7 +442,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name(\n-        _sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name: ast::Name,\n     ) -> Option<NameContext> {\n@@ -481,9 +454,9 @@ impl<'a> CompletionContext<'a> {\n                 ast::Enum(_) => NameKind::Enum,\n                 ast::Fn(_) => NameKind::Function,\n                 ast::IdentPat(bind_pat) => {\n-                    let mut pat_ctx = pattern_context_for(original_file, bind_pat.into());\n+                    let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n                     if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n-                        pat_ctx.record_pat = find_node_in_file_compensated(original_file, &record_field.parent_record_pat());\n+                        pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n                     }\n \n                     NameKind::IdentPat(pat_ctx)\n@@ -520,9 +493,13 @@ impl<'a> CompletionContext<'a> {\n             |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            return find_node_in_file_compensated(original_file, &record_field.parent_record_lit())\n-                .map(NameRefKind::RecordExpr)\n-                .map(make_res);\n+            return find_node_in_file_compensated(\n+                sema,\n+                original_file,\n+                &record_field.parent_record_lit(),\n+            )\n+            .map(NameRefKind::RecordExpr)\n+            .map(make_res);\n         }\n         if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n             let kind = NameRefKind::Pattern(PatternContext {\n@@ -531,10 +508,12 @@ impl<'a> CompletionContext<'a> {\n                 ref_token: None,\n                 mut_token: None,\n                 record_pat: find_node_in_file_compensated(\n+                    sema,\n                     original_file,\n                     &record_field.parent_record_pat(),\n                 ),\n                 ..pattern_context_for(\n+                    sema,\n                     original_file,\n                     record_field.parent_record_pat().clone().into(),\n                 )\n@@ -594,7 +573,7 @@ impl<'a> CompletionContext<'a> {\n         };\n         let func_update_record = |syn: &SyntaxNode| {\n             if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                find_node_in_file_compensated(original_file, &record_expr)\n+                find_node_in_file_compensated(sema, original_file, &record_expr)\n             } else {\n                 None\n             }\n@@ -696,9 +675,9 @@ impl<'a> CompletionContext<'a> {\n                     ast::TypeBound(_) => TypeLocation::TypeBound,\n                     // is this case needed?\n                     ast::TypeBoundList(_) => TypeLocation::TypeBound,\n-                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n                     // is this case needed?\n-                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(original_file, Some(it))),\n+                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n                     ast::TupleField(_) => TypeLocation::TupleField,\n                     _ => return None,\n                 }\n@@ -727,8 +706,63 @@ impl<'a> CompletionContext<'a> {\n             let after_if_expr = after_if_expr(it.clone());\n             let ref_expr_parent =\n                 path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n+            let (innermost_ret_ty, self_param) = {\n+                let find_ret_ty = |it: SyntaxNode| {\n+                    if let Some(item) = ast::Item::cast(it.clone()) {\n+                        match item {\n+                            ast::Item::Fn(f) => {\n+                                Some(sema.to_def(&f).map(|it| it.ret_type(sema.db)))\n+                            }\n+                            ast::Item::MacroCall(_) => None,\n+                            _ => Some(None),\n+                        }\n+                    } else {\n+                        let expr = ast::Expr::cast(it)?;\n+                        let callable = match expr {\n+                            // FIXME\n+                            // ast::Expr::BlockExpr(b) if b.async_token().is_some() || b.try_token().is_some() => sema.type_of_expr(b),\n+                            ast::Expr::ClosureExpr(_) => sema.type_of_expr(&expr),\n+                            _ => return None,\n+                        };\n+                        Some(\n+                            callable\n+                                .and_then(|c| c.adjusted().as_callable(sema.db))\n+                                .map(|it| it.return_type()),\n+                        )\n+                    }\n+                };\n+                let find_fn_self_param = |it| match it {\n+                    ast::Item::Fn(fn_) => {\n+                        Some(sema.to_def(&fn_).and_then(|it| it.self_param(sema.db)))\n+                    }\n+                    ast::Item::MacroCall(_) => None,\n+                    _ => Some(None),\n+                };\n+\n+                match find_node_in_file_compensated(sema, original_file, &expr) {\n+                    Some(it) => {\n+                        let innermost_ret_ty = sema\n+                            .ancestors_with_macros(it.syntax().clone())\n+                            .find_map(find_ret_ty)\n+                            .flatten();\n+\n+                        let self_param = sema\n+                            .ancestors_with_macros(it.syntax().clone())\n+                            .filter_map(ast::Item::cast)\n+                            .find_map(find_fn_self_param)\n+                            .flatten();\n+                        (innermost_ret_ty, self_param)\n+                    }\n+                    None => (None, None),\n+                }\n+            };\n             let is_func_update = func_update_record(it);\n             let in_condition = is_in_condition(&expr);\n+            let incomplete_let = it\n+                .parent()\n+                .and_then(ast::LetStmt::cast)\n+                .map_or(false, |it| it.semicolon_token().is_none());\n+            let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n \n             PathKind::Expr {\n                 in_block_expr,\n@@ -737,6 +771,10 @@ impl<'a> CompletionContext<'a> {\n                 in_condition,\n                 ref_expr_parent,\n                 is_func_update,\n+                innermost_ret_ty,\n+                self_param,\n+                incomplete_let,\n+                impl_,\n             }\n         };\n         let make_path_kind_type = |ty: ast::Type| {\n@@ -764,14 +802,14 @@ impl<'a> CompletionContext<'a> {\n                     },\n                     ast::TupleStructPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::RecordPat(it) => {\n                         path_ctx.has_call_parens = true;\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::PathPat(it) => {\n-                        PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())}\n+                        PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n                     },\n                     ast::MacroCall(it) => {\n                         // A macro call in this position is usually a result of parsing recovery, so check that\n@@ -785,15 +823,15 @@ impl<'a> CompletionContext<'a> {\n                         match_ast! {\n                             match parent {\n                                 ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(original_file, it.into())},\n+                                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n                                 ast::MacroType(ty) => make_path_kind_type(ty.into()),\n                                 ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n                                 ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n                                     Some(it) => match_ast! {\n                                         match it {\n                                             ast::Trait(_) => ItemListKind::Trait,\n                                             ast::Impl(it) => if it.trait_().is_some() {\n-                                                ItemListKind::TraitImpl\n+                                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n                                             } else {\n                                                 ItemListKind::Impl\n                                             },\n@@ -930,7 +968,11 @@ impl<'a> CompletionContext<'a> {\n     }\n }\n \n-fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternContext {\n+fn pattern_context_for(\n+    sema: &Semantics<RootDatabase>,\n+    original_file: &SyntaxNode,\n+    pat: ast::Pat,\n+) -> PatternContext {\n     let mut is_param = None;\n     let (refutability, has_type_ascription) =\n     pat\n@@ -946,7 +988,7 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n                         let has_type_ascription = param.ty().is_some();\n                         is_param = (|| {\n                             let fake_param_list = param.syntax().parent().and_then(ast::ParamList::cast)?;\n-                            let param_list = find_node_in_file_compensated(original_file, &fake_param_list)?;\n+                            let param_list = find_node_in_file_compensated(sema, original_file, &fake_param_list)?;\n                             let param_list_owner = param_list.syntax().parent()?;\n                             let kind = match_ast! {\n                                 match param_list_owner {\n@@ -971,6 +1013,7 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n         ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n         _ => (None, None),\n     };\n+\n     PatternContext {\n         refutability,\n         param_ctx: is_param,\n@@ -979,6 +1022,27 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n         mut_token,\n         ref_token,\n         record_pat: None,\n+        impl_: fetch_immediate_impl(sema, original_file, pat.syntax()),\n+    }\n+}\n+\n+fn fetch_immediate_impl(\n+    sema: &Semantics<RootDatabase>,\n+    original_file: &SyntaxNode,\n+    node: &SyntaxNode,\n+) -> Option<ast::Impl> {\n+    let mut ancestors = ancestors_in_file_compensated(sema, original_file, node)?\n+        .filter_map(ast::Item::cast)\n+        .filter(|it| !matches!(it, ast::Item::MacroCall(_)));\n+\n+    match ancestors.next()? {\n+        ast::Item::Const(_) | ast::Item::Fn(_) | ast::Item::TypeAlias(_) => (),\n+        ast::Item::Impl(it) => return Some(it),\n+        _ => return None,\n+    }\n+    match ancestors.next()? {\n+        ast::Item::Impl(it) => Some(it),\n+        _ => None,\n     }\n }\n \n@@ -1000,27 +1064,44 @@ fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n /// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n /// for the offset introduced by the fake ident.\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n-fn find_node_in_file_compensated<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n-    let syntax_range = syntax.text_range();\n-    let range = node.syntax().text_range();\n+fn find_node_in_file_compensated<N: AstNode>(\n+    sema: &Semantics<RootDatabase>,\n+    in_file: &SyntaxNode,\n+    node: &N,\n+) -> Option<N> {\n+    ancestors_in_file_compensated(sema, in_file, node.syntax())?.find_map(N::cast)\n+}\n+\n+fn ancestors_in_file_compensated<'sema>(\n+    sema: &'sema Semantics<RootDatabase>,\n+    in_file: &SyntaxNode,\n+    node: &SyntaxNode,\n+) -> Option<impl Iterator<Item = SyntaxNode> + 'sema> {\n+    let syntax_range = in_file.text_range();\n+    let range = node.text_range();\n     let end = range.end().checked_sub(TextSize::try_from(COMPLETION_MARKER.len()).ok()?)?;\n     if end < range.start() {\n         return None;\n     }\n     let range = TextRange::new(range.start(), end);\n     // our inserted ident could cause `range` to go outside of the original syntax, so cap it\n     let intersection = range.intersect(syntax_range)?;\n-    syntax.covering_element(intersection).ancestors().find_map(N::cast)\n+    let node = match in_file.covering_element(intersection) {\n+        NodeOrToken::Node(node) => node,\n+        NodeOrToken::Token(tok) => tok.parent()?,\n+    };\n+    Some(sema.ancestors_with_macros(node))\n }\n \n /// Attempts to find `node` inside `syntax` via `node`'s text range while compensating\n /// for the offset introduced by the fake ident..\n /// This is wrong if `node` comes before the insertion point! Use `find_node_in_file` instead.\n fn find_opt_node_in_file_compensated<N: AstNode>(\n+    sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     node: Option<N>,\n ) -> Option<N> {\n-    find_node_in_file_compensated(syntax, &node?)\n+    find_node_in_file_compensated(sema, syntax, &node?)\n }\n \n fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {"}]}