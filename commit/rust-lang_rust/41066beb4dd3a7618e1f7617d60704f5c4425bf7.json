{"sha": "41066beb4dd3a7618e1f7617d60704f5c4425bf7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMDY2YmViNGRkM2E3NjE4ZTFmNzYxN2Q2MDcwNGY1YzQ0MjViZjc=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T16:17:16Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T16:20:07Z"}, "message": "Get rid of UnsafeCell in cloudabi rwlock.", "tree": {"sha": "dd04c6987557913b00d0b28f9e946d0473905b31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd04c6987557913b00d0b28f9e946d0473905b31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41066beb4dd3a7618e1f7617d60704f5c4425bf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41066beb4dd3a7618e1f7617d60704f5c4425bf7", "html_url": "https://github.com/rust-lang/rust/commit/41066beb4dd3a7618e1f7617d60704f5c4425bf7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41066beb4dd3a7618e1f7617d60704f5c4425bf7/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f26578f2e2e41c51279f3b2bd967785241d316d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f26578f2e2e41c51279f3b2bd967785241d316d", "html_url": "https://github.com/rust-lang/rust/commit/0f26578f2e2e41c51279f3b2bd967785241d316d"}], "stats": {"total": 45, "additions": 21, "deletions": 24}, "files": [{"sha": "8306819423db666ff686af072de64f1ff0eb498d", "filename": "library/std/src/sys/cloudabi/rwlock.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/41066beb4dd3a7618e1f7617d60704f5c4425bf7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41066beb4dd3a7618e1f7617d60704f5c4425bf7/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Frwlock.rs?ref=41066beb4dd3a7618e1f7617d60704f5c4425bf7", "patch": "@@ -1,4 +1,3 @@\n-use crate::cell::UnsafeCell;\n use crate::mem;\n use crate::mem::MaybeUninit;\n use crate::sync::atomic::{AtomicU32, Ordering};\n@@ -13,28 +12,25 @@ extern \"C\" {\n static mut RDLOCKS_ACQUIRED: u32 = 0;\n \n pub struct RWLock {\n-    lock: UnsafeCell<AtomicU32>,\n+    lock: AtomicU32,\n }\n \n pub unsafe fn raw(r: &RWLock) -> *mut AtomicU32 {\n-    r.lock.get()\n+    &r.lock as *const AtomicU32 as *mut AtomicU32\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n-const NEW: RWLock = RWLock { lock: UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)) };\n-\n impl RWLock {\n     pub const fn new() -> RWLock {\n-        NEW\n+        RWLock { lock: AtomicU32::new(abi::LOCK_UNLOCKED.0) }\n     }\n \n     pub unsafe fn try_read(&self) -> bool {\n-        let lock = self.lock.get();\n         let mut old = abi::LOCK_UNLOCKED.0;\n         while let Err(cur) =\n-            (*lock).compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n+            self.lock.compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n         {\n             if (cur & abi::LOCK_WRLOCKED.0) != 0 {\n                 // Another thread already has a write lock.\n@@ -61,12 +57,11 @@ impl RWLock {\n     pub unsafe fn read(&self) {\n         if !self.try_read() {\n             // Call into the kernel to acquire a read lock.\n-            let lock = self.lock.get();\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::LOCK_RDLOCK,\n                 union: abi::subscription_union {\n                     lock: abi::subscription_lock {\n-                        lock: lock as *mut abi::lock,\n+                        lock: &self.lock as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -96,11 +91,10 @@ impl RWLock {\n         assert!(RDLOCKS_ACQUIRED > 0, \"Bad lock count\");\n         let mut old = 1;\n         loop {\n-            let lock = self.lock.get();\n             if old == 1 | abi::LOCK_KERNEL_MANAGED.0 {\n                 // Last read lock while threads are waiting. Attempt to upgrade\n                 // to a write lock before calling into the kernel to unlock.\n-                if let Err(cur) = (*lock).compare_exchange_weak(\n+                if let Err(cur) = self.lock.compare_exchange_weak(\n                     old,\n                     __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 | abi::LOCK_KERNEL_MANAGED.0,\n                     Ordering::Acquire,\n@@ -109,7 +103,10 @@ impl RWLock {\n                     old = cur;\n                 } else {\n                     // Call into the kernel to unlock.\n-                    let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+                    let ret = abi::lock_unlock(\n+                        &self.lock as *const AtomicU32 as *mut abi::lock,\n+                        abi::scope::PRIVATE,\n+                    );\n                     assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n                     break;\n                 }\n@@ -122,7 +119,7 @@ impl RWLock {\n                     0,\n                     \"Attempted to read-unlock a write-locked rwlock\"\n                 );\n-                if let Err(cur) = (*lock).compare_exchange_weak(\n+                if let Err(cur) = self.lock.compare_exchange_weak(\n                     old,\n                     old - 1,\n                     Ordering::Acquire,\n@@ -140,8 +137,7 @@ impl RWLock {\n \n     pub unsafe fn try_write(&self) -> bool {\n         // Attempt to acquire the lock.\n-        let lock = self.lock.get();\n-        if let Err(old) = (*lock).compare_exchange(\n+        if let Err(old) = self.lock.compare_exchange(\n             abi::LOCK_UNLOCKED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             Ordering::Acquire,\n@@ -163,12 +159,11 @@ impl RWLock {\n     pub unsafe fn write(&self) {\n         if !self.try_write() {\n             // Call into the kernel to acquire a write lock.\n-            let lock = self.lock.get();\n             let subscription = abi::subscription {\n                 type_: abi::eventtype::LOCK_WRLOCK,\n                 union: abi::subscription_union {\n                     lock: abi::subscription_lock {\n-                        lock: lock as *mut abi::lock,\n+                        lock: &self.lock as *const AtomicU32 as *mut abi::lock,\n                         lock_scope: abi::scope::PRIVATE,\n                     },\n                 },\n@@ -184,14 +179,14 @@ impl RWLock {\n     }\n \n     pub unsafe fn write_unlock(&self) {\n-        let lock = self.lock.get();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            self.lock.load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n             __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n             \"This rwlock is not write-locked by this thread\"\n         );\n \n-        if !(*lock)\n+        if !self\n+            .lock\n             .compare_exchange(\n                 __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n                 abi::LOCK_UNLOCKED.0,\n@@ -202,15 +197,17 @@ impl RWLock {\n         {\n             // Lock is managed by kernelspace. Call into the kernel\n             // to unblock waiting threads.\n-            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            let ret = abi::lock_unlock(\n+                &self.lock as *const AtomicU32 as *mut abi::lock,\n+                abi::scope::PRIVATE,\n+            );\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n         }\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let lock = self.lock.get();\n         assert_eq!(\n-            (*lock).load(Ordering::Relaxed),\n+            self.lock.load(Ordering::Relaxed),\n             abi::LOCK_UNLOCKED.0,\n             \"Attempted to destroy locked rwlock\"\n         );"}]}