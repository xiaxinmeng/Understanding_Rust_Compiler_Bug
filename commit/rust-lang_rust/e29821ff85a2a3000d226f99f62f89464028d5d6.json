{"sha": "e29821ff85a2a3000d226f99f62f89464028d5d6", "node_id": "C_kwDOAAsO6NoAKGUyOTgyMWZmODVhMmEzMDAwZDIyNmY5OWY2MmY4OTQ2NDAyOGQ1ZDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T08:25:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-31T08:25:28Z"}, "message": "Auto merge of #111623 - BoxyUwU:move_eval_hack, r=compiler-errors\n\nmove `super_relate_consts` hack to `normalize_param_env_or_error`\n\n`super_relate_consts` has as hack in it to work around the fact that `normalize_param_env_or_error` is broken. When relating two constants we attempt to evaluate them (aka normalize them). This is not an issue in any way specific to const generics, type aliases also have the same issue as demonstrated in [this code](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=84b6d3956a2c852a04b60782476b56c9).\n\nSince the hack in `super_relate_consts` only exists to make `normalize_param_env_or_error` emit less errors move it to `normalize_param_env_or_error`. This makes `super_relate_consts` act more like the normal plain structural equality its supposed to and should help ensure that the hack doesnt accidentally affect other situations.\n\nr? `@compiler-errors`", "tree": {"sha": "3b5e7c252534f84ef9b23158de86562dba45cb5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5e7c252534f84ef9b23158de86562dba45cb5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e29821ff85a2a3000d226f99f62f89464028d5d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e29821ff85a2a3000d226f99f62f89464028d5d6", "html_url": "https://github.com/rust-lang/rust/commit/e29821ff85a2a3000d226f99f62f89464028d5d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e29821ff85a2a3000d226f99f62f89464028d5d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "617d3d6d722c432cdcbf210e6db55c3bdeafe381", "url": "https://api.github.com/repos/rust-lang/rust/commits/617d3d6d722c432cdcbf210e6db55c3bdeafe381", "html_url": "https://github.com/rust-lang/rust/commit/617d3d6d722c432cdcbf210e6db55c3bdeafe381"}, {"sha": "21cf9ea7ed5f87c905f1548d1855b02ee61b5aec", "url": "https://api.github.com/repos/rust-lang/rust/commits/21cf9ea7ed5f87c905f1548d1855b02ee61b5aec", "html_url": "https://github.com/rust-lang/rust/commit/21cf9ea7ed5f87c905f1548d1855b02ee61b5aec"}], "stats": {"total": 97, "additions": 81, "deletions": 16}, "files": [{"sha": "8bcae3d9ab7cc7450c2a5d5bed364ed49d671731", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e29821ff85a2a3000d226f99f62f89464028d5d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29821ff85a2a3000d226f99f62f89464028d5d6/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e29821ff85a2a3000d226f99f62f89464028d5d6", "patch": "@@ -589,17 +589,6 @@ pub fn structurally_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     debug!(\"{}.structurally_relate_consts(a = {:?}, b = {:?})\", relation.tag(), a, b);\n     let tcx = relation.tcx();\n \n-    // HACK(const_generics): We still need to eagerly evaluate consts when\n-    // relating them because during `normalize_param_env_or_error`,\n-    // we may relate an evaluated constant in a obligation against\n-    // an unnormalized (i.e. unevaluated) const in the param-env.\n-    // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n-    // these `eval` calls can be removed.\n-    if !tcx.features().generic_const_exprs {\n-        a = a.eval(tcx, relation.param_env());\n-        b = b.eval(tcx, relation.param_env());\n-    }\n-\n     if tcx.features().generic_const_exprs {\n         a = tcx.expand_abstract_consts(a);\n         b = tcx.expand_abstract_consts(b);"}, {"sha": "f7389bda159e5272ffc431e3414c78b481d28577", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e29821ff85a2a3000d226f99f62f89464028d5d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29821ff85a2a3000d226f99f62f89464028d5d6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=e29821ff85a2a3000d226f99f62f89464028d5d6", "patch": "@@ -32,7 +32,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_middle::query::Providers;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFolder, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n@@ -272,8 +272,62 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // parameter environments once for every fn as it goes,\n     // and errors will get reported then; so outside of type inference we\n     // can be sure that no errors should occur.\n-    let mut predicates: Vec<_> =\n-        util::elaborate(tcx, unnormalized_env.caller_bounds().into_iter()).collect();\n+    let mut predicates: Vec<_> = util::elaborate(\n+        tcx,\n+        unnormalized_env.caller_bounds().into_iter().map(|predicate| {\n+            if tcx.features().generic_const_exprs {\n+                return predicate;\n+            }\n+\n+            struct ConstNormalizer<'tcx>(TyCtxt<'tcx>);\n+\n+            impl<'tcx> TypeFolder<TyCtxt<'tcx>> for ConstNormalizer<'tcx> {\n+                fn interner(&self) -> TyCtxt<'tcx> {\n+                    self.0\n+                }\n+\n+                fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+                    // While it is pretty sus to be evaluating things with an empty param env, it\n+                    // should actually be okay since without `feature(generic_const_exprs)` the only\n+                    // const arguments that have a non-empty param env are array repeat counts. These\n+                    // do not appear in the type system though.\n+                    c.eval(self.0, ty::ParamEnv::empty())\n+                }\n+            }\n+\n+            // This whole normalization step is a hack to work around the fact that\n+            // `normalize_param_env_or_error` is fundamentally broken from using an\n+            // unnormalized param env with a trait solver that expects the param env\n+            // to be normalized.\n+            //\n+            // When normalizing the param env we can end up evaluating obligations\n+            // that have been normalized but can only be proven via a where clause\n+            // which is still in its unnormalized form. example:\n+            //\n+            // Attempting to prove `T: Trait<<u8 as Identity>::Assoc>` in a param env\n+            // with a `T: Trait<<u8 as Identity>::Assoc>` where clause will fail because\n+            // we first normalize obligations before proving them so we end up proving\n+            // `T: Trait<u8>`. Since lazy normalization is not implemented equating `u8`\n+            // with `<u8 as Identity>::Assoc` fails outright so we incorrectly believe that\n+            // we cannot prove `T: Trait<u8>`.\n+            //\n+            // The same thing is true for const generics- attempting to prove\n+            // `T: Trait<ConstKind::Unevaluated(...)>` with the same thing as a where clauses\n+            // will fail. After normalization we may be attempting to prove `T: Trait<4>` with\n+            // the unnormalized where clause `T: Trait<ConstKind::Unevaluated(...)>`. In order\n+            // for the obligation to hold `4` must be equal to `ConstKind::Unevaluated(...)`\n+            // but as we do not have lazy norm implemented, equating the two consts fails outright.\n+            //\n+            // Ideally we would not normalize consts here at all but it is required for backwards\n+            // compatibility. Eventually when lazy norm is implemented this can just be removed.\n+            // We do not normalize types here as there is no backwards compatibility requirement\n+            // for us to do so.\n+            //\n+            // FIXME(-Ztrait-solver=next): remove this hack since we have deferred projection equality\n+            predicate.fold_with(&mut ConstNormalizer(tcx))\n+        }),\n+    )\n+    .collect();\n \n     debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n "}, {"sha": "c492d927696bdbbdc2d6e40966077078c3ca614e", "filename": "tests/ui/traits/new-solver/structural-resolve-field.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e29821ff85a2a3000d226f99f62f89464028d5d6/tests%2Fui%2Ftraits%2Fnew-solver%2Fstructural-resolve-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e29821ff85a2a3000d226f99f62f89464028d5d6/tests%2Fui%2Ftraits%2Fnew-solver%2Fstructural-resolve-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fstructural-resolve-field.rs?ref=e29821ff85a2a3000d226f99f62f89464028d5d6", "patch": "@@ -1,13 +1,35 @@\n // compile-flags: -Ztrait-solver=next\n // check-pass\n \n-#[derive(Default)]\n struct Foo {\n     x: i32,\n }\n \n+impl MyDefault for Foo {\n+    fn my_default() -> Self {\n+        Self {\n+            x: 0,\n+        }\n+    }\n+}\n+\n+trait MyDefault {\n+    fn my_default() -> Self;\n+}\n+\n+impl MyDefault for [Foo; 0]  {\n+    fn my_default() -> Self {\n+        []\n+    }\n+}\n+impl MyDefault for [Foo; 1] {\n+    fn my_default() -> Self {\n+        [Foo::my_default(); 1]\n+    }\n+}\n+\n fn main() {\n-    let mut xs = <[Foo; 1]>::default();\n+    let mut xs = <[Foo; 1]>::my_default();\n     xs[0].x = 1;\n     (&mut xs[0]).x = 2;\n }"}]}