{"sha": "02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMTMxZjRkY2QwYzg1ZjZiM2NjN2U4ZDZhNTg0NWE2YmRkMzBmZjU=", "commit": {"author": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-10-29T10:15:54Z"}, "committer": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-04T10:09:10Z"}, "message": "Use packed struct instead of manually packing into an array", "tree": {"sha": "47b692e95cdc33620c4b6431748e020e3b00ddb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47b692e95cdc33620c4b6431748e020e3b00ddb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "html_url": "https://github.com/rust-lang/rust/commit/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed7a4adeb326c9957b4a2514a69cbae4276ab028", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed7a4adeb326c9957b4a2514a69cbae4276ab028", "html_url": "https://github.com/rust-lang/rust/commit/ed7a4adeb326c9957b4a2514a69cbae4276ab028"}], "stats": {"total": 79, "additions": 41, "deletions": 38}, "files": [{"sha": "6b8e9edc13ccf0ed23b922cb964848f212071584", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "patch": "@@ -2,7 +2,6 @@ use crate::mir::interpret::{sign_extend, truncate, InterpErrorInfo, InterpResult\n use crate::throw_ub;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n-use rustc_macros::HashStable;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_target::abi::{Size, TargetDataLayout};\n use std::convert::{TryFrom, TryInto};\n@@ -29,7 +28,7 @@ impl std::fmt::Debug for ConstInt {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         let Self { int, signed, is_ptr_sized_integral } = *self;\n         let size = int.size().bytes();\n-        let raw = int.data();\n+        let raw = int.data;\n         if signed {\n             let bit_size = size * 8;\n             let min = 1u128 << (bit_size - 1);\n@@ -116,41 +115,46 @@ impl std::fmt::Debug for ConstInt {\n \n // FIXME: reuse in `super::int::ConstInt` and `Scalar::Bits`\n /// The raw bytes of a simple value.\n+///\n+/// This is a packed struct in order to allow this type to be optimally embedded in enums\n+/// (like Scalar).\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n-#[derive(HashStable)]\n+#[repr(packed)]\n pub struct ScalarInt {\n     /// The first `size` bytes of `data` are the value.\n     /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n-    ///\n-    /// This is an array in order to allow this type to be optimally embedded in enums\n-    /// (like Scalar).\n-    bytes: [u8; 16],\n+    data: u128,\n     size: u8,\n }\n \n+// Cannot derive these, as the derives take references to the fields, and we\n+// can't take references to fields of packed structs.\n+impl<CTX> crate::ty::HashStable<CTX> for ScalarInt {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut crate::ty::StableHasher) {\n+        { self.data }.hash_stable(hcx, hasher);\n+        self.size.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<S: Encoder> Encodable<S> for ScalarInt {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u128(self.data())?;\n+        s.emit_u128(self.data)?;\n         s.emit_u8(self.size)\n     }\n }\n \n impl<D: Decoder> Decodable<D> for ScalarInt {\n     fn decode(d: &mut D) -> Result<ScalarInt, D::Error> {\n-        Ok(ScalarInt { bytes: d.read_u128()?.to_ne_bytes(), size: d.read_u8()? })\n+        Ok(ScalarInt { data: d.read_u128()?, size: d.read_u8()? })\n     }\n }\n \n impl ScalarInt {\n-    pub const TRUE: ScalarInt = ScalarInt { bytes: 1_u128.to_ne_bytes(), size: 1 };\n+    pub const TRUE: ScalarInt = ScalarInt { data: 1_u128, size: 1 };\n \n-    pub const FALSE: ScalarInt = ScalarInt { bytes: 0_u128.to_ne_bytes(), size: 1 };\n+    pub const FALSE: ScalarInt = ScalarInt { data: 0_u128, size: 1 };\n \n-    pub const ZST: ScalarInt = ScalarInt { bytes: 0_u128.to_ne_bytes(), size: 0 };\n-\n-    fn data(self) -> u128 {\n-        u128::from_ne_bytes(self.bytes)\n-    }\n+    pub const ZST: ScalarInt = ScalarInt { data: 0_u128, size: 0 };\n \n     #[inline]\n     pub fn size(self) -> Size {\n@@ -164,10 +168,10 @@ impl ScalarInt {\n     #[inline(always)]\n     fn check_data(self) {\n         debug_assert_eq!(\n-            truncate(self.data(), self.size()),\n-            self.data(),\n+            truncate(self.data, self.size()),\n+            { self.data },\n             \"Scalar value {:#x} exceeds size of {} bytes\",\n-            self.data(),\n+            { self.data },\n             self.size\n         );\n     }\n@@ -179,7 +183,7 @@ impl ScalarInt {\n \n     #[inline]\n     pub fn null(size: Size) -> Self {\n-        Self { bytes: [0; 16], size: size.bytes() as u8 }\n+        Self { data: 0, size: size.bytes() as u8 }\n     }\n \n     pub(crate) fn ptr_sized_op<'tcx>(\n@@ -188,17 +192,14 @@ impl ScalarInt {\n         f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n     ) -> InterpResult<'tcx, Self> {\n         assert_eq!(u64::from(self.size), dl.pointer_size.bytes());\n-        Ok(Self {\n-            bytes: u128::from(f_int(u64::try_from(self.data()).unwrap())?).to_ne_bytes(),\n-            size: self.size,\n-        })\n+        Ok(Self { data: u128::from(f_int(u64::try_from(self.data).unwrap())?), size: self.size })\n     }\n \n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n         let data = i.into();\n         if truncate(data, size) == data {\n-            Some(Self { bytes: data.to_ne_bytes(), size: size.bytes() as u8 })\n+            Some(Self { data, size: size.bytes() as u8 })\n         } else {\n             None\n         }\n@@ -210,7 +211,7 @@ impl ScalarInt {\n         // `into` performed sign extension, we have to truncate\n         let truncated = truncate(i as u128, size);\n         if sign_extend(truncated, size) as i128 == i {\n-            Some(Self { bytes: truncated.to_ne_bytes(), size: size.bytes() as u8 })\n+            Some(Self { data: truncated, size: size.bytes() as u8 })\n         } else {\n             None\n         }\n@@ -221,7 +222,7 @@ impl ScalarInt {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         assert_eq!(target_size.bytes(), u64::from(self.size));\n         self.check_data();\n-        self.data()\n+        self.data\n     }\n \n     #[inline]\n@@ -234,7 +235,7 @@ impl ScalarInt {\n             });\n         }\n         self.check_data();\n-        Ok(self.data())\n+        Ok(self.data)\n     }\n }\n \n@@ -245,7 +246,7 @@ macro_rules! from {\n                 #[inline]\n                 fn from(u: $ty) -> Self {\n                     Self {\n-                        bytes: u128::from(u).to_ne_bytes(),\n+                        data: u128::from(u),\n                         size: std::mem::size_of::<$ty>() as u8,\n                     }\n                 }\n@@ -274,7 +275,7 @@ try_from!(u8, u16, u32, u64, u128);\n impl From<char> for ScalarInt {\n     #[inline]\n     fn from(c: char) -> Self {\n-        Self { bytes: (c as u128).to_ne_bytes(), size: std::mem::size_of::<char>() as u8 }\n+        Self { data: c as u128, size: std::mem::size_of::<char>() as u8 }\n     }\n }\n \n@@ -291,7 +292,7 @@ impl From<Single> for ScalarInt {\n     #[inline]\n     fn from(f: Single) -> Self {\n         // We trust apfloat to give us properly truncated data.\n-        Self { bytes: f.to_bits().to_ne_bytes(), size: 4 }\n+        Self { data: f.to_bits(), size: 4 }\n     }\n }\n \n@@ -307,7 +308,7 @@ impl From<Double> for ScalarInt {\n     #[inline]\n     fn from(f: Double) -> Self {\n         // We trust apfloat to give us properly truncated data.\n-        Self { bytes: f.to_bits().to_ne_bytes(), size: 8 }\n+        Self { data: f.to_bits(), size: 8 }\n     }\n }\n \n@@ -335,6 +336,6 @@ impl fmt::LowerHex for ScalarInt {\n         self.check_data();\n         // Format as hex number wide enough to fit any value of the given `size`.\n         // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-        write!(f, \"{:01$x}\", self.data(), self.size as usize * 2)\n+        write!(f, \"{:01$x}\", { self.data }, self.size as usize * 2)\n     }\n }"}, {"sha": "27ba6c9d49c52a224a6d00e47e6ea8c72594fa4a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "patch": "@@ -982,8 +982,8 @@ pub trait PrettyPrinter<'tcx>:\n                 None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw(ScalarInt::FALSE), ty::Bool) => p!(\"false\"),\n-            (Scalar::Raw(ScalarInt::TRUE), ty::Bool) => p!(\"true\"),\n+            (Scalar::Raw(int), ty::Bool) if int == ScalarInt::FALSE => p!(\"false\"),\n+            (Scalar::Raw(int), ty::Bool) if int == ScalarInt::TRUE => p!(\"true\"),\n             // Float\n             (Scalar::Raw(int), ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n@@ -1025,7 +1025,9 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Raw(ScalarInt::ZST), ty::FnDef(d, s)) => p!(print_value_path(*d, s)),\n+            (Scalar::Raw(int), ty::FnDef(d, s)) if int == ScalarInt::ZST => {\n+                p!(print_value_path(*d, s))\n+            }\n             // Nontrivial types with scalar bit representation\n             (Scalar::Raw(int), _) => {\n                 let print = |mut this: Self| {"}, {"sha": "1ada54cc102ed022fe0e9b6de98fdbaf0eefc4e9", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=02131f4dcd0c85f6b3cc7e8d6a5845a6bdd30ff5", "patch": "@@ -3,8 +3,8 @@\n // revisions: legacy v0\n //[legacy]compile-flags: -Z symbol-mangling-version=legacy\n     //[v0]compile-flags: -Z symbol-mangling-version=v0\n-//[legacy]normalize-stderr-32bit: \"h30edc7aa010c48ae\" -> \"SYMBOL_HASH\"\n-//[legacy]normalize-stderr-64bit: \"h56362331c4f93d19\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-32bit: \"hee444285569b39c2\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-64bit: \"h310ea0259fc3d32d\" -> \"SYMBOL_HASH\"\n \n #![feature(optin_builtin_traits, rustc_attrs)]\n #![allow(dead_code)]"}]}