{"sha": "0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MTdkNTgwZTZjZmFmYjFmYzY2MmNmYjljOWEzYzIzODI5ZmUyYWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-17T02:50:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-18T21:07:35Z"}, "message": "core::comm: Remove functions in favor of methods\n\n`send`, etc. are never used. I've left the functions for oneshot pipes\nbecause by-value methods don't work.", "tree": {"sha": "de119c3ec366dbac5fe3981f2e2287da98020afe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de119c3ec366dbac5fe3981f2e2287da98020afe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "html_url": "https://github.com/rust-lang/rust/commit/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e22461cd8b3aaa1876f0579615b9afe037f7195", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e22461cd8b3aaa1876f0579615b9afe037f7195", "html_url": "https://github.com/rust-lang/rust/commit/4e22461cd8b3aaa1876f0579615b9afe037f7195"}], "stats": {"total": 256, "additions": 97, "deletions": 159}, "files": [{"sha": "fe6dbddc75e4d6535317fc785c36b91e486e03a4", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 97, "deletions": 159, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=0617d580e6cfafb1fc662cfb9c9a3c23829fe2ae", "patch": "@@ -132,122 +132,88 @@ pub mod streamp {\n     }\n }\n \n-struct Chan_<T> {\n-    mut endp: Option<streamp::client::Open<T>>\n-}\n-\n /// An endpoint that can send many messages.\n-pub enum Chan<T> {\n-    Chan_(Chan_<T>)\n-}\n-\n-struct Port_<T> {\n-    mut endp: Option<streamp::server::Open<T>>,\n+pub struct Chan<T> {\n+    mut endp: Option<streamp::client::Open<T>>\n }\n \n /// An endpoint that can receive many messages.\n-pub enum Port<T> {\n-    Port_(Port_<T>)\n+pub struct Port<T> {\n+    mut endp: Option<streamp::server::Open<T>>,\n }\n \n-/** Creates a `(chan, port)` pair.\n+/** Creates a `(Port, Chan)` pair.\n \n These allow sending or receiving an unlimited number of messages.\n \n */\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     let (c, s) = streamp::init();\n \n-    (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n-}\n-\n-// Add an inherent method so that imports of GenericChan are not\n-// required.\n-pub impl<T: Owned> Chan<T> {\n-    fn send(&self, x: T) { chan_send(self, x) }\n-    fn try_send(&self, x: T) -> bool { chan_try_send(self, x) }\n+    (Port { endp: Some(s) }, Chan { endp: Some(c) })\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(&self, x: T) { chan_send(self, x) }\n-}\n-\n-#[inline(always)]\n-fn chan_send<T:Owned>(self: &Chan<T>, x: T) {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    self.endp = Some(\n-        streamp::client::data(endp.unwrap(), x))\n+    #[inline(always)]\n+    fn send(&self, x: T) {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        self.endp = Some(\n+            streamp::client::data(endp.unwrap(), x))\n+    }\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n-        chan_try_send(self, x)\n-    }\n-}\n-\n-#[inline(always)]\n-fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    match streamp::client::try_data(endp.unwrap(), x) {\n-        Some(next) => {\n-            self.endp = Some(next);\n-            true\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match streamp::client::try_data(endp.unwrap(), x) {\n+            Some(next) => {\n+                self.endp = Some(next);\n+                true\n+            }\n+            None => false\n         }\n-        None => false\n     }\n }\n \n-// Use an inherent impl so that imports are not required:\n-pub impl<T: Owned> Port<T> {\n-    fn recv(&self) -> T { port_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-    fn peek(&self) -> bool { port_peek(self) }\n-}\n-\n impl<T: Owned> GenericPort<T> for Port<T> {\n-    // These two calls will prefer the inherent versions above:\n-    fn recv(&self) -> T { port_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-}\n-\n-#[inline(always)]\n-fn port_recv<T:Owned>(self: &Port<T>) -> T {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    let streamp::data(x, endp) = recv(endp.unwrap());\n-    self.endp = Some(endp);\n-    x\n-}\n-\n-#[inline(always)]\n-fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    match try_recv(endp.unwrap()) {\n-        Some(streamp::data(x, endp)) => {\n-            self.endp = Some(endp);\n-            Some(x)\n+    #[inline(always)]\n+    fn recv(&self) -> T {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let streamp::data(x, endp) = recv(endp.unwrap());\n+        self.endp = Some(endp);\n+        x\n+    }\n+\n+    #[inline(always)]\n+    fn try_recv(&self) -> Option<T> {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match try_recv(endp.unwrap()) {\n+            Some(streamp::data(x, endp)) => {\n+                self.endp = Some(endp);\n+                Some(x)\n+            }\n+            None => None\n         }\n-        None => None\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool { port_peek(self) }\n-}\n-\n-#[inline(always)]\n-fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    let peek = match &endp {\n-        &Some(ref endp) => peek(endp),\n-        &None => fail!(~\"peeking empty stream\")\n-    };\n-    self.endp <-> endp;\n-    peek\n+    #[inline(always)]\n+    fn peek(&self) -> bool {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let peek = match &endp {\n+            &Some(ref endp) => peek(endp),\n+            &None => fail!(~\"peeking empty stream\")\n+        };\n+        self.endp <-> endp;\n+        peek\n+    }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n@@ -272,13 +238,6 @@ pub fn PortSet<T: Owned>() -> PortSet<T>{\n     }\n }\n \n-// Use an inherent impl so that imports are not required:\n-pub impl<T:Owned> PortSet<T> {\n-    fn recv(&self) -> T { port_set_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    fn peek(&self) -> bool { port_set_peek(self) }\n-}\n-\n pub impl<T: Owned> PortSet<T> {\n     fn add(&self, port: Port<T>) {\n         self.ports.push(port)\n@@ -292,90 +251,69 @@ pub impl<T: Owned> PortSet<T> {\n }\n \n impl<T:Owned> GenericPort<T> for PortSet<T> {\n-    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    fn recv(&self) -> T { port_set_recv(self) }\n-}\n-\n-#[inline(always)]\n-fn port_set_recv<T:Owned>(self: &PortSet<T>) -> T {\n-    port_set_try_recv(self).expect(\"port_set: endpoints closed\")\n-}\n-\n-#[inline(always)]\n-fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n-    let mut result = None;\n-    // we have to swap the ports array so we aren't borrowing\n-    // aliasable mutable memory.\n-    let mut ports = ~[];\n-    ports <-> self.ports;\n-    while result.is_none() && ports.len() > 0 {\n-        let i = wait_many(ports);\n-        match ports[i].try_recv() {\n-            Some(m) => {\n-                result = Some(m);\n-            }\n-            None => {\n-                // Remove this port.\n-                let _ = ports.swap_remove(i);\n+    fn try_recv(&self) -> Option<T> {\n+        let mut result = None;\n+        // we have to swap the ports array so we aren't borrowing\n+        // aliasable mutable memory.\n+        let mut ports = ~[];\n+        ports <-> self.ports;\n+        while result.is_none() && ports.len() > 0 {\n+            let i = wait_many(ports);\n+            match ports[i].try_recv() {\n+                Some(m) => {\n+                    result = Some(m);\n+                }\n+                None => {\n+                    // Remove this port.\n+                    let _ = ports.swap_remove(i);\n+                }\n             }\n         }\n+        ports <-> self.ports;\n+        result\n+    }\n+    fn recv(&self) -> T {\n+        self.try_recv().expect(\"port_set: endpoints closed\")\n     }\n-    ports <-> self.ports;\n-    result\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    fn peek(&self) -> bool { port_set_peek(self) }\n-}\n-\n-#[inline(always)]\n-fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n-    // It'd be nice to use self.port.each, but that version isn't\n-    // pure.\n-    for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-        // XXX: Botch pending demuting.\n-        unsafe {\n-            let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n-            if port.peek() { return true }\n+    fn peek(&self) -> bool {\n+        // It'd be nice to use self.port.each, but that version isn't\n+        // pure.\n+        for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n+            // XXX: Botch pending demuting.\n+            unsafe {\n+                let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n+                if port.peek() { return true }\n+            }\n         }\n+        false\n     }\n-    false\n }\n \n-\n /// A channel that can be shared between many senders.\n pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n \n-pub impl<T: Owned> SharedChan<T> {\n-    fn send(&self, x: T) { shared_chan_send(self, x) }\n-    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n-}\n-\n impl<T: Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, x: T) { shared_chan_send(self, x) }\n-}\n-\n-#[inline(always)]\n-fn shared_chan_send<T:Owned>(self: &SharedChan<T>, x: T) {\n-    let mut xx = Some(x);\n-    do self.with_imm |chan| {\n-        let mut x = None;\n-        x <-> xx;\n-        chan.send(x.unwrap())\n+    fn send(&self, x: T) {\n+        let mut xx = Some(x);\n+        do self.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.send(x.unwrap())\n+        }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n-}\n-\n-#[inline(always)]\n-fn shared_chan_try_send<T:Owned>(self: &SharedChan<T>, x: T) -> bool {\n-    let mut xx = Some(x);\n-    do self.with_imm |chan| {\n-        let mut x = None;\n-        x <-> xx;\n-        chan.try_send(x.unwrap())\n+    fn try_send(&self, x: T) -> bool {\n+        let mut xx = Some(x);\n+        do self.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.try_send(x.unwrap())\n+        }\n     }\n }\n "}]}