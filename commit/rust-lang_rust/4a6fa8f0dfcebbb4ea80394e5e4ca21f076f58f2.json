{"sha": "4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNmZhOGYwZGZjZWJiYjRlYTgwMzk0ZTVlNGNhMjFmMDc2ZjU4ZjI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-05T21:15:49Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-05T21:15:49Z"}, "message": "Rename AtomTextEdit -> Indel", "tree": {"sha": "a639c6697f88528f35dc010ecf7c969cf4aaab56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a639c6697f88528f35dc010ecf7c969cf4aaab56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "html_url": "https://github.com/rust-lang/rust/commit/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381cbc6088b6c4238b0f82df8ef37b552257ae59", "url": "https://api.github.com/repos/rust-lang/rust/commits/381cbc6088b6c4238b0f82df8ef37b552257ae59", "html_url": "https://github.com/rust-lang/rust/commit/381cbc6088b6c4238b0f82df8ef37b552257ae59"}], "stats": {"total": 317, "additions": 154, "deletions": 163}, "files": [{"sha": "83dd270c6cec7f2d0e6113820054aeef01a24a8e", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -4,14 +4,13 @@ use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo::{self, find_covering_element, find_node_at_offset},\n+    algo::{self, find_covering_element, find_node_at_offset, SyntaxRewriter},\n     AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n use ra_text_edit::TextEditBuilder;\n \n use crate::{AssistAction, AssistFile, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n-use algo::SyntaxRewriter;\n \n #[derive(Clone, Debug)]\n pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n@@ -42,7 +41,6 @@ impl AssistInfo {\n     }\n }\n \n-\n /// `AssistCtx` allows to apply an assist or check if it could be applied.\n ///\n /// Assists use a somewhat over-engineered approach, given the current needs. The"}, {"sha": "b6b9627deab555269a6f89a3ab5f487ae910e11d", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use ra_text_edit::AtomTextEdit;\n+use ra_text_edit::Indel;\n \n use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n \n@@ -76,7 +76,7 @@ impl<'a> CompletionContext<'a> {\n         // actual completion.\n         let file_with_fake_ident = {\n             let parse = db.parse(position.file_id);\n-            let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n+            let edit = Indel::insert(position.offset, \"intellijRulezz\".to_string());\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token ="}, {"sha": "383b23ac44e91ab63ea783836d296808c11c7b10", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -62,8 +62,8 @@ impl fmt::Debug for CompletionItem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n         s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n-        if self.text_edit().as_atoms().len() == 1 {\n-            let atom = &self.text_edit().as_atoms()[0];\n+        if self.text_edit().as_indels().len() == 1 {\n+            let atom = &self.text_edit().as_indels()[0];\n             s.field(\"delete\", &atom.delete);\n             s.field(\"insert\", &atom.insert);\n         } else {"}, {"sha": "7fa6fc448e0e88c441c1493a5c4d152ffad6feb0", "filename": "crates/ra_ide_db/src/line_index_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fline_index_utils.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -10,7 +10,7 @@\n use std::convert::TryInto;\n \n use ra_syntax::{TextRange, TextSize};\n-use ra_text_edit::{AtomTextEdit, TextEdit};\n+use ra_text_edit::{Indel, TextEdit};\n \n use crate::line_index::{LineCol, LineIndex, Utf16Char};\n \n@@ -182,14 +182,14 @@ struct TranslatedEdit<'a> {\n }\n \n struct Edits<'a> {\n-    edits: &'a [AtomTextEdit],\n+    edits: &'a [Indel],\n     current: Option<TranslatedEdit<'a>>,\n     acc_diff: i64,\n }\n \n impl<'a> Edits<'a> {\n     fn from_text_edit(text_edit: &'a TextEdit) -> Edits<'a> {\n-        let mut x = Edits { edits: text_edit.as_atoms(), current: None, acc_diff: 0 };\n+        let mut x = Edits { edits: text_edit.as_indels(), current: None, acc_diff: 0 };\n         x.advance_edit();\n         x\n     }"}, {"sha": "39f9b12ab20b916e1760129ce5940f5e6665537b", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -5,7 +5,7 @@ use std::{\n     str::{self, FromStr},\n };\n \n-use ra_text_edit::AtomTextEdit;\n+use ra_text_edit::Indel;\n \n use crate::{validation, AstNode, SourceFile, TextRange};\n \n@@ -22,7 +22,7 @@ pub fn check_parser(text: &str) {\n #[derive(Debug, Clone)]\n pub struct CheckReparse {\n     text: String,\n-    edit: AtomTextEdit,\n+    edit: Indel,\n     edited_text: String,\n }\n \n@@ -43,7 +43,7 @@ impl CheckReparse {\n             TextRange::at(delete_start.try_into().unwrap(), delete_len.try_into().unwrap());\n         let edited_text =\n             format!(\"{}{}{}\", &text[..delete_start], &insert, &text[delete_start + delete_len..]);\n-        let edit = AtomTextEdit { delete, insert };\n+        let edit = Indel { delete, insert };\n         Some(CheckReparse { text, edit, edited_text })\n     }\n "}, {"sha": "1a7348dacdc5a5b955182745c3e71f54998ed639", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -39,7 +39,7 @@ pub mod fuzz;\n \n use std::{marker::PhantomData, sync::Arc};\n \n-use ra_text_edit::AtomTextEdit;\n+use ra_text_edit::Indel;\n use stdx::format_to;\n \n use crate::syntax_node::GreenNode;\n@@ -126,13 +126,13 @@ impl Parse<SourceFile> {\n         buf\n     }\n \n-    pub fn reparse(&self, edit: &AtomTextEdit) -> Parse<SourceFile> {\n-        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+    pub fn reparse(&self, indel: &Indel) -> Parse<SourceFile> {\n+        self.incremental_reparse(indel).unwrap_or_else(|| self.full_reparse(indel))\n     }\n \n-    fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<Parse<SourceFile>> {\n+    fn incremental_reparse(&self, indel: &Indel) -> Option<Parse<SourceFile>> {\n         // FIXME: validation errors are not handled here\n-        parsing::incremental_reparse(self.tree().syntax(), edit, self.errors.to_vec()).map(\n+        parsing::incremental_reparse(self.tree().syntax(), indel, self.errors.to_vec()).map(\n             |(green_node, errors, _reparsed_range)| Parse {\n                 green: green_node,\n                 errors: Arc::new(errors),\n@@ -141,8 +141,8 @@ impl Parse<SourceFile> {\n         )\n     }\n \n-    fn full_reparse(&self, edit: &AtomTextEdit) -> Parse<SourceFile> {\n-        let text = edit.apply(self.tree().syntax().text().to_string());\n+    fn full_reparse(&self, indel: &Indel) -> Parse<SourceFile> {\n+        let text = indel.apply(self.tree().syntax().text().to_string());\n         SourceFile::parse(&text)\n     }\n }"}, {"sha": "6257e3f33888791c2001f398ec3353505eea0785", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -7,7 +7,7 @@\n //!     and try to parse only this block.\n \n use ra_parser::Reparser;\n-use ra_text_edit::AtomTextEdit;\n+use ra_text_edit::Indel;\n \n use crate::{\n     algo,\n@@ -24,7 +24,7 @@ use crate::{\n \n pub(crate) fn incremental_reparse(\n     node: &SyntaxNode,\n-    edit: &AtomTextEdit,\n+    edit: &Indel,\n     errors: Vec<SyntaxError>,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     if let Some((green, new_errors, old_range)) = reparse_token(node, &edit) {\n@@ -39,7 +39,7 @@ pub(crate) fn incremental_reparse(\n \n fn reparse_token<'node>(\n     root: &'node SyntaxNode,\n-    edit: &AtomTextEdit,\n+    edit: &Indel,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let prev_token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n     let prev_token_kind = prev_token.kind();\n@@ -88,7 +88,7 @@ fn reparse_token<'node>(\n \n fn reparse_block<'node>(\n     root: &'node SyntaxNode,\n-    edit: &AtomTextEdit,\n+    edit: &Indel,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let (node, reparser) = find_reparsable_node(root, edit.delete)?;\n     let text = get_text_after_edit(node.clone().into(), edit);\n@@ -108,9 +108,9 @@ fn reparse_block<'node>(\n     Some((node.replace_with(green), new_parser_errors, node.text_range()))\n }\n \n-fn get_text_after_edit(element: SyntaxElement, edit: &AtomTextEdit) -> String {\n+fn get_text_after_edit(element: SyntaxElement, edit: &Indel) -> String {\n     let edit =\n-        AtomTextEdit::replace(edit.delete - element.text_range().start(), edit.insert.clone());\n+        Indel::replace(edit.delete - element.text_range().start(), edit.insert.clone());\n \n     let text = match element {\n         NodeOrToken::Token(token) => token.text().to_string(),\n@@ -167,7 +167,7 @@ fn merge_errors(\n     old_errors: Vec<SyntaxError>,\n     new_errors: Vec<SyntaxError>,\n     range_before_reparse: TextRange,\n-    edit: &AtomTextEdit,\n+    edit: &Indel,\n ) -> Vec<SyntaxError> {\n     let mut res = Vec::new();\n \n@@ -198,7 +198,7 @@ mod tests {\n \n     fn do_check(before: &str, replace_with: &str, reparsed_len: u32) {\n         let (range, before) = extract_range(before);\n-        let edit = AtomTextEdit::replace(range, replace_with.to_owned());\n+        let edit = Indel::replace(range, replace_with.to_owned());\n         let after = edit.apply(before.clone());\n \n         let fully_reparsed = SourceFile::parse(&after);"}, {"sha": "c41bf324b6a7bccf16e8abbced65745635594e3a", "filename": "crates/ra_text_edit/src/lib.rs", "status": "modified", "additions": 114, "deletions": 17, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Fra_text_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Flib.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -1,30 +1,40 @@\n-//! FIXME: write short doc here\n-\n-mod text_edit;\n+//! Representation of a `TextEdit`.\n+//!\n+//! `rust-analyzer` never mutates text itself and only sends diffs to clients,\n+//! so `TextEdit` is the ultimate representation of the work done by\n+//! rust-analyzer.\n \n use text_size::{TextRange, TextSize};\n \n-pub use crate::text_edit::{TextEdit, TextEditBuilder};\n-\n-/// Must not overlap with other `AtomTextEdit`s\n+/// `InsertDelete` -- a single \"atomic\" change to text\n+///\n+/// Must not overlap with other `InDel`s\n #[derive(Debug, Clone)]\n-pub struct AtomTextEdit {\n+pub struct Indel {\n+    pub insert: String,\n     /// Refers to offsets in the original text\n     pub delete: TextRange,\n-    pub insert: String,\n }\n \n-impl AtomTextEdit {\n-    pub fn replace(range: TextRange, replace_with: String) -> AtomTextEdit {\n-        AtomTextEdit { delete: range, insert: replace_with }\n-    }\n+#[derive(Debug, Clone)]\n+pub struct TextEdit {\n+    indels: Vec<Indel>,\n+}\n \n-    pub fn delete(range: TextRange) -> AtomTextEdit {\n-        AtomTextEdit::replace(range, String::new())\n-    }\n+#[derive(Debug, Default)]\n+pub struct TextEditBuilder {\n+    indels: Vec<Indel>,\n+}\n \n-    pub fn insert(offset: TextSize, text: String) -> AtomTextEdit {\n-        AtomTextEdit::replace(TextRange::empty(offset), text)\n+impl Indel {\n+    pub fn insert(offset: TextSize, text: String) -> Indel {\n+        Indel::replace(TextRange::empty(offset), text)\n+    }\n+    pub fn delete(range: TextRange) -> Indel {\n+        Indel::replace(range, String::new())\n+    }\n+    pub fn replace(range: TextRange, replace_with: String) -> Indel {\n+        Indel { delete: range, insert: replace_with }\n     }\n \n     pub fn apply(&self, mut text: String) -> String {\n@@ -34,3 +44,90 @@ impl AtomTextEdit {\n         text\n     }\n }\n+\n+impl TextEdit {\n+    pub fn insert(offset: TextSize, text: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.insert(offset, text);\n+        builder.finish()\n+    }\n+\n+    pub fn delete(range: TextRange) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.delete(range);\n+        builder.finish()\n+    }\n+\n+    pub fn replace(range: TextRange, replace_with: String) -> TextEdit {\n+        let mut builder = TextEditBuilder::default();\n+        builder.replace(range, replace_with);\n+        builder.finish()\n+    }\n+\n+    pub(crate) fn from_indels(mut indels: Vec<Indel>) -> TextEdit {\n+        indels.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n+        for (a1, a2) in indels.iter().zip(indels.iter().skip(1)) {\n+            assert!(a1.delete.end() <= a2.delete.start())\n+        }\n+        TextEdit { indels }\n+    }\n+\n+    pub fn as_indels(&self) -> &[Indel] {\n+        &self.indels\n+    }\n+\n+    pub fn apply(&self, text: &str) -> String {\n+        let mut total_len = TextSize::of(text);\n+        for indel in self.indels.iter() {\n+            total_len += TextSize::of(&indel.insert);\n+            total_len -= indel.delete.end() - indel.delete.start();\n+        }\n+        let mut buf = String::with_capacity(total_len.into());\n+        let mut prev = 0;\n+        for indel in self.indels.iter() {\n+            let start: usize = indel.delete.start().into();\n+            let end: usize = indel.delete.end().into();\n+            if start > prev {\n+                buf.push_str(&text[prev..start]);\n+            }\n+            buf.push_str(&indel.insert);\n+            prev = end;\n+        }\n+        buf.push_str(&text[prev..text.len()]);\n+        assert_eq!(TextSize::of(&buf), total_len);\n+        buf\n+    }\n+\n+    pub fn apply_to_offset(&self, offset: TextSize) -> Option<TextSize> {\n+        let mut res = offset;\n+        for indel in self.indels.iter() {\n+            if indel.delete.start() >= offset {\n+                break;\n+            }\n+            if offset < indel.delete.end() {\n+                return None;\n+            }\n+            res += TextSize::of(&indel.insert);\n+            res -= indel.delete.len();\n+        }\n+        Some(res)\n+    }\n+}\n+\n+impl TextEditBuilder {\n+    pub fn replace(&mut self, range: TextRange, replace_with: String) {\n+        self.indels.push(Indel::replace(range, replace_with))\n+    }\n+    pub fn delete(&mut self, range: TextRange) {\n+        self.indels.push(Indel::delete(range))\n+    }\n+    pub fn insert(&mut self, offset: TextSize, text: String) {\n+        self.indels.push(Indel::insert(offset, text))\n+    }\n+    pub fn finish(self) -> TextEdit {\n+        TextEdit::from_indels(self.indels)\n+    }\n+    pub fn invalidates_offset(&self, offset: TextSize) -> bool {\n+        self.indels.iter().any(|indel| indel.delete.contains_inclusive(offset))\n+    }\n+}"}, {"sha": "eabab4b4d117e215f2e35403a52065f3413b83d9", "filename": "crates/ra_text_edit/src/text_edit.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/381cbc6088b6c4238b0f82df8ef37b552257ae59/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/381cbc6088b6c4238b0f82df8ef37b552257ae59/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_text_edit%2Fsrc%2Ftext_edit.rs?ref=381cbc6088b6c4238b0f82df8ef37b552257ae59", "patch": "@@ -1,102 +0,0 @@\n-//! FIXME: write short doc here\n-\n-use crate::AtomTextEdit;\n-\n-use text_size::{TextRange, TextSize};\n-\n-#[derive(Debug, Clone)]\n-pub struct TextEdit {\n-    atoms: Vec<AtomTextEdit>,\n-}\n-\n-#[derive(Debug, Default)]\n-pub struct TextEditBuilder {\n-    atoms: Vec<AtomTextEdit>,\n-}\n-\n-impl TextEditBuilder {\n-    pub fn replace(&mut self, range: TextRange, replace_with: String) {\n-        self.atoms.push(AtomTextEdit::replace(range, replace_with))\n-    }\n-    pub fn delete(&mut self, range: TextRange) {\n-        self.atoms.push(AtomTextEdit::delete(range))\n-    }\n-    pub fn insert(&mut self, offset: TextSize, text: String) {\n-        self.atoms.push(AtomTextEdit::insert(offset, text))\n-    }\n-    pub fn finish(self) -> TextEdit {\n-        TextEdit::from_atoms(self.atoms)\n-    }\n-    pub fn invalidates_offset(&self, offset: TextSize) -> bool {\n-        self.atoms.iter().any(|atom| atom.delete.contains_inclusive(offset))\n-    }\n-}\n-\n-impl TextEdit {\n-    pub fn insert(offset: TextSize, text: String) -> TextEdit {\n-        let mut builder = TextEditBuilder::default();\n-        builder.insert(offset, text);\n-        builder.finish()\n-    }\n-\n-    pub fn delete(range: TextRange) -> TextEdit {\n-        let mut builder = TextEditBuilder::default();\n-        builder.delete(range);\n-        builder.finish()\n-    }\n-\n-    pub fn replace(range: TextRange, replace_with: String) -> TextEdit {\n-        let mut builder = TextEditBuilder::default();\n-        builder.replace(range, replace_with);\n-        builder.finish()\n-    }\n-\n-    pub(crate) fn from_atoms(mut atoms: Vec<AtomTextEdit>) -> TextEdit {\n-        atoms.sort_by_key(|a| (a.delete.start(), a.delete.end()));\n-        for (a1, a2) in atoms.iter().zip(atoms.iter().skip(1)) {\n-            assert!(a1.delete.end() <= a2.delete.start())\n-        }\n-        TextEdit { atoms }\n-    }\n-\n-    pub fn as_atoms(&self) -> &[AtomTextEdit] {\n-        &self.atoms\n-    }\n-\n-    pub fn apply(&self, text: &str) -> String {\n-        let mut total_len = TextSize::of(text);\n-        for atom in self.atoms.iter() {\n-            total_len += TextSize::of(&atom.insert);\n-            total_len -= atom.delete.end() - atom.delete.start();\n-        }\n-        let mut buf = String::with_capacity(total_len.into());\n-        let mut prev = 0;\n-        for atom in self.atoms.iter() {\n-            let start: usize = atom.delete.start().into();\n-            let end: usize = atom.delete.end().into();\n-            if start > prev {\n-                buf.push_str(&text[prev..start]);\n-            }\n-            buf.push_str(&atom.insert);\n-            prev = end;\n-        }\n-        buf.push_str(&text[prev..text.len()]);\n-        assert_eq!(TextSize::of(&buf), total_len);\n-        buf\n-    }\n-\n-    pub fn apply_to_offset(&self, offset: TextSize) -> Option<TextSize> {\n-        let mut res = offset;\n-        for atom in self.atoms.iter() {\n-            if atom.delete.start() >= offset {\n-                break;\n-            }\n-            if offset < atom.delete.end() {\n-                return None;\n-            }\n-            res += TextSize::of(&atom.insert);\n-            res -= atom.delete.len();\n-        }\n-        Some(res)\n-    }\n-}"}, {"sha": "f64c90b5b17ad2bbbccdbdd92f5e44f4dbacc35d", "filename": "crates/rust-analyzer/src/conv.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/crates%2Frust-analyzer%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconv.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -15,7 +15,7 @@ use ra_ide::{\n     ReferenceAccess, Severity, SourceChange, SourceFileEdit,\n };\n use ra_syntax::{SyntaxKind, TextRange, TextSize};\n-use ra_text_edit::{AtomTextEdit, TextEdit};\n+use ra_text_edit::{Indel, TextEdit};\n use ra_vfs::LineEndings;\n \n use crate::{\n@@ -124,23 +124,22 @@ impl ConvWith<(&LineIndex, LineEndings)> for CompletionItem {\n         let mut text_edit = None;\n         // LSP does not allow arbitrary edits in completion, so we have to do a\n         // non-trivial mapping here.\n-        for atom_edit in self.text_edit().as_atoms() {\n-            if atom_edit.delete.contains_range(self.source_range()) {\n-                text_edit = Some(if atom_edit.delete == self.source_range() {\n-                    atom_edit.conv_with((ctx.0, ctx.1))\n+        for indel in self.text_edit().as_indels() {\n+            if indel.delete.contains_range(self.source_range()) {\n+                text_edit = Some(if indel.delete == self.source_range() {\n+                    indel.conv_with((ctx.0, ctx.1))\n                 } else {\n-                    assert!(self.source_range().end() == atom_edit.delete.end());\n-                    let range1 =\n-                        TextRange::new(atom_edit.delete.start(), self.source_range().start());\n+                    assert!(self.source_range().end() == indel.delete.end());\n+                    let range1 = TextRange::new(indel.delete.start(), self.source_range().start());\n                     let range2 = self.source_range();\n-                    let edit1 = AtomTextEdit::replace(range1, String::new());\n-                    let edit2 = AtomTextEdit::replace(range2, atom_edit.insert.clone());\n+                    let edit1 = Indel::replace(range1, String::new());\n+                    let edit2 = Indel::replace(range2, indel.insert.clone());\n                     additional_text_edits.push(edit1.conv_with((ctx.0, ctx.1)));\n                     edit2.conv_with((ctx.0, ctx.1))\n                 })\n             } else {\n-                assert!(self.source_range().intersect(atom_edit.delete).is_none());\n-                additional_text_edits.push(atom_edit.conv_with((ctx.0, ctx.1)));\n+                assert!(self.source_range().intersect(indel.delete).is_none());\n+                additional_text_edits.push(indel.conv_with((ctx.0, ctx.1)));\n             }\n         }\n         let text_edit = text_edit.unwrap();\n@@ -257,11 +256,11 @@ impl ConvWith<(&LineIndex, LineEndings)> for TextEdit {\n     type Output = Vec<lsp_types::TextEdit>;\n \n     fn conv_with(self, ctx: (&LineIndex, LineEndings)) -> Vec<lsp_types::TextEdit> {\n-        self.as_atoms().iter().map_conv_with(ctx).collect()\n+        self.as_indels().iter().map_conv_with(ctx).collect()\n     }\n }\n \n-impl ConvWith<(&LineIndex, LineEndings)> for &AtomTextEdit {\n+impl ConvWith<(&LineIndex, LineEndings)> for &Indel {\n     type Output = lsp_types::TextEdit;\n \n     fn conv_with(\n@@ -522,7 +521,7 @@ impl TryConvWith<&WorldSnapshot> for SourceFileEdit {\n         let line_index = world.analysis().file_line_index(self.file_id)?;\n         let line_endings = world.file_line_endings(self.file_id);\n         let edits =\n-            self.edit.as_atoms().iter().map_conv_with((&line_index, line_endings)).collect();\n+            self.edit.as_indels().iter().map_conv_with((&line_index, line_endings)).collect();\n         Ok(TextDocumentEdit { text_document, edits })\n     }\n }"}, {"sha": "3213c4dfa3c3833a7c80bbcb8ac456cd9e41bf20", "filename": "xtask/tests/tidy-tests/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2/xtask%2Ftests%2Ftidy-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy-tests%2Fmain.rs?ref=4a6fa8f0dfcebbb4ea80394e5e4ca21f076f58f2", "patch": "@@ -115,7 +115,6 @@ impl TidyDocs {\n             \"ra_prof\",\n             \"ra_project_model\",\n             \"ra_syntax\",\n-            \"ra_text_edit\",\n             \"ra_tt\",\n             \"ra_hir_ty\",\n         ];"}]}