{"sha": "7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzRhZjMyMjY4ZjliMDc4M2NhOTQxMDdiMGIxMGQ1MmU0ZWJlNWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T11:06:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T11:06:30Z"}, "message": "Avoid materializing strings", "tree": {"sha": "179d818c695a27ceee3f8193e219234854190f9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/179d818c695a27ceee3f8193e219234854190f9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "html_url": "https://github.com/rust-lang/rust/commit/7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "363f466627db373fab23d1df94b7382223b8675a", "url": "https://api.github.com/repos/rust-lang/rust/commits/363f466627db373fab23d1df94b7382223b8675a", "html_url": "https://github.com/rust-lang/rust/commit/363f466627db373fab23d1df94b7382223b8675a"}], "stats": {"total": 171, "additions": 139, "deletions": 32}, "files": [{"sha": "cd5146d87497459caf2ab65f98b0c7fd8d863986", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -29,8 +29,8 @@ pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n     let right = non_trivia_sibling(comma, Direction::Forward)?;\n     Some(move || {\n         let mut edit = EditBuilder::new();\n-        edit.replace(left.range(), right.text());\n-        edit.replace(right.range(), left.text());\n+        edit.replace(left.range(), right.text().to_string());\n+        edit.replace(right.range(), left.text().to_string());\n         ActionResult {\n             edit: edit.finish(),\n             cursor_position: None,"}, {"sha": "3a3776c26839497fd12c8610aeb74b9a464b7214", "filename": "crates/libeditor/src/typing.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftyping.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -15,16 +15,15 @@ use {ActionResult, EditBuilder, find_node_at_offset};\n \n pub fn join_lines(file: &File, range: TextRange) -> ActionResult {\n     let range = if range.is_empty() {\n-        let text = file.syntax().text();\n-        let text = &text[TextRange::from_to(range.start(), TextUnit::of_str(&text))];\n-        let pos = text.bytes().take_while(|&b| b != b'\\n').count();\n-        if pos == text.len() {\n-            return ActionResult {\n+        let syntax = file.syntax();\n+        let text = syntax.text().slice(range.start()..);\n+        let pos = match text.find('\\n') {\n+            None => return ActionResult {\n                 edit: EditBuilder::new().finish(),\n                 cursor_position: None\n-            };\n-        }\n-        let pos: TextUnit = (pos as u32).into();\n+            },\n+            Some(pos) => pos\n+        };\n         TextRange::offset_len(\n             range.start() + pos,\n             TextUnit::of_char('\\n'),\n@@ -129,7 +128,7 @@ fn join_lambda_body(\n     let expr = single_expr(block)?;\n     edit.replace(\n         block_expr.syntax().range(),\n-        expr.syntax().text(),\n+        expr.syntax().text().to_string(),\n     );\n     Some(())\n }"}, {"sha": "ccf13e4ab38bd323dd107420071e35e4ce6258fa", "filename": "crates/libsyntax2/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flib.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -81,7 +81,7 @@ impl File {\n     pub fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n         let (node, reparser) = find_reparsable_node(self.syntax(), edit.delete)?;\n         let text = replace_range(\n-            node.text(),\n+            node.text().to_string(),\n             edit.delete - node.range().start(),\n             &edit.insert,\n         );\n@@ -97,7 +97,7 @@ impl File {\n         Some(File::new(green_root, errors))\n     }\n     fn full_reparse(&self, edit: &AtomEdit) -> File {\n-        let text = replace_range(self.syntax().text(), edit.delete, &edit.insert);\n+        let text = replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n         File::parse(&text)\n     }\n     pub fn ast(&self) -> ast::Root {"}, {"sha": "59aefb0def937db9b016e47c5fc6bbac5d48e8fb", "filename": "crates/libsyntax2/src/yellow/green.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fgreen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fgreen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fgreen.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -43,21 +43,13 @@ impl GreenNode {\n         }\n     }\n \n-    pub fn text(&self) -> String {\n-        let mut buff = String::new();\n-        go(self, &mut buff);\n-        return buff;\n-        fn go(node: &GreenNode, buff: &mut String) {\n-            match node {\n-                GreenNode::Leaf { text, .. } => buff.push_str(text.as_str()),\n-                GreenNode::Branch(b) => b.children().iter().for_each(|child| go(child, buff)),\n-            }\n-        }\n+    pub fn leaf_text(&self) -> Option<SmolStr> {\n+        self.leaf_text_ref().map(Clone::clone)\n     }\n \n-    pub fn leaf_text(&self) -> Option<SmolStr> {\n+    pub fn leaf_text_ref(&self) -> Option<&SmolStr> {\n         match self {\n-            GreenNode::Leaf { text, .. } => Some(text.clone()),\n+            GreenNode::Leaf { text, .. } => Some(text),\n             GreenNode::Branch(_) => None,\n         }\n     }"}, {"sha": "82eda79d6d3303d9aeddd6f5d1e7b9cd6ad21d87", "filename": "crates/libsyntax2/src/yellow/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fmod.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -2,6 +2,7 @@ mod builder;\n mod green;\n mod red;\n mod syntax;\n+mod syntax_text;\n \n use std::{\n     sync::Arc,\n@@ -12,6 +13,7 @@ pub(crate) use self::{\n     builder::GreenBuilder,\n     green::GreenNode,\n     red::RedNode,\n+    syntax_text::SyntaxText,\n };\n \n #[derive(Debug)]\n@@ -32,6 +34,12 @@ pub struct OwnedRoot(Arc<SyntaxRoot>);\n #[derive(Clone, Copy, Debug)]\n pub struct RefRoot<'a>(&'a OwnedRoot); // TODO: shared_from_this instead of double indirection\n \n+impl<'a> RefRoot<'a> {\n+    fn syntax_root(&self) -> &'a SyntaxRoot {\n+        self.0.syntax_root()\n+    }\n+}\n+\n impl TreeRoot for OwnedRoot {\n     fn borrowed(&self) -> RefRoot {\n         RefRoot(&self)\n@@ -78,7 +86,7 @@ impl RedPtr {\n         RedPtr(red.into())\n     }\n \n-    unsafe fn get<'a>(self, _root: &'a impl TreeRoot) -> &'a RedNode {\n+    unsafe fn get<'a>(self, _root: &'a SyntaxRoot) -> &'a RedNode {\n         &*self.0.as_ptr()\n     }\n }"}, {"sha": "ede9ad3c8ff3cd48c2270510dc2e4285d88db681", "filename": "crates/libsyntax2/src/yellow/syntax.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -6,7 +6,7 @@ use std::{\n use smol_str::SmolStr;\n \n use {\n-    yellow::{GreenNode, RedNode, TreeRoot, SyntaxRoot, RedPtr, RefRoot, OwnedRoot},\n+    yellow::{GreenNode, RedNode, TreeRoot, SyntaxRoot, RedPtr, RefRoot, OwnedRoot, SyntaxText},\n     SyntaxKind::{self, *},\n     TextRange, TextUnit,\n };\n@@ -58,6 +58,13 @@ impl SyntaxNode<OwnedRoot> {\n     }\n }\n \n+impl<'a> SyntaxNode<RefRoot<'a>> {\n+    pub(crate) fn leaf_text_ref(self) -> Option<&'a SmolStr> {\n+        let red = unsafe { self.red.get(self.root.syntax_root()) };\n+        red.green().leaf_text_ref()\n+    }\n+}\n+\n impl<R: TreeRoot> SyntaxNode<R> {\n     pub fn borrowed<'a>(&'a self) -> SyntaxNodeRef<'a> {\n         SyntaxNode {\n@@ -66,7 +73,7 @@ impl<R: TreeRoot> SyntaxNode<R> {\n         }\n     }\n \n-    pub fn owned<'a>(&'a self) -> SyntaxNode {\n+    pub fn owned(&self) -> SyntaxNode {\n         SyntaxNode {\n             root: self.root.owned(),\n             red: self.red,\n@@ -82,16 +89,16 @@ impl<R: TreeRoot> SyntaxNode<R> {\n         TextRange::offset_len(red.start_offset(), red.green().text_len())\n     }\n \n-    pub fn text(&self) -> String {\n-        self.red().green().text()\n+    pub fn text(&self) -> SyntaxText {\n+        SyntaxText::new(self.borrowed())\n     }\n \n     pub fn children(&self) -> impl Iterator<Item = SyntaxNode<R>> {\n         let red = self.red;\n         let n_children = self.red().n_children();\n         let root = self.root.clone();\n         (0..n_children).map(move |i| {\n-            let red = unsafe { red.get(&root) };\n+            let red = unsafe { red.get(root.syntax_root()) };\n             SyntaxNode {\n                 root: root.clone(),\n                 red: red.get_child(i).unwrap(),\n@@ -171,7 +178,7 @@ impl<R: TreeRoot> SyntaxNode<R> {\n     }\n \n     fn red(&self) -> &RedNode {\n-        unsafe { self.red.get(&self.root) }\n+        unsafe { self.red.get(self.root.syntax_root()) }\n     }\n }\n "}, {"sha": "2685474701927870c22de705238ba12031106339", "filename": "crates/libsyntax2/src/yellow/syntax_text.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e74af32268f9b0783ca94107b0b10d52e4ebe5e/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=7e74af32268f9b0783ca94107b0b10d52e4ebe5e", "patch": "@@ -0,0 +1,101 @@\n+use std::{\n+    fmt, ops,\n+};\n+\n+use {\n+    SyntaxNodeRef, TextRange, TextUnit,\n+    algo::walk::preorder,\n+    text_utils::{intersect, contains_offset_nonstrict},\n+};\n+\n+#[derive(Clone)]\n+pub struct SyntaxText<'a> {\n+    node: SyntaxNodeRef<'a>,\n+    range: TextRange,\n+}\n+\n+impl<'a> SyntaxText<'a> {\n+    pub(crate) fn new(node: SyntaxNodeRef<'a>) -> SyntaxText<'a> {\n+        SyntaxText {\n+            node,\n+            range: node.range()\n+        }\n+    }\n+    pub fn chunks(&self) -> impl Iterator<Item=&'a str> {\n+        let range = self.range;\n+        preorder(self.node)\n+            .filter_map(move |node| {\n+                let text = node.leaf_text_ref()?;\n+                let range = intersect(range, node.range())?;\n+                let range = range - node.range().start();\n+                Some(&text[range])\n+            })\n+    }\n+    pub fn to_string(&self) -> String {\n+        self.chunks().collect()\n+    }\n+    pub fn contains(&self, c: char) -> bool {\n+        self.chunks().any(|it| it.contains(c))\n+    }\n+    pub fn find(&self, c: char) -> Option<TextUnit> {\n+        let mut acc: TextUnit = 0.into();\n+        for chunk in self.chunks() {\n+            if let Some(pos) = chunk.find(c) {\n+                let pos: TextUnit = (pos as u32).into();\n+                return Some(acc + pos);\n+            }\n+            acc += TextUnit::of_str(chunk);\n+        }\n+        None\n+    }\n+    pub fn len(&self) -> TextUnit {\n+        self.range.len()\n+    }\n+    pub fn slice(&self, range: impl SyntaxTextSlice) -> SyntaxText<'a> {\n+        let range = range.restrict(self.range)\n+            .unwrap_or_else(|| {\n+                panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n+            });\n+        SyntaxText { node: self.node, range }\n+    }\n+}\n+\n+impl<'a> fmt::Debug for SyntaxText<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.to_string(), f)\n+    }\n+}\n+\n+impl<'a> fmt::Display for SyntaxText<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.to_string(), f)\n+    }\n+}\n+\n+pub trait SyntaxTextSlice: fmt::Debug {\n+    fn restrict(&self, range: TextRange) -> Option<TextRange>;\n+}\n+\n+impl SyntaxTextSlice for TextRange {\n+    fn restrict(&self, range: TextRange) -> Option<TextRange> {\n+        intersect(*self, range)\n+    }\n+}\n+\n+impl SyntaxTextSlice for ops::RangeTo<TextUnit> {\n+    fn restrict(&self, range: TextRange) -> Option<TextRange> {\n+        if !contains_offset_nonstrict(range, self.end) {\n+            return None;\n+        }\n+        Some(TextRange::from_to(range.start(), self.end))\n+    }\n+}\n+\n+impl SyntaxTextSlice for ops::RangeFrom<TextUnit> {\n+    fn restrict(&self, range: TextRange) -> Option<TextRange> {\n+        if !contains_offset_nonstrict(range, self.start) {\n+            return None;\n+        }\n+        Some(TextRange::from_to(self.start, range.end()))\n+    }\n+}"}]}