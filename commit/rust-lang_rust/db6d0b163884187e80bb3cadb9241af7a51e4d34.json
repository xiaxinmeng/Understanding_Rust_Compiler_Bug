{"sha": "db6d0b163884187e80bb3cadb9241af7a51e4d34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNmQwYjE2Mzg4NDE4N2U4MGJiM2NhZGI5MjQxYWY3YTUxZTRkMzQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-08T16:58:22Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-20T20:10:07Z"}, "message": "Check associated type implementations for generic mismatches", "tree": {"sha": "deaf22f60221d4a7b97ea49c36fe0a8cf7f883a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deaf22f60221d4a7b97ea49c36fe0a8cf7f883a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db6d0b163884187e80bb3cadb9241af7a51e4d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db6d0b163884187e80bb3cadb9241af7a51e4d34", "html_url": "https://github.com/rust-lang/rust/commit/db6d0b163884187e80bb3cadb9241af7a51e4d34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db6d0b163884187e80bb3cadb9241af7a51e4d34/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01a46509a4c2dc430ebebf940a26232fdaeeba81", "url": "https://api.github.com/repos/rust-lang/rust/commits/01a46509a4c2dc430ebebf940a26232fdaeeba81", "html_url": "https://github.com/rust-lang/rust/commit/01a46509a4c2dc430ebebf940a26232fdaeeba81"}], "stats": {"total": 221, "additions": 195, "deletions": 26}, "files": [{"sha": "fca0632a4a623b5f8d36d032955e6b408750b8d1", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -1912,6 +1912,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n+            CompareImplTypeObligation { .. } => Error0308(\"type not compatible with trait\"),\n             MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =>\n                 Error0308(match source {\n                     hir::MatchSource::IfLetDesugar { .. } =>\n@@ -1948,6 +1949,7 @@ impl<'tcx> ObligationCause<'tcx> {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n+            CompareImplTypeObligation { .. } => \"associated type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n             MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\","}, {"sha": "b9238491acd2a1d6d1a478cf73be74306cfc39d8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -702,6 +702,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             SelectionError::Unimplemented => {\n                 if let ObligationCauseCode::CompareImplMethodObligation {\n                     item_name, impl_item_def_id, trait_item_def_id,\n+                } | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name, impl_item_def_id, trait_item_def_id,\n                 } = obligation.cause.code {\n                     self.report_extra_impl_obligation(\n                         span,\n@@ -2631,6 +2633,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                               but not on the corresponding trait method\",\n                              predicate));\n             }\n+            ObligationCauseCode::CompareImplTypeObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the associated impl type\\\n+                     but not on the corresponding associated trait type\",\n+                     predicate));\n+            }\n             ObligationCauseCode::ReturnType |\n             ObligationCauseCode::ReturnValue(_) |\n             ObligationCauseCode::BlockTailExpression(_) => (),"}, {"sha": "8baedfed9d60135e123982dfe48918013257fbad", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -230,6 +230,13 @@ pub enum ObligationCauseCode<'tcx> {\n         trait_item_def_id: DefId,\n     },\n \n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplTypeObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n     /// Checking that this expression can be assigned where it needs to be\n     // FIXME(eddyb) #11161 is the original Expr required?\n     ExprAssignable,"}, {"sha": "1e78b79ebb619229727e512b4da255e3e127f485", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -514,6 +514,15 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 impl_item_def_id,\n                 trait_item_def_id,\n             }),\n+            super::CompareImplTypeObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplTypeObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n             super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                 arm_span,"}, {"sha": "c2b69f3aae531de1d5c764d88014c0ac80e08cf5", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 155, "deletions": 21, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n-use rustc::ty::subst::{Subst, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::common::ErrorReported;\n use errors::{Applicability, DiagnosticId};\n \n@@ -26,7 +26,7 @@ use rustc_error_codes::*;\n /// - `trait_m`: the method in the trait\n /// - `impl_trait_ref`: the TraitRef corresponding to the trait implementation\n \n-pub fn compare_impl_method<'tcx>(\n+crate fn compare_impl_method<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_m: &ty::AssocItem,\n     impl_m_span: Span,\n@@ -181,13 +181,14 @@ fn compare_predicate_entailment<'tcx>(\n     let trait_m_predicates = tcx.predicates_of(trait_m.def_id);\n \n     // Check region bounds.\n-    check_region_bounds_on_impl_method(tcx,\n-                                       impl_m_span,\n-                                       impl_m,\n-                                       trait_m,\n-                                       &trait_m_generics,\n-                                       &impl_m_generics,\n-                                       trait_to_skol_substs)?;\n+    check_region_bounds_on_impl_item(\n+        tcx,\n+        impl_m_span,\n+        impl_m,\n+        trait_m,\n+        &trait_m_generics,\n+        &impl_m_generics,\n+    )?;\n \n     // Create obligations for each predicate declared by the impl\n     // definition in the context of the trait's parameter\n@@ -361,25 +362,22 @@ fn compare_predicate_entailment<'tcx>(\n     })\n }\n \n-fn check_region_bounds_on_impl_method<'tcx>(\n+fn check_region_bounds_on_impl_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,\n     impl_m: &ty::AssocItem,\n     trait_m: &ty::AssocItem,\n     trait_generics: &ty::Generics,\n     impl_generics: &ty::Generics,\n-    trait_to_skol_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorReported> {\n     let trait_params = trait_generics.own_counts().lifetimes;\n     let impl_params = impl_generics.own_counts().lifetimes;\n \n-    debug!(\"check_region_bounds_on_impl_method: \\\n+    debug!(\"check_region_bounds_on_impl_item: \\\n             trait_generics={:?} \\\n-            impl_generics={:?} \\\n-            trait_to_skol_substs={:?}\",\n+            impl_generics={:?}\",\n            trait_generics,\n-           impl_generics,\n-           trait_to_skol_substs);\n+           impl_generics);\n \n     // Must have same number of early-bound lifetime parameters.\n     // Unfortunately, if the user screws up the bounds, then this\n@@ -391,20 +389,25 @@ fn check_region_bounds_on_impl_method<'tcx>(\n     // are zero. Since I don't quite know how to phrase things at\n     // the moment, give a kind of vague error message.\n     if trait_params != impl_params {\n+        let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().def_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map(|g| g.span).unwrap_or(def_span);\n         let mut err = struct_span_err!(\n             tcx.sess,\n             span,\n             E0195,\n-            \"lifetime parameters or bounds on method `{}` do not match the trait declaration\",\n+            \"lifetime parameters or bounds on {} `{}` do not match the trait declaration\",\n+            item_kind,\n             impl_m.ident,\n         );\n-        err.span_label(span, \"lifetimes do not match method in trait\");\n+        err.span_label(span, &format!(\"lifetimes do not match {} in trait\", item_kind));\n         if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n             let def_sp = tcx.sess.source_map().def_span(sp);\n             let sp = tcx.hir().get_generics(trait_m.def_id).map(|g| g.span).unwrap_or(def_sp);\n-            err.span_label(sp, \"lifetimes in impl do not match this method in trait\");\n+            err.span_label(\n+                sp,\n+                &format!(\"lifetimes in impl do not match this {} in trait\", item_kind),\n+            );\n         }\n         err.emit();\n         return Err(ErrorReported);\n@@ -603,6 +606,8 @@ fn compare_number_of_generics<'tcx>(\n         (\"const\", trait_own_counts.consts, impl_own_counts.consts),\n     ];\n \n+    let item_kind = assoc_item_kind_str(impl_);\n+\n     let mut err_occurred = false;\n     for &(kind, trait_count, impl_count) in &matchings {\n         if impl_count != trait_count {\n@@ -647,8 +652,9 @@ fn compare_number_of_generics<'tcx>(\n             let mut err = tcx.sess.struct_span_err_with_code(\n                 spans,\n                 &format!(\n-                    \"method `{}` has {} {kind} parameter{} but its trait \\\n+                    \"{} `{}` has {} {kind} parameter{} but its trait \\\n                      declaration has {} {kind} parameter{}\",\n+                    item_kind,\n                     trait_.ident,\n                     impl_count,\n                     pluralize!(impl_count),\n@@ -961,7 +967,7 @@ fn compare_synthetic_generics<'tcx>(\n     }\n }\n \n-pub fn compare_const_impl<'tcx>(\n+crate fn compare_const_impl<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_c: &ty::AssocItem,\n     impl_c_span: Span,\n@@ -1059,3 +1065,131 @@ pub fn compare_const_impl<'tcx>(\n         fcx.regionck_item(impl_c_hir_id, impl_c_span, &[]);\n     });\n }\n+\n+crate fn compare_ty_impl<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    impl_ty: &ty::AssocItem,\n+    impl_ty_span: Span,\n+    trait_ty: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    trait_item_span: Option<Span>,\n+) {\n+    debug!(\"compare_impl_type(impl_trait_ref={:?})\", impl_trait_ref);\n+\n+    let _: Result<(), ErrorReported> = (|| {\n+        compare_number_of_generics(tcx, impl_ty, impl_ty_span, trait_ty, trait_item_span)?;\n+\n+        compare_type_predicate_entailment(tcx, impl_ty, impl_ty_span, trait_ty, impl_trait_ref)\n+    })();\n+}\n+\n+/// The equivalent of [compare_predicate_entailment], but for associated types\n+/// instead of associated functions.\n+fn compare_type_predicate_entailment(\n+    tcx: TyCtxt<'tcx>,\n+    impl_ty: &ty::AssocItem,\n+    impl_ty_span: Span,\n+    trait_ty: &ty::AssocItem,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+) -> Result<(), ErrorReported> {\n+    let impl_substs = InternalSubsts::identity_for_item(tcx, impl_ty.def_id);\n+    let trait_to_impl_substs = impl_substs.rebase_onto(tcx,\n+                                                       impl_ty.container.id(),\n+                                                       impl_trait_ref.substs);\n+\n+    let impl_ty_generics = tcx.generics_of(impl_ty.def_id);\n+    let trait_ty_generics = tcx.generics_of(trait_ty.def_id);\n+    let impl_ty_predicates = tcx.predicates_of(impl_ty.def_id);\n+    let trait_ty_predicates = tcx.predicates_of(trait_ty.def_id);\n+\n+    check_region_bounds_on_impl_item(\n+        tcx,\n+        impl_ty_span,\n+        impl_ty,\n+        trait_ty,\n+        &trait_ty_generics,\n+        &impl_ty_generics,\n+    )?;\n+\n+    let impl_ty_own_bounds = impl_ty_predicates.instantiate_own(tcx, impl_substs);\n+\n+    if impl_ty_own_bounds.is_empty() {\n+        // Nothing to check.\n+        return Ok(());\n+    }\n+\n+    // This `HirId` should be used for the `body_id` field on each\n+    // `ObligationCause` (and the `FnCtxt`). This is what\n+    // `regionck_item` expects.\n+    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id).unwrap();\n+    let cause = ObligationCause {\n+        span: impl_ty_span,\n+        body_id: impl_ty_hir_id,\n+        code: ObligationCauseCode::CompareImplTypeObligation {\n+            item_name: impl_ty.ident.name,\n+            impl_item_def_id: impl_ty.def_id,\n+            trait_item_def_id: trait_ty.def_id,\n+        },\n+    };\n+\n+    debug!(\"compare_type_predicate_entailment: trait_to_impl_substs={:?}\", trait_to_impl_substs);\n+\n+    // The predicates declared by the impl definition, the trait and the\n+    // associated type in the trait are assumed.\n+    let impl_predicates = tcx.predicates_of(impl_ty_predicates.parent.unwrap());\n+    let mut hybrid_preds = impl_predicates.instantiate_identity(tcx);\n+    hybrid_preds.predicates.extend(\n+        trait_ty_predicates.instantiate_own(tcx, trait_to_impl_substs).predicates);\n+\n+    debug!(\"compare_type_predicate_entailment: bounds={:?}\", hybrid_preds);\n+\n+    let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n+    let param_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&hybrid_preds.predicates),\n+        Reveal::UserFacing,\n+        None\n+    );\n+    let param_env = traits::normalize_param_env_or_error(tcx,\n+                                                         impl_ty.def_id,\n+                                                         param_env,\n+                                                         normalize_cause.clone());\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let inh = Inherited::new(infcx, impl_ty.def_id);\n+        let infcx = &inh.infcx;\n+\n+        debug!(\"compare_type_predicate_entailment: caller_bounds={:?}\",\n+               param_env.caller_bounds);\n+\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+\n+        for predicate in impl_ty_own_bounds.predicates {\n+            let traits::Normalized { value: predicate, obligations } =\n+                traits::normalize(&mut selcx, param_env, normalize_cause.clone(), &predicate);\n+\n+            inh.register_predicates(obligations);\n+            inh.register_predicate(traits::Obligation::new(cause.clone(), param_env, predicate));\n+        }\n+\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        if let Err(ref errors) = inh.fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(errors, None, false);\n+            return Err(ErrorReported);\n+        }\n+\n+        // Finally, resolve all regions. This catches wily misuses of\n+        // lifetime parameters.\n+        let fcx = FnCtxt::new(&inh, param_env, impl_ty_hir_id);\n+        fcx.regionck_item(impl_ty_hir_id, impl_ty_span, &[]);\n+\n+        Ok(())\n+    })\n+}\n+\n+fn assoc_item_kind_str(impl_item: &ty::AssocItem) -> &'static str {\n+    match impl_item.kind {\n+        ty::AssocKind::Const => \"const\",\n+        ty::AssocKind::Method => \"method\",\n+        ty::AssocKind::Type | ty::AssocKind::OpaqueTy => \"type\",\n+    }\n+}"}, {"sha": "113d3f273233029ad84886ccb6022e2b508f71b3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db6d0b163884187e80bb3cadb9241af7a51e4d34/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=db6d0b163884187e80bb3cadb9241af7a51e4d34", "patch": "@@ -154,7 +154,7 @@ pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n-pub use self::compare_method::{compare_impl_method, compare_const_impl};\n+use self::compare_method::{compare_impl_method, compare_const_impl, compare_ty_impl};\n use self::method::{MethodCallee, SelfSource};\n use self::TupleArgumentsFlag::*;\n \n@@ -2014,41 +2014,50 @@ fn check_impl_items_against_trait<'tcx>(\n                     }\n                 }\n                 hir::ImplItemKind::Method(..) => {\n-                    let trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n+                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssocKind::Method {\n                         compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n-                                            trait_span);\n+                                            opt_trait_span);\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                             \"item `{}` is an associated method, \\\n                              which doesn't match its trait `{}`\",\n                             ty_impl_item.ident,\n                             impl_trait_ref.print_only_trait_path());\n                          err.span_label(impl_item.span, \"does not match trait\");\n-                         if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = opt_trait_span {\n                             err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()\n                     }\n                 }\n                 hir::ImplItemKind::OpaqueTy(..) |\n                 hir::ImplItemKind::TyAlias(_) => {\n+                    let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssocKind::Type {\n                         if ty_trait_item.defaultness.has_value() {\n                             overridden_associated_type = Some(impl_item);\n                         }\n+                        compare_ty_impl(\n+                            tcx,\n+                            &ty_impl_item,\n+                            impl_item.span,\n+                            &ty_trait_item,\n+                            impl_trait_ref,\n+                            opt_trait_span,\n+                        )\n                     } else {\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                             \"item `{}` is an associated type, \\\n                              which doesn't match its trait `{}`\",\n                             ty_impl_item.ident,\n                             impl_trait_ref.print_only_trait_path());\n                          err.span_label(impl_item.span, \"does not match trait\");\n-                         if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n+                         if let Some(trait_span) = opt_trait_span {\n                             err.span_label(trait_span, \"item in trait\");\n                          }\n                          err.emit()"}]}