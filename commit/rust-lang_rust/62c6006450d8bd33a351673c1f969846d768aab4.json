{"sha": "62c6006450d8bd33a351673c1f969846d768aab4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzYwMDY0NTBkOGJkMzNhMzUxNjczYzFmOTY5ODQ2ZDc2OGFhYjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-26T20:45:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-26T20:45:47Z"}, "message": "Auto merge of #70441 - Dylan-DPC:rollup-qv7h2ph, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #70384 (Refactor object file handling)\n - #70397 (add 'fn write_u16s' to Memory)\n - #70413 (Fix incorrect pattern warning \"unreachable pattern\")\n - #70428 (`error_bad_item_kind`: add help text)\n - #70429 (Clean up E0459 explanation)\n - #70437 (Miri float->int casts: be explicit that this is saturating)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0edfb75370b8c0af344b9aad1d1a8adb2518ddcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0edfb75370b8c0af344b9aad1d1a8adb2518ddcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c6006450d8bd33a351673c1f969846d768aab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c6006450d8bd33a351673c1f969846d768aab4", "html_url": "https://github.com/rust-lang/rust/commit/62c6006450d8bd33a351673c1f969846d768aab4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c6006450d8bd33a351673c1f969846d768aab4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbb07525e2f07a815e780a4268b11916248b5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbb07525e2f07a815e780a4268b11916248b5a9", "html_url": "https://github.com/rust-lang/rust/commit/2fbb07525e2f07a815e780a4268b11916248b5a9"}, {"sha": "195147c7ae303acdc99cc9bcf920d1417e683a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/195147c7ae303acdc99cc9bcf920d1417e683a13", "html_url": "https://github.com/rust-lang/rust/commit/195147c7ae303acdc99cc9bcf920d1417e683a13"}], "stats": {"total": 394, "additions": 302, "deletions": 92}, "files": [{"sha": "1557630fc7afdaeb5cde12d33a9ee5536497f04e", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -16,7 +16,9 @@ use crate::ModuleLlvm;\n use log::debug;\n use rustc::bug;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::{run_assembler, CodegenContext, EmbedBitcode, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{\n+    run_assembler, BitcodeSection, CodegenContext, EmitObj, ModuleConfig,\n+};\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen, RLIB_BYTECODE_EXTENSION};\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -651,7 +653,7 @@ pub(crate) unsafe fn codegen(\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n-            if config.emit_bc || config.obj_is_bitcode {\n+            if config.emit_bc || config.emit_obj == EmitObj::Bitcode {\n                 let _timer = cgcx.prof.generic_activity_with_arg(\n                     \"LLVM_module_codegen_emit_bitcode\",\n                     &module.name[..],\n@@ -662,7 +664,7 @@ pub(crate) unsafe fn codegen(\n                 }\n             }\n \n-            if config.embed_bitcode == EmbedBitcode::Full {\n+            if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Full) {\n                 let _timer = cgcx.prof.generic_activity_with_arg(\n                     \"LLVM_module_codegen_embed_bitcode\",\n                     &module.name[..],\n@@ -682,7 +684,7 @@ pub(crate) unsafe fn codegen(\n                     diag_handler.err(&msg);\n                 }\n             }\n-        } else if config.embed_bitcode == EmbedBitcode::Marker {\n+        } else if config.emit_obj == EmitObj::ObjectCode(BitcodeSection::Marker) {\n             embed_bitcode(cgcx, llcx, llmod, None);\n         }\n \n@@ -732,9 +734,9 @@ pub(crate) unsafe fn codegen(\n             })?;\n         }\n \n-        let config_emit_normal_obj = config.emit_obj && !config.obj_is_bitcode;\n+        let config_emit_object_code = matches!(config.emit_obj, EmitObj::ObjectCode(_));\n \n-        if config.emit_asm || (config_emit_normal_obj && config.no_integrated_as) {\n+        if config.emit_asm || (config_emit_object_code && config.no_integrated_as) {\n             let _timer = cgcx\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n@@ -743,60 +745,65 @@ pub(crate) unsafe fn codegen(\n             // We can't use the same module for asm and binary output, because that triggers\n             // various errors like invalid IR or broken binaries, so we might have to clone the\n             // module to produce the asm output\n-            let llmod = if config.emit_obj { llvm::LLVMCloneModule(llmod) } else { llmod };\n+            let llmod = if config_emit_object_code { llvm::LLVMCloneModule(llmod) } else { llmod };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(diag_handler, tm, cpm, llmod, &path, llvm::FileType::AssemblyFile)\n             })?;\n         }\n \n-        if config_emit_normal_obj {\n-            if !config.no_integrated_as {\n-                let _timer = cgcx\n-                    .prof\n-                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n-                with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                    write_output_file(\n-                        diag_handler,\n-                        tm,\n-                        cpm,\n-                        llmod,\n-                        &obj_out,\n-                        llvm::FileType::ObjectFile,\n-                    )\n-                })?;\n-            } else {\n-                let _timer = cgcx\n-                    .prof\n-                    .generic_activity_with_arg(\"LLVM_module_codegen_asm_to_obj\", &module.name[..]);\n-                let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n-                run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n-\n-                if !config.emit_asm && !cgcx.save_temps {\n-                    drop(fs::remove_file(&assembly));\n+        match config.emit_obj {\n+            EmitObj::ObjectCode(_) => {\n+                if !config.no_integrated_as {\n+                    let _timer = cgcx.prof.generic_activity_with_arg(\n+                        \"LLVM_module_codegen_emit_obj\",\n+                        &module.name[..],\n+                    );\n+                    with_codegen(tm, llmod, config.no_builtins, |cpm| {\n+                        write_output_file(\n+                            diag_handler,\n+                            tm,\n+                            cpm,\n+                            llmod,\n+                            &obj_out,\n+                            llvm::FileType::ObjectFile,\n+                        )\n+                    })?;\n+                } else {\n+                    let _timer = cgcx.prof.generic_activity_with_arg(\n+                        \"LLVM_module_codegen_asm_to_obj\",\n+                        &module.name[..],\n+                    );\n+                    let assembly =\n+                        cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n+                    run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n+\n+                    if !config.emit_asm && !cgcx.save_temps {\n+                        drop(fs::remove_file(&assembly));\n+                    }\n                 }\n             }\n-        }\n \n-        if config.obj_is_bitcode {\n-            if config.emit_obj {\n+            EmitObj::Bitcode => {\n                 debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n                 if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n                     diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n                 }\n-            }\n \n-            if !config.emit_bc {\n-                debug!(\"removing_bitcode {:?}\", bc_out);\n-                if let Err(e) = fs::remove_file(&bc_out) {\n-                    diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+                if !config.emit_bc {\n+                    debug!(\"removing_bitcode {:?}\", bc_out);\n+                    if let Err(e) = fs::remove_file(&bc_out) {\n+                        diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+                    }\n                 }\n             }\n+\n+            EmitObj::None => {}\n         }\n \n         drop(handlers);\n     }\n     Ok(module.into_compiled_module(\n-        config.emit_obj,\n+        config.emit_obj != EmitObj::None,\n         config.emit_bc,\n         config.emit_bc_compressed,\n         &cgcx.output_filenames,"}, {"sha": "e9b3bf026b2ba5499977e91bbc8ddc1c99372129", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -51,11 +51,31 @@ use std::thread;\n \n const PRE_LTO_BC_EXT: &str = \"pre-lto.bc\";\n \n-/// The kind of bitcode to embed in object files.\n-#[derive(PartialEq)]\n-pub enum EmbedBitcode {\n+/// What kind of object file to emit.\n+#[derive(Clone, Copy, PartialEq)]\n+pub enum EmitObj {\n+    // No object file.\n     None,\n+\n+    // Just uncompressed llvm bitcode. Provides easy compatibility with\n+    // emscripten's ecc compiler, when used as the linker.\n+    Bitcode,\n+\n+    // Object code, possibly augmented with a bitcode section.\n+    ObjectCode(BitcodeSection),\n+}\n+\n+/// What kind of llvm bitcode section to embed in an object file.\n+#[derive(Clone, Copy, PartialEq)]\n+pub enum BitcodeSection {\n+    // No bitcode section.\n+    None,\n+\n+    // An empty bitcode section (to placate tools such as the iOS linker that\n+    // require this section even if they don't use it).\n     Marker,\n+\n+    // A full, uncompressed bitcode section.\n     Full,\n }\n \n@@ -84,7 +104,7 @@ pub struct ModuleConfig {\n     pub emit_bc_compressed: bool,\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n-    pub emit_obj: bool,\n+    pub emit_obj: EmitObj,\n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n     pub verify_llvm_ir: bool,\n@@ -96,12 +116,7 @@ pub struct ModuleConfig {\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n     pub new_llvm_pass_manager: Option<bool>,\n-    // Instead of creating an object file by doing LLVM codegen, just\n-    // make the object file bitcode. Provides easy compatibility with\n-    // emscripten's ecc compiler, when used as the linker.\n-    pub obj_is_bitcode: bool,\n     pub no_integrated_as: bool,\n-    pub embed_bitcode: EmbedBitcode,\n }\n \n impl ModuleConfig {\n@@ -124,9 +139,7 @@ impl ModuleConfig {\n             emit_bc_compressed: false,\n             emit_ir: false,\n             emit_asm: false,\n-            emit_obj: false,\n-            obj_is_bitcode: false,\n-            embed_bitcode: EmbedBitcode::None,\n+            emit_obj: EmitObj::None,\n             no_integrated_as: false,\n \n             verify_llvm_ir: false,\n@@ -147,17 +160,6 @@ impl ModuleConfig {\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n-        self.obj_is_bitcode =\n-            sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n-        self.embed_bitcode =\n-            if sess.target.target.options.embed_bitcode || sess.opts.debugging_opts.embed_bitcode {\n-                match sess.opts.optimize {\n-                    config::OptLevel::No | config::OptLevel::Less => EmbedBitcode::Marker,\n-                    _ => EmbedBitcode::Full,\n-                }\n-            } else {\n-                EmbedBitcode::None\n-            };\n \n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n@@ -194,9 +196,9 @@ impl ModuleConfig {\n \n     pub fn bitcode_needed(&self) -> bool {\n         self.emit_bc\n-            || self.obj_is_bitcode\n             || self.emit_bc_compressed\n-            || self.embed_bitcode == EmbedBitcode::Full\n+            || self.emit_obj == EmitObj::Bitcode\n+            || self.emit_obj == EmitObj::ObjectCode(BitcodeSection::Full)\n     }\n }\n \n@@ -397,6 +399,20 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         allocator_config.emit_bc_compressed = true;\n     }\n \n+    let emit_obj =\n+        if sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled() {\n+            EmitObj::Bitcode\n+        } else if sess.opts.debugging_opts.embed_bitcode {\n+            match sess.opts.optimize {\n+                config::OptLevel::No | config::OptLevel::Less => {\n+                    EmitObj::ObjectCode(BitcodeSection::Marker)\n+                }\n+                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n+            }\n+        } else {\n+            EmitObj::ObjectCode(BitcodeSection::None)\n+        };\n+\n     modules_config.emit_pre_lto_bc = need_pre_lto_bitcode_for_incr_comp(sess);\n \n     modules_config.no_integrated_as =\n@@ -416,20 +432,20 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n                 // could be invoked specially with output_type_assembly, so\n                 // in this case we still want the metadata object file.\n                 if !sess.opts.output_types.contains_key(&OutputType::Assembly) {\n-                    metadata_config.emit_obj = true;\n-                    allocator_config.emit_obj = true;\n+                    metadata_config.emit_obj = emit_obj;\n+                    allocator_config.emit_obj = emit_obj;\n                 }\n             }\n             OutputType::Object => {\n-                modules_config.emit_obj = true;\n+                modules_config.emit_obj = emit_obj;\n             }\n             OutputType::Metadata => {\n-                metadata_config.emit_obj = true;\n+                metadata_config.emit_obj = emit_obj;\n             }\n             OutputType::Exe => {\n-                modules_config.emit_obj = true;\n-                metadata_config.emit_obj = true;\n-                allocator_config.emit_obj = true;\n+                modules_config.emit_obj = emit_obj;\n+                metadata_config.emit_obj = emit_obj;\n+                allocator_config.emit_obj = emit_obj;\n             }\n             OutputType::Mir => {}\n             OutputType::DepInfo => {}\n@@ -880,7 +896,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         }\n     }\n \n-    assert_eq!(object.is_some(), module_config.emit_obj);\n+    assert_eq!(object.is_some(), module_config.emit_obj != EmitObj::None);\n     assert_eq!(bytecode.is_some(), module_config.emit_bc);\n     assert_eq!(bytecode_compressed.is_some(), module_config.emit_bc_compressed);\n "}, {"sha": "6f75f2a99a563409ec581258fd33ae1d4a116842", "filename": "src/librustc_error_codes/error_codes/E0459.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1,4 +1,6 @@\n-A link was used without a name parameter. Erroneous code example:\n+A link was used without a name parameter.\n+\n+Erroneous code example:\n \n ```compile_fail,E0459\n #[link(kind = \"dylib\")] extern {}"}, {"sha": "24176427ba526aebb9fcc722b28329a028283b95", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -229,13 +229,17 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // float -> uint\n             Uint(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                // `to_u128` is a saturating cast, which is what we need\n+                // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_u128(usize::try_from(width).unwrap()).value;\n                 // This should already fit the bit width\n                 Ok(Scalar::from_uint(v, Size::from_bits(width)))\n             }\n             // float -> int\n             Int(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits());\n+                // `to_i128` is a saturating cast, which is what we need\n+                // (https://doc.rust-lang.org/nightly/nightly-rustc/rustc_apfloat/trait.Float.html#method.to_i128_r).\n                 let v = f.to_i128(usize::try_from(width).unwrap()).value;\n                 Ok(Scalar::from_int(v, Size::from_bits(width)))\n             }"}, {"sha": "7b6de4b0726c1ccce907cf29b4ab8fb939bee9a9", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -833,17 +833,57 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr: Scalar<M::PointerTag>,\n         src: impl IntoIterator<Item = u8>,\n     ) -> InterpResult<'tcx> {\n-        let src = src.into_iter();\n+        let mut src = src.into_iter();\n         let size = Size::from_bytes(src.size_hint().0);\n         // `write_bytes` checks that this lower bound `size` matches the upper bound and reality.\n         let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(1).unwrap())? {\n             Some(ptr) => ptr,\n-            None => return Ok(()), // zero-sized access\n+            None => {\n+                // zero-sized access\n+                src.next().expect_none(\"iterator said it was empty but returned an element\");\n+                return Ok(());\n+            }\n         };\n         let tcx = self.tcx.tcx;\n         self.get_raw_mut(ptr.alloc_id)?.write_bytes(&tcx, ptr, src)\n     }\n \n+    /// Writes the given stream of u16s into memory.\n+    ///\n+    /// Performs appropriate bounds checks.\n+    pub fn write_u16s(\n+        &mut self,\n+        ptr: Scalar<M::PointerTag>,\n+        src: impl IntoIterator<Item = u16>,\n+    ) -> InterpResult<'tcx> {\n+        let mut src = src.into_iter();\n+        let (lower, upper) = src.size_hint();\n+        let len = upper.expect(\"can only write bounded iterators\");\n+        assert_eq!(lower, len, \"can only write iterators with a precise length\");\n+\n+        let size = Size::from_bytes(lower);\n+        let ptr = match self.check_ptr_access(ptr, size, Align::from_bytes(2).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => {\n+                // zero-sized access\n+                src.next().expect_none(\"iterator said it was empty but returned an element\");\n+                return Ok(());\n+            }\n+        };\n+        let tcx = self.tcx.tcx;\n+        let allocation = self.get_raw_mut(ptr.alloc_id)?;\n+\n+        for idx in 0..len {\n+            let val = Scalar::from_u16(\n+                src.next().expect(\"iterator was shorter than it said it would be\"),\n+            );\n+            let offset_ptr = ptr.offset(Size::from_bytes(idx) * 2, &tcx)?; // `Size` multiplication\n+            allocation.write_scalar(&tcx, offset_ptr, val.into(), Size::from_bytes(2))?;\n+        }\n+        src.next().expect_none(\"iterator was longer than it said it would be\");\n+        Ok(())\n+    }\n+\n     /// Expects the caller to have checked bounds and alignment.\n     pub fn copy(\n         &mut self,"}, {"sha": "85e44adc30b86a14c76f50e6fd82ee7426d44f65", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -24,6 +24,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(range_is_empty)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]\n+#![feature(option_expect_none)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "5c69cea8b9169d1fc22241948f5722dfc055ded7", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1619,12 +1619,17 @@ impl<'tcx> fmt::Debug for MissingConstructors<'tcx> {\n /// relation to preceding patterns, it is not reachable) and exhaustiveness\n /// checking (if a wildcard pattern is useful in relation to a matrix, the\n /// matrix isn't exhaustive).\n+///\n+/// `is_under_guard` is used to inform if the pattern has a guard. If it\n+/// has one it must not be inserted into the matrix. This shouldn't be\n+/// relied on for soundness.\n crate fn is_useful<'p, 'tcx>(\n     cx: &mut MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n+    is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'tcx, 'p> {\n     let &Matrix(ref rows) = matrix;\n@@ -1653,7 +1658,7 @@ crate fn is_useful<'p, 'tcx>(\n         let mut unreachable_pats = Vec::new();\n         let mut any_is_useful = false;\n         for v in vs {\n-            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, false);\n+            let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             match res {\n                 Useful(pats) => {\n                     any_is_useful = true;\n@@ -1664,7 +1669,10 @@ crate fn is_useful<'p, 'tcx>(\n                     bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n                 }\n             }\n-            matrix.push(v);\n+            // If pattern has a guard don't add it to the matrix\n+            if !is_under_guard {\n+                matrix.push(v);\n+            }\n         }\n         return if any_is_useful { Useful(unreachable_pats) } else { NotUseful };\n     }\n@@ -1712,7 +1720,18 @@ crate fn is_useful<'p, 'tcx>(\n             Some(hir_id),\n         )\n         .into_iter()\n-        .map(|c| is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id))\n+        .map(|c| {\n+            is_useful_specialized(\n+                cx,\n+                matrix,\n+                v,\n+                c,\n+                pcx.ty,\n+                witness_preference,\n+                hir_id,\n+                is_under_guard,\n+            )\n+        })\n         .find(|result| result.is_useful())\n         .unwrap_or(NotUseful)\n     } else {\n@@ -1746,14 +1765,24 @@ crate fn is_useful<'p, 'tcx>(\n             split_grouped_constructors(cx.tcx, cx.param_env, pcx, all_ctors, matrix, DUMMY_SP, None)\n                 .into_iter()\n                 .map(|c| {\n-                    is_useful_specialized(cx, matrix, v, c, pcx.ty, witness_preference, hir_id)\n+                    is_useful_specialized(\n+                        cx,\n+                        matrix,\n+                        v,\n+                        c,\n+                        pcx.ty,\n+                        witness_preference,\n+                        hir_id,\n+                        is_under_guard,\n+                    )\n                 })\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n             let matrix = matrix.specialize_wildcard();\n             let v = v.to_tail();\n-            let usefulness = is_useful(cx, &matrix, &v, witness_preference, hir_id, false);\n+            let usefulness =\n+                is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n \n             // In this case, there's at least one \"free\"\n             // constructor that is only matched against by\n@@ -1810,14 +1839,15 @@ fn is_useful_specialized<'p, 'tcx>(\n     lty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n+    is_under_guard: bool,\n ) -> Usefulness<'tcx, 'p> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n \n     let ctor_wild_subpatterns =\n         cx.pattern_arena.alloc_from_iter(ctor.wildcard_subpatterns(cx, lty));\n     let matrix = matrix.specialize_constructor(cx, &ctor, ctor_wild_subpatterns);\n     v.specialize_constructor(cx, &ctor, ctor_wild_subpatterns)\n-        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, false))\n+        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, lty))\n         .unwrap_or(NotUseful)\n }"}, {"sha": "c2eeac60b8b3bc709e2357f123f67ca2c0622ec4", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -360,7 +360,7 @@ fn check_arms<'p, 'tcx>(\n     let mut catchall = None;\n     for (arm_index, (pat, id, has_guard)) in arms.iter().copied().enumerate() {\n         let v = PatStack::from_pattern(pat);\n-        match is_useful(cx, &seen, &v, LeaveOutWitness, id, true) {\n+        match is_useful(cx, &seen, &v, LeaveOutWitness, id, has_guard, true) {\n             NotUseful => {\n                 match source {\n                     hir::MatchSource::IfDesugar { .. } | hir::MatchSource::WhileDesugar => bug!(),\n@@ -410,7 +410,10 @@ fn check_not_useful<'p, 'tcx>(\n ) -> Result<(), Vec<super::Pat<'tcx>>> {\n     let wild_pattern = cx.pattern_arena.alloc(super::Pat::wildcard_from_ty(ty));\n     let v = PatStack::from_pattern(wild_pattern);\n-    match is_useful(cx, matrix, &v, ConstructWitness, hir_id, true) {\n+\n+    // false is given for `is_under_guard` argument due to the wildcard\n+    // pattern not having a guard\n+    match is_useful(cx, matrix, &v, ConstructWitness, hir_id, false, true) {\n         NotUseful => Ok(()), // This is good, wildcard pattern isn't reachable.\n         UsefulWithWitness(pats) => Err(if pats.is_empty() {\n             bug!(\"Exhaustiveness check returned no witnesses\")"}, {"sha": "6b7a9ec658dffd296735d6754258ed9bcc47be48", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -908,8 +908,10 @@ impl<'a> Parser<'a> {\n \n     fn error_bad_item_kind<T>(&self, span: Span, kind: &ItemKind, ctx: &str) -> Option<T> {\n         let span = self.sess.source_map().guess_head_span(span);\n-        let msg = format!(\"{} is not supported in {}\", kind.descr(), ctx);\n-        self.struct_span_err(span, &msg).emit();\n+        let descr = kind.descr();\n+        self.struct_span_err(span, &format!(\"{} is not supported in {}\", descr, ctx))\n+            .help(&format!(\"consider moving the {} out to a nearby module scope\", descr))\n+            .emit();\n         None\n     }\n "}, {"sha": "6d688c12977e3acf4ba43db0258bb0263cb8bc15", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -771,9 +771,6 @@ pub struct TargetOptions {\n     /// rather than \"default\"\n     pub default_hidden_visibility: bool,\n \n-    /// Whether or not bitcode is embedded in object files\n-    pub embed_bitcode: bool,\n-\n     /// Whether a .debug_gdb_scripts section will be added to the output object file\n     pub emit_debug_gdb_scripts: bool,\n \n@@ -893,7 +890,6 @@ impl Default for TargetOptions {\n             no_builtins: false,\n             codegen_backend: \"llvm\".to_string(),\n             default_hidden_visibility: false,\n-            embed_bitcode: false,\n             emit_debug_gdb_scripts: true,\n             requires_uwtable: false,\n             simd_types_indirect: true,\n@@ -1208,7 +1204,6 @@ impl Target {\n         key!(no_builtins, bool);\n         key!(codegen_backend);\n         key!(default_hidden_visibility, bool);\n-        key!(embed_bitcode, bool);\n         key!(emit_debug_gdb_scripts, bool);\n         key!(requires_uwtable, bool);\n         key!(simd_types_indirect, bool);\n@@ -1437,7 +1432,6 @@ impl ToJson for Target {\n         target_option_val!(no_builtins);\n         target_option_val!(codegen_backend);\n         target_option_val!(default_hidden_visibility);\n-        target_option_val!(embed_bitcode);\n         target_option_val!(emit_debug_gdb_scripts);\n         target_option_val!(requires_uwtable);\n         target_option_val!(simd_types_indirect);"}, {"sha": "eb6706e50006f7d6c005664a3a6261786a0410d0", "filename": "src/test/ui/or-patterns/issue-70413-no-unreachable-pat-and-guard.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2For-patterns%2Fissue-70413-no-unreachable-pat-and-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2For-patterns%2Fissue-70413-no-unreachable-pat-and-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-70413-no-unreachable-pat-and-guard.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![deny(unreachable_patterns)]\n+\n+#![feature(or_patterns)]\n+fn main() {\n+    match (3,42) {\n+        (a,_) | (_,a) if a > 10 => {println!(\"{}\", a)}\n+        _ => ()\n+    }\n+\n+    match Some((3,42)) {\n+        Some((a, _)) | Some((_, a)) if a > 10 => {println!(\"{}\", a)}\n+        _ => ()\n+\n+    }\n+\n+    match Some((3,42)) {\n+        Some((a, _) | (_, a)) if a > 10 => {println!(\"{}\", a)}\n+        _ => ()\n+    }\n+}"}, {"sha": "af513f7617b09aeaf3dc318aeba1322b34bfcbcd", "filename": "src/test/ui/parser/default-on-wrong-item-kind.stderr", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fdefault-on-wrong-item-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fdefault-on-wrong-item-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdefault-on-wrong-item-kind.stderr?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -123,6 +123,8 @@ error: extern crate is not supported in `extern` blocks\n    |\n LL |     default extern crate foo;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern crate out to a nearby module scope\n \n error: a `use` import cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:35:5\n@@ -137,6 +139,8 @@ error: `use` import is not supported in `extern` blocks\n    |\n LL |     default use foo;\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the `use` import out to a nearby module scope\n \n error: a static item cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:37:5\n@@ -169,6 +173,8 @@ error: module is not supported in `extern` blocks\n    |\n LL |     default mod foo {}\n    |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the module out to a nearby module scope\n \n error: an extern block cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:43:5\n@@ -183,6 +189,8 @@ error: extern block is not supported in `extern` blocks\n    |\n LL |     default extern \"C\" {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern block out to a nearby module scope\n \n error: an enum cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:46:5\n@@ -197,6 +205,8 @@ error: enum is not supported in `extern` blocks\n    |\n LL |     default enum foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the enum out to a nearby module scope\n \n error: a struct cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:48:5\n@@ -211,6 +221,8 @@ error: struct is not supported in `extern` blocks\n    |\n LL |     default struct foo {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: a union cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:50:5\n@@ -225,6 +237,8 @@ error: union is not supported in `extern` blocks\n    |\n LL |     default union foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the union out to a nearby module scope\n \n error: a trait cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:52:5\n@@ -239,6 +253,8 @@ error: trait is not supported in `extern` blocks\n    |\n LL |     default trait foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait out to a nearby module scope\n \n error: a trait alias cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:54:5\n@@ -253,12 +269,16 @@ error: trait alias is not supported in `extern` blocks\n    |\n LL |     default trait foo = Ord;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait alias out to a nearby module scope\n \n error: implementation is not supported in `extern` blocks\n   --> $DIR/default-on-wrong-item-kind.rs:56:5\n    |\n LL |     default impl foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the implementation out to a nearby module scope\n \n error: an item macro invocation cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:60:5\n@@ -289,6 +309,8 @@ error: macro definition is not supported in `extern` blocks\n    |\n LL |     default macro foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: a macro definition cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:64:5\n@@ -303,6 +325,8 @@ error: macro definition is not supported in `extern` blocks\n    |\n LL |     default macro_rules! foo {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: an extern crate cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:70:5\n@@ -317,6 +341,8 @@ error: extern crate is not supported in `trait`s or `impl`s\n    |\n LL |     default extern crate foo;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern crate out to a nearby module scope\n \n error: a `use` import cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:72:5\n@@ -331,6 +357,8 @@ error: `use` import is not supported in `trait`s or `impl`s\n    |\n LL |     default use foo;\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the `use` import out to a nearby module scope\n \n error: a static item cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:74:5\n@@ -359,6 +387,8 @@ error: module is not supported in `trait`s or `impl`s\n    |\n LL |     default mod foo {}\n    |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the module out to a nearby module scope\n \n error: an extern block cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:80:5\n@@ -373,6 +403,8 @@ error: extern block is not supported in `trait`s or `impl`s\n    |\n LL |     default extern \"C\" {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern block out to a nearby module scope\n \n error: an enum cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:83:5\n@@ -387,6 +419,8 @@ error: enum is not supported in `trait`s or `impl`s\n    |\n LL |     default enum foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the enum out to a nearby module scope\n \n error: a struct cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:85:5\n@@ -401,6 +435,8 @@ error: struct is not supported in `trait`s or `impl`s\n    |\n LL |     default struct foo {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: a union cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:87:5\n@@ -415,6 +451,8 @@ error: union is not supported in `trait`s or `impl`s\n    |\n LL |     default union foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the union out to a nearby module scope\n \n error: a trait cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:89:5\n@@ -429,6 +467,8 @@ error: trait is not supported in `trait`s or `impl`s\n    |\n LL |     default trait foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait out to a nearby module scope\n \n error: a trait alias cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:91:5\n@@ -443,12 +483,16 @@ error: trait alias is not supported in `trait`s or `impl`s\n    |\n LL |     default trait foo = Ord;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait alias out to a nearby module scope\n \n error: implementation is not supported in `trait`s or `impl`s\n   --> $DIR/default-on-wrong-item-kind.rs:93:5\n    |\n LL |     default impl foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the implementation out to a nearby module scope\n \n error: an item macro invocation cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:97:5\n@@ -479,6 +523,8 @@ error: macro definition is not supported in `trait`s or `impl`s\n    |\n LL |     default macro foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: a macro definition cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:101:5\n@@ -493,6 +539,8 @@ error: macro definition is not supported in `trait`s or `impl`s\n    |\n LL |     default macro_rules! foo {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: an extern crate cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:107:5\n@@ -507,6 +555,8 @@ error: extern crate is not supported in `trait`s or `impl`s\n    |\n LL |     default extern crate foo;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern crate out to a nearby module scope\n \n error: a `use` import cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:109:5\n@@ -521,6 +571,8 @@ error: `use` import is not supported in `trait`s or `impl`s\n    |\n LL |     default use foo;\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the `use` import out to a nearby module scope\n \n error: a static item cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:111:5\n@@ -549,6 +601,8 @@ error: module is not supported in `trait`s or `impl`s\n    |\n LL |     default mod foo {}\n    |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the module out to a nearby module scope\n \n error: an extern block cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:117:5\n@@ -563,6 +617,8 @@ error: extern block is not supported in `trait`s or `impl`s\n    |\n LL |     default extern \"C\" {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the extern block out to a nearby module scope\n \n error: an enum cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:120:5\n@@ -577,6 +633,8 @@ error: enum is not supported in `trait`s or `impl`s\n    |\n LL |     default enum foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the enum out to a nearby module scope\n \n error: a struct cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:122:5\n@@ -591,6 +649,8 @@ error: struct is not supported in `trait`s or `impl`s\n    |\n LL |     default struct foo {}\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: a union cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:124:5\n@@ -605,6 +665,8 @@ error: union is not supported in `trait`s or `impl`s\n    |\n LL |     default union foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the union out to a nearby module scope\n \n error: a trait cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:126:5\n@@ -619,6 +681,8 @@ error: trait is not supported in `trait`s or `impl`s\n    |\n LL |     default trait foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait out to a nearby module scope\n \n error: a trait alias cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:128:5\n@@ -633,12 +697,16 @@ error: trait alias is not supported in `trait`s or `impl`s\n    |\n LL |     default trait foo = Ord;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the trait alias out to a nearby module scope\n \n error: implementation is not supported in `trait`s or `impl`s\n   --> $DIR/default-on-wrong-item-kind.rs:130:5\n    |\n LL |     default impl foo {}\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the implementation out to a nearby module scope\n \n error: an item macro invocation cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:134:5\n@@ -669,6 +737,8 @@ error: macro definition is not supported in `trait`s or `impl`s\n    |\n LL |     default macro foo {}\n    |     ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: a macro definition cannot be `default`\n   --> $DIR/default-on-wrong-item-kind.rs:138:5\n@@ -683,6 +753,8 @@ error: macro definition is not supported in `trait`s or `impl`s\n    |\n LL |     default macro_rules! foo {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the macro definition out to a nearby module scope\n \n error: aborting due to 95 previous errors\n "}, {"sha": "c83205aadd6729a28b408be3b617e8babe5300bc", "filename": "src/test/ui/parser/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.stderr", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fissue-48137-macros-cannot-interpolate-impl-items-bad-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fissue-48137-macros-cannot-interpolate-impl-items-bad-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-48137-macros-cannot-interpolate-impl-items-bad-variants.stderr?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -3,6 +3,8 @@ error: struct is not supported in `trait`s or `impl`s\n    |\n LL |     struct BadS;\n    |     ^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: enum is not supported in `trait`s or `impl`s\n   --> $DIR/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.rs:5:9\n@@ -13,13 +15,16 @@ LL |         enum BadE {}\n LL |     expand_to_enum!();\n    |     ------------------ in this macro invocation\n    |\n+   = help: consider moving the enum out to a nearby module scope\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: struct is not supported in `trait`s or `impl`s\n   --> $DIR/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.rs:31:5\n    |\n LL |     struct BadS;\n    |     ^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: enum is not supported in `trait`s or `impl`s\n   --> $DIR/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.rs:5:9\n@@ -30,13 +35,16 @@ LL |         enum BadE {}\n LL |     expand_to_enum!();\n    |     ------------------ in this macro invocation\n    |\n+   = help: consider moving the enum out to a nearby module scope\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: struct is not supported in `extern` blocks\n   --> $DIR/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.rs:42:5\n    |\n LL |     struct BadS;\n    |     ^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: enum is not supported in `extern` blocks\n   --> $DIR/issue-48137-macros-cannot-interpolate-impl-items-bad-variants.rs:5:9\n@@ -47,6 +55,7 @@ LL |         enum BadE {}\n LL |     expand_to_enum!();\n    |     ------------------ in this macro invocation\n    |\n+   = help: consider moving the enum out to a nearby module scope\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors"}, {"sha": "cc7cc0c55d5ff1fe08d379bd3b593d306022e827", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-impl-trait.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-impl-trait.stderr?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -12,12 +12,16 @@ error: trait is not supported in `trait`s or `impl`s\n    |\n LL | trait T {\n    | ^^^^^^^\n+   |\n+   = help: consider moving the trait out to a nearby module scope\n \n error: struct is not supported in `trait`s or `impl`s\n   --> $DIR/missing-close-brace-in-impl-trait.rs:11:1\n    |\n LL | pub(crate) struct Bar<T>();\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error[E0405]: cannot find trait `T` in this scope\n   --> $DIR/missing-close-brace-in-impl-trait.rs:3:6"}, {"sha": "7c6254356e0774be199e69435119fbc6f47d53df", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -12,12 +12,16 @@ error: struct is not supported in `trait`s or `impl`s\n    |\n LL | pub(crate) struct Bar<T>();\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the struct out to a nearby module scope\n \n error: implementation is not supported in `trait`s or `impl`s\n   --> $DIR/missing-close-brace-in-trait.rs:7:1\n    |\n LL | impl T for Bar<usize> {\n    | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider moving the implementation out to a nearby module scope\n \n error: aborting due to 3 previous errors\n "}]}