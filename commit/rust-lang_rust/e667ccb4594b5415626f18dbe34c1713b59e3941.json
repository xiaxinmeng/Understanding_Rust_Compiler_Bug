{"sha": "e667ccb4594b5415626f18dbe34c1713b59e3941", "node_id": "C_kwDOAAsO6NoAKGU2NjdjY2I0NTk0YjU0MTU2MjZmMThkYmUzNGMxNzEzYjU5ZTM5NDE", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-26T03:22:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-26T03:40:58Z"}, "message": "test that futexes induce appropriate synchronization", "tree": {"sha": "794a0e15bc876207aa81a43c9255bd892d98ca44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/794a0e15bc876207aa81a43c9255bd892d98ca44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e667ccb4594b5415626f18dbe34c1713b59e3941", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e667ccb4594b5415626f18dbe34c1713b59e3941", "html_url": "https://github.com/rust-lang/rust/commit/e667ccb4594b5415626f18dbe34c1713b59e3941", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e667ccb4594b5415626f18dbe34c1713b59e3941/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e2dac4787e5470ecd9e245420e8da9528620edd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e2dac4787e5470ecd9e245420e8da9528620edd", "html_url": "https://github.com/rust-lang/rust/commit/9e2dac4787e5470ecd9e245420e8da9528620edd"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "b65dd46d5974cf46c1b21fc3790e6eba98bac8b1", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e667ccb4594b5415626f18dbe34c1713b59e3941/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e667ccb4594b5415626f18dbe34c1713b59e3941/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=e667ccb4594b5415626f18dbe34c1713b59e3941", "patch": "@@ -222,11 +222,17 @@ fn wait_wake_bitset() {\n     t.join().unwrap();\n }\n \n-const FREE: i32 = 0;\n-const HELD: i32 = 1;\n fn concurrent_wait_wake() {\n+    const FREE: i32 = 0;\n+    const HELD: i32 = 1;\n+\n     static FUTEX: AtomicI32 = AtomicI32::new(0);\n-    for _ in 0..20 {\n+    static mut DATA: i32 = 0;\n+    static WOKEN: AtomicI32 = AtomicI32::new(0);\n+\n+    let rounds = 50;\n+    for _ in 0..rounds {\n+        unsafe { DATA = 0 }; // Reset\n         // Suppose the main thread is holding a lock implemented using futex...\n         FUTEX.store(HELD, Ordering::Relaxed);\n \n@@ -239,23 +245,41 @@ fn concurrent_wait_wake() {\n             // the FUTEX is FREE != HELD and return without waiting\n             // or we'll deadlock.\n             unsafe {\n-                libc::syscall(\n+                let ret = libc::syscall(\n                     libc::SYS_futex,\n                     &FUTEX as *const AtomicI32,\n                     libc::FUTEX_WAIT,\n                     HELD,\n                     ptr::null::<libc::timespec>(),\n                 );\n+                if ret == 0 {\n+                    // We actually slept. And then woke up again. So we should be ordered-after\n+                    // what happened-before the FUTEX_WAKE. So this is not a race.\n+                    assert_eq!(DATA, 1);\n+                    // Also remember that this happened at least once.\n+                    WOKEN.fetch_add(1, Ordering::Relaxed);\n+                }\n             }\n         });\n+        // Increase the chance that the other thread actually goes to sleep.\n+        // (5 yields in a loop seem to make that happen around 40% of the time.)\n+        for _ in 0..5 {\n+            thread::yield_now();\n+        }\n \n         FUTEX.store(FREE, Ordering::Relaxed);\n         unsafe {\n+            DATA = 1;\n             libc::syscall(libc::SYS_futex, &FUTEX as *const AtomicI32, libc::FUTEX_WAKE, 1);\n         }\n \n         t.join().unwrap();\n     }\n+\n+    // Make sure we got the interesting case (of having woken a thread) at least once, but not *each* time.\n+    let woken = WOKEN.load(Ordering::Relaxed);\n+    assert!(woken > 0 && woken < rounds);\n+    //eprintln!(\"waking happened {woken} times\");\n }\n \n fn main() {"}]}