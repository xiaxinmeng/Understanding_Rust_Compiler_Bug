{"sha": "210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMGRkNjExYWExYmQ4MGVkMmY0ZTY2M2IzYzRiODdiM2NlYTA2OWE=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-02-28T22:38:48Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2016-03-07T19:39:39Z"}, "message": "implement the `?` operator\n\nThe `?` postfix operator is sugar equivalent to the try! macro, but is more amenable to chaining:\n`File::open(\"foo\")?.metadata()?.is_dir()`.\n\n`?` is accepted on any *expression* that can return a `Result`, e.g. `x()?`, `y!()?`, `{z}?`,\n`(w)?`, etc. And binds more tightly than unary operators, e.g. `!x?` is parsed as `!(x?)`.\n\ncc #31436", "tree": {"sha": "ad6c6e804d47524cce05caaf60d22ac8d62d2935", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad6c6e804d47524cce05caaf60d22ac8d62d2935"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "html_url": "https://github.com/rust-lang/rust/commit/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/comments", "author": null, "committer": null, "parents": [{"sha": "c116ae35cf49b55bd8d82e31f1ba030cf7e63867", "url": "https://api.github.com/repos/rust-lang/rust/commits/c116ae35cf49b55bd8d82e31f1ba030cf7e63867", "html_url": "https://github.com/rust-lang/rust/commit/c116ae35cf49b55bd8d82e31f1ba030cf7e63867"}], "stats": {"total": 357, "additions": 355, "deletions": 2}, "files": [{"sha": "94b2b12dca31c298fcd031de94b2d9367408cc90", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -344,6 +344,10 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         hir::MatchSource::Normal => {\n                             span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n                         },\n+\n+                        hir::MatchSource::TryDesugar => {\n+                            cx.tcx.sess.span_bug(pat.span, \"unreachable try pattern\")\n+                        },\n                     }\n                 }\n                 Useful => (),"}, {"sha": "ece62364376fc75b0ecd911c6dadc009870cd70f", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -835,6 +835,7 @@ pub enum MatchSource {\n     },\n     WhileLetDesugar,\n     ForLoopDesugar,\n+    TryDesugar,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]"}, {"sha": "291df66755e7d80359f00920936b6357318b2b6d", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -1605,6 +1605,63 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 });\n             }\n \n+            // Desugar ExprKind::Try\n+            // From: `<expr>?`\n+            ExprKind::Try(ref sub_expr) => {\n+                // to:\n+                //\n+                // {\n+                //     match <expr> {\n+                //         Ok(val) => val,\n+                //         Err(err) => {\n+                //             return Err(From::from(err))\n+                //         }\n+                //     }\n+                // }\n+\n+                return cache_ids(lctx, e.id, |lctx| {\n+                    // expand <expr>\n+                    let sub_expr = lower_expr(lctx, sub_expr);\n+\n+                    // Ok(val) => val\n+                    let ok_arm = {\n+                        let val_ident = lctx.str_to_ident(\"val\");\n+                        let val_pat = pat_ident(lctx, e.span, val_ident);\n+                        let val_expr = expr_ident(lctx, e.span, val_ident, None);\n+                        let ok_pat = pat_ok(lctx, e.span, val_pat);\n+\n+                        arm(hir_vec![ok_pat], val_expr)\n+                    };\n+\n+                    // Err(err) => return Err(From::from(err))\n+                    let err_arm = {\n+                        let err_ident = lctx.str_to_ident(\"err\");\n+                        let from_expr = {\n+                            let path = std_path(lctx, &[\"convert\", \"From\", \"from\"]);\n+                            let path = path_global(e.span, path);\n+                            let from = expr_path(lctx, path, None);\n+                            let err_expr = expr_ident(lctx, e.span, err_ident, None);\n+\n+                            expr_call(lctx, e.span, from, hir_vec![err_expr], None)\n+                        };\n+                        let err_expr = {\n+                            let path = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n+                            let path = path_global(e.span, path);\n+                            let err_ctor = expr_path(lctx, path, None);\n+                            expr_call(lctx, e.span, err_ctor, hir_vec![from_expr], None)\n+                        };\n+                        let err_pat = pat_err(lctx, e.span, pat_ident(lctx, e.span, err_ident));\n+                        let ret_expr = expr(lctx, e.span,\n+                                            hir::Expr_::ExprRet(Some(err_expr)), None);\n+\n+                        arm(hir_vec![err_pat], ret_expr)\n+                    };\n+\n+                    expr_match(lctx, e.span, sub_expr, hir_vec![err_arm, ok_arm],\n+                               hir::MatchSource::TryDesugar, None)\n+                })\n+            }\n+\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n@@ -1819,6 +1876,18 @@ fn block_all(lctx: &LoweringContext,\n     })\n }\n \n+fn pat_ok(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    let ok = std_path(lctx, &[\"result\", \"Result\", \"Ok\"]);\n+    let path = path_global(span, ok);\n+    pat_enum(lctx, span, path, hir_vec![pat])\n+}\n+\n+fn pat_err(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    let err = std_path(lctx, &[\"result\", \"Result\", \"Err\"]);\n+    let path = path_global(span, err);\n+    pat_enum(lctx, span, path, hir_vec![pat])\n+}\n+\n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n     let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n     let path = path_global(span, some);"}, {"sha": "342ba60e553b0012e29b009286ad97ae2205d699", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -1022,6 +1022,9 @@ pub enum ExprKind {\n \n     /// No-op: used solely so we can pretty-print faithfully\n     Paren(P<Expr>),\n+\n+    /// `expr?`\n+    Try(P<Expr>),\n }\n \n /// The explicit Self type in a \"qualified path\". The actual"}, {"sha": "14a3f93738a32a9aa6dc7d43595593d7ba661830", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -245,6 +245,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // a...b and ...b\n     (\"inclusive_range_syntax\", \"1.7.0\", Some(28237), Active),\n+\n+    // `expr?`\n+    (\"question_mark\", \"1.9.0\", Some(31436), Active)\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -570,6 +573,7 @@ pub struct Features {\n     pub staged_api: bool,\n     pub stmt_expr_attributes: bool,\n     pub deprecated: bool,\n+    pub question_mark: bool,\n }\n \n impl Features {\n@@ -603,6 +607,7 @@ impl Features {\n             staged_api: false,\n             stmt_expr_attributes: false,\n             deprecated: false,\n+            question_mark: false,\n         }\n     }\n }\n@@ -1001,6 +1006,9 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   e.span,\n                                   \"inclusive range syntax is experimental\");\n             }\n+            ast::ExprKind::Try(..) => {\n+                self.gate_feature(\"question_mark\", e.span, \"the `?` operator is not stable\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);\n@@ -1203,6 +1211,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n         staged_api: cx.has_feature(\"staged_api\"),\n         stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n         deprecated: cx.has_feature(\"deprecated\"),\n+        question_mark: cx.has_feature(\"question_mark\"),\n     }\n }\n "}, {"sha": "9056103d30086bbdd7e1bd6f9f45a355e4dae187", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -1332,7 +1332,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                         fields.move_map(|x| folder.fold_field(x)),\n                         maybe_expr.map(|x| folder.fold_expr(x)))\n             },\n-            ExprKind::Paren(ex) => ExprKind::Paren(folder.fold_expr(ex))\n+            ExprKind::Paren(ex) => ExprKind::Paren(folder.fold_expr(ex)),\n+            ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n         },\n         span: folder.new_span(span),\n         attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),"}, {"sha": "53b5341542987a0f03cede810a3cf66b03730881", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -2534,6 +2534,12 @@ impl<'a> Parser<'a> {\n         let mut e = e0;\n         let mut hi;\n         loop {\n+            // expr?\n+            while self.eat(&token::Question) {\n+                let hi = self.span.hi;\n+                e = self.mk_expr(lo, hi, ExprKind::Try(e), None);\n+            }\n+\n             // expr.f\n             if self.eat(&token::Dot) {\n                 match self.token {\n@@ -2907,7 +2913,6 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-\n         if self.expr_is_complete(&lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n             return Ok(lhs);"}, {"sha": "2cfed1f82f7ecd455788845cfa85db68f1ba2043", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -2277,6 +2277,10 @@ impl<'a> State<'a> {\n                 try!(self.print_inner_attributes_inline(attrs));\n                 try!(self.print_expr(&e));\n                 try!(self.pclose());\n+            },\n+            ast::ExprKind::Try(ref e) => {\n+                try!(self.print_expr(e));\n+                try!(word(&mut self.s, \"?\"))\n             }\n         }\n         try!(self.ann.post(self, NodeExpr(expr)));"}, {"sha": "25aee09e26c8efb81a09fc32b74f05d613387c80", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -793,6 +793,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(&output.expr)\n             }\n         }\n+        ExprKind::Try(ref subexpression) => {\n+            visitor.visit_expr(subexpression)\n+        }\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "184aa63b23426bb8220219d0a380a5d89e81df0a", "filename": "src/test/compile-fail/feature-gate-try-operator.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-try-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Fcompile-fail%2Ffeature-gate-try-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-try-operator.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! id {\n+    ($e:expr) => { $e }\n+}\n+\n+fn main() {\n+    id!(x?);  //~ error: the `?` operator is not stable (see issue #31436)\n+    //~^ help: add #![feature(question_mark)] to the crate attributes to enable\n+    y?;  //~ error: the `?` operator is not stable (see issue #31436)\n+    //~^ help: add #![feature(question_mark)] to the crate attributes to enable\n+}"}, {"sha": "233c03df4e57ee2243dc2ce30f3e90927d38cfad", "filename": "src/test/run-pass/try-operator-hygiene.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator-hygiene.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// `expr?` expands to:\n+//\n+// match expr {\n+//     Ok(val) => val,\n+//     Err(err) => return From::from(err),\n+// }\n+//\n+// This test verifies that the expansion is hygienic, i.e. it's not affected by other `val` and\n+// `err` bindings that may be in scope.\n+\n+#![feature(question_mark)]\n+\n+use std::num::ParseIntError;\n+\n+fn main() {\n+    assert_eq!(parse(), Ok(1));\n+}\n+\n+fn parse() -> Result<i32, ParseIntError> {\n+    const val: char = 'a';\n+    const err: char = 'b';\n+\n+    Ok(\"1\".parse::<i32>()?)\n+}"}, {"sha": "de5ccf09c5923d4ca67331f08f3afc52537c2438", "filename": "src/test/run-pass/try-operator.rs", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/210dd611aa1bd80ed2f4e663b3c4b87b3cea069a/src%2Ftest%2Frun-pass%2Ftry-operator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftry-operator.rs?ref=210dd611aa1bd80ed2f4e663b3c4b87b3cea069a", "patch": "@@ -0,0 +1,200 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(question_mark)]\n+\n+use std::fs::File;\n+use std::io::{Read, self};\n+use std::num::ParseIntError;\n+use std::str::FromStr;\n+\n+fn on_method() -> Result<i32, ParseIntError> {\n+    Ok(\"1\".parse::<i32>()? + \"2\".parse::<i32>()?)\n+}\n+\n+fn in_chain() -> Result<String, ParseIntError> {\n+    Ok(\"3\".parse::<i32>()?.to_string())\n+}\n+\n+fn on_call() -> Result<i32, ParseIntError> {\n+    fn parse<T: FromStr>(s: &str) -> Result<T, T::Err> {\n+        s.parse()\n+    }\n+\n+    Ok(parse(\"4\")?)\n+}\n+\n+fn nested() -> Result<i32, ParseIntError> {\n+    Ok(\"5\".parse::<i32>()?.to_string().parse()?)\n+}\n+\n+fn on_path() -> Result<i32, ParseIntError> {\n+    let x = \"6\".parse::<i32>();\n+\n+    Ok(x?)\n+}\n+\n+fn on_macro() -> Result<i32, ParseIntError> {\n+    macro_rules! id {\n+        ($e:expr) => { $e }\n+    }\n+\n+    Ok(id!(\"7\".parse::<i32>())?)\n+}\n+\n+fn on_parens() -> Result<i32, ParseIntError> {\n+    let x = \"8\".parse::<i32>();\n+\n+    Ok((x)?)\n+}\n+\n+fn on_block() -> Result<i32, ParseIntError> {\n+    let x = \"9\".parse::<i32>();\n+\n+    Ok({x}?)\n+}\n+\n+fn on_field() -> Result<i32, ParseIntError> {\n+    struct Pair<A, B> { a: A, b: B }\n+\n+    let x = Pair { a: \"10\".parse::<i32>(), b: 0 };\n+\n+    Ok(x.a?)\n+}\n+\n+fn on_tuple_field() -> Result<i32, ParseIntError> {\n+    let x = (\"11\".parse::<i32>(), 0);\n+\n+    Ok(x.0?)\n+}\n+\n+fn on_try() -> Result<i32, ParseIntError> {\n+    let x = \"12\".parse::<i32>().map(|i| i.to_string().parse::<i32>());\n+\n+    Ok(x??)\n+}\n+\n+fn on_binary_op() -> Result<i32, ParseIntError> {\n+    let x = 13 - \"14\".parse::<i32>()?;\n+    let y = \"15\".parse::<i32>()? - 16;\n+    let z = \"17\".parse::<i32>()? - \"18\".parse::<i32>()?;\n+\n+    Ok(x + y + z)\n+}\n+\n+fn on_index() -> Result<i32, ParseIntError> {\n+    let x = [19];\n+    let y = \"0\".parse::<usize>();\n+\n+    Ok(x[y?])\n+}\n+\n+fn on_args() -> Result<i32, ParseIntError> {\n+    fn sub(x: i32, y: i32) -> i32 { x - y }\n+\n+    let x = \"20\".parse();\n+    let y = \"21\".parse();\n+\n+    Ok(sub(x?, y?))\n+}\n+\n+fn on_if() -> Result<i32, ParseIntError> {\n+    Ok(if true {\n+        \"22\".parse::<i32>()\n+    } else {\n+        \"23\".parse::<i32>()\n+    }?)\n+}\n+\n+fn on_if_let() -> Result<i32, ParseIntError> {\n+    Ok(if let Ok(..) = \"24\".parse::<i32>() {\n+        \"25\".parse::<i32>()\n+    } else {\n+        \"26\".parse::<i32>()\n+    }?)\n+}\n+\n+fn on_match() -> Result<i32, ParseIntError> {\n+    Ok(match \"27\".parse::<i32>() {\n+        Err(..) => \"28\".parse::<i32>(),\n+        Ok(..) => \"29\".parse::<i32>(),\n+    }?)\n+}\n+\n+fn tight_binding() -> Result<bool, ()> {\n+    fn ok<T>(x: T) -> Result<T, ()> { Ok(x) }\n+\n+    let x = ok(true);\n+    Ok(!x?)\n+}\n+\n+// just type check\n+fn merge_error() -> Result<i32, Error> {\n+    let mut s = String::new();\n+\n+    File::open(\"foo.txt\")?.read_to_string(&mut s)?;\n+\n+    Ok(s.parse::<i32>()? + 1)\n+}\n+\n+fn main() {\n+    assert_eq!(Ok(3), on_method());\n+\n+    assert_eq!(Ok(\"3\".to_string()), in_chain());\n+\n+    assert_eq!(Ok(4), on_call());\n+\n+    assert_eq!(Ok(5), nested());\n+\n+    assert_eq!(Ok(6), on_path());\n+\n+    assert_eq!(Ok(7), on_macro());\n+\n+    assert_eq!(Ok(8), on_parens());\n+\n+    assert_eq!(Ok(9), on_block());\n+\n+    assert_eq!(Ok(10), on_field());\n+\n+    assert_eq!(Ok(11), on_tuple_field());\n+\n+    assert_eq!(Ok(12), on_try());\n+\n+    assert_eq!(Ok(-3), on_binary_op());\n+\n+    assert_eq!(Ok(19), on_index());\n+\n+    assert_eq!(Ok(-1), on_args());\n+\n+    assert_eq!(Ok(22), on_if());\n+\n+    assert_eq!(Ok(25), on_if_let());\n+\n+    assert_eq!(Ok(29), on_match());\n+\n+    assert_eq!(Ok(false), tight_binding());\n+}\n+\n+enum Error {\n+    Io(io::Error),\n+    Parse(ParseIntError),\n+}\n+\n+impl From<io::Error> for Error {\n+    fn from(e: io::Error) -> Error {\n+        Error::Io(e)\n+    }\n+}\n+\n+impl From<ParseIntError> for Error {\n+    fn from(e: ParseIntError) -> Error {\n+        Error::Parse(e)\n+    }\n+}"}]}