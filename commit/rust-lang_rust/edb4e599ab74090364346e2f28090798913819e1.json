{"sha": "edb4e599ab74090364346e2f28090798913819e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYjRlNTk5YWI3NDA5MDM2NDM0NmUyZjI4MDkwNzk4OTEzODE5ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T02:21:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-26T02:21:28Z"}, "message": "auto merge of #15184 : jbclements/rust/for-loop-hygiene-etc, r=jbclements\n\nIt turns out that bindings introduced by 'for' loops were not treated hygienically. The fix for this is to make the 'for' expansion more like a macro; rather than expanding sub-pieces and then assembling them, we need to rewrite the for and then call expand again on the whole thing.\r\n\r\nThis PR includes a test and the fix.\r\n\r\nIt also contains a number of other things:\r\n- unit tests for other forms of hygiene (currently ignored)\r\n- a fix for the isaac.rs macro that (it turned out) was relying on capturing\r\n- other miscellaneous cleanup and comments", "tree": {"sha": "6204a62b81b51c143b4be69d0e106a56f5fc27c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6204a62b81b51c143b4be69d0e106a56f5fc27c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edb4e599ab74090364346e2f28090798913819e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edb4e599ab74090364346e2f28090798913819e1", "html_url": "https://github.com/rust-lang/rust/commit/edb4e599ab74090364346e2f28090798913819e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edb4e599ab74090364346e2f28090798913819e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f8149e185fe55751b8d8675021d2066249abe54", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8149e185fe55751b8d8675021d2066249abe54", "html_url": "https://github.com/rust-lang/rust/commit/9f8149e185fe55751b8d8675021d2066249abe54"}, {"sha": "e880c42920592558c5c7d3d7cfdf339bb4ab08d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e880c42920592558c5c7d3d7cfdf339bb4ab08d1", "html_url": "https://github.com/rust-lang/rust/commit/e880c42920592558c5c7d3d7cfdf339bb4ab08d1"}], "stats": {"total": 359, "additions": 249, "deletions": 110}, "files": [{"sha": "6caa936636a710528017b09d81a4ab008fb3c3a5", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 65, "deletions": 62, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -130,37 +130,39 @@ impl IsaacRng {\n         macro_rules! ind (($x:expr) => {\n             self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))]\n         });\n-        macro_rules! rngstepp(\n-            ($j:expr, $shift:expr) => {{\n-                let base = $j;\n-                let mix = a << $shift as uint;\n-\n-                let x = self.mem[base  + mr_offset];\n-                a = (a ^ mix) + self.mem[base + m2_offset];\n-                let y = ind!(x) + a + b;\n-                self.mem[base + mr_offset] = y;\n-\n-                b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                self.rsl[base + mr_offset] = b;\n-            }}\n-        );\n-        macro_rules! rngstepn(\n-            ($j:expr, $shift:expr) => {{\n-                let base = $j;\n-                let mix = a >> $shift as uint;\n-\n-                let x = self.mem[base  + mr_offset];\n-                a = (a ^ mix) + self.mem[base + m2_offset];\n-                let y = ind!(x) + a + b;\n-                self.mem[base + mr_offset] = y;\n-\n-                b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                self.rsl[base + mr_offset] = b;\n-            }}\n-        );\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n+\n+            macro_rules! rngstepp(\n+                ($j:expr, $shift:expr) => {{\n+                        let base = $j;\n+                        let mix = a << $shift as uint;\n+\n+                        let x = self.mem[base  + mr_offset];\n+                        a = (a ^ mix) + self.mem[base + m2_offset];\n+                        let y = ind!(x) + a + b;\n+                        self.mem[base + mr_offset] = y;\n+\n+                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                        self.rsl[base + mr_offset] = b;\n+                    }}\n+                );\n+            macro_rules! rngstepn(\n+                ($j:expr, $shift:expr) => {{\n+                        let base = $j;\n+                        let mix = a >> $shift as uint;\n+\n+                        let x = self.mem[base  + mr_offset];\n+                        a = (a ^ mix) + self.mem[base + m2_offset];\n+                        let y = ind!(x) + a + b;\n+                        self.mem[base + mr_offset] = y;\n+\n+                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                        self.rsl[base + mr_offset] = b;\n+                    }}\n+                );\n+\n             for i in range_step(0u, MIDPOINT, 4) {\n                 rngstepp!(i + 0, 13);\n                 rngstepn!(i + 1, 6);\n@@ -349,43 +351,44 @@ impl Isaac64Rng {\n                 *self.mem.unsafe_ref(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n-        macro_rules! rngstepp(\n-            ($j:expr, $shift:expr) => {{\n-                let base = base + $j;\n-                let mix = a ^ (a << $shift as uint);\n-                let mix = if $j == 0 {!mix} else {mix};\n-\n-                unsafe {\n-                    let x = *self.mem.unsafe_ref(base + mr_offset);\n-                    a = mix + *self.mem.unsafe_ref(base + m2_offset);\n-                    let y = ind!(x) + a + b;\n-                    self.mem.unsafe_set(base + mr_offset, y);\n-\n-                    b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                    self.rsl.unsafe_set(base + mr_offset, b);\n-                }\n-            }}\n-        );\n-        macro_rules! rngstepn(\n-            ($j:expr, $shift:expr) => {{\n-                let base = base + $j;\n-                let mix = a ^ (a >> $shift as uint);\n-                let mix = if $j == 0 {!mix} else {mix};\n-\n-                unsafe {\n-                    let x = *self.mem.unsafe_ref(base + mr_offset);\n-                    a = mix + *self.mem.unsafe_ref(base + m2_offset);\n-                    let y = ind!(x) + a + b;\n-                    self.mem.unsafe_set(base + mr_offset, y);\n-\n-                    b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                    self.rsl.unsafe_set(base + mr_offset, b);\n-                }\n-            }}\n-        );\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n+\n+                macro_rules! rngstepp(\n+                    ($j:expr, $shift:expr) => {{\n+                            let base = base + $j;\n+                            let mix = a ^ (a << $shift as uint);\n+                            let mix = if $j == 0 {!mix} else {mix};\n+\n+                            unsafe {\n+                                let x = *self.mem.unsafe_ref(base + mr_offset);\n+                                a = mix + *self.mem.unsafe_ref(base + m2_offset);\n+                                let y = ind!(x) + a + b;\n+                                self.mem.unsafe_set(base + mr_offset, y);\n+\n+                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                                self.rsl.unsafe_set(base + mr_offset, b);\n+                            }\n+                        }}\n+                    );\n+                macro_rules! rngstepn(\n+                    ($j:expr, $shift:expr) => {{\n+                            let base = base + $j;\n+                            let mix = a ^ (a >> $shift as uint);\n+                            let mix = if $j == 0 {!mix} else {mix};\n+\n+                            unsafe {\n+                                let x = *self.mem.unsafe_ref(base + mr_offset);\n+                                a = mix + *self.mem.unsafe_ref(base + m2_offset);\n+                                let y = ind!(x) + a + b;\n+                                self.mem.unsafe_set(base + mr_offset, y);\n+\n+                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                                self.rsl.unsafe_set(base + mr_offset, b);\n+                            }\n+                        }}\n+                    );\n                 rngstepp!(0, 21);\n                 rngstepn!(1, 5);\n                 rngstepp!(2, 12);"}, {"sha": "d24c2be5a74de76980750c3e9b9ca25f81b3f73a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -835,6 +835,7 @@ impl Arg {\n     }\n }\n \n+// represents the header (not the body) of a function declaration\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,"}, {"sha": "321c56d4bbfd38e82cab36abc58c7ca171e94f55", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 103, "deletions": 35, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -132,8 +132,6 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n         ast::ExprForLoop(src_pat, src_expr, src_loop_block, opt_ident) => {\n             // Expand any interior macros etc.\n             // NB: we don't fold pats yet. Curious.\n-            let src_expr = fld.fold_expr(src_expr).clone();\n-            let (src_loop_block, opt_ident) = expand_loop_block(src_loop_block, opt_ident, fld);\n \n             let span = e.span;\n \n@@ -143,7 +141,7 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             //     i => {\n             //       ['<ident>:] loop {\n             //         match i.next() {\n-            //           None => break,\n+            //           None => break ['<ident>],\n             //           Some(mut value) => {\n             //             let <src_pat> = value;\n             //             <src_loop_block>\n@@ -156,22 +154,23 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             // (The use of the `let` is to give better error messages\n             // when the pattern is refutable.)\n \n-            let local_ident = token::gensym_ident(\"__i\"); // FIXME #13573\n+            let local_ident = token::gensym_ident(\"i\");\n             let next_ident = fld.cx.ident_of(\"next\");\n             let none_ident = fld.cx.ident_of(\"None\");\n \n             let local_path = fld.cx.path_ident(span, local_ident);\n             let some_path = fld.cx.path_ident(span, fld.cx.ident_of(\"Some\"));\n \n-            // `None => break ['<ident>];`\n+            // `None => break ['<ident>],`\n             let none_arm = {\n                 let break_expr = fld.cx.expr(span, ast::ExprBreak(opt_ident));\n                 let none_pat = fld.cx.pat_ident(span, none_ident);\n                 fld.cx.arm(span, vec!(none_pat), break_expr)\n             };\n \n             // let <src_pat> = value;\n-            let value_ident = token::gensym_ident(\"__value\");\n+            // use underscore to suppress lint error:\n+            let value_ident = token::gensym_ident(\"_value\");\n             // this is careful to use src_pat.span so that error\n             // messages point exact at that.\n             let local = box(GC) ast::Local {\n@@ -221,7 +220,9 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             let discrim = fld.cx.expr_mut_addr_of(span, src_expr);\n             let i_pattern = fld.cx.pat_ident(span, local_ident);\n             let arm = fld.cx.arm(span, vec!(i_pattern), loop_expr);\n-            fld.cx.expr_match(span, discrim, vec!(arm))\n+            // why these clone()'s everywhere? I guess I'll follow the pattern....\n+            let match_expr = fld.cx.expr_match(span, discrim, vec!(arm));\n+            fld.fold_expr(match_expr).clone()\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n@@ -658,15 +659,15 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n     }\n }\n \n-// a visitor that extracts the pat_ident paths\n+// a visitor that extracts the pat_ident (binding) paths\n // from a given thingy and puts them in a mutable\n-// array (passed in to the traversal)\n+// array (passed in to the traversal).\n #[deriving(Clone)]\n-pub struct NewNameFinderContext {\n+struct NameFinderContext {\n     ident_accumulator: Vec<ast::Ident> ,\n }\n \n-impl Visitor<()> for NewNameFinderContext {\n+impl Visitor<()> for NameFinderContext {\n     fn visit_pat(&mut self, pattern: &ast::Pat, _: ()) {\n         match *pattern {\n             // we found a pat_ident!\n@@ -698,17 +699,13 @@ impl Visitor<()> for NewNameFinderContext {\n         }\n     }\n \n-    fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n-        visit::walk_ty(self, typ, ())\n-    }\n-\n }\n \n // return a visitor that extracts the pat_ident paths\n // from a given thingy and puts them in a mutable\n // array (passed in to the traversal)\n-pub fn new_name_finder(idents: Vec<ast::Ident> ) -> NewNameFinderContext {\n-    NewNameFinderContext {\n+fn new_name_finder(idents: Vec<ast::Ident> ) -> NameFinderContext {\n+    NameFinderContext {\n         ident_accumulator: idents,\n     }\n }\n@@ -1016,7 +1013,7 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n \n #[cfg(test)]\n mod test {\n-    use super::*;\n+    use super::{new_name_finder, expand_crate, contains_macro_escape};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n     use attr;\n@@ -1026,7 +1023,7 @@ mod test {\n     use parse;\n     use parse::token;\n     use util::parser_testing::{string_to_parser};\n-    use util::parser_testing::{string_to_pat, strs_to_idents};\n+    use util::parser_testing::{string_to_pat, string_to_crate, strs_to_idents};\n     use visit;\n     use visit::Visitor;\n \n@@ -1036,11 +1033,11 @@ mod test {\n     // from a given thingy and puts them in a mutable\n     // array (passed in to the traversal)\n     #[deriving(Clone)]\n-    struct NewPathExprFinderContext {\n+    struct PathExprFinderContext {\n         path_accumulator: Vec<ast::Path> ,\n     }\n \n-    impl Visitor<()> for NewPathExprFinderContext {\n+    impl Visitor<()> for PathExprFinderContext {\n \n         fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n             match *expr {\n@@ -1051,26 +1048,21 @@ mod test {\n                 _ => visit::walk_expr(self,expr,())\n             }\n         }\n-\n-        fn visit_ty(&mut self, typ: &ast::Ty, _: ()) {\n-            visit::walk_ty(self, typ, ())\n-        }\n-\n     }\n \n     // return a visitor that extracts the paths\n-    // from a given pattern and puts them in a mutable\n+    // from a given thingy and puts them in a mutable\n     // array (passed in to the traversal)\n-    pub fn new_path_finder(paths: Vec<ast::Path> ) -> NewPathExprFinderContext {\n-        NewPathExprFinderContext {\n+    fn new_path_finder(paths: Vec<ast::Path> ) -> PathExprFinderContext {\n+        PathExprFinderContext {\n             path_accumulator: paths\n         }\n     }\n \n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n \n-    // make sure that macros can leave scope\n+    // make sure that macros can't escape fns\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n         let src = \"fn bogus() {macro_rules! z (() => (3+4))}\\\n@@ -1088,7 +1080,7 @@ mod test {\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n \n-    // make sure that macros can leave scope for modules\n+    // make sure that macros can't escape modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n         let src = \"mod foo {macro_rules! z (() => (3+4))}\\\n@@ -1105,7 +1097,7 @@ mod test {\n         expand_crate(&sess,cfg,vec!(),vec!(),crate_ast);\n     }\n \n-    // macro_escape modules shouldn't cause macros to leave scope\n+    // macro_escape modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                    fn inty() -> int { z!() }\".to_string();\n@@ -1114,7 +1106,6 @@ mod test {\n             \"<test>\".to_string(),\n             src,\n             Vec::new(), &sess);\n-        // should fail:\n         let cfg = ::syntax::ext::expand::ExpansionConfig {\n             deriving_hash_type_parameter: false,\n             crate_id: from_str(\"test\").unwrap(),\n@@ -1185,10 +1176,16 @@ mod test {\n     // binding should match the second two varrefs, and the second binding\n     // should match the first varref.\n     //\n+    // Put differently; this is a sparse representation of a boolean matrix\n+    // indicating which bindings capture which identifiers.\n+    //\n+    // Note also that this matrix is dependent on the implicit ordering of\n+    // the bindings and the varrefs discovered by the name-finder and the path-finder.\n+    //\n     // The comparisons are done post-mtwt-resolve, so we're comparing renamed\n     // names; differences in marks don't matter any more.\n     //\n-    // oog... I also want tests that check \"binding-identifier-=?\". That is,\n+    // oog... I also want tests that check \"bound-identifier-=?\". That is,\n     // not just \"do these have the same name\", but \"do they have the same\n     // name *and* the same marks\"? Understanding this is really pretty painful.\n     // in principle, you might want to control this boolean on a per-varref basis,\n@@ -1217,12 +1214,68 @@ mod test {\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}))\n                   fn main() -> int {user!(z)}\",\n-                 vec!(vec!(0)), false));\n+                 vec!(vec!(0)), false)\n+                );\n         for (idx,s) in tests.iter().enumerate() {\n             run_renaming_test(s,idx);\n         }\n     }\n \n+    // no longer a fixme #8062: this test exposes a *potential* bug; our system does\n+    // not behave exactly like MTWT, but a conversation with Matthew Flatt\n+    // suggests that this can only occur in the presence of local-expand, which\n+    // we have no plans to support. ... unless it's needed for item hygiene....\n+    #[ignore]\n+    #[test] fn issue_8062(){\n+        run_renaming_test(\n+            &(\"fn main() {let hrcoo = 19; macro_rules! getx(()=>(hrcoo)); getx!();}\",\n+              vec!(vec!(0)), true), 0)\n+    }\n+\n+    // FIXME #6994:\n+    // the z flows into and out of two macros (g & f) along one path, and one\n+    // (just g) along the other, so the result of the whole thing should\n+    // be \"let z_123 = 3; z_123\"\n+    #[ignore]\n+    #[test] fn issue_6994(){\n+        run_renaming_test(\n+            &(\"macro_rules! g (($x:ident) =>\n+              ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n+              fn a(){g!(z)}\",\n+              vec!(vec!(0)),false),\n+            0)\n+    }\n+\n+    // FIXME #9384, match variable hygiene. Should expand into\n+    // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 => x_2 + x_1}}}}\n+    #[ignore]\n+    #[test] fn issue_9384(){\n+        run_renaming_test(\n+            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x => x + $ex}}))\n+              fn z() {match 8 {x => bad_macro!(_x)}}\",\n+              // NB: the third \"binding\" is the repeat of the second one.\n+              vec!(vec!(1),vec!(0),vec!(0)),\n+              true),\n+            0)\n+    }\n+\n+    // create a really evil test case where a $x appears inside a binding of $x\n+    // but *shouldnt* bind because it was inserted by a different macro....\n+    // can't write this test case until we have macro-generating macros.\n+\n+    // FIXME #9383 : lambda var hygiene\n+    // interesting... can't even write this test, yet, because the name-finder\n+    // only finds pattern vars. Time to upgrade test framework.\n+    /*#[test]\n+    fn issue_9383(){\n+        run_renaming_test(\n+            &(\"macro_rules! bad_macro (($ex:expr) => ({(|_x| { $ex }) (9) }))\n+              fn takes_x(_x : int) { assert_eq!(bad_macro!(_x),8); }\n+              fn main() { takes_x(8); }\",\n+              vec!(vec!()),false),\n+            0)\n+    }*/\n+\n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n         let invalid_name = token::special_idents::invalid.name;\n@@ -1358,4 +1411,19 @@ foo_module!()\n                    strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n \n+    // test the list of identifier patterns gathered by the visitor. Note that\n+    // 'None' is listed as an identifier pattern because we don't yet know that\n+    // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n+    #[test]\n+    fn crate_idents(){\n+        let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n+        match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n+        let mut idents = new_name_finder(Vec::new());\n+        //visit::walk_crate(&mut idents, &the_crate, ());\n+        idents.visit_mod(&the_crate.module, the_crate.span, ast::CRATE_NODE_ID, ());\n+        assert_eq!(idents.ident_accumulator,\n+                   strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n+    }\n+\n+\n }"}, {"sha": "4db8cfa65651b3b3bcd07fff8f14fdc612c64bf0", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -23,23 +23,23 @@ use std::str;\n use std::vec;\n use std::io::File;\n \n-macro_rules! bench (\n-    ($argv:expr, $id:ident) => (maybe_run_test($argv.as_slice(),\n-                                               stringify!($id).to_string(),\n-                                                          $id))\n-)\n-\n fn main() {\n     let argv = os::args().move_iter().map(|x| x.to_string()).collect::<Vec<String>>();\n     let _tests = argv.slice(1, argv.len());\n \n-    bench!(argv, shift_push);\n-    bench!(argv, read_line);\n-    bench!(argv, vec_plus);\n-    bench!(argv, vec_append);\n-    bench!(argv, vec_push_all);\n-    bench!(argv, is_utf8_ascii);\n-    bench!(argv, is_utf8_multibyte);\n+    macro_rules! bench (\n+        ($id:ident) =>\n+            (maybe_run_test(argv.as_slice(),\n+                            stringify!($id).to_string(),\n+                            $id)))\n+\n+    bench!(shift_push);\n+    bench!(read_line);\n+    bench!(vec_plus);\n+    bench!(vec_append);\n+    bench!(vec_push_all);\n+    bench!(is_utf8_ascii);\n+    bench!(is_utf8_multibyte);\n }\n \n fn maybe_run_test(argv: &[String], name: String, test: ||) {"}, {"sha": "716646da37eef87440ee336e1a69dd4e7a628cd9", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -15,6 +15,8 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n+// ignore-pretty FIXME #15189\n+\n extern crate time;\n \n use std::sync::{Arc, Future, Mutex};"}, {"sha": "2580e6cad2121128aa027326e54aa881c440270b", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -15,6 +15,8 @@\n \n // This also serves as a pipes test, because Arcs are implemented with pipes.\n \n+// ignore-pretty FIXME #15189\n+\n extern crate time;\n \n use std::sync::{RWLock, Arc, Future};"}, {"sha": "a0ff8e8c1f92a8a874b28e65d658745e16e7c3d3", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -38,6 +38,8 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n+// ignore-pretty FIXME #15189\n+\n #![feature(phase)]\n #[phase(plugin)] extern crate green;\n "}, {"sha": "949cf439df1cab65bfba29bd8651385a9d722015", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n #![feature(phase)]\n #![allow(non_snake_case_functions)]\n #[phase(plugin)] extern crate green;"}, {"sha": "61e1e92ff9420d139d3885dc399e733154dba442", "filename": "src/test/compile-fail/issue-15167.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// macro f should not be able to inject a reference to 'n'.\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! f(() => (n))\n+\n+fn main() -> (){\n+    for n in range(0, 1) {\n+        println!(\"{}\", f!()); //~ ERROR unresolved name `n`\n+    }\n+}"}, {"sha": "3b74ec4add31982e05bebbded9678328404ce9f8", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n // ignore-win32 FIXME #13259\n extern crate native;\n "}, {"sha": "4a9324dd201a1f13726aa915d6ea32fa4ae33262", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n enum E<T> {\n     E0,"}, {"sha": "b21c95d7b50ce6d475585ca4cb507e5a56c5172c", "filename": "src/test/run-pass/deriving-cmp-generic-struct-enum.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct-enum.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n #![feature(struct_variant)]\n \n #[deriving(PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "e2b8e1b6b82f545d857dfa847f8eb99db483a46b", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct S<T> {\n     x: T,"}, {"sha": "c07f124a08d1928cf646f3e50549e0a6aa78a8c2", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n #[deriving(PartialEq, Eq, PartialOrd, Ord)]\n struct TS<T>(T,T);\n "}, {"sha": "abf8b6dbbea49bd61fbba51919e9fe802b21fcb5", "filename": "src/test/run-pass/issue-15189.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+#![feature(macro_rules)]\n+\n+macro_rules! third(($e:expr)=>({let x = 2; *$e.get(x)}))\n+\n+fn main() {\n+    let x = vec!(10u,11u,12u,13u);\n+    let t = third!(x);\n+    assert_eq!(t,12u);\n+}"}, {"sha": "640ed3883eb851e4a5dc192a716d8388228e59e0", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n extern crate debug;\n \n pub fn main() {"}, {"sha": "1c14153a11018343bbfccb93b67baade65905ec7", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n extern crate debug;\n \n use std::task;"}, {"sha": "d3e70706867b41b5f5330e4adccce7288e435267", "filename": "src/test/run-pass/unfold-cross-crate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n use std::iter::Unfold;\n \n // Unfold had a bug with 'a that mean it didn't work"}, {"sha": "6cf0d518628eac102a9e0fd49b8e30495d767ac6", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb4e599ab74090364346e2f28090798913819e1/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=edb4e599ab74090364346e2f28090798913819e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-pretty FIXME #15189\n+\n pub fn main() {\n     let yen: char = '\u00a5'; // 0xa5\n     let c_cedilla: char = '\u00e7'; // 0xe7"}]}