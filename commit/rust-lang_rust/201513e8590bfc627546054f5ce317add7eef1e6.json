{"sha": "201513e8590bfc627546054f5ce317add7eef1e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMTUxM2U4NTkwYmZjNjI3NTQ2MDU0ZjVjZTMxN2FkZDdlZWYxZTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T19:02:59Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-02T19:04:49Z"}, "message": "De-export std::{fun_treemap, list, map}. Part of #3583.", "tree": {"sha": "553e08e9ecdc1d11cd4bae5641bdc6f1e7d7bfca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/553e08e9ecdc1d11cd4bae5641bdc6f1e7d7bfca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/201513e8590bfc627546054f5ce317add7eef1e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/201513e8590bfc627546054f5ce317add7eef1e6", "html_url": "https://github.com/rust-lang/rust/commit/201513e8590bfc627546054f5ce317add7eef1e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/201513e8590bfc627546054f5ce317add7eef1e6/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092de78fab2bf346a548e59f98db9d7df27a6b56", "url": "https://api.github.com/repos/rust-lang/rust/commits/092de78fab2bf346a548e59f98db9d7df27a6b56", "html_url": "https://github.com/rust-lang/rust/commit/092de78fab2bf346a548e59f98db9d7df27a6b56"}], "stats": {"total": 77, "additions": 30, "deletions": 47}, "files": [{"sha": "2973c8cc9f784c3f461b392b2aa2e9654cc54c41", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=201513e8590bfc627546054f5ce317add7eef1e6", "patch": "@@ -15,24 +15,18 @@ use core::cmp::{Eq, Ord};\n use option::{Some, None};\n use option = option;\n \n-export Treemap;\n-export init;\n-export insert;\n-export find;\n-export traverse;\n-\n-type Treemap<K, V> = @TreeNode<K, V>;\n+pub type Treemap<K, V> = @TreeNode<K, V>;\n \n enum TreeNode<K, V> {\n     Empty,\n     Node(@K, @V, @TreeNode<K, V>, @TreeNode<K, V>)\n }\n \n /// Create a treemap\n-fn init<K, V>() -> Treemap<K, V> { @Empty }\n+pub fn init<K, V>() -> Treemap<K, V> { @Empty }\n \n /// Insert a value into the map\n-fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n+pub fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n   -> Treemap<K, V> {\n     @match m {\n        @Empty => Node(@k, @v, @Empty, @Empty),\n@@ -47,7 +41,7 @@ fn insert<K: Copy Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K, +v: V)\n }\n \n /// Find a value based on the key\n-fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n+pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n     match *m {\n       Empty => None,\n       Node(@ref kk, @copy v, left, right) => {\n@@ -59,7 +53,7 @@ fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, +k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn((&K), (&V))) {\n+pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn((&K), (&V))) {\n     match *m {\n       Empty => (),\n       /*"}, {"sha": "5b0931ebdeedad60a55b9a130e6f703a86403d9a", "filename": "src/libstd/list.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=201513e8590bfc627546054f5ce317add7eef1e6", "patch": "@@ -6,13 +6,13 @@ use core::option;\n use option::*;\n use option::{Some, None};\n \n-enum List<T> {\n+pub enum List<T> {\n     Cons(T, @List<T>),\n     Nil,\n }\n \n /// Cregate a list from a vector\n-fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n+pub fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n }\n \n@@ -29,7 +29,7 @@ fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-fn foldl<T: Copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n+pub fn foldl<T: Copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -42,7 +42,7 @@ fn foldl<T: Copy, U>(+z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n+pub fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -56,43 +56,43 @@ fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n }\n \n /// Returns true if a list contains an element with the given value\n-fn has<T: Copy Eq>(ls: @List<T>, +elt: T) -> bool {\n+pub fn has<T: Copy Eq>(ls: @List<T>, +elt: T) -> bool {\n     for each(ls) |e| {\n         if *e == elt { return true; }\n     }\n     return false;\n }\n \n /// Returns true if the list is empty\n-pure fn is_empty<T: Copy>(ls: @List<T>) -> bool {\n+pub pure fn is_empty<T: Copy>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n     }\n }\n \n /// Returns true if the list is not empty\n-pure fn is_not_empty<T: Copy>(ls: @List<T>) -> bool {\n+pub pure fn is_not_empty<T: Copy>(ls: @List<T>) -> bool {\n     return !is_empty(ls);\n }\n \n /// Returns the length of a list\n-fn len<T>(ls: @List<T>) -> uint {\n+pub fn len<T>(ls: @List<T>) -> uint {\n     let mut count = 0u;\n     iter(ls, |_e| count += 1u);\n     count\n }\n \n /// Returns all but the first element of a list\n-pure fn tail<T: Copy>(ls: @List<T>) -> @List<T> {\n+pub pure fn tail<T: Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail ~\"list empty\"\n     }\n }\n \n /// Returns the first element of a list\n-pure fn head<T: Copy>(ls: @List<T>) -> T {\n+pub pure fn head<T: Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(copy hd, _) => hd,\n       // makes me sad\n@@ -101,7 +101,7 @@ pure fn head<T: Copy>(ls: @List<T>) -> T {\n }\n \n /// Appends one list to another\n-pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pub pure fn append<T: Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(copy x, xs) => {\n@@ -120,7 +120,7 @@ pure fn push<T: Copy>(ll: &mut @list<T>, +vv: T) {\n */\n \n /// Iterate over a list\n-fn iter<T>(l: @List<T>, f: fn((&T))) {\n+pub fn iter<T>(l: @List<T>, f: fn((&T))) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -134,7 +134,7 @@ fn iter<T>(l: @List<T>, f: fn((&T))) {\n }\n \n /// Iterate over a list\n-fn each<T>(l: @List<T>, f: fn((&T)) -> bool) {\n+pub fn each<T>(l: @List<T>, f: fn((&T)) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}, {"sha": "84fee0925622c04cb8688f3735923d6295e29d33", "filename": "src/libstd/map.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=201513e8590bfc627546054f5ce317add7eef1e6", "patch": "@@ -11,16 +11,12 @@ use core::cmp::Eq;\n use hash::Hash;\n use to_bytes::IterBytes;\n \n-export HashMap, hashfn, eqfn, Set, Map, chained, set_add;\n-export hash_from_vec;\n-export vec_from_set;\n-\n /// A convenience type to treat a hashmap as a set\n-type Set<K:Eq IterBytes Hash> = HashMap<K, ()>;\n+pub type Set<K:Eq IterBytes Hash> = HashMap<K, ()>;\n \n-type HashMap<K:Eq IterBytes Hash, V> = chained::T<K, V>;\n+pub type HashMap<K:Eq IterBytes Hash, V> = chained::T<K, V>;\n \n-trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n+pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n     /// Return the number of elements in the map\n     pure fn size() -> uint;\n \n@@ -82,10 +78,9 @@ trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n }\n \n mod util {\n-    #[legacy_exports];\n-    type Rational = {num: int, den: int}; // : int::positive(*.den);\n+    pub type Rational = {num: int, den: int}; // : int::positive(*.den);\n \n-    pure fn rational_leq(x: Rational, y: Rational) -> bool {\n+    pub pure fn rational_leq(x: Rational, y: Rational) -> bool {\n         // NB: Uses the fact that rationals have positive denominators WLOG:\n \n         x.num * y.den <= y.num * x.den\n@@ -95,9 +90,7 @@ mod util {\n \n // FIXME (#2344): package this up and export it as a datatype usable for\n // external code that doesn't want to pay the cost of a box.\n-mod chained {\n-    #[legacy_exports];\n-    export T, mk, HashMap;\n+pub mod chained {\n \n     const initial_capacity: uint = 32u; // 2^5\n \n@@ -113,7 +106,7 @@ mod chained {\n         mut chains: ~[mut Option<@Entry<K,V>>]\n     }\n \n-    type T<K:Eq IterBytes Hash, V> = @HashMap_<K, V>;\n+    pub type T<K:Eq IterBytes Hash, V> = @HashMap_<K, V>;\n \n     enum SearchResult<K, V> {\n         NotFound,\n@@ -366,7 +359,7 @@ mod chained {\n         vec::to_mut(vec::from_elem(nchains, None))\n     }\n \n-    fn mk<K:Eq IterBytes Hash, V: Copy>() -> T<K,V> {\n+    pub fn mk<K:Eq IterBytes Hash, V: Copy>() -> T<K,V> {\n         let slf: T<K, V> = @HashMap_ {count: 0u,\n                                       chains: chains(initial_capacity)};\n         slf\n@@ -378,18 +371,18 @@ Function: hashmap\n \n Construct a hashmap.\n */\n-fn HashMap<K:Eq IterBytes Hash Const, V: Copy>()\n+pub fn HashMap<K:Eq IterBytes Hash Const, V: Copy>()\n         -> HashMap<K, V> {\n     chained::mk()\n }\n \n /// Convenience function for adding keys to a hashmap with nil type keys\n-fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, +key: K) -> bool {\n+pub fn set_add<K:Eq IterBytes Hash Const Copy>(set: Set<K>, +key: K) -> bool {\n     set.insert(key, ())\n }\n \n /// Convert a set into a vector.\n-fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n+pub fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.size()) |push| {\n         for s.each_key() |k| {\n             push(k);\n@@ -398,7 +391,7 @@ fn vec_from_set<T:Eq IterBytes Hash Copy>(s: Set<T>) -> ~[T] {\n }\n \n /// Construct a hashmap from a vector\n-fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n+pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n     items: &[(K, V)]) -> HashMap<K, V> {\n     let map = HashMap();\n     for vec::each(items) |item| {\n@@ -517,7 +510,6 @@ impl<K: Eq IterBytes Hash Copy, V: Copy> @Mut<LinearMap<K, V>>:\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     #[test]\n     fn test_simple() {"}, {"sha": "4831ac993a20cbdc806673a7d27556787a8f3f79", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/201513e8590bfc627546054f5ce317add7eef1e6/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=201513e8590bfc627546054f5ce317add7eef1e6", "patch": "@@ -77,11 +77,8 @@ mod comm;\n \n mod bitv;\n mod deque;\n-#[legacy_exports]\n mod fun_treemap;\n-#[legacy_exports]\n mod list;\n-#[legacy_exports]\n mod map;\n mod rope;\n mod smallintmap;"}]}