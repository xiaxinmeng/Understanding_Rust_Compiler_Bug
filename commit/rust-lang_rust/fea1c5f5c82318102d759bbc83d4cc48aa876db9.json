{"sha": "fea1c5f5c82318102d759bbc83d4cc48aa876db9", "node_id": "C_kwDOAAsO6NoAKGZlYTFjNWY1YzgyMzE4MTAyZDc1OWJiYzgzZDRjYzQ4YWE4NzZkYjk", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-02T13:48:14Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-09-05T13:31:02Z"}, "message": "refactor: remove unnecessary variables", "tree": {"sha": "e66de1da2f8a9ef4374e7915112f6d2cf9abe645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e66de1da2f8a9ef4374e7915112f6d2cf9abe645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fea1c5f5c82318102d759bbc83d4cc48aa876db9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fea1c5f5c82318102d759bbc83d4cc48aa876db9", "html_url": "https://github.com/rust-lang/rust/commit/fea1c5f5c82318102d759bbc83d4cc48aa876db9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fea1c5f5c82318102d759bbc83d4cc48aa876db9/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3955dc3480cfb60116586ce94f9c332744fcacbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3955dc3480cfb60116586ce94f9c332744fcacbb", "html_url": "https://github.com/rust-lang/rust/commit/3955dc3480cfb60116586ce94f9c332744fcacbb"}], "stats": {"total": 201, "additions": 93, "deletions": 108}, "files": [{"sha": "10b4633a3b2101715036735a7356e92c1f724f00", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -906,7 +906,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,\n                         ..\n-                    }) = arg.kind {\n+                    }) = arg.kind\n+                    {\n                         closure_span = Some(arg.span.shrink_to_lo());\n                         break;\n                     }"}, {"sha": "01df564a7c2eabe0ec35cd94e13cb18f74e2937b", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -1881,11 +1881,11 @@ pub enum ExprKind<'hir> {\n     ///\n     /// The `PathSegment` represents the method name and its generic arguments\n     /// (within the angle brackets).\n-    /// The first element of the `&[Expr]` is the expression that evaluates\n+    /// The `&Expr` is the expression that evaluates\n     /// to the object on which the method is being called on (the receiver),\n-    /// and the remaining elements are the rest of the arguments.\n+    /// and the `&[Expr]` is the rest of the arguments.\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n-    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, [x, a, b, c, d], span)`.\n+    /// `ExprKind::MethodCall(PathSegment { foo, [Bar, Baz] }, x, [a, b, c, d], span)`.\n     /// The final `Span` represents the span of the function and arguments\n     /// (e.g. `foo::<Bar, Baz>(a, b, c, d)` in `x.foo::<Bar, Baz>(a, b, c, d)`\n     ///"}, {"sha": "b97f8acb37f8442d7152d0e12f01fe9fac4db493", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n         }\n \n         // We only care about method call expressions.\n-        if let hir::ExprKind::MethodCall(call, receiver, ..) = &expr.kind {\n+        if let hir::ExprKind::MethodCall(call, receiver_arg, ..) = &expr.kind {\n             if call.ident.name != sym::into_iter {\n                 return;\n             }\n@@ -75,7 +75,6 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             };\n \n             // As this is a method call expression, we have at least one argument.\n-            let receiver_arg = receiver;\n             let receiver_ty = cx.typeck_results().expr_ty(receiver_arg);\n             let adjustments = cx.typeck_results().expr_adjustments(receiver_arg);\n "}, {"sha": "5f7f03480c043b07e58815012b35ff2b8418705c", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -63,15 +63,13 @@ impl<'tcx> LateLintPass<'tcx> for TemporaryCStringAsPtr {\n         }\n \n         match first_method_call(expr) {\n-            Some((path, receiver)) if path.ident.name == sym::as_ptr => {\n-                let unwrap_arg = receiver;\n+            Some((path, unwrap_arg)) if path.ident.name == sym::as_ptr => {\n                 let as_ptr_span = path.ident.span;\n                 match first_method_call(unwrap_arg) {\n                     Some((path, receiver))\n                         if path.ident.name == sym::unwrap || path.ident.name == sym::expect =>\n                     {\n-                        let source_arg = receiver;\n-                        lint_cstring_as_ptr(cx, as_ptr_span, source_arg, unwrap_arg);\n+                        lint_cstring_as_ptr(cx, as_ptr_span, receiver, unwrap_arg);\n                     }\n                     _ => return,\n                 }"}, {"sha": "d059877f8e71fcb481258efc1c8aa5698835479c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -267,7 +267,8 @@ impl<'tcx> Cx<'tcx> {\n                 // When we apply adjustments to the receiver, use the span of\n                 // the overall method call for better diagnostics. args[0]\n                 // is guaranteed to exist, since a method call always has a receiver.\n-                let old_adjustment_span = self.adjustment_span.replace((receiver.hir_id, expr_span));\n+                let old_adjustment_span =\n+                    self.adjustment_span.replace((receiver.hir_id, expr_span));\n                 info!(\"Using method span: {:?}\", expr.span);\n                 let args = std::iter::once(receiver)\n                     .chain(args.iter())"}, {"sha": "a9ea79c2fe3927921ec497e0ea3d89bd66c8ba13", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -1041,10 +1041,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::MethodCall(.., receiver, ref args, _) => {\n                 let succ = self.check_is_ty_uninhabited(expr, succ);\n-                std::iter::once(receiver)\n-                    .chain(args.iter())\n+                let succ = args\n+                    .iter()\n                     .rev()\n-                    .fold(succ, |succ, expr| self.propagate_through_expr(expr, succ))\n+                    .fold(succ, |succ, expr| self.propagate_through_expr(expr, succ));\n+                self.propagate_through_expr(receiver, succ)\n             }\n \n             hir::ExprKind::Tup(ref exprs) => self.propagate_through_exprs(exprs, succ),"}, {"sha": "d078252ebd4e2fadf6b9ce12eb9ac305706c7c61", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -770,16 +770,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let hir::ExprKind::MethodCall(ref segment, receiver, args, _) = expr.kind {\n                         let clone_trait =\n                             self.tcx.require_lang_item(LangItem::Clone, Some(segment.ident.span));\n-                        if let (true, Some(true), sym::clone) = (\n-                            args.is_empty(),\n-                            self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map(\n+                        if args.is_empty()\n+                            && self.typeck_results.borrow().type_dependent_def_id(expr.hir_id).map(\n                                 |did| {\n                                     let ai = self.tcx.associated_item(did);\n                                     ai.trait_container(self.tcx) == Some(clone_trait)\n                                 },\n-                            ),\n-                            segment.ident.name,\n-                        ) {\n+                            ) == Some(true)\n+                            && segment.ident.name == sym::clone\n+                        {\n                             // If this expression had a clone call when suggesting borrowing\n                             // we want to suggest removing it because it'd now be unnecessary.\n                             sugg_sp = receiver.span;"}, {"sha": "e4141647d7d2df66fd8b99a8e83ce89a68def8f9", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -1195,14 +1195,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         segment: &hir::PathSegment<'_>,\n-        receiver: &'tcx hir::Expr<'tcx>,\n+        rcvr: &'tcx hir::Expr<'tcx>,\n         args: &'tcx [hir::Expr<'tcx>],\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n-        let rcvr = &receiver;\n         let rcvr_t = self.check_expr(&rcvr);\n         // no need to check for bot/err -- callee does that\n-        let rcvr_t = self.structurally_resolved_type(receiver.span, rcvr_t);\n+        let rcvr_t = self.structurally_resolved_type(rcvr.span, rcvr_t);\n         let span = segment.ident.span;\n \n         let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr, args) {\n@@ -1219,9 +1218,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         rcvr_t,\n                         segment.ident,\n-                        SelfSource::MethodCall(receiver),\n+                        SelfSource::MethodCall(rcvr),\n                         error,\n-                        Some((receiver, args)),\n+                        Some((rcvr, args)),\n                     ) {\n                         err.emit();\n                     }"}, {"sha": "9157b83330dd6ba54a4016cbb02c6c7f68ccd683", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -1913,14 +1913,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .enumerate()\n             .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n             .collect();\n-        let args: Vec<&'tcx hir::Expr<'tcx>> = if let Some(receiver) = receiver {\n-            std::iter::once(receiver).chain(args.iter()).collect()\n-        } else {\n-            args.iter().collect()\n-        };\n-\n         // If there's one field that references the given generic, great!\n-        if let [(idx, _)] = args_referencing_param.as_slice() && let Some(arg) = args.get(*idx) {\n+        if let [(idx, _)] = args_referencing_param.as_slice()\n+            && let Some(arg) = receiver\n+                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {"}, {"sha": "6ee9e2e9754ced7799883f31b43fb3c23e92d9e5", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -798,57 +798,55 @@ fn walk_parents<'tcx>(\n                     }),\n                 ExprKind::MethodCall(_, receiver, args, _) => {\n                     let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n-                    std::iter::once(receiver)\n-                        .chain(args.iter())\n-                        .position(|arg| arg.hir_id == child_id)\n-                        .map(|i| {\n-                            if i == 0 {\n-                                // Check for calls to trait methods where the trait is implemented on a reference.\n-                                // Two cases need to be handled:\n-                                // * `self` methods on `&T` will never have auto-borrow\n-                                // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n-                                //   priority.\n-                                if e.hir_id != child_id {\n-                                Position::ReborrowStable(precedence)\n-                            } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n-                                && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n-                                && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n-                                && let subs = match cx\n-                                    .typeck_results()\n-                                    .node_substs_opt(parent.hir_id)\n-                                    .and_then(|subs| subs.get(1..))\n-                                {\n-                                    Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n-                                    None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n-                                } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n-                                    // Trait methods taking `&self`\n-                                    sub_ty\n-                                } else {\n-                                    // Trait methods taking `self`\n-                                    arg_ty\n-                                } && impl_ty.is_ref()\n-                                && cx.tcx.infer_ctxt().enter(|infcx|\n-                                    infcx\n-                                        .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n-                                        .must_apply_modulo_regions()\n-                                )\n+                    if receiver.hir_id == child_id {\n+                        // Check for calls to trait methods where the trait is implemented on a reference.\n+                        // Two cases need to be handled:\n+                        // * `self` methods on `&T` will never have auto-borrow\n+                        // * `&self` methods on `&T` can have auto-borrow, but `&self` methods on `T` will take\n+                        //   priority.\n+                        if e.hir_id != child_id {\n+                            return Some(Position::ReborrowStable(precedence))\n+                        } else if let Some(trait_id) = cx.tcx.trait_of_item(id)\n+                            && let arg_ty = cx.tcx.erase_regions(cx.typeck_results().expr_ty_adjusted(e))\n+                            && let ty::Ref(_, sub_ty, _) = *arg_ty.kind()\n+                            && let subs = match cx\n+                                .typeck_results()\n+                                .node_substs_opt(parent.hir_id)\n+                                .and_then(|subs| subs.get(1..))\n                             {\n-                                Position::MethodReceiverRefImpl\n+                                Some(subs) => cx.tcx.mk_substs(subs.iter().copied()),\n+                                None => cx.tcx.mk_substs(std::iter::empty::<ty::subst::GenericArg<'_>>()),\n+                            } && let impl_ty = if cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref() {\n+                                // Trait methods taking `&self`\n+                                sub_ty\n                             } else {\n-                                Position::MethodReceiver\n-                            }\n+                                // Trait methods taking `self`\n+                                arg_ty\n+                            } && impl_ty.is_ref()\n+                            && cx.tcx.infer_ctxt().enter(|infcx|\n+                                infcx\n+                                    .type_implements_trait(trait_id, impl_ty, subs, cx.param_env)\n+                                    .must_apply_modulo_regions()\n+                            )\n+                        {\n+                            return Some(Position::MethodReceiverRefImpl)\n+                        } else {\n+                            return Some(Position::MethodReceiver)\n+                        }\n+                    }\n+                    args.iter()\n+                        .position(|arg| arg.hir_id == child_id)\n+                        .map(|i| {\n+                            let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                            if let ty::Param(param_ty) = ty.kind() {\n+                                needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n                             } else {\n-                                let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i];\n-                                if let ty::Param(param_ty) = ty.kind() {\n-                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n-                                } else {\n-                                    ty_auto_deref_stability(\n-                                        cx,\n-                                        cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i)),\n-                                        precedence,\n-                                    )\n-                                    .position_for_arg()\n-                                }\n+                                ty_auto_deref_stability(\n+                                    cx,\n+                                    cx.tcx.erase_late_bound_regions(cx.tcx.fn_sig(id).input(i + 1)),\n+                                    precedence,\n+                                )\n+                                .position_for_arg()\n                             }\n                         })\n                 },"}, {"sha": "d55a8e1ead17d11eb02f135c361010dca7fb9a2c", "filename": "src/tools/clippy/clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finfinite_iter.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -59,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for InfiniteIter {\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n             Finite => {\n                 return;\n-            },\n+            }\n         };\n         span_lint(cx, lint, expr.span, msg);\n     }\n@@ -229,11 +229,9 @@ fn complete_infinite_iter(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                     return MaybeInfinite.and(is_infinite(cx, receiver));\n                 }\n             }\n-            if method.ident.name == sym!(last) {\n-                let not_double_ended = cx\n-                    .tcx\n-                    .get_diagnostic_item(sym::DoubleEndedIterator)\n-                    .map_or(false, |id| {\n+            if method.ident.name == sym!(last) && args.is_empty() {\n+                let not_double_ended =\n+                    cx.tcx.get_diagnostic_item(sym::DoubleEndedIterator).map_or(false, |id| {\n                         !implements_trait(cx, cx.typeck_results().expr_ty(receiver), id, &[])\n                     });\n                 if not_double_ended {"}, {"sha": "3cbdaff407b04383f07bf24c84dfb71d52bed93d", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -370,15 +370,15 @@ fn check_for_is_empty<'tcx>(\n }\n \n fn check_cmp(cx: &LateContext<'_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(method_path, receiver, ..), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(method_path, receiver, args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {\n                 return;\n             }\n         }\n \n-        check_len(cx, span, method_path.ident.name, receiver, &lit.node, op, compare_to);\n+        check_len(cx, span, method_path.ident.name, receiver, args, &lit.node, op, compare_to);\n     } else {\n         check_empty_expr(cx, span, method, lit, op);\n     }\n@@ -389,6 +389,7 @@ fn check_len(\n     span: Span,\n     method_name: Symbol,\n     receiver: &Expr<'_>,\n+    args: &[Expr<'_>],\n     lit: &LitKind,\n     op: &str,\n     compare_to: u32,\n@@ -399,7 +400,7 @@ fn check_len(\n             return;\n         }\n \n-        if method_name == sym::len && has_is_empty(cx, receiver) {\n+        if method_name == sym::len && args.is_empty() && has_is_empty(cx, receiver) {\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,"}, {"sha": "25a9e6dafea151e427ee385c26ce27643baa9921", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -21,10 +21,7 @@ pub(super) fn check(\n     receiver: &Expr<'_>,\n     args: &[Expr<'_>],\n ) {\n-    let arg = match args {\n-        [] if method_name == sym::clone => receiver,\n-        _ => return,\n-    };\n+    let arg = if method_name == sym::clone && args.is_empty() { receiver } else { return };\n     if cx\n         .typeck_results()\n         .type_dependent_def_id(expr.hir_id)"}, {"sha": "f82ca8912006180b5b853dd57f8af0538c423976", "filename": "src/tools/clippy/clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -20,8 +20,7 @@ pub(super) fn check(\n     if !(args.is_empty() && method_name == sym::clone) {\n         return;\n     }\n-    let arg = receiver;\n-    let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n+    let obj_ty = cx.typeck_results().expr_ty(receiver).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {\n         let caller_type = if is_type_diagnostic_item(cx, obj_ty, sym::Rc) {\n@@ -34,7 +33,7 @@ pub(super) fn check(\n             return;\n         };\n \n-        let snippet = snippet_with_macro_callsite(cx, arg.span, \"..\");\n+        let snippet = snippet_with_macro_callsite(cx, receiver.span, \"..\");\n \n         span_lint_and_sugg(\n             cx,"}, {"sha": "fc9ba15d82a40e4e00f59c35ef8c378c43e28847", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -3381,7 +3381,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n impl Methods {\n     #[allow(clippy::too_many_lines)]\n     fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((name, recv, [args @ ..], span)) = method_call(expr) {\n+        if let Some((name, recv, args, span)) = method_call(expr) {\n             match (name, args) {\n                 (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n                     zst_offset::check(cx, expr, recv);\n@@ -3485,7 +3485,7 @@ impl Methods {\n                     }\n                 },\n                 (\"last\", []) | (\"skip\", [_]) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }\n@@ -3500,7 +3500,7 @@ impl Methods {\n                     } else {\n                         map_err_ignore::check(cx, expr, m_arg);\n                     }\n-                    if let Some((name, recv2, [args @ ..], span2)) = method_call(recv) {\n+                    if let Some((name, recv2, args, span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n                             (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n@@ -3520,7 +3520,7 @@ impl Methods {\n                     manual_ok_or::check(cx, expr, recv, def, map);\n                 },\n                 (\"next\", []) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _)) = method_call(recv) {\n                         match (name2, args2) {\n                             (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv, recv2, false, false),\n                             (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n@@ -3593,7 +3593,7 @@ impl Methods {\n                 },\n                 (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n                 (\"take\", [_arg]) => {\n-                    if let Some((name2, recv2, [args2 @ ..], _span2)) = method_call(recv) {\n+                    if let Some((name2, recv2, args2, _span2)) = method_call(recv) {\n                         if let (\"cloned\", []) = (name2, args2) {\n                             iter_overeager_cloned::check(cx, expr, recv, recv2, false, false);\n                         }"}, {"sha": "44b21e7b080d22c6aa8c8654ceb76b226ccba6d2", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -109,14 +109,12 @@ fn fetch_const<'a>(\n     args: &'a [Expr<'a>],\n     m: MinMax,\n ) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n-    if (receiver.is_some() && args.len() != 1) || (receiver.is_none() && args.len() != 2) {\n+    let mut args = receiver.into_iter().chain(args.into_iter());\n+    let arg0 = args.next()?;\n+    let arg1 = args.next()?;\n+    if args.next().is_some() {\n         return None;\n     }\n-    let (arg0, arg1) = if let Some(receiver) = receiver {\n-        (receiver, &args[0])\n-    } else {\n-        (&args[0], &args[1])\n-    };\n     constant_simple(cx, cx.typeck_results(), arg0).map_or_else(\n         || constant_simple(cx, cx.typeck_results(), arg1).map(|c| (m, c, arg0)),\n         |c| {"}, {"sha": "cfc181e435b9c9da1068a6d642a16d4d9f789b71", "filename": "src/tools/clippy/clippy_lints/src/unused_peekable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea1c5f5c82318102d759bbc83d4cc48aa876db9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_peekable.rs?ref=fea1c5f5c82318102d759bbc83d4cc48aa876db9", "patch": "@@ -150,7 +150,7 @@ impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n                                     ..\n                                 },\n                                 self_arg,\n-                                [remaining_args @ ..],\n+                                remaining_args,\n                                 _,\n                             ) => {\n                                 let method_name = method_name_ident.name.as_str();"}]}