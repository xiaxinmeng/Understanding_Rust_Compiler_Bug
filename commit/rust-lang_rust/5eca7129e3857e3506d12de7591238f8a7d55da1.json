{"sha": "5eca7129e3857e3506d12de7591238f8a7d55da1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlY2E3MTI5ZTM4NTdlMzUwNmQxMmRlNzU5MTIzOGY4YTdkNTVkYTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-18T00:39:47Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-18T00:39:47Z"}, "message": "rustc: Switch mutability from being a type constructor to a field annotation", "tree": {"sha": "54701099b4b723539074b662daaf3290e63d51e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54701099b4b723539074b662daaf3290e63d51e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eca7129e3857e3506d12de7591238f8a7d55da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eca7129e3857e3506d12de7591238f8a7d55da1", "html_url": "https://github.com/rust-lang/rust/commit/5eca7129e3857e3506d12de7591238f8a7d55da1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eca7129e3857e3506d12de7591238f8a7d55da1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed96688be5ae2c9b433cf8b00a207ce21e630562", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed96688be5ae2c9b433cf8b00a207ce21e630562", "html_url": "https://github.com/rust-lang/rust/commit/ed96688be5ae2c9b433cf8b00a207ce21e630562"}], "stats": {"total": 607, "additions": 327, "deletions": 280}, "files": [{"sha": "e519d03bf2c15b3c4026d92bf8e4095bcddc9267", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -168,7 +168,6 @@ tag unop {\n     bitnot;\n     not;\n     neg;\n-    _mutable;\n }\n \n fn unop_to_str(unop op) -> str {\n@@ -178,7 +177,6 @@ fn unop_to_str(unop op) -> str {\n         case (bitnot) {ret \"~\";}\n         case (not) {ret \"!\";}\n         case (neg) {ret \"-\";}\n-        case (_mutable) {ret \"mutable\";}\n     }\n }\n \n@@ -215,7 +213,7 @@ type field = rec(mutability mut, ident ident, @expr expr);\n \n type expr = spanned[expr_];\n tag expr_ {\n-    expr_vec(vec[@expr], ann);\n+    expr_vec(vec[@expr], mutability, ann);\n     expr_tup(vec[elt], ann);\n     expr_rec(vec[field], option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n@@ -263,7 +261,8 @@ tag lit_ {\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n \n-type ty_field = rec(ident ident, @ty ty);\n+type mt = rec(@ty ty, mutability mut);\n+type ty_field = rec(ident ident, mt mt);\n type ty_arg = rec(mode mode, @ty ty);\n // TODO: effect\n type ty_method = rec(proto proto, ident ident,\n@@ -277,16 +276,15 @@ tag ty_ {\n     ty_machine(util.common.ty_mach);\n     ty_char;\n     ty_str;\n-    ty_box(@ty);\n-    ty_vec(@ty);\n+    ty_box(mt);\n+    ty_vec(mt);\n     ty_port(@ty);\n     ty_chan(@ty);\n-    ty_tup(vec[@ty]);\n+    ty_tup(vec[mt]);\n     ty_rec(vec[ty_field]);\n     ty_fn(proto, vec[ty_arg], @ty);        // TODO: effect\n     ty_obj(vec[ty_method]);\n     ty_path(path, option.t[def]);\n-    ty_mutable(@ty);\n     ty_type;\n     ty_constr(@ty, vec[@constr]);\n }"}, {"sha": "71f0f2d891dab33ccf14ae43987d6ee41f13b18b", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -189,6 +189,11 @@ impure fn parse_ty_fn(ast.proto proto, parser p,\n         if (p.peek() == token.BINOP(token.AND)) {\n             p.bump();\n             mode = ast.alias;\n+\n+            if (p.peek() == token.MUTABLE) {\n+                p.bump();\n+                // TODO: handle mutable alias args\n+            }\n         } else {\n             mode = ast.val;\n         }\n@@ -262,10 +267,16 @@ impure fn parse_ty_obj(parser p, &mutable ast.span hi) -> ast.ty_ {\n     ret ast.ty_obj(meths.node);\n }\n \n+impure fn parse_mt(parser p) -> ast.mt {\n+    auto mut = parse_mutability(p);\n+    auto t = parse_ty(p);\n+    ret rec(ty=t, mut=mut);\n+}\n+\n impure fn parse_ty_field(parser p) -> ast.ty_field {\n-    auto ty = parse_ty(p);\n+    auto mt = parse_mt(p);\n     auto id = parse_ident(p);\n-    ret rec(ident=id, ty=ty);\n+    ret rec(ident=id, mt=mt);\n }\n \n impure fn parse_constr_arg(parser p) -> @ast.constr_arg {\n@@ -360,25 +371,25 @@ impure fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.AT) {\n             p.bump();\n-            auto t0 = parse_ty(p);\n-            hi = t0.span;\n-            t = ast.ty_box(t0);\n+            auto mt = parse_mt(p);\n+            hi = mt.ty.span;\n+            t = ast.ty_box(mt);\n         }\n \n         case (token.VEC) {\n             p.bump();\n             expect(p, token.LBRACKET);\n-            t = ast.ty_vec(parse_ty(p));\n+            t = ast.ty_vec(parse_mt(p));\n             hi = p.get_span();\n             expect(p, token.RBRACKET);\n         }\n \n         case (token.TUP) {\n             p.bump();\n-            auto f = parse_ty; // FIXME: trans_const_lval bug\n-            auto elems = parse_seq[@ast.ty] (token.LPAREN,\n-                                             token.RPAREN,\n-                                             some(token.COMMA), f, p);\n+            auto f = parse_mt; // FIXME: trans_const_lval bug\n+            auto elems = parse_seq[ast.mt] (token.LPAREN,\n+                                            token.RPAREN,\n+                                            some(token.COMMA), f, p);\n             hi = elems.span;\n             t = ast.ty_tup(elems.node);\n         }\n@@ -395,13 +406,6 @@ impure fn parse_ty(parser p) -> @ast.ty {\n             t = ast.ty_rec(elems.node);\n         }\n \n-        case (token.MUTABLE) {\n-            p.bump();\n-            auto t0 = parse_ty(p);\n-            hi = t0.span;\n-            t = ast.ty_mutable(t0);\n-        }\n-\n         case (token.FN) {\n             auto flo = p.get_span();\n             p.bump();\n@@ -463,20 +467,22 @@ impure fn parse_arg(parser p) -> ast.arg {\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n         p.bump();\n+\n+        if (p.peek() == token.MUTABLE) {\n+            // TODO: handle mutable alias args\n+            p.bump();\n+        }\n     }\n     let @ast.ty t = parse_ty(p);\n     let ast.ident i = parse_ident(p);\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n-impure fn parse_seq[T](token.token bra,\n-                      token.token ket,\n-                      option.t[token.token] sep,\n-                      (impure fn(parser) -> T) f,\n-                      parser p) -> util.common.spanned[vec[T]] {\n+impure fn parse_seq_to_end[T](token.token ket,\n+                              option.t[token.token] sep,\n+                              (impure fn(parser) -> T) f,\n+                              parser p) -> vec[T] {\n     let bool first = true;\n-    auto lo = p.get_span();\n-    expect(p, bra);\n     let vec[T] v = vec();\n     while (p.peek() != ket) {\n         alt(sep) {\n@@ -494,9 +500,20 @@ impure fn parse_seq[T](token.token bra,\n         let T t = f(p);\n         v += vec(t);\n     }\n-    auto hi = p.get_span();\n     expect(p, ket);\n-    ret spanned(lo, hi, v);\n+    ret v;\n+}\n+\n+impure fn parse_seq[T](token.token bra,\n+                      token.token ket,\n+                      option.t[token.token] sep,\n+                      (impure fn(parser) -> T) f,\n+                      parser p) -> util.common.spanned[vec[T]] {\n+    auto lo = p.get_span();\n+    expect(p, bra);\n+    auto result = parse_seq_to_end[T](ket, sep, f, p);\n+    auto hi = p.get_span();\n+    ret spanned(lo, hi, result);\n }\n \n impure fn parse_lit(parser p) -> ast.lit {\n@@ -667,12 +684,15 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.VEC) {\n             p.bump();\n             auto pf = parse_expr;\n-            auto es = parse_seq[@ast.expr](token.LPAREN,\n-                                           token.RPAREN,\n-                                           some(token.COMMA),\n-                                           pf, p);\n-            hi = es.span;\n-            ex = ast.expr_vec(es.node, ast.ann_none);\n+\n+            expect(p, token.LPAREN);\n+            auto mut = parse_mutability(p);\n+\n+            auto es = parse_seq_to_end[@ast.expr](token.RPAREN,\n+                                                  some(token.COMMA),\n+                                                  pf, p);\n+            hi = p.get_span();\n+            ex = ast.expr_vec(es, mut, ast.ann_none);\n         }\n \n         case (token.REC) {\n@@ -1004,13 +1024,6 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n             ex = ast.expr_unary(ast.box, e, ast.ann_none);\n         }\n \n-        case (token.MUTABLE) {\n-            p.bump();\n-            auto e = parse_prefix_expr(p);\n-            hi = e.span;\n-            ex = ast.expr_unary(ast._mutable, e, ast.ann_none);\n-        }\n-\n         case (_) {\n             ret parse_dot_or_call_expr(p);\n         }\n@@ -1558,7 +1571,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n         }\n         case (ast.stmt_expr(?e)) {\n             alt (e.node) {\n-                case (ast.expr_vec(_,_))        { ret true; }\n+                case (ast.expr_vec(_,_,_))      { ret true; }\n                 case (ast.expr_tup(_,_))        { ret true; }\n                 case (ast.expr_rec(_,_,_))      { ret true; }\n                 case (ast.expr_call(_,_,_))     { ret true; }\n@@ -1722,6 +1735,7 @@ impure fn parse_item_fn_or_iter(parser p, ast.effect eff) -> @ast.item {\n \n \n impure fn parse_obj_field(parser p) -> ast.obj_field {\n+    auto mut = parse_mutability(p); // TODO: store this, use it in typeck\n     auto ty = parse_ty(p);\n     auto ident = parse_ident(p);\n     ret rec(ty=ty, ident=ident, id=p.next_def_id(), ann=ast.ann_none);"}, {"sha": "703c7ea4400abfb617cf5a567bc38afdc879b4ae", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -28,6 +28,7 @@ import front.ast.arm;\n import front.ast.def;\n import front.ast.def_id;\n import front.ast.ann;\n+import front.ast.mt;\n \n import std._uint;\n import std._vec;\n@@ -46,10 +47,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ty_mach tm) -> @ty)    fold_ty_machine,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_char,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_str,\n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_box,\n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_vec,\n+     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_box,\n+     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_vec,\n \n-     (fn(&ENV e, &span sp, vec[@ty] elts) -> @ty) fold_ty_tup,\n+     (fn(&ENV e, &span sp, vec[mt] elts) -> @ty)  fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n          vec[ast.ty_field] elts) -> @ty)          fold_ty_rec,\n@@ -65,13 +66,13 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ast.path p,\n          &option.t[def] d) -> @ty)                fold_ty_path,\n \n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_mutable,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_chan,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_port,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         vec[@expr] es, ann a) -> @expr)          fold_expr_vec,\n+         vec[@expr] es, ast.mutability mut,\n+         ann a) -> @expr)                         fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n          vec[ast.elt] es, ann a) -> @expr)        fold_expr_tup,\n@@ -343,29 +344,31 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         case (ast.ty_char) { ret fld.fold_ty_char(env_, t.span); }\n         case (ast.ty_str) { ret fld.fold_ty_str(env_, t.span); }\n \n-        case (ast.ty_box(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_box(env_, t.span, ty_);\n+        case (ast.ty_box(?tm)) {\n+            auto ty_ = fold_ty(env, fld, tm.ty);\n+            ret fld.fold_ty_box(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n-        case (ast.ty_vec(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_vec(env_, t.span, ty_);\n+        case (ast.ty_vec(?tm)) {\n+            auto ty_ = fold_ty(env, fld, tm.ty);\n+            ret fld.fold_ty_vec(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n         case (ast.ty_tup(?elts)) {\n-            let vec[@ty] elts_ = vec();\n-            for (@ty elt in elts) {\n-                _vec.push[@ty](elts_,fold_ty(env, fld, elt));\n+            let vec[mt] elts_ = vec();\n+            for (mt elt in elts) {\n+                auto ty_ = fold_ty(env, fld, elt.ty);\n+                _vec.push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n \n         case (ast.ty_rec(?flds)) {\n             let vec[ast.ty_field] flds_ = vec();\n             for (ast.ty_field f in flds) {\n+                auto ty_ = fold_ty(env, fld, f.mt.ty);\n                 _vec.push[ast.ty_field]\n-                    (flds_, rec(ty=fold_ty(env, fld, f.ty) with f));\n+                    (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n         }\n@@ -391,11 +394,6 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             ret fld.fold_ty_path(env_, t.span, pth_, ref_opt);\n         }\n \n-        case (ast.ty_mutable(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_mutable(env_, t.span, ty_);\n-        }\n-\n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n         }\n@@ -516,9 +514,9 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n     }\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es, ?t)) {\n+        case (ast.expr_vec(?es, ?mut, ?t)) {\n             auto ees = fold_exprs(env_, fld, es);\n-            ret fld.fold_expr_vec(env_, e.span, ees, t);\n+            ret fld.fold_expr_vec(env_, e.span, ees, mut, t);\n         }\n \n         case (ast.expr_tup(?es, ?t)) {\n@@ -1077,16 +1075,16 @@ fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_str);\n }\n \n-fn identity_fold_ty_box[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_box(t));\n+fn identity_fold_ty_box[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n+    ret @respan(sp, ast.ty_box(tm));\n }\n \n-fn identity_fold_ty_vec[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_vec(t));\n+fn identity_fold_ty_vec[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n+    ret @respan(sp, ast.ty_vec(tm));\n }\n \n fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n-                             vec[@ty] elts) -> @ty {\n+                             vec[mt] elts) -> @ty {\n     ret @respan(sp, ast.ty_tup(elts));\n }\n \n@@ -1112,10 +1110,6 @@ fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n     ret @respan(sp, ast.ty_path(p, d));\n }\n \n-fn identity_fold_ty_mutable[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_mutable(t));\n-}\n-\n fn identity_fold_ty_chan[ENV](&ENV env, &span sp, @ty t) -> @ty {\n     ret @respan(sp, ast.ty_chan(t));\n }\n@@ -1127,8 +1121,8 @@ fn identity_fold_ty_port[ENV](&ENV env, &span sp, @ty t) -> @ty {\n // Expr identities.\n \n fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n-                               ann a) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es, a));\n+                               ast.mutability mut, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_vec(es, mut, a));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n@@ -1528,11 +1522,10 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n          fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n-         fold_ty_mutable = bind identity_fold_ty_mutable[ENV](_,_,_),\n          fold_ty_chan    = bind identity_fold_ty_chan[ENV](_,_,_),\n          fold_ty_port    = bind identity_fold_ty_port[ENV](_,_,_),\n \n-         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_),\n+         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_,_),\n          fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_,_),\n          fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_,_,_),\n          fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_,_),"}, {"sha": "2ef619cb4d2cace2f54d3a057e2edc4f67a9de2c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 57, "deletions": 56, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -614,23 +614,23 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                 llty = T_tag(cx.tn, size);\n             }\n         }\n-        case (ty.ty_box(?t)) {\n-            llty = T_ptr(T_box(type_of_inner(cx, t, true)));\n+        case (ty.ty_box(?mt)) {\n+            llty = T_ptr(T_box(type_of_inner(cx, mt.ty, true)));\n         }\n-        case (ty.ty_vec(?t)) {\n-            llty = T_ptr(T_vec(type_of_inner(cx, t, true)));\n+        case (ty.ty_vec(?mt)) {\n+            llty = T_ptr(T_vec(type_of_inner(cx, mt.ty, true)));\n         }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (@ty.t elt in elts) {\n-                tys += vec(type_of_inner(cx, elt, boxed));\n+            for (ty.mt elt in elts) {\n+                tys += vec(type_of_inner(cx, elt.ty, boxed));\n             }\n             llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += vec(type_of_inner(cx, f.ty, boxed));\n+                tys += vec(type_of_inner(cx, f.mt.ty, boxed));\n             }\n             llty = T_struct(tys);\n         }\n@@ -971,8 +971,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (ast.variant variant in variants) {\n-        let vec[@ty.t] tys = variant_types(cx, variant);\n-        auto tup_ty = ty.plain_ty(ty.ty_tup(tys));\n+        auto tup_ty = ty.plain_tup_ty(variant_types(cx, variant));\n \n         // Perform any type parameter substitutions.\n         tup_ty = ty.substitute_ty_params(ty_params, subtys, tup_ty);\n@@ -1021,12 +1020,16 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n-            ret align_elements(cx, elts);\n+            let vec[@ty.t] tys = vec();\n+            for (ty.mt mt in elts) {\n+                tys += vec(mt.ty);\n+            }\n+            ret align_elements(cx, tys);\n         }\n         case (ty.ty_rec(?flds)) {\n             let vec[@ty.t] tys = vec();\n             for (ty.field f in flds) {\n-                tys += vec(f.ty);\n+                tys += vec(f.mt.ty);\n             }\n             ret align_elements(cx, tys);\n         }\n@@ -1072,8 +1075,8 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n         case (ty.ty_tup(?elts)) {\n             auto a = C_int(1);\n             auto bcx = cx;\n-            for (@ty.t e in elts) {\n-                auto align = align_of(bcx, e);\n+            for (ty.mt e in elts) {\n+                auto align = align_of(bcx, e.ty);\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n@@ -1083,7 +1086,7 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n             auto a = C_int(1);\n             auto bcx = cx;\n             for (ty.field f in flds) {\n-                auto align = align_of(bcx, f.ty);\n+                auto align = align_of(bcx, f.mt.ty);\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n@@ -1183,7 +1186,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(t, ixs, 0u);\n-    auto prefix_ty = plain_ty(ty.ty_tup(s.prefix));\n+    auto prefix_ty = ty.plain_tup_ty(s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -1227,7 +1230,8 @@ fn GEP_tag(@block_ctxt cx,\n \n         i += 1;\n     }\n-    auto tup_ty = ty.plain_ty(ty.ty_tup(true_arg_tys));\n+\n+    auto tup_ty = ty.plain_tup_ty(true_arg_tys);\n \n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n@@ -1267,8 +1271,8 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n-    auto boxed_body = plain_ty(ty.ty_tup(vec(plain_ty(ty.ty_int), t)));\n-    auto box_ptr = plain_ty(ty.ty_box(t));\n+    auto boxed_body = ty.plain_tup_ty(vec(plain_ty(ty.ty_int), t));\n+    auto box_ptr = ty.plain_box_ty(t);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -1566,7 +1570,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                         T_int(), C_int(0));\n         }\n \n-        case (ty.ty_box(?body_ty)) {\n+        case (ty.ty_box(?body_mt)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v,\n                         @ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n@@ -1579,7 +1583,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n             ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind hit_zero(_, v, body_ty),\n+                                        bind hit_zero(_, v, body_mt.ty),\n                                         \"free box\",\n                                         T_int(), C_int(0));\n         }\n@@ -1831,7 +1835,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n         auto tnil = plain_ty(ty.ty_nil);\n-        auto tbox = plain_ty(ty.ty_box(tnil));\n+        auto tbox = ty.plain_box_ty(tnil);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -1846,15 +1850,15 @@ fn iter_structural_ty_full(@block_ctxt cx,\n     alt (t.struct) {\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n-            for (@ty.t arg in args) {\n+            for (ty.mt arg in args) {\n                 r = GEP_tup_like(r.bcx, t, av, vec(0, i));\n                 auto elt_a = r.val;\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto elt_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, elt_a, arg),\n-                      load_scalar_or_boxed(r.bcx, elt_b, arg),\n-                      arg);\n+                      load_scalar_or_boxed(r.bcx, elt_a, arg.ty),\n+                      load_scalar_or_boxed(r.bcx, elt_b, arg.ty),\n+                      arg.ty);\n                 i += 1;\n             }\n         }\n@@ -1866,9 +1870,9 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto llfld_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, llfld_a, fld.ty),\n-                      load_scalar_or_boxed(r.bcx, llfld_b, fld.ty),\n-                      fld.ty);\n+                      load_scalar_or_boxed(r.bcx, llfld_a, fld.mt.ty),\n+                      load_scalar_or_boxed(r.bcx, llfld_b, fld.mt.ty),\n+                      fld.mt.ty);\n                 i += 1;\n             }\n         }\n@@ -2106,8 +2110,8 @@ fn iter_sequence(@block_ctxt cx,\n     }\n \n     alt (t.struct) {\n-        case (ty.ty_vec(?et)) {\n-            ret iter_sequence_body(cx, v, et, f, false);\n+        case (ty.ty_vec(?elt)) {\n+            ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n         case (ty.ty_str) {\n             auto et = plain_ty(ty.ty_machine(common.ty_u8));\n@@ -2397,9 +2401,6 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             }\n             ret res(sub.bcx, val);\n         }\n-        case (ast._mutable) {\n-            ret trans_expr(cx, e);\n-        }\n     }\n     fail;\n }\n@@ -2698,12 +2699,12 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n \n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) {\n+            case (ty.ty_box(?mt)) {\n                 auto body = cx.build.GEP(v1,\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n-                t1 = inner;\n-                v1 = load_scalar_or_boxed(cx, body, inner);\n+                t1 = mt.ty;\n+                v1 = load_scalar_or_boxed(cx, body, t1);\n             }\n             case (_) {\n                 ret res(cx, v1);\n@@ -2717,8 +2718,8 @@ fn autoderefed_ty(@ty.t t) -> @ty.t {\n \n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) {\n-                t1 = inner;\n+            case (ty.ty_box(?mt)) {\n+                t1 = mt.ty;\n             }\n             case (_) {\n                 ret t1;\n@@ -3483,7 +3484,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     r = autoderef(r.bcx, r.val, t);\n     t = autoderefed_ty(t);\n     alt (t.struct) {\n-        case (ty.ty_tup(?fields)) {\n+        case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(v.bcx, v.val);\n@@ -3623,7 +3624,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llclosure_ptr_ty = type_of(cx, plain_ty(ty.ty_box(closure_ty)));\n+    auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -3795,7 +3796,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n+            let @ty.t bindings_ty = ty.plain_tup_ty(bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n@@ -3809,9 +3810,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n-                    plain_ty(ty.ty_tup(captured_tys)));\n+                    ty.plain_tup_ty(captured_tys));\n \n-            let @ty.t closure_ty = plain_ty(ty.ty_tup(closure_tys));\n+            let @ty.t closure_ty = ty.plain_tup_ty(closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n@@ -4155,8 +4156,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto unit_ty = t;\n     alt (t.struct) {\n-        case (ty.ty_vec(?t)) {\n-            unit_ty = t;\n+        case (ty.ty_vec(?mt)) {\n+            unit_ty = mt.ty;\n         }\n         case (_) {\n             cx.fcx.ccx.sess.bug(\"non-vec type in trans_vec\");\n@@ -4183,8 +4184,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n                                            C_int(abi.vec_elt_data)));\n \n     auto pseudo_tup_ty =\n-        plain_ty(ty.ty_tup(_vec.init_elt[@ty.t](unit_ty,\n-                                                _vec.len[@ast.expr](args))));\n+        ty.plain_tup_ty(_vec.init_elt[@ty.t](unit_ty,\n+                                             _vec.len[@ast.expr](args)));\n     let int i = 0;\n \n     for (@ast.expr e in args) {\n@@ -4253,7 +4254,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     }\n \n     for (ty.field tf in ty_fields) {\n-        auto e_ty = tf.ty;\n+        auto e_ty = tf.mt.ty;\n         auto dst_res = GEP_tup_like(bcx, t, rec_val, vec(0, i));\n         bcx = dst_res.bcx;\n \n@@ -4359,7 +4360,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_cast(cx, e, ann);\n         }\n \n-        case (ast.expr_vec(?args, ?ann)) {\n+        case (ast.expr_vec(?args, _, ?ann)) {\n             ret trans_vec(cx, args, ann);\n         }\n \n@@ -4910,7 +4911,7 @@ fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) -> result {\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n-    auto fields_tup_ty = ty.plain_ty(ty.ty_tup(field_tys));\n+    auto fields_tup_ty = ty.plain_tup_ty(field_tys);\n \n     auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.ccx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.ccx.tn, n_typarams);\n@@ -5102,12 +5103,12 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n             _vec.push[@ty.t](tps, tydesc_ty);\n         }\n \n-        let @ty.t typarams_ty = plain_ty(ty.ty_tup(tps));\n-        let @ty.t fields_ty = plain_ty(ty.ty_tup(obj_fields));\n-        let @ty.t body_ty = plain_ty(ty.ty_tup(vec(tydesc_ty,\n-                                                   typarams_ty,\n-                                                   fields_ty)));\n-        let @ty.t boxed_body_ty = plain_ty(ty.ty_box(body_ty));\n+        let @ty.t typarams_ty = ty.plain_tup_ty(tps);\n+        let @ty.t fields_ty = ty.plain_tup_ty(obj_fields);\n+        let @ty.t body_ty = ty.plain_tup_ty(vec(tydesc_ty,\n+                                                typarams_ty,\n+                                                fields_ty));\n+        let @ty.t boxed_body_ty = ty.plain_box_ty(body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);"}, {"sha": "3d10462ad653d0ae04a67d4bbf8121bdf166c881", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 100, "deletions": 58, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -17,15 +17,17 @@ import util.common.span;\n // Data types\n \n type arg = rec(ast.mode mode, @t ty);\n-type field = rec(ast.ident ident, @t ty);\n+type field = rec(ast.ident ident, mt mt);\n type method = rec(ast.proto proto,\n                   ast.ident ident,\n                   vec[arg] inputs,\n                   @t output);\n \n+type mt = rec(@t ty, ast.mutability mut);\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n-type t = rec(sty struct, mutability mut, option.t[str] cname);\n+type t = rec(sty struct, option.t[str] cname);\n tag sty {\n     ty_nil;\n     ty_bool;\n@@ -35,11 +37,11 @@ tag sty {\n     ty_char;\n     ty_str;\n     ty_tag(ast.def_id, vec[@t]);\n-    ty_box(@t);\n-    ty_vec(@t);\n+    ty_box(mt);\n+    ty_vec(mt);\n     ty_port(@t);\n     ty_chan(@t);\n-    ty_tup(vec[@t]);\n+    ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n     ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n     ty_native_fn(ast.native_abi, vec[arg], @t);     // TODO: effect\n@@ -65,6 +67,8 @@ type unify_handler = obj {\n \n tag type_err {\n     terr_mismatch;\n+    terr_box_mutability;\n+    terr_vec_mutability;\n     terr_tuple_size(uint, uint);\n     terr_tuple_mutability;\n     terr_record_size(uint, uint);\n@@ -138,14 +142,20 @@ fn ty_to_str(&@t typ) -> str {\n     }\n \n     fn field_to_str(&field f) -> str {\n-        ret ty_to_str(f.ty) + \" \" + f.ident;\n+        ret mt_to_str(f.mt) + \" \" + f.ident;\n     }\n \n-    auto s = \"\";\n-    if (typ.mut == ast.mut) {\n-        s += \"mutable \";\n+    fn mt_to_str(&mt m) -> str {\n+        auto mstr;\n+        alt (m.mut) {\n+            case (ast.mut) { mstr = \"mutable \"; }\n+            case (ast.imm) { mstr = \"\";         }\n+        }\n+\n+        ret mstr + ty_to_str(m.ty);\n     }\n \n+    auto s = \"\";\n     alt (typ.struct) {\n         case (ty_native)       { s += \"native\";                     }\n         case (ty_nil)          { s += \"()\";                         }\n@@ -155,15 +165,15 @@ fn ty_to_str(&@t typ) -> str {\n         case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);    }\n         case (ty_char)         { s += \"char\";                       }\n         case (ty_str)          { s += \"str\";                        }\n-        case (ty_box(?t))      { s += \"@\" + ty_to_str(t);           }\n-        case (ty_vec(?t))      { s += \"vec[\" + ty_to_str(t) + \"]\";  }\n+        case (ty_box(?tm))     { s += \"@\" + mt_to_str(tm);          }\n+        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(tm) + \"]\"; }\n         case (ty_port(?t))     { s += \"port[\" + ty_to_str(t) + \"]\"; }\n         case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(t) + \"]\"; }\n         case (ty_type)         { s += \"type\";                       }\n \n         case (ty_tup(?elems)) {\n-            auto f = ty_to_str;\n-            auto strs = _vec.map[@t,str](f, elems);\n+            auto f = mt_to_str;\n+            auto strs = _vec.map[mt,str](f, elems);\n             s += \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n@@ -224,7 +234,7 @@ type ty_fold = state obj {\n \n fn fold_ty(ty_fold fld, @t ty) -> @t {\n     fn rewrap(@t orig, &sty new) -> @t {\n-        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n+        ret @rec(struct=new, cname=orig.cname);\n     }\n \n     alt (ty.struct) {\n@@ -237,11 +247,11 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n         case (ty_str)           { ret fld.fold_simple_ty(ty); }\n         case (ty_type)          { ret fld.fold_simple_ty(ty); }\n         case (ty_native)        { ret fld.fold_simple_ty(ty); }\n-        case (ty_box(?subty)) {\n-            ret rewrap(ty, ty_box(fold_ty(fld, subty)));\n+        case (ty_box(?tm)) {\n+            ret rewrap(ty, ty_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n-        case (ty_vec(?subty)) {\n-            ret rewrap(ty, ty_vec(fold_ty(fld, subty)));\n+        case (ty_vec(?tm)) {\n+            ret rewrap(ty, ty_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n         case (ty_port(?subty)) {\n             ret rewrap(ty, ty_port(fold_ty(fld, subty)));\n@@ -256,18 +266,20 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_tag(tid, new_subtys));\n         }\n-        case (ty_tup(?subtys)) {\n-            let vec[@t] new_subtys = vec();\n-            for (@t subty in subtys) {\n-                new_subtys += vec(fold_ty(fld, subty));\n+        case (ty_tup(?mts)) {\n+            let vec[mt] new_mts = vec();\n+            for (mt tm in mts) {\n+                auto new_subty = fold_ty(fld, tm.ty);\n+                new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ret rewrap(ty, ty_tup(new_subtys));\n+            ret rewrap(ty, ty_tup(new_mts));\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n             for (field fl in fields) {\n-                auto new_ty = fold_ty(fld, fl.ty);\n-                new_fields += vec(rec(ident=fl.ident, ty=new_ty));\n+                auto new_ty = fold_ty(fld, fl.mt.ty);\n+                auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n+                new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n             ret rewrap(ty, ty_rec(new_fields));\n         }\n@@ -351,8 +363,8 @@ fn type_is_sequence(@t ty) -> bool {\n \n fn sequence_element_type(@t ty) -> @t {\n     alt (ty.struct) {\n-        case (ty_str)     { ret plain_ty(ty_machine(common.ty_u8)); }\n-        case (ty_vec(?e)) { ret e; }\n+        case (ty_str)      { ret plain_ty(ty_machine(common.ty_u8)); }\n+        case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n }\n@@ -372,11 +384,11 @@ fn type_is_tup_like(@t ty) -> bool {\n fn get_element_type(@t ty, uint i) -> @t {\n     check (type_is_tup_like(ty));\n     alt (ty.struct) {\n-        case (ty_tup(?tys)) {\n-            ret tys.(i);\n+        case (ty_tup(?mts)) {\n+            ret mts.(i).ty;\n         }\n         case (ty_rec(?flds)) {\n-            ret flds.(i).ty;\n+            ret flds.(i).mt.ty;\n         }\n     }\n     fail;\n@@ -427,17 +439,17 @@ fn type_is_native(@t ty) -> bool {\n \n fn type_has_dynamic_size(@t ty) -> bool {\n     alt (ty.struct) {\n-        case (ty_tup(?ts)) {\n+        case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < _vec.len[@t](ts)) {\n-                if (type_has_dynamic_size(ts.(i))) { ret true; }\n+            while (i < _vec.len[mt](mts)) {\n+                if (type_has_dynamic_size(mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n             while (i < _vec.len[field](fields)) {\n-                if (type_has_dynamic_size(fields.(i).ty)) { ret true; }\n+                if (type_has_dynamic_size(fields.(i).mt.ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n@@ -518,7 +530,19 @@ fn type_param(@t ty) -> option.t[ast.def_id] {\n }\n \n fn plain_ty(&sty st) -> @t {\n-    ret @rec(struct=st, mut=ast.imm, cname=none[str]);\n+    ret @rec(struct=st, cname=none[str]);\n+}\n+\n+fn plain_box_ty(@t subty) -> @t {\n+    ret plain_ty(ty_box(rec(ty=subty, mut=ast.imm)));\n+}\n+\n+fn plain_tup_ty(vec[@t] elem_tys) -> @t {\n+    let vec[ty.mt] mts = vec();\n+    for (@ty.t typ in elem_tys) {\n+        mts += vec(rec(ty=typ, mut=ast.imm));\n+    }\n+    ret plain_ty(ty_tup(mts));\n }\n \n fn hash_ty(&@t ty) -> uint {\n@@ -703,7 +727,7 @@ fn pat_ty(@ast.pat pat) -> @t {\n \n fn expr_ty(@ast.expr expr) -> @t {\n     alt (expr.node) {\n-        case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_vec(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_rec(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_bind(_, _, ?ann))      { ret ann_to_type(ann); }\n@@ -1131,16 +1155,23 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret ures_err(terr_mismatch, expected, actual);\n             }\n \n-            case (ty.ty_box(?expected_sub)) {\n+            case (ty.ty_box(?expected_mt)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_box(?actual_sub)) {\n+                    case (ty.ty_box(?actual_mt)) {\n+                        if (expected_mt.mut != actual_mt.mut) {\n+                            ret ures_err(terr_box_mutability, expected,\n+                                         actual);\n+                        }\n+\n                         auto result = unify_step(bindings,\n-                                                 expected_sub,\n-                                                 actual_sub,\n+                                                 expected_mt.ty,\n+                                                 actual_mt.ty,\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_box(result_sub)));\n+                                auto mt = rec(ty=result_sub,\n+                                              mut=expected_mt.mut);\n+                                ret ures_ok(plain_ty(ty.ty_box(mt)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1154,16 +1185,23 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n             }\n \n-            case (ty.ty_vec(?expected_sub)) {\n+            case (ty.ty_vec(?expected_mt)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_vec(?actual_sub)) {\n+                    case (ty.ty_vec(?actual_mt)) {\n+                        if (expected_mt.mut != actual_mt.mut) {\n+                            ret ures_err(terr_vec_mutability, expected,\n+                                         actual);\n+                        }\n+\n                         auto result = unify_step(bindings,\n-                                                 expected_sub,\n-                                                 actual_sub,\n+                                                 expected_mt.ty,\n+                                                 actual_mt.ty,\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_vec(result_sub)));\n+                                auto mt = rec(ty=result_sub,\n+                                              mut=expected_mt.mut);\n+                                ret ures_ok(plain_ty(ty.ty_vec(mt)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1226,8 +1264,8 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             case (ty.ty_tup(?expected_elems)) {\n                 alt (actual.struct) {\n                     case (ty.ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec.len[@ty.t](expected_elems);\n-                        auto actual_len = _vec.len[@ty.t](actual_elems);\n+                        auto expected_len = _vec.len[ty.mt](expected_elems);\n+                        auto actual_len = _vec.len[ty.mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -1236,7 +1274,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[@ty.t] result_elems = vec();\n+                        let vec[ty.mt] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n@@ -1247,12 +1285,14 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                             }\n \n                             auto result = unify_step(bindings,\n-                                                     expected_elem,\n-                                                     actual_elem,\n+                                                     expected_elem.ty,\n+                                                     actual_elem.ty,\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    _vec.push[@ty.t](result_elems,rty);\n+                                    auto mt = rec(ty=rty,\n+                                                  mut=expected_elem.mut);\n+                                    result_elems += vec(mt);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1289,29 +1329,31 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         while (i < expected_len) {\n                             auto expected_field = expected_fields.(i);\n                             auto actual_field = actual_fields.(i);\n-                            if (expected_field.ty.mut\n-                                != actual_field.ty.mut) {\n+                            if (expected_field.mt.mut\n+                                    != actual_field.mt.mut) {\n                                 auto err = terr_record_mutability;\n                                 ret ures_err(err, expected, actual);\n                             }\n \n                             if (!_str.eq(expected_field.ident,\n-                                        actual_field.ident)) {\n+                                         actual_field.ident)) {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n                                                        actual_field.ident);\n                                 ret ures_err(err, expected, actual);\n                             }\n \n                             auto result = unify_step(bindings,\n-                                                     expected_field.ty,\n-                                                     actual_field.ty,\n+                                                     expected_field.mt.ty,\n+                                                     actual_field.mt.ty,\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n+                                    auto mt = rec(ty=rty,\n+                                                  mut=expected_field.mt.mut);\n                                     _vec.push[field]\n                                         (result_fields,\n-                                         rec(ty=rty with expected_field));\n+                                         rec(mt=mt with expected_field));\n                                 }\n                                 case (_) {\n                                     ret result;"}, {"sha": "5279b71378ff7247aa89d0d184e9740519ae842e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -276,6 +276,10 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n     }\n \n+    fn ast_mt_to_mt(ty_getter getter, &ast.mt mt) -> ty.mt {\n+        ret rec(ty=ast_ty_to_ty(getter, mt.ty), mut=mt.mut);\n+    }\n+\n     fn instantiate(ty_getter getter, ast.def_id id,\n                    vec[@ast.ty] args) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n@@ -305,8 +309,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         case (ast.ty_machine(?tm)) { sty = ty.ty_machine(tm); }\n         case (ast.ty_char)         { sty = ty.ty_char; }\n         case (ast.ty_str)          { sty = ty.ty_str; }\n-        case (ast.ty_box(?t)) { sty = ty.ty_box(ast_ty_to_ty(getter, t)); }\n-        case (ast.ty_vec(?t)) { sty = ty.ty_vec(ast_ty_to_ty(getter, t)); }\n+        case (ast.ty_box(?mt)) { sty = ty.ty_box(ast_mt_to_mt(getter, mt)); }\n+        case (ast.ty_vec(?mt)) { sty = ty.ty_vec(ast_mt_to_mt(getter, mt)); }\n \n         case (ast.ty_port(?t)) {\n             sty = ty.ty_port(ast_ty_to_ty(getter, t));\n@@ -317,17 +321,17 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         }\n \n         case (ast.ty_tup(?fields)) {\n-            let vec[@ty.t] flds = vec();\n-            for (@ast.ty field in fields) {\n-                _vec.push[@ty.t](flds, ast_ty_to_ty(getter, field));\n+            let vec[ty.mt] flds = vec();\n+            for (ast.mt field in fields) {\n+                _vec.push[ty.mt](flds, ast_mt_to_mt(getter, field));\n             }\n             sty = ty.ty_tup(flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n                 _vec.push[field](flds, rec(ident=f.ident,\n-                                        ty=ast_ty_to_ty(getter, f.ty)));\n+                                        mt=ast_mt_to_mt(getter, f.mt)));\n             }\n             sty = ty.ty_rec(flds);\n         }\n@@ -357,13 +361,6 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n             cname = some(path_to_str(path));\n         }\n \n-        case (ast.ty_mutable(?t)) {\n-            mut = ast.mut;\n-            auto t0 = ast_ty_to_ty(getter, t);\n-            sty = t0.struct;\n-            cname = t0.cname;\n-        }\n-\n         case (ast.ty_obj(?meths)) {\n             let vec[ty.method] tmeths = vec();\n             auto f = bind ast_arg_to_arg(getter, _);\n@@ -381,7 +378,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         }\n     }\n \n-    ret @rec(struct=sty, mut=mut, cname=cname);\n+    ret @rec(struct=sty, cname=cname);\n }\n \n fn actual_type(@ty.t t, @ast.item item) -> @ty.t {\n@@ -638,8 +635,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     // Avoid repeating work.\n                     ret item_to_ty.get(def_id);\n                 }\n-                auto x =\n-                    @rec(struct=ty.ty_native, mut=ast.imm, cname=none[str]);\n+                auto x = @rec(struct=ty.ty_native, cname=none[str]);\n                 item_to_ty.insert(def_id, x);\n                 ret x;\n             }\n@@ -973,7 +969,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) { t1 = inner; }\n+            case (ty.ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n     }\n@@ -983,7 +979,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n fn add_boxes(uint n, @ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = plain_ty(ty.ty_box(t1));\n+        t1 = ty.plain_box_ty(t1);\n         n -= 1u;\n     }\n     ret t1;\n@@ -995,7 +991,7 @@ fn count_boxes(@ty.t t) -> uint {\n     auto t1 = t;\n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) { n += 1u; t1 = inner; }\n+            case (ty.ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n     }\n@@ -1143,30 +1139,32 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n     auto e_1;\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es_0, ?ann)) {\n+        case (ast.expr_vec(?es_0, ?mut, ?ann)) {\n+            // TODO: enforce mutability\n+\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[@ast.expr] es_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_vec(?subty)) {\n+                case (ty.ty_vec(?mt)) {\n                     for (@ast.expr e_0 in es_0) {\n-                        es_1 += vec(demand_expr(fcx, subty, e_0));\n+                        es_1 += vec(demand_expr(fcx, mt.ty, e_0));\n                     }\n                 }\n                 case (_) {\n                     log \"vec expr doesn't have a vec type!\";\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_vec(es_1, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_vec(es_1, mut, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_tup(?es_0, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.elt] elts_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_tup(?subtys)) {\n+                case (ty.ty_tup(?mts)) {\n                     auto i = 0u;\n                     for (ast.elt elt_0 in es_0) {\n-                        auto e_1 = demand_expr(fcx, subtys.(i), elt_0.expr);\n+                        auto e_1 = demand_expr(fcx, mts.(i).ty, elt_0.expr);\n                         elts_1 += vec(rec(mut=elt_0.mut, expr=e_1));\n                         i += 1u;\n                     }\n@@ -1185,15 +1183,15 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.field] fields_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_rec(?field_tys)) {\n+                case (ty.ty_rec(?field_mts)) {\n                     alt (base_0) {\n                         case (none[@ast.expr]) {\n                             auto i = 0u;\n                             for (ast.field field_0 in fields_0) {\n                                 check (_str.eq(field_0.ident,\n-                                               field_tys.(i).ident));\n+                                               field_mts.(i).ident));\n                                 auto e_1 = demand_expr(fcx,\n-                                                       field_tys.(i).ty,\n+                                                       field_mts.(i).mt.ty,\n                                                        field_0.expr);\n                                 fields_1 += vec(rec(mut=field_0.mut,\n                                                     ident=field_0.ident,\n@@ -1210,9 +1208,9 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n \n                             for (ast.field field_0 in fields_0) {\n \n-                                for (ty.field ft in field_tys) {\n+                                for (ty.field ft in field_mts) {\n                                     if (_str.eq(field_0.ident, ft.ident)) {\n-                                        auto e_1 = demand_expr(fcx, ft.ty,\n+                                        auto e_1 = demand_expr(fcx, ft.mt.ty,\n                                                                field_0.expr);\n                                         fields_1 +=\n                                             vec(rec(mut=field_0.mut,\n@@ -1704,11 +1702,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto oper_1 = check_expr(fcx, oper);\n             auto oper_t = expr_ty(oper_1);\n             alt (unop) {\n-                case (ast.box) { oper_t = plain_ty(ty.ty_box(oper_t)); }\n+                case (ast.box) {\n+                    // TODO: mutable\n+                    oper_t = ty.plain_box_ty(oper_t);\n+                }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n-                        case (ty.ty_box(?inner_t)) {\n-                            oper_t = inner_t;\n+                        case (ty.ty_box(?inner)) {\n+                            oper_t = inner.ty;\n                         }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n@@ -1718,9 +1719,6 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n                 }\n-                case (ast._mutable) {\n-                    oper_t = @rec(mut=ast.mut with *oper_t);\n-                }\n                 case (_) { oper_t = strip_boxes(oper_t); }\n             }\n \n@@ -2107,12 +2105,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_cast(e_1, t, ann));\n         }\n \n-        case (ast.expr_vec(?args, _)) {\n+        case (ast.expr_vec(?args, ?mut, _)) {\n             let vec[@ast.expr] args_1 = vec();\n \n-            // FIXME: implement mutable vectors with leading 'mutable' flag\n-            // marking the elements as mutable.\n-\n             let @ty.t t;\n             if (_vec.len[@ast.expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n@@ -2127,26 +2122,25 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 demand(fcx, expr.span, t, expr_t);\n                 _vec.push[@ast.expr](args_1,expr_1);\n             }\n-            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)), none[vec[@ty.t]]);\n+\n+            auto vec_sty = ty.ty_vec(rec(ty=t, mut=mut));\n+            auto ann = ast.ann_type(plain_ty(vec_sty), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_vec(args_1, ann));\n+                                        ast.expr_vec(args_1, mut, ann));\n         }\n \n         case (ast.expr_tup(?elts, _)) {\n             let vec[ast.elt] elts_1 = vec();\n-            let vec[@ty.t] elts_t = vec();\n+            let vec[ty.mt] elts_mt = vec();\n \n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n                 auto expr_t = expr_ty(expr_1);\n-                if (e.mut == ast.mut) {\n-                    expr_t = @rec(mut=ast.mut with *expr_t);\n-                }\n                 _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n-                _vec.push[@ty.t](elts_t, expr_t);\n+                elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)),\n+            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_mt)),\n                                     none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n@@ -2168,11 +2162,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n                 auto expr_t = expr_ty(expr_1);\n-                if (f.mut == ast.mut) {\n-                    expr_t = @rec(mut=ast.mut with *expr_t);\n-                }\n                 _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n-                _vec.push[field](fields_t, rec(ident=f.ident, ty=expr_t));\n+\n+                auto expr_mt = rec(ty=expr_t, mut=f.mut);\n+                _vec.push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n             }\n \n             auto ann = ast.ann_none;\n@@ -2206,7 +2199,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         auto found = false;\n                         for (ty.field bf in base_fields) {\n                             if (_str.eq(f.ident, bf.ident)) {\n-                                demand(fcx, expr.span, f.ty, bf.ty);\n+                                demand(fcx, expr.span, f.mt.ty, bf.mt.ty);\n                                 found = true;\n                             }\n                         }\n@@ -2231,11 +2224,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n-                    if (ix >= _vec.len[@ty.t](args)) {\n+                    if (ix >= _vec.len[ty.mt](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix), none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(args.(ix).ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2249,7 +2242,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = ast.ann_type(fields.(ix).ty, none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(fields.(ix).mt.ty,\n+                                            none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2289,14 +2283,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto idx_t = expr_ty(idx_1);\n \n             alt (base_t.struct) {\n-                case (ty.ty_vec(?t)) {\n+                case (ty.ty_vec(?mt)) {\n                     if (! type_is_integral(idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(mt.ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,"}, {"sha": "f2e52d721781020bba7d63a3889a2b465d1414c8", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eca7129e3857e3506d12de7591238f8a7d55da1/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=5eca7129e3857e3506d12de7591238f8a7d55da1", "patch": "@@ -48,7 +48,7 @@ impure fn bclose(ps s) {\n   end(s);\n   pp.cwrd(s, \"}\");\n }\n-impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, IN) op) {\n+impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, &IN) op) {\n   auto first = true;\n   for (IN elt in elts) {\n     if (first) {first = false;}\n@@ -57,7 +57,14 @@ impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, IN) op) {\n   }\n }\n \n-impure fn print_type(ps s, @ast.ty ty) {\n+impure fn print_mt(ps s, &ast.mt mt) {\n+    if (mt.mut == ast.mut) {\n+        wrd1(s, \"mutable\");\n+    }\n+    print_type(s, mt.ty);\n+}\n+\n+impure fn print_type(ps s, &@ast.ty ty) {\n   hbox(s);\n   alt (ty.node) {\n     case (ast.ty_nil) {wrd(s, \"()\");}\n@@ -67,22 +74,22 @@ impure fn print_type(ps s, @ast.ty ty) {\n     case (ast.ty_machine(?tm)) {wrd(s, util.common.ty_mach_to_str(tm));}\n     case (ast.ty_char) {wrd(s, \"char\");}\n     case (ast.ty_str) {wrd(s, \"str\");}\n-    case (ast.ty_box(?t)) {wrd(s, \"@\"); print_type(s, t);}\n-    case (ast.ty_vec(?t)) {wrd(s, \"vec[\"); print_type(s, t); wrd(s, \"]\");}\n+    case (ast.ty_box(?mt)) {wrd(s, \"@\"); print_mt(s, mt);}\n+    case (ast.ty_vec(?mt)) {wrd(s, \"vec[\"); print_mt(s, mt); wrd(s, \"]\");}\n     case (ast.ty_type) {wrd(s, \"type\");}\n     case (ast.ty_tup(?elts)) {\n       wrd(s, \"tup\");\n       popen(s);\n-      auto f = print_type;\n-      commasep[@ast.ty](s, elts, f);\n+      auto f = print_mt;\n+      commasep[ast.mt](s, elts, f);\n       pclose(s);\n     }\n     case (ast.ty_rec(?fields)) {\n       wrd(s, \"rec\");\n       popen(s);\n-      impure fn print_field(ps s, ast.ty_field f) {\n+      impure fn print_field(ps s, &ast.ty_field f) {\n         hbox(s);\n-        print_type(s, f.ty);\n+        print_mt(s, f.mt);\n         space(s);\n         wrd(s, f.ident);\n         end(s);\n@@ -110,10 +117,6 @@ impure fn print_type(ps s, @ast.ty ty) {\n     case (ast.ty_path(?path,_)) {\n       print_path(s, path);\n     }\n-    case (ast.ty_mutable(?t)) {\n-      wrd1(s, \"mutable\");\n-      print_type(s, t);\n-    }\n   }\n   end(s);\n }\n@@ -186,7 +189,7 @@ impure fn print_item(ps s, @ast.item item) {\n         wrd(s, v.name);\n         if (_vec.len[ast.variant_arg](v.args) > 0u) {\n           popen(s);\n-          impure fn print_variant_arg(ps s, ast.variant_arg arg) {\n+          impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n             print_type(s, arg.ty);\n           }\n           auto f = print_variant_arg;\n@@ -203,7 +206,7 @@ impure fn print_item(ps s, @ast.item item) {\n       wrd(s, id);\n       print_type_params(s, params);\n       popen(s);\n-      impure fn print_field(ps s, ast.obj_field field) {\n+      impure fn print_field(ps s, &ast.obj_field field) {\n         hbox(s);\n         print_type(s, field.ty);\n         space(s);\n@@ -285,18 +288,21 @@ impure fn print_literal(ps s, @ast.lit lit) {\n   }\n }\n \n-impure fn print_expr(ps s, @ast.expr expr) {\n+impure fn print_expr(ps s, &@ast.expr expr) {\n   auto pe = print_expr;\n   hbox(s);\n   alt (expr.node) {\n-    case (ast.expr_vec(?exprs,_)) {\n+    case (ast.expr_vec(?exprs,?mut,_)) {\n+      if (mut == ast.mut) {\n+        wrd1(s, \"mutable\");\n+      }\n       wrd(s, \"vec\");\n       popen(s);\n       commasep[@ast.expr](s, exprs, pe);\n       pclose(s);\n     }\n     case (ast.expr_tup(?exprs,_)) {\n-      impure fn printElt(ps s, ast.elt elt) {\n+      impure fn printElt(ps s, &ast.elt elt) {\n         hbox(s);\n         if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n         print_expr(s, elt.expr);\n@@ -309,7 +315,7 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       pclose(s);\n     }\n     case (ast.expr_rec(?fields,?wth,_)) {\n-      impure fn print_field(ps s, ast.field field) {\n+      impure fn print_field(ps s, &ast.field field) {\n         hbox(s);\n         if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n         wrd(s, field.ident);\n@@ -340,7 +346,7 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       pclose(s);\n     }\n     case (ast.expr_bind(?func,?args,_)) {\n-      impure fn print_opt(ps s, option.t[@ast.expr] expr) {\n+      impure fn print_opt(ps s, &option.t[@ast.expr] expr) {\n         alt (expr) {\n           case (option.some[@ast.expr](?expr)) {\n             print_expr(s, expr);\n@@ -364,7 +370,6 @@ impure fn print_expr(ps s, @ast.expr expr) {\n     }\n     case (ast.expr_unary(?op,?expr,_)) {\n       wrd(s, ast.unop_to_str(op));\n-      if (op == ast._mutable) {space(s);}\n       print_expr(s, expr);\n     }\n     case (ast.expr_lit(?lit,_)) {\n@@ -577,7 +582,7 @@ impure fn print_path(ps s, ast.path path) {\n   }\n }\n \n-impure fn print_pat(ps s, @ast.pat pat) {\n+impure fn print_pat(ps s, &@ast.pat pat) {\n   alt (pat.node) {\n     case (ast.pat_wild(_)) {wrd(s, \"_\");}\n     case (ast.pat_bind(?id,_,_)) {wrd(s, \"?\" + id);}\n@@ -605,7 +610,7 @@ impure fn print_fn(ps s, ast.fn_decl decl, str name,\n   wrd(s, name);\n   print_type_params(s, typarams);\n   popen(s);\n-  impure fn print_arg(ps s, ast.arg x) {\n+  impure fn print_arg(ps s, &ast.arg x) {\n     hbox(s);\n     print_type(s, x.ty);\n     space(s);\n@@ -627,7 +632,7 @@ impure fn print_fn(ps s, ast.fn_decl decl, str name,\n impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n   if (_vec.len[ast.ty_param](params) > 0u) {\n     wrd(s, \"[\");\n-    impure fn printParam(ps s, ast.ty_param param) {wrd(s, param.ident);}\n+    impure fn printParam(ps s, &ast.ty_param param) {wrd(s, param.ident);}\n     auto f = printParam;\n     commasep[ast.ty_param](s, params, f);\n     wrd(s, \"]\");\n@@ -642,7 +647,7 @@ impure fn print_view_item(ps s, @ast.view_item item) {\n       wrd(s, id);\n       if (_vec.len[@ast.meta_item](mta) > 0u) {\n         popen(s);\n-        impure fn print_meta(ps s, @ast.meta_item item) {\n+        impure fn print_meta(ps s, &@ast.meta_item item) {\n           hbox(s);\n           wrd1(s, item.node.name);\n           wrd1(s, \"=\");\n@@ -738,7 +743,7 @@ impure fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n     case (_) {}\n   }\n   popen(s);\n-  impure fn print_arg(ps s, ast.ty_arg input) {\n+  impure fn print_arg(ps s, &ast.ty_arg input) {\n     if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n     print_type(s, input.ty);\n   }"}]}