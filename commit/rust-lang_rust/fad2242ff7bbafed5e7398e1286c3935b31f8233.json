{"sha": "fad2242ff7bbafed5e7398e1286c3935b31f8233", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhZDIyNDJmZjdiYmFmZWQ1ZTczOThlMTI4NmMzOTM1YjMxZjgyMzM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-05-13T13:30:14Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-06-06T17:37:42Z"}, "message": "Add variance-related information to lifetime error messages", "tree": {"sha": "8130278ea5c71d6985ede8c4e008fc86d6af2e45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8130278ea5c71d6985ede8c4e008fc86d6af2e45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fad2242ff7bbafed5e7398e1286c3935b31f8233", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmC9B/AACgkQtAh+UQ6Y\nsWTScQ//WdOLBMj1WEEnno4BqH7WPFzElePmzSpJVrs/i25FAqlorzI8728a17fv\nx6tDqKMQEv3hB0akW5ATUcEsr7TZ4uzSJkaFXrxx3ceK1R6VRw+WVibQHW9ly2tm\n834Ybj03xz9uIZ+V6068hqx+7oIVJGb93ElZKZle5SHRbwihtFBpxOUl8ALxyF+s\n0c5sgY3KAfW3fV66WYhmMLUj8DnDCGYsg1ZgSYwslEEkPLp3c4Ygd+yC2TwNVHDm\nJhNY5LiviZx0iV9aIX9ZbFjEf4oo4BmMbENZP3DO1ivAhy+Y4Hw/XLsHwaNeefCc\nh7mZkPRclkjH4Tg7MGIErAbQV8Ci7bJw4WNYifC8jWwXmUOGp40ffpwv+PHw3SPA\nU41JtxrV/RWw6nmBeh/u8Mxgc9plwxFWvjfkBkFMe4qpuev3FptB1fr/fPVg4mm2\nB/vMXlURlgnyDPEfC5TlwktQ8ExiezZFbsUi1ZzB1PRUH+Q4dzWzMrEuHWL3uB81\nAi3GfNP05rYIodPbxLB0BjK8Dm83c8De6HMZyQ31Ipbz61TMnujeznAUFt3qtT1w\n161ojVuLK0nKYByLRZAf4/sjHSu/j7/9Lzozt9CCGdGiI5A7fE2JdTlVBP6f2BoF\n3eiU34S+N3ooAcEr+oVQzMK4HE3KpRY5QQREQ3niMH49CMw42T4=\n=/1VL\n-----END PGP SIGNATURE-----", "payload": "tree 8130278ea5c71d6985ede8c4e008fc86d6af2e45\nparent 86b0bafbf1e0fab3aa433c10256919d1b6ba46ac\nauthor Aaron Hill <aa1ronham@gmail.com> 1620912614 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1623001062 -0500\n\nAdd variance-related information to lifetime error messages\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fad2242ff7bbafed5e7398e1286c3935b31f8233", "html_url": "https://github.com/rust-lang/rust/commit/fad2242ff7bbafed5e7398e1286c3935b31f8233", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fad2242ff7bbafed5e7398e1286c3935b31f8233/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b0bafbf1e0fab3aa433c10256919d1b6ba46ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b0bafbf1e0fab3aa433c10256919d1b6ba46ac", "html_url": "https://github.com/rust-lang/rust/commit/86b0bafbf1e0fab3aa433c10256919d1b6ba46ac"}], "stats": {"total": 541, "additions": 397, "deletions": 144}, "files": [{"sha": "c3c28d70081512550f398aacac7337d78888947d", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -660,7 +660,12 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         )\n     }\n \n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,"}, {"sha": "3a11b5a214490088d71ef7f4ff7cb8518b9c4d7b", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -371,9 +371,12 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         match dir {\n             EqTo => self.equate(a_is_expected).relate(a_ty, b_ty),\n             SubtypeOf => self.sub(a_is_expected).relate(a_ty, b_ty),\n-            SupertypeOf => {\n-                self.sub(a_is_expected).relate_with_variance(ty::Contravariant, a_ty, b_ty)\n-            }\n+            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                ty::Contravariant,\n+                ty::VarianceDiagInfo::default(),\n+                a_ty,\n+                b_ty,\n+            ),\n         }?;\n \n         Ok(())\n@@ -574,6 +577,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -737,7 +741,12 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 if self.tcx().lazy_normalization() =>\n             {\n                 assert_eq!(promoted, None);\n-                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n@@ -831,6 +840,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -965,7 +975,12 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                 if self.tcx().lazy_normalization() =>\n             {\n                 assert_eq!(promoted, None);\n-                let substs = self.relate_with_variance(ty::Variance::Invariant, substs, substs)?;\n+                let substs = self.relate_with_variance(\n+                    ty::Variance::Invariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    substs,\n+                    substs,\n+                )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n                     val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),"}, {"sha": "0c93271a1aeca716844af99337c8f8e7e9fd8bb7", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -59,6 +59,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "60f02b84aa344225f73a762884c33e783d628a03", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -43,6 +43,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -96,7 +97,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        self.relate_with_variance(ty::Variance::Invariant, ty::VarianceDiagInfo::default(), a, b)?;\n         Ok(a)\n     }\n }"}, {"sha": "a08323535c55abd6d926abb15df0246800b8d66a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -43,6 +43,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n@@ -96,7 +97,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         // When higher-ranked types are involved, computing the LUB is\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n-        self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n+        self.relate_with_variance(ty::Variance::Invariant, ty::VarianceDiagInfo::default(), a, b)?;\n         Ok(a)\n     }\n }"}, {"sha": "20be06adfd09e1a37c64991476ee00f4d85cedca", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -55,6 +55,8 @@ where\n     /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n \n+    ambient_variance_info: ty::VarianceDiagInfo<'tcx>,\n+\n     /// When we pass through a set of binders (e.g., when looking into\n     /// a `fn` type), we push a new bound region scope onto here. This\n     /// will contain the instantiated region for each region in those\n@@ -78,7 +80,12 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// satisfied for the two types to be related. `sub` and `sup` may\n     /// be regions from the type or new variables created through the\n     /// delegate.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>);\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    );\n \n     fn const_equate(&mut self, a: &'tcx ty::Const<'tcx>, b: &'tcx ty::Const<'tcx>);\n \n@@ -138,7 +145,14 @@ where\n         delegate: D,\n         ambient_variance: ty::Variance,\n     ) -> Self {\n-        Self { infcx, delegate, ambient_variance, a_scopes: vec![], b_scopes: vec![] }\n+        Self {\n+            infcx,\n+            delegate,\n+            ambient_variance,\n+            ambient_variance_info: ty::VarianceDiagInfo::default(),\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n     }\n \n     fn ambient_covariance(&self) -> bool {\n@@ -239,10 +253,15 @@ where\n \n     /// Push a new outlives requirement into our output set of\n     /// constraints.\n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n-        self.delegate.push_outlives(sup, sub);\n+        self.delegate.push_outlives(sup, sub, info);\n     }\n \n     /// Relate a projection type and some value type lazily. This will always\n@@ -490,13 +509,15 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {\n         debug!(\"relate_with_variance(variance={:?}, a={:?}, b={:?})\", variance, a, b);\n \n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.ambient_variance.xform(variance);\n+        self.ambient_variance_info = self.ambient_variance_info.clone().xform(info);\n \n         debug!(\"relate_with_variance: ambient_variance = {:?}\", self.ambient_variance);\n \n@@ -574,12 +595,12 @@ where\n \n         if self.ambient_covariance() {\n             // Covariance: a <= b. Hence, `b: a`.\n-            self.push_outlives(v_b, v_a);\n+            self.push_outlives(v_b, v_a, self.ambient_variance_info.clone());\n         }\n \n         if self.ambient_contravariance() {\n             // Contravariant: b <= a. Hence, `a: b`.\n-            self.push_outlives(v_a, v_b);\n+            self.push_outlives(v_a, v_b, self.ambient_variance_info.clone());\n         }\n \n         Ok(a)\n@@ -835,6 +856,7 @@ where\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "b3131936ae06608210a7bedab490e1bf38859c58", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -62,6 +62,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "02ff1b9f4d655ff15fc191617eccd1439e7dfd29", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -46,6 +46,7 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "b58c92b8415175c748752757eed4cff4ef04fb75", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -71,7 +71,7 @@ pub use self::sty::{\n     ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n     GeneratorSubsts, GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n     PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n-    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts, VarianceDiagInfo, VarianceDiagMutKind,\n };\n pub use self::trait_def::TraitDef;\n "}, {"sha": "872d12cac9384ab086d829be8e856facb9c1c643", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 57, "deletions": 28, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -67,6 +67,7 @@ pub trait TypeRelation<'tcx>: Sized {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n+        info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T>;\n@@ -111,24 +112,23 @@ pub trait Relate<'tcx>: TypeFoldable<'tcx> + Copy {\n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n-impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<R: TypeRelation<'tcx>>(\n-        relation: &mut R,\n-        a: ty::TypeAndMut<'tcx>,\n-        b: ty::TypeAndMut<'tcx>,\n-    ) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n-        debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n-        if a.mutbl != b.mutbl {\n-            Err(TypeError::Mutability)\n-        } else {\n-            let mutbl = a.mutbl;\n-            let variance = match mutbl {\n-                ast::Mutability::Not => ty::Covariant,\n-                ast::Mutability::Mut => ty::Invariant,\n-            };\n-            let ty = relation.relate_with_variance(variance, a.ty, b.ty)?;\n-            Ok(ty::TypeAndMut { ty, mutbl })\n-        }\n+fn relate_type_and_mut<'tcx, R: TypeRelation<'tcx>>(\n+    relation: &mut R,\n+    a: ty::TypeAndMut<'tcx>,\n+    b: ty::TypeAndMut<'tcx>,\n+    kind: ty::VarianceDiagMutKind,\n+) -> RelateResult<'tcx, ty::TypeAndMut<'tcx>> {\n+    debug!(\"{}.mts({:?}, {:?})\", relation.tag(), a, b);\n+    if a.mutbl != b.mutbl {\n+        Err(TypeError::Mutability)\n+    } else {\n+        let mutbl = a.mutbl;\n+        let (variance, info) = match mutbl {\n+            ast::Mutability::Not => (ty::Covariant, ty::VarianceDiagInfo::None),\n+            ast::Mutability::Mut => (ty::Invariant, ty::VarianceDiagInfo::Mut { kind, ty: a.ty }),\n+        };\n+        let ty = relation.relate_with_variance(variance, info, a.ty, b.ty)?;\n+        Ok(ty::TypeAndMut { ty, mutbl })\n     }\n }\n \n@@ -142,7 +142,7 @@ pub fn relate_substs<R: TypeRelation<'tcx>>(\n \n     let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-        relation.relate_with_variance(variance, a, b)\n+        relation.relate_with_variance(variance, ty::VarianceDiagInfo::default(), a, b)\n     });\n \n     tcx.mk_substs(params)\n@@ -177,7 +177,12 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 if is_output {\n                     relation.relate(a, b)\n                 } else {\n-                    relation.relate_with_variance(ty::Contravariant, a, b)\n+                    relation.relate_with_variance(\n+                        ty::Contravariant,\n+                        ty::VarianceDiagInfo::default(),\n+                        a,\n+                        b,\n+                    )\n                 }\n             })\n             .enumerate()\n@@ -251,8 +256,18 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialProjection<'tcx> {\n                 b.item_def_id,\n             )))\n         } else {\n-            let ty = relation.relate_with_variance(ty::Invariant, a.ty, b.ty)?;\n-            let substs = relation.relate_with_variance(ty::Invariant, a.substs, b.substs)?;\n+            let ty = relation.relate_with_variance(\n+                ty::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                a.ty,\n+                b.ty,\n+            )?;\n+            let substs = relation.relate_with_variance(\n+                ty::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                a.substs,\n+                b.substs,\n+            )?;\n             Ok(ty::ExistentialProjection { item_def_id: a.item_def_id, substs, ty })\n         }\n     }\n@@ -364,7 +379,12 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n \n         (&ty::Dynamic(a_obj, a_region), &ty::Dynamic(b_obj, b_region)) => {\n             let region_bound = relation.with_cause(Cause::ExistentialRegionBound, |relation| {\n-                relation.relate_with_variance(ty::Contravariant, a_region, b_region)\n+                relation.relate_with_variance(\n+                    ty::Contravariant,\n+                    ty::VarianceDiagInfo::default(),\n+                    a_region,\n+                    b_region,\n+                )\n             })?;\n             Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n@@ -398,15 +418,20 @@ pub fn super_relate_tys<R: TypeRelation<'tcx>>(\n         }\n \n         (&ty::RawPtr(a_mt), &ty::RawPtr(b_mt)) => {\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let mt = relate_type_and_mut(relation, a_mt, b_mt, ty::VarianceDiagMutKind::RawPtr)?;\n             Ok(tcx.mk_ptr(mt))\n         }\n \n         (&ty::Ref(a_r, a_ty, a_mutbl), &ty::Ref(b_r, b_ty, b_mutbl)) => {\n-            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n+            let r = relation.relate_with_variance(\n+                ty::Contravariant,\n+                ty::VarianceDiagInfo::default(),\n+                a_r,\n+                b_r,\n+            )?;\n             let a_mt = ty::TypeAndMut { ty: a_ty, mutbl: a_mutbl };\n             let b_mt = ty::TypeAndMut { ty: b_ty, mutbl: b_mutbl };\n-            let mt = relation.relate(a_mt, b_mt)?;\n+            let mt = relate_type_and_mut(relation, a_mt, b_mt, ty::VarianceDiagMutKind::Ref)?;\n             Ok(tcx.mk_ref(r, mt))\n         }\n \n@@ -536,8 +561,12 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if au.def == bu.def && au.promoted == bu.promoted =>\n         {\n-            let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, au.substs, bu.substs)?;\n+            let substs = relation.relate_with_variance(\n+                ty::Variance::Invariant,\n+                ty::VarianceDiagInfo::default(),\n+                au.substs,\n+                bu.substs,\n+            )?;\n             return Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                     def: au.def,"}, {"sha": "1d9ff512288db9b05e140f6f4d224fa35b60f36a", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -2181,3 +2181,55 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n }\n+\n+/// Extra information about why we ended up with a particular variance.\n+/// This is only used to add more information to error messages, and\n+/// has no effect on soundness. While choosing the 'wrong' `VarianceDiagInfo`\n+/// may lead to confusing notes in error messages, it will never cause\n+/// a miscompilation or unsoundness.\n+///\n+/// When in doubt, use `VarianceDiagInfo::default()`\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum VarianceDiagInfo<'tcx> {\n+    /// No additional information - this is the default.\n+    /// We will not add any additional information to error messages.\n+    None,\n+    /// We switched our variance because a type occurs inside\n+    /// the generic argument of a mutable reference or pointer\n+    /// (`*mut T` or `&mut T`). In either case, our variance\n+    /// will always be `Invariant`.\n+    Mut {\n+        /// Tracks whether we had a mutable pointer or reference,\n+        /// for better error messages\n+        kind: VarianceDiagMutKind,\n+        /// The type parameter of the mutable pointer/reference\n+        /// (the `T` in `&mut T` or `*mut T`).\n+        ty: Ty<'tcx>,\n+    },\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum VarianceDiagMutKind {\n+    /// A mutable raw pointer (`*mut T`)\n+    RawPtr,\n+    /// A mutable reference (`&mut T`)\n+    Ref,\n+}\n+\n+impl<'tcx> VarianceDiagInfo<'tcx> {\n+    /// Mirrors `Variance::xform` - used to 'combine' the existing\n+    /// and new `VarianceDiagInfo`s when our variance changes.\n+    pub fn xform(self, other: VarianceDiagInfo<'tcx>) -> VarianceDiagInfo<'tcx> {\n+        // For now, just use the first `VarianceDiagInfo::Mut` that we see\n+        match self {\n+            VarianceDiagInfo::None => other,\n+            VarianceDiagInfo::Mut { .. } => self,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Default for VarianceDiagInfo<'tcx> {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}"}, {"sha": "9e4cfb2cc00fa0f541e51649c229d0c0f18da8fb", "filename": "compiler/rustc_mir/src/borrow_check/constraints/graph.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fgraph.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use rustc_span::DUMMY_SP;\n \n use crate::borrow_check::{\n@@ -26,8 +26,8 @@ crate type ReverseConstraintGraph = ConstraintGraph<Reverse>;\n /// Marker trait that controls whether a `R1: R2` constraint\n /// represents an edge `R1 -> R2` or `R2 -> R1`.\n crate trait ConstraintGraphDirecton: Copy + 'static {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid;\n-    fn end_region(c: &OutlivesConstraint) -> RegionVid;\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid;\n     fn is_normal() -> bool;\n }\n \n@@ -39,11 +39,11 @@ crate trait ConstraintGraphDirecton: Copy + 'static {\n crate struct Normal;\n \n impl ConstraintGraphDirecton for Normal {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sup\n     }\n \n-    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sub\n     }\n \n@@ -60,11 +60,11 @@ impl ConstraintGraphDirecton for Normal {\n crate struct Reverse;\n \n impl ConstraintGraphDirecton for Reverse {\n-    fn start_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn start_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sub\n     }\n \n-    fn end_region(c: &OutlivesConstraint) -> RegionVid {\n+    fn end_region(c: &OutlivesConstraint<'_>) -> RegionVid {\n         c.sup\n     }\n \n@@ -78,7 +78,7 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n-    crate fn new(direction: D, set: &OutlivesConstraintSet, num_region_vars: usize) -> Self {\n+    crate fn new(direction: D, set: &OutlivesConstraintSet<'_>, num_region_vars: usize) -> Self {\n         let mut first_constraints = IndexVec::from_elem_n(None, num_region_vars);\n         let mut next_constraints = IndexVec::from_elem(None, &set.outlives);\n \n@@ -96,21 +96,21 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     /// Given the constraint set from which this graph was built\n     /// creates a region graph so that you can iterate over *regions*\n     /// and not constraints.\n-    crate fn region_graph<'rg>(\n+    crate fn region_graph<'rg, 'tcx>(\n         &'rg self,\n-        set: &'rg OutlivesConstraintSet,\n+        set: &'rg OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n-    ) -> RegionGraph<'rg, D> {\n+    ) -> RegionGraph<'rg, 'tcx, D> {\n         RegionGraph::new(set, self, static_region)\n     }\n \n     /// Given a region `R`, iterate over all constraints `R: R1`.\n-    crate fn outgoing_edges<'a>(\n+    crate fn outgoing_edges<'a, 'tcx>(\n         &'a self,\n         region_sup: RegionVid,\n-        constraints: &'a OutlivesConstraintSet,\n+        constraints: &'a OutlivesConstraintSet<'tcx>,\n         static_region: RegionVid,\n-    ) -> Edges<'a, D> {\n+    ) -> Edges<'a, 'tcx, D> {\n         //if this is the `'static` region and the graph's direction is normal,\n         //then setup the Edges iterator to return all regions #53178\n         if region_sup == static_region && D::is_normal() {\n@@ -129,22 +129,22 @@ impl<D: ConstraintGraphDirecton> ConstraintGraph<D> {\n     }\n }\n \n-crate struct Edges<'s, D: ConstraintGraphDirecton> {\n+crate struct Edges<'s, 'tcx, D: ConstraintGraphDirecton> {\n     graph: &'s ConstraintGraph<D>,\n-    constraints: &'s OutlivesConstraintSet,\n+    constraints: &'s OutlivesConstraintSet<'tcx>,\n     pointer: Option<OutlivesConstraintIndex>,\n     next_static_idx: Option<usize>,\n     static_region: RegionVid,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n-    type Item = OutlivesConstraint;\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Edges<'s, 'tcx, D> {\n+    type Item = OutlivesConstraint<'tcx>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(p) = self.pointer {\n             self.pointer = self.graph.next_constraints[p];\n \n-            Some(self.constraints[p])\n+            Some(self.constraints[p].clone())\n         } else if let Some(next_static_idx) = self.next_static_idx {\n             self.next_static_idx = if next_static_idx == (self.graph.first_constraints.len() - 1) {\n                 None\n@@ -157,6 +157,7 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n                 sub: next_static_idx.into(),\n                 locations: Locations::All(DUMMY_SP),\n                 category: ConstraintCategory::Internal,\n+                variance_info: VarianceDiagInfo::default(),\n             })\n         } else {\n             None\n@@ -167,19 +168,19 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n /// This struct brings together a constraint set and a (normal, not\n /// reverse) constraint graph. It implements the graph traits and is\n /// usd for doing the SCC computation.\n-crate struct RegionGraph<'s, D: ConstraintGraphDirecton> {\n-    set: &'s OutlivesConstraintSet,\n+crate struct RegionGraph<'s, 'tcx, D: ConstraintGraphDirecton> {\n+    set: &'s OutlivesConstraintSet<'tcx>,\n     constraint_graph: &'s ConstraintGraph<D>,\n     static_region: RegionVid,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> RegionGraph<'s, 'tcx, D> {\n     /// Creates a \"dependency graph\" where each region constraint `R1:\n     /// R2` is treated as an edge `R1 -> R2`. We use this graph to\n     /// construct SCCs for region inference but also for error\n     /// reporting.\n     crate fn new(\n-        set: &'s OutlivesConstraintSet,\n+        set: &'s OutlivesConstraintSet<'tcx>,\n         constraint_graph: &'s ConstraintGraph<D>,\n         static_region: RegionVid,\n     ) -> Self {\n@@ -188,42 +189,45 @@ impl<'s, D: ConstraintGraphDirecton> RegionGraph<'s, D> {\n \n     /// Given a region `R`, iterate over all regions `R1` such that\n     /// there exists a constraint `R: R1`.\n-    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, D> {\n+    crate fn outgoing_regions(&self, region_sup: RegionVid) -> Successors<'_, 'tcx, D> {\n         Successors {\n             edges: self.constraint_graph.outgoing_edges(region_sup, self.set, self.static_region),\n         }\n     }\n }\n \n-crate struct Successors<'s, D: ConstraintGraphDirecton> {\n-    edges: Edges<'s, D>,\n+crate struct Successors<'s, 'tcx, D: ConstraintGraphDirecton> {\n+    edges: Edges<'s, 'tcx, D>,\n }\n \n-impl<'s, D: ConstraintGraphDirecton> Iterator for Successors<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> Iterator for Successors<'s, 'tcx, D> {\n     type Item = RegionVid;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         self.edges.next().map(|c| D::end_region(&c))\n     }\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::DirectedGraph for RegionGraph<'s, 'tcx, D> {\n     type Node = RegionVid;\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithNumNodes for RegionGraph<'s, 'tcx, D> {\n     fn num_nodes(&self) -> usize {\n         self.constraint_graph.first_constraints.len()\n     }\n }\n \n-impl<'s, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, D> {\n+impl<'s, 'tcx, D: ConstraintGraphDirecton> graph::WithSuccessors for RegionGraph<'s, 'tcx, D> {\n     fn successors(&self, node: Self::Node) -> <Self as graph::GraphSuccessors<'_>>::Iter {\n         self.outgoing_regions(node)\n     }\n }\n \n-impl<'s, 'graph, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph> for RegionGraph<'s, D> {\n+impl<'s, 'graph, 'tcx, D: ConstraintGraphDirecton> graph::GraphSuccessors<'graph>\n+    for RegionGraph<'s, 'tcx, D>\n+{\n     type Item = RegionVid;\n-    type Iter = Successors<'graph, D>;\n+    // FIXME - why can't this be `'graph, 'tcx`\n+    type Iter = Successors<'graph, 'graph, D>;\n }"}, {"sha": "b944479ca456b387fe7dd23c44e1be17a2840308", "filename": "compiler/rustc_mir/src/borrow_check/constraints/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fconstraints%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use std::fmt;\n use std::ops::Index;\n \n@@ -14,12 +14,12 @@ crate mod graph;\n /// a unique `OutlivesConstraintIndex` and you can index into the set\n /// (`constraint_set[i]`) to access the constraint details.\n #[derive(Clone, Default)]\n-crate struct OutlivesConstraintSet {\n-    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint>,\n+crate struct OutlivesConstraintSet<'tcx> {\n+    outlives: IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>>,\n }\n \n-impl OutlivesConstraintSet {\n-    crate fn push(&mut self, constraint: OutlivesConstraint) {\n+impl<'tcx> OutlivesConstraintSet<'tcx> {\n+    crate fn push(&mut self, constraint: OutlivesConstraint<'tcx>) {\n         debug!(\n             \"OutlivesConstraintSet::push({:?}: {:?} @ {:?}\",\n             constraint.sup, constraint.sub, constraint.locations\n@@ -59,21 +59,21 @@ impl OutlivesConstraintSet {\n         Sccs::new(region_graph)\n     }\n \n-    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint> {\n+    crate fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n         &self.outlives\n     }\n }\n \n-impl Index<OutlivesConstraintIndex> for OutlivesConstraintSet {\n-    type Output = OutlivesConstraint;\n+impl<'tcx> Index<OutlivesConstraintIndex> for OutlivesConstraintSet<'tcx> {\n+    type Output = OutlivesConstraint<'tcx>;\n \n     fn index(&self, i: OutlivesConstraintIndex) -> &Self::Output {\n         &self.outlives[i]\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct OutlivesConstraint {\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct OutlivesConstraint<'tcx> {\n     // NB. The ordering here is not significant for correctness, but\n     // it is for convenience. Before we dump the constraints in the\n     // debugging logs, we sort them, and we'd like the \"super region\"\n@@ -89,11 +89,18 @@ pub struct OutlivesConstraint {\n \n     /// What caused this constraint?\n     pub category: ConstraintCategory,\n+\n+    /// Variance diagnostic information\n+    pub variance_info: VarianceDiagInfo<'tcx>,\n }\n \n-impl fmt::Debug for OutlivesConstraint {\n+impl<'tcx> fmt::Debug for OutlivesConstraint<'tcx> {\n     fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(formatter, \"({:?}: {:?}) due to {:?}\", self.sup, self.sub, self.locations)\n+        write!(\n+            formatter,\n+            \"({:?}: {:?}) due to {:?} ({:?})\",\n+            self.sup, self.sub, self.locations, self.variance_info\n+        )\n     }\n }\n "}, {"sha": "e9f1ecb9bbc81dec0af6123ecb6402f742d69c55", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{self, RegionVid, TyCtxt};\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n \n+use crate::borrow_check::region_infer::BlameConstraint;\n use crate::borrow_check::{\n     borrow_set::BorrowData, nll::ConstraintDescription, region_infer::Cause, MirBorrowckCtxt,\n     WriteKind,\n@@ -289,12 +290,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n-            &self.body,\n-            borrow_region,\n-            NllRegionVariableOrigin::FreeRegion,\n-            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n+        let BlameConstraint { category, from_closure, span, variance_info: _ } =\n+            self.regioncx.best_blame_constraint(\n+                &self.body,\n+                borrow_region,\n+                NllRegionVariableOrigin::FreeRegion,\n+                |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+            );\n \n         let outlived_fr_name = self.give_region_a_name(outlived_region);\n "}, {"sha": "feb7672f650ecdd1338e55b04693bd211db9d2b8", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -13,6 +13,7 @@ use rustc_span::Span;\n \n use crate::util::borrowck_errors;\n \n+use crate::borrow_check::region_infer::BlameConstraint;\n use crate::borrow_check::{\n     nll::ConstraintDescription,\n     region_infer::{values::RegionElement, TypeTest},\n@@ -275,12 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) =\n+        let BlameConstraint { category, span, variance_info, from_closure: _ } =\n             self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n                 self.regioncx.provides_universal_region(r, fr, outlived_fr)\n             });\n \n-        debug!(\"report_region_error: category={:?} {:?}\", category, span);\n+        debug!(\"report_region_error: category={:?} {:?} {:?}\", category, span, variance_info);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let nice = NiceRegionError::new_from_span(self.infcx, span, o, f);\n@@ -309,7 +310,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             span,\n         };\n \n-        let diag = match (category, fr_is_local, outlived_fr_is_local) {\n+        let mut diag = match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return(kind), true, false) if self.is_closure_fn_mut(fr) => {\n                 self.report_fnmut_error(&errci, kind)\n             }\n@@ -332,6 +333,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n         };\n \n+        match variance_info {\n+            ty::VarianceDiagInfo::None => {}\n+            ty::VarianceDiagInfo::Mut { kind, ty } => {\n+                let kind_name = match kind {\n+                    ty::VarianceDiagMutKind::Ref => \"reference\",\n+                    ty::VarianceDiagMutKind::RawPtr => \"pointer\",\n+                };\n+                diag.note(&format!(\"requirement occurs because of a mutable {kind_name} to {ty}\",));\n+                diag.note(&format!(\"mutable {kind_name}s are invariant over their type parameter\"));\n+                diag.help(\"see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\");\n+            }\n+        }\n+\n         diag.buffer(&mut self.errors_buffer);\n     }\n "}, {"sha": "213ebff12abc0b65940e94f9845232c3c83cfa95", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n-            let OutlivesConstraint { sup, sub, locations, category } = constraint;\n+            let OutlivesConstraint { sup, sub, locations, category, variance_info: _ } = constraint;\n             let (name, arg) = match locations {\n                 Locations::All(span) => {\n                     (\"All\", tcx.sess.source_map().span_to_embeddable_string(*span))"}, {"sha": "b944d74e6f23137b3040974955e291d9ce70e26d", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/graphviz.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fgraphviz.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -35,7 +35,7 @@ struct RawConstraints<'a, 'tcx> {\n \n impl<'a, 'this, 'tcx> dot::Labeller<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n-    type Edge = OutlivesConstraint;\n+    type Edge = OutlivesConstraint<'tcx>;\n \n     fn graph_id(&'this self) -> dot::Id<'this> {\n         dot::Id::new(\"RegionInferenceContext\").unwrap()\n@@ -49,31 +49,31 @@ impl<'a, 'this, 'tcx> dot::Labeller<'this> for RawConstraints<'a, 'tcx> {\n     fn node_label(&'this self, n: &RegionVid) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", n).into())\n     }\n-    fn edge_label(&'this self, e: &OutlivesConstraint) -> dot::LabelText<'this> {\n+    fn edge_label(&'this self, e: &OutlivesConstraint<'tcx>) -> dot::LabelText<'this> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", e.locations).into())\n     }\n }\n \n impl<'a, 'this, 'tcx> dot::GraphWalk<'this> for RawConstraints<'a, 'tcx> {\n     type Node = RegionVid;\n-    type Edge = OutlivesConstraint;\n+    type Edge = OutlivesConstraint<'tcx>;\n \n     fn nodes(&'this self) -> dot::Nodes<'this, RegionVid> {\n         let vids: Vec<RegionVid> = self.regioncx.definitions.indices().collect();\n         vids.into()\n     }\n-    fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n+    fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint<'tcx>> {\n         (&self.regioncx.constraints.outlives().raw[..]).into()\n     }\n \n     // Render `a: b` as `a -> b`, indicating the flow\n     // of data during inference.\n \n-    fn source(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n+    fn source(&'this self, edge: &OutlivesConstraint<'tcx>) -> RegionVid {\n         edge.sup\n     }\n \n-    fn target(&'this self, edge: &OutlivesConstraint) -> RegionVid {\n+    fn target(&'this self, edge: &OutlivesConstraint<'tcx>) -> RegionVid {\n         edge.sub\n     }\n }"}, {"sha": "dded7a7e3cf99e47166e2997d7c364369866490e", "filename": "compiler/rustc_mir/src/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -54,7 +54,7 @@ pub struct RegionInferenceContext<'tcx> {\n     liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    constraints: Frozen<OutlivesConstraintSet>,\n+    constraints: Frozen<OutlivesConstraintSet<'tcx>>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n@@ -227,10 +227,10 @@ enum RegionRelationCheckResult {\n     Error,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Trace {\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+enum Trace<'tcx> {\n     StartRegion,\n-    FromOutlivesConstraint(OutlivesConstraint),\n+    FromOutlivesConstraint(OutlivesConstraint<'tcx>),\n     NotVisited,\n }\n \n@@ -247,7 +247,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-        outlives_constraints: OutlivesConstraintSet,\n+        outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n@@ -1750,20 +1750,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn retrieve_closure_constraint_info(\n         &self,\n         body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint,\n-    ) -> (ConstraintCategory, bool, Span) {\n+        constraint: &OutlivesConstraint<'tcx>,\n+    ) -> BlameConstraint<'tcx> {\n         let loc = match constraint.locations {\n-            Locations::All(span) => return (constraint.category, false, span),\n+            Locations::All(span) => {\n+                return BlameConstraint {\n+                    category: constraint.category,\n+                    from_closure: false,\n+                    span,\n+                    variance_info: constraint.variance_info.clone(),\n+                };\n+            }\n             Locations::Single(loc) => loc,\n         };\n \n         let opt_span_category =\n             self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n-            constraint.category,\n-            false,\n-            body.source_info(loc).span,\n-        ))\n+        opt_span_category\n+            .map(|&(category, span)| BlameConstraint {\n+                category,\n+                from_closure: true,\n+                span: span,\n+                variance_info: constraint.variance_info.clone(),\n+            })\n+            .unwrap_or(BlameConstraint {\n+                category: constraint.category,\n+                from_closure: false,\n+                span: body.source_info(loc).span,\n+                variance_info: constraint.variance_info.clone(),\n+            })\n     }\n \n     /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n@@ -1774,9 +1789,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-            self.provides_universal_region(r, fr1, fr2)\n-        });\n+        let BlameConstraint { category, span, .. } =\n+            self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n+                self.provides_universal_region(r, fr1, fr2)\n+            });\n         (category, span)\n     }\n \n@@ -1792,7 +1808,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n+    ) -> Option<(Vec<OutlivesConstraint<'tcx>>, RegionVid)> {\n         let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n         context[from_region] = Trace::StartRegion;\n \n@@ -1816,14 +1832,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let mut result = vec![];\n                 let mut p = r;\n                 loop {\n-                    match context[p] {\n+                    match context[p].clone() {\n                         Trace::NotVisited => {\n                             bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n                         }\n \n                         Trace::FromOutlivesConstraint(c) => {\n-                            result.push(c);\n                             p = c.sup;\n+                            result.push(c);\n                         }\n \n                         Trace::StartRegion => {\n@@ -1846,7 +1862,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             // Always inline this closure because it can be hot.\n             let mut handle_constraint = #[inline(always)]\n-            |constraint: OutlivesConstraint| {\n+            |constraint: OutlivesConstraint<'tcx>| {\n                 debug_assert_eq!(constraint.sup, r);\n                 let sub_region = constraint.sub;\n                 if let Trace::NotVisited = context[sub_region] {\n@@ -1870,6 +1886,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     sub: constraint.min_choice,\n                     locations: Locations::All(p_c.definition_span),\n                     category: ConstraintCategory::OpaqueType,\n+                    variance_info: ty::VarianceDiagInfo::default(),\n                 };\n                 handle_constraint(constraint);\n             }\n@@ -1967,7 +1984,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         from_region: RegionVid,\n         from_region_origin: NllRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, bool, Span) {\n+    ) -> BlameConstraint<'tcx> {\n         debug!(\n             \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n             from_region, from_region_origin\n@@ -1979,7 +1996,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\n             \"best_blame_constraint: path={:#?}\",\n             path.iter()\n-                .map(|&c| format!(\n+                .map(|c| format!(\n                     \"{:?} ({:?}: {:?})\",\n                     c,\n                     self.constraint_sccs.scc(c.sup),\n@@ -1989,13 +2006,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n+        let mut categorized_path: Vec<BlameConstraint<'tcx>> = path\n             .iter()\n             .map(|constraint| {\n                 if constraint.category == ConstraintCategory::ClosureBounds {\n                     self.retrieve_closure_constraint_info(body, &constraint)\n                 } else {\n-                    (constraint.category, false, constraint.locations.span(body))\n+                    BlameConstraint {\n+                        category: constraint.category,\n+                        from_closure: false,\n+                        span: constraint.locations.span(body),\n+                        variance_info: constraint.variance_info.clone(),\n+                    }\n                 }\n             })\n             .collect();\n@@ -2067,12 +2089,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         let find_region = |i: &usize| {\n-            let constraint = path[*i];\n+            let constraint = &path[*i];\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n             if blame_source {\n-                match categorized_path[*i].0 {\n+                match categorized_path[*i].category {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n@@ -2083,7 +2105,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     _ => constraint_sup_scc != target_scc,\n                 }\n             } else {\n-                match categorized_path[*i].0 {\n+                match categorized_path[*i].category {\n                     ConstraintCategory::OpaqueType\n                     | ConstraintCategory::Boring\n                     | ConstraintCategory::BoringNoLocation\n@@ -2103,37 +2125,42 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n-                if matches!(categorized_path[i].0, ConstraintCategory::Return(_))\n-                    && next.0 == ConstraintCategory::OpaqueType\n+                if matches!(categorized_path[i].category, ConstraintCategory::Return(_))\n+                    && next.category == ConstraintCategory::OpaqueType\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n-                    return *next;\n+                    return next.clone();\n                 }\n             }\n \n-            if categorized_path[i].0 == ConstraintCategory::Return(ReturnConstraint::Normal) {\n+            if categorized_path[i].category == ConstraintCategory::Return(ReturnConstraint::Normal)\n+            {\n                 let field = categorized_path.iter().find_map(|p| {\n-                    if let ConstraintCategory::ClosureUpvar(f) = p.0 { Some(f) } else { None }\n+                    if let ConstraintCategory::ClosureUpvar(f) = p.category {\n+                        Some(f)\n+                    } else {\n+                        None\n+                    }\n                 });\n \n                 if let Some(field) = field {\n-                    categorized_path[i].0 =\n+                    categorized_path[i].category =\n                         ConstraintCategory::Return(ReturnConstraint::ClosureUpvar(field));\n                 }\n             }\n \n-            return categorized_path[i];\n+            return categorized_path[i].clone();\n         }\n \n         // If that search fails, that is.. unusual. Maybe everything\n         // is in the same SCC or something. In that case, find what\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n         debug!(\"`: sorted_path={:#?}\", categorized_path);\n \n-        *categorized_path.first().unwrap()\n+        categorized_path.remove(0)\n     }\n }\n \n@@ -2228,3 +2255,11 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             .collect()\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct BlameConstraint<'tcx> {\n+    pub category: ConstraintCategory,\n+    pub from_closure: bool,\n+    pub span: Span,\n+    pub variance_info: ty::VarianceDiagInfo<'tcx>,\n+}"}, {"sha": "eb11b9371433d145a24cac55f8738877d39ecb25", "filename": "compiler/rustc_mir/src/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -143,6 +143,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             category: self.category,\n             sub,\n             sup,\n+            variance_info: ty::VarianceDiagInfo::default(),\n         });\n     }\n "}, {"sha": "a34ae281b70dfdd547ed652226264299e0f37a1f", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -107,7 +107,7 @@ fn compute_live_locals(\n fn regions_that_outlive_free_regions(\n     num_region_vars: usize,\n     universal_regions: &UniversalRegions<'tcx>,\n-    constraint_set: &OutlivesConstraintSet,\n+    constraint_set: &OutlivesConstraintSet<'tcx>,\n ) -> FxHashSet<RegionVid> {\n     // Build a graph of the outlives constraints thus far. This is\n     // a reverse graph, so for each constraint `R1: R2` we have an"}, {"sha": "e294f128f2e142eb789e3a41051fc6aebbb97e91", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -226,7 +226,7 @@ fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n         let _prof_timer = typeck.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n         let location_table = cx.location_table;\n         facts.outlives.extend(cx.constraints.outlives_constraints.outlives().iter().flat_map(\n-            |constraint: &OutlivesConstraint| {\n+            |constraint: &OutlivesConstraint<'_>| {\n                 if let Some(from_location) = constraint.locations.from_location() {\n                     Either::Left(iter::once((\n                         constraint.sup,\n@@ -572,7 +572,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let locations = location.to_locations();\n         for constraint in constraints.outlives().iter() {\n-            let mut constraint = *constraint;\n+            let mut constraint = constraint.clone();\n             constraint.locations = locations;\n             if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n@@ -862,7 +862,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_constraints: LivenessValues<RegionVid>,\n \n-    crate outlives_constraints: OutlivesConstraintSet,\n+    crate outlives_constraints: OutlivesConstraintSet<'tcx>,\n \n     crate member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n@@ -2535,6 +2535,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 sub: borrow_region.to_region_vid(),\n                                 locations: location.to_locations(),\n                                 category,\n+                                variance_info: ty::VarianceDiagInfo::default(),\n                             });\n \n                             match mutbl {"}, {"sha": "f97252a117a6f018eec4cc881f37a39ceb94f727", "filename": "compiler/rustc_mir/src/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -94,7 +94,12 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         )\n     }\n \n-    fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {\n+    fn push_outlives(\n+        &mut self,\n+        sup: ty::Region<'tcx>,\n+        sub: ty::Region<'tcx>,\n+        info: ty::VarianceDiagInfo<'tcx>,\n+    ) {\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             let sub = borrowck_context.universal_regions.to_region_vid(sub);\n             let sup = borrowck_context.universal_regions.to_region_vid(sup);\n@@ -103,6 +108,7 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n                 sub,\n                 locations: self.locations,\n                 category: self.category,\n+                variance_info: info,\n             });\n         }\n     }"}, {"sha": "1da17bddcb777c3b044f4160beb686b8fddf4172", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -15,6 +15,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n+#![feature(format_args_capture)]\n #![feature(iter_zip)]\n #![feature(never_type)]\n #![feature(map_try_insert)]"}, {"sha": "01276495c185aea81546f90973c0c04a3db91852", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -310,6 +310,7 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,\n+        _info: ty::VarianceDiagInfo<'tcx>,\n         a: T,\n         b: T,\n     ) -> RelateResult<'tcx, T> {"}, {"sha": "cf73403bbae0755606200b12da834029deec0cf7", "filename": "src/test/ui/c-variadic/variadic-ffi-4.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -64,6 +64,10 @@ LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut\n    |                                               has type `&mut VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n    |     ^^^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n+   |\n+   = note: requirement occurs because of a mutable reference to VaListImpl<'_>\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/variadic-ffi-4.rs:28:5\n@@ -74,6 +78,10 @@ LL | pub unsafe extern \"C\" fn no_escape4(_: usize, mut ap0: &mut VaListImpl, mut\n    |                                               has type `&mut VaListImpl<'1>`\n LL |     ap0 = &mut ap1;\n    |     ^^^^^^^^^^^^^^ assignment requires that `'2` must outlive `'1`\n+   |\n+   = note: requirement occurs because of a mutable reference to VaListImpl<'_>\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error[E0597]: `ap1` does not live long enough\n   --> $DIR/variadic-ffi-4.rs:28:11"}, {"sha": "1dc29d2088cea353ac262aaff3062ab176cc63fc", "filename": "src/test/ui/match/match-ref-mut-invariance.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-invariance.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -9,6 +9,9 @@ LL |         match self.0 { ref mut x => x }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: aborting due to previous error\n "}, {"sha": "8b87c3da28b02f946a700dc55b004a272b0a26b1", "filename": "src/test/ui/match/match-ref-mut-let-invariance.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-ref-mut-let-invariance.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -10,6 +10,9 @@ LL |         x\n    |         ^ returning this value requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: aborting due to previous error\n "}, {"sha": "ccb3d33ac40647fe14f45cbfcf3a6fe4e85aa11f", "filename": "src/test/ui/nll/type-check-pointer-coercions.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-coercions.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -34,6 +34,9 @@ LL |     x\n    |     ^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable pointer to &i32\n+   = note: mutable pointers are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/type-check-pointer-coercions.rs:13:5\n@@ -47,6 +50,9 @@ LL |     x\n    |     ^ returning this value requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable pointer to &i32\n+   = note: mutable pointers are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'b` and `'a` must be the same: replace one with the other\n "}, {"sha": "b488af820b86d78344fff37d05dab2357098cd1b", "filename": "src/test/ui/nll/type-check-pointer-comparisons.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -9,6 +9,9 @@ LL |     x == y;\n    |     ^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/type-check-pointer-comparisons.rs:6:10\n@@ -21,6 +24,9 @@ LL |     x == y;\n    |          ^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'a` and `'b` must be the same: replace one with the other\n \n@@ -35,6 +41,9 @@ LL |     x == y;\n    |     ^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable pointer to &i32\n+   = note: mutable pointers are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/type-check-pointer-comparisons.rs:12:10\n@@ -47,6 +56,9 @@ LL |     x == y;\n    |          ^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable pointer to &i32\n+   = note: mutable pointers are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'a` and `'b` must be the same: replace one with the other\n \n@@ -61,6 +73,9 @@ LL |     f == g;\n    |     ^ requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/type-check-pointer-comparisons.rs:18:10\n@@ -73,6 +88,9 @@ LL |     f == g;\n    |          ^ requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to &i32\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n help: `'a` and `'b` must be the same: replace one with the other\n "}, {"sha": "4ddea2c27b2a634263b583da8368661d2d09a78b", "filename": "src/test/ui/regions/region-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -23,6 +23,9 @@ LL |     a(x, y);\n    |     ^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to &isize\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: higher-ranked subtype error\n   --> $DIR/region-lifetime-bounds-on-fns-where-clause.rs:20:12"}, {"sha": "a9cf128bb621a4bdec7167e1dee1573b058c6597", "filename": "src/test/ui/regions/region-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-multiple-lifetime-bounds-on-fns-where-clause.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -23,6 +23,9 @@ LL |     a(x, y, z);\n    |     ^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to &isize\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: higher-ranked subtype error\n   --> $DIR/region-multiple-lifetime-bounds-on-fns-where-clause.rs:22:12"}, {"sha": "db86572f1cf73a4c1ddde1973abfd164a76976c0", "filename": "src/test/ui/regions/regions-lifetime-bounds-on-fns.nll.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-lifetime-bounds-on-fns.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -23,6 +23,9 @@ LL |     a(x, y);\n    |     ^^^^^^^ argument requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to &isize\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: higher-ranked subtype error\n   --> $DIR/regions-lifetime-bounds-on-fns.rs:20:12"}, {"sha": "bf325d5601348697cdedd2dffb7e52b1ac020544", "filename": "src/test/ui/regions/regions-trait-object-subtyping.nll.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fad2242ff7bbafed5e7398e1286c3935b31f8233/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr?ref=fad2242ff7bbafed5e7398e1286c3935b31f8233", "patch": "@@ -10,6 +10,9 @@ LL |     x\n    |     ^ returning this value requires that `'a` must outlive `'b`\n    |\n    = help: consider adding the following bound: `'a: 'b`\n+   = note: requirement occurs because of a mutable reference to dyn Dummy\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: lifetime may not live long enough\n   --> $DIR/regions-trait-object-subtyping.rs:22:5\n@@ -23,6 +26,9 @@ LL |     x\n    |     ^ returning this value requires that `'b` must outlive `'a`\n    |\n    = help: consider adding the following bound: `'b: 'a`\n+   = note: requirement occurs because of a mutable reference to dyn Dummy\n+   = note: mutable references are invariant over their type parameter\n+   = help: see <https://doc.rust-lang.org/nomicon/subtyping.html> for more information about variance\n \n error: aborting due to 2 previous errors\n "}]}