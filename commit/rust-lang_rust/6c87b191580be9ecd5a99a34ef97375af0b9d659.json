{"sha": "6c87b191580be9ecd5a99a34ef97375af0b9d659", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjODdiMTkxNTgwYmU5ZWNkNWE5OWEzNGVmOTczNzVhZjBiOWQ2NTk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-17T17:41:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-17T21:52:56Z"}, "message": "Abstract away differences between Vec and ptr::P in HIR", "tree": {"sha": "c34e1c2b9553feb04db062f957cf86d7cc326c99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c34e1c2b9553feb04db062f957cf86d7cc326c99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c87b191580be9ecd5a99a34ef97375af0b9d659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c87b191580be9ecd5a99a34ef97375af0b9d659", "html_url": "https://github.com/rust-lang/rust/commit/6c87b191580be9ecd5a99a34ef97375af0b9d659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c87b191580be9ecd5a99a34ef97375af0b9d659/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d298f9904468b8f668cb9b505c19d64fdeb7633", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d298f9904468b8f668cb9b505c19d64fdeb7633", "html_url": "https://github.com/rust-lang/rust/commit/0d298f9904468b8f668cb9b505c19d64fdeb7633"}], "stats": {"total": 398, "additions": 214, "deletions": 184}, "files": [{"sha": "cab7e45ee62832522f99b664a1d4b3f269967ff7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -517,7 +517,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n         ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n             let v = adt.variant_of_ctor(ctor);\n             if let VariantKind::Struct = v.kind() {\n-                let field_pats: Vec<_> = v.fields.iter()\n+                let field_pats: hir::HirVec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != hir::PatWild)\n                     .map(|(field, pat)| Spanned {\n@@ -540,14 +540,14 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                ty::TyArray(_, n) => match ctor {\n                     &Single => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n                 ty::TySlice(_) => match ctor {\n                     &Slice(n) => {\n                         assert_eq!(pats_len, n);\n-                        hir::PatVec(pats.collect(), None, vec!())\n+                        hir::PatVec(pats.collect(), None, hir::HirVec::new())\n                     },\n                     _ => unreachable!()\n                 },\n@@ -562,7 +562,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n \n         ty::TyArray(_, len) => {\n             assert_eq!(pats_len, len);\n-            hir::PatVec(pats.collect(), None, vec![])\n+            hir::PatVec(pats.collect(), None, hir::HirVec::new())\n         }\n \n         _ => {"}, {"sha": "fb471fb6aaa4f9a84ad2ffe5c23ae59878e73d39", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -357,14 +357,14 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n \n         hir::ExprVec(ref exprs) => {\n             let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n-            hir::PatVec(pats, None, vec![])\n+            hir::PatVec(pats, None, hir::HirVec::new())\n         }\n \n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n                 Some(def::DefStruct(..)) =>\n-                    hir::PatStruct(path.clone(), vec![], false),\n+                    hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n                 Some(def::DefVariant(..)) =>\n                     hir::PatEnum(path.clone(), None),\n                 _ => {"}, {"sha": "73776304bc846d65cec3a38d1dc0a8a9326e25c7", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -324,7 +324,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n-    fn consume_exprs(&mut self, exprs: &Vec<P<hir::Expr>>) {\n+    fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n         for expr in exprs {\n             self.consume_expr(&**expr);\n         }\n@@ -651,7 +651,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn walk_struct_expr(&mut self,\n                         _expr: &hir::Expr,\n-                        fields: &Vec<hir::Field>,\n+                        fields: &[hir::Field],\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n@@ -697,7 +697,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         self.walk_expr(with_expr);\n \n         fn contains_field_named(field: ty::FieldDef,\n-                                fields: &Vec<hir::Field>)\n+                                fields: &[hir::Field])\n                                 -> bool\n         {\n             fields.iter().any("}, {"sha": "2abf499185690f7c8bd9ef3f251946637cb095f4", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -1254,7 +1254,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut lifetimes = Vec::new();\n         for lt in add {\n             lifetimes.push(hir::LifetimeDef { lifetime: *lt,\n-                                              bounds: Vec::new() });\n+                                              bounds: hir::HirVec::new() });\n         }\n         for lt in &generics.lifetimes {\n             if keep.contains(&lt.lifetime.name) ||\n@@ -1263,7 +1263,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n         }\n         hir::Generics {\n-            lifetimes: lifetimes,\n+            lifetimes: lifetimes.into(),\n             ty_params: ty_params,\n             where_clause: where_clause,\n         }\n@@ -1274,7 +1274,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        lifetime: hir::Lifetime,\n                        anon_nums: &HashSet<u32>,\n                        region_names: &HashSet<ast::Name>)\n-                       -> Vec<hir::Arg> {\n+                       -> hir::HirVec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n             let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             };\n             new_inputs.push(possibly_new_arg);\n         }\n-        new_inputs\n+        new_inputs.into()\n     }\n \n     fn rebuild_output(&self, ty: &hir::FunctionRetTy,\n@@ -1513,7 +1513,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 });\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                    lifetimes: new_lts,\n+                    lifetimes: new_lts.into(),\n                     types: new_types,\n                     bindings: new_bindings,\n                })\n@@ -1529,7 +1529,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n-            segments: new_segs\n+            segments: new_segs.into()\n         }\n     }\n }"}, {"sha": "9b133c5401519f595ff08dbe9a6f86bc99e89ecd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -79,10 +79,10 @@ struct LifetimeContext<'a> {\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n-    EarlyScope(subst::ParamSpace, &'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    EarlyScope(subst::ParamSpace, &'a [hir::LifetimeDef], Scope<'a>),\n     /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(&'a Vec<hir::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a [hir::LifetimeDef], Scope<'a>),\n \n     /// lifetimes introduced by a fn are scoped to the call-site for that fn.\n     FnScope { fn_id: ast::NodeId, body_id: ast::NodeId, s: Scope<'a> },\n@@ -206,7 +206,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n                     Some((def::DefTrait(..), 0)) => {\n-                        self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n+                        self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n                     }\n@@ -661,7 +661,7 @@ impl<'a> LifetimeContext<'a> {\n                     lifetime_ref.name);\n     }\n \n-    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<hir::LifetimeDef>) {\n+    fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &[hir::LifetimeDef]) {\n         for i in 0..lifetimes.len() {\n             let lifetime_i = &lifetimes[i];\n \n@@ -753,7 +753,7 @@ impl<'a> LifetimeContext<'a> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a Vec<hir::LifetimeDef>,\n+fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n                     lifetime_ref: &hir::Lifetime)\n                     -> Option<(u32, &'a hir::Lifetime)> {\n     for (i, lifetime_decl) in lifetimes.iter().enumerate() {"}, {"sha": "a41ee51fb5546023991fd29f56b2f53a0b190806", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -82,7 +82,7 @@ struct Annotator<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n-    fn annotate<F>(&mut self, id: NodeId, attrs: &Vec<Attribute>,\n+    fn annotate<F>(&mut self, id: NodeId, attrs: &[Attribute],\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Annotator)\n     {"}, {"sha": "784428cc114dc0cd9e7dba13dd0dd4e416aac3df", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -34,7 +34,7 @@ pub trait Folder : Sized {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: HirVec<P<MetaItem>>) -> HirVec<P<MetaItem>> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n@@ -198,11 +198,11 @@ pub trait Folder : Sized {\n         noop_fold_variant_data(vdata, self)\n     }\n \n-    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n+    fn fold_lifetimes(&mut self, lts: HirVec<Lifetime>) -> HirVec<Lifetime> {\n         noop_fold_lifetimes(lts, self)\n     }\n \n-    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n+    fn fold_lifetime_defs(&mut self, lts: HirVec<LifetimeDef>) -> HirVec<LifetimeDef> {\n         noop_fold_lifetime_defs(lts, self)\n     }\n \n@@ -263,9 +263,9 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>,\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: HirVec<P<MetaItem>>,\n                                        fld: &mut T)\n-                                       -> Vec<P<MetaItem>> {\n+                                       -> HirVec<P<MetaItem>> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n@@ -304,7 +304,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n     })\n }\n \n-pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n+pub fn fold_attrs<T: Folder>(attrs: HirVec<Attribute>, fld: &mut T) -> HirVec<Attribute> {\n     attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n@@ -477,7 +477,7 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n-            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, fld)),\n+            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), fld).into()),\n         }\n     })\n }\n@@ -596,11 +596,13 @@ pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T) -> Lifetim\n     }\n }\n \n-pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+pub fn noop_fold_lifetimes<T: Folder>(lts: HirVec<Lifetime>, fld: &mut T) -> HirVec<Lifetime> {\n     lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T) -> Vec<LifetimeDef> {\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: HirVec<LifetimeDef>,\n+                                          fld: &mut T)\n+                                          -> HirVec<LifetimeDef> {\n     lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n@@ -1139,7 +1141,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &\n             }\n         },\n         span: folder.new_span(span),\n-        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder)),\n+        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs.into(), folder).into()),\n     }\n }\n "}, {"sha": "6b2664af60ba5cd3bdf998321199b3396bdf68ee", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 75, "deletions": 57, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -40,7 +40,7 @@ use std::collections::BTreeMap;\n use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n-use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n+use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::ThinAttributes;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -52,6 +52,22 @@ use std::fmt;\n use std::hash::{Hash, Hasher};\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n+/// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n+/// of `Vec` to avoid keeping extra capacity.\n+pub type HirVec<T> = Vec<T>;\n+\n+macro_rules! hir_vec {\n+    ($elem:expr; $n:expr) => (\n+        $crate::hir::HirVec::from(vec![$elem; $n])\n+    );\n+    ($($x:expr),*) => (\n+        $crate::hir::HirVec::from(vec![$($x),*])\n+    );\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n /// Identifier in HIR\n #[derive(Clone, Copy, Eq)]\n pub struct Ident {\n@@ -129,7 +145,7 @@ impl fmt::Debug for Lifetime {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct LifetimeDef {\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// A \"Path\" is essentially Rust's notion of a name; for instance:\n@@ -142,7 +158,7 @@ pub struct Path {\n     /// module (like paths in an import).\n     pub global: bool,\n     /// The segments in the path: the things separated by `::`.\n-    pub segments: Vec<PathSegment>,\n+    pub segments: HirVec<PathSegment>,\n }\n \n impl fmt::Debug for Path {\n@@ -191,7 +207,7 @@ pub enum PathParameters {\n impl PathParameters {\n     pub fn none() -> PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: Vec::new(),\n+            lifetimes: HirVec::new(),\n             types: P::empty(),\n             bindings: P::empty(),\n         })\n@@ -223,7 +239,7 @@ impl PathParameters {\n \n     /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n     /// parameters in the parenthesized case.\n-    pub fn types(&self) -> Vec<&P<Ty>> {\n+    pub fn types(&self) -> HirVec<&P<Ty>> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.types.iter().collect()\n@@ -237,24 +253,24 @@ impl PathParameters {\n         }\n     }\n \n-    pub fn lifetimes(&self) -> Vec<&Lifetime> {\n+    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.lifetimes.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n \n-    pub fn bindings(&self) -> Vec<&TypeBinding> {\n+    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n         match *self {\n             AngleBracketedParameters(ref data) => {\n                 data.bindings.iter().collect()\n             }\n             ParenthesizedParameters(_) => {\n-                Vec::new()\n+                HirVec::new()\n             }\n         }\n     }\n@@ -264,7 +280,7 @@ impl PathParameters {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct AngleBracketedParameterData {\n     /// The lifetime parameters for this path segment.\n-    pub lifetimes: Vec<Lifetime>,\n+    pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: P<[P<Ty>]>,\n     /// Bindings (equality constraints) on associated types, if present.\n@@ -285,7 +301,7 @@ pub struct ParenthesizedParameterData {\n     pub span: Span,\n \n     /// `(A,B)`\n-    pub inputs: Vec<P<Ty>>,\n+    pub inputs: HirVec<P<Ty>>,\n \n     /// `C`\n     pub output: Option<P<Ty>>,\n@@ -324,7 +340,7 @@ pub struct TyParam {\n /// of a function, enum, trait, etc.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Generics {\n-    pub lifetimes: Vec<LifetimeDef>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n     pub ty_params: P<[TyParam]>,\n     pub where_clause: WhereClause,\n }\n@@ -345,7 +361,7 @@ impl Generics {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct WhereClause {\n     pub id: NodeId,\n-    pub predicates: Vec<WherePredicate>,\n+    pub predicates: HirVec<WherePredicate>,\n }\n \n /// A single predicate in a `where` clause\n@@ -364,7 +380,7 @@ pub enum WherePredicate {\n pub struct WhereBoundPredicate {\n     pub span: Span,\n     /// Any lifetimes from a `for` binding\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n     /// The type being bounded\n     pub bounded_ty: P<Ty>,\n     /// Trait and lifetime bounds (`Clone+Send+'static`)\n@@ -376,7 +392,7 @@ pub struct WhereBoundPredicate {\n pub struct WhereRegionPredicate {\n     pub span: Span,\n     pub lifetime: Lifetime,\n-    pub bounds: Vec<Lifetime>,\n+    pub bounds: HirVec<Lifetime>,\n }\n \n /// An equality predicate (unsupported), e.g. `T=int`\n@@ -388,13 +404,15 @@ pub struct WhereEqPredicate {\n     pub ty: P<Ty>,\n }\n \n+pub type CrateConfig = HirVec<P<MetaItem>>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Debug)]\n pub struct Crate {\n     pub module: Mod,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<MacroDef>,\n+    pub exported_macros: HirVec<MacroDef>,\n \n     // NB: We use a BTreeMap here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n@@ -431,20 +449,20 @@ impl Crate {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MacroDef {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub imported_from: Option<Name>,\n     pub export: bool,\n     pub use_locally: bool,\n     pub allow_internal_unstable: bool,\n-    pub body: Vec<TokenTree>,\n+    pub body: HirVec<TokenTree>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Block {\n     /// Statements in a block\n-    pub stmts: Vec<Stmt>,\n+    pub stmts: HirVec<Stmt>,\n     /// An expression at the end of the block\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n@@ -503,7 +521,7 @@ pub enum Pat_ {\n     PatIdent(BindingMode, Spanned<Ident>, Option<P<Pat>>),\n \n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<P<Pat>>>),\n+    PatEnum(Path, Option<HirVec<P<Pat>>>),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n@@ -513,9 +531,9 @@ pub enum Pat_ {\n \n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    PatStruct(Path, HirVec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(Vec<P<Pat>>),\n+    PatTup(HirVec<P<Pat>>),\n     /// A `box` pattern\n     PatBox(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n@@ -526,7 +544,7 @@ pub enum Pat_ {\n     PatRange(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n     ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    PatVec(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -640,8 +658,8 @@ pub enum Decl_ {\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n-    pub attrs: Vec<Attribute>,\n-    pub pats: Vec<P<Pat>>,\n+    pub attrs: HirVec<Attribute>,\n+    pub pats: HirVec<P<Pat>>,\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n }\n@@ -690,12 +708,12 @@ pub enum Expr_ {\n     /// A `box x` expression.\n     ExprBox(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n-    ExprVec(Vec<P<Expr>>),\n+    ExprVec(HirVec<P<Expr>>),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n     /// and the second field is the list of arguments\n-    ExprCall(P<Expr>, Vec<P<Expr>>),\n+    ExprCall(P<Expr>, HirVec<P<Expr>>),\n     /// A method call (`x.foo::<Bar, Baz>(a, b, c, d)`)\n     ///\n     /// The `Spanned<Name>` is the identifier for the method name.\n@@ -708,9 +726,9 @@ pub enum Expr_ {\n     ///\n     /// Thus, `x.foo::<Bar, Baz>(a, b, c, d)` is represented as\n     /// `ExprMethodCall(foo, [Bar, Baz], [x, a, b, c, d])`.\n-    ExprMethodCall(Spanned<Name>, Vec<P<Ty>>, Vec<P<Expr>>),\n+    ExprMethodCall(Spanned<Name>, HirVec<P<Ty>>, HirVec<P<Expr>>),\n     /// A tuple (`(a, b, c ,d)`)\n-    ExprTup(Vec<P<Expr>>),\n+    ExprTup(HirVec<P<Expr>>),\n     /// A binary operation (For example: `a + b`, `a * b`)\n     ExprBinary(BinOp, P<Expr>, P<Expr>),\n     /// A unary operation (For example: `!x`, `*x`)\n@@ -733,7 +751,7 @@ pub enum Expr_ {\n     ExprLoop(P<Block>, Option<Ident>),\n     /// A `match` block, with a source that indicates whether or not it is\n     /// the result of a desugaring, and if so, which kind.\n-    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n+    ExprMatch(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (for example, `move |a, b, c| {a + b + c}`)\n     ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     /// A block (`{ ... }`)\n@@ -760,7 +778,7 @@ pub enum Expr_ {\n     /// parameters, e.g. foo::bar::<baz>.\n     ///\n     /// Optionally \"qualified\",\n-    /// e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ExprPath(Option<QSelf>, Path),\n \n     /// A referencing operation (`&a` or `&mut a`)\n@@ -779,7 +797,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(Path, Vec<Field>, Option<P<Expr>>),\n+    ExprStruct(Path, HirVec<Field>, Option<P<Expr>>),\n \n     /// A vector literal constructed from one repeated element.\n     ///\n@@ -793,11 +811,11 @@ pub enum Expr_ {\n /// separately. `position` represents the index of the associated\n /// item qualified with this Self type.\n ///\n-///     <Vec<T> as a::b::Trait>::AssociatedItem\n+///     <HirVec<T> as a::b::Trait>::AssociatedItem\n ///      ^~~~~     ~~~~~~~~~~~~~~^\n ///      ty        position = 3\n ///\n-///     <Vec<T>>::AssociatedItem\n+///     <HirVec<T>>::AssociatedItem\n ///      ^~~~~    ^\n ///      ty       position = 0\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -850,7 +868,7 @@ pub struct MethodSig {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: TraitItem_,\n     pub span: Span,\n }\n@@ -867,7 +885,7 @@ pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: Visibility,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n }\n@@ -918,7 +936,7 @@ pub enum PrimTy {\n pub struct BareFnTy {\n     pub unsafety: Unsafety,\n     pub abi: Abi,\n-    pub lifetimes: Vec<LifetimeDef>,\n+    pub lifetimes: HirVec<LifetimeDef>,\n     pub decl: P<FnDecl>,\n }\n \n@@ -935,9 +953,9 @@ pub enum Ty_ {\n     /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n-    TyTup(Vec<P<Ty>>),\n+    TyTup(HirVec<P<Ty>>),\n     /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<Vec<T> as SomeTrait>::SomeType`.\n+    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n     ///\n     /// Type parameters are stored in the Path itself\n     TyPath(Option<QSelf>, Path),\n@@ -964,9 +982,9 @@ pub struct InlineAsmOutput {\n pub struct InlineAsm {\n     pub asm: InternedString,\n     pub asm_str_style: StrStyle,\n-    pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub outputs: HirVec<InlineAsmOutput>,\n+    pub inputs: HirVec<(InternedString, P<Expr>)>,\n+    pub clobbers: HirVec<InternedString>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -1007,7 +1025,7 @@ impl Arg {\n /// Represents the header (not the body) of a function declaration\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct FnDecl {\n-    pub inputs: Vec<Arg>,\n+    pub inputs: HirVec<Arg>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n }\n@@ -1098,24 +1116,24 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub item_ids: Vec<ItemId>,\n+    pub item_ids: HirVec<ItemId>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub items: Vec<ForeignItem>,\n+    pub items: HirVec<ForeignItem>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct EnumDef {\n-    pub variants: Vec<Variant>,\n+    pub variants: HirVec<Variant>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Variant_ {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub data: VariantData,\n     /// Explicit discriminant, eg `Foo = 1`\n     pub disr_expr: Option<P<Expr>>,\n@@ -1176,7 +1194,7 @@ pub enum ViewPath_ {\n     ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem>),\n+    ViewPathList(Path, HirVec<PathListItem>),\n }\n \n /// TraitRef's appear in impls.\n@@ -1194,7 +1212,7 @@ pub struct TraitRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PolyTraitRef {\n     /// The `'a` in `<'a> Foo<&'a T>`\n-    pub bound_lifetimes: Vec<LifetimeDef>,\n+    pub bound_lifetimes: HirVec<LifetimeDef>,\n \n     /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n     pub trait_ref: TraitRef,\n@@ -1222,7 +1240,7 @@ pub struct StructField_ {\n     pub kind: StructFieldKind,\n     pub id: NodeId,\n     pub ty: P<Ty>,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n }\n \n impl StructField_ {\n@@ -1271,8 +1289,8 @@ impl StructFieldKind {\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum VariantData {\n-    Struct(Vec<StructField>, NodeId),\n-    Tuple(Vec<StructField>, NodeId),\n+    Struct(HirVec<StructField>, NodeId),\n+    Tuple(HirVec<StructField>, NodeId),\n     Unit(NodeId),\n }\n \n@@ -1327,7 +1345,7 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n     pub node: Item_,\n     pub vis: Visibility,\n@@ -1360,7 +1378,7 @@ pub enum Item_ {\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(Unsafety, Generics, TyParamBounds, Vec<TraitItem>),\n+    ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n \n     // Default trait implementations\n     ///\n@@ -1372,7 +1390,7 @@ pub enum Item_ {\n              Generics,\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n-             Vec<ImplItem>),\n+             HirVec<ImplItem>),\n }\n \n impl Item_ {\n@@ -1398,7 +1416,7 @@ impl Item_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ForeignItem {\n     pub name: Name,\n-    pub attrs: Vec<Attribute>,\n+    pub attrs: HirVec<Attribute>,\n     pub node: ForeignItem_,\n     pub id: NodeId,\n     pub span: Span,"}, {"sha": "60080854a6f1724441b3ce75f405220aa71b5268", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -47,6 +47,7 @@ extern crate rustc_bitflags;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+#[macro_use]\n pub mod hir;\n pub mod lowering;\n pub mod fold;"}, {"sha": "db30ee9a5d2d351b7c61816edcd3fb45ac9a62e5", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -147,6 +147,10 @@ pub fn lower_ident(_lctx: &LoweringContext, ident: Ident) -> hir::Ident {\n     }\n }\n \n+pub fn lower_attrs(_lctx: &LoweringContext, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+    attrs.clone().into()\n+}\n+\n pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n     P(Spanned {\n         node: match view_path.node {\n@@ -186,7 +190,7 @@ pub fn lower_view_path(lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::V\n \n pub fn lower_arm(lctx: &LoweringContext, arm: &Arm) -> hir::Arm {\n     hir::Arm {\n-        attrs: arm.attrs.clone(),\n+        attrs: lower_attrs(lctx, &arm.attrs),\n         pats: arm.pats.iter().map(|x| lower_pat(lctx, x)).collect(),\n         guard: arm.guard.as_ref().map(|ref x| lower_expr(lctx, x)),\n         body: lower_expr(lctx, &arm.body),\n@@ -275,7 +279,7 @@ pub fn lower_variant(lctx: &LoweringContext, v: &Variant) -> hir::Variant {\n     Spanned {\n         node: hir::Variant_ {\n             name: v.node.name.name,\n-            attrs: v.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &v.node.attrs),\n             data: lower_variant_data(lctx, &v.node.data),\n             disr_expr: v.node.disr_expr.as_ref().map(|e| lower_expr(lctx, e)),\n         },\n@@ -449,13 +453,13 @@ pub fn lower_lifetime_def(lctx: &LoweringContext, l: &LifetimeDef) -> hir::Lifet\n     }\n }\n \n-pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> Vec<hir::Lifetime> {\n+pub fn lower_lifetimes(lctx: &LoweringContext, lts: &Vec<Lifetime>) -> hir::HirVec<hir::Lifetime> {\n     lts.iter().map(|l| lower_lifetime(lctx, l)).collect()\n }\n \n pub fn lower_lifetime_defs(lctx: &LoweringContext,\n                            lts: &Vec<LifetimeDef>)\n-                           -> Vec<hir::LifetimeDef> {\n+                           -> hir::HirVec<hir::LifetimeDef> {\n     lts.iter().map(|l| lower_lifetime_def(lctx, l)).collect()\n }\n \n@@ -560,7 +564,7 @@ pub fn lower_struct_field(lctx: &LoweringContext, f: &StructField) -> hir::Struc\n             id: f.node.id,\n             kind: lower_struct_field_kind(lctx, &f.node.kind),\n             ty: lower_ty(lctx, &f.node.ty),\n-            attrs: f.node.attrs.clone(),\n+            attrs: lower_attrs(lctx, &f.node.attrs),\n         },\n         span: f.span,\n     }\n@@ -673,7 +677,7 @@ pub fn lower_trait_item(lctx: &LoweringContext, i: &TraitItem) -> hir::TraitItem\n     hir::TraitItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ConstTraitItem(ref ty, ref default) => {\n                 hir::ConstTraitItem(lower_ty(lctx, ty),\n@@ -696,7 +700,7 @@ pub fn lower_impl_item(lctx: &LoweringContext, i: &ImplItem) -> hir::ImplItem {\n     hir::ImplItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         vis: lower_visibility(lctx, i.vis),\n         node: match i.node {\n             ImplItemKind::Const(ref ty, ref expr) => {\n@@ -740,25 +744,25 @@ pub fn lower_crate(lctx: &LoweringContext, c: &Crate) -> hir::Crate {\n \n     hir::Crate {\n         module: lower_mod(lctx, &c.module),\n-        attrs: c.attrs.clone(),\n-        config: c.config.clone(),\n+        attrs: lower_attrs(lctx, &c.attrs),\n+        config: c.config.clone().into(),\n         span: c.span,\n         exported_macros: c.exported_macros.iter().map(|m| lower_macro_def(lctx, m)).collect(),\n         items: items,\n     }\n }\n \n-pub fn lower_macro_def(_lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n+pub fn lower_macro_def(lctx: &LoweringContext, m: &MacroDef) -> hir::MacroDef {\n     hir::MacroDef {\n         name: m.ident.name,\n-        attrs: m.attrs.clone(),\n+        attrs: lower_attrs(lctx, &m.attrs),\n         id: m.id,\n         span: m.span,\n         imported_from: m.imported_from.map(|x| x.name),\n         export: m.export,\n         use_locally: m.use_locally,\n         allow_internal_unstable: m.allow_internal_unstable,\n-        body: m.body.clone(),\n+        body: m.body.clone().into(),\n     }\n }\n \n@@ -772,7 +776,7 @@ pub fn lower_item(lctx: &LoweringContext, i: &Item) -> hir::Item {\n     hir::Item {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: node,\n         vis: lower_visibility(lctx, i.vis),\n         span: i.span,\n@@ -783,7 +787,7 @@ pub fn lower_foreign_item(lctx: &LoweringContext, i: &ForeignItem) -> hir::Forei\n     hir::ForeignItem {\n         id: i.id,\n         name: i.ident.name,\n-        attrs: i.attrs.clone(),\n+        attrs: lower_attrs(lctx, &i.attrs),\n         node: match i.node {\n             ForeignItemFn(ref fdec, ref generics) => {\n                 hir::ForeignItemFn(lower_fn_decl(lctx, fdec), lower_generics(lctx, generics))\n@@ -1020,7 +1024,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let placer = <placer_expr> ;\n                     let s1 = {\n                         let placer_expr = signal_block_expr(lctx,\n-                                                            vec![],\n+                                                            hir_vec![],\n                                                             placer_expr,\n                                                             e.span,\n                                                             hir::PopUnstableBlock,\n@@ -1031,28 +1035,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // let mut place = Placer::make_place(placer);\n                     let s2 = {\n                         let placer = expr_ident(lctx, e.span, placer_ident, None);\n-                        let call = make_call(lctx, &make_place, vec![placer]);\n+                        let call = make_call(lctx, &make_place, hir_vec![placer]);\n                         mk_stmt_let_mut(lctx, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let s3 = {\n                         let agent = expr_ident(lctx, e.span, place_ident, None);\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n+                        let args = hir_vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                         let call = make_call(lctx, &place_pointer, args);\n                         mk_stmt_let(lctx, p_ptr_ident, call)\n                     };\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n                         let value_expr = signal_block_expr(lctx,\n-                                                           vec![],\n+                                                           hir_vec![],\n                                                            value_expr,\n                                                            e.span,\n                                                            hir::PopUnstableBlock,\n                                                            None);\n                         signal_block_expr(lctx,\n-                                          vec![],\n+                                          hir_vec![],\n                                           value_expr,\n                                           e.span,\n                                           hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n@@ -1066,21 +1070,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n-                                make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n+                                make_call(lctx, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n                                 lctx.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n                         let place = expr_ident(lctx, e.span, place_ident, None);\n-                        let call = make_call(lctx, &inplace_finalize, vec![place]);\n+                        let call = make_call(lctx, &inplace_finalize, hir_vec![place]);\n                         signal_block_expr(lctx,\n-                                          vec![call_move_val_init],\n+                                          hir_vec![call_move_val_init],\n                                           call,\n                                           e.span,\n                                           hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     signal_block_expr(lctx,\n-                                      vec![s1, s2, s3],\n+                                      hir_vec![s1, s2, s3],\n                                       expr,\n                                       e.span,\n                                       hir::PushUnstableBlock,\n@@ -1141,7 +1145,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 let els = lower_expr(lctx, els);\n                                 let id = lctx.next_id();\n                                 let blk = P(hir::Block {\n-                                    stmts: vec![],\n+                                    stmts: hir_vec![],\n                                     expr: Some(els),\n                                     id: id,\n                                     rules: hir::DefaultBlock,\n@@ -1238,7 +1242,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 .collect(),\n                 asm: asm.clone(),\n                 asm_str_style: asm_str_style,\n-                clobbers: clobbers.clone(),\n+                clobbers: clobbers.clone().into(),\n                 volatile: volatile,\n                 alignstack: alignstack,\n                 dialect: dialect,\n@@ -1275,7 +1279,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n@@ -1290,8 +1294,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                         hir::ExprIf(cond, then, else_opt) => {\n                                             let pat_under = pat_wild(lctx, e.span);\n                                             arms.push(hir::Arm {\n-                                                attrs: vec![],\n-                                                pats: vec![pat_under],\n+                                                attrs: hir_vec![],\n+                                                pats: hir_vec![pat_under],\n                                                 guard: Some(cond),\n                                                 body: expr_block(lctx, then, None),\n                                             });\n@@ -1325,8 +1329,8 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let else_expr =\n                             else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, vec![], None));\n-                        arm(vec![pat_under], else_expr)\n+                                || expr_tuple(lctx, e.span, hir_vec![], None));\n+                        arm(hir_vec![pat_under], else_expr)\n                     };\n \n                     let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n@@ -1339,7 +1343,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     expr(lctx,\n                          e.span,\n                          hir::ExprMatch(sub_expr,\n-                                        arms,\n+                                        arms.into(),\n                                         hir::MatchSource::IfLetDesugar {\n                                             contains_else_clause: contains_else_clause,\n                                         }),\n@@ -1364,18 +1368,18 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n                         let body_expr = expr_block(lctx, body, None);\n-                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                        arm(hir_vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let break_expr = expr_break(lctx, e.span, None);\n-                        arm(vec![pat_under], break_expr)\n+                        arm(hir_vec![pat_under], break_expr)\n                     };\n \n                     // `match <sub_expr> { ... }`\n-                    let arms = vec![pat_arm, break_arm];\n+                    let arms = hir_vec![pat_arm, break_arm];\n                     let sub_expr = lower_expr(lctx, sub_expr);\n                     let match_expr = expr(lctx,\n                                           e.span,\n@@ -1431,14 +1435,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat = lower_pat(lctx, pat);\n                         let some_pat = pat_some(lctx, e.span, pat);\n \n-                        arm(vec![some_pat], body_expr)\n+                        arm(hir_vec![some_pat], body_expr)\n                     };\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n                         let break_expr = expr_break(lctx, e.span, None);\n \n-                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                        arm(hir_vec![pat_none(lctx, e.span)], break_expr)\n                     };\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n@@ -1454,9 +1458,9 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let next_expr = expr_call(lctx,\n                                                   e.span,\n                                                   next_path,\n-                                                  vec![ref_mut_iter],\n+                                                  hir_vec![ref_mut_iter],\n                                                   None);\n-                        let arms = vec![pat_arm, break_arm];\n+                        let arms = hir_vec![pat_arm, break_arm];\n \n                         expr(lctx,\n                              e.span,\n@@ -1476,7 +1480,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                               e.span,\n                                                               iter,\n                                                               hir::BindByValue(hir::MutMutable));\n-                        arm(vec![iter_pat], loop_expr)\n+                        arm(hir_vec![iter_pat], loop_expr)\n                     };\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n@@ -1488,21 +1492,21 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         };\n \n                         let into_iter = expr_path(lctx, into_iter_path, None);\n-                        expr_call(lctx, e.span, into_iter, vec![head], None)\n+                        expr_call(lctx, e.span, into_iter, hir_vec![head], None)\n                     };\n \n                     let match_expr = expr_match(lctx,\n                                                 e.span,\n                                                 into_iter_expr,\n-                                                vec![iter_arm],\n+                                                hir_vec![iter_arm],\n                                                 hir::MatchSource::ForLoopDesugar,\n                                                 None);\n \n                     // `{ let result = ...; result }`\n                     let result_ident = lctx.str_to_ident(\"result\");\n                     let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n                     let result = expr_ident(lctx, e.span, result_ident, None);\n-                    let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n+                    let block = block_all(lctx, e.span, hir_vec![let_stmt], Some(result));\n                     // add the attributes to the outer returned expr node\n                     expr_block(lctx, block, e.attrs.clone())\n                 });\n@@ -1601,9 +1605,9 @@ pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n \n // Helper methods for building HIR.\n \n-fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+fn arm(pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     hir::Arm {\n-        attrs: vec![],\n+        attrs: hir_vec![],\n         pats: pats,\n         guard: None,\n         body: expr,\n@@ -1618,7 +1622,7 @@ fn expr_break(lctx: &LoweringContext, span: Span,\n fn expr_call(lctx: &LoweringContext,\n              span: Span,\n              e: P<hir::Expr>,\n-             args: Vec<P<hir::Expr>>,\n+             args: hir::HirVec<P<hir::Expr>>,\n              attrs: ThinAttributes)\n              -> P<hir::Expr> {\n     expr(lctx, span, hir::ExprCall(e, args), attrs)\n@@ -1642,7 +1646,7 @@ fn expr_path(lctx: &LoweringContext, path: hir::Path,\n fn expr_match(lctx: &LoweringContext,\n               span: Span,\n               arg: P<hir::Expr>,\n-              arms: Vec<hir::Arm>,\n+              arms: hir::HirVec<hir::Arm>,\n               source: hir::MatchSource,\n               attrs: ThinAttributes)\n               -> P<hir::Expr> {\n@@ -1654,7 +1658,7 @@ fn expr_block(lctx: &LoweringContext, b: P<hir::Block>,\n     expr(lctx, b.span, hir::ExprBlock(b), attrs)\n }\n \n-fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>,\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: hir::HirVec<P<hir::Expr>>,\n               attrs: ThinAttributes) -> P<hir::Expr> {\n     expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n@@ -1694,12 +1698,12 @@ fn stmt_let(lctx: &LoweringContext,\n }\n \n fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n-    block_all(lctx, expr.span, Vec::new(), Some(expr))\n+    block_all(lctx, expr.span, hir::HirVec::new(), Some(expr))\n }\n \n fn block_all(lctx: &LoweringContext,\n              span: Span,\n-             stmts: Vec<hir::Stmt>,\n+             stmts: hir::HirVec<hir::Stmt>,\n              expr: Option<P<hir::Expr>>)\n              -> P<hir::Block> {\n     P(hir::Block {\n@@ -1714,19 +1718,19 @@ fn block_all(lctx: &LoweringContext,\n fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n     let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n     let path = path_global(span, some);\n-    pat_enum(lctx, span, path, vec![pat])\n+    pat_enum(lctx, span, path, hir_vec![pat])\n }\n \n fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n     let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n     let path = path_global(span, none);\n-    pat_enum(lctx, span, path, vec![])\n+    pat_enum(lctx, span, path, hir_vec![])\n }\n \n fn pat_enum(lctx: &LoweringContext,\n             span: Span,\n             path: hir::Path,\n-            subpats: Vec<P<hir::Pat>>)\n+            subpats: hir::HirVec<P<hir::Pat>>)\n             -> P<hir::Pat> {\n     let pt = hir::PatEnum(path, Some(subpats));\n     pat(lctx, span, pt)\n@@ -1767,17 +1771,17 @@ fn path_ident(span: Span, id: hir::Ident) -> hir::Path {\n }\n \n fn path(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, false, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_global(span: Span, strs: Vec<hir::Ident>) -> hir::Path {\n-    path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+    path_all(span, true, strs, hir::HirVec::new(), Vec::new(), Vec::new())\n }\n \n fn path_all(sp: Span,\n             global: bool,\n             mut idents: Vec<hir::Ident>,\n-            lifetimes: Vec<hir::Lifetime>,\n+            lifetimes: hir::HirVec<hir::Lifetime>,\n             types: Vec<P<hir::Ty>>,\n             bindings: Vec<hir::TypeBinding>)\n             -> hir::Path {\n@@ -1801,7 +1805,7 @@ fn path_all(sp: Span,\n     hir::Path {\n         span: sp,\n         global: global,\n-        segments: segments,\n+        segments: segments.into(),\n     }\n }\n \n@@ -1822,7 +1826,7 @@ fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Pa\n }\n \n fn signal_block_expr(lctx: &LoweringContext,\n-                     stmts: Vec<hir::Stmt>,\n+                     stmts: hir::HirVec<hir::Stmt>,\n                      expr: P<hir::Expr>,\n                      span: Span,\n                      rule: hir::BlockCheckMode,"}, {"sha": "c4c5b9170f6bf54cf4a85cab28bd77d55451ac6a", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -521,7 +521,7 @@ impl<'a> State<'a> {\n                     ty_params: P::empty(),\n                     where_clause: hir::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n-                        predicates: Vec::new(),\n+                        predicates: hir::HirVec::new(),\n                     },\n                 };\n                 try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n@@ -2256,11 +2256,11 @@ impl<'a> State<'a> {\n             try!(self.print_generics(generics));\n         }\n         let generics = hir::Generics {\n-            lifetimes: Vec::new(),\n+            lifetimes: hir::HirVec::new(),\n             ty_params: P::empty(),\n             where_clause: hir::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n-                predicates: Vec::new(),\n+                predicates: hir::HirVec::new(),\n             },\n         };\n         try!(self.print_fn(decl,"}, {"sha": "298904d1e0d7abdcf82df68c090b3a5cceca64eb", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -334,11 +334,11 @@ pub fn is_path(e: P<Expr>) -> bool {\n \n pub fn empty_generics() -> Generics {\n     Generics {\n-        lifetimes: Vec::new(),\n+        lifetimes: HirVec::new(),\n         ty_params: P::empty(),\n         where_clause: WhereClause {\n             id: DUMMY_NODE_ID,\n-            predicates: Vec::new(),\n+            predicates: HirVec::new(),\n         },\n     }\n }\n@@ -349,13 +349,13 @@ pub fn ident_to_path(s: Span, ident: Ident) -> Path {\n     hir::Path {\n         span: s,\n         global: false,\n-        segments: vec!(hir::PathSegment {\n+        segments: hir_vec![hir::PathSegment {\n             identifier: ident,\n             parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: Vec::new(),\n+                lifetimes: HirVec::new(),\n                 types: P::empty(),\n                 bindings: P::empty(),\n             }),\n-        }),\n+        }],\n     }\n }"}, {"sha": "64a86373ee1e57ec7fe0573e29b97e57ce839de2", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -252,7 +252,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n         }\n     }\n \n-    fn to_pats(&mut self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<Pattern<'tcx>> {\n+    fn to_pats(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n         pats.iter().map(|p| self.to_pat(p)).collect()\n     }\n \n@@ -263,9 +263,9 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n     fn slice_or_array_pattern(&mut self,\n                               pat: &'tcx hir::Pat,\n                               ty: Ty<'tcx>,\n-                              prefix: &'tcx Vec<P<hir::Pat>>,\n+                              prefix: &'tcx [P<hir::Pat>],\n                               slice: &'tcx Option<P<hir::Pat>>,\n-                              suffix: &'tcx Vec<P<hir::Pat>>)\n+                              suffix: &'tcx [P<hir::Pat>])\n                               -> PatternKind<'tcx> {\n         match ty.sty {\n             ty::TySlice(..) => {"}, {"sha": "2a9b675d8767deede0c472f7ab02870ecffcfe2b", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -1038,7 +1038,7 @@ pub fn trans_static(ccx: &CrateContext,\n                     m: hir::Mutability,\n                     expr: &hir::Expr,\n                     id: ast::NodeId,\n-                    attrs: &Vec<ast::Attribute>)\n+                    attrs: &[ast::Attribute])\n                     -> Result<ValueRef, ConstEvalErr> {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");"}, {"sha": "675eef637b10b7626a83b476ae79a084b7df973b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -1584,8 +1584,13 @@ impl Clean<Type> for hir::Ty {\n                 resolve_type(cx, p.clean(cx), self.id)\n             }\n             TyPath(Some(ref qself), ref p) => {\n-                let mut trait_path = p.clone();\n-                trait_path.segments.pop();\n+                let mut segments: Vec<_> = p.segments.clone().into();\n+                segments.pop();\n+                let trait_path = hir::Path {\n+                    span: p.span,\n+                    global: p.global,\n+                    segments: segments.into(),\n+                };\n                 Type::QPath {\n                     name: p.segments.last().unwrap().identifier.name.clean(cx),\n                     self_type: box qself.ty.clean(cx),"}, {"sha": "fc0422b3a3f037ad6be59491121c57deb068532f", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -24,7 +24,7 @@ use rustc_front::hir;\n \n pub struct Module {\n     pub name: Option<Name>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n     pub extern_crates: Vec<ExternCrate>,\n@@ -58,7 +58,7 @@ impl Module {\n             depr: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n-            attrs      : Vec::new(),\n+            attrs      : hir::HirVec::new(),\n             extern_crates: Vec::new(),\n             imports    : Vec::new(),\n             structs    : Vec::new(),\n@@ -103,26 +103,26 @@ pub struct Struct {\n     pub struct_type: StructType,\n     pub name: Name,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n-    pub fields: Vec<hir::StructField>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub fields: hir::HirVec<hir::StructField>,\n     pub whence: Span,\n }\n \n pub struct Enum {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n-    pub variants: Vec<Variant>,\n+    pub variants: hir::HirVec<Variant>,\n     pub generics: hir::Generics,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub whence: Span,\n     pub name: Name,\n }\n \n pub struct Variant {\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub def: hir::VariantData,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -131,7 +131,7 @@ pub struct Variant {\n \n pub struct Function {\n     pub decl: hir::FnDecl,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: NodeId,\n     pub name: Name,\n     pub vis: hir::Visibility,\n@@ -149,7 +149,7 @@ pub struct Typedef {\n     pub gen: hir::Generics,\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -162,7 +162,7 @@ pub struct Static {\n     pub mutability: hir::Mutability,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -174,7 +174,7 @@ pub struct Constant {\n     pub type_: P<hir::Ty>,\n     pub expr: P<hir::Expr>,\n     pub name: Name,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n@@ -185,10 +185,10 @@ pub struct Constant {\n pub struct Trait {\n     pub unsafety: hir::Unsafety,\n     pub name: Name,\n-    pub items: Vec<hir::TraitItem>,\n+    pub items: hir::HirVec<hir::TraitItem>,\n     pub generics: hir::Generics,\n-    pub bounds: Vec<hir::TyParamBound>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub bounds: hir::HirVec<hir::TyParamBound>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub id: ast::NodeId,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n@@ -202,8 +202,8 @@ pub struct Impl {\n     pub generics: hir::Generics,\n     pub trait_: Option<hir::TraitRef>,\n     pub for_: P<hir::Ty>,\n-    pub items: Vec<hir::ImplItem>,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub items: hir::HirVec<hir::ImplItem>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,\n@@ -215,16 +215,16 @@ pub struct DefaultImpl {\n     pub unsafety: hir::Unsafety,\n     pub trait_: hir::TraitRef,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Macro {\n     pub name: Name,\n     pub id: ast::NodeId,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n-    pub matchers: Vec<Span>,\n+    pub matchers: hir::HirVec<Span>,\n     pub stab: Option<attr::Stability>,\n     pub depr: Option<attr::Deprecation>,\n     pub imported_from: Option<Name>,\n@@ -234,14 +234,14 @@ pub struct ExternCrate {\n     pub name: Name,\n     pub path: Option<String>,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub whence: Span,\n }\n \n pub struct Import {\n     pub id: NodeId,\n     pub vis: hir::Visibility,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub node: hir::ViewPath_,\n     pub whence: Span,\n }"}, {"sha": "ba389bc42b78cd30df66543a03e688ef923a9827", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c87b191580be9ecd5a99a34ef97375af0b9d659/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6c87b191580be9ecd5a99a34ef97375af0b9d659", "patch": "@@ -38,7 +38,7 @@ use doctree::*;\n \n pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n-    pub attrs: Vec<ast::Attribute>,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n     pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n-            attrs: Vec::new(),\n+            attrs: hir::HirVec::new(),\n             cx: cx,\n             analysis: analysis,\n             view_item_stack: stack,\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n-    pub fn visit_mod_contents(&mut self, span: Span, attrs: Vec<ast::Attribute> ,\n+    pub fn visit_mod_contents(&mut self, span: Span, attrs: hir::HirVec<ast::Attribute>,\n                               vis: hir::Visibility, id: ast::NodeId,\n                               m: &hir::Mod,\n                               name: Option<ast::Name>) -> Module {\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let mine = paths.into_iter().filter(|path| {\n                     !self.resolve_id(path.node.id(), None, false, om,\n                                      please_inline)\n-                }).collect::<Vec<hir::PathListItem>>();\n+                }).collect::<hir::HirVec<hir::PathListItem>>();\n \n                 if mine.is_empty() {\n                     None"}]}