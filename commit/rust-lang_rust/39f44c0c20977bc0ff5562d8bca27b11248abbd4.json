{"sha": "39f44c0c20977bc0ff5562d8bca27b11248abbd4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjQ0YzBjMjA5NzdiYzBmZjU1NjJkOGJjYTI3YjExMjQ4YWJiZDQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T20:00:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T04:53:01Z"}, "message": "libsyntax: remove unnecessary `as_slice()` calls", "tree": {"sha": "c8b98cf1edcfdccfb831c18190e078fc394a4c92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8b98cf1edcfdccfb831c18190e078fc394a4c92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f44c0c20977bc0ff5562d8bca27b11248abbd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f44c0c20977bc0ff5562d8bca27b11248abbd4", "html_url": "https://github.com/rust-lang/rust/commit/39f44c0c20977bc0ff5562d8bca27b11248abbd4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f44c0c20977bc0ff5562d8bca27b11248abbd4/comments", "author": null, "committer": null, "parents": [{"sha": "60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd", "html_url": "https://github.com/rust-lang/rust/commit/60338d91c4334e5fdfbd37b298cd5b99e8fc0cdd"}], "stats": {"total": 46, "additions": 22, "deletions": 24}, "files": [{"sha": "ce2fe6e72209602e80d2eea1fafbc3db44726eee", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -260,7 +260,7 @@ impl<'ast> Map<'ast> {\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().as_slice().get(id as uint).map(|e| *e)\n+        self.map.borrow().get(id as uint).map(|e| *e)\n     }\n \n     pub fn krate(&self) -> &'ast Crate {"}, {"sha": "7df09260cfc2f24f1371c73687be3f518aa03420", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -290,7 +290,7 @@ impl FileMap {\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n             let begin = begin.to_uint();\n-            let slice = self.src.as_slice().slice_from(begin);\n+            let slice = self.src.slice_from(begin);\n             match slice.find('\\n') {\n                 Some(e) => slice.slice_to(e),\n                 None => slice\n@@ -308,8 +308,8 @@ impl FileMap {\n     }\n \n     pub fn is_real_file(&self) -> bool {\n-        !(self.name.as_slice().starts_with(\"<\") &&\n-          self.name.as_slice().ends_with(\">\"))\n+        !(self.name.starts_with(\"<\") &&\n+          self.name.ends_with(\">\"))\n     }\n }\n \n@@ -336,8 +336,8 @@ impl CodeMap {\n         // Remove utf-8 BOM if any.\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n-        let mut src = if src.as_slice().starts_with(\"\\ufeff\") {\n-            String::from_str(src.as_slice().slice_from(3))\n+        let mut src = if src.starts_with(\"\\ufeff\") {\n+            String::from_str(src.slice_from(3))\n         } else {\n             String::from_str(src.as_slice())\n         };\n@@ -346,7 +346,7 @@ impl CodeMap {\n         // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n         // overflowing into the next filemap in case the last byte of span is also the last\n         // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n-        if src.len() > 0 && !src.as_slice().ends_with(\"\\n\") {\n+        if src.len() > 0 && !src.ends_with(\"\\n\") {\n             src.push('\\n');\n         }\n \n@@ -426,14 +426,14 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.src.as_slice().slice(begin.pos.to_uint(),\n-                                               end.pos.to_uint()).to_string())\n+            Some(begin.fm.src.slice(begin.pos.to_uint(),\n+                                    end.pos.to_uint()).to_string())\n         }\n     }\n \n     pub fn get_filemap(&self, filename: &str) -> Rc<FileMap> {\n         for fm in self.files.borrow().iter() {\n-            if filename == fm.name.as_slice() {\n+            if filename == fm.name {\n                 return fm.clone();\n             }\n         }"}, {"sha": "0787518f04fb6fe43bb4dfd99139bc43db26f915", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -527,7 +527,7 @@ impl<'a> ExtCtxt<'a> {\n         let mut call_site = None;\n         loop {\n             let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n-                ei.map(|ei| (ei.call_site, ei.callee.name.as_slice() == \"include\"))\n+                ei.map(|ei| (ei.call_site, ei.callee.name == \"include\"))\n             });\n             match expn_info {\n                 None => break,"}, {"sha": "4af7b35079a63ffa2cddaeb27b2ce21cf6aa598e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -132,7 +132,7 @@ impl<'a> Context<'a> {\n     }\n \n     fn has_feature(&self, feature: &str) -> bool {\n-        self.features.iter().any(|n| n.as_slice() == feature)\n+        self.features.iter().any(|&n| n == feature)\n     }\n }\n "}, {"sha": "f9877d937ca16dbaa6458d3e40086144b2a11d71", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -66,21 +66,20 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n-                lines[0].as_slice().chars().all(|c| c == '*') {\n+                lines[0].chars().all(|c| c == '*') {\n             i += 1;\n         }\n-        while i < j && lines[i].as_slice().trim().is_empty() {\n+        while i < j && lines[i].trim().is_empty() {\n             i += 1;\n         }\n         // like the first, a last line of all stars should be omitted\n         if j > i && lines[j - 1]\n-                         .as_slice()\n                          .chars()\n                          .skip(1)\n                          .all(|c| c == '*') {\n             j -= 1;\n         }\n-        while j > i && lines[j - 1].as_slice().trim().is_empty() {\n+        while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n         return lines.slice(i, j).iter().map(|x| (*x).clone()).collect();\n@@ -92,7 +91,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {\n-            for (j, c) in line.as_slice().chars().enumerate() {\n+            for (j, c) in line.chars().enumerate() {\n                 if j > i || !\"* \\t\".contains_char(c) {\n                     can_trim = false;\n                     break;\n@@ -117,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line.as_slice().slice(i + 1, line.len()).to_string()\n+                line.slice(i + 1, line.len()).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -228,7 +227,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n     let s1 = match all_whitespace(s.as_slice(), col) {\n         Some(col) => {\n             if col < len {\n-                s.as_slice().slice(col, len).to_string()\n+                s.slice(col, len).to_string()\n             } else {\n                 \"\".to_string()\n             }\n@@ -265,7 +264,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         if is_block_doc_comment(curr_line.as_slice()) {\n             return\n         }\n-        assert!(!curr_line.as_slice().contains_char('\\n'));\n+        assert!(!curr_line.contains_char('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: int = 1;"}, {"sha": "2a77e3e67915bb92b46fc42d20eced6281db784e", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -265,7 +265,7 @@ impl<'a> StringReader<'a> {\n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `end`.\n     fn with_str_from_to<T>(&self, start: BytePos, end: BytePos, f: |s: &str| -> T) -> T {\n-        f(self.filemap.src.as_slice().slice(\n+        f(self.filemap.src.slice(\n                 self.byte_offset(start).to_uint(),\n                 self.byte_offset(end).to_uint()))\n     }\n@@ -321,7 +321,6 @@ impl<'a> StringReader<'a> {\n             let last_char = self.curr.unwrap();\n             let next = self.filemap\n                           .src\n-                          .as_slice()\n                           .char_range_at(current_byte_offset);\n             let byte_offset_diff = next.next - current_byte_offset;\n             self.pos = self.pos + Pos::from_uint(byte_offset_diff);\n@@ -343,7 +342,7 @@ impl<'a> StringReader<'a> {\n     pub fn nextch(&self) -> Option<char> {\n         let offset = self.byte_offset(self.pos).to_uint();\n         if offset < self.filemap.src.len() {\n-            Some(self.filemap.src.as_slice().char_at(offset))\n+            Some(self.filemap.src.char_at(offset))\n         } else {\n             None\n         }"}, {"sha": "40303cdffe3f111b95200fbb7c2d7718acb3580c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f44c0c20977bc0ff5562d8bca27b11248abbd4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=39f44c0c20977bc0ff5562d8bca27b11248abbd4", "patch": "@@ -2844,7 +2844,7 @@ impl<'a> State<'a> {\n             comments::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let is_semi = match self.s.last_token() {\n-                    pp::String(s, _) => \";\" == s.as_slice(),\n+                    pp::String(s, _) => \";\" == s,\n                     _ => false\n                 };\n                 if is_semi || self.is_begin() || self.is_end() {"}]}