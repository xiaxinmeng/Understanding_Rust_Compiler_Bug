{"sha": "685ad70647c867944128f6c6bacf9483995eff71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NWFkNzA2NDdjODY3OTQ0MTI4ZjZjNmJhY2Y5NDgzOTk1ZWZmNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-06T08:41:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-06T08:41:11Z"}, "message": "Auto merge of #1757 - RalfJung:rustdoc, r=RalfJung\n\nadd rustdoc support\n\n`@teryror` did all the work in https://github.com/rust-lang/miri/pull/1671; I just finished things up and fixed conflicts. Also thanks to `@hyd-dev` for preemptively fixing a sysroot issue that would have taken me some time to diagnose.\n\nFixes https://github.com/rust-lang/miri/issues/584", "tree": {"sha": "c3eb5caa27994a84ecb5772a5056f2d4fcc4184a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3eb5caa27994a84ecb5772a5056f2d4fcc4184a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/685ad70647c867944128f6c6bacf9483995eff71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/685ad70647c867944128f6c6bacf9483995eff71", "html_url": "https://github.com/rust-lang/rust/commit/685ad70647c867944128f6c6bacf9483995eff71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/685ad70647c867944128f6c6bacf9483995eff71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28f813f4d3de8204a444eccb0797b7a31aca113e", "url": "https://api.github.com/repos/rust-lang/rust/commits/28f813f4d3de8204a444eccb0797b7a31aca113e", "html_url": "https://github.com/rust-lang/rust/commit/28f813f4d3de8204a444eccb0797b7a31aca113e"}, {"sha": "2f6dff6da81e4bf351f82c648b79fbfddd175b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f6dff6da81e4bf351f82c648b79fbfddd175b3e", "html_url": "https://github.com/rust-lang/rust/commit/2f6dff6da81e4bf351f82c648b79fbfddd175b3e"}], "stats": {"total": 297, "additions": 252, "deletions": 45}, "files": [{"sha": "8a80a57e2d9fcca1fdee56b6542a34327658736b", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -290,6 +290,10 @@ different Miri binaries, and as such worth documenting:\n   that the compiled `rlib`s are compatible with Miri.\n   When set while running `cargo-miri`, it indicates that we are part of a sysroot\n   build (for which some crates need special treatment).\n+* `MIRI_CALLED_FROM_RUSTDOC` when set to any value tells `cargo-miri` that it is\n+  running as a child process of `rustdoc`, which invokes it twice for each doc-test\n+  and requires special treatment, most notably a check-only build before interpretation.\n+  This is set by `cargo-miri` itself when running as a `rustdoc`-wrapper.\n * `MIRI_CWD` when set to any value tells the Miri driver to change to the given\n   directory after loading all the source files, but before commencing\n   interpretation. This is useful if the interpreted program wants a different"}, {"sha": "b70d95c604028733282cafad6484f136d72f5363", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 193, "deletions": 35, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -1,8 +1,8 @@\n use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n-use std::io::{self, BufRead, BufReader, BufWriter, Write};\n use std::iter::TakeWhile;\n+use std::io::{self, BufRead, BufReader, BufWriter, Read, Write};\n use std::ops::Not;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n@@ -46,6 +46,24 @@ struct CrateRunEnv {\n     env: Vec<(OsString, OsString)>,\n     /// The current working directory.\n     current_dir: OsString,\n+    /// The contents passed via standard input.\n+    stdin: Vec<u8>,\n+}\n+\n+impl CrateRunEnv {\n+    /// Gather all the information we need.\n+    fn collect(args: env::Args, capture_stdin: bool) -> Self {\n+        let args = args.collect();\n+        let env = env::vars_os().collect();\n+        let current_dir = env::current_dir().unwrap().into_os_string();\n+\n+        let mut stdin = Vec::new();\n+        if capture_stdin {\n+            std::io::stdin().lock().read_to_end(&mut stdin).expect(\"cannot read stdin\");\n+        }\n+\n+        CrateRunEnv { args, env, current_dir, stdin }\n+    }\n }\n \n /// The information Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n@@ -58,14 +76,6 @@ enum CrateRunInfo {\n }\n \n impl CrateRunInfo {\n-    /// Gather all the information we need.\n-    fn collect(args: env::Args) -> Self {\n-        let args = args.collect();\n-        let env = env::vars_os().collect();\n-        let current_dir = env::current_dir().unwrap().into_os_string();\n-        Self::RunWith(CrateRunEnv { args, env, current_dir })\n-    }\n-\n     fn store(&self, filename: &Path) {\n         let file = File::create(filename)\n             .unwrap_or_else(|_| show_error(format!(\"cannot create `{}`\", filename.display())));\n@@ -155,6 +165,13 @@ fn forward_patched_extern_arg(args: &mut impl Iterator<Item = String>, cmd: &mut\n     }\n }\n \n+fn forward_miri_sysroot(cmd: &mut Command) {\n+    let sysroot =\n+        env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n+    cmd.arg(\"--sysroot\");\n+    cmd.arg(sysroot);\n+}\n+\n /// Returns the path to the `miri` binary\n fn find_miri() -> PathBuf {\n     if let Some(path) = env::var_os(\"MIRI\") {\n@@ -190,6 +207,22 @@ fn exec(mut cmd: Command) {\n     }\n }\n \n+/// Execute the command and pipe `input` into its stdin.\n+/// If it fails, fail this process with the same exit code.\n+/// Otherwise, continue.\n+fn exec_with_pipe(mut cmd: Command, input: &[u8]) {\n+    cmd.stdin(std::process::Stdio::piped());\n+    let mut child = cmd.spawn().expect(\"failed to spawn process\");\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"failed to open stdin\");\n+        stdin.write_all(input).expect(\"failed to write out test source\");\n+    }\n+    let exit_status = child.wait().expect(\"failed to run command\");\n+    if exit_status.success().not() {\n+        std::process::exit(exit_status.code().unwrap_or(-1))\n+    }\n+}\n+\n fn xargo_version() -> Option<(u32, u32, u32)> {\n     let out = xargo_check().arg(\"--version\").output().ok()?;\n     if !out.status.success() {\n@@ -548,7 +581,7 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // us in order to skip them.\n     cmd.env(&host_runner_env_name, &cargo_miri_path);\n \n-    // Set rustdoc to us as well, so we can make it do nothing (see issue #584).\n+    // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n     // Run cargo.\n@@ -591,17 +624,22 @@ fn phase_cargo_rustc(mut args: env::Args) {\n     }\n \n     fn out_filename(prefix: &str, suffix: &str) -> PathBuf {\n-        let mut path = PathBuf::from(get_arg_flag_value(\"--out-dir\").unwrap());\n-        path.push(format!(\n-            \"{}{}{}{}\",\n-            prefix,\n-            get_arg_flag_value(\"--crate-name\").unwrap(),\n-            // This is technically a `-C` flag but the prefix seems unique enough...\n-            // (and cargo passes this before the filename so it should be unique)\n-            get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n-            suffix,\n-        ));\n-        path\n+        if let Some(out_dir) = get_arg_flag_value(\"--out-dir\") {\n+            let mut path = PathBuf::from(out_dir);\n+            path.push(format!(\n+                \"{}{}{}{}\",\n+                prefix,\n+                get_arg_flag_value(\"--crate-name\").unwrap(),\n+                // This is technically a `-C` flag but the prefix seems unique enough...\n+                // (and cargo passes this before the filename so it should be unique)\n+                get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n+                suffix,\n+            ));\n+            path\n+        } else {\n+            let out_file = get_arg_flag_value(\"-o\").unwrap();\n+            PathBuf::from(out_file)\n+        }\n     }\n \n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n@@ -631,12 +669,43 @@ fn phase_cargo_rustc(mut args: env::Args) {\n     let runnable_crate = !print && is_runnable_crate();\n \n     if runnable_crate && target_crate {\n+        let inside_rustdoc = env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some();\n         // This is the binary or test crate that we want to interpret under Miri.\n         // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n         // like we want them.\n         // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n         // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n-        store_json(CrateRunInfo::collect(args));\n+        let env = CrateRunEnv::collect(args, inside_rustdoc);\n+\n+        // Rustdoc expects us to exit with an error code if the test is marked as `compile_fail`,\n+        // just creating the JSON file is not enough: we need to detect syntax errors,\n+        // so we need to run Miri with `MIRI_BE_RUSTC` for a check-only build.\n+        if inside_rustdoc {\n+            let mut cmd = miri();\n+\n+            // Ensure --emit argument for a check-only build is present.\n+            // We cannot use the usual helpers since we need to check specifically in `env.args`.\n+            if let Some(i) = env.args.iter().position(|arg| arg.starts_with(\"--emit=\")) {\n+                // For `no_run` tests, rustdoc passes a `--emit` flag; make sure it has the right shape.\n+                assert_eq!(env.args[i], \"--emit=metadata\");\n+            } else {\n+                // For all other kinds of tests, we can just add our flag.\n+                cmd.arg(\"--emit=metadata\");\n+            }\n+\n+            cmd.args(&env.args);\n+            cmd.env(\"MIRI_BE_RUSTC\", \"1\");\n+\n+            if verbose {\n+                eprintln!(\"[cargo-miri rustc] captured input:\\n{}\", std::str::from_utf8(&env.stdin).unwrap());\n+                eprintln!(\"[cargo-miri rustc] {:?}\", cmd);\n+            }\n+\n+            exec_with_pipe(cmd, &env.stdin);\n+        }\n+\n+        store_json(CrateRunInfo::RunWith(env));\n+\n         return;\n     }\n \n@@ -681,10 +750,7 @@ fn phase_cargo_rustc(mut args: env::Args) {\n         }\n \n         // Use our custom sysroot.\n-        let sysroot =\n-            env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n-        cmd.arg(\"--sysroot\");\n-        cmd.arg(sysroot);\n+        forward_miri_sysroot(&mut cmd);\n     } else {\n         // For host crates or when we are printing, just forward everything.\n         cmd.args(args);\n@@ -772,11 +838,10 @@ fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n             cmd.arg(arg);\n         }\n     }\n-    // Set sysroot.\n-    let sysroot =\n-        env::var_os(\"MIRI_SYSROOT\").expect(\"the wrapper should have set MIRI_SYSROOT\");\n-    cmd.arg(\"--sysroot\");\n-    cmd.arg(sysroot);\n+    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_none() {\n+        // Set sysroot (if we are inside rustdoc, we already did that in `phase_cargo_rustdoc`).\n+        forward_miri_sysroot(&mut cmd);\n+    }\n     // Respect `MIRIFLAGS`.\n     if let Ok(a) = env::var(\"MIRIFLAGS\") {\n         // This code is taken from `RUSTFLAGS` handling in cargo.\n@@ -801,6 +866,77 @@ fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n     if verbose {\n         eprintln!(\"[cargo-miri runner] {:?}\", cmd);\n     }\n+\n+    if std::env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n+        exec_with_pipe(cmd, &info.stdin)\n+    } else {\n+        exec(cmd)\n+    }\n+}\n+\n+fn phase_cargo_rustdoc(fst_arg: &str, mut args: env::Args) {\n+    let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n+\n+    // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n+    // just default to a straight-forward invocation for now:\n+    let mut cmd = Command::new(\"rustdoc\");\n+\n+    // Because of the way the main function is structured, we have to take the first argument spearately\n+    // from the rest; to simplify the following argument patching loop, we'll just skip that one.\n+    // This is fine for now, because cargo will never pass --extern arguments in the first position,\n+    // but we should defensively assert that this will work.\n+    let extern_flag = \"--extern\";\n+    assert!(fst_arg != extern_flag);\n+    cmd.arg(fst_arg);\n+\n+    let runtool_flag = \"--runtool\";\n+    // `crossmode` records if *any* argument matches `runtool_flag`; here we check the first one.\n+    let mut crossmode = fst_arg == runtool_flag;\n+    while let Some(arg) = args.next() {\n+        if arg == extern_flag {\n+            // Patch --extern arguments to use *.rmeta files, since phase_cargo_rustc only creates stub *.rlib files.\n+            forward_patched_extern_arg(&mut args, &mut cmd);\n+        } else if arg == runtool_flag {\n+            // An existing --runtool flag indicates cargo is running in cross-target mode, which we don't support.\n+            // Note that this is only passed when cargo is run with the unstable -Zdoctest-xcompile flag;\n+            // otherwise, we won't be called as rustdoc at all.\n+            crossmode = true;\n+            break;\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+\n+    if crossmode {\n+        show_error(format!(\"cross-interpreting doc-tests is not currently supported by Miri.\"));\n+    }\n+\n+    // For each doc-test, rustdoc starts two child processes: first the test is compiled,\n+    // then the produced executable is invoked. We want to reroute both of these to cargo-miri,\n+    // such that the first time we'll enter phase_cargo_rustc, and phase_cargo_runner second.\n+    //\n+    // rustdoc invokes the test-builder by forwarding most of its own arguments, which makes\n+    // it difficult to determine when phase_cargo_rustc should run instead of phase_cargo_rustdoc.\n+    // Furthermore, the test code is passed via stdin, rather than a temporary file, so we need\n+    // to let phase_cargo_rustc know to expect that. We'll use this environment variable as a flag:\n+    cmd.env(\"MIRI_CALLED_FROM_RUSTDOC\", \"1\");\n+\n+    // The `--test-builder` and `--runtool` arguments are unstable rustdoc features,\n+    // which are disabled by default. We first need to enable them explicitly:\n+    cmd.arg(\"-Z\").arg(\"unstable-options\");\n+\n+    // rustdoc needs to know the right sysroot.\n+    forward_miri_sysroot(&mut cmd);\n+\n+    // Make rustdoc call us back.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    cmd.arg(\"--test-builder\").arg(&cargo_miri_path); // invoked by forwarding most arguments\n+    cmd.arg(\"--runtool\").arg(&cargo_miri_path); // invoked with just a single path argument\n+\n+    if verbose {\n+        eprintln!(\"[cargo-miri rustdoc] {:?}\", cmd);\n+    }\n+\n     exec(cmd)\n }\n \n@@ -817,6 +953,29 @@ fn main() {\n         return;\n     }\n \n+    // The way rustdoc invokes rustc is indistuingishable from the way cargo invokes rustdoc by the\n+    // arguments alone. `phase_cargo_rustdoc` sets this environment variable to let us disambiguate.\n+    let invoked_by_rustdoc = env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some();\n+    if invoked_by_rustdoc {\n+        // ...however, we then also see this variable when rustdoc invokes us as the testrunner!\n+        // The runner is invoked as `$runtool ($runtool-arg)* output_file`;\n+        // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n+        // the test-builder unconditionally, we can just check the number of remaining arguments:\n+        if args.len() == 1 {\n+            let arg = args.next().unwrap();\n+            let binary = Path::new(&arg);\n+            if binary.exists() {\n+                phase_cargo_runner(binary, args);\n+            } else {\n+                show_error(format!(\"`cargo-miri` called with non-existing path argument `{}` in rustdoc mode; please invoke this binary through `cargo miri`\", arg));\n+            }\n+        } else {\n+            phase_cargo_rustc(args);\n+        }\n+\n+        return;\n+    }\n+\n     // Dispatch to `cargo-miri` phase. There are three phases:\n     // - When we are called via `cargo miri`, we run as the frontend and invoke the underlying\n     //   cargo. We set RUSTC_WRAPPER and CARGO_TARGET_RUNNER to ourselves.\n@@ -829,16 +988,15 @@ fn main() {\n         Some(\"miri\") => phase_cargo_miri(args),\n         Some(\"rustc\") => phase_cargo_rustc(args),\n         Some(arg) => {\n-            // We have to distinguish the \"runner\" and \"rustfmt\" cases.\n+            // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n             // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n-            // as rustfmt, the first argument is a flag (`--something`).\n+            // as rustdoc, the first argument is a flag (`--something`).\n             let binary = Path::new(arg);\n             if binary.exists() {\n                 assert!(!arg.starts_with(\"--\")); // not a flag\n                 phase_cargo_runner(binary, args);\n             } else if arg.starts_with(\"--\") {\n-                // We are rustdoc.\n-                eprintln!(\"Running doctests is not currently supported by Miri.\")\n+                phase_cargo_rustdoc(arg, args);\n             } else {\n                 show_error(format!(\"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\", arg));\n             }"}, {"sha": "9185c2507b6fc275aeb74aaa3599e805faa63437", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -5,7 +5,7 @@\n and the working directory to contain the cargo-miri-test project.\n '''\n \n-import sys, subprocess, os\n+import sys, subprocess, os, re\n \n CGREEN  = '\\33[32m'\n CBOLD   = '\\33[1m'\n@@ -23,6 +23,10 @@ def cargo_miri(cmd, quiet = True):\n         args += [\"--target\", os.environ['MIRI_TEST_TARGET']]\n     return args\n \n+def normalize_stdout(str):\n+    str = str.replace(\"src\\\\\", \"src/\") # normalize paths across platforms\n+    return re.sub(\"finished in \\d+\\.\\d\\ds\", \"finished in $TIME\", str)\n+\n def test(name, cmd, stdout_ref, stderr_ref, stdin=b'', env={}):\n     print(\"Testing {}...\".format(name))\n     ## Call `cargo miri`, capture all output\n@@ -38,7 +42,7 @@ def test(name, cmd, stdout_ref, stderr_ref, stdin=b'', env={}):\n     (stdout, stderr) = p.communicate(input=stdin)\n     stdout = stdout.decode(\"UTF-8\")\n     stderr = stderr.decode(\"UTF-8\")\n-    if p.returncode == 0 and stdout == open(stdout_ref).read() and stderr == open(stderr_ref).read():\n+    if p.returncode == 0 and normalize_stdout(stdout) == open(stdout_ref).read() and stderr == open(stderr_ref).read():\n         # All good!\n         return\n     # Show output\n@@ -101,26 +105,27 @@ def test_cargo_miri_run():\n def test_cargo_miri_test():\n     # rustdoc is not run on foreign targets\n     is_foreign = 'MIRI_TEST_TARGET' in os.environ\n-    rustdoc_ref = \"test.stderr-empty.ref\" if is_foreign else \"test.stderr-rustdoc.ref\"\n+    default_ref = \"test.cross-target.stdout.ref\" if is_foreign else \"test.default.stdout.ref\"\n+    filter_ref = \"test.filter.cross-target.stdout.ref\" if is_foreign else \"test.filter.stdout.ref\"\n \n     test(\"`cargo miri test`\",\n         cargo_miri(\"test\"),\n-        \"test.default.stdout.ref\", rustdoc_ref,\n+        default_ref, \"test.stderr-empty.ref\",\n         env={'MIRIFLAGS': \"-Zmiri-seed=feed\"},\n     )\n-    test(\"`cargo miri test` (no isolation)\",\n-        cargo_miri(\"test\"),\n-        \"test.default.stdout.ref\", rustdoc_ref,\n+    test(\"`cargo miri test` (no isolation, no doctests)\",\n+        cargo_miri(\"test\") + [\"--bins\", \"--tests\"], # no `--lib`, we disabled that in `Cargo.toml`\n+        \"test.cross-target.stdout.ref\", \"test.stderr-empty.ref\",\n         env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n     test(\"`cargo miri test` (raw-ptr tracking)\",\n         cargo_miri(\"test\"),\n-        \"test.default.stdout.ref\", rustdoc_ref,\n+        default_ref, \"test.stderr-empty.ref\",\n         env={'MIRIFLAGS': \"-Zmiri-track-raw-pointers\"},\n     )\n     test(\"`cargo miri test` (with filter)\",\n         cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"le1\"],\n-        \"test.filter.stdout.ref\", rustdoc_ref,\n+        filter_ref, \"test.stderr-empty.ref\",\n     )\n     test(\"`cargo miri test` (test target)\",\n         cargo_miri(\"test\") + [\"--test\", \"test\", \"--\", \"--format=pretty\"],\n@@ -138,6 +143,7 @@ def test_cargo_miri_test():\n \n os.chdir(os.path.dirname(os.path.realpath(__file__)))\n os.environ[\"RUST_TEST_NOCAPTURE\"] = \"0\" # this affects test output, so make sure it is not set\n+os.environ[\"RUST_TEST_THREADS\"] = \"1\" # avoid non-deterministic output due to concurrent test runs\n \n target_str = \" for target {}\".format(os.environ['MIRI_TEST_TARGET']) if 'MIRI_TEST_TARGET' in os.environ else \"\"\n print(CGREEN + CBOLD + \"## Running `cargo miri` tests{}\".format(target_str) + CEND)"}, {"sha": "0c268a18f63c430e01e7d4747696724a07793acc", "filename": "test-cargo-miri/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Fsrc%2Flib.rs?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -2,6 +2,12 @@\n /// ```rust\n /// assert!(cargo_miri_test::make_true());\n /// ```\n+/// ```rust,no_run\n+/// assert!(cargo_miri_test::make_true());\n+/// ```\n+/// ```rust,compile_fail\n+/// assert!(cargo_miri_test::make_true() == 5);\n+/// ```\n pub fn make_true() -> bool {\n     issue_1567::use_the_dependency();\n     issue_1705::use_the_dependency();"}, {"sha": "7079798e42febd9b127bf9261df839d4ac4e5219", "filename": "test-cargo-miri/test.cross-target.stdout.ref", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.cross-target.stdout.ref?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -0,0 +1,10 @@\n+\n+running 1 test\n+.\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+\n+\n+running 7 tests\n+..i....\n+test result: ok. 6 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "6e35c374e192023de62d0edd162bfa85b9fa66a3", "filename": "test-cargo-miri/test.default.stdout.ref", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.default.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.default.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.default.stdout.ref?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -8,3 +8,11 @@ running 7 tests\n ..i....\n test result: ok. 6 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n \n+\n+running 3 tests\n+test src/lib.rs - make_true (line 2) ... ok\n+test src/lib.rs - make_true (line 5) ... ok\n+test src/lib.rs - make_true (line 8) ... ok\n+\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}, {"sha": "37efb8c3ee896f6c871fb56bcf00227ac6782f93", "filename": "test-cargo-miri/test.filter.cross-target.stdout.ref", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.filter.cross-target.stdout.ref?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -0,0 +1,11 @@\n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out\n+\n+\n+running 1 test\n+test simple1 ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 6 filtered out\n+"}, {"sha": "11e47e8ff81652861f2a7efca84acabbb8fb2f07", "filename": "test-cargo-miri/test.filter.stdout.ref", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.filter.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/685ad70647c867944128f6c6bacf9483995eff71/test-cargo-miri%2Ftest.filter.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.filter.stdout.ref?ref=685ad70647c867944128f6c6bacf9483995eff71", "patch": "@@ -9,3 +9,8 @@ test simple1 ... ok\n \n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 6 filtered out\n \n+\n+running 0 tests\n+\n+test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 3 filtered out; finished in $TIME\n+"}, {"sha": "a310169e305ee1828c2d5ae38ae37987cdb308fd", "filename": "test-cargo-miri/test.stderr-rustdoc.ref", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28f813f4d3de8204a444eccb0797b7a31aca113e/test-cargo-miri%2Ftest.stderr-rustdoc.ref", "raw_url": "https://github.com/rust-lang/rust/raw/28f813f4d3de8204a444eccb0797b7a31aca113e/test-cargo-miri%2Ftest.stderr-rustdoc.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stderr-rustdoc.ref?ref=28f813f4d3de8204a444eccb0797b7a31aca113e", "patch": "@@ -1 +0,0 @@\n-Running doctests is not currently supported by Miri."}]}