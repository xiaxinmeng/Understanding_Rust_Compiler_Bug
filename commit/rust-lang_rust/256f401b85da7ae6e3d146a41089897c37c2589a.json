{"sha": "256f401b85da7ae6e3d146a41089897c37c2589a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NmY0MDFiODVkYTdhZTZlM2QxNDZhNDEwODk4OTdjMzdjMjU4OWE=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-08T15:29:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-08T15:29:09Z"}, "message": "Rollup merge of #67798 - matklad:spin-thouse-docs, r=Amanieu\n\nRemove wrong advice about spin locks from `spin_loop_hint` docs\n\nUsing a pure spin lock for a critical section in a preemptable thread\nis always wrong, however short the critical section may be. The thread\nmight be preempted, which will cause all other threads to hammer\nbusily at the core for the whole quant. Moreover, if threads have\ndifferent priorities, this might lead to a priority inversion problem\nand a deadlock. More generally, a spinlock is not more efficient than\na well-written mutex, which typically does several spin iterations at\nthe start anyway.\n\nThe advise about UP vs SMP is also irrelevant in the context of\npreemptive threads.\n\nSee also accompanying piece: https://matklad.github.io/2020/01/02/spinlocs-considered-harmful.html\n\nAnd another, independent piece: https://probablydance.com/2019/12/30/measuring-mutexes-spinlocks-and-how-bad-the-linux-scheduler-really-is\n\nEDIT: obligatory disclosure that I am not an expert in these things, and might be terribly wrong :)", "tree": {"sha": "bb11420c7c9c655c1ab8b8f0aa6514e1f3af7d91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb11420c7c9c655c1ab8b8f0aa6514e1f3af7d91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/256f401b85da7ae6e3d146a41089897c37c2589a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeFfVGCRBK7hj4Ov3rIwAAdHIIAHJBsiwTxAc6q7JFY3eiFI6t\ni3HfAdBinaCFRWgOlkkfrWv30Lsw4ugNWkyLwBJpom2QazvJkSAcPVjubR8KqRoe\no86j+RupP5P5YovfoL41d7l65LPV24vQp0/NdyPD2wiHq/xgTuHQDZm+xfiTkIol\nhvKyM52y9BxumsmgfhfTaUA8jrEONG/VgwFffbNrOMcCqZzhLLDtzWOUBQ+alkCL\nRjDz25xSUkkPKtSwYTk2qo2m860cPq9rvcugNAxkTWPEYcVgD4IMmNj9/K/fzyQy\nzPb8b0T4kQYNCBgcGdu061pbvh17z2XXw15i6GuJ2B2ZxKSRCd2w0IP06/G1jjg=\n=YUBG\n-----END PGP SIGNATURE-----\n", "payload": "tree bb11420c7c9c655c1ab8b8f0aa6514e1f3af7d91\nparent b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b\nparent b25eeef88d55a412c0e0bec7c0989d5a7969f195\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1578497349 +0900\ncommitter GitHub <noreply@github.com> 1578497349 +0900\n\nRollup merge of #67798 - matklad:spin-thouse-docs, r=Amanieu\n\nRemove wrong advice about spin locks from `spin_loop_hint` docs\n\nUsing a pure spin lock for a critical section in a preemptable thread\nis always wrong, however short the critical section may be. The thread\nmight be preempted, which will cause all other threads to hammer\nbusily at the core for the whole quant. Moreover, if threads have\ndifferent priorities, this might lead to a priority inversion problem\nand a deadlock. More generally, a spinlock is not more efficient than\na well-written mutex, which typically does several spin iterations at\nthe start anyway.\n\nThe advise about UP vs SMP is also irrelevant in the context of\npreemptive threads.\n\nSee also accompanying piece: https://matklad.github.io/2020/01/02/spinlocs-considered-harmful.html\n\nAnd another, independent piece: https://probablydance.com/2019/12/30/measuring-mutexes-spinlocks-and-how-bad-the-linux-scheduler-really-is\n\nEDIT: obligatory disclosure that I am not an expert in these things, and might be terribly wrong :)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/256f401b85da7ae6e3d146a41089897c37c2589a", "html_url": "https://github.com/rust-lang/rust/commit/256f401b85da7ae6e3d146a41089897c37c2589a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/256f401b85da7ae6e3d146a41089897c37c2589a/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b", "html_url": "https://github.com/rust-lang/rust/commit/b85b1dd465e32dfdfe6a61d9ebffb1c5e50ac40b"}, {"sha": "b25eeef88d55a412c0e0bec7c0989d5a7969f195", "url": "https://api.github.com/repos/rust-lang/rust/commits/b25eeef88d55a412c0e0bec7c0989d5a7969f195", "html_url": "https://github.com/rust-lang/rust/commit/b25eeef88d55a412c0e0bec7c0989d5a7969f195"}], "stats": {"total": 14, "additions": 4, "deletions": 10}, "files": [{"sha": "fae95ca5cdb36ba4182343e308d7c53f05bf810d", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/256f401b85da7ae6e3d146a41089897c37c2589a/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/256f401b85da7ae6e3d146a41089897c37c2589a/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=256f401b85da7ae6e3d146a41089897c37c2589a", "patch": "@@ -134,16 +134,10 @@ use crate::hint::spin_loop;\n /// This function is different from [`std::thread::yield_now`] which directly yields to the\n /// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Spin locks can be very efficient for short lock durations because they do not involve context\n-/// switches or interaction with the operating system. For long lock durations they become wasteful\n-/// however because they use CPU cycles for the entire lock duration, and using a\n-/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n-/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n-/// or [`std::thread::sleep`] may be the best option.\n-///\n-/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n-/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n-/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n+/// A common use case for `spin_loop_hint` is implementing bounded optimistic spinning in a CAS\n+/// loop in synchronization primitives. To avoid problems like priority inversion, it is strongly\n+/// recommended that the spin loop is terminated after a finite amount of iterations and an\n+/// appropriate blocking syscall is made.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all."}]}