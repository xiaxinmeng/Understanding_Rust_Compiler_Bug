{"sha": "2fa62b91c81b10064bb298befa1f539d1ea28a08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYTYyYjkxYzgxYjEwMDY0YmIyOThiZWZhMWY1MzlkMWVhMjhhMDg=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-04-21T06:33:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-21T06:33:01Z"}, "message": "Merge pull request #98 from rust-lang/feature/common-shuffles\n\nAdd some common shuffles", "tree": {"sha": "4ae5eb71931687280832c3995655068b25e22830", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae5eb71931687280832c3995655068b25e22830"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa62b91c81b10064bb298befa1f539d1ea28a08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgf8cdCRBK7hj4Ov3rIwAAJ0AIACv3KxQjXIQJfpetOgTXZtTw\n5/LOCKcex9uBr13t8dK/F7q8VTFkX/NPpN5oMPcb84cXlRAg0P6lcSm7e91qJUhv\ntWamXbISlrkC9Y436cZNpfnsqc7jmyGD754xMrOazlIpHpxyAgvoFoW7hQvgCNjG\nF0YqwBVEjZH25xlhFGyBb7byIMeDXJk74iE7SHpo2uXNx6ctPNw948guehA974Ab\n37iFCNZYw42ZmI8+KZZAqS08Y39vM9Wx2xG+1/ROYT5SVzyoRI3TafzZMdYvCqge\n6jRCoo1O8xpRWiHJBuwoyBkpq7ZE4iAxALHoMy/6J94HaU+AkFn8NTQS0gsPCVY=\n=xC+F\n-----END PGP SIGNATURE-----\n", "payload": "tree 4ae5eb71931687280832c3995655068b25e22830\nparent b2e25bc8c8ab536e0c5abd8175258cfc63c83a1b\nparent 7028a5829464be5b0087afc7aedfff064b2e545f\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1618986781 -0700\ncommitter GitHub <noreply@github.com> 1618986781 -0700\n\nMerge pull request #98 from rust-lang/feature/common-shuffles\n\nAdd some common shuffles"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa62b91c81b10064bb298befa1f539d1ea28a08", "html_url": "https://github.com/rust-lang/rust/commit/2fa62b91c81b10064bb298befa1f539d1ea28a08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa62b91c81b10064bb298befa1f539d1ea28a08/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2e25bc8c8ab536e0c5abd8175258cfc63c83a1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2e25bc8c8ab536e0c5abd8175258cfc63c83a1b", "html_url": "https://github.com/rust-lang/rust/commit/b2e25bc8c8ab536e0c5abd8175258cfc63c83a1b"}, {"sha": "7028a5829464be5b0087afc7aedfff064b2e545f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7028a5829464be5b0087afc7aedfff064b2e545f", "html_url": "https://github.com/rust-lang/rust/commit/7028a5829464be5b0087afc7aedfff064b2e545f"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "dd63c69c63db7d9e591445f1e8f9e6d43d265cc9", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2fa62b91c81b10064bb298befa1f539d1ea28a08/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa62b91c81b10064bb298befa1f539d1ea28a08/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=2fa62b91c81b10064bb298befa1f539d1ea28a08", "patch": "@@ -13,6 +13,115 @@ macro_rules! impl_shuffle_lane {\n             pub fn shuffle<const IDX: [u32; $n]>(self, second: Self) -> Self {\n                 unsafe { crate::intrinsics::$fn(self, second, IDX) }\n             }\n+\n+            /// Reverse the order of the lanes in the vector.\n+            #[inline]\n+            pub fn reverse(self) -> Self {\n+                const fn idx() -> [u32; $n] {\n+                    let mut idx = [0u32; $n];\n+                    let mut i = 0;\n+                    while i < $n {\n+                        idx[i] = ($n - i - 1) as u32;\n+                        i += 1;\n+                    }\n+                    idx\n+                }\n+                self.shuffle::<{ idx() }>(self)\n+            }\n+\n+            /// Interleave two vectors.\n+            ///\n+            /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+            ///\n+            /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n+            /// alternating, starting with the first lane of `self`.\n+            ///\n+            /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n+            /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+            ///\n+            /// This particular permutation is efficient on many architectures.\n+            ///\n+            /// ```\n+            /// # use core_simd::SimdU32;\n+            /// let a = SimdU32::from_array([0, 1, 2, 3]);\n+            /// let b = SimdU32::from_array([4, 5, 6, 7]);\n+            /// let (x, y) = a.interleave(b);\n+            /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n+            /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n+            /// ```\n+            #[inline]\n+            pub fn interleave(self, other: Self) -> (Self, Self) {\n+                const fn lo() -> [u32; $n] {\n+                    let mut idx = [0u32; $n];\n+                    let mut i = 0;\n+                    while i < $n {\n+                        let offset = i / 2;\n+                        idx[i] = if i % 2 == 0 {\n+                            offset\n+                        } else {\n+                            $n + offset\n+                        } as u32;\n+                        i += 1;\n+                    }\n+                    idx\n+                }\n+                const fn hi() -> [u32; $n] {\n+                    let mut idx = [0u32; $n];\n+                    let mut i = 0;\n+                    while i < $n {\n+                        let offset = ($n + i) / 2;\n+                        idx[i] = if i % 2 == 0 {\n+                            offset\n+                        } else {\n+                            $n + offset\n+                        } as u32;\n+                        i += 1;\n+                    }\n+                    idx\n+                }\n+                (self.shuffle::<{ lo() }>(other), self.shuffle::<{ hi() }>(other))\n+            }\n+\n+            /// Deinterleave two vectors.\n+            ///\n+            /// The first result takes every other lane of `self` and then `other`, starting with\n+            /// the first lane.\n+            ///\n+            /// The second result takes every other lane of `self` and then `other`, starting with\n+            /// the second lane.\n+            ///\n+            /// This particular permutation is efficient on many architectures.\n+            ///\n+            /// ```\n+            /// # use core_simd::SimdU32;\n+            /// let a = SimdU32::from_array([0, 4, 1, 5]);\n+            /// let b = SimdU32::from_array([2, 6, 3, 7]);\n+            /// let (x, y) = a.deinterleave(b);\n+            /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n+            /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n+            /// ```\n+            #[inline]\n+            pub fn deinterleave(self, other: Self) -> (Self, Self) {\n+                const fn even() -> [u32; $n] {\n+                    let mut idx = [0u32; $n];\n+                    let mut i = 0;\n+                    while i < $n {\n+                        idx[i] = 2 * i as u32;\n+                        i += 1;\n+                    }\n+                    idx\n+                }\n+                const fn odd() -> [u32; $n] {\n+                    let mut idx = [0u32; $n];\n+                    let mut i = 0;\n+                    while i < $n {\n+                        idx[i] = 1 + 2 * i as u32;\n+                        i += 1;\n+                    }\n+                    idx\n+                }\n+                (self.shuffle::<{ even() }>(other), self.shuffle::<{ odd() }>(other))\n+            }\n         }\n     }\n }"}, {"sha": "2be43c9cf3cea6457c06ee47696c260786d8275e", "filename": "crates/core_simd/tests/permute.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2fa62b91c81b10064bb298befa1f539d1ea28a08/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa62b91c81b10064bb298befa1f539d1ea28a08/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpermute.rs?ref=2fa62b91c81b10064bb298befa1f539d1ea28a08", "patch": "@@ -13,3 +13,23 @@ fn simple_shuffle() {\n     let b = a;\n     assert_eq!(a.shuffle::<{ [3, 1, 4, 6] }>(b).to_array(), [9, 4, 2, 1]);\n }\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn reverse() {\n+    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    assert_eq!(a.reverse().to_array(), [7, 6, 5, 4, 3, 2, 1, 0]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn interleave() {\n+    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let b = SimdU32::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n+    let (lo, hi) = a.interleave(b);\n+    assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n+    assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);\n+    let (even, odd) = lo.deinterleave(hi);\n+    assert_eq!(even, a);\n+    assert_eq!(odd, b);\n+}"}]}