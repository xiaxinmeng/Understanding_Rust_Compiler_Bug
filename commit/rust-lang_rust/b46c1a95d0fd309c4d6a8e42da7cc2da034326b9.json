{"sha": "b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NmMxYTk1ZDBmZDMwOWM0ZDZhOGU0MmRhN2NjMmRhMDM0MzI2Yjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-12T15:44:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-22T19:37:10Z"}, "message": "move `needs_drop` into a query", "tree": {"sha": "aecbce20b797bc3d8358d3e19f08d52ad776967a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aecbce20b797bc3d8358d3e19f08d52ad776967a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "html_url": "https://github.com/rust-lang/rust/commit/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a5c265e24cc79a8e28f01930380cb8a2481165c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5c265e24cc79a8e28f01930380cb8a2481165c", "html_url": "https://github.com/rust-lang/rust/commit/5a5c265e24cc79a8e28f01930380cb8a2481165c"}], "stats": {"total": 192, "additions": 86, "deletions": 106}, "files": [{"sha": "12a3e5bfaa06ac2a16c4516809f107f20e2a5ee1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "patch": "@@ -111,6 +111,7 @@ pub enum DepNode<D: Clone + Debug> {\n     IsCopy(D),\n     IsSized(D),\n     IsFreeze(D),\n+    NeedsDrop(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -240,6 +241,7 @@ impl<D: Clone + Debug> DepNode<D> {\n             IsCopy(ref d) => op(d).map(IsCopy),\n             IsSized(ref d) => op(d).map(IsSized),\n             IsFreeze(ref d) => op(d).map(IsFreeze),\n+            NeedsDrop(ref d) => op(d).map(NeedsDrop),\n             Hir(ref d) => op(d).map(Hir),\n             HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),"}, {"sha": "5f2bc03ed9ea9c0584c7184ac278616df02586f4", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "patch": "@@ -271,6 +271,12 @@ impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n+    fn describe(_tcx: TyCtxt, env: ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> String {\n+        format!(\"computing whether `{}` needs drop\", env.value)\n+    }\n+}\n+\n impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n@@ -891,6 +897,7 @@ define_maps! { <'tcx>\n     [] is_copy_raw: is_copy_dep_node(ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] is_sized_raw: is_sized_dep_node(ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> bool,\n     [] is_freeze_raw: is_freeze_dep_node(ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> bool,\n+    [] needs_drop_raw: needs_drop_dep_node(ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -949,3 +956,8 @@ fn is_freeze_dep_node<'tcx>(_: ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> D\n     let krate_def_id = DefId::local(CRATE_DEF_INDEX);\n     DepNode::IsSized(krate_def_id)\n }\n+\n+fn needs_drop_dep_node<'tcx>(_: ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>) -> DepNode<DefId> {\n+    let krate_def_id = DefId::local(CRATE_DEF_INDEX);\n+    DepNode::NeedsDrop(krate_def_id)\n+}"}, {"sha": "0c2f4efccd53102b7fe615d1571ed6c9ab535f5a", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 72, "deletions": 106, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46c1a95d0fd309c4d6a8e42da7cc2da034326b9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b46c1a95d0fd309c4d6a8e42da7cc2da034326b9", "patch": "@@ -15,14 +15,13 @@ use hir::map::DefPathData;\n use infer::InferCtxt;\n use ich::{StableHashingContext, NodeIdHashingMode};\n use traits::{self, Reveal};\n-use ty::{self, Ty, TyCtxt, TypeFlags, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::ParameterEnvironment;\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::subst::{Subst, Kind};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n-use util::nodemap::FxHashSet;\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n@@ -754,110 +753,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_env: ty::ParameterEnvironment<'tcx>)\n                       -> bool {\n-        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n-        }\n-\n-        self.needs_drop_uncached(tcx, param_env, &mut FxHashSet())\n-    }\n-\n-    fn needs_drop_inner(&'tcx self,\n-                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                        param_env: ty::ParameterEnvironment<'tcx>,\n-                        stack: &mut FxHashSet<Ty<'tcx>>)\n-                        -> bool {\n-        if self.flags.get().intersects(TypeFlags::NEEDS_DROP_CACHED) {\n-            return self.flags.get().intersects(TypeFlags::NEEDS_DROP);\n-        }\n-\n-        // This should be reported as an error by `check_representable`.\n-        //\n-        // Consider the type as not needing drop in the meanwhile to avoid\n-        // further errors.\n-        if let Some(_) = stack.replace(self) {\n-            return false;\n-        }\n-\n-        let needs_drop = self.needs_drop_uncached(tcx, param_env, stack);\n-\n-        // \"Pop\" the cycle detection \"stack\".\n-        stack.remove(self);\n-\n-        needs_drop\n-    }\n-\n-    fn needs_drop_uncached(&'tcx self,\n-                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           param_env: ty::ParameterEnvironment<'tcx>,\n-                           stack: &mut FxHashSet<Ty<'tcx>>)\n-                           -> bool {\n-        assert!(!self.needs_infer());\n-\n-        let result = match self.sty {\n-            // Fast-path for primitive types\n-            ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-            ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n-\n-            // Issue #22536: We first query type_moves_by_default.  It sees a\n-            // normalized version of the type, and therefore will definitely\n-            // know whether the type implements Copy (and thus needs no\n-            // cleanup/drop/zeroing) ...\n-            _ if !self.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n-\n-            // ... (issue #22536 continued) but as an optimization, still use\n-            // prior logic of asking for the structural \"may drop\".\n-\n-            // FIXME(#22815): Note that this is a conservative heuristic;\n-            // it may report that the type \"may drop\" when actual type does\n-            // not actually have a destructor associated with it. But since\n-            // the type absolutely did not have the `Copy` bound attached\n-            // (see above), it is sound to treat it as having a destructor.\n-\n-            // User destructors are the only way to have concrete drop types.\n-            ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n-\n-            // Can refer to a type which may drop.\n-            // FIXME(eddyb) check this against a ParameterEnvironment.\n-            ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n-            ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n-\n-            // Structural recursion.\n-            ty::TyArray(ty, _) | ty::TySlice(ty) => {\n-                ty.needs_drop_inner(tcx, param_env, stack)\n-            }\n-\n-            ty::TyClosure(def_id, ref substs) => {\n-                substs.upvar_tys(def_id, tcx)\n-                    .any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n-            }\n-\n-            ty::TyTuple(ref tys, _) => {\n-                tys.iter().any(|ty| ty.needs_drop_inner(tcx, param_env, stack))\n-            }\n-\n-            // unions don't have destructors regardless of the child types\n-            ty::TyAdt(def, _) if def.is_union() => false,\n-\n-            ty::TyAdt(def, substs) => {\n-                def.variants.iter().any(|v| {\n-                    v.fields.iter().any(|f| {\n-                        f.ty(tcx, substs).needs_drop_inner(tcx, param_env, stack)\n-                    })\n-                })\n-            }\n-        };\n-\n-        if !self.has_param_types() && !self.has_self_ty() {\n-            self.flags.set(self.flags.get() | if result {\n-                TypeFlags::NEEDS_DROP_CACHED | TypeFlags::NEEDS_DROP\n-            } else {\n-                TypeFlags::NEEDS_DROP_CACHED\n-            });\n-        }\n-\n-        result\n+        tcx.needs_drop_raw(param_env.and(self))\n     }\n \n     #[inline]\n@@ -1075,11 +971,81 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx, ty, trait_def_id, DUMMY_SP))\n }\n \n+fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            query: ty::ParameterEnvironmentAnd<'tcx, Ty<'tcx>>)\n+                            -> bool\n+{\n+    let (param_env, ty) = query.into_parts();\n+\n+    let needs_drop = |ty: Ty<'tcx>| -> bool {\n+        match ty::queries::needs_drop_raw::try_get(tcx, DUMMY_SP, param_env.and(ty)) {\n+            Ok(v) => v,\n+            Err(_) => {\n+                // Cycles should be reported as an error by `check_representable`.\n+                //\n+                // Consider the type as not needing drop in the meanwhile to avoid\n+                // further errors.\n+                false\n+            }\n+        }\n+    };\n+\n+    assert!(!ty.needs_infer());\n+\n+    match ty.sty {\n+        // Fast-path for primitive types\n+        ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n+        ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+        ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+\n+        // Issue #22536: We first query type_moves_by_default.  It sees a\n+        // normalized version of the type, and therefore will definitely\n+        // know whether the type implements Copy (and thus needs no\n+        // cleanup/drop/zeroing) ...\n+        _ if !ty.moves_by_default(tcx, param_env, DUMMY_SP) => false,\n+\n+        // ... (issue #22536 continued) but as an optimization, still use\n+        // prior logic of asking for the structural \"may drop\".\n+\n+        // FIXME(#22815): Note that this is a conservative heuristic;\n+        // it may report that the type \"may drop\" when actual type does\n+        // not actually have a destructor associated with it. But since\n+        // the type absolutely did not have the `Copy` bound attached\n+        // (see above), it is sound to treat it as having a destructor.\n+\n+        // User destructors are the only way to have concrete drop types.\n+        ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+\n+        // Can refer to a type which may drop.\n+        // FIXME(eddyb) check this against a ParameterEnvironment.\n+        ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n+        ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+\n+        // Structural recursion.\n+        ty::TyArray(ty, _) | ty::TySlice(ty) => needs_drop(ty),\n+\n+        ty::TyClosure(def_id, ref substs) => substs.upvar_tys(def_id, tcx).any(needs_drop),\n+\n+        ty::TyTuple(ref tys, _) => tys.iter().cloned().any(needs_drop),\n+\n+        // unions don't have destructors regardless of the child types\n+        ty::TyAdt(def, _) if def.is_union() => false,\n+\n+        ty::TyAdt(def, substs) =>\n+            def.variants.iter().any(\n+                |variant| variant.fields.iter().any(\n+                    |field| needs_drop(field.ty(tcx, substs)))),\n+    }\n+}\n+\n+\n pub fn provide(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         is_copy_raw,\n         is_sized_raw,\n         is_freeze_raw,\n+        needs_drop_raw,\n         ..*providers\n     };\n }"}]}