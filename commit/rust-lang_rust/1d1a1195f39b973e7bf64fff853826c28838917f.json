{"sha": "1d1a1195f39b973e7bf64fff853826c28838917f", "node_id": "C_kwDOAAsO6NoAKDFkMWExMTk1ZjM5Yjk3M2U3YmY2NGZmZjg1MzgyNmMyODgzODkxN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T10:58:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T10:58:46Z"}, "message": "Auto merge of #14880 - Veykril:intern-double, r=Veykril\n\nRemove double lookups from Interned", "tree": {"sha": "941dedd4bfcef8705494207a26e1a417e97ef9eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/941dedd4bfcef8705494207a26e1a417e97ef9eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d1a1195f39b973e7bf64fff853826c28838917f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1a1195f39b973e7bf64fff853826c28838917f", "html_url": "https://github.com/rust-lang/rust/commit/1d1a1195f39b973e7bf64fff853826c28838917f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d1a1195f39b973e7bf64fff853826c28838917f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2120c913c28896ed8e6247906f8884939c268683", "url": "https://api.github.com/repos/rust-lang/rust/commits/2120c913c28896ed8e6247906f8884939c268683", "html_url": "https://github.com/rust-lang/rust/commit/2120c913c28896ed8e6247906f8884939c268683"}, {"sha": "12d4355c60954e5c1b744ea49ca2652f1df16d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d4355c60954e5c1b744ea49ca2652f1df16d9a", "html_url": "https://github.com/rust-lang/rust/commit/12d4355c60954e5c1b744ea49ca2652f1df16d9a"}], "stats": {"total": 91, "additions": 45, "deletions": 46}, "files": [{"sha": "dabbf3a38b502725a6b52ec0e09bbd6d0f0e64e7", "filename": "crates/intern/src/lib.rs", "status": "modified", "additions": 45, "deletions": 46, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1d1a1195f39b973e7bf64fff853826c28838917f/crates%2Fintern%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1a1195f39b973e7bf64fff853826c28838917f/crates%2Fintern%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fintern%2Fsrc%2Flib.rs?ref=1d1a1195f39b973e7bf64fff853826c28838917f", "patch": "@@ -9,7 +9,7 @@ use std::{\n };\n \n use dashmap::{DashMap, SharedValue};\n-use hashbrown::HashMap;\n+use hashbrown::{hash_map::RawEntryMut, HashMap};\n use once_cell::sync::OnceCell;\n use rustc_hash::FxHasher;\n use triomphe::Arc;\n@@ -26,56 +26,58 @@ pub struct Interned<T: Internable + ?Sized> {\n \n impl<T: Internable> Interned<T> {\n     pub fn new(obj: T) -> Self {\n-        match Interned::lookup(&obj) {\n-            Ok(this) => this,\n-            Err(shard) => {\n-                let arc = Arc::new(obj);\n-                Self::alloc(arc, shard)\n-            }\n+        let (mut shard, hash) = Self::select(&obj);\n+        // Atomically,\n+        // - check if `obj` is already in the map\n+        //   - if so, clone its `Arc` and return it\n+        //   - if not, box it up, insert it, and return a clone\n+        // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n+        // insert the same object between us looking it up and inserting it.\n+        match shard.raw_entry_mut().from_key_hashed_nocheck(hash as u64, &obj) {\n+            RawEntryMut::Occupied(occ) => Self { arc: occ.key().clone() },\n+            RawEntryMut::Vacant(vac) => Self {\n+                arc: vac\n+                    .insert_hashed_nocheck(hash as u64, Arc::new(obj), SharedValue::new(()))\n+                    .0\n+                    .clone(),\n+            },\n         }\n     }\n }\n \n-impl<T: Internable + ?Sized> Interned<T> {\n-    fn lookup(obj: &T) -> Result<Self, Guard<T>> {\n-        let storage = T::storage().get();\n-        let shard_idx = storage.determine_map(obj);\n-        let shard = &storage.shards()[shard_idx];\n-        let shard = shard.write();\n-\n+impl Interned<str> {\n+    pub fn new_str(s: &str) -> Self {\n+        let (mut shard, hash) = Self::select(s);\n         // Atomically,\n         // - check if `obj` is already in the map\n         //   - if so, clone its `Arc` and return it\n         //   - if not, box it up, insert it, and return a clone\n         // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n         // insert the same object between us looking it up and inserting it.\n-\n-        // FIXME: avoid double lookup/hashing by using raw entry API (once stable, or when\n-        // hashbrown can be plugged into dashmap)\n-        match shard.get_key_value(obj) {\n-            Some((arc, _)) => Ok(Self { arc: arc.clone() }),\n-            None => Err(shard),\n+        match shard.raw_entry_mut().from_key_hashed_nocheck(hash as u64, s) {\n+            RawEntryMut::Occupied(occ) => Self { arc: occ.key().clone() },\n+            RawEntryMut::Vacant(vac) => Self {\n+                arc: vac\n+                    .insert_hashed_nocheck(hash as u64, Arc::from(s), SharedValue::new(()))\n+                    .0\n+                    .clone(),\n+            },\n         }\n     }\n-\n-    fn alloc(arc: Arc<T>, mut shard: Guard<T>) -> Self {\n-        let arc2 = arc.clone();\n-\n-        shard.insert(arc2, SharedValue::new(()));\n-\n-        Self { arc }\n-    }\n }\n \n-impl Interned<str> {\n-    pub fn new_str(s: &str) -> Self {\n-        match Interned::lookup(s) {\n-            Ok(this) => this,\n-            Err(shard) => {\n-                let arc = Arc::<str>::from(s);\n-                Self::alloc(arc, shard)\n-            }\n-        }\n+impl<T: Internable + ?Sized> Interned<T> {\n+    #[inline]\n+    fn select(obj: &T) -> (Guard<T>, u64) {\n+        let storage = T::storage().get();\n+        let hash = {\n+            let mut hasher = std::hash::BuildHasher::build_hasher(storage.hasher());\n+            obj.hash(&mut hasher);\n+            hasher.finish()\n+        };\n+        let shard_idx = storage.determine_shard(hash as usize);\n+        let shard = &storage.shards()[shard_idx];\n+        (shard.write(), hash)\n     }\n }\n \n@@ -94,20 +96,17 @@ impl<T: Internable + ?Sized> Drop for Interned<T> {\n impl<T: Internable + ?Sized> Interned<T> {\n     #[cold]\n     fn drop_slow(&mut self) {\n-        let storage = T::storage().get();\n-        let shard_idx = storage.determine_map(&self.arc);\n-        let shard = &storage.shards()[shard_idx];\n-        let mut shard = shard.write();\n-\n-        // FIXME: avoid double lookup\n-        let (arc, _) = shard.get_key_value(&self.arc).expect(\"interned value removed prematurely\");\n+        let (mut shard, hash) = Self::select(&self.arc);\n \n-        if Arc::count(arc) != 2 {\n+        if Arc::count(&self.arc) != 2 {\n             // Another thread has interned another copy\n             return;\n         }\n \n-        shard.remove(&self.arc);\n+        match shard.raw_entry_mut().from_key_hashed_nocheck(hash, &self.arc) {\n+            RawEntryMut::Occupied(occ) => occ.remove(),\n+            RawEntryMut::Vacant(_) => unreachable!(),\n+        };\n \n         // Shrink the backing storage if the shard is less than 50% occupied.\n         if shard.len() * 2 < shard.capacity() {"}]}