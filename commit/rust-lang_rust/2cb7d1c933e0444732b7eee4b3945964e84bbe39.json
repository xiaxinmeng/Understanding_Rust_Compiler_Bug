{"sha": "2cb7d1c933e0444732b7eee4b3945964e84bbe39", "node_id": "C_kwDOAAsO6NoAKDJjYjdkMWM5MzNlMDQ0NDczMmI3ZWVlNGIzOTQ1OTY0ZTg0YmJlMzk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-10T22:33:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-10T22:33:47Z"}, "message": "Rollup merge of #98713 - nikomatsakis:issue-98693, r=jackh726\n\npromote placeholder bounds to 'static obligations\n\nIn NLL, when we are promoting a bound out from a closure, if we have a requirement that `T: 'a` where `'a` is in a higher universe, we were previously ignoring that, which is totally wrong. We should be promoting those constraints to `'static`, since universes are not expressible across closure boundaries.\n\nFixes #98693\n\n~~(Marking as WIP because I'm still running tests, haven't add the new test, etc)~~\n\nr? ``@jackh726``", "tree": {"sha": "3d4311e661b7cf81d518903b40ba274ee1918110", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d4311e661b7cf81d518903b40ba274ee1918110"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cb7d1c933e0444732b7eee4b3945964e84bbe39", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiy1PMCRBK7hj4Ov3rIwAAzvMIAF/UpZnQAM0FWdLqH97y95GB\nGvHvslG4/K4N263WdmF7CdS77pwGWR3OdjAUkQvWgjvStaJpgYSVy/HEPuTz5jr8\njH3YKjJQCuthF2FpXwuIP0LfUYCrR3BBFAkP9Q4FpjWQthGu5zyr8KG+gspi4NAP\nEwBVZSXH8WIssW6JhoiFkMy0ryoOIUrgvhTHU27s78rZGK+Vhyg/WAw+tx16c9Ei\nmhes1R3YyvbprmX9qiN5bShO6Y5L94XYguO9WGsVn+XNNyxBesjg8yJn41er6sku\ncojUYs3mSbHaVBvGQTqeaC1RRTmEYqMBXsn9F5J38SgXPTbNOfQeYSHWdR3thXU=\n=kFhI\n-----END PGP SIGNATURE-----\n", "payload": "tree 3d4311e661b7cf81d518903b40ba274ee1918110\nparent c396bb3b8a16b1f2762b7c6078dc3e023f6a2493\nparent 7fda86249fd37e5ff148427771423bfefc0b1e4a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1657492427 +0200\ncommitter GitHub <noreply@github.com> 1657492427 +0200\n\nRollup merge of #98713 - nikomatsakis:issue-98693, r=jackh726\n\npromote placeholder bounds to 'static obligations\n\nIn NLL, when we are promoting a bound out from a closure, if we have a requirement that `T: 'a` where `'a` is in a higher universe, we were previously ignoring that, which is totally wrong. We should be promoting those constraints to `'static`, since universes are not expressible across closure boundaries.\n\nFixes #98693\n\n~~(Marking as WIP because I'm still running tests, haven't add the new test, etc)~~\n\nr? ``@jackh726``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cb7d1c933e0444732b7eee4b3945964e84bbe39", "html_url": "https://github.com/rust-lang/rust/commit/2cb7d1c933e0444732b7eee4b3945964e84bbe39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cb7d1c933e0444732b7eee4b3945964e84bbe39/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c396bb3b8a16b1f2762b7c6078dc3e023f6a2493", "url": "https://api.github.com/repos/rust-lang/rust/commits/c396bb3b8a16b1f2762b7c6078dc3e023f6a2493", "html_url": "https://github.com/rust-lang/rust/commit/c396bb3b8a16b1f2762b7c6078dc3e023f6a2493"}, {"sha": "7fda86249fd37e5ff148427771423bfefc0b1e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fda86249fd37e5ff148427771423bfefc0b1e4a", "html_url": "https://github.com/rust-lang/rust/commit/7fda86249fd37e5ff148427771423bfefc0b1e4a"}], "stats": {"total": 91, "additions": 85, "deletions": 6}, "files": [{"sha": "0cf04b369de5f4a11f2a8bce1c2d215701c5e65b", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2cb7d1c933e0444732b7eee4b3945964e84bbe39/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb7d1c933e0444732b7eee4b3945964e84bbe39/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=2cb7d1c933e0444732b7eee4b3945964e84bbe39", "patch": "@@ -917,6 +917,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// The idea then is to lower the `T: 'X` constraint into multiple\n     /// bounds -- e.g., if `'X` is the union of two free lifetimes,\n     /// `'1` and `'2`, then we would create `T: '1` and `T: '2`.\n+    #[instrument(level = \"debug\", skip(self, infcx, propagated_outlives_requirements))]\n     fn try_promote_type_test(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -934,11 +935,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return false;\n         };\n \n+        debug!(\"subject = {:?}\", subject);\n+\n+        let r_scc = self.constraint_sccs.scc(*lower_bound);\n+\n+        debug!(\n+            \"lower_bound = {:?} r_scc={:?} universe={:?}\",\n+            lower_bound, r_scc, self.scc_universes[r_scc]\n+        );\n+\n+        // If the type test requires that `T: 'a` where `'a` is a\n+        // placeholder from another universe, that effectively requires\n+        // `T: 'static`, so we have to propagate that requirement.\n+        //\n+        // It doesn't matter *what* universe because the promoted `T` will\n+        // always be in the root universe.\n+        if let Some(p) = self.scc_values.placeholders_contained_in(r_scc).next() {\n+            debug!(\"encountered placeholder in higher universe: {:?}, requiring 'static\", p);\n+            let static_r = self.universal_regions.fr_static;\n+            propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n+                subject,\n+                outlived_free_region: static_r,\n+                blame_span: locations.span(body),\n+                category: ConstraintCategory::Boring,\n+            });\n+\n+            // we can return here -- the code below might push add'l constraints\n+            // but they would all be weaker than this one.\n+            return true;\n+        }\n+\n         // For each region outlived by lower_bound find a non-local,\n         // universal region (it may be the same region) and add it to\n         // `ClosureOutlivesRequirement`.\n-        let r_scc = self.constraint_sccs.scc(*lower_bound);\n         for ur in self.scc_values.universal_regions_outlived_by(r_scc) {\n+            debug!(\"universal_region_outlived_by ur={:?}\", ur);\n             // Check whether we can already prove that the \"subject\" outlives `ur`.\n             // If so, we don't have to propagate this requirement to our caller.\n             //\n@@ -963,8 +994,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 continue;\n             }\n \n-            debug!(\"try_promote_type_test: ur={:?}\", ur);\n-\n             let non_local_ub = self.universal_region_relations.non_local_upper_bounds(ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n@@ -1001,15 +1030,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// will use it's *external name*, which will be a `RegionKind`\n     /// variant that can be used in query responses such as\n     /// `ReEarlyBound`.\n+    #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n \n-        debug!(\"try_promote_type_test_subject(ty = {:?})\", ty);\n-\n         let ty = tcx.fold_regions(ty, |r, _depth| {\n             let region_vid = self.to_region_vid(r);\n "}, {"sha": "40eef11f058e15cd04a9c0b03b77372afad9f7d1", "filename": "src/test/ui/generic-associated-types/issue-91139.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.rs?ref=2cb7d1c933e0444732b7eee4b3945964e84bbe39", "patch": "@@ -22,6 +22,7 @@ fn foo<T>() {\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n     //~| ERROR `T` does not live long enough\n+    //~| ERROR `T` may not live long enough\n     //\n     // FIXME: This error is bogus, but it arises because we try to validate\n     // that `<() as Foo<T>>::Type<'a>` is valid, which requires proving"}, {"sha": "b789b3a42f3302032a0e7c46cbb06d2d9c76899b", "filename": "src/test/ui/generic-associated-types/issue-91139.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fissue-91139.stderr?ref=2cb7d1c933e0444732b7eee4b3945964e84bbe39", "patch": "@@ -34,6 +34,17 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |                                                          ^^^^^^^^^\n \n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-91139.rs:16:58\n+   |\n+LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n+   |                                                          ^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn foo<T: 'static>() {\n+   |         +++++++++\n+\n error: `T` does not live long enough\n   --> $DIR/issue-91139.rs:16:58\n    |\n@@ -46,5 +57,6 @@ error: `T` does not live long enough\n LL |     let _: for<'a> fn(<() as Foo<T>>::Type<'a>, &'a T) = |_, _| ();\n    |                                                          ^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "18e6ec630464657410329fb09e01c3d48387fcc7", "filename": "src/test/ui/nll/issue-98693.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.rs?ref=2cb7d1c933e0444732b7eee4b3945964e84bbe39", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for #98693.\n+//\n+// The closure encounters an obligation that `T` must outlive `!U1`,\n+// a placeholder from universe U1. We were ignoring this placeholder\n+// when promoting the constraint to the enclosing function, and\n+// thus incorrectly judging the closure to be safe.\n+\n+fn assert_static<T>()\n+where\n+    for<'a> T: 'a,\n+{\n+}\n+\n+fn test<T>() {\n+    || {\n+        //~^ ERROR the parameter type `T` may not live long enough\n+        assert_static::<T>();\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "31689620c6414e781c5bdd5c1b038b5645a96302", "filename": "src/test/ui/nll/issue-98693.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2cb7d1c933e0444732b7eee4b3945964e84bbe39/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-98693.stderr?ref=2cb7d1c933e0444732b7eee4b3945964e84bbe39", "patch": "@@ -0,0 +1,17 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/issue-98693.rs:15:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         assert_static::<T>();\n+LL | |     };\n+   | |_____^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL | fn test<T: 'static>() {\n+   |          +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}]}