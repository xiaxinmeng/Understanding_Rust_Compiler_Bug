{"sha": "6834944fd321deeb412838e9c8fedfb717b4f67c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MzQ5NDRmZDMyMWRlZWI0MTI4MzhlOWM4ZmVkZmI3MTdiNGY2N2M=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-04-18T10:29:31Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2021-04-18T10:29:31Z"}, "message": "fix MIRI_BE_RUSTC value during sysroot build", "tree": {"sha": "e02f3709189a7c5af0be0db67d869edcf507a76f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e02f3709189a7c5af0be0db67d869edcf507a76f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6834944fd321deeb412838e9c8fedfb717b4f67c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6834944fd321deeb412838e9c8fedfb717b4f67c", "html_url": "https://github.com/rust-lang/rust/commit/6834944fd321deeb412838e9c8fedfb717b4f67c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6834944fd321deeb412838e9c8fedfb717b4f67c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a86eab3e6c3d645769bfdb2d09efd84d1e1fcbc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a86eab3e6c3d645769bfdb2d09efd84d1e1fcbc0", "html_url": "https://github.com/rust-lang/rust/commit/a86eab3e6c3d645769bfdb2d09efd84d1e1fcbc0"}], "stats": {"total": 100, "additions": 57, "deletions": 43}, "files": [{"sha": "e0fbd9fafbb2901473d8e9f2eb1421c8df241917", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6834944fd321deeb412838e9c8fedfb717b4f67c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/6834944fd321deeb412838e9c8fedfb717b4f67c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=6834944fd321deeb412838e9c8fedfb717b4f67c", "patch": "@@ -283,16 +283,17 @@ Moreover, Miri recognizes some environment variables:\n   architecture to test against.  `miri` and `cargo miri` accept the `--target`\n   flag for the same purpose.\n \n-The following environment variables are internal, but used to communicate between\n-different Miri binaries, and as such worth documenting:\n+The following environment variables are *internal* and must not be used by\n+anyone but Miri itself. They are used to communicate between different Miri\n+binaries, and as such worth documenting:\n \n * `MIRI_BE_RUSTC` can be set to `host` or `target`. It tells the Miri driver to\n   actually not interpret the code but compile it like rustc would. With `target`, Miri sets\n   some compiler flags to prepare the code for interpretation; with `host`, this is not done.\n   This environment variable is useful to be sure that the compiled `rlib`s are compatible\n   with Miri.\n-  When set while running `cargo-miri`, it indicates that we are part of a sysroot\n-  build (for which some crates need special treatment).\n+* `MIRI_CALLED_FROM_XARGO` is set during the Miri-induced `xargo` sysroot build,\n+  which will re-invoke `cargo-miri` as the `rustc` to use for this build.\n * `MIRI_CALLED_FROM_RUSTDOC` when set to any value tells `cargo-miri` that it is\n   running as a child process of `rustdoc`, which invokes it twice for each doc-test\n   and requires special treatment, most notably a check-only build before interpretation."}, {"sha": "01b445ee7eb4c85f1a4e69cf389fc0c9560ab10f", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6834944fd321deeb412838e9c8fedfb717b4f67c/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6834944fd321deeb412838e9c8fedfb717b4f67c/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=6834944fd321deeb412838e9c8fedfb717b4f67c", "patch": "@@ -413,14 +413,14 @@ path = \"lib.rs\"\n     // for target crates.\n     // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n     // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n-    // The `MIRI_BE_RUSTC` will mean we dispatch to `phase_setup_rustc`.\n+    // The `MIRI_CALLED_FROM_XARGO` will mean we dispatch to `phase_setup_rustc`.\n     let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n     if env::var_os(\"RUSTC_STAGE\").is_some() {\n         command.env(\"RUSTC_REAL\", &cargo_miri_path);\n     } else {\n         command.env(\"RUSTC\", &cargo_miri_path);\n     }\n-    command.env(\"MIRI_BE_RUSTC\", \"target\");\n+    command.env(\"MIRI_CALLED_FROM_XARGO\", \"1\");\n     // Make sure there are no other wrappers or flags getting in our way\n     // (Cc https://github.com/rust-lang/miri/issues/1421).\n     // This is consistent with normal `cargo build` that does not apply `RUSTFLAGS`\n@@ -450,21 +450,6 @@ path = \"lib.rs\"\n     }\n }\n \n-fn phase_setup_rustc(args: env::Args) {\n-    // Mostly we just forward everything.\n-    // `MIRI_BE_RUST` is already set.\n-    let mut cmd = miri();\n-    cmd.args(args);\n-\n-    // Patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n-    if get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\") {\n-        cmd.arg(\"-C\").arg(\"panic=abort\");\n-    }\n-\n-    // Run it!\n-    exec(cmd);\n-}\n-\n fn phase_cargo_miri(mut args: env::Args) {\n     // Check for version and help flags even when invoked as `cargo-miri`.\n     if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n@@ -598,7 +583,17 @@ fn phase_cargo_miri(mut args: env::Args) {\n     exec(cmd)\n }\n \n-fn phase_cargo_rustc(mut args: env::Args) {\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+enum RustcPhase {\n+    /// `rustc` called via `xargo` for sysroot build.\n+    Setup,\n+    /// `rustc` called by `cargo` for regular build.\n+    Build,\n+    /// `rustc` called by `rustdoc` for doctest.\n+    Rustdoc,\n+}\n+\n+fn phase_rustc(mut args: env::Args, phase: RustcPhase) {\n     /// Determines if we are being invoked (as rustc) to build a crate for\n     /// the \"target\" architecture, in contrast to the \"host\" architecture.\n     /// Host crates are for build scripts and proc macros and still need to\n@@ -644,7 +639,7 @@ fn phase_cargo_rustc(mut args: env::Args) {\n \n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n     let target_crate = is_target_crate();\n-    let print = get_arg_flag_value(\"--print\").is_some(); // whether this is cargo passing `--print` to get some infos\n+    let print = get_arg_flag_value(\"--print\").is_some() || has_arg_flag(\"-vV\"); // whether this is cargo/xargo invoking rustc to get some infos\n \n     let store_json = |info: CrateRunInfo| {\n         // Create a stub .d file to stop Cargo from \"rebuilding\" the crate:\n@@ -669,7 +664,8 @@ fn phase_cargo_rustc(mut args: env::Args) {\n     let runnable_crate = !print && is_runnable_crate();\n \n     if runnable_crate && target_crate {\n-        let inside_rustdoc = env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some();\n+        assert!(phase != RustcPhase::Setup, \"there should be no interpretation during sysroot build\");\n+        let inside_rustdoc = phase == RustcPhase::Rustdoc;\n         // This is the binary or test crate that we want to interpret under Miri.\n         // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n         // like we want them.\n@@ -749,8 +745,15 @@ fn phase_cargo_rustc(mut args: env::Args) {\n             }\n         }\n \n-        // Use our custom sysroot.\n-        forward_miri_sysroot(&mut cmd);\n+        // Use our custom sysroot (but not if that is what we are currently building).\n+        if phase != RustcPhase::Setup {\n+            forward_miri_sysroot(&mut cmd);\n+        }\n+\n+        // During setup, patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n+        if phase == RustcPhase::Setup && get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\") {\n+            cmd.arg(\"-C\").arg(\"panic=abort\");\n+        }\n     } else {\n         // For host crates or when we are printing, just forward everything.\n         cmd.args(args);\n@@ -783,7 +786,15 @@ fn phase_cargo_rustc(mut args: env::Args) {\n     }\n }\n \n-fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n+#[derive(Debug, Copy, Clone, PartialEq)]\n+enum RunnerPhase {\n+    /// `cargo` is running a binary\n+    Cargo,\n+    /// `rustdoc` is running a binary\n+    Rustdoc,\n+}\n+\n+fn phase_runner(binary: &Path, binary_args: env::Args, phase: RunnerPhase) {\n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n \n     let file = File::open(&binary)\n@@ -840,8 +851,8 @@ fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n             cmd.arg(arg);\n         }\n     }\n-    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_none() {\n-        // Set sysroot (if we are inside rustdoc, we already did that in `phase_cargo_rustdoc`).\n+    // Set sysroot (if we are inside rustdoc, we already did that in `phase_cargo_rustdoc`).\n+    if phase != RunnerPhase::Rustdoc {\n         forward_miri_sysroot(&mut cmd);\n     }\n     // Respect `MIRIFLAGS`.\n@@ -869,14 +880,17 @@ fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n         eprintln!(\"[cargo-miri runner] {:?}\", cmd);\n     }\n \n-    if std::env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n-        exec_with_pipe(cmd, &info.stdin)\n-    } else {\n-        exec(cmd)\n+    match phase {\n+        RunnerPhase::Rustdoc => {\n+            exec_with_pipe(cmd, &info.stdin)\n+        }\n+        RunnerPhase::Cargo => {\n+            exec(cmd)\n+        }\n     }\n }\n \n-fn phase_cargo_rustdoc(fst_arg: &str, mut args: env::Args) {\n+fn phase_rustdoc(fst_arg: &str, mut args: env::Args) {\n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n \n     // phase_cargo_miri sets the RUSTDOC env var to ourselves, so we can't use that here;\n@@ -950,15 +964,14 @@ fn main() {\n     args.next().unwrap();\n \n     // Dispatch running as part of sysroot compilation.\n-    if env::var_os(\"MIRI_BE_RUSTC\").is_some() {\n-        phase_setup_rustc(args);\n+    if env::var_os(\"MIRI_CALLED_FROM_XARGO\").is_some() {\n+        phase_rustc(args, RustcPhase::Setup);\n         return;\n     }\n \n     // The way rustdoc invokes rustc is indistuingishable from the way cargo invokes rustdoc by the\n     // arguments alone. `phase_cargo_rustdoc` sets this environment variable to let us disambiguate.\n-    let invoked_by_rustdoc = env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some();\n-    if invoked_by_rustdoc {\n+    if env::var_os(\"MIRI_CALLED_FROM_RUSTDOC\").is_some() {\n         // ...however, we then also see this variable when rustdoc invokes us as the testrunner!\n         // The runner is invoked as `$runtool ($runtool-arg)* output_file`;\n         // since we don't specify any runtool-args, and rustdoc supplies multiple arguments to\n@@ -967,12 +980,12 @@ fn main() {\n             let arg = args.next().unwrap();\n             let binary = Path::new(&arg);\n             if binary.exists() {\n-                phase_cargo_runner(binary, args);\n+                phase_runner(binary, args, RunnerPhase::Rustdoc);\n             } else {\n                 show_error(format!(\"`cargo-miri` called with non-existing path argument `{}` in rustdoc mode; please invoke this binary through `cargo miri`\", arg));\n             }\n         } else {\n-            phase_cargo_rustc(args);\n+            phase_rustc(args, RustcPhase::Rustdoc);\n         }\n \n         return;\n@@ -988,17 +1001,17 @@ fn main() {\n     // On top of that, we are also called as RUSTDOC, but that is just a stub currently.\n     match args.next().as_deref() {\n         Some(\"miri\") => phase_cargo_miri(args),\n-        Some(\"rustc\") => phase_cargo_rustc(args),\n+        Some(\"rustc\") => phase_rustc(args, RustcPhase::Build),\n         Some(arg) => {\n             // We have to distinguish the \"runner\" and \"rustdoc\" cases.\n             // As runner, the first argument is the binary (a file that should exist, with an absolute path);\n             // as rustdoc, the first argument is a flag (`--something`).\n             let binary = Path::new(arg);\n             if binary.exists() {\n                 assert!(!arg.starts_with(\"--\")); // not a flag\n-                phase_cargo_runner(binary, args);\n+                phase_runner(binary, args, RunnerPhase::Cargo);\n             } else if arg.starts_with(\"--\") {\n-                phase_cargo_rustdoc(arg, args);\n+                phase_rustdoc(arg, args);\n             } else {\n                 show_error(format!(\"`cargo-miri` called with unexpected first argument `{}`; please only invoke this binary through `cargo miri`\", arg));\n             }"}]}