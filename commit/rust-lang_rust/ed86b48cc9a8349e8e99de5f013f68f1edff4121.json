{"sha": "ed86b48cc9a8349e8e99de5f013f68f1edff4121", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkODZiNDhjYzlhODM0OWU4ZTk5ZGU1ZjAxM2Y2OGYxZWRmZjQxMjE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-26T02:27:27Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-27T05:11:17Z"}, "message": "Clean up statically initialized data on shutdown\n\nWhenever the runtime is shut down, add a few hooks to clean up some of the\nstatically initialized data of the runtime. Note that this is an unsafe\noperation because there's no guarantee on behalf of the runtime that there's no\nother code running which is using the runtime.\n\nThis helps turn down the noise a bit in the valgrind output related to\nstatically initialized mutexes. It doesn't turn the noise down to 0 because\nthere are still statically initialized mutexes in dynamic_lib and\nos::with_env_lock, but I believe that it would be easy enough to add exceptions\nfor those cases and I don't think that it's the runtime's job to go and clean up\nthat data.", "tree": {"sha": "286d4792fffa99a88eeccefde277edf69eaf70ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/286d4792fffa99a88eeccefde277edf69eaf70ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed86b48cc9a8349e8e99de5f013f68f1edff4121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed86b48cc9a8349e8e99de5f013f68f1edff4121", "html_url": "https://github.com/rust-lang/rust/commit/ed86b48cc9a8349e8e99de5f013f68f1edff4121", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed86b48cc9a8349e8e99de5f013f68f1edff4121/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82d9033b67d618d5bc51e9b22190c369214db4b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/82d9033b67d618d5bc51e9b22190c369214db4b9", "html_url": "https://github.com/rust-lang/rust/commit/82d9033b67d618d5bc51e9b22190c369214db4b9"}], "stats": {"total": 69, "additions": 55, "deletions": 14}, "files": [{"sha": "7b27161ab5d7c9fd7954ee3d2d604fd13ef05f05", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=ed86b48cc9a8349e8e99de5f013f68f1edff4121", "patch": "@@ -32,8 +32,8 @@ pub unsafe fn init(argc: int, argv: **u8) { imp::init(argc, argv) }\n pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n \n /// One-time global cleanup.\n-#[cfg(not(test))] pub fn cleanup() { imp::cleanup() }\n-#[cfg(test)]      pub fn cleanup() { realargs::cleanup() }\n+#[cfg(not(test))] pub unsafe fn cleanup() { imp::cleanup() }\n+#[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n #[cfg(not(test))] pub fn take() -> Option<~[~str]> { imp::take() }\n@@ -74,14 +74,16 @@ mod imp {\n     use vec;\n \n     static mut global_args_ptr: uint = 0;\n+    static mut lock: Mutex = MUTEX_INIT;\n \n     pub unsafe fn init(argc: int, argv: **u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n \n-    pub fn cleanup() {\n+    pub unsafe fn cleanup() {\n         rtassert!(take().is_some());\n+        lock.destroy();\n     }\n \n     pub fn take() -> Option<~[~str]> {\n@@ -108,7 +110,6 @@ mod imp {\n     }\n \n     fn with_lock<T>(f: || -> T) -> T {\n-        static mut lock: Mutex = MUTEX_INIT;\n         (|| {\n             unsafe {\n                 lock.lock();"}, {"sha": "86f0f643c996251cc814be283b13fc9d6b5825bc", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=ed86b48cc9a8349e8e99de5f013f68f1edff4121", "patch": "@@ -41,28 +41,45 @@ pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n #[cfg(stage0)]\n #[cfg(windows)]\n static mut RT_TLS_KEY: tls::Key = -1;\n+static mut tls_lock: Mutex = MUTEX_INIT;\n+static mut tls_initialized: bool = false;\n \n /// Initialize the TLS key. Other ops will fail if this isn't executed first.\n #[inline(never)]\n #[cfg(stage0)]\n #[cfg(windows)]\n pub fn init_tls_key() {\n-    static mut lock: Mutex = MUTEX_INIT;\n-    static mut initialized: bool = false;\n-\n     unsafe {\n-        lock.lock();\n-        if !initialized {\n+        tls_lock.lock();\n+        if !tls_initialized {\n             tls::create(&mut RT_TLS_KEY);\n-            initialized = true;\n+            tls_initialized = true;\n         }\n-        lock.unlock();\n+        tls_lock.unlock();\n     }\n }\n \n #[cfg(not(stage0), not(windows))]\n pub fn init_tls_key() {}\n \n+#[cfg(windows)]\n+pub unsafe fn cleanup() {\n+    // No real use to acquiring a lock around these operations. All we're\n+    // going to do is destroy the lock anyway which races locking itself. This\n+    // is why the whole function is labeled as 'unsafe'\n+    assert!(tls_initialized);\n+    tls::destroy(RT_TLS_KEY);\n+    tls_lock.destroy();\n+    tls_initialized = false;\n+}\n+\n+#[cfg(not(windows))]\n+pub unsafe fn cleanup() {\n+    assert!(tls_initialized);\n+    tls_lock.destroy();\n+    tls_initialized = false;\n+}\n+\n /// Give a pointer to thread-local storage.\n ///\n /// # Safety note"}, {"sha": "79b7dbf2aabf4f42fe47b51f4c9bc15672b4d553", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=ed86b48cc9a8349e8e99de5f013f68f1edff4121", "patch": "@@ -215,7 +215,8 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n \n     init(argc, argv);\n     let exit_code = run(main);\n-    cleanup();\n+    // unsafe is ok b/c we're sure that the runtime is gone\n+    unsafe { cleanup(); }\n \n     return exit_code;\n }\n@@ -228,7 +229,8 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n pub fn start_on_main_thread(argc: int, argv: **u8, main: proc()) -> int {\n     init(argc, argv);\n     let exit_code = run_on_main_thread(main);\n-    cleanup();\n+    // unsafe is ok b/c we're sure that the runtime is gone\n+    unsafe { cleanup(); }\n \n     return exit_code;\n }\n@@ -249,8 +251,17 @@ pub fn init(argc: int, argv: **u8) {\n }\n \n /// One-time runtime cleanup.\n-pub fn cleanup() {\n+///\n+/// This function is unsafe because it performs no checks to ensure that the\n+/// runtime has completely ceased running. It is the responsibility of the\n+/// caller to ensure that the runtime is entirely shut down and nothing will be\n+/// poking around at the internal components.\n+///\n+/// Invoking cleanup while portions of the runtime are still in use may cause\n+/// undefined behavior.\n+pub unsafe fn cleanup() {\n     args::cleanup();\n+    local_ptr::cleanup();\n }\n \n /// Execute the main function in a scheduler."}, {"sha": "62e1b6c50d65f82ec73004513396e3f2520dbc62", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed86b48cc9a8349e8e99de5f013f68f1edff4121/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=ed86b48cc9a8349e8e99de5f013f68f1edff4121", "patch": "@@ -34,6 +34,11 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n     pthread_getspecific(key)\n }\n \n+#[cfg(unix)]\n+pub unsafe fn destroy(key: Key) {\n+    assert_eq!(0, pthread_key_delete(key));\n+}\n+\n #[cfg(target_os=\"macos\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_ulong;\n@@ -47,6 +52,7 @@ type pthread_key_t = ::libc::c_uint;\n #[cfg(unix)]\n extern {\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n+    fn pthread_key_delete(key: pthread_key_t) -> c_int;\n     fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n     fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n }\n@@ -71,9 +77,15 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n     TlsGetValue(key)\n }\n \n+#[cfg(windows)]\n+pub unsafe fn destroy(key: Key) {\n+    assert!(TlsFree(key) != 0);\n+}\n+\n #[cfg(windows)]\n extern \"system\" {\n     fn TlsAlloc() -> DWORD;\n+    fn TlsFree(dwTlsIndex: DWORD) -> BOOL;\n     fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;\n     fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n }"}]}