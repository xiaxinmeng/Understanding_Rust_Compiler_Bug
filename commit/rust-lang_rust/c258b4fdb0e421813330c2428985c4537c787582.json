{"sha": "c258b4fdb0e421813330c2428985c4537c787582", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNThiNGZkYjBlNDIxODEzMzMwYzI0Mjg5ODVjNDUzN2M3ODc1ODI=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-11T19:27:00Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-11T19:27:00Z"}, "message": "Add validator for byte", "tree": {"sha": "e53263f28c0cd07911a1e9c9ef6538c8ff0227fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e53263f28c0cd07911a1e9c9ef6538c8ff0227fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c258b4fdb0e421813330c2428985c4537c787582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c258b4fdb0e421813330c2428985c4537c787582", "html_url": "https://github.com/rust-lang/rust/commit/c258b4fdb0e421813330c2428985c4537c787582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c258b4fdb0e421813330c2428985c4537c787582/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4f7d7a7cd85a5b9b64a935dd84ad493b6860236", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236", "html_url": "https://github.com/rust-lang/rust/commit/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236"}], "stats": {"total": 506, "additions": 416, "deletions": 90}, "files": [{"sha": "75236153d9c911cfbea3536729a0ecd67185c6b3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -372,6 +372,43 @@ impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {\n \n impl<'a> BreakExpr<'a> {}\n \n+// Byte\n+#[derive(Debug, Clone, Copy,)]\n+pub struct ByteNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type Byte<'a> = ByteNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ByteNode<R1>> for ByteNode<R2> {\n+    fn eq(&self, other: &ByteNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ByteNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ByteNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for Byte<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BYTE => Some(Byte { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> ByteNode<R> {\n+    pub fn borrowed(&self) -> Byte {\n+        ByteNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> ByteNode {\n+        ByteNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> Byte<'a> {}\n+\n // CallExpr\n #[derive(Debug, Clone, Copy,)]\n pub struct CallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {"}, {"sha": "686b5cf0407efe0b9a5a709f97c3cbcba504011a", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -134,6 +134,12 @@ impl<'a> Char<'a> {\n     }\n }\n \n+impl<'a> Byte<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n impl<'a> String<'a> {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()"}, {"sha": "2c2ed1aebc10160ca2168bcf7d536def2a4eb2fb", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -412,6 +412,7 @@ Grammar(\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n         \"String\": (),\n+        \"Byte\": (),\n         \"Char\": (),\n         \"Literal\": (),\n "}, {"sha": "4e8c3a91c8e618d8a5c5ce5dac184bf3af575887", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -63,6 +63,56 @@ impl<'a> Iterator for StringComponentIterator<'a> {\n     }\n }\n \n+pub fn parse_byte_literal(src: &str) -> ByteComponentIterator {\n+    ByteComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct ByteComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for ByteComponentIterator<'a> {\n+    type Item = CharComponent;\n+    fn next(&mut self) -> Option<CharComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == 'b',\n+                \"Byte literal should start with a b\"\n+            );\n+\n+            assert!(\n+                self.parser.advance() == '\\'',\n+                \"Byte literal should start with a b, followed by a quote\"\n+            );\n+        }\n+\n+\n+        if let Some(component) = self.parser.parse_char_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\\'') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"byte literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n     CharComponentIterator {\n         parser: Parser::new(src),"}, {"sha": "3d2806c4e1227f8e6e015910f5b3972f0ebb5d9c", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -0,0 +1,202 @@\n+//! Validation of byte literals\n+\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, CharComponentKind},\n+    TextRange,\n+    validation::char,\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_byte_literal(literal_text);\n+    let mut len = 0;\n+    for component in &mut components {\n+        len += 1;\n+        let text = &literal_text[component.range];\n+        let range = component.range + literal_range.start();\n+\n+        use self::CharComponentKind::*;\n+        match component.kind {\n+            AsciiEscape => validate_byte_escape(text, range, errors),\n+            AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n+            UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n+            CodePoint => {\n+                let c = text.chars().next().expect(\"Code points should be one character long\");\n+\n+                // These bytes must always be escaped\n+                if c == '\\t' || c == '\\r' || c == '\\n' {\n+                    errors.push(SyntaxError::new(UnescapedByte, range));\n+                }\n+\n+                // Only ASCII bytes are allowed\n+                if c > 0x7F as char {\n+                    errors.push(SyntaxError::new(ByteOutOfRange, range));\n+                }\n+            }\n+        }\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedByte, literal_range));\n+    }\n+\n+    if len == 0 {\n+        errors.push(SyntaxError::new(EmptyByte, literal_range));\n+    }\n+\n+    if len > 1 {\n+        errors.push(SyntaxError::new(OverlongByte, literal_range));\n+    }\n+}\n+\n+fn validate_byte_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    if text.len() == 1 {\n+        // Escape sequence consists only of leading `\\`\n+        errors.push(SyntaxError::new(EmptyByteEscape, range));\n+    } else {\n+        let escape_code = text.chars().skip(1).next().unwrap();\n+        if !char::is_ascii_escape(escape_code) {\n+            errors.push(SyntaxError::new(InvalidByteEscape, range));\n+        }\n+    }\n+}\n+\n+fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    // A ByteCodeEscape has 4 chars, example: `\\xDD`\n+    if text.len() < 4 {\n+        errors.push(SyntaxError::new(TooShortByteCodeEscape, range));\n+    } else {\n+        assert!(\n+            text.chars().count() == 4,\n+            \"ByteCodeEscape cannot be longer than 4 chars\"\n+        );\n+\n+        if u8::from_str_radix(&text[2..], 16).is_err() {\n+            errors.push(SyntaxError::new(MalformedByteCodeEscape, range));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(\"const C: u8 = b'{}';\", literal);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_byte(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_byte(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..128 {\n+            match byte {\n+                b'\\n' | b'\\r' | b'\\t' => assert_invalid_byte(&(byte as char).to_string()),\n+                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n+                _ => assert_valid_byte(&(byte as char).to_string()),\n+            }\n+        }\n+\n+        for byte in 128..=255u8 {\n+            assert_invalid_byte(&(byte as char).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_byte_escape() {\n+        let valid = [\n+            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n+        ];\n+        for c in &valid {\n+            assert_valid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_byte_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_byte_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n+        for c in &valid {\n+            assert_valid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_byte_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let well_formed = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &well_formed {\n+            assert_invalid_byte(c);\n+        }\n+\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+}"}, {"sha": "793539b3ab238435879c0958006b6a6cdeea1d9d", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 98, "deletions": 90, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -1,3 +1,5 @@\n+//! Validation of char literals\n+\n use std::u32;\n \n use arrayvec::ArrayString;\n@@ -12,7 +14,7 @@ use crate::{\n     },\n };\n \n-pub(crate) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_char_literal(literal_text);\n@@ -37,7 +39,7 @@ pub(crate) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>)\n     }\n }\n \n-pub(crate) fn validate_char_component(\n+pub(super) fn validate_char_component(\n     text: &str,\n     kind: CharComponentKind,\n     range: TextRange,\n@@ -46,109 +48,115 @@ pub(crate) fn validate_char_component(\n     // Validate escapes\n     use self::CharComponentKind::*;\n     match kind {\n-        AsciiEscape => {\n-            if text.len() == 1 {\n-                // Escape sequence consists only of leading `\\`\n-                errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n-            } else {\n-                let escape_code = text.chars().skip(1).next().unwrap();\n-                if !is_ascii_escape(escape_code) {\n-                    errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n-                }\n+        AsciiEscape => validate_ascii_escape(text, range, errors),\n+        AsciiCodeEscape => validate_ascii_code_escape(text, range, errors),\n+        UnicodeEscape => validate_unicode_escape(text, range, errors),\n+        CodePoint => {\n+            // These code points must always be escaped\n+            if text == \"\\t\" || text == \"\\r\" || text == \"\\n\" {\n+                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n             }\n         }\n-        AsciiCodeEscape => {\n-            // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n-            if text.len() < 4 {\n-                errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n-            } else {\n-                assert!(\n-                    text.chars().count() == 4,\n-                    \"AsciiCodeEscape cannot be longer than 4 chars\"\n-                );\n-\n-                match u8::from_str_radix(&text[2..], 16) {\n-                    Ok(code) if code < 128 => { /* Escape code is valid */ }\n-                    Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n-                    Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n-                }\n-            }\n+    }\n+}\n+\n+fn validate_ascii_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    if text.len() == 1 {\n+        // Escape sequence consists only of leading `\\`\n+        errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n+    } else {\n+        let escape_code = text.chars().skip(1).next().unwrap();\n+        if !is_ascii_escape(escape_code) {\n+            errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n         }\n-        UnicodeEscape => {\n-            assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n+    }\n+}\n \n-            if text.len() == 2 {\n-                // No starting `{`\n-                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                return;\n-            }\n+pub(super) fn is_ascii_escape(code: char) -> bool {\n+    match code {\n+        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n+        _ => false,\n+    }\n+}\n \n-            if text.len() == 3 {\n-                // Only starting `{`\n-                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n-                return;\n-            }\n+fn validate_ascii_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n+    if text.len() < 4 {\n+        errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n+    } else {\n+        assert!(\n+            text.chars().count() == 4,\n+            \"AsciiCodeEscape cannot be longer than 4 chars\"\n+        );\n \n-            let mut code = ArrayString::<[_; 6]>::new();\n-            let mut closed = false;\n-            for c in text[3..].chars() {\n-                assert!(!closed, \"no characters after escape is closed\");\n-\n-                if c.is_digit(16) {\n-                    if code.len() == 6 {\n-                        errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n-                        return;\n-                    }\n-\n-                    code.push(c);\n-                } else if c == '_' {\n-                    // Reject leading _\n-                    if code.len() == 0 {\n-                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                        return;\n-                    }\n-                } else if c == '}' {\n-                    closed = true;\n-                } else {\n-                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                    return;\n-                }\n-            }\n+        match u8::from_str_radix(&text[2..], 16) {\n+            Ok(code) if code < 128 => { /* Escape code is valid */ }\n+            Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n+            Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n+        }\n+    }\n+}\n \n-            if !closed {\n-                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n-            }\n+fn validate_unicode_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n \n-            if code.len() == 0 {\n-                errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+    if text.len() == 2 {\n+        // No starting `{`\n+        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+        return;\n+    }\n+\n+    if text.len() == 3 {\n+        // Only starting `{`\n+        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n+        return;\n+    }\n+\n+    let mut code = ArrayString::<[_; 6]>::new();\n+    let mut closed = false;\n+    for c in text[3..].chars() {\n+        assert!(!closed, \"no characters after escape is closed\");\n+\n+        if c.is_digit(16) {\n+            if code.len() == 6 {\n+                errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n                 return;\n             }\n \n-            match u32::from_str_radix(&code, 16) {\n-                Ok(code_u32) if code_u32 > 0x10FFFF => {\n-                    errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n-                }\n-                Ok(_) => {\n-                    // Valid escape code\n-                }\n-                Err(_) => {\n-                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                }\n-            }\n-        }\n-        CodePoint => {\n-            // These code points must always be escaped\n-            if text == \"\\t\" || text == \"\\r\" {\n-                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n+            code.push(c);\n+        } else if c == '_' {\n+            // Reject leading _\n+            if code.len() == 0 {\n+                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                return;\n             }\n+        } else if c == '}' {\n+            closed = true;\n+        } else {\n+            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+            return;\n         }\n     }\n-}\n \n-fn is_ascii_escape(code: char) -> bool {\n-    match code {\n-        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n-        _ => false,\n+    if !closed {\n+        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n+    }\n+\n+    if code.len() == 0 {\n+        errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+        return;\n+    }\n+\n+    match u32::from_str_radix(&code, 16) {\n+        Ok(code_u32) if code_u32 > 0x10FFFF => {\n+            errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n+        }\n+        Ok(_) => {\n+            // Valid escape code\n+        }\n+        Err(_) => {\n+            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+        }\n     }\n }\n "}, {"sha": "acad7cb7fc8b2a5b69d80c9521b1ea3236d92fc3", "filename": "crates/ra_syntax/src/validation/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -5,13 +5,15 @@ use crate::{\n     yellow::SyntaxError,\n };\n \n+mod byte;\n mod char;\n mod string;\n \n pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)\n+            .visit::<ast::Byte, _>(self::byte::validate_byte_node)\n             .visit::<ast::Char, _>(self::char::validate_char_node)\n             .visit::<ast::String, _>(self::string::validate_string_node)\n             .accept(node);"}, {"sha": "df230293bbc4f7d754bbc59e7f4423efecb26e48", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c258b4fdb0e421813330c2428985c4537c787582/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=c258b4fdb0e421813330c2428985c4537c787582", "patch": "@@ -72,6 +72,16 @@ pub enum SyntaxErrorKind {\n     EmptyChar,\n     UnclosedChar,\n     OverlongChar,\n+    EmptyByte,\n+    UnclosedByte,\n+    OverlongByte,\n+    ByteOutOfRange,\n+    UnescapedByte,\n+    EmptyByteEscape,\n+    InvalidByteEscape,\n+    TooShortByteCodeEscape,\n+    MalformedByteCodeEscape,\n+    UnicodeEscapeForbidden,\n     EmptyAsciiEscape,\n     InvalidAsciiEscape,\n     TooShortAsciiCodeEscape,\n@@ -98,6 +108,16 @@ impl fmt::Display for SyntaxErrorKind {\n             EmptyChar => write!(f, \"Empty char literal\"),\n             UnclosedChar => write!(f, \"Unclosed char literal\"),\n             OverlongChar => write!(f, \"Char literal should be one character long\"),\n+            EmptyByte => write!(f, \"Empty byte literal\"),\n+            UnclosedByte => write!(f, \"Unclosed byte literal\"),\n+            OverlongByte => write!(f, \"Byte literal should be one character long\"),\n+            ByteOutOfRange => write!(f, \"Byte should be a valid ASCII character\"),\n+            UnescapedByte => write!(f, \"This byte should always be escaped\"),\n+            EmptyByteEscape => write!(f, \"Empty escape sequence\"),\n+            InvalidByteEscape => write!(f, \"Invalid escape sequence\"),\n+            TooShortByteCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n+            MalformedByteCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n+            UnicodeEscapeForbidden => write!(f, \"Unicode escapes are not allowed in byte literals or byte strings\"),\n             TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n             AsciiCodeEscapeOutOfRange => {\n                 write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")"}]}