{"sha": "b5e889791a5ec8cb06224cf07273be8c84192698", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZTg4OTc5MWE1ZWM4Y2IwNjIyNGNmMDcyNzNiZThjODQxOTI2OTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-03-16T21:47:32Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-03-21T20:01:53Z"}, "message": "Refactor parsing of trait object types", "tree": {"sha": "dc43eb9074818d1a8cdb750f2cc22c896452e908", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc43eb9074818d1a8cdb750f2cc22c896452e908"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5e889791a5ec8cb06224cf07273be8c84192698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e889791a5ec8cb06224cf07273be8c84192698", "html_url": "https://github.com/rust-lang/rust/commit/b5e889791a5ec8cb06224cf07273be8c84192698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5e889791a5ec8cb06224cf07273be8c84192698/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58c701f5c7dc26d9b55c631006ece52abe1ddce2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58c701f5c7dc26d9b55c631006ece52abe1ddce2", "html_url": "https://github.com/rust-lang/rust/commit/58c701f5c7dc26d9b55c631006ece52abe1ddce2"}], "stats": {"total": 561, "additions": 294, "deletions": 267}, "files": [{"sha": "4347046b6b8088651e413766e9958231a5772d96", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -17,7 +17,7 @@ pub use self::PathParameters::*;\n pub use symbol::Symbol as Name;\n pub use util::ThinVec;\n \n-use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n+use syntax_pos::{mk_sp, BytePos, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::SyntaxContext;\n@@ -1716,6 +1716,16 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n+impl PolyTraitRef {\n+    pub fn new(lifetimes: Vec<LifetimeDef>, path: Path, lo: BytePos, hi: BytePos) -> Self {\n+        PolyTraitRef {\n+            bound_lifetimes: lifetimes,\n+            trait_ref: TraitRef { path: path, ref_id: DUMMY_NODE_ID },\n+            span: mk_sp(lo, hi),\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,"}, {"sha": "6abeb4b0b2805f9b642c6eaa7f7a2e9c82d56119", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -657,7 +657,7 @@ impl<'a> Parser<'a> {\n             }\n             ExpansionKind::Expr => Expansion::Expr(self.parse_expr()?),\n             ExpansionKind::OptExpr => Expansion::OptExpr(Some(self.parse_expr()?)),\n-            ExpansionKind::Ty => Expansion::Ty(self.parse_ty_no_plus()?),\n+            ExpansionKind::Ty => Expansion::Ty(self.parse_ty()?),\n             ExpansionKind::Pat => Expansion::Pat(self.parse_pat()?),\n         })\n     }"}, {"sha": "d7a85baa3fff56b127eefdea5fcd24be5aa7a677", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -414,7 +414,7 @@ pub fn parse_arm_panic(parser: &mut Parser) -> Arm {\n }\n \n pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> {\n-    panictry!(parser.parse_ty_no_plus())\n+    panictry!(parser.parse_ty())\n }\n \n pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> {"}, {"sha": "ed17f0f956cf3b5367f8a77dd6c0cae0fbd4b833", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -512,7 +512,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         },\n         \"pat\" => token::NtPat(panictry!(p.parse_pat())),\n         \"expr\" => token::NtExpr(panictry!(p.parse_expr())),\n-        \"ty\" => token::NtTy(panictry!(p.parse_ty_no_plus())),\n+        \"ty\" => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n         \"ident\" => match p.token {\n             token::Ident(sn) => {"}, {"sha": "df4ccc94c0421cbb9397a459079f405fac7f5a29", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 177, "deletions": 227, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -41,7 +41,7 @@ use ast::{BinOpKind, UnOp};\n use ast::RangeEnd;\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, spanned, respan};\n-use syntax_pos::{self, Span, Pos, BytePos, mk_sp};\n+use syntax_pos::{self, Span, BytePos, mk_sp};\n use errors::{self, DiagnosticBuilder};\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n@@ -1116,57 +1116,13 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern)\n     }\n \n-    pub fn get_lifetime(&mut self) -> ast::Ident {\n+    fn get_label(&mut self) -> ast::Ident {\n         match self.token {\n             token::Lifetime(ref ident) => *ident,\n             _ => self.bug(\"not a lifetime\"),\n         }\n     }\n \n-    pub fn parse_for_in_type(&mut self) -> PResult<'a, TyKind> {\n-        /*\n-        Parses whatever can come after a `for` keyword in a type.\n-        The `for` hasn't been consumed.\n-\n-        - for <'lt> [unsafe] [extern \"ABI\"] fn (S) -> T\n-        - for <'lt> path::foo(a, b) + Trait + 'a\n-        */\n-\n-        let lo = self.span.lo;\n-        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-        // examine next token to decide to do\n-        if self.token_is_bare_fn_keyword() {\n-            self.parse_ty_bare_fn(lifetime_defs)\n-        } else {\n-            let hi = self.span.hi;\n-            let trait_ref = self.parse_trait_ref()?;\n-            let poly_trait_ref = PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                                trait_ref: trait_ref,\n-                                                span: mk_sp(lo, hi)};\n-            let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n-                self.parse_ty_param_bounds()?\n-            } else {\n-                Vec::new()\n-            };\n-            let all_bounds =\n-                Some(TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None)).into_iter()\n-                .chain(other_bounds)\n-                .collect();\n-            Ok(ast::TyKind::TraitObject(all_bounds))\n-        }\n-    }\n-\n-    pub fn parse_impl_trait_type(&mut self) -> PResult<'a, TyKind> {\n-        // Parses whatever can come after a `impl` keyword in a type.\n-        // The `impl` has already been consumed.\n-        Ok(ast::TyKind::ImplTrait(self.parse_ty_param_bounds()?))\n-    }\n-\n-    pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n-        Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n-    }\n-\n     /// parse a TyKind::BareFn type:\n     pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<LifetimeDef>)\n                             -> PResult<'a, TyKind> {\n@@ -1347,100 +1303,27 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a type.\n+    // Parse a type\n     pub fn parse_ty(&mut self) -> PResult<'a, P<Ty>> {\n-        let lo = self.span.lo;\n-        let lhs = self.parse_ty_no_plus()?;\n-\n-        if !self.eat(&token::BinOp(token::Plus)) {\n-            return Ok(lhs);\n-        }\n-\n-        let mut bounds = self.parse_ty_param_bounds()?;\n-\n-        // In type grammar, `+` is treated like a binary operator,\n-        // and hence both L and R side are required.\n-        if bounds.is_empty() {\n-            let prev_span = self.prev_span;\n-            self.span_err(prev_span,\n-                          \"at least one type parameter bound \\\n-                          must be specified\");\n-        }\n-\n-        let mut lhs = lhs.unwrap();\n-        if let TyKind::Paren(ty) = lhs.node {\n-            // We have to accept the first bound in parens for backward compatibility.\n-            // Example: `(Bound) + Bound + Bound`\n-            lhs = ty.unwrap();\n-        }\n-        if let TyKind::Path(None, path) = lhs.node {\n-            let poly_trait_ref = PolyTraitRef {\n-                bound_lifetimes: Vec::new(),\n-                trait_ref: TraitRef { path: path, ref_id: lhs.id },\n-                span: lhs.span,\n-            };\n-            let poly_trait_ref = TraitTyParamBound(poly_trait_ref, TraitBoundModifier::None);\n-            bounds.insert(0, poly_trait_ref);\n-        } else {\n-            let mut err = struct_span_err!(self.sess.span_diagnostic, lhs.span, E0178,\n-                                            \"expected a path on the left-hand side \\\n-                                            of `+`, not `{}`\",\n-                                            pprust::ty_to_string(&lhs));\n-            err.span_label(lhs.span, &format!(\"expected a path\"));\n-            let hi = bounds.iter().map(|x| match *x {\n-                TraitTyParamBound(ref tr, _) => tr.span.hi,\n-                RegionTyParamBound(ref r) => r.span.hi,\n-            }).max_by_key(|x| x.to_usize());\n-            let full_span = hi.map(|hi| Span {\n-                lo: lhs.span.lo,\n-                hi: hi,\n-                expn_id: lhs.span.expn_id,\n-            });\n-            match (&lhs.node, full_span) {\n-                (&TyKind::Rptr(ref lifetime, ref mut_ty), Some(full_span)) => {\n-                    let ty_str = pprust::to_string(|s| {\n-                        use print::pp::word;\n-                        use print::pprust::PrintState;\n-\n-                        word(&mut s.s, \"&\")?;\n-                        s.print_opt_lifetime(lifetime)?;\n-                        s.print_mutability(mut_ty.mutbl)?;\n-                        s.popen()?;\n-                        s.print_type(&mut_ty.ty)?;\n-                        s.print_bounds(\" +\", &bounds)?;\n-                        s.pclose()\n-                    });\n-                    err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n-                                        ty_str);\n-                }\n-\n-                _ => {\n-                    help!(&mut err,\n-                                \"perhaps you forgot parentheses? (per RFC 438)\");\n-                }\n-            }\n-            err.emit();\n-        }\n-\n-        let sp = mk_sp(lo, self.prev_span.hi);\n-        let sum = TyKind::TraitObject(bounds);\n-        Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: sum, span: sp}))\n+        self.parse_ty_common(true)\n     }\n \n     /// Parse a type in restricted contexts where `+` is not permitted.\n     /// Example 1: `&'a TYPE`\n     ///     `+` is prohibited to maintain operator priority (P(+) < P(&)).\n     /// Example 2: `value1 as TYPE + value2`\n     ///     `+` is prohibited to avoid interactions with expression grammar.\n-    pub fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n+    fn parse_ty_no_plus(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(false)\n+    }\n+\n+    fn parse_ty_common(&mut self, allow_plus: bool) -> PResult<'a, P<Ty>> {\n         maybe_whole!(self, NtTy, |x| x);\n \n         let lo = self.span.lo;\n-\n-        let t = if self.eat(&token::OpenDelim(token::Paren)) {\n-            // (t) is a parenthesized ty\n-            // (t,) is the type of a tuple with only one field,\n-            // of type t\n+        let node = if self.eat(&token::OpenDelim(token::Paren)) {\n+            // `(TYPE)` is a parenthesized type.\n+            // `(TYPE,)` is a tuple with a single field of type TYPE.\n             let mut ts = vec![];\n             let mut last_comma = false;\n             while self.token != token::CloseDelim(token::Paren) {\n@@ -1452,81 +1335,162 @@ impl<'a> Parser<'a> {\n                     break;\n                 }\n             }\n-\n             self.expect(&token::CloseDelim(token::Paren))?;\n+\n             if ts.len() == 1 && !last_comma {\n-                TyKind::Paren(ts.into_iter().nth(0).unwrap())\n+                let ty = ts.into_iter().nth(0).unwrap().unwrap();\n+                match ty.node {\n+                    // Accept `(Trait1) + Trait2 + 'a` for backward compatibility (#39318).\n+                    TyKind::Path(None, ref path)\n+                            if allow_plus && self.token == token::BinOp(token::Plus) => {\n+                        self.bump(); // `+`\n+                        let pt = PolyTraitRef::new(Vec::new(), path.clone(), lo, self.prev_span.hi);\n+                        let mut bounds = vec![TraitTyParamBound(pt, TraitBoundModifier::None)];\n+                        bounds.append(&mut self.parse_ty_param_bounds()?);\n+                        TyKind::TraitObject(bounds)\n+                    }\n+                    _ => TyKind::Paren(P(ty))\n+                }\n             } else {\n                 TyKind::Tup(ts)\n             }\n         } else if self.eat(&token::Not) {\n+            // Never type `!`\n             TyKind::Never\n         } else if self.eat(&token::BinOp(token::Star)) {\n-            // STAR POINTER (bare pointer?)\n+            // Raw pointer\n             TyKind::Ptr(self.parse_ptr()?)\n         } else if self.eat(&token::OpenDelim(token::Bracket)) {\n-            // VECTOR\n+            // Array or slice\n             let t = self.parse_ty()?;\n-\n-            // Parse the `; e` in `[ i32; e ]`\n-            // where `e` is a const expression\n+            // Parse optional `; EXPR` in `[TYPE; EXPR]`\n             let t = match self.maybe_parse_fixed_length_of_vec()? {\n                 None => TyKind::Slice(t),\n-                Some(suffix) => TyKind::Array(t, suffix)\n+                Some(suffix) => TyKind::Array(t, suffix),\n             };\n             self.expect(&token::CloseDelim(token::Bracket))?;\n             t\n-        } else if self.check(&token::BinOp(token::And)) ||\n-                  self.check(&token::AndAnd) {\n-            // BORROWED POINTER\n+        } else if self.check(&token::BinOp(token::And)) || self.check(&token::AndAnd) {\n+            // Reference\n             self.expect_and()?;\n             self.parse_borrowed_pointee()?\n-        } else if self.check_keyword(keywords::For) {\n-            // FIXME `+` has incorrect priority in trait object types starting with `for` (#39317).\n-            self.parse_for_in_type()?\n-        } else if self.eat_keyword(keywords::Impl) {\n-            // FIXME figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n-            self.parse_impl_trait_type()?\n-        } else if self.token_is_bare_fn_keyword() {\n-            // BARE FUNCTION\n-            self.parse_ty_bare_fn(Vec::new())?\n         } else if self.eat_keyword_noexpect(keywords::Typeof) {\n-            // TYPEOF\n+            // `typeof(EXPR)`\n             // In order to not be ambiguous, the type must be surrounded by parens.\n             self.expect(&token::OpenDelim(token::Paren))?;\n             let e = self.parse_expr()?;\n             self.expect(&token::CloseDelim(token::Paren))?;\n             TyKind::Typeof(e)\n+        } else if self.eat(&token::Underscore) {\n+            // A type to be inferred `_`\n+            TyKind::Infer\n         } else if self.eat_lt() {\n+            // Qualified path\n             let (qself, path) = self.parse_qualified_path(PathStyle::Type)?;\n             TyKind::Path(Some(qself), path)\n         } else if self.token.is_path_start() {\n+            // Simple path\n             let path = self.parse_path(PathStyle::Type)?;\n             if self.eat(&token::Not) {\n-                // MACRO INVOCATION\n+                // Macro invocation in type position\n                 let (_, tts) = self.expect_delimited_token_tree()?;\n-                let hi = self.span.hi;\n-                TyKind::Mac(spanned(lo, hi, Mac_ { path: path, tts: tts }))\n+                TyKind::Mac(spanned(lo, self.span.hi, Mac_ { path: path, tts: tts }))\n             } else {\n-                // NAMED TYPE\n-                TyKind::Path(None, path)\n+                // Just a type path or bound list (trait object type) starting with a trait.\n+                //   `Type`\n+                //   `Trait1 + Trait2 + 'a`\n+                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n+                    let poly_trait = PolyTraitRef::new(Vec::new(), path, lo, self.prev_span.hi);\n+                    let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n+                    bounds.append(&mut self.parse_ty_param_bounds()?);\n+                    TyKind::TraitObject(bounds)\n+                } else {\n+                    TyKind::Path(None, path)\n+                }\n             }\n-        } else if self.eat(&token::Underscore) {\n-            // TYPE TO BE INFERRED\n-            TyKind::Infer\n+        } else if self.token_is_bare_fn_keyword() {\n+            // Function pointer type\n+            self.parse_ty_bare_fn(Vec::new())?\n+        } else if self.check_keyword(keywords::For) {\n+            // Function pointer type or bound list (trait object type) starting with a poly-trait.\n+            //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n+            //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n+            let lo = self.span.lo;\n+            let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+            if self.token_is_bare_fn_keyword() {\n+                self.parse_ty_bare_fn(lifetime_defs)?\n+            } else {\n+                let path = self.parse_path(PathStyle::Type)?;\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n+                let mut bounds = vec![TraitTyParamBound(poly_trait, TraitBoundModifier::None)];\n+                if allow_plus && self.eat(&token::BinOp(token::Plus)) {\n+                    bounds.append(&mut self.parse_ty_param_bounds()?)\n+                }\n+                TyKind::TraitObject(bounds)\n+            }\n+        } else if self.eat_keyword(keywords::Impl) {\n+            // FIXME: figure out priority of `+` in `impl Trait1 + Trait2` (#34511).\n+            TyKind::ImplTrait(self.parse_ty_param_bounds()?)\n+        } else if self.check(&token::Question) {\n+            // Bound list (trait object type)\n+            // Bound lists starting with `'lt` are not currently supported (#40043)\n+            TyKind::TraitObject(self.parse_ty_param_bounds_common(allow_plus)?)\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n             return Err(self.fatal(&msg));\n         };\n \n-        let sp = mk_sp(lo, self.prev_span.hi);\n-        Ok(P(Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}))\n+        let span = mk_sp(lo, self.prev_span.hi);\n+        let ty = Ty { node: node, span: span, id: ast::DUMMY_NODE_ID };\n+\n+        // Try to recover from use of `+` with incorrect priority.\n+        self.maybe_recover_from_bad_type_plus(allow_plus, &ty)?;\n+\n+        Ok(P(ty))\n     }\n \n-    pub fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n-        // look for `&'lt` or `&'foo ` and interpret `foo` as the region name:\n-        let opt_lifetime = self.eat_lifetime();\n-        let mutbl = self.parse_mutability()?;\n+    fn maybe_recover_from_bad_type_plus(&mut self, allow_plus: bool, ty: &Ty) -> PResult<'a, ()> {\n+        // Do not add `+` to expected tokens.\n+        if !allow_plus || self.token != token::BinOp(token::Plus) {\n+            return Ok(())\n+        }\n+\n+        self.bump(); // `+`\n+        let bounds = self.parse_ty_param_bounds()?;\n+        let sum_span = mk_sp(ty.span.lo, self.prev_span.hi);\n+\n+        let mut err = struct_span_err!(self.sess.span_diagnostic, ty.span, E0178,\n+            \"expected a path on the left-hand side of `+`, not `{}`\", pprust::ty_to_string(&ty));\n+        err.span_label(ty.span, &format!(\"expected a path\"));\n+\n+        match ty.node {\n+            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n+                let sum_with_parens = pprust::to_string(|s| {\n+                    use print::pp::word;\n+                    use print::pprust::PrintState;\n+\n+                    word(&mut s.s, \"&\")?;\n+                    s.print_opt_lifetime(lifetime)?;\n+                    s.print_mutability(mut_ty.mutbl)?;\n+                    s.popen()?;\n+                    s.print_type(&mut_ty.ty)?;\n+                    s.print_bounds(\" +\", &bounds)?;\n+                    s.pclose()\n+                });\n+                err.span_suggestion(sum_span, \"try adding parentheses:\", sum_with_parens);\n+            }\n+            TyKind::Ptr(..) | TyKind::BareFn(..) => {\n+                help!(&mut err, \"perhaps you forgot parentheses?\");\n+            }\n+            _ => {}\n+        }\n+        err.emit();\n+        Ok(())\n+    }\n+\n+    fn parse_borrowed_pointee(&mut self) -> PResult<'a, TyKind> {\n+        let opt_lifetime = if self.check_lifetime() { Some(self.expect_lifetime()) } else { None };\n+        let mutbl = self.parse_mutability();\n         let ty = self.parse_ty_no_plus()?;\n         return Ok(TyKind::Rptr(opt_lifetime, MutTy { ty: ty, mutbl: mutbl }));\n     }\n@@ -1927,30 +1891,28 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse single lifetime 'a or nothing.\n-    pub fn eat_lifetime(&mut self) -> Option<Lifetime> {\n+    fn check_lifetime(&mut self) -> bool {\n+        self.expected_tokens.push(TokenType::Lifetime);\n+        self.token.is_lifetime()\n+    }\n+\n+    /// Parse single lifetime 'a or panic.\n+    fn expect_lifetime(&mut self) -> Lifetime {\n         match self.token {\n             token::Lifetime(ident) => {\n                 self.bump();\n-                Some(Lifetime {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: self.prev_span,\n-                    name: ident.name\n-                })\n-            }\n-            _ => {\n-                self.expected_tokens.push(TokenType::Lifetime);\n-                None\n+                Lifetime { name: ident.name, span: self.prev_span, id: ast::DUMMY_NODE_ID }\n             }\n+            _ => self.span_bug(self.span, \"not a lifetime\")\n         }\n     }\n \n     /// Parse mutability (`mut` or nothing).\n-    pub fn parse_mutability(&mut self) -> PResult<'a, Mutability> {\n+    fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(keywords::Mut) {\n-            Ok(Mutability::Mutable)\n+            Mutability::Mutable\n         } else {\n-            Ok(Mutability::Immutable)\n+            Mutability::Immutable\n         }\n     }\n \n@@ -2207,7 +2169,7 @@ impl<'a> Parser<'a> {\n                     return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n-                    let label = Spanned { node: self.get_lifetime(),\n+                    let label = Spanned { node: self.get_label(),\n                                           span: self.span };\n                     let lo = self.span.lo;\n                     self.bump();\n@@ -2230,7 +2192,7 @@ impl<'a> Parser<'a> {\n                 if self.eat_keyword(keywords::Continue) {\n                     let ex = if self.token.is_lifetime() {\n                         let ex = ExprKind::Continue(Some(Spanned{\n-                            node: self.get_lifetime(),\n+                            node: self.get_label(),\n                             span: self.span\n                         }));\n                         self.bump();\n@@ -2267,7 +2229,7 @@ impl<'a> Parser<'a> {\n                 } else if self.eat_keyword(keywords::Break) {\n                     let lt = if self.token.is_lifetime() {\n                         let spanned_lt = Spanned {\n-                            node: self.get_lifetime(),\n+                            node: self.get_label(),\n                             span: self.span\n                         };\n                         self.bump();\n@@ -2700,7 +2662,7 @@ impl<'a> Parser<'a> {\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 self.expect_and()?;\n-                let m = self.parse_mutability()?;\n+                let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 hi = span.hi;\n@@ -3422,7 +3384,7 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::And) | token::AndAnd => {\n                 // Parse &pat / &mut pat\n                 self.expect_and()?;\n-                let mutbl = self.parse_mutability()?;\n+                let mutbl = self.parse_mutability();\n                 if let token::Lifetime(ident) = self.token {\n                     return Err(self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", ident)));\n                 }\n@@ -3449,7 +3411,7 @@ impl<'a> Parser<'a> {\n                 pat = self.parse_pat_ident(BindingMode::ByValue(Mutability::Mutable))?;\n             } else if self.eat_keyword(keywords::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n-                let mutbl = self.parse_mutability()?;\n+                let mutbl = self.parse_mutability();\n                 pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n             } else if self.eat_keyword(keywords::Box) {\n                 // Parse box pat\n@@ -4069,43 +4031,49 @@ impl<'a> Parser<'a> {\n     // BOUND = TY_BOUND | LT_BOUND\n     // LT_BOUND = LIFETIME (e.g. `'a`)\n     // TY_BOUND = [?] [for<LT_PARAM_DEFS>] SIMPLE_PATH (e.g. `?for<'a: 'b> m::Trait<'a>`)\n-    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds>\n-    {\n+    fn parse_ty_param_bounds_common(&mut self, allow_plus: bool) -> PResult<'a, TyParamBounds> {\n         let mut bounds = Vec::new();\n         loop {\n             let question = if self.eat(&token::Question) { Some(self.prev_span) } else { None };\n-            if let Some(lifetime) = self.eat_lifetime() {\n+            if self.check_lifetime() {\n                 if let Some(question_span) = question {\n                     self.span_err(question_span,\n                                   \"`?` may only modify trait bounds, not lifetime bounds\");\n                 }\n-                bounds.push(RegionTyParamBound(lifetime));\n-            } else {if self.check_keyword(keywords::For) || self.check_path() {\n-                let poly_trait_ref = self.parse_poly_trait_ref()?;\n+                bounds.push(RegionTyParamBound(self.expect_lifetime()));\n+            } else if self.check_keyword(keywords::For) || self.check_path() {\n+                let lo = self.span.lo;\n+                let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n+                let path = self.parse_path(PathStyle::Type)?;\n+                let poly_trait = PolyTraitRef::new(lifetime_defs, path, lo, self.prev_span.hi);\n                 let modifier = if question.is_some() {\n                     TraitBoundModifier::Maybe\n                 } else {\n                     TraitBoundModifier::None\n                 };\n-                bounds.push(TraitTyParamBound(poly_trait_ref, modifier));\n+                bounds.push(TraitTyParamBound(poly_trait, modifier));\n             } else {\n                 break\n-            }}\n+            }\n \n-            if !self.eat(&token::BinOp(token::Plus)) {\n+            if !allow_plus || !self.eat(&token::BinOp(token::Plus)) {\n                 break\n             }\n         }\n \n         return Ok(bounds);\n     }\n \n+    fn parse_ty_param_bounds(&mut self) -> PResult<'a, TyParamBounds> {\n+        self.parse_ty_param_bounds_common(true)\n+    }\n+\n     // Parse bounds of a type parameter `BOUND + BOUND + BOUND` without trailing `+`.\n     // BOUND = LT_BOUND (e.g. `'a`)\n     fn parse_lt_param_bounds(&mut self) -> Vec<Lifetime> {\n         let mut lifetimes = Vec::new();\n-        while let Some(lifetime) = self.eat_lifetime() {\n-            lifetimes.push(lifetime);\n+        while self.check_lifetime() {\n+            lifetimes.push(self.expect_lifetime());\n \n             if !self.eat(&token::BinOp(token::Plus)) {\n                 break\n@@ -4150,7 +4118,8 @@ impl<'a> Parser<'a> {\n         let mut seen_ty_param = false;\n         loop {\n             let attrs = self.parse_outer_attributes()?;\n-            if let Some(lifetime) = self.eat_lifetime() {\n+            if self.check_lifetime() {\n+                let lifetime = self.expect_lifetime();\n                 // Parse lifetime parameter.\n                 let bounds = if self.eat(&token::Colon) {\n                     self.parse_lt_param_bounds()\n@@ -4166,7 +4135,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n                 }\n-            } else {if self.check_ident() {\n+            } else if self.check_ident() {\n                 // Parse type parameter.\n                 ty_params.push(self.parse_ty_param(attrs)?);\n                 seen_ty_param = true;\n@@ -4178,7 +4147,7 @@ impl<'a> Parser<'a> {\n                         &format!(\"trailing attribute after {} parameters\", param_kind));\n                 }\n                 break\n-            }}\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break\n@@ -4224,14 +4193,14 @@ impl<'a> Parser<'a> {\n         let mut seen_type = false;\n         let mut seen_binding = false;\n         loop {\n-            if let Some(lifetime) = self.eat_lifetime() {\n+            if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n                 // Parse lifetime argument.\n-                lifetimes.push(lifetime);\n+                lifetimes.push(self.expect_lifetime());\n                 if seen_type || seen_binding {\n                     self.span_err(self.prev_span,\n                         \"lifetime parameters must be declared prior to type parameters\");\n                 }\n-            } else {if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n+            } else if self.check_ident() && self.look_ahead(1, |t| t == &token::Eq) {\n                 // Parse associated type binding.\n                 let lo = self.span.lo;\n                 let ident = self.parse_ident()?;\n@@ -4254,7 +4223,7 @@ impl<'a> Parser<'a> {\n                 seen_type = true;\n             } else {\n                 break\n-            }}\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break\n@@ -4299,7 +4268,8 @@ impl<'a> Parser<'a> {\n \n         loop {\n             let lo = self.span.lo;\n-            if let Some(lifetime) = self.eat_lifetime() {\n+            if self.check_lifetime() && self.look_ahead(1, |t| t != &token::BinOp(token::Plus)) {\n+                let lifetime = self.expect_lifetime();\n                 // Bounds starting with a colon are mandatory, but possibly empty.\n                 self.expect(&token::Colon)?;\n                 let bounds = self.parse_lt_param_bounds();\n@@ -4310,7 +4280,7 @@ impl<'a> Parser<'a> {\n                         bounds: bounds,\n                     }\n                 ));\n-            } else {if self.check_type() {\n+            } else if self.check_type() {\n                 // Parse optional `for<'a, 'b>`.\n                 // This `for` is parsed greedily and applies to the whole predicate,\n                 // the bounded type can have its own `for` applying only to it.\n@@ -4348,7 +4318,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 break\n-            }}\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break\n@@ -4453,13 +4423,13 @@ impl<'a> Parser<'a> {\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n-                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n+                    let lt = self.expect_lifetime();\n                     (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n-                    let lt = self.eat_lifetime().expect(\"not a lifetime\");\n+                    let lt = self.expect_lifetime();\n                     self.bump();\n                     (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n@@ -4852,14 +4822,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a::B<String,i32>\n-    fn parse_trait_ref(&mut self) -> PResult<'a, TraitRef> {\n-        Ok(TraitRef {\n-            path: self.parse_path(PathStyle::Type)?,\n-            ref_id: ast::DUMMY_NODE_ID,\n-        })\n-    }\n-\n     fn parse_late_bound_lifetime_defs(&mut self) -> PResult<'a, Vec<LifetimeDef>> {\n         if self.eat_keyword(keywords::For) {\n             self.expect_lt()?;\n@@ -4875,18 +4837,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse for<'l> a::B<String,i32>\n-    fn parse_poly_trait_ref(&mut self) -> PResult<'a, PolyTraitRef> {\n-        let lo = self.span.lo;\n-        let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-\n-        Ok(PolyTraitRef {\n-            bound_lifetimes: lifetime_defs,\n-            trait_ref: self.parse_trait_ref()?,\n-            span: mk_sp(lo, self.prev_span.hi),\n-        })\n-    }\n-\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = self.parse_ident()?;"}, {"sha": "519d5bd98e47fff701afff2a15a139b905f0b817", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -103,6 +103,21 @@ fn ident_can_begin_expr(ident: ast::Ident) -> bool {\n     ].contains(&ident.name)\n }\n \n+fn ident_can_begin_type(ident: ast::Ident) -> bool {\n+    let ident_token: Token = Ident(ident);\n+\n+    !ident_token.is_any_keyword() ||\n+    ident_token.is_path_segment_keyword() ||\n+    [\n+        keywords::For.name(),\n+        keywords::Impl.name(),\n+        keywords::Fn.name(),\n+        keywords::Unsafe.name(),\n+        keywords::Extern.name(),\n+        keywords::Typeof.name(),\n+    ].contains(&ident.name)\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug)]\n pub enum Token {\n     /* Expression-operator symbols. */\n@@ -182,23 +197,21 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of an expression.\n     pub fn can_begin_expr(&self) -> bool {\n         match *self {\n-            OpenDelim(..)               => true,\n-            Ident(ident)                => ident_can_begin_expr(ident),\n-            Literal(..)                 => true,\n-            Not                         => true,\n-            BinOp(Minus)                => true,\n-            BinOp(Star)                 => true,\n-            BinOp(And)                  => true,\n-            BinOp(Or)                   => true, // in lambda syntax\n-            OrOr                        => true, // in lambda syntax\n-            AndAnd                      => true, // double borrow\n+            Ident(ident)                => ident_can_begin_expr(ident), // value name or keyword\n+            OpenDelim(..)               => true, // tuple, array or block\n+            Literal(..)                 => true, // literal\n+            Not                         => true, // operator not\n+            BinOp(Minus)                => true, // unary minus\n+            BinOp(Star)                 => true, // dereference\n+            BinOp(Or) | OrOr            => true, // closure\n+            BinOp(And)                  => true, // reference\n+            AndAnd                      => true, // double reference\n             DotDot | DotDotDot          => true, // range notation\n             Lt | BinOp(Shl)             => true, // associated path\n-            ModSep                      => true,\n-            Pound                       => true, // for expression attributes\n+            ModSep                      => true, // global path\n+            Pound                       => true, // expression attributes\n             Interpolated(ref nt) => match **nt {\n                 NtExpr(..) => true,\n-                NtIdent(..) => true,\n                 NtBlock(..) => true,\n                 NtPath(..) => true,\n                 _ => false,\n@@ -210,19 +223,20 @@ impl Token {\n     /// Returns `true` if the token can appear at the start of a type.\n     pub fn can_begin_type(&self) -> bool {\n         match *self {\n+            Ident(ident)                => ident_can_begin_type(ident), // type name or keyword\n             OpenDelim(Paren)            => true, // tuple\n             OpenDelim(Bracket)          => true, // array\n-            Ident(..)                   => true, // type name or keyword\n             Underscore                  => true, // placeholder\n             Not                         => true, // never\n             BinOp(Star)                 => true, // raw pointer\n             BinOp(And)                  => true, // reference\n             AndAnd                      => true, // double reference\n+            Question                    => true, // maybe bound in trait object\n+            Lifetime(..)                => true, // lifetime bound in trait object\n             Lt | BinOp(Shl)             => true, // associated path\n             ModSep                      => true, // global path\n             Interpolated(ref nt) => match **nt {\n                 NtTy(..) => true,\n-                NtIdent(..) => true,\n                 NtPath(..) => true,\n                 _ => false,\n             },"}, {"sha": "6527465e0b7f74631c17a159fe5ca41f289b9cbb", "filename": "src/test/compile-fail/E0178.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2FE0178.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2FE0178.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0178.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -17,15 +17,12 @@ struct Bar<'a> {\n     x: &'a Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n-    //~| ERROR at least one non-builtin trait is required for an object type\n     y: &'a mut Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n-    //~| ERROR at least one non-builtin trait is required for an object type\n     z: fn() -> Foo + 'a,\n     //~^ ERROR E0178\n     //~| NOTE expected a path\n-    //~| ERROR at least one non-builtin trait is required for an object type\n }\n \n fn main() {"}, {"sha": "95b5fabc81e4f0e2930023e38f4b2f237d098122", "filename": "src/test/compile-fail/issue-34334.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-34334.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main () {\n-    let sr: Vec<(u32, _, _) = vec![]; //~ ERROR expected one of `+`, `,`, or `>`, found `=`\n+    let sr: Vec<(u32, _, _) = vec![]; //~ ERROR expected one of `,` or `>`, found `=`\n     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_receiver)| {}).collect();\n     //~^ ERROR cannot find value `sr` in this scope\n }"}, {"sha": "208f1a0e2ee259403fd7c75142f2d07eacc82013", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -11,6 +11,6 @@\n mod foo {\n     type T = ();\n     struct S1(pub(foo) (), pub(T), pub(crate) (), pub(((), T)));\n-    struct S2(pub((foo)) ()); //~ ERROR expected one of `+` or `,`, found `(`\n-                              //~| ERROR expected one of `+`, `;`, or `where`, found `(`\n+    struct S2(pub((foo)) ()); //~ ERROR expected `,`, found `(`\n+                              //~| ERROR expected one of `;` or `where`, found `(`\n }"}, {"sha": "57769646e3b8f2de2118f7357fc13f9278df75e0", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest2.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -12,8 +12,8 @@ macro_rules! define_struct {\n     ($t:ty) => {\n         struct S1(pub $t);\n         struct S2(pub (foo) ());\n-        struct S3(pub $t ()); //~ ERROR expected one of `+` or `,`, found `(`\n-                              //~| ERROR expected one of `+`, `;`, or `where`, found `(`\n+        struct S3(pub $t ()); //~ ERROR expected `,`, found `(`\n+                              //~| ERROR expected one of `;` or `where`, found `(`\n     }\n }\n "}, {"sha": "db3358f7d50aec95f39d29f4ff2733c4544cea6c", "filename": "src/test/compile-fail/privacy/restricted/tuple-struct-fields/test3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Frestricted%2Ftuple-struct-fields%2Ftest3.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -12,8 +12,8 @@ macro_rules! define_struct {\n     ($t:ty) => {\n         struct S1(pub($t));\n         struct S2(pub (foo) ());\n-        struct S3(pub($t) ()); //~ ERROR expected one of `+` or `,`, found `(`\n-                               //~| ERROR expected one of `+`, `;`, or `where`, found `(`\n+        struct S3(pub($t) ()); //~ ERROR expected `,`, found `(`\n+                               //~| ERROR expected one of `;` or `where`, found `(`\n     }\n }\n "}, {"sha": "de80b04b86568639f5d3578edbb0283d605444b2", "filename": "src/test/compile-fail/trait-object-macro-matcher.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-macro-matcher.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// `ty` matcher accepts trait object types\n+\n+macro_rules! m {\n+    ($t: ty) => ( let _: $t; )\n+}\n+\n+fn main() {\n+    m!(Copy + Send + 'static); //~ ERROR the trait `std::marker::Copy` cannot be made into an object\n+}"}, {"sha": "f9f887b78b0d8d1802aa0e6ac016ca1615714cee", "filename": "src/test/compile-fail/trait-object-reference-without-parens-suggestion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-object-reference-without-parens-suggestion.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -13,10 +13,9 @@ fn main() {\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &(Copy + 'static);\n-    //~| ERROR at least one non-builtin trait is required for an object type\n+    //~| ERROR the trait `std::marker::Copy` cannot be made into an object\n     let _: &'static Copy + 'static;\n     //~^ ERROR expected a path\n     //~| HELP try adding parentheses\n     //~| SUGGESTION let _: &'static (Copy + 'static);\n-    //~| ERROR at least one non-builtin trait is required for an object type\n }"}, {"sha": "ad59d4a52d74c44824fb4a3a7ab5d4d1e6639163", "filename": "src/test/parse-fail/bounds-obj-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fbounds-obj-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fbounds-obj-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbounds-obj-parens.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -10,6 +10,6 @@\n \n // compile-flags: -Z parse-only\n \n-type A = Box<(Fn(D::Error) -> E) + 'static + Send + Sync>; // OK\n+type A = Box<(Fn(D::Error) -> E) + 'static + Send + Sync>; // OK (but see #39318)\n \n FAIL //~ ERROR"}, {"sha": "a54d89f48c300e7dbc935762c8fb803ae9219ac8", "filename": "src/test/parse-fail/issue-17904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fissue-17904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-17904.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -13,6 +13,6 @@\n struct Baz<U> where U: Eq(U); //This is parsed as the new Fn* style parenthesis syntax.\n struct Baz<U> where U: Eq(U) -> R; // Notice this parses as well.\n struct Baz<U>(U) where U: Eq; // This rightfully signals no error as well.\n-struct Foo<T> where T: Copy, (T); //~ ERROR expected one of `+`, `:`, `==`, or `=`, found `;`\n+struct Foo<T> where T: Copy, (T); //~ ERROR expected one of `:`, `==`, or `=`, found `;`\n \n fn main() {}"}, {"sha": "b91ab8730b3dccfb83e4be47a47f9ed1d2bac5b3", "filename": "src/test/parse-fail/removed-syntax-ptr-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-ptr-lifetime.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type bptr = &lifetime/isize; //~ ERROR expected one of `!`, `(`, `+`, `::`, `;`, or `<`, found `/`\n+type bptr = &lifetime/isize; //~ ERROR expected one of `!`, `(`, `::`, `;`, or `<`, found `/`"}, {"sha": "8a47376179dfdab0f133b97400062c00026848db", "filename": "src/test/parse-fail/removed-syntax-uniq-mut-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fremoved-syntax-uniq-mut-ty.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -10,4 +10,4 @@\n \n // compile-flags: -Z parse-only\n \n-type mut_box = Box<mut isize>; //~ ERROR expected type, found keyword `mut`\n+type mut_box = Box<mut isize>; //~ ERROR expected one of `>`, lifetime, or type, found `mut`"}, {"sha": "4a2e6d5bdcd9c14f86f7293c528f39ad305128b3", "filename": "src/test/parse-fail/trailing-plus-in-bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrailing-plus-in-bounds.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -13,7 +13,7 @@\n use std::fmt::Debug;\n \n fn main() {\n-    let x: Box<Debug+> = box 3 as Box<Debug+>;\n-    //~^ ERROR at least one type parameter bound must be specified\n-    //~^^ ERROR at least one type parameter bound must be specified\n+    let x: Box<Debug+> = box 3 as Box<Debug+>; // Trailing `+` is OK\n }\n+\n+FAIL //~ ERROR"}, {"sha": "3a5bce509f10eb6a2927a8f6d61402748033aa2e", "filename": "src/test/parse-fail/trait-object-macro-matcher.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrait-object-macro-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrait-object-macro-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-macro-matcher.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A single lifetime is not parsed as a type.\n+// `ty` matcher in particular doesn't accept a single lifetime\n+\n+macro_rules! m {\n+    ($t: ty) => ( let _: $t; )\n+}\n+\n+fn main() {\n+    m!('static); //~ ERROR expected type, found `'static`\n+}"}, {"sha": "f0abc678c213062dafc397d3a225276226fdfa59", "filename": "src/test/parse-fail/trait-object-polytrait-priority.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrait-object-polytrait-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Fparse-fail%2Ftrait-object-polytrait-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-object-polytrait-priority.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait<'a> {}\n+\n+fn main() {\n+    let _: &for<'a> Trait<'a> + 'static;\n+    //~^ ERROR expected a path on the left-hand side of `+`, not `& for<'a>Trait<'a>`\n+    //~| NOTE expected a path\n+    //~| HELP try adding parentheses\n+    //~| SUGGESTION &( for<'a>Trait<'a> + 'static)\n+}"}, {"sha": "3165084b9e90d43795595e35fa150e05601a3c11", "filename": "src/test/run-pass/issue-28279.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Frun-pass%2Fissue-28279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5e889791a5ec8cb06224cf07273be8c84192698/src%2Ftest%2Frun-pass%2Fissue-28279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28279.rs?ref=b5e889791a5ec8cb06224cf07273be8c84192698", "patch": "@@ -18,7 +18,7 @@ fn test1() -> Rc<for<'a> Fn(&'a usize) + 'static> {\n     }\n }\n \n-fn test2() -> *mut for<'a> Fn(&'a usize) + 'static {\n+fn test2() -> *mut (for<'a> Fn(&'a usize) + 'static) {\n     if let Some(_) = Some(1) {\n         loop{}\n     } else {\n@@ -27,4 +27,3 @@ fn test2() -> *mut for<'a> Fn(&'a usize) + 'static {\n }\n \n fn main() {}\n-"}]}