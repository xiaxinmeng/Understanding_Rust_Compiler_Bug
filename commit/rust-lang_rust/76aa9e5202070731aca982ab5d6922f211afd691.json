{"sha": "76aa9e5202070731aca982ab5d6922f211afd691", "node_id": "C_kwDOAAsO6NoAKDc2YWE5ZTUyMDIwNzA3MzFhY2E5ODJhYjVkNjkyMmYyMTFhZmQ2OTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-04-24T22:10:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-24T22:10:59Z"}, "message": "Rollup merge of #95395 - compiler-errors:infer-on-impl-for-trait, r=oli-obk\n\nBetter error message for `_` in function signature in `impl Trait for Ty`\n\nProvides a replacement suggestion for when `_` is present in the function signature for `impl Trait for Ty`, using the substitutions from the trait to compute the exact type.\n\nFixes #95097", "tree": {"sha": "6c6898146ff02900fc232167a21b3728de226761", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c6898146ff02900fc232167a21b3728de226761"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76aa9e5202070731aca982ab5d6922f211afd691", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZcrzCRBK7hj4Ov3rIwAAtR4IAJ6pJvfgtRjT9c6EbMS7xRnk\nv6z8EZzvKAxRC1kQJrR7C6JCWbeSxsRLZ3hobQj/NmEVM+nljbi+uBJdy+CElaVl\nQ5BK1ytQHIHDCj25ewesqbxtkXWK3L0rYm8hCrFzaOh05Fz4+oFfzj+jntjrcIK8\n4uGu3Sju/ja0l/VrGa+U7soiYpnM6PWVe1n9TArCjdATb5Lk1TTkRNOPzB4Gy4VW\nHk4OQg6ZS/FvMPFoOR/+JU+UFbm1SA1xhBgGhx1sYUtaoWBdQtFRyo7ZZF6ilcDo\nfAuUyipUSsEKwmitvfowD07Mrr91LORZxJdMeTSOQ3mdSkTKppLhp0KifJWvM00=\n=5cLh\n-----END PGP SIGNATURE-----\n", "payload": "tree 6c6898146ff02900fc232167a21b3728de226761\nparent 18f314e7027fe7084aaab8620c624a0d7bd29e70\nparent 319fbe371d060baa8585a77cf6e2593854e089cf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1650838259 +0200\ncommitter GitHub <noreply@github.com> 1650838259 +0200\n\nRollup merge of #95395 - compiler-errors:infer-on-impl-for-trait, r=oli-obk\n\nBetter error message for `_` in function signature in `impl Trait for Ty`\n\nProvides a replacement suggestion for when `_` is present in the function signature for `impl Trait for Ty`, using the substitutions from the trait to compute the exact type.\n\nFixes #95097\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76aa9e5202070731aca982ab5d6922f211afd691", "html_url": "https://github.com/rust-lang/rust/commit/76aa9e5202070731aca982ab5d6922f211afd691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76aa9e5202070731aca982ab5d6922f211afd691/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f314e7027fe7084aaab8620c624a0d7bd29e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f314e7027fe7084aaab8620c624a0d7bd29e70", "html_url": "https://github.com/rust-lang/rust/commit/18f314e7027fe7084aaab8620c624a0d7bd29e70"}, {"sha": "319fbe371d060baa8585a77cf6e2593854e089cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/319fbe371d060baa8585a77cf6e2593854e089cf", "html_url": "https://github.com/rust-lang/rust/commit/319fbe371d060baa8585a77cf6e2593854e089cf"}], "stats": {"total": 332, "additions": 260, "deletions": 72}, "files": [{"sha": "1cd0ace8adb052ab23d242516c85198138156f60", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -2563,40 +2563,77 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         // We proactively collect all the inferred type params to emit a single error per fn def.\n         let mut visitor = HirPlaceholderCollector::default();\n-        for ty in decl.inputs {\n-            visitor.visit_ty(ty);\n-        }\n+        let mut infer_replacements = vec![];\n+\n         walk_generics(&mut visitor, generics);\n \n-        let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n+        let input_tys: Vec<_> = decl\n+            .inputs\n+            .iter()\n+            .enumerate()\n+            .map(|(i, a)| {\n+                if let hir::TyKind::Infer = a.kind && !self.allow_ty_infer() {\n+                    if let Some(suggested_ty) =\n+                        self.suggest_trait_fn_ty_for_impl_fn_infer(hir_id, Some(i))\n+                    {\n+                        infer_replacements.push((a.span, suggested_ty.to_string()));\n+                        return suggested_ty;\n+                    }\n+                }\n+\n+                // Only visit the type looking for `_` if we didn't fix the type above\n+                visitor.visit_ty(a);\n+                self.ty_of_arg(a, None)\n+            })\n+            .collect();\n+\n         let output_ty = match decl.output {\n             hir::FnRetTy::Return(output) => {\n-                visitor.visit_ty(output);\n-                self.ast_ty_to_ty(output)\n+                if let hir::TyKind::Infer = output.kind\n+                    && !self.allow_ty_infer()\n+                    && let Some(suggested_ty) =\n+                        self.suggest_trait_fn_ty_for_impl_fn_infer(hir_id, None)\n+                {\n+                    infer_replacements.push((output.span, suggested_ty.to_string()));\n+                    suggested_ty\n+                } else {\n+                    visitor.visit_ty(output);\n+                    self.ast_ty_to_ty(output)\n+                }\n             }\n             hir::FnRetTy::DefaultReturn(..) => tcx.mk_unit(),\n         };\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        let fn_ty = tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi);\n+        let fn_ty = tcx.mk_fn_sig(input_tys.into_iter(), output_ty, decl.c_variadic, unsafety, abi);\n         let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n \n-        if !self.allow_ty_infer() {\n+        if !self.allow_ty_infer() && !(visitor.0.is_empty() && infer_replacements.is_empty()) {\n             // We always collect the spans for placeholder types when evaluating `fn`s, but we\n             // only want to emit an error complaining about them if infer types (`_`) are not\n             // allowed. `allow_ty_infer` gates this behavior. We check for the presence of\n             // `ident_span` to not emit an error twice when we have `fn foo(_: fn() -> _)`.\n \n-            crate::collect::placeholder_type_error(\n+            let mut diag = crate::collect::placeholder_type_error_diag(\n                 tcx,\n                 ident_span.map(|sp| sp.shrink_to_hi()),\n                 generics.params,\n                 visitor.0,\n+                infer_replacements.iter().map(|(s, _)| *s).collect(),\n                 true,\n                 hir_ty,\n                 \"function\",\n             );\n+\n+            if !infer_replacements.is_empty() {\n+                diag.multipart_suggestion(&format!(\n+                    \"try replacing `_` with the type{} in the corresponding trait method signature\",\n+                    rustc_errors::pluralize!(infer_replacements.len()),\n+                ), infer_replacements, Applicability::MachineApplicable);\n+            }\n+\n+            diag.emit();\n         }\n \n         // Find any late-bound regions declared in return type that do\n@@ -2624,6 +2661,43 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bare_fn_ty\n     }\n \n+    /// Given a fn_hir_id for a impl function, suggest the type that is found on the\n+    /// corresponding function in the trait that the impl implements, if it exists.\n+    /// If arg_idx is Some, then it corresponds to an input type index, otherwise it\n+    /// corresponds to the return type.\n+    fn suggest_trait_fn_ty_for_impl_fn_infer(\n+        &self,\n+        fn_hir_id: hir::HirId,\n+        arg_idx: Option<usize>,\n+    ) -> Option<Ty<'tcx>> {\n+        let tcx = self.tcx();\n+        let hir = tcx.hir();\n+\n+        let hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), ident, .. }) =\n+            hir.get(fn_hir_id) else { return None };\n+        let hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(i), .. }) =\n+                hir.get(hir.get_parent_node(fn_hir_id)) else { bug!(\"ImplItem should have Impl parent\") };\n+\n+        let trait_ref =\n+            self.instantiate_mono_trait_ref(i.of_trait.as_ref()?, self.ast_ty_to_ty(i.self_ty));\n+\n+        let x: &ty::AssocItem = tcx.associated_items(trait_ref.def_id).find_by_name_and_kind(\n+            tcx,\n+            *ident,\n+            ty::AssocKind::Fn,\n+            trait_ref.def_id,\n+        )?;\n+\n+        let fn_sig = tcx.fn_sig(x.def_id).subst(\n+            tcx,\n+            trait_ref.substs.extend_to(tcx, x.def_id, |param, _| tcx.mk_param_from_def(param)),\n+        );\n+\n+        let ty = if let Some(arg_idx) = arg_idx { fn_sig.input(arg_idx) } else { fn_sig.output() };\n+\n+        Some(tcx.erase_late_bound_regions(ty))\n+    }\n+\n     fn validate_late_bound_regions(\n         &self,\n         constrained_regions: FxHashSet<ty::BoundRegionKind>,"}, {"sha": "be77bdb0bf5f06e3b16840f6ab2e67fed4489e28", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 107, "deletions": 45, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -160,6 +160,33 @@ crate fn placeholder_type_error<'tcx>(\n         return;\n     }\n \n+    placeholder_type_error_diag(\n+        tcx,\n+        span,\n+        generics,\n+        placeholder_types,\n+        vec![],\n+        suggest,\n+        hir_ty,\n+        kind,\n+    )\n+    .emit();\n+}\n+\n+crate fn placeholder_type_error_diag<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Option<Span>,\n+    generics: &[hir::GenericParam<'_>],\n+    placeholder_types: Vec<Span>,\n+    additional_spans: Vec<Span>,\n+    suggest: bool,\n+    hir_ty: Option<&hir::Ty<'_>>,\n+    kind: &'static str,\n+) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+    if placeholder_types.is_empty() {\n+        return bad_placeholder(tcx, additional_spans, kind);\n+    }\n+\n     let type_name = generics.next_type_param_name(None);\n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, (*type_name).to_string())).collect();\n@@ -182,7 +209,8 @@ crate fn placeholder_type_error<'tcx>(\n         sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n-    let mut err = bad_placeholder(tcx, placeholder_types, kind);\n+    let mut err =\n+        bad_placeholder(tcx, placeholder_types.into_iter().chain(additional_spans).collect(), kind);\n \n     // Suggest, but only if it is not a function in const or static\n     if suggest {\n@@ -218,7 +246,8 @@ crate fn placeholder_type_error<'tcx>(\n             );\n         }\n     }\n-    err.emit();\n+\n+    err\n }\n \n fn reject_placeholder_type_signatures_in_item<'tcx>(\n@@ -1868,50 +1897,17 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             generics,\n             ..\n         })\n-        | ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), ident, generics, .. })\n         | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n-            match get_infer_ret_ty(&sig.decl.output) {\n-                Some(ty) => {\n-                    let fn_sig = tcx.typeck(def_id).liberated_fn_sigs()[hir_id];\n-                    // Typeck doesn't expect erased regions to be returned from `type_of`.\n-                    let fn_sig = tcx.fold_regions(fn_sig, &mut false, |r, _| match *r {\n-                        ty::ReErased => tcx.lifetimes.re_static,\n-                        _ => r,\n-                    });\n-                    let fn_sig = ty::Binder::dummy(fn_sig);\n-\n-                    let mut visitor = HirPlaceholderCollector::default();\n-                    visitor.visit_ty(ty);\n-                    let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n-                    let ret_ty = fn_sig.skip_binder().output();\n-                    if !ret_ty.references_error() {\n-                        if !ret_ty.is_closure() {\n-                            let ret_ty_str = match ret_ty.kind() {\n-                                // Suggest a function pointer return type instead of a unique function definition\n-                                // (e.g. `fn() -> i32` instead of `fn() -> i32 { f }`, the latter of which is invalid\n-                                // syntax)\n-                                ty::FnDef(..) => ret_ty.fn_sig(tcx).to_string(),\n-                                _ => ret_ty.to_string(),\n-                            };\n-                            diag.span_suggestion(\n-                                ty.span,\n-                                \"replace with the correct return type\",\n-                                ret_ty_str,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n-                            // to prevent the user from getting a papercut while trying to use the unique closure\n-                            // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n-                            diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n-                            diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n-                        }\n-                    }\n-                    diag.emit();\n+            infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n+        }\n \n-                    fn_sig\n-                }\n-                None => <dyn AstConv<'_>>::ty_of_fn(\n+        ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), ident, generics, .. }) => {\n+            // Do not try to inference the return type for a impl method coming from a trait\n+            if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n+                tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n+                && i.of_trait.is_some()\n+            {\n+                <dyn AstConv<'_>>::ty_of_fn(\n                     &icx,\n                     hir_id,\n                     sig.header.unsafety,\n@@ -1920,7 +1916,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     generics,\n                     Some(ident.span),\n                     None,\n-                ),\n+                )\n+            } else {\n+                infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n             }\n         }\n \n@@ -1982,6 +1980,70 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     }\n }\n \n+fn infer_return_ty_for_fn_sig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sig: &hir::FnSig<'_>,\n+    ident: Ident,\n+    generics: &hir::Generics<'_>,\n+    def_id: LocalDefId,\n+    icx: &ItemCtxt<'tcx>,\n+) -> ty::PolyFnSig<'tcx> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    match get_infer_ret_ty(&sig.decl.output) {\n+        Some(ty) => {\n+            let fn_sig = tcx.typeck(def_id).liberated_fn_sigs()[hir_id];\n+            // Typeck doesn't expect erased regions to be returned from `type_of`.\n+            let fn_sig = tcx.fold_regions(fn_sig, &mut false, |r, _| match *r {\n+                ty::ReErased => tcx.lifetimes.re_static,\n+                _ => r,\n+            });\n+            let fn_sig = ty::Binder::dummy(fn_sig);\n+\n+            let mut visitor = HirPlaceholderCollector::default();\n+            visitor.visit_ty(ty);\n+            let mut diag = bad_placeholder(tcx, visitor.0, \"return type\");\n+            let ret_ty = fn_sig.skip_binder().output();\n+            if !ret_ty.references_error() {\n+                if !ret_ty.is_closure() {\n+                    let ret_ty_str = match ret_ty.kind() {\n+                        // Suggest a function pointer return type instead of a unique function definition\n+                        // (e.g. `fn() -> i32` instead of `fn() -> i32 { f }`, the latter of which is invalid\n+                        // syntax)\n+                        ty::FnDef(..) => ret_ty.fn_sig(tcx).to_string(),\n+                        _ => ret_ty.to_string(),\n+                    };\n+                    diag.span_suggestion(\n+                        ty.span,\n+                        \"replace with the correct return type\",\n+                        ret_ty_str,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    // We're dealing with a closure, so we should suggest using `impl Fn` or trait bounds\n+                    // to prevent the user from getting a papercut while trying to use the unique closure\n+                    // syntax (e.g. `[closure@src/lib.rs:2:5: 2:9]`).\n+                    diag.help(\"consider using an `Fn`, `FnMut`, or `FnOnce` trait bound\");\n+                    diag.note(\"for more information on `Fn` traits and closure types, see https://doc.rust-lang.org/book/ch13-01-closures.html\");\n+                }\n+            }\n+            diag.emit();\n+\n+            fn_sig\n+        }\n+        None => <dyn AstConv<'_>>::ty_of_fn(\n+            icx,\n+            hir_id,\n+            sig.header.unsafety,\n+            sig.header.abi,\n+            sig.decl,\n+            generics,\n+            Some(ident.span),\n+            None,\n+        ),\n+    }\n+}\n+\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n     match tcx.hir().expect_item(def_id.expect_local()).kind {"}, {"sha": "4963790c35de26101e74c9cfaf9f23e0e5a8828a", "filename": "src/test/ui/did_you_mean/replace-impl-infer-ty-from-trait.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.fixed?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+trait Foo<T>: Sized {\n+    fn bar(i: i32, t: T, s: &Self) -> (T, i32);\n+}\n+\n+impl Foo<usize> for () {\n+    fn bar(i: i32, t: usize, s: &()) -> (usize, i32) {\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+        (1, 2)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ddf39c9c861973e65f309ae73d1627388aff40c8", "filename": "src/test/ui/did_you_mean/replace-impl-infer-ty-from-trait.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.rs?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused)]\n+\n+trait Foo<T>: Sized {\n+    fn bar(i: i32, t: T, s: &Self) -> (T, i32);\n+}\n+\n+impl Foo<usize> for () {\n+    fn bar(i: _, t: _, s: _) -> _ {\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n+        (1, 2)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "730836a40c26a2d97f1a6a70b853ad6a28228e54", "filename": "src/test/ui/did_you_mean/replace-impl-infer-ty-from-trait.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Freplace-impl-infer-ty-from-trait.stderr?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -0,0 +1,18 @@\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n+  --> $DIR/replace-impl-infer-ty-from-trait.rs:9:15\n+   |\n+LL |     fn bar(i: _, t: _, s: _) -> _ {\n+   |               ^     ^     ^     ^ not allowed in type signatures\n+   |               |     |     |\n+   |               |     |     not allowed in type signatures\n+   |               |     not allowed in type signatures\n+   |               not allowed in type signatures\n+   |\n+help: try replacing `_` with the types in the corresponding trait method signature\n+   |\n+LL |     fn bar(i: i32, t: usize, s: &()) -> (usize, i32) {\n+   |               ~~~     ~~~~~     ~~~     ~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "22fedb22d66c6b9b2fe96046bbd9706889062493", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -57,7 +57,7 @@ unsafe fn test12(x: *const usize) -> *const *const _ {\n \n impl Clone for Test9 {\n     fn clone(&self) -> _ { Test9 }\n-    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+    //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n     fn clone_from(&mut self, other: _) { *self = Test9; }\n     //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n@@ -113,7 +113,7 @@ pub fn main() {\n \n     impl Clone for FnTest9 {\n         fn clone(&self) -> _ { FnTest9 }\n-        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for return types\n+        //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions\n \n         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n         //~^ ERROR the placeholder `_` is not allowed within types on item signatures for functions"}, {"sha": "3ea317dfb1a5d329a07c14569935f854b1a32861", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76aa9e5202070731aca982ab5d6922f211afd691/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=76aa9e5202070731aca982ab5d6922f211afd691", "patch": "@@ -545,25 +545,27 @@ help: use type parameters instead\n LL |     fn test10<T>(&self, _x : T) { }\n    |              +++             ~\n \n-error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:59:24\n    |\n LL |     fn clone(&self) -> _ { Test9 }\n-   |                        ^\n-   |                        |\n-   |                        not allowed in type signatures\n-   |                        help: replace with the correct return type: `Test9`\n+   |                        ^ not allowed in type signatures\n+   |\n+help: try replacing `_` with the type in the corresponding trait method signature\n+   |\n+LL |     fn clone(&self) -> Test9 { Test9 }\n+   |                        ~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:62:37\n    |\n LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n    |                                     ^ not allowed in type signatures\n    |\n-help: use type parameters instead\n+help: try replacing `_` with the type in the corresponding trait method signature\n    |\n-LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n-   |                  +++                   ~\n+LL |     fn clone_from(&mut self, other: &Test9) { *self = Test9; }\n+   |                                     ~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/typeck_type_placeholder_item.rs:107:31\n@@ -585,25 +587,27 @@ help: use type parameters instead\n LL |         fn fn_test10<T>(&self, _x : T) { }\n    |                     +++             ~\n \n-error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n+error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:115:28\n    |\n LL |         fn clone(&self) -> _ { FnTest9 }\n-   |                            ^\n-   |                            |\n-   |                            not allowed in type signatures\n-   |                            help: replace with the correct return type: `FnTest9`\n+   |                            ^ not allowed in type signatures\n+   |\n+help: try replacing `_` with the type in the corresponding trait method signature\n+   |\n+LL |         fn clone(&self) -> FnTest9 { FnTest9 }\n+   |                            ~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for functions\n   --> $DIR/typeck_type_placeholder_item.rs:118:41\n    |\n LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n    |                                         ^ not allowed in type signatures\n    |\n-help: use type parameters instead\n+help: try replacing `_` with the type in the corresponding trait method signature\n    |\n-LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n-   |                      +++                   ~\n+LL |         fn clone_from(&mut self, other: &FnTest9) { *self = FnTest9; }\n+   |                                         ~~~~~~~~\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for associated types\n   --> $DIR/typeck_type_placeholder_item.rs:201:14"}]}