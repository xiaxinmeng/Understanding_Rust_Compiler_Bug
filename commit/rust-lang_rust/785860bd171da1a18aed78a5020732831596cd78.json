{"sha": "785860bd171da1a18aed78a5020732831596cd78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NTg2MGJkMTcxZGExYTE4YWVkNzhhNTAyMDczMjgzMTU5NmNkNzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-16T22:42:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-16T22:42:54Z"}, "message": "Merge #6909\n\n6909: Avoid querying attributes in item tree lowering r=jonas-schievink a=jonas-schievink\n\nItemTree is per-file, so there is no unique crate associated with it.\r\nThis means that it cannot know the active CfgOptions and thus couldn't\r\nhandle `cfg_attr`.\r\n\r\nPrepare it for `cfg_attr`s by avoiding accessing attributes.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "da9ac7abc2f426dbe2783aa7a2a29e57d17cddf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da9ac7abc2f426dbe2783aa7a2a29e57d17cddf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/785860bd171da1a18aed78a5020732831596cd78", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf2o1uCRBK7hj4Ov3rIwAAdHIIAH5lZ3ITF2aGj6sLHgPesqxv\nEYGoleKSZatSHSx7uYrM17J5T3IE+1JX/Rljnc4aC2/S823+ZLn8NzxwoQahMQvh\nHszTg1v55RlJ510k7/KF6dKNHdwHZfEgY30Q89KTwNLDAGjz1bk0GIrLAYf38cgH\najgT3XdSkhhdpZW87zrqavirF4X+LjZ0/qDBYwKYmdx9DJN5jXegIyR0DHuhKIIj\nKliS12q6hgyeHn7tXmQgkEkFVEPcTyBkVmJ9c5kgN8g3LmfG+/8SCDXQkeP7ol66\nlTIQJgPPIdng90HfqbWnlWSyF7OlB4ZQUHjeOegflBOfxiUMSsxh+rPrgIEs1n8=\n=tCRF\n-----END PGP SIGNATURE-----\n", "payload": "tree da9ac7abc2f426dbe2783aa7a2a29e57d17cddf8\nparent 067067a6c11bb5afda98f5af14bfdec4744e7812\nparent 28b5334580e5814d102b006e310ca0d1f03cdd72\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608158574 +0000\ncommitter GitHub <noreply@github.com> 1608158574 +0000\n\nMerge #6909\n\n6909: Avoid querying attributes in item tree lowering r=jonas-schievink a=jonas-schievink\n\nItemTree is per-file, so there is no unique crate associated with it.\r\nThis means that it cannot know the active CfgOptions and thus couldn't\r\nhandle `cfg_attr`.\r\n\r\nPrepare it for `cfg_attr`s by avoiding accessing attributes.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/785860bd171da1a18aed78a5020732831596cd78", "html_url": "https://github.com/rust-lang/rust/commit/785860bd171da1a18aed78a5020732831596cd78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/785860bd171da1a18aed78a5020732831596cd78/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "067067a6c11bb5afda98f5af14bfdec4744e7812", "url": "https://api.github.com/repos/rust-lang/rust/commits/067067a6c11bb5afda98f5af14bfdec4744e7812", "html_url": "https://github.com/rust-lang/rust/commit/067067a6c11bb5afda98f5af14bfdec4744e7812"}, {"sha": "28b5334580e5814d102b006e310ca0d1f03cdd72", "url": "https://api.github.com/repos/rust-lang/rust/commits/28b5334580e5814d102b006e310ca0d1f03cdd72", "html_url": "https://github.com/rust-lang/rust/commit/28b5334580e5814d102b006e310ca0d1f03cdd72"}], "stats": {"total": 66, "additions": 28, "deletions": 38}, "files": [{"sha": "b8e09e3af3138513977b95319b56074b34136d84", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=785860bd171da1a18aed78a5020732831596cd78", "patch": "@@ -646,12 +646,6 @@ pub struct MacroCall {\n pub struct MacroRules {\n     /// The name of the declared macro.\n     pub name: Name,\n-    /// Has `#[macro_export]`.\n-    pub is_export: bool,\n-    /// Has `#[macro_export(local_inner_macros)]`.\n-    pub is_local_inner: bool,\n-    /// Has `#[rustc_builtin_macro]`.\n-    pub is_builtin: bool,\n     pub ast_id: FileAstId<ast::MacroRules>,\n }\n \n@@ -660,8 +654,6 @@ pub struct MacroRules {\n pub struct MacroDef {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n-    /// Has `#[rustc_builtin_macro]`.\n-    pub is_builtin: bool,\n     pub ast_id: FileAstId<ast::MacroDef>,\n }\n "}, {"sha": "7de385ee83ecf8047daaa7c14c6d18538a3eb670", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=785860bd171da1a18aed78a5020732831596cd78", "patch": "@@ -539,39 +539,19 @@ impl Ctx {\n \n     fn lower_macro_rules(&mut self, m: &ast::MacroRules) -> Option<FileItemTreeId<MacroRules>> {\n         let name = m.name().map(|it| it.as_name())?;\n-        let attrs = Attrs::new(m, &self.hygiene);\n-\n         let ast_id = self.source_ast_id_map.ast_id(m);\n \n-        // FIXME: cfg_attr\n-        let export_attr = attrs.by_key(\"macro_export\");\n-\n-        let is_export = export_attr.exists();\n-        let is_local_inner = if is_export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    ident.text.contains(\"local_inner_macros\")\n-                }\n-                _ => false,\n-            })\n-        } else {\n-            false\n-        };\n-\n-        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        let res = MacroRules { name, is_export, is_builtin, is_local_inner, ast_id };\n+        let res = MacroRules { name, ast_id };\n         Some(id(self.data().macro_rules.alloc(res)))\n     }\n \n     fn lower_macro_def(&mut self, m: &ast::MacroDef) -> Option<FileItemTreeId<MacroDef>> {\n         let name = m.name().map(|it| it.as_name())?;\n-        let attrs = Attrs::new(m, &self.hygiene);\n \n         let ast_id = self.source_ast_id_map.ast_id(m);\n         let visibility = self.lower_visibility(m);\n \n-        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-        let res = MacroDef { name, is_builtin, ast_id, visibility };\n+        let res = MacroDef { name, ast_id, visibility };\n         Some(id(self.data().macro_defs.alloc(res)))\n     }\n "}, {"sha": "1936348fb43b74bc465cc275a056a71e578e6572", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/785860bd171da1a18aed78a5020732831596cd78/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=785860bd171da1a18aed78a5020732831596cd78", "patch": "@@ -26,7 +26,8 @@ use crate::{\n     db::DefDatabase,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n-        self, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind, StructDefKind,\n+        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind,\n+        StructDefKind,\n     },\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n@@ -967,14 +968,15 @@ impl ModCollector<'_, '_> {\n                     })\n                 }\n                 ModItem::MacroCall(mac) => self.collect_macro_call(&self.item_tree[mac]),\n-                ModItem::MacroRules(mac) => self.collect_macro_rules(&self.item_tree[mac]),\n+                ModItem::MacroRules(id) => self.collect_macro_rules(id),\n                 ModItem::MacroDef(id) => {\n                     let mac = &self.item_tree[id];\n                     let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n \n                     // \"Macro 2.0\" is not currently supported by rust-analyzer, but libcore uses it\n                     // to define builtin macros, so we support at least that part.\n-                    if mac.is_builtin {\n+                    let attrs = self.item_tree.attrs(ModItem::from(id).into());\n+                    if attrs.by_key(\"rustc_builtin_macro\").exists() {\n                         let krate = self.def_collector.def_map.krate;\n                         let macro_id = find_builtin_macro(&mac.name, krate, ast_id)\n                             .or_else(|| find_builtin_derive(&mac.name, krate, ast_id));\n@@ -1300,18 +1302,34 @@ impl ModCollector<'_, '_> {\n         self.def_collector.resolve_proc_macro(&macro_name);\n     }\n \n-    fn collect_macro_rules(&mut self, mac: &MacroRules) {\n+    fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {\n+        let mac = &self.item_tree[id];\n+        let attrs = self.item_tree.attrs(ModItem::from(id).into());\n         let ast_id = InFile::new(self.file_id, mac.ast_id.upcast());\n \n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let is_export = export_attr.exists();\n+        let is_local_inner = if is_export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n         // Case 1: builtin macros\n-        if mac.is_builtin {\n+        if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             let krate = self.def_collector.def_map.krate;\n             if let Some(macro_id) = find_builtin_macro(&mac.name, krate, ast_id) {\n                 self.def_collector.define_macro(\n                     self.module_id,\n                     mac.name.clone(),\n                     macro_id,\n-                    mac.is_export,\n+                    is_export,\n                 );\n                 return;\n             }\n@@ -1322,9 +1340,9 @@ impl ModCollector<'_, '_> {\n             ast_id: Some(ast_id),\n             krate: self.def_collector.def_map.krate,\n             kind: MacroDefKind::Declarative,\n-            local_inner: mac.is_local_inner,\n+            local_inner: is_local_inner,\n         };\n-        self.def_collector.define_macro(self.module_id, mac.name.clone(), macro_id, mac.is_export);\n+        self.def_collector.define_macro(self.module_id, mac.name.clone(), macro_id, is_export);\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall) {"}]}