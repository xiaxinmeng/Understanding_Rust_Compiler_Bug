{"sha": "bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZDA0ODc2YjkzYWQ1YzAxM2Q5MGJjNDY5MzdlMjhiNmVlMWEzZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-11T11:36:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-11T11:36:39Z"}, "message": "Auto merge of #68126 - Centril:rollup-cz5u7xx, r=Centril\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #67756 (Collector tweaks)\n - #67889 (Compile some CGUs in parallel at the start of codegen)\n - #67930 (Rename Result::as_deref_ok to as_deref)\n - #68018 (feature_gate: Remove `GateStrength`)\n - #68070 (clean up E0185 explanation)\n - #68072 (Fix ICE #68058)\n - #68114 (Don't require `allow_internal_unstable` unless `staged_api` is enabled.)\n - #68120 (Ban `...X` pats, harden tests, and improve diagnostics)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fc35ad7fae01337e6873d43c00087dd53c3992db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc35ad7fae01337e6873d43c00087dd53c3992db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "html_url": "https://github.com/rust-lang/rust/commit/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543b7d97d019bff882cc70cf2f8bdc317e7b840f", "url": "https://api.github.com/repos/rust-lang/rust/commits/543b7d97d019bff882cc70cf2f8bdc317e7b840f", "html_url": "https://github.com/rust-lang/rust/commit/543b7d97d019bff882cc70cf2f8bdc317e7b840f"}, {"sha": "4eee796679bd13e0935c16f41a5e6e2ab0d5c018", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eee796679bd13e0935c16f41a5e6e2ab0d5c018", "html_url": "https://github.com/rust-lang/rust/commit/4eee796679bd13e0935c16f41a5e6e2ab0d5c018"}], "stats": {"total": 935, "additions": 528, "deletions": 407}, "files": [{"sha": "6c4956663841c21ce1217981d2f75ca3ddae862b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -70,7 +70,6 @@\n #![feature(bound_cloned)]\n #![feature(cfg_target_has_atomic)]\n #![feature(concat_idents)]\n-#![feature(const_fn)]\n #![feature(const_if_match)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]"}, {"sha": "c657ce33f60adccb380b82001affb7dfd59606ae", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1136,7 +1136,7 @@ impl<T: Deref, E> Result<T, E> {\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a reference to the\n     /// `Ok` type's `Deref::Target` type.\n-    pub fn as_deref_ok(&self) -> Result<&T::Target, &E> {\n+    pub fn as_deref(&self) -> Result<&T::Target, &E> {\n         self.as_ref().map(|t| t.deref())\n     }\n }\n@@ -1152,24 +1152,13 @@ impl<T, E: Deref> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n-impl<T: Deref, E: Deref> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&Result<T, E>`) to `Result<&T::Target, &E::Target>`.\n-    ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a reference to both\n-    /// the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref(&self) -> Result<&T::Target, &E::Target> {\n-        self.as_ref().map(|t| t.deref()).map_err(|e| e.deref())\n-    }\n-}\n-\n #[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n impl<T: DerefMut, E> Result<T, E> {\n     /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to `Result<&mut T::Target, &mut E>`.\n     ///\n     /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n     /// the `Ok` type's `Deref::Target` type.\n-    pub fn as_deref_mut_ok(&mut self) -> Result<&mut T::Target, &mut E> {\n+    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n }\n@@ -1185,18 +1174,6 @@ impl<T, E: DerefMut> Result<T, E> {\n     }\n }\n \n-#[unstable(feature = \"inner_deref\", reason = \"newly added\", issue = \"50264\")]\n-impl<T: DerefMut, E: DerefMut> Result<T, E> {\n-    /// Converts from `Result<T, E>` (or `&mut Result<T, E>`) to\n-    /// `Result<&mut T::Target, &mut E::Target>`.\n-    ///\n-    /// Leaves the original `Result` in-place, creating a new one containing a mutable reference to\n-    /// both the `Ok` and `Err` types' `Deref::Target` types.\n-    pub fn as_deref_mut(&mut self) -> Result<&mut T::Target, &mut E::Target> {\n-        self.as_mut().map(|t| t.deref_mut()).map_err(|e| e.deref_mut())\n-    }\n-}\n-\n impl<T, E> Result<Option<T>, E> {\n     /// Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n     ///"}, {"sha": "86cf6fc104c8390bc19e5a3baa4c6bfabd94763d", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -31,7 +31,6 @@\n #![feature(slice_internals)]\n #![feature(slice_partition_dedup)]\n #![feature(int_error_matching)]\n-#![feature(const_fn)]\n #![feature(array_value_iter)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]"}, {"sha": "c835313aae7037cd59860781dee296bc37fc3149", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 27, "deletions": 58, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -236,31 +236,17 @@ fn test_try() {\n \n #[test]\n fn test_result_as_deref() {\n-    // &Result<T: Deref, E>::Ok(T).as_deref_ok() ->\n+    // &Result<T: Deref, E>::Ok(T).as_deref() ->\n     //      Result<&T::Deref::Target, &E>::Ok(&*T)\n     let ref_ok = &Result::Ok::<&i32, u8>(&42);\n     let expected_result = Result::Ok::<&i32, &u8>(&42);\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n-    let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n-    let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n-    assert_eq!(ref_ok.as_deref_ok(), expected_result);\n-\n-    // &Result<T: Deref, E: Deref>::Ok(T).as_deref() ->\n-    //      Result<&T::Deref::Target, &E::Deref::Target>::Ok(&*T)\n-    let ref_ok = &Result::Ok::<&i32, &u8>(&42);\n-    let expected_result = Result::Ok::<&i32, &u8>(&42);\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    let ref_ok = &Result::Ok::<String, &u32>(String::from(\"a result\"));\n+    let ref_ok = &Result::Ok::<String, u32>(String::from(\"a result\"));\n     let expected_result = Result::Ok::<&str, &u32>(\"a result\");\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n-    let ref_ok = &Result::Ok::<Vec<i32>, &u32>(vec![1, 2, 3, 4, 5]);\n+    let ref_ok = &Result::Ok::<Vec<i32>, u32>(vec![1, 2, 3, 4, 5]);\n     let expected_result = Result::Ok::<&[i32], &u32>([1, 2, 3, 4, 5].as_slice());\n     assert_eq!(ref_ok.as_deref(), expected_result);\n \n@@ -281,19 +267,21 @@ fn test_result_as_deref() {\n     // &Result<T: Deref, E: Deref>::Err(T).as_deref_err() ->\n     //      Result<&T, &E::Deref::Target>::Err(&*E)\n     let ref_err = &Result::Err::<&u8, &i32>(&41);\n-    let expected_result = Result::Err::<&u8, &i32>(&41);\n+    let expected_result = Result::Err::<&u8, &&i32>(&&41);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n-    let ref_err = &Result::Err::<&u32, String>(String::from(\"an error\"));\n-    let expected_result = Result::Err::<&u32, &str>(\"an error\");\n+    let s = String::from(\"an error\");\n+    let ref_err = &Result::Err::<&u32, String>(s.clone());\n+    let expected_result = Result::Err::<&u32, &String>(&s);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n-    let ref_err = &Result::Err::<&u32, Vec<i32>>(vec![5, 4, 3, 2, 1]);\n-    let expected_result = Result::Err::<&u32, &[i32]>([5, 4, 3, 2, 1].as_slice());\n+    let v = vec![5, 4, 3, 2, 1];\n+    let ref_err = &Result::Err::<&u32, Vec<i32>>(v.clone());\n+    let expected_result = Result::Err::<&u32, &Vec<i32>>(&v);\n     assert_eq!(ref_err.as_deref(), expected_result);\n \n     // The following cases test calling `as_deref_*` with the wrong variant (i.e.\n-    // `as_deref_ok()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n+    // `as_deref()` with a `Result::Err()`, or `as_deref_err()` with a `Result::Ok()`.\n     // While uncommon, these cases are supported to ensure that an `as_deref_*`\n     // call can still be made even when one of the Result types does not implement\n     // `Deref` (for example, std::io::Error).\n@@ -312,56 +300,38 @@ fn test_result_as_deref() {\n     let expected_result = Result::Ok::<&[i32; 5], &u32>(&[1, 2, 3, 4, 5]);\n     assert_eq!(ref_ok.as_deref_err(), expected_result);\n \n-    // &Result<T: Deref, E>::Err(E).as_deref_ok() ->\n+    // &Result<T: Deref, E>::Err(E).as_deref() ->\n     //      Result<&T::Deref::Target, &E>::Err(&E)\n     let ref_err = &Result::Err::<&u8, i32>(41);\n     let expected_result = Result::Err::<&u8, &i32>(&41);\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, &str>(\"an error\");\n     let expected_result = Result::Err::<&u32, &&str>(&\"an error\");\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n \n     let ref_err = &Result::Err::<&u32, [i32; 5]>([5, 4, 3, 2, 1]);\n     let expected_result = Result::Err::<&u32, &[i32; 5]>(&[5, 4, 3, 2, 1]);\n-    assert_eq!(ref_err.as_deref_ok(), expected_result);\n+    assert_eq!(ref_err.as_deref(), expected_result);\n }\n \n #[test]\n fn test_result_as_deref_mut() {\n-    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut_ok() ->\n+    // &mut Result<T: Deref, E>::Ok(T).as_deref_mut() ->\n     //      Result<&mut T::Deref::Target, &mut E>::Ok(&mut *T)\n     let mut val = 42;\n     let mut expected_val = 42;\n     let mut_ok = &mut Result::Ok::<&mut i32, u8>(&mut val);\n     let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    let mut expected_string = String::from(\"a result\");\n-    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n-    let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    let mut expected_vec = vec![1, 2, 3, 4, 5];\n-    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n-    let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n-    assert_eq!(mut_ok.as_deref_mut_ok(), expected_result);\n-\n-    // &mut Result<T: Deref, E: Deref>::Ok(T).as_deref_mut() ->\n-    //      Result<&mut T::Deref::Target, &mut E::Deref::Target>::Ok(&mut *T)\n-    let mut val = 42;\n-    let mut expected_val = 42;\n-    let mut_ok = &mut Result::Ok::<&mut i32, &mut u8>(&mut val);\n-    let expected_result = Result::Ok::<&mut i32, &mut u8>(&mut expected_val);\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n     let mut expected_string = String::from(\"a result\");\n-    let mut_ok = &mut Result::Ok::<String, &mut u32>(expected_string.clone());\n+    let mut_ok = &mut Result::Ok::<String, u32>(expected_string.clone());\n     let expected_result = Result::Ok::<&mut str, &mut u32>(expected_string.deref_mut());\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n     let mut expected_vec = vec![1, 2, 3, 4, 5];\n-    let mut_ok = &mut Result::Ok::<Vec<i32>, &mut u32>(expected_vec.clone());\n+    let mut_ok = &mut Result::Ok::<Vec<i32>, u32>(expected_vec.clone());\n     let expected_result = Result::Ok::<&mut [i32], &mut u32>(expected_vec.as_mut_slice());\n     assert_eq!(mut_ok.as_deref_mut(), expected_result);\n \n@@ -386,23 +356,22 @@ fn test_result_as_deref_mut() {\n     // &mut Result<T: Deref, E: Deref>::Err(T).as_deref_mut_err() ->\n     //      Result<&mut T, &mut E::Deref::Target>::Err(&mut *E)\n     let mut val = 41;\n-    let mut expected_val = 41;\n-    let mut_err = &mut Result::Err::<&mut u8, &mut i32>(&mut val);\n-    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n+    let mut_err = &mut Result::Err::<&mut u8, i32>(val);\n+    let expected_result = Result::Err::<&mut u8, &mut i32>(&mut val);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_string = String::from(\"an error\");\n     let mut_err = &mut Result::Err::<&mut u32, String>(expected_string.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut str>(expected_string.as_mut_str());\n+    let expected_result = Result::Err::<&mut u32, &mut String>(&mut expected_string);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_vec = vec![5, 4, 3, 2, 1];\n     let mut_err = &mut Result::Err::<&mut u32, Vec<i32>>(expected_vec.clone());\n-    let expected_result = Result::Err::<&mut u32, &mut [i32]>(expected_vec.as_mut_slice());\n+    let expected_result = Result::Err::<&mut u32, &mut Vec<i32>>(&mut expected_vec);\n     assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     // The following cases test calling `as_deref_mut_*` with the wrong variant (i.e.\n-    // `as_deref_mut_ok()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n+    // `as_deref_mut()` with a `Result::Err()`, or `as_deref_mut_err()` with a `Result::Ok()`.\n     // While uncommon, these cases are supported to ensure that an `as_deref_mut_*`\n     // call can still be made even when one of the Result types does not implement\n     // `Deref` (for example, std::io::Error).\n@@ -426,22 +395,22 @@ fn test_result_as_deref_mut() {\n     let expected_result = Result::Ok::<&mut [i32; 5], &mut u32>(&mut expected_arr);\n     assert_eq!(mut_ok.as_deref_mut_err(), expected_result);\n \n-    // &mut Result<T: Deref, E>::Err(E).as_deref_mut_ok() ->\n+    // &mut Result<T: Deref, E>::Err(E).as_deref_mut() ->\n     //      Result<&mut T::Deref::Target, &mut E>::Err(&mut E)\n     let mut expected_val = 41;\n     let mut_err = &mut Result::Err::<&mut u8, i32>(expected_val.clone());\n     let expected_result = Result::Err::<&mut u8, &mut i32>(&mut expected_val);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let string = String::from(\"an error\");\n     let expected_string = string.clone();\n     let mut ref_str = expected_string.as_ref();\n     let mut_err = &mut Result::Err::<&mut u32, &str>(string.as_str());\n     let expected_result = Result::Err::<&mut u32, &mut &str>(&mut ref_str);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n \n     let mut expected_arr = [5, 4, 3, 2, 1];\n     let mut_err = &mut Result::Err::<&mut u32, [i32; 5]>(expected_arr.clone());\n     let expected_result = Result::Err::<&mut u32, &mut [i32; 5]>(&mut expected_arr);\n-    assert_eq!(mut_err.as_deref_mut_ok(), expected_result);\n+    assert_eq!(mut_err.as_deref_mut(), expected_result);\n }"}, {"sha": "c51db695a5b1581efd9e7bdd7c81bcffe34edfb6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -21,7 +21,6 @@\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(allow_internal_unstable)]\n-#![feature(const_fn)]\n #![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]"}, {"sha": "3c0160a04527e1381e31d8195bc695aba7b33ac4", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -31,7 +31,6 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(const_fn)]\n #![feature(const_transmute)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]"}, {"sha": "9a229e709a5e55dd911f1038b24db78f69687016", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -202,7 +202,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n-        hir::Expr { hir_id: self.lower_node_id(e.id), kind, span: e.span, attrs: e.attrs.clone() }\n+        hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            kind,\n+            span: e.span,\n+            attrs: e.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n+        }\n     }\n \n     fn lower_unop(&mut self, u: UnOp) -> hir::UnOp {"}, {"sha": "e6f4535a38dbaa51485404aacf676e994d767b92", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -8,37 +8,25 @@ use rustc_span::Span;\n use syntax::ast::{self, AssocTyConstraint, AssocTyConstraintKind, NodeId};\n use syntax::ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n use syntax::attr;\n-use syntax::sess::{feature_err, leveled_feature_err, GateStrength, ParseSess};\n+use syntax::sess::{feature_err, feature_err_issue, ParseSess};\n use syntax::visit::{self, FnKind, Visitor};\n \n use log::debug;\n \n macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $level: expr) => {{\n-        let (cx, has_feature, span, name, explain, level) =\n-            (&*$cx, $has_feature, $span, $name, $explain, $level);\n+    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (cx, has_feature, span, name, explain) = (&*$cx, $has_feature, $span, $name, $explain);\n         let has_feature: bool = has_feature(&$cx.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            leveled_feature_err(cx.parse_sess, name, span, GateIssue::Language, explain, level)\n-                .emit();\n+            feature_err_issue(cx.parse_sess, name, span, GateIssue::Language, explain).emit();\n         }\n     }};\n }\n \n-macro_rules! gate_feature {\n+macro_rules! gate_feature_post {\n     ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!(\n-            $cx,\n-            |x: &Features| x.$feature,\n-            $span,\n-            sym::$feature,\n-            $explain,\n-            GateStrength::Hard\n-        )\n-    };\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {\n-        gate_feature_fn!($cx, |x: &Features| x.$feature, $span, sym::$feature, $explain, $level)\n+        gate_feature_fn!($cx, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n }\n \n@@ -51,21 +39,6 @@ struct PostExpansionVisitor<'a> {\n     features: &'a Features,\n }\n \n-macro_rules! gate_feature_post {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {{\n-        let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx, $feature, span, $explain)\n-        }\n-    }};\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr, $level: expr) => {{\n-        let (cx, span) = ($cx, $span);\n-        if !span.allows_unstable(sym::$feature) {\n-            gate_feature!(cx, $feature, span, $explain, $level)\n-        }\n-    }};\n-}\n-\n impl<'a> PostExpansionVisitor<'a> {\n     fn check_abi(&self, abi: ast::StrLit) {\n         let ast::StrLit { symbol_unescaped, span, .. } = abi;\n@@ -257,15 +230,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name)).map(|a| **a);\n         // Check feature gates for built-in attributes.\n         if let Some((.., AttributeGate::Gated(_, name, descr, has_feature))) = attr_info {\n-            gate_feature_fn!(self, has_feature, attr.span, name, descr, GateStrength::Hard);\n+            gate_feature_fn!(self, has_feature, attr.span, name, descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n         if attr.check_name(sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n                     $(if nested_meta.check_name(sym::$name) {\n                         let msg = concat!(\"`#[doc(\", stringify!($name), \")]` is experimental\");\n-                        gate_feature!(self, $feature, attr.span, msg);\n+                        gate_feature_post!(self, $feature, attr.span, msg);\n                     })*\n                 }}\n \n@@ -666,7 +639,7 @@ pub fn check_crate(\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n             for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n-                gate_feature!(&visitor, $gate, *span, $msg);\n+                gate_feature_post!(&visitor, $gate, *span, $msg);\n             }\n         };\n     }\n@@ -688,7 +661,7 @@ pub fn check_crate(\n             // disabling these uses of early feature-gatings.\n             if false {\n                 for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n-                    gate_feature!(&visitor, $gate, *span, $msg);\n+                    gate_feature_post!(&visitor, $gate, *span, $msg);\n                 }\n             }\n         };"}, {"sha": "d3b524c1a1e70023fe3bd43eddd16a4244630d9c", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -13,7 +13,7 @@\n //!   but one `llvm::Type` corresponds to many `Ty`s; for instance, `tup(int, int,\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n-use super::{LlvmCodegenBackend, ModuleLlvm};\n+use super::ModuleLlvm;\n \n use crate::builder::Builder;\n use crate::common;\n@@ -29,7 +29,6 @@ use rustc::middle::exported_symbols;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::session::config::DebugInfo;\n use rustc::ty::TyCtxt;\n-use rustc_codegen_ssa::back::write::submit_codegened_module_to_llvm;\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n@@ -100,8 +99,7 @@ pub fn iter_globals(llmod: &'ll llvm::Module) -> ValueIter<'ll> {\n pub fn compile_codegen_unit(\n     tcx: TyCtxt<'tcx>,\n     cgu_name: Symbol,\n-    tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n-) {\n+) -> (ModuleCodegen<ModuleLlvm>, u64) {\n     let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n@@ -115,8 +113,6 @@ pub fn compile_codegen_unit(\n     // the time we needed for codegenning it.\n     let cost = time_to_codegen.as_secs() * 1_000_000_000 + time_to_codegen.subsec_nanos() as u64;\n \n-    submit_codegened_module_to_llvm(&LlvmCodegenBackend(()), tx_to_llvm_workers, module, cost);\n-\n     fn module_codegen(tcx: TyCtxt<'_>, cgu_name: Symbol) -> ModuleCodegen<ModuleLlvm> {\n         let cgu = tcx.codegen_unit(cgu_name);\n         // Instantiate monomorphizations without filling out definitions yet...\n@@ -164,6 +160,8 @@ pub fn compile_codegen_unit(\n             kind: ModuleKind::Regular,\n         }\n     }\n+\n+    (module, cost)\n }\n \n pub fn set_link_section(llval: &Value, attrs: &CodegenFnAttrs) {"}, {"sha": "a6168128c4d44611eb45a5be8f9234e687dfcfc8", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -19,6 +19,7 @@\n #![feature(link_args)]\n #![feature(static_nobundle)]\n #![feature(trusted_len)]\n+#![recursion_limit = \"256\"]\n \n use back::write::{create_informational_target_machine, create_target_machine};\n use rustc_span::symbol::Symbol;\n@@ -108,9 +109,8 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n         &self,\n         tcx: TyCtxt<'_>,\n         cgu_name: Symbol,\n-        tx: &std::sync::mpsc::Sender<Box<dyn Any + Send>>,\n-    ) {\n-        base::compile_codegen_unit(tcx, cgu_name, tx);\n+    ) -> (ModuleCodegen<ModuleLlvm>, u64) {\n+        base::compile_codegen_unit(tcx, cgu_name)\n     }\n     fn target_machine_factory(\n         &self,"}, {"sha": "efd560071202cd7aa1ebbc5cf6d3a32553933091", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -14,8 +14,8 @@\n //!   int)` and `rec(x=int, y=int, z=int)` will have the same `llvm::Type`.\n \n use crate::back::write::{\n-    start_async_codegen, submit_post_lto_module_to_llvm, submit_pre_lto_module_to_llvm,\n-    OngoingCodegen,\n+    start_async_codegen, submit_codegened_module_to_llvm, submit_post_lto_module_to_llvm,\n+    submit_pre_lto_module_to_llvm, OngoingCodegen,\n };\n use crate::common::{IntPredicate, RealPredicate, TypeKind};\n use crate::meth;\n@@ -40,6 +40,7 @@ use rustc::ty::{self, Instance, Ty, TyCtxt};\n use rustc_codegen_utils::{check_for_rustc_errors_attr, symbol_names_test};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::print_time_passes_entry;\n+use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_index::vec::Idx;\n@@ -606,20 +607,83 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         codegen_units\n     };\n \n-    let mut total_codegen_time = Duration::new(0, 0);\n+    let total_codegen_time = Lock::new(Duration::new(0, 0));\n \n-    for cgu in codegen_units.into_iter() {\n+    // The non-parallel compiler can only translate codegen units to LLVM IR\n+    // on a single thread, leading to a staircase effect where the N LLVM\n+    // threads have to wait on the single codegen threads to generate work\n+    // for them. The parallel compiler does not have this restriction, so\n+    // we can pre-load the LLVM queue in parallel before handing off\n+    // coordination to the OnGoingCodegen scheduler.\n+    //\n+    // This likely is a temporary measure. Once we don't have to support the\n+    // non-parallel compiler anymore, we can compile CGUs end-to-end in\n+    // parallel and get rid of the complicated scheduling logic.\n+    let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n+        if cfg!(parallel_compiler) {\n+            tcx.sess.time(\"compile_first_CGU_batch\", || {\n+                // Try to find one CGU to compile per thread.\n+                let cgus: Vec<_> = cgu_reuse\n+                    .iter()\n+                    .enumerate()\n+                    .filter(|&(_, reuse)| reuse == &CguReuse::No)\n+                    .take(tcx.sess.threads())\n+                    .collect();\n+\n+                // Compile the found CGUs in parallel.\n+                par_iter(cgus)\n+                    .map(|(i, _)| {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        (i, module)\n+                    })\n+                    .collect()\n+            })\n+        } else {\n+            FxHashMap::default()\n+        }\n+    };\n+\n+    let mut cgu_reuse = Vec::new();\n+    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n+\n+    for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        let cgu_reuse = determine_cgu_reuse(tcx, &cgu);\n+        // Do some setup work in the first iteration\n+        if pre_compiled_cgus.is_none() {\n+            // Calculate the CGU reuse\n+            cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n+                codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n+            });\n+            // Pre compile some CGUs\n+            pre_compiled_cgus = Some(pre_compile_cgus(&cgu_reuse));\n+        }\n+\n+        let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let start_time = Instant::now();\n-                backend.compile_codegen_unit(tcx, cgu.name(), &ongoing_codegen.coordinator_send);\n-                total_codegen_time += start_time.elapsed();\n+                let (module, cost) =\n+                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n+                        cgu\n+                    } else {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        module\n+                    };\n+                submit_codegened_module_to_llvm(\n+                    &backend,\n+                    &ongoing_codegen.coordinator_send,\n+                    module,\n+                    cost,\n+                );\n                 false\n             }\n             CguReuse::PreLto => {\n@@ -652,7 +716,11 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n+    print_time_passes_entry(\n+        tcx.sess.time_passes(),\n+        \"codegen_to_LLVM_IR\",\n+        total_codegen_time.into_inner(),\n+    );\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n "}, {"sha": "bc3a75250bf703f0b20606c8113c2f3831ea1979", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,5 +1,6 @@\n use super::write::WriteBackendMethods;\n use super::CodegenObject;\n+use crate::ModuleCodegen;\n \n use rustc::middle::cstore::EncodedMetadata;\n use rustc::session::{config, Session};\n@@ -10,7 +11,6 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_span::symbol::Symbol;\n use syntax::expand::allocator::AllocatorKind;\n \n-use std::sync::mpsc;\n use std::sync::Arc;\n \n pub trait BackendTypes {\n@@ -34,7 +34,7 @@ impl<'tcx, T> Backend<'tcx> for T where\n {\n }\n \n-pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n+pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send + Sync {\n     fn new_metadata(&self, sess: TyCtxt<'_>, mod_name: &str) -> Self::Module;\n     fn write_compressed_metadata<'tcx>(\n         &self,\n@@ -48,12 +48,13 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n+    /// This generates the codegen unit and returns it along with\n+    /// a `u64` giving an estimate of the unit's processing cost.\n     fn compile_codegen_unit(\n         &self,\n         tcx: TyCtxt<'_>,\n         cgu_name: Symbol,\n-        tx_to_llvm_workers: &mpsc::Sender<Box<dyn std::any::Any + Send>>,\n-    );\n+    ) -> (ModuleCodegen<Self::Module>, u64);\n     // If find_features is true this won't access `sess.crate_types` by assuming\n     // that `is_pie_binary` is false. When we discover LLVM target features\n     // `sess.crate_types` is uninitialized so we cannot access it."}, {"sha": "944a93ed14e6c699c7f9a1c10cbad556dfaa7273", "filename": "src/librustc_error_codes/error_codes/E0185.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -2,7 +2,7 @@ An associated function for a trait was defined to be static, but an\n implementation of the trait declared the same function to be a method (i.e., to\n take a `self` parameter).\n \n-Here's an example of this error:\n+Erroneous code example:\n \n ```compile_fail,E0185\n trait Foo {\n@@ -17,3 +17,19 @@ impl Foo for Bar {\n     fn foo(&self) {}\n }\n ```\n+\n+When a type implements a trait's associated function, it has to use the same\n+signature. So in this case, since `Foo::foo` does not take any argument and\n+does not return anything, its implementation on `Bar` should be the same:\n+\n+```\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo() {} // ok!\n+}\n+```"}, {"sha": "f54fa291bd6e81e7c3620a8f044864ebdf37d345", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -3,7 +3,7 @@\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/hir.html\n \n #![feature(crate_visibility_modifier)]\n-#![feature(const_fn)]\n+#![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(in_band_lifetimes)]\n #![feature(specialization)]\n #![recursion_limit = \"256\"]"}, {"sha": "d2565bf9c63d427270bd8b2eb45003b94000c6c5", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -13,7 +13,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(core_intrinsics)]\n-#![feature(const_fn)]\n #![feature(decl_macro)]\n #![feature(drain_filter)]\n #![feature(exhaustive_patterns)]"}, {"sha": "511a5fbc617951e94343a1cb6bc5ac8ba4cfab77", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -194,7 +194,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_index::bit_set::GrowableBitSet;\n-\n+use smallvec::SmallVec;\n use std::iter;\n \n #[derive(PartialEq)]\n@@ -227,28 +227,23 @@ impl<'tcx> InliningMap<'tcx> {\n         }\n     }\n \n-    fn record_accesses<I>(&mut self, source: MonoItem<'tcx>, new_targets: I)\n-    where\n-        I: Iterator<Item = (MonoItem<'tcx>, bool)> + ExactSizeIterator,\n-    {\n-        assert!(!self.index.contains_key(&source));\n-\n+    fn record_accesses(&mut self, source: MonoItem<'tcx>, new_targets: &[(MonoItem<'tcx>, bool)]) {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n         let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n         self.inlines.ensure(new_items_count_total);\n \n-        for (i, (target, inline)) in new_targets.enumerate() {\n-            self.targets.push(target);\n-            if inline {\n+        for (i, (target, inline)) in new_targets.iter().enumerate() {\n+            self.targets.push(*target);\n+            if *inline {\n                 self.inlines.insert(i + start_index);\n             }\n         }\n \n         let end_index = self.targets.len();\n-        self.index.insert(source, (start_index, end_index));\n+        assert!(self.index.insert(source, (start_index, end_index)).is_none());\n     }\n \n     // Internally iterate over all items referenced by `source` which will be\n@@ -403,10 +398,15 @@ fn record_accesses<'tcx>(\n         mono_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n-    let accesses =\n-        callees.into_iter().map(|mono_item| (*mono_item, is_inlining_candidate(mono_item)));\n+    // We collect this into a `SmallVec` to avoid calling `is_inlining_candidate` in the lock.\n+    // FIXME: Call `is_inlining_candidate` when pushing to `neighbors` in `collect_items_rec`\n+    // instead to avoid creating this `SmallVec`.\n+    let accesses: SmallVec<[_; 128]> = callees\n+        .into_iter()\n+        .map(|mono_item| (*mono_item, is_inlining_candidate(mono_item)))\n+        .collect();\n \n-    inlining_map.lock_mut().record_accesses(caller, accesses);\n+    inlining_map.lock_mut().record_accesses(caller, &accesses);\n }\n \n fn check_recursion_limit<'tcx>("}, {"sha": "0def51a6a33e5410a1adeffc0fa2a2d15d65a9b1", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -104,6 +104,7 @@ use rustc::ty::print::characteristic_def_id_of_type;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, DefIdTree, InstanceDef, TyCtxt};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_span::symbol::Symbol;\n@@ -796,6 +797,8 @@ where\n     I: Iterator<Item = &'a MonoItem<'tcx>>,\n     'tcx: 'a,\n {\n+    let _prof_timer = tcx.prof.generic_activity(\"assert_symbols_are_distinct\");\n+\n     let mut symbols: Vec<_> =\n         mono_items.map(|mono_item| (mono_item, mono_item.symbol_name(tcx))).collect();\n \n@@ -869,18 +872,23 @@ fn collect_and_partition_mono_items(\n \n     tcx.sess.abort_if_errors();\n \n-    assert_symbols_are_distinct(tcx, items.iter());\n-\n-    let strategy = if tcx.sess.opts.incremental.is_some() {\n-        PartitioningStrategy::PerModule\n-    } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n-    };\n-\n-    let codegen_units = partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n-        .into_iter()\n-        .map(Arc::new)\n-        .collect::<Vec<_>>();\n+    let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n+        sync::join(\n+            || {\n+                let strategy = if tcx.sess.opts.incremental.is_some() {\n+                    PartitioningStrategy::PerModule\n+                } else {\n+                    PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n+                };\n+\n+                partition(tcx, items.iter().cloned(), strategy, &inlining_map)\n+                    .into_iter()\n+                    .map(Arc::new)\n+                    .collect::<Vec<_>>()\n+            },\n+            || assert_symbols_are_distinct(tcx, items.iter()),\n+        )\n+    });\n \n     let mono_items: DefIdSet = items\n         .iter()"}, {"sha": "c2c1625001d0f1c452ce5f62c94ced0e07897768", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -281,8 +281,22 @@ fn check_place(\n     Ok(())\n }\n \n-/// Returns whether `allow_internal_unstable(..., <feature_gate>, ...)` is present.\n+/// Returns `true` if the given feature gate is allowed within the function with the given `DefId`.\n fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    // All features require that the corresponding gate be enabled,\n+    // even if the function has `#[allow_internal_unstable(the_gate)]`.\n+    if !tcx.features().enabled(feature_gate) {\n+        return false;\n+    }\n+\n+    // If this crate is not using stability attributes, or this function is not claiming to be a\n+    // stable `const fn`, that is all that is required.\n+    if !tcx.features().staged_api || tcx.has_attr(def_id, sym::rustc_const_unstable) {\n+        return true;\n+    }\n+\n+    // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n+    // opt-in via `allow_internal_unstable`.\n     attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }"}, {"sha": "dd2b6ab997196f7c65dc479aae921acbd474ea56", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1966,7 +1966,7 @@ impl<'a> Parser<'a> {\n         limits: RangeLimits,\n     ) -> PResult<'a, ExprKind> {\n         if end.is_none() && limits == RangeLimits::Closed {\n-            self.error_inclusive_range_with_no_end(self.token.span);\n+            self.error_inclusive_range_with_no_end(self.prev_span);\n             Ok(ExprKind::Err)\n         } else {\n             Ok(ExprKind::Range(start, end, limits))"}, {"sha": "0c2cfc20daf0fd1b8043badf7bb27337d81d6646", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -661,14 +661,34 @@ impl<'a> Parser<'a> {\n     pub(super) fn error_inclusive_range_with_no_end(&self, span: Span) {\n         use rustc_error_codes::E0586;\n         struct_span_err!(self.sess.span_diagnostic, span, E0586, \"inclusive range with no end\")\n-            .help(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\")\n+            .span_suggestion_short(\n+                span,\n+                \"use `..` instead\",\n+                \"..\".to_string(),\n+                Applicability::MachineApplicable,\n+            )\n+            .note(\"inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\")\n             .emit();\n     }\n \n-    /// Parse a range-to pattern, e.g. `..X` and `..=X` where `X` remains to be parsed.\n-    fn parse_pat_range_to(&mut self, re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n+    /// Parse a range-to pattern, `..X` or `..=X` where `X` remains to be parsed.\n+    ///\n+    /// The form `...X` is prohibited to reduce confusion with the potential\n+    /// expression syntax `...expr` for splatting in expressions.\n+    fn parse_pat_range_to(&mut self, mut re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n         let end = self.parse_pat_range_end()?;\n         self.sess.gated_spans.gate(sym::half_open_range_patterns, re.span.to(self.prev_span));\n+        if let RangeEnd::Included(ref mut syn @ RangeSyntax::DotDotDot) = &mut re.node {\n+            *syn = RangeSyntax::DotDotEq;\n+            self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n+                .span_suggestion_short(\n+                    re.span,\n+                    \"use `..=` instead\",\n+                    \"..=\".to_string(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n         Ok(PatKind::Range(None, Some(end), re))\n     }\n "}, {"sha": "a98cf929095ead3aa73ea261caace287291f0e14", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -62,16 +62,6 @@ impl GatedSpans {\n     }\n }\n \n-/// The strenght of a feature gate.\n-/// Either it is a `Hard` error, or only a `Soft` warning.\n-#[derive(Debug, Copy, Clone, PartialEq)]\n-pub enum GateStrength {\n-    /// A hard error. (Most feature gates should use this.)\n-    Hard,\n-    /// Only a warning. (Use this only as backwards-compatibility demands.)\n-    Soft,\n-}\n-\n /// Construct a diagnostic for a language feature error due to the given `span`.\n /// The `feature`'s `Symbol` is the one you used in `active.rs` and `rustc_span::symbols`.\n pub fn feature_err<'a>(\n@@ -94,26 +84,7 @@ pub fn feature_err_issue<'a>(\n     issue: GateIssue,\n     explain: &str,\n ) -> DiagnosticBuilder<'a> {\n-    leveled_feature_err(sess, feature, span, issue, explain, GateStrength::Hard)\n-}\n-\n-/// Construct a diagnostic for a feature gate error / warning.\n-///\n-/// You should typically just use `feature_err` instead.\n-pub fn leveled_feature_err<'a>(\n-    sess: &'a ParseSess,\n-    feature: Symbol,\n-    span: impl Into<MultiSpan>,\n-    issue: GateIssue,\n-    explain: &str,\n-    level: GateStrength,\n-) -> DiagnosticBuilder<'a> {\n-    let diag = &sess.span_diagnostic;\n-\n-    let mut err = match level {\n-        GateStrength::Hard => diag.struct_span_err_with_code(span, explain, error_code!(E0658)),\n-        GateStrength::Soft => diag.struct_span_warn(span, explain),\n-    };\n+    let mut err = sess.span_diagnostic.struct_span_err_with_code(span, explain, error_code!(E0658));\n \n     if let Some(n) = find_feature_issue(feature, issue) {\n         err.note(&format!(\n@@ -127,13 +98,6 @@ pub fn leveled_feature_err<'a>(\n         err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feature));\n     }\n \n-    // If we're on stable and only emitting a \"soft\" warning, add a note to\n-    // clarify that the feature isn't \"on\" (rather than being on but\n-    // warning-worthy).\n-    if !sess.unstable_features.is_nightly_build() && level == GateStrength::Soft {\n-        err.help(\"a nightly build of the compiler is required to enable this feature\");\n-    }\n-\n     err\n }\n "}, {"sha": "1dc7fc5aa3ad1aec7fa4b33d7cbbfdcf225ef5e7", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(const_fn)]\n #![feature(crate_visibility_modifier)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]"}, {"sha": "0fcbd4e0b58c61f7fd9fac0c5184a47708f8989d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -12,7 +12,6 @@\n #![feature(test)]\n #![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n-#![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(never_type)]\n #![feature(unicode_internals)]"}, {"sha": "0184a3214b5b4985748e5d17f6e99f4d52be8f35", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -7,7 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n-#![feature(const_fn)]\n+#![feature(const_fn)] // For the `transmute` in `P::new`\n #![feature(const_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]"}, {"sha": "99006a20b1bcba56dfe6275b847724ea47185cc1", "filename": "src/test/ui/consts/const-mut-refs/const_mut_refs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n \n #![feature(const_mut_refs)]\n-#![feature(const_fn)]\n \n struct Foo {\n     x: usize"}, {"sha": "6bbbdd972a26c102b243a275b71352ed823d4815", "filename": "src/test/ui/consts/control-flow/exhaustive-c-like-enum-match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -3,7 +3,6 @@\n // check-pass\n \n #![feature(const_if_match)]\n-#![feature(const_fn)]\n \n enum E {\n     A,"}, {"sha": "21e3f2af15ad6280ce4ca9b38300f7a023126f5f", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.if_match.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,5 +1,5 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/feature-gate-const-if-match.rs:109:1\n+  --> $DIR/feature-gate-const-if-match.rs:108:1\n    |\n LL | / fn main() {\n LL | |     let _ = [0; {"}, {"sha": "00576d50ac66b46f3af78f3fc08de759b9436ea6", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -6,7 +6,6 @@\n \n #![feature(rustc_attrs)]\n #![cfg_attr(if_match, feature(const_if_match))]\n-#![feature(const_fn)]\n \n const _: i32 = if true { //[stock]~ ERROR `if` is not allowed in a `const`\n     5"}, {"sha": "d3c6a51923ffb54317d6315399c92c61ba520b6e", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.stock.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:11:16\n+  --> $DIR/feature-gate-const-if-match.rs:10:16\n    |\n LL |   const _: i32 = if true {\n    |  ________________^\n@@ -13,7 +13,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:17:16\n+  --> $DIR/feature-gate-const-if-match.rs:16:16\n    |\n LL |   const _: i32 = if let Some(true) = Some(false) {\n    |  ________________^\n@@ -27,7 +27,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:23:16\n+  --> $DIR/feature-gate-const-if-match.rs:22:16\n    |\n LL |   const _: i32 = match 1 {\n    |  ________________^\n@@ -41,7 +41,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:30:13\n+  --> $DIR/feature-gate-const-if-match.rs:29:13\n    |\n LL |     let x = if true { 0 } else { 1 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -50,7 +50,7 @@ LL |     let x = if true { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:32:13\n+  --> $DIR/feature-gate-const-if-match.rs:31:13\n    |\n LL |     let x = match x { 0 => 1, _ => 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -59,7 +59,7 @@ LL |     let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:34:5\n+  --> $DIR/feature-gate-const-if-match.rs:33:5\n    |\n LL |     if let Some(x) = Some(x) { x } else { 1 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -68,7 +68,7 @@ LL |     if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:39:13\n+  --> $DIR/feature-gate-const-if-match.rs:38:13\n    |\n LL |     let x = if true { 0 } else { 1 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -77,7 +77,7 @@ LL |     let x = if true { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:41:13\n+  --> $DIR/feature-gate-const-if-match.rs:40:13\n    |\n LL |     let x = match x { 0 => 1, _ => 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -86,7 +86,7 @@ LL |     let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:43:5\n+  --> $DIR/feature-gate-const-if-match.rs:42:5\n    |\n LL |     if let Some(x) = Some(x) { x } else { 1 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -95,7 +95,7 @@ LL |     if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:48:5\n+  --> $DIR/feature-gate-const-if-match.rs:47:5\n    |\n LL |     if true { 5 } else { 6 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -104,7 +104,7 @@ LL |     if true { 5 } else { 6 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:52:5\n+  --> $DIR/feature-gate-const-if-match.rs:51:5\n    |\n LL | /     if let Some(true) = a {\n LL | |         0\n@@ -117,7 +117,7 @@ LL | |     }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:60:5\n+  --> $DIR/feature-gate-const-if-match.rs:59:5\n    |\n LL | /     match i {\n LL | |         i if i > 10 => i,\n@@ -130,7 +130,7 @@ LL | |     }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:91:17\n+  --> $DIR/feature-gate-const-if-match.rs:90:17\n    |\n LL |         let x = if y { 0 } else { 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n@@ -139,7 +139,7 @@ LL |         let x = if y { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:93:17\n+  --> $DIR/feature-gate-const-if-match.rs:92:17\n    |\n LL |         let x = match x { 0 => 1, _ => 0 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -148,7 +148,7 @@ LL |         let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:95:9\n+  --> $DIR/feature-gate-const-if-match.rs:94:9\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -157,7 +157,7 @@ LL |         if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:111:17\n+  --> $DIR/feature-gate-const-if-match.rs:110:17\n    |\n LL |         let x = if false { 0 } else { 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL |         let x = if false { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:113:17\n+  --> $DIR/feature-gate-const-if-match.rs:112:17\n    |\n LL |         let x = match x { 0 => 1, _ => 0 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -175,7 +175,7 @@ LL |         let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:115:9\n+  --> $DIR/feature-gate-const-if-match.rs:114:9\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -184,7 +184,7 @@ LL |         if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:68:21\n+  --> $DIR/feature-gate-const-if-match.rs:67:21\n    |\n LL |     const IF: i32 = if true { 5 } else { 6 };\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -193,7 +193,7 @@ LL |     const IF: i32 = if true { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:71:25\n+  --> $DIR/feature-gate-const-if-match.rs:70:25\n    |\n LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -202,7 +202,7 @@ LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:74:24\n+  --> $DIR/feature-gate-const-if-match.rs:73:24\n    |\n LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -211,7 +211,7 @@ LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:79:21\n+  --> $DIR/feature-gate-const-if-match.rs:78:21\n    |\n LL |     const IF: i32 = if true { 5 } else { 6 };\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -220,7 +220,7 @@ LL |     const IF: i32 = if true { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:82:25\n+  --> $DIR/feature-gate-const-if-match.rs:81:25\n    |\n LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -229,7 +229,7 @@ LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:85:24\n+  --> $DIR/feature-gate-const-if-match.rs:84:24\n    |\n LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -238,7 +238,7 @@ LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/feature-gate-const-if-match.rs:115:21\n+  --> $DIR/feature-gate-const-if-match.rs:114:21\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |                     ^"}, {"sha": "8cee2a54f56d3e4c08b1aeeeb272a068e9364959", "filename": "src/test/ui/consts/control-flow/short-circuit-let.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -4,7 +4,6 @@\n \n #![feature(const_if_match)]\n #![feature(const_panic)]\n-#![feature(const_fn)]\n \n const X: i32 = {\n     let mut x = 0;"}, {"sha": "823605ff034f10c8ca1c25bb2b53c6da78c021c8", "filename": "src/test/ui/consts/control-flow/single_variant_match_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(const_if_match, const_fn)]\n+#![feature(const_if_match)]\n \n enum Foo {\n     Prob,"}, {"sha": "0bbf9a6080349f4a0d4f6f135803f3538024fcd8", "filename": "src/test/ui/error-codes/E0586.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Ferror-codes%2FE0586.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Ferror-codes%2FE0586.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0586.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,10 +1,10 @@\n error[E0586]: inclusive range with no end\n-  --> $DIR/E0586.rs:3:22\n+  --> $DIR/E0586.rs:3:19\n    |\n LL |     let x = &tmp[1..=];\n-   |                      ^\n+   |                   ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: aborting due to previous error\n "}, {"sha": "1733012b9c54fb12283dcae2986fb0c82b1def0f", "filename": "src/test/ui/half-open-range-patterns/feature-gate-half-open-range-patterns.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -8,6 +8,7 @@ fn foo() {\n     //~^ ERROR half-open range patterns are unstable\n     if let ...5 = 0 {}\n     //~^ ERROR half-open range patterns are unstable\n+    //~| ERROR range-to patterns with `...` are not allowed\n     if let ..5 = 0 {}\n     //~^ ERROR half-open range patterns are unstable\n     if let 5.. = 0 {}"}, {"sha": "99db339cf74e1404f08fa86f4537c4ee927e0b10", "filename": "src/test/ui/half-open-range-patterns/feature-gate-half-open-range-patterns.stderr", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Ffeature-gate-half-open-range-patterns.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,18 +1,24 @@\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:9:12\n+   |\n+LL |     if let ...5 = 0 {}\n+   |            ^^^ help: use `..=` instead\n+\n error[E0586]: inclusive range with no end\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:15:13\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:16:13\n    |\n LL |     if let 5..= = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:18:13\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:19:13\n    |\n LL |     if let 5... = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0658]: half-open range patterns are unstable\n   --> $DIR/feature-gate-half-open-range-patterns.rs:7:12\n@@ -33,7 +39,7 @@ LL |     if let ...5 = 0 {}\n    = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n \n error[E0658]: half-open range patterns are unstable\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:11:12\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:12:12\n    |\n LL |     if let ..5 = 0 {}\n    |            ^^^\n@@ -42,7 +48,7 @@ LL |     if let ..5 = 0 {}\n    = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n \n error[E0658]: half-open range patterns are unstable\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:13:12\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:14:12\n    |\n LL |     if let 5.. = 0 {}\n    |            ^^^\n@@ -51,7 +57,7 @@ LL |     if let 5.. = 0 {}\n    = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n \n error[E0658]: half-open range patterns are unstable\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:15:12\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:16:12\n    |\n LL |     if let 5..= = 0 {}\n    |            ^^^^\n@@ -60,15 +66,15 @@ LL |     if let 5..= = 0 {}\n    = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n \n error[E0658]: half-open range patterns are unstable\n-  --> $DIR/feature-gate-half-open-range-patterns.rs:18:12\n+  --> $DIR/feature-gate-half-open-range-patterns.rs:19:12\n    |\n LL |     if let 5... = 0 {}\n    |            ^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/67264\n    = help: add `#![feature(half_open_range_patterns)]` to the crate attributes to enable\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0586, E0658.\n For more information about an error, try `rustc --explain E0586`."}, {"sha": "daed775cf7c01cecf3cdfd1f02c6cbcc928c2825", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -0,0 +1,32 @@\n+// Test that `...X` range-to patterns are syntactically invalid.\n+//\n+// See https://github.com/rust-lang/rust/pull/67258#issuecomment-565656155\n+// for the reason why. To summarize, we might want to introduce `...expr` as\n+// an expression form for splatting (or \"untupling\") in an expression context.\n+// While there is no syntactic ambiguity with `...X` in a pattern context,\n+// there's a potential confusion factor here, and we would prefer to keep patterns\n+// and expressions in-sync. As such, we do not allow `...X` in patterns either.\n+\n+#![feature(half_open_range_patterns)]\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn syntax() {\n+    match scrutinee {\n+        ...X => {} //~ ERROR range-to patterns with `...` are not allowed\n+        ...0 => {} //~ ERROR range-to patterns with `...` are not allowed\n+        ...'a' => {} //~ ERROR range-to patterns with `...` are not allowed\n+        ...0.0f32 => {} //~ ERROR range-to patterns with `...` are not allowed\n+    }\n+}\n+\n+fn syntax2() {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            let ...$e; //~ ERROR range-to patterns with `...` are not allowed\n+        }\n+    }\n+\n+    mac!(0);\n+}"}, {"sha": "ba2e7ea8b5354cd2b70bf7af8c140270dd155965", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -0,0 +1,35 @@\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs:17:9\n+   |\n+LL |         ...X => {}\n+   |         ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs:18:9\n+   |\n+LL |         ...0 => {}\n+   |         ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs:19:9\n+   |\n+LL |         ...'a' => {}\n+   |         ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs:20:9\n+   |\n+LL |         ...0.0f32 => {}\n+   |         ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-inclusive-dotdotdot-bad-syntax.rs:27:17\n+   |\n+LL |             let ...$e;\n+   |                 ^^^ help: use `..=` instead\n+...\n+LL |     mac!(0);\n+   |     -------- in this macro invocation\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "9ace0c357b2d4a2dc1a1d77838328ecfc28c184d", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-no-end.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -13,3 +13,14 @@ fn foo() {\n     if let X... = 1 {} //~ ERROR inclusive range with no end\n     if let X..= = 1 {} //~ ERROR inclusive range with no end\n }\n+\n+fn bar() {\n+    macro_rules! mac {\n+        ($e:expr) => {\n+            let $e...; //~ ERROR inclusive range with no end\n+            let $e..=; //~ ERROR inclusive range with no end\n+        }\n+    }\n+\n+    mac!(0);\n+}"}, {"sha": "2bdb8ea57668ad4af8f87fafe6cdff76086f8baa", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-no-end.stderr", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -2,34 +2,56 @@ error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-inclusive-no-end.rs:10:13\n    |\n LL |     if let 0... = 1 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-inclusive-no-end.rs:11:13\n    |\n LL |     if let 0..= = 1 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-inclusive-no-end.rs:13:13\n    |\n LL |     if let X... = 1 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-inclusive-no-end.rs:14:13\n    |\n LL |     if let X..= = 1 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-error: aborting due to 4 previous errors\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:20:19\n+   |\n+LL |             let $e...;\n+   |                   ^^^ help: use `..` instead\n+...\n+LL |     mac!(0);\n+   |     -------- in this macro invocation\n+   |\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error[E0586]: inclusive range with no end\n+  --> $DIR/half-open-range-pats-inclusive-no-end.rs:21:19\n+   |\n+LL |             let $e..=;\n+   |                   ^^^ help: use `..` instead\n+...\n+LL |     mac!(0);\n+   |     -------- in this macro invocation\n+   |\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0586`."}, {"sha": "f054bbea4e3e7c99d1219b0ee384147c26af359c", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-ref-ambiguous-interp.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -20,5 +20,7 @@ fn syntax() {\n         &..=0 | _ => {}\n         //~^ ERROR the range pattern here has ambiguous interpretation\n         &...0 | _ => {}\n+        //~^ ERROR the range pattern here has ambiguous interpretation\n+        //~| ERROR range-to patterns with `...` are not allowed\n     }\n }"}, {"sha": "a5f7c390627bad950c83155ab21e18a6fdfb6698", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-ref-ambiguous-interp.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-ref-ambiguous-interp.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -8,9 +8,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:11\n    |\n LL |         &0..= | _ => {}\n-   |           ^^^\n+   |           ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: the range pattern here has ambiguous interpretation\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:10:10\n@@ -22,9 +22,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:13:11\n    |\n LL |         &0... | _ => {}\n-   |           ^^^\n+   |           ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: the range pattern here has ambiguous interpretation\n   --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:18:10\n@@ -38,6 +38,18 @@ error: the range pattern here has ambiguous interpretation\n LL |         &..=0 | _ => {}\n    |          ^^^^ help: add parentheses to clarify the precedence: `(..=0)`\n \n-error: aborting due to 6 previous errors\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:22:10\n+   |\n+LL |         &...0 | _ => {}\n+   |          ^^^ help: use `..=` instead\n+\n+error: the range pattern here has ambiguous interpretation\n+  --> $DIR/half-open-range-pats-ref-ambiguous-interp.rs:22:10\n+   |\n+LL |         &...0 | _ => {}\n+   |          ^^^^ help: add parentheses to clarify the precedence: `(..=0)`\n+\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0586`."}, {"sha": "8bb98d3b5c56fd10480ea3db32cf1b02b9b89797", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-syntactic-pass.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-syntactic-pass.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -11,22 +11,20 @@ fn main() {}\n fn syntax() {\n     match scrutinee {\n         X.. | 0.. | 'a'.. | 0.0f32.. => {}\n-        ..=X | ...X | ..X => {}\n-        ..=0 | ...0 | ..0 => {}\n-        ..='a' | ...'a' | ..'a' => {}\n-        ..=0.0f32 | ...0.0f32 | ..0.0f32 => {}\n+        ..=X | ..X => {}\n+        ..=0 | ..0 => {}\n+        ..='a' | ..'a' => {}\n+        ..=0.0f32 | ..0.0f32 => {}\n     }\n+}\n \n+fn syntax2() {\n     macro_rules! mac {\n         ($e:expr) => {\n-            let ..$e;\n-            let ...$e;\n-            let ..=$e;\n-            let $e..;\n-            let $e...;\n-            let $e..=;\n+            match 0u8 { ..$e => {}, _ => {} }\n+            match 0u8 { ..=$e => {}, _ => {} }\n+            match 0u8 { $e.. => {}, _ => {} }\n         }\n     }\n-\n-    mac!(0);\n+    mac!(42u8);\n }"}, {"sha": "21e5c03eb1605b254f76db7f8ef7bccefc56e51e", "filename": "src/test/ui/impossible_range.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fimpossible_range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fimpossible_range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpossible_range.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,17 +1,17 @@\n-// Make sure that invalid ranges generate an error during HIR lowering, not an ICE\n+// Make sure that invalid ranges generate an error during parsing, not an ICE\n \n pub fn main() {\n     ..;\n     0..;\n     ..1;\n     0..1;\n     ..=; //~ERROR inclusive range with no end\n-         //~^HELP bounded at the end\n+         //~^HELP use `..` instead\n }\n \n fn _foo1() {\n     ..=1;\n     0..=1;\n     0..=; //~ERROR inclusive range with no end\n-          //~^HELP bounded at the end\n+          //~^HELP use `..` instead\n }"}, {"sha": "ea2ab0f299d1b9f3c759e9e3f6e43ab06f6c0508", "filename": "src/test/ui/impossible_range.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fimpossible_range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fimpossible_range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpossible_range.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,18 +1,18 @@\n error[E0586]: inclusive range with no end\n-  --> $DIR/impossible_range.rs:8:8\n+  --> $DIR/impossible_range.rs:8:5\n    |\n LL |     ..=;\n-   |        ^\n+   |     ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n-  --> $DIR/impossible_range.rs:15:9\n+  --> $DIR/impossible_range.rs:15:6\n    |\n LL |     0..=;\n-   |         ^\n+   |      ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ce306c845175af061075edcc003316362fb70775", "filename": "src/test/ui/internal/internal-unstable-const.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -0,0 +1,10 @@\n+#![feature(staged_api)]\n+#![feature(const_if_match)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_stable(feature = \"rust1\", since = \"1.0.0\")]\n+const fn foo() -> i32 {\n+    if true { 4 } else { 5 } //~ loops and conditional expressions are not stable in const fn\n+}\n+\n+fn main() {}"}, {"sha": "58bbe798b00b6ab89ad73ea4ce78390c9ce45ba0", "filename": "src/test/ui/internal/internal-unstable-const.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finternal%2Finternal-unstable-const.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -0,0 +1,12 @@\n+error[E0723]: loops and conditional expressions are not stable in const fn\n+  --> $DIR/internal-unstable-const.rs:7:5\n+   |\n+LL |     if true { 4 } else { 5 }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "1d98361c46198f2640dc9718a85ee03972a83c42", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_err.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `as_deref_err` found for enum `std::result::Result\n   --> $DIR/result-as_deref_err.rs:4:28\n    |\n LL |     let _result = &Err(41).as_deref_err();\n-   |                            ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_ok`\n+   |                            ^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut`\n    |\n    = note: the method `as_deref_err` exists but the following trait bounds were not satisfied:\n            `{integer} : std::ops::Deref`"}, {"sha": "950a050ea9f81aa93fe11e6a1a7882e5b8a19950", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_err.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -2,7 +2,7 @@ error[E0599]: no method named `as_deref_mut_err` found for enum `std::result::Re\n   --> $DIR/result-as_deref_mut_err.rs:4:32\n    |\n LL |     let _result = &mut Err(41).as_deref_mut_err();\n-   |                                ^^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut_ok`\n+   |                                ^^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut`\n    |\n    = note: the method `as_deref_mut_err` exists but the following trait bounds were not satisfied:\n            `{integer} : std::ops::DerefMut`"}, {"sha": "54b695a0865f120546bfc199edaf281dc8aa3281", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_ok.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.rs?ref=543b7d97d019bff882cc70cf2f8bdc317e7b840f", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &mut Ok(42).as_deref_mut_ok();\n-//~^ ERROR no method named `as_deref_mut_ok` found\n-}"}, {"sha": "af8d657999cb0d8c0c97ae2751657733e1a1f828", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_mut_ok.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_mut_ok.stderr?ref=543b7d97d019bff882cc70cf2f8bdc317e7b840f", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `as_deref_mut_ok` found for enum `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-as_deref_mut_ok.rs:4:31\n-   |\n-LL |     let _result = &mut Ok(42).as_deref_mut_ok();\n-   |                               ^^^^^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_mut_err`\n-   |\n-   = note: the method `as_deref_mut_ok` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::DerefMut`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "ebb0500e8190fdc9309291450952d3496a2dbb83", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_ok.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.rs?ref=543b7d97d019bff882cc70cf2f8bdc317e7b840f", "patch": "@@ -1,6 +0,0 @@\n-#![feature(inner_deref)]\n-\n-fn main() {\n-    let _result = &Ok(42).as_deref_ok();\n-//~^ ERROR no method named `as_deref_ok` found\n-}"}, {"sha": "145e610d52c7c527a03f2f73ad1430563426abaa", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-as_deref_ok.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/543b7d97d019bff882cc70cf2f8bdc317e7b840f/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-as_deref_ok.stderr?ref=543b7d97d019bff882cc70cf2f8bdc317e7b840f", "patch": "@@ -1,12 +0,0 @@\n-error[E0599]: no method named `as_deref_ok` found for enum `std::result::Result<{integer}, _>` in the current scope\n-  --> $DIR/result-as_deref_ok.rs:4:27\n-   |\n-LL |     let _result = &Ok(42).as_deref_ok();\n-   |                           ^^^^^^^^^^^ help: there is a method with a similar name: `as_deref_err`\n-   |\n-   = note: the method `as_deref_ok` exists but the following trait bounds were not satisfied:\n-           `{integer} : std::ops::Deref`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "24da2620c2eaf887525e7d547b3802224c699e85", "filename": "src/test/ui/macros/issue-68058.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fmacros%2Fissue-68058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fmacros%2Fissue-68058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68058.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+macro_rules! foo {\n+    ($doc: expr) => {\n+        fn f() {\n+            #[doc = $doc]\n+            ()\n+        }\n+    };\n+}\n+\n+foo!(\"doc\");\n+\n+fn main() {}"}, {"sha": "4775b9b7bc003593d9c76ca2a06268b5e060ceb8", "filename": "src/test/ui/parser/attr-stmt-expr-attr-bad.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fattr-stmt-expr-attr-bad.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -342,9 +342,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/attr-stmt-expr-attr-bad.rs:94:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] 10 => () } }\n-   |                                   ^^^\n+   |                                   ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:94:38\n@@ -356,9 +356,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/attr-stmt-expr-attr-bad.rs:97:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] -10 => () } }\n-   |                                   ^^^\n+   |                                   ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:97:38\n@@ -376,9 +376,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/attr-stmt-expr-attr-bad.rs:102:35\n    |\n LL | #[cfg(FALSE)] fn e() { match 0 { 0..=#[attr] FOO => () } }\n-   |                                   ^^^\n+   |                                   ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: expected one of `=>`, `if`, or `|`, found `#`\n   --> $DIR/attr-stmt-expr-attr-bad.rs:102:38"}, {"sha": "7c3b906b47f9f4b8723ccbba0ca8ca4065049596", "filename": "src/test/ui/parser/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -2,5 +2,5 @@\n \n pub fn main() {\n     for _ in 1..= {} //~ERROR inclusive range with no end\n-                     //~^HELP bounded at the end\n+                     //~^HELP use `..` instead\n }"}, {"sha": "1dd479945968104d4c270154d978c91038e5b16f", "filename": "src/test/ui/parser/range_inclusive.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frange_inclusive.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -1,10 +1,10 @@\n error[E0586]: inclusive range with no end\n-  --> $DIR/range_inclusive.rs:4:19\n+  --> $DIR/range_inclusive.rs:4:15\n    |\n LL |     for _ in 1..= {}\n-   |                   ^\n+   |               ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: aborting due to previous error\n "}, {"sha": "e07ea6221d7c95637e7b103756d16164c2a5a81b", "filename": "src/test/ui/parser/recover-range-pats.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.rs?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -107,15 +107,15 @@ fn inclusive_to() {\n \n fn inclusive2_to() {\n     if let ...3 = 0 {}\n-    //~^ ERROR `...` range patterns are deprecated\n+    //~^ ERROR range-to patterns with `...` are not allowed\n     if let ...Y = 0 {}\n-    //~^ ERROR `...` range patterns are deprecated\n+    //~^ ERROR range-to patterns with `...` are not allowed\n     if let ...true = 0 {}\n-    //~^ ERROR `...` range patterns are deprecated\n+    //~^ ERROR range-to patterns with `...` are not allowed\n     //~| ERROR only char and numeric types\n     if let ....3 = 0 {}\n     //~^ ERROR float literals must have an integer part\n-    //~| ERROR `...` range patterns are deprecated\n+    //~| ERROR range-to patterns with `...` are not allowed\n     //~| ERROR mismatched types\n }\n \n@@ -135,7 +135,7 @@ fn with_macro_expr_var() {\n         ($e:expr) => {\n             let ..$e;\n             let ...$e;\n-            //~^ ERROR `...` range patterns are deprecated\n+            //~^ ERROR range-to patterns with `...` are not allowed\n             let ..=$e;\n             let $e..;\n             let $e...; //~ ERROR inclusive range with no end"}, {"sha": "f43f9bf3012183b870a61dcc7502e375d36f6a2e", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfd04876b93ad5c013d90bc46937e28b6ee1a3f4/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=bfd04876b93ad5c013d90bc46937e28b6ee1a3f4", "patch": "@@ -44,25 +44,25 @@ error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:69:13\n    |\n LL |     if let 0..= = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:70:13\n    |\n LL |     if let X..= = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:71:16\n    |\n LL |     if let true..= = 0 {}\n-   |                ^^^\n+   |                ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n   --> $DIR/recover-range-pats.rs:73:12\n@@ -74,33 +74,33 @@ error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:73:14\n    |\n LL |     if let .0..= = 0 {}\n-   |              ^^^\n+   |              ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:79:13\n    |\n LL |     if let 0... = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:80:13\n    |\n LL |     if let X... = 0 {}\n-   |             ^^^\n+   |             ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:81:16\n    |\n LL |     if let true... = 0 {}\n-   |                ^^^\n+   |                ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n   --> $DIR/recover-range-pats.rs:83:12\n@@ -112,9 +112,9 @@ error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:83:14\n    |\n LL |     if let .0... = 0 {}\n-   |              ^^^\n+   |              ^^^ help: use `..` instead\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: float literals must have an integer part\n   --> $DIR/recover-range-pats.rs:93:15\n@@ -128,33 +128,66 @@ error: float literals must have an integer part\n LL |     if let ..=.0 = 0 {}\n    |               ^^ help: must have an integer part: `0.0`\n \n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/recover-range-pats.rs:109:12\n+   |\n+LL |     if let ...3 = 0 {}\n+   |            ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/recover-range-pats.rs:111:12\n+   |\n+LL |     if let ...Y = 0 {}\n+   |            ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/recover-range-pats.rs:113:12\n+   |\n+LL |     if let ...true = 0 {}\n+   |            ^^^ help: use `..=` instead\n+\n error: float literals must have an integer part\n   --> $DIR/recover-range-pats.rs:116:15\n    |\n LL |     if let ....3 = 0 {}\n    |               ^^ help: must have an integer part: `0.3`\n \n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/recover-range-pats.rs:116:12\n+   |\n+LL |     if let ....3 = 0 {}\n+   |            ^^^ help: use `..=` instead\n+\n+error: range-to patterns with `...` are not allowed\n+  --> $DIR/recover-range-pats.rs:137:17\n+   |\n+LL |             let ...$e;\n+   |                 ^^^ help: use `..=` instead\n+...\n+LL |     mac!(0);\n+   |     -------- in this macro invocation\n+\n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:141:19\n    |\n LL |             let $e...;\n-   |                   ^^^\n+   |                   ^^^ help: use `..` instead\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/recover-range-pats.rs:142:19\n    |\n LL |             let $e..=;\n-   |                   ^^^\n+   |                   ^^^ help: use `..` instead\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n    |\n-   = help: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n error: `...` range patterns are deprecated\n   --> $DIR/recover-range-pats.rs:42:13\n@@ -210,30 +243,6 @@ error: `...` range patterns are deprecated\n LL |     if let X... .0 = 0 {}\n    |             ^^^ help: use `..=` for an inclusive range\n \n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:109:12\n-   |\n-LL |     if let ...3 = 0 {}\n-   |            ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:111:12\n-   |\n-LL |     if let ...Y = 0 {}\n-   |            ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:113:12\n-   |\n-LL |     if let ...true = 0 {}\n-   |            ^^^ help: use `..=` for an inclusive range\n-\n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:116:12\n-   |\n-LL |     if let ....3 = 0 {}\n-   |            ^^^ help: use `..=` for an inclusive range\n-\n error: `...` range patterns are deprecated\n   --> $DIR/recover-range-pats.rs:126:20\n    |\n@@ -243,15 +252,6 @@ LL |             let $e1...$e2;\n LL |     mac2!(0, 1);\n    |     ------------ in this macro invocation\n \n-error: `...` range patterns are deprecated\n-  --> $DIR/recover-range-pats.rs:137:17\n-   |\n-LL |             let ...$e;\n-   |                 ^^^ help: use `..=` for an inclusive range\n-...\n-LL |     mac!(0);\n-   |     -------- in this macro invocation\n-\n error[E0029]: only char and numeric types are allowed in range patterns\n   --> $DIR/recover-range-pats.rs:20:12\n    |"}]}