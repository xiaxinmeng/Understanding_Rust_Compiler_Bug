{"sha": "a9292d871c09bbfc2924dc6e7358fde3ba564d51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MjkyZDg3MWMwOWJiZmMyOTI0ZGM2ZTczNThmZGUzYmE1NjRkNTE=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-15T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-01-18T12:15:27Z"}, "message": "Remove disabled transformation from instcombine", "tree": {"sha": "60dd358b95ca69a96d7040c69afdbb77762525b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60dd358b95ca69a96d7040c69afdbb77762525b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9292d871c09bbfc2924dc6e7358fde3ba564d51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9292d871c09bbfc2924dc6e7358fde3ba564d51", "html_url": "https://github.com/rust-lang/rust/commit/a9292d871c09bbfc2924dc6e7358fde3ba564d51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9292d871c09bbfc2924dc6e7358fde3ba564d51/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "url": "https://api.github.com/repos/rust-lang/rust/commits/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "html_url": "https://github.com/rust-lang/rust/commit/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df"}], "stats": {"total": 216, "additions": 4, "deletions": 212}, "files": [{"sha": "405f8ae36e85e64eb27ea332aa0a0fa98d21b24f", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 3, "deletions": 142, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/a9292d871c09bbfc2924dc6e7358fde3ba564d51/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9292d871c09bbfc2924dc6e7358fde3ba564d51/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=a9292d871c09bbfc2924dc6e7358fde3ba564d51", "patch": "@@ -4,14 +4,9 @@ use crate::transform::MirPass;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::Mutability;\n use rustc_index::vec::Idx;\n+use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::{\n-    visit::PlaceContext,\n-    visit::{MutVisitor, Visitor},\n-    Statement,\n-};\n-use rustc_middle::mir::{\n-    BinOp, Body, BorrowKind, Constant, Local, Location, Operand, Place, PlaceRef, ProjectionElem,\n-    Rvalue,\n+    BinOp, Body, Constant, Local, Location, Operand, Place, PlaceRef, ProjectionElem, Rvalue,\n };\n use rustc_middle::ty::{self, TyCtxt};\n use std::mem;\n@@ -90,38 +85,10 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             }\n         }\n \n-        if let Some(place) = self.optimizations.unneeded_deref.remove(&location) {\n-            if self.should_combine(rvalue, location) {\n-                debug!(\"unneeded_deref: replacing {:?} with {:?}\", rvalue, place);\n-                *rvalue = Rvalue::Use(Operand::Copy(place));\n-            }\n-        }\n-\n         // We do not call super_rvalue as we are not interested in any other parts of the tree\n     }\n }\n \n-struct MutatingUseVisitor {\n-    has_mutating_use: bool,\n-    local_to_look_for: Local,\n-}\n-\n-impl MutatingUseVisitor {\n-    fn has_mutating_use_in_stmt(local: Local, stmt: &Statement<'tcx>, location: Location) -> bool {\n-        let mut _self = Self { has_mutating_use: false, local_to_look_for: local };\n-        _self.visit_statement(stmt, location);\n-        _self.has_mutating_use\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for MutatingUseVisitor {\n-    fn visit_local(&mut self, local: &Local, context: PlaceContext, _: Location) {\n-        if *local == self.local_to_look_for {\n-            self.has_mutating_use |= context.is_mutating_use();\n-        }\n-    }\n-}\n-\n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'tcx> {\n     body: &'b Body<'tcx>,\n@@ -134,103 +101,6 @@ impl OptimizationFinder<'b, 'tcx> {\n         OptimizationFinder { body, tcx, optimizations: OptimizationList::default() }\n     }\n \n-    fn find_deref_of_address(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n-        // FIXME(#78192): This optimization can result in unsoundness.\n-        if !self.tcx.sess.opts.debugging_opts.unsound_mir_opts {\n-            return None;\n-        }\n-\n-        // Look for the sequence\n-        //\n-        // _2 = &_1;\n-        // ...\n-        // _5 = (*_2);\n-        //\n-        // which we can replace the last statement with `_5 = _1;` to avoid the load of `_2`.\n-        if let Rvalue::Use(op) = rvalue {\n-            let local_being_derefed = match op.place()?.as_ref() {\n-                PlaceRef { local, projection: [ProjectionElem::Deref] } => Some(local),\n-                _ => None,\n-            }?;\n-\n-            let mut dead_locals_seen = vec![];\n-\n-            let stmt_index = location.statement_index;\n-            // Look behind for statement that assigns the local from a address of operator.\n-            // 6 is chosen as a heuristic determined by seeing the number of times\n-            // the optimization kicked in compiling rust std.\n-            let lower_index = stmt_index.saturating_sub(6);\n-            let statements_to_look_in = self.body.basic_blocks()[location.block].statements\n-                [lower_index..stmt_index]\n-                .iter()\n-                .rev();\n-            for stmt in statements_to_look_in {\n-                match &stmt.kind {\n-                    // Exhaustive match on statements to detect conditions that warrant we bail out of the optimization.\n-                    rustc_middle::mir::StatementKind::Assign(box (l, r))\n-                        if l.local == local_being_derefed =>\n-                    {\n-                        match r {\n-                            // Looking for immutable reference e.g _local_being_deref = &_1;\n-                            Rvalue::Ref(\n-                                _,\n-                                // Only apply the optimization if it is an immutable borrow.\n-                                BorrowKind::Shared,\n-                                place_taken_address_of,\n-                            ) => {\n-                                // Make sure that the place has not been marked dead\n-                                if dead_locals_seen.contains(&place_taken_address_of.local) {\n-                                    return None;\n-                                }\n-\n-                                self.optimizations\n-                                    .unneeded_deref\n-                                    .insert(location, *place_taken_address_of);\n-                                return Some(());\n-                            }\n-\n-                            // We found an assignment of `local_being_deref` that is not an immutable ref, e.g the following sequence\n-                            // _2 = &_1;\n-                            // _3 = &5\n-                            // _2 = _3;  <-- this means it is no longer valid to replace the last statement with `_5 = _1;`\n-                            // _5 = (*_2);\n-                            _ => return None,\n-                        }\n-                    }\n-\n-                    // Inline asm can do anything, so bail out of the optimization.\n-                    rustc_middle::mir::StatementKind::LlvmInlineAsm(_) => return None,\n-\n-                    // Remember `StorageDead`s, as the local being marked dead could be the\n-                    // place RHS we are looking for, in which case we need to abort to avoid UB\n-                    // using an uninitialized place\n-                    rustc_middle::mir::StatementKind::StorageDead(dead) => {\n-                        dead_locals_seen.push(*dead)\n-                    }\n-\n-                    // Check that `local_being_deref` is not being used in a mutating way which can cause misoptimization.\n-                    rustc_middle::mir::StatementKind::Assign(box (_, _))\n-                    | rustc_middle::mir::StatementKind::Coverage(_)\n-                    | rustc_middle::mir::StatementKind::Nop\n-                    | rustc_middle::mir::StatementKind::FakeRead(_, _)\n-                    | rustc_middle::mir::StatementKind::StorageLive(_)\n-                    | rustc_middle::mir::StatementKind::Retag(_, _)\n-                    | rustc_middle::mir::StatementKind::AscribeUserType(_, _)\n-                    | rustc_middle::mir::StatementKind::SetDiscriminant { .. } => {\n-                        if MutatingUseVisitor::has_mutating_use_in_stmt(\n-                            local_being_derefed,\n-                            stmt,\n-                            location,\n-                        ) {\n-                            return None;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        Some(())\n-    }\n-\n     fn find_unneeded_equality_comparison(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         // find Ne(_place, false) or Ne(false, _place)\n         // or   Eq(_place, true) or Eq(true, _place)\n@@ -295,8 +165,6 @@ impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n             }\n         }\n \n-        let _ = self.find_deref_of_address(rvalue, location);\n-\n         self.find_unneeded_equality_comparison(rvalue, location);\n \n         // We do not call super_rvalue as we are not interested in any other parts of the tree\n@@ -308,22 +176,15 @@ struct OptimizationList<'tcx> {\n     and_stars: FxHashSet<Location>,\n     arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n     unneeded_equality_comparison: FxHashMap<Location, Operand<'tcx>>,\n-    unneeded_deref: FxHashMap<Location, Place<'tcx>>,\n }\n \n impl<'tcx> OptimizationList<'tcx> {\n     fn is_empty(&self) -> bool {\n         match self {\n-            OptimizationList {\n-                and_stars,\n-                arrays_lengths,\n-                unneeded_equality_comparison,\n-                unneeded_deref,\n-            } => {\n+            OptimizationList { and_stars, arrays_lengths, unneeded_equality_comparison } => {\n                 and_stars.is_empty()\n                     && arrays_lengths.is_empty()\n                     && unneeded_equality_comparison.is_empty()\n-                    && unneeded_deref.is_empty()\n             }\n         }\n     }"}, {"sha": "4bda9ae383c228b48220f9aeb3ab18863af32a53", "filename": "src/test/mir-opt/inline/inline_closure_borrows_arg.foo.Inline.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9292d871c09bbfc2924dc6e7358fde3ba564d51/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/a9292d871c09bbfc2924dc6e7358fde3ba564d51/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_closure_borrows_arg.foo.Inline.after.mir?ref=a9292d871c09bbfc2924dc6e7358fde3ba564d51", "patch": "@@ -40,7 +40,7 @@ fn foo(_1: T, _2: &i32) -> i32 {\n         _9 = move (_5.1: &i32);          // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageLive(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         _10 = _8;                        // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n-        _0 = (*_8);                      // scope 3 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n+        _0 = (*_10);                     // scope 3 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_10);                // scope 2 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_9);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12\n         StorageDead(_8);                 // scope 1 at $DIR/inline-closure-borrows-arg.rs:16:5: 16:12"}, {"sha": "78361c336607c671b5f9635101d6edc54ef9468b", "filename": "src/test/mir-opt/inst_combine_deref.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finst_combine_deref.rs?ref=86e0ff47a0d1afcbe9f0c8cdb54f60bb18da20df", "patch": "@@ -1,69 +0,0 @@\n-// compile-flags: -O -Zunsound-mir-opts\n-// EMIT_MIR inst_combine_deref.simple_opt.InstCombine.diff\n-fn simple_opt() -> u64 {\n-    let x = 5;\n-    let y = &x;\n-    let z = *y;\n-    z\n-}\n-\n-// EMIT_MIR inst_combine_deref.deep_opt.InstCombine.diff\n-fn deep_opt() -> (u64, u64, u64) {\n-    let x1 = 1;\n-    let x2 = 2;\n-    let x3 = 3;\n-    let y1 = &x1;\n-    let y2 = &x2;\n-    let y3 = &x3;\n-    let z1 = *y1;\n-    let z2 = *y2;\n-    let z3 = *y3;\n-    (z1, z2, z3)\n-}\n-\n-struct S {\n-    a: u64,\n-    b: u64,\n-}\n-\n-// EMIT_MIR inst_combine_deref.opt_struct.InstCombine.diff\n-fn opt_struct(s: S) -> u64 {\n-    let a = &s.a;\n-    let b = &s.b;\n-    let x = *a;\n-    *b + x\n-}\n-\n-// EMIT_MIR inst_combine_deref.dont_opt.InstCombine.diff\n-// do not optimize a sequence looking like this:\n-// _1 = &_2;\n-// _1 = _3;\n-// _4 = *_1;\n-// as the _1 = _3 assignment makes it not legal to replace the last statement with _4 = _2\n-fn dont_opt() -> u64 {\n-    let y = 5;\n-    let _ref = &y;\n-    let x = 5;\n-    let mut _1 = &x;\n-    _1 = _ref;\n-    let _4 = *_1;\n-    0\n-}\n-\n-// EMIT_MIR inst_combine_deref.do_not_miscompile.InstCombine.diff\n-fn do_not_miscompile() {\n-    let x = 42;\n-    let a = 99;\n-    let mut y = &x;\n-    let z = &mut y;\n-    *z = &a;\n-    assert!(*y == 99);\n-}\n-\n-fn main() {\n-    simple_opt();\n-    deep_opt();\n-    opt_struct(S { a: 0, b: 1 });\n-    dont_opt();\n-    do_not_miscompile();\n-}"}]}