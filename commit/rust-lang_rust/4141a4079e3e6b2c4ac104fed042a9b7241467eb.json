{"sha": "4141a4079e3e6b2c4ac104fed042a9b7241467eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNDFhNDA3OWUzZTZiMmM0YWMxMDRmZWQwNDJhOWI3MjQxNDY3ZWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T20:02:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T20:02:14Z"}, "message": "Auto merge of #53542 - alexreg:impl-trait-in-bindings, r=cramertj\n\n`impl trait` in bindings (feature: impl-trait-existential-types)\n\nThis PR enables `impl Trait` syntax (opaque types) to be used in bindings, e.g.\n\n* `let foo: impl Clone = 1;`\n* `static foo: impl Clone = 2;`\n* `const foo: impl Clone = 3;`\n\nThis is part of [RFC 2071](https://github.com/rust-lang/rfcs/blob/master/text/2071-impl-trait-existential-types.md) ([tracking issue](https://github.com/rust-lang/rust/issues/34511)), but exists behind the separate feature gate `impl_trait_in_bindings`.\n\nCC @cramertj @oli-obk @eddyb @Centril @varkor", "tree": {"sha": "fac6b20ad1dc438736aa960ea174dbaa3883d075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fac6b20ad1dc438736aa960ea174dbaa3883d075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4141a4079e3e6b2c4ac104fed042a9b7241467eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4141a4079e3e6b2c4ac104fed042a9b7241467eb", "html_url": "https://github.com/rust-lang/rust/commit/4141a4079e3e6b2c4ac104fed042a9b7241467eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4141a4079e3e6b2c4ac104fed042a9b7241467eb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31789a658bb6b6c78da1f2b99a5f169e4e8b983b", "url": "https://api.github.com/repos/rust-lang/rust/commits/31789a658bb6b6c78da1f2b99a5f169e4e8b983b", "html_url": "https://github.com/rust-lang/rust/commit/31789a658bb6b6c78da1f2b99a5f169e4e8b983b"}, {"sha": "16cf404f9853e716a216be32d05f5215ff821c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/16cf404f9853e716a216be32d05f5215ff821c00", "html_url": "https://github.com/rust-lang/rust/commit/16cf404f9853e716a216be32d05f5215ff821c00"}], "stats": {"total": 1116, "additions": 746, "deletions": 370}, "files": [{"sha": "896465cf64978552c2bf283554f6446798aca0c8", "filename": "src/doc/unstable-book/src/language-features/impl-trait-in-bindings.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fimpl-trait-in-bindings.md?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,28 @@\n+# `impl_trait_in_bindings`\n+\n+The tracking issue for this feature is: [#34511]\n+\n+[#34511]: https://github.com/rust-lang/rust/issues/34511\n+\n+------------------------\n+\n+The `impl_trait_in_bindings` feature gate lets you use `impl Trait` syntax in\n+`let`, `static`, and `const` bindings.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(impl_trait_in_bindings)]\n+\n+use std::fmt::Debug;\n+\n+fn main() {\n+    let a: impl Debug + Clone = 42;\n+    let b = a.clone();\n+    println!(\"{:?}\", b); // prints `42`\n+}\n+```\n+\n+Note however that because the types of `a` and `b` are opaque in the above\n+example, calling inherent methods or methods outside of the specified traits\n+(e.g., `a.abs()` or `b.abs()`) is not allowed, and yields an error."}, {"sha": "84afdd53cf48c17e9cb2d913cf1e881a09f78f66", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -1739,7 +1739,7 @@ specified exit code, use `std::process::exit`.\n \n E0562: r##\"\n Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function return types.\n+allowed as function and inherent impl return types.\n \n Erroneous code example:\n "}, {"sha": "638591eb1fb6977bd506fd46babad9642a687994", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -131,7 +131,6 @@ pub struct DefIndex(u32);\n /// thanks to `NodeCollector::new`.\n pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n-\n impl fmt::Debug for DefIndex {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f,\n@@ -216,7 +215,7 @@ impl DefIndexAddressSpace {\n     }\n }\n \n-/// A DefId identifies a particular *definition*, by combining a crate\n+/// A `DefId` identifies a particular *definition*, by combining a crate\n /// index and a def index.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub struct DefId {"}, {"sha": "1e9936fdc13fcbf503f0447f40cba2bedec89ced", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 146, "deletions": 70, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -175,15 +175,17 @@ enum ImplTraitContext<'a> {\n     /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n-    /// Newly generated parameters should be inserted into the given `Vec`\n+    /// Newly generated parameters should be inserted into the given `Vec`.\n     Universal(&'a mut Vec<hir::GenericParam>),\n \n-    /// Treat `impl Trait` as shorthand for a new universal existential parameter.\n+    /// Treat `impl Trait` as shorthand for a new existential parameter.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n-    /// equivalent to a fresh existential parameter like `abstract type T; fn foo() -> T`.\n+    /// equivalent to a fresh existential parameter like `existential type T; fn foo() -> T`.\n     ///\n-    /// We store a DefId here so we can look up necessary information later\n-    Existential(DefId),\n+    /// We optionally store a `DefId` for the parent item here so we can look up necessary\n+    /// information later. It is `None` when no information about the context should be stored,\n+    /// e.g. for consts and statics.\n+    Existential(Option<DefId>),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed,\n@@ -305,6 +307,35 @@ enum AnonymousLifetimeMode {\n     PassThrough,\n }\n \n+struct ImplTraitTypeIdVisitor<'a> { ids: &'a mut OneVector<hir::ItemId> }\n+\n+impl<'a, 'b> Visitor<'a> for ImplTraitTypeIdVisitor<'b> {\n+    fn visit_ty(&mut self, ty: &'a Ty) {\n+        match ty.node {\n+            | TyKind::Typeof(_)\n+            | TyKind::BareFn(_)\n+            => return,\n+\n+            TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n+            _ => {},\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_path_segment(\n+        &mut self,\n+        path_span: Span,\n+        path_segment: &'v PathSegment,\n+    ) {\n+        if let Some(ref p) = path_segment.args {\n+            if let GenericArgs::Parenthesized(_) = **p {\n+                return;\n+            }\n+        }\n+        visit::walk_path_segment(self, path_span, path_segment)\n+    }\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -396,7 +427,7 @@ impl<'a> LoweringContext<'a> {\n \n                     self.lctx.with_parent_impl_lifetime_defs(&item_generics, |this| {\n                         let this = &mut ItemLowerer { lctx: this };\n-                        if let ItemKind::Impl(_, _, _, _, ref opt_trait_ref, _, _) = item.node {\n+                        if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n                             this.with_trait_impl_ref(opt_trait_ref, |this| {\n                                 visit::walk_item(this, item)\n                             });\n@@ -955,13 +986,13 @@ impl<'a> LoweringContext<'a> {\n \n         let catch_scopes = mem::replace(&mut self.catch_scopes, Vec::new());\n         let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n-        let result = f(self);\n+        let ret = f(self);\n         self.catch_scopes = catch_scopes;\n         self.loop_scopes = loop_scopes;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n-        result\n+        ret\n     }\n \n     fn def_key(&mut self, id: DefId) -> DefKey {\n@@ -1224,12 +1255,18 @@ impl<'a> LoweringContext<'a> {\n                         ))\n                     }\n                     ImplTraitContext::Disallowed => {\n+                        let allowed_in = if self.sess.features_untracked()\n+                                                .impl_trait_in_bindings {\n+                            \"bindings or function and inherent method return types\"\n+                        } else {\n+                            \"function and inherent method return types\"\n+                        };\n                         span_err!(\n                             self.sess,\n                             t.span,\n                             E0562,\n-                            \"`impl Trait` not allowed outside of function \\\n-                             and inherent method return types\"\n+                            \"`impl Trait` not allowed outside of {}\",\n+                            allowed_in,\n                         );\n                         hir::TyKind::Err\n                     }\n@@ -1250,7 +1287,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_existential_impl_trait(\n         &mut self,\n         span: Span,\n-        fn_def_id: DefId,\n+        fn_def_id: Option<DefId>,\n         exist_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut LoweringContext) -> hir::GenericBounds,\n     ) -> hir::TyKind {\n@@ -1270,7 +1307,6 @@ impl<'a> LoweringContext<'a> {\n             .opt_def_index(exist_ty_node_id)\n             .unwrap();\n \n-\n         self.allocate_hir_id_counter(exist_ty_node_id, &\"existential impl trait\");\n \n         let hir_bounds = self.with_hir_id_owner(exist_ty_node_id, lower_bounds);\n@@ -1292,7 +1328,7 @@ impl<'a> LoweringContext<'a> {\n                     span,\n                 },\n                 bounds: hir_bounds,\n-                impl_trait_fn: Some(fn_def_id),\n+                impl_trait_fn: fn_def_id,\n             });\n             let exist_ty_id = lctx.lower_node_id(exist_ty_node_id);\n             // Generate an `existential type Foo: Trait;` declaration\n@@ -1865,20 +1901,34 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n+    fn lower_local(&mut self, l: &Local) -> (P<hir::Local>, OneVector<hir::ItemId>) {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n-        P(hir::Local {\n+        let mut ids = OneVector::<hir::ItemId>::new();\n+        if self.sess.features_untracked().impl_trait_in_bindings {\n+            if let Some(ref ty) = l.ty {\n+                let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                visitor.visit_ty(ty);\n+            }\n+        }\n+        let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n+        (P(hir::Local {\n             id: node_id,\n             hir_id,\n             ty: l.ty\n                 .as_ref()\n-                .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed)),\n+                .map(|t| self.lower_ty(t,\n+                    if self.sess.features_untracked().impl_trait_in_bindings {\n+                        ImplTraitContext::Existential(Some(parent_def_id))\n+                    } else {\n+                        ImplTraitContext::Disallowed\n+                    }\n+                )),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n             source: hir::LocalSource::Normal,\n-        })\n+        }), ids)\n     }\n \n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n@@ -1948,7 +1998,7 @@ impl<'a> LoweringContext<'a> {\n             match decl.output {\n                 FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n                     Some((def_id, _)) if impl_trait_return_allow => {\n-                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(def_id)))\n+                        hir::Return(self.lower_ty(ty, ImplTraitContext::Existential(Some(def_id))))\n                     }\n                     _ => hir::Return(self.lower_ty(ty, ImplTraitContext::Disallowed)),\n                 },\n@@ -2131,10 +2181,11 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         let impl_trait_ty = self.lower_existential_impl_trait(\n-            span, fn_def_id, return_impl_trait_id, |this| {\n+            span, Some(fn_def_id), return_impl_trait_id, |this| {\n             let output_ty = match output {\n-                FunctionRetTy::Ty(ty) =>\n-                    this.lower_ty(ty, ImplTraitContext::Existential(fn_def_id)),\n+                FunctionRetTy::Ty(ty) => {\n+                    this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id)))\n+                }\n                 FunctionRetTy::Default(span) => {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n                     P(hir::Ty {\n@@ -2629,18 +2680,34 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Static(\n-                    self.lower_ty(t, ImplTraitContext::Disallowed),\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::Existential(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed\n+                        }\n+                    ),\n                     self.lower_mutability(m),\n                     value,\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemKind::Const(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n+                hir::ItemKind::Const(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::Existential(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed\n+                        }\n+                    ),\n+                    value\n+                )\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n-\n                 self.with_new_scopes(|this| {\n                     // Note: we don't need to change the return type from `T` to\n                     // `impl Future<Output = T>` here because lower_body\n@@ -2653,7 +2720,11 @@ impl<'a> LoweringContext<'a> {\n                         fn_def_id,\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| this.lower_fn_decl(\n-                            decl, Some((fn_def_id, idty)), true, header.asyncness.opt_return_id()),\n+                            decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.opt_return_id()\n+                        ),\n                     );\n \n                     hir::ItemKind::Fn(\n@@ -2995,15 +3066,13 @@ impl<'a> LoweringContext<'a> {\n                     let body = this.lower_block(body, false);\n                     this.expr_block(body, ThinVec::new())\n                 });\n-\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n                     trait_item_def_id,\n                     false,\n                     None,\n                 );\n-\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n             TraitItemKind::Type(ref bounds, ref default) => (\n@@ -3137,8 +3206,8 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    /// Lowers `impl Trait` items and appends them to the list\n-    fn lower_impl_trait_ids(\n+    /// Lowers `impl Trait` items for a function and appends them to the list\n+    fn lower_fn_impl_trait_ids(\n         &mut self,\n         decl: &FnDecl,\n         header: &FnHeader,\n@@ -3147,33 +3216,7 @@ impl<'a> LoweringContext<'a> {\n         if let Some(id) = header.asyncness.opt_return_id() {\n             ids.push(hir::ItemId { id });\n         }\n-        struct IdVisitor<'a> { ids: &'a mut OneVector<hir::ItemId> }\n-        impl<'a, 'b> Visitor<'a> for IdVisitor<'b> {\n-            fn visit_ty(&mut self, ty: &'a Ty) {\n-                match ty.node {\n-                    | TyKind::Typeof(_)\n-                    | TyKind::BareFn(_)\n-                    => return,\n-\n-                    TyKind::ImplTrait(id, _) => self.ids.push(hir::ItemId { id }),\n-                    _ => {},\n-                }\n-                visit::walk_ty(self, ty);\n-            }\n-            fn visit_path_segment(\n-                &mut self,\n-                path_span: Span,\n-                path_segment: &'v PathSegment,\n-            ) {\n-                if let Some(ref p) = path_segment.args {\n-                    if let GenericArgs::Parenthesized(_) = **p {\n-                        return;\n-                    }\n-                }\n-                visit::walk_path_segment(self, path_span, path_segment)\n-            }\n-        }\n-        let mut visitor = IdVisitor { ids };\n+        let mut visitor = ImplTraitTypeIdVisitor { ids };\n         match decl.output {\n             FunctionRetTy::Default(_) => {},\n             FunctionRetTy::Ty(ref ty) => visitor.visit_ty(ty),\n@@ -3190,18 +3233,34 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::MacroDef(..) => OneVector::new(),\n             ItemKind::Fn(ref decl, ref header, ..) => {\n                 let mut ids = smallvec![hir::ItemId { id: i.id }];\n-                self.lower_impl_trait_ids(decl, header, &mut ids);\n+                self.lower_fn_impl_trait_ids(decl, header, &mut ids);\n                 ids\n             },\n             ItemKind::Impl(.., None, _, ref items) => {\n                 let mut ids = smallvec![hir::ItemId { id: i.id }];\n                 for item in items {\n                     if let ImplItemKind::Method(ref sig, _) = item.node {\n-                        self.lower_impl_trait_ids(&sig.decl, &sig.header, &mut ids);\n+                        self.lower_fn_impl_trait_ids(&sig.decl, &sig.header, &mut ids);\n                     }\n                 }\n                 ids\n             },\n+            ItemKind::Static(ref ty, ..) => {\n+                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            ItemKind::Const(ref ty, ..) => {\n+                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n             _ => smallvec![hir::ItemId { id: i.id }],\n         }\n     }\n@@ -3761,8 +3820,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Block(ref blk, opt_label) => {\n                 hir::ExprKind::Block(self.lower_block(blk,\n-                                                opt_label.is_some()),\n-                                                self.lower_label(opt_label))\n+                                                      opt_label.is_some()),\n+                                                      self.lower_label(opt_label))\n             }\n             ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n@@ -4312,15 +4371,32 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_stmt(&mut self, s: &Stmt) -> OneVector<hir::Stmt> {\n         smallvec![match s.node {\n-            StmtKind::Local(ref l) => Spanned {\n-                node: hir::StmtKind::Decl(\n-                    P(Spanned {\n-                        node: hir::DeclKind::Local(self.lower_local(l)),\n+            StmtKind::Local(ref l) => {\n+                let (l, item_ids) = self.lower_local(l);\n+                let mut ids: OneVector<hir::Stmt> = item_ids\n+                    .into_iter()\n+                    .map(|item_id| Spanned {\n+                        node: hir::StmtKind::Decl(\n+                            P(Spanned {\n+                                node: hir::DeclKind::Item(item_id),\n+                                span: s.span,\n+                            }),\n+                            self.next_id().node_id,\n+                        ),\n                         span: s.span,\n-                    }),\n-                    self.lower_node_id(s.id).node_id,\n-                ),\n-                span: s.span,\n+                    })\n+                    .collect();\n+                ids.push(Spanned {\n+                    node: hir::StmtKind::Decl(\n+                        P(Spanned {\n+                            node: hir::DeclKind::Local(l),\n+                            span: s.span,\n+                        }),\n+                        self.lower_node_id(s.id).node_id,\n+                    ),\n+                    span: s.span,\n+                });\n+                return ids;\n             },\n             StmtKind::Item(ref it) => {\n                 // Can only use the ID once.\n@@ -4334,8 +4410,8 @@ impl<'a> LoweringContext<'a> {\n                                 span: s.span,\n                             }),\n                             id.take()\n-                                .map(|id| self.lower_node_id(id).node_id)\n-                                .unwrap_or_else(|| self.next_id().node_id),\n+                              .map(|id| self.lower_node_id(id).node_id)\n+                              .unwrap_or_else(|| self.next_id().node_id),\n                         ),\n                         span: s.span,\n                     })"}, {"sha": "26cf8f5d2ae5c031c2670433375d450cb9f051a1", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -102,9 +102,9 @@ impl<'a> DefCollector<'a> {\n             visit::walk_fn_decl(this, decl);\n \n             let closure_def = this.create_def(closure_id,\n-                                  DefPathData::ClosureExpr,\n-                                  REGULAR_SPACE,\n-                                  span);\n+                                              DefPathData::ClosureExpr,\n+                                              REGULAR_SPACE,\n+                                              span);\n             this.with_parent(closure_def, |this| {\n                 visit::walk_block(this, body);\n             })"}, {"sha": "88d375742670d2e68dbfe0b2f4d44842328b18b6", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -98,9 +98,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// # Parameters\n     ///\n-    /// - `parent_def_id` -- we will only instantiate opaque types\n-    ///   with this parent. This is typically the def-id of the function\n-    ///   in whose return type opaque types are being instantiated.\n+    /// - `parent_def_id` -- the def-id of the function in which the opaque type\n+    ///   is defined\n     /// - `body_id` -- the body-id with which the resulting obligations should\n     ///   be associated\n     /// - `param_env` -- the in-scope parameter environment to be used for\n@@ -113,11 +112,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?},\n-            parent_def_id={:?}, body_id={:?},\n-            param_env={:?})\",\n-            value, parent_def_id, body_id, param_env,\n+        debug!(\"instantiate_opaque_types(value={:?}, parent_def_id={:?}, body_id={:?}, \\\n+                param_env={:?})\",\n+               value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -736,7 +733,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n                         debug!(\n                             \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside it's definition scope \\\n+                             encountered opaque outside its definition scope \\\n                              def_id={:?}\",\n                             def_id,\n                         );\n@@ -808,8 +805,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         for predicate in bounds.predicates {\n             // Change the predicate to refer to the type variable,\n-            // which will be the concrete type, instead of the Opaque.\n-            // This also instantiates nested `impl Trait`.\n+            // which will be the concrete type instead of the opaque type.\n+            // This also instantiates nested instances of `impl Trait`.\n             let predicate = self.instantiate_opaque_types_in_map(&predicate);\n \n             let cause = traits::ObligationCause::new(span, self.body_id, traits::SizedReturnType);"}, {"sha": "98042e18d32d9bd0913a4913aa6b59caf52bb84b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -361,7 +361,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     let tcx = relation.tcx();\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    debug!(\"super_relate_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     match (a_sty, b_sty) {\n         (&ty::Infer(_), _) |\n         (_, &ty::Infer(_)) =>"}, {"sha": "8e4819b68a95f6e1d3e07d531fff2364af15a222", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -79,8 +79,8 @@ impl BoundRegion {\n     }\n }\n \n-/// NB: If you change this, you'll probably want to change the corresponding\n-/// AST structure in libsyntax/ast.rs as well.\n+/// N.B., If you change this, you'll probably want to change the corresponding\n+/// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n@@ -158,7 +158,7 @@ pub enum TyKind<'tcx> {\n     Projection(ProjectionTy<'tcx>),\n \n     /// Opaque (`impl Trait`) type found in a return type.\n-    /// The DefId comes either from\n+    /// The `DefId` comes either from\n     /// * the `impl Trait` ast::Ty node,\n     /// * or the `existential type` declaration\n     /// The substitutions are for the generics of the function in question.\n@@ -168,7 +168,7 @@ pub enum TyKind<'tcx> {\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param(ParamTy),\n \n-    /// A type variable used during type-checking.\n+    /// A type variable used during type checking.\n     Infer(InferTy),\n \n     /// A placeholder for a type which could not be computed; this is"}, {"sha": "acde4587d77dcad5a75cf0f79a1455850eaf96f4", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 16, "deletions": 133, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -14,18 +14,11 @@\n //! are supplied to us before normalization and may contain existential\n //! `impl Trait` instances. In contrast, the input/output types found in\n //! the MIR (specifically, in the special local variables for the\n-//! `RETURN_PLACE` the MIR arguments) are always fully normalize (and\n+//! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use borrow_check::nll::renumber;\n-use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use rustc::hir::def_id::DefId;\n-use rustc::infer::InferOk;\n use rustc::mir::*;\n-use rustc::traits::query::type_op::custom::CustomTypeOp;\n-use rustc::traits::{ObligationCause, PredicateObligations};\n-use rustc::ty::subst::Subst;\n use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -37,16 +30,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         mir: &Mir<'tcx>,\n-        mir_def_id: DefId,\n         universal_regions: &UniversalRegions<'tcx>,\n-        universal_region_relations: &UniversalRegionRelations<'tcx>,\n         normalized_inputs_and_output: &[Ty<'tcx>],\n     ) {\n-        let tcx = self.infcx.tcx;\n-\n         let (&normalized_output_ty, normalized_input_tys) =\n             normalized_inputs_and_output.split_last().unwrap();\n-        let infcx = self.infcx;\n \n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n@@ -77,111 +65,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n-        let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n         let output_span = mir.local_decls[RETURN_PLACE].source_info.span;\n-        let opaque_type_map =\n-            self.fully_perform_op(\n-                Locations::All(output_span),\n-                ConstraintCategory::BoringNoLocation,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        let mut obligations = ObligationAccumulator::default();\n-\n-                        let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, opaque_type_map) =\n-                            obligations.add(infcx.instantiate_opaque_types(\n-                                mir_def_id,\n-                                dummy_body_id,\n-                                param_env,\n-                                &normalized_output_ty,\n-                            ));\n-                        debug!(\n-                            \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                            output_ty\n-                        );\n-                        debug!(\n-                            \"equate_inputs_and_outputs: opaque_type_map={:#?}\",\n-                            opaque_type_map\n-                        );\n-\n-                        debug!(\n-                            \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                            mir_output_ty\n-                        );\n-                        obligations.add(\n-                            infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(output_ty, mir_output_ty)?,\n-                        );\n-\n-                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                            let opaque_defn_ty = renumber::renumber_regions(\n-                                infcx,\n-                                &opaque_defn_ty,\n-                            );\n-                            debug!(\n-                                \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                                opaque_decl.concrete_ty\n-                            );\n-                            debug!(\"equate_inputs_and_outputs: opaque_defn_ty={:?}\",\n-                                   opaque_defn_ty);\n-                            obligations.add(\n-                                infcx\n-                                    .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n-                            );\n-                        }\n-\n-                        debug!(\"equate_inputs_and_outputs: equated\");\n-\n-                        Ok(InferOk {\n-                            value: Some(opaque_type_map),\n-                            obligations: obligations.into_vec(),\n-                        })\n-                    },\n-                    || \"input_output\".to_string(),\n-                ),\n-            ).unwrap_or_else(|terr| {\n-                span_mirbug!(\n-                    self,\n-                    Location::START,\n-                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    normalized_output_ty,\n-                    mir_output_ty,\n-                    terr\n-                );\n-                None\n-            });\n-\n-        // Finally, if we instantiated the opaque types successfully, we\n-        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n-        // prove that `T: Iterator` where `T` is the type we\n-        // instantiated it with).\n-        if let Some(opaque_type_map) = opaque_type_map {\n-            for (opaque_def_id, opaque_decl) in opaque_type_map {\n-                self.fully_perform_op(\n-                    Locations::All(infcx.tcx.def_span(opaque_def_id)),\n-                    ConstraintCategory::OpaqueType,\n-                    CustomTypeOp::new(\n-                        |_cx| {\n-                            infcx.constrain_opaque_type(\n-                                opaque_def_id,\n-                                &opaque_decl,\n-                                universal_region_relations\n-                            );\n-                            Ok(InferOk {\n-                                value: (),\n-                                obligations: vec![],\n-                            })\n-                        },\n-                        || \"opaque_type_map\".to_string(),\n-                    ),\n-                ).unwrap();\n-            }\n-        }\n+        if let Err(terr) = self.eq_opaque_type_and_type(\n+            mir_output_ty,\n+            normalized_output_ty,\n+            Locations::All(output_span),\n+            ConstraintCategory::BoringNoLocation,\n+        ) {\n+            span_mirbug!(\n+                self,\n+                Location::START,\n+                \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n+                normalized_output_ty,\n+                mir_output_ty,\n+                terr\n+            );\n+        };\n     }\n \n     fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n@@ -204,20 +104,3 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n }\n-\n-#[derive(Debug, Default)]\n-struct ObligationAccumulator<'tcx> {\n-    obligations: PredicateObligations<'tcx>,\n-}\n-\n-impl<'tcx> ObligationAccumulator<'tcx> {\n-    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = value;\n-        self.obligations.extend(obligations);\n-        value\n-    }\n-\n-    fn into_vec(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}"}, {"sha": "70687d0efa4025e168082fff1bb9748d25b3f0a0", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -22,22 +22,26 @@ use borrow_check::nll::type_check::free_region_relations::{\n };\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::renumber;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::GenericKind;\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n+use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::traits::query::type_op;\n+use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::subst::Subst;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -98,7 +102,7 @@ mod relate_tys;\n ///   to outlive; should represent the fn body\n /// - `input_tys` -- fully liberated, but **not** normalized, expected types of the arguments;\n ///   the types of the input parameters found in the MIR itself will be equated with these\n-/// - `output_ty` -- fully liberaetd, but **not** normalized, expected return type;\n+/// - `output_ty` -- fully liberated, but **not** normalized, expected return type;\n ///   the type for the RETURN_PLACE will be equated with this\n /// - `liveness` -- results of a liveness computation on the MIR; used to create liveness\n ///   constraints for the regions in the types of variables\n@@ -155,12 +159,11 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             &region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n+            Some(&universal_region_relations),\n             |cx| {\n                 cx.equate_inputs_and_outputs(\n                     mir,\n-                    mir_def_id,\n                     universal_regions,\n-                    &universal_region_relations,\n                     &normalized_inputs_and_output,\n                 );\n                 liveness::generate(cx, mir, elements, flow_inits, move_data);\n@@ -182,6 +185,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n@@ -192,6 +196,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n         region_bound_pairs,\n         implicit_region_bound,\n         borrowck_context,\n+        universal_region_relations,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -692,6 +697,7 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -799,6 +805,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+        universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -810,6 +817,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             implicit_region_bound,\n             borrowck_context,\n             reported_errors: FxHashSet(),\n+            universal_region_relations,\n         }\n     }\n \n@@ -883,6 +891,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    fn sub_types_or_anon(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n+            if let TyKind::Opaque(..) = sup.sty {\n+                return self.eq_opaque_type_and_type(sub, sup, locations, category);\n+            } else {\n+                return Err(terr);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn eq_types(\n         &mut self,\n         a: Ty<'tcx>,\n@@ -919,6 +944,112 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    fn eq_opaque_type_and_type(\n+        &mut self,\n+        revealed_ty: Ty<'tcx>,\n+        anon_ty: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+        let param_env = self.param_env;\n+        let parent_def_id = infcx.tcx.closure_base_def_id(self.mir_def_id);\n+        let opaque_type_map =\n+            self.fully_perform_op(\n+                locations,\n+                category,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        let mut obligations = ObligationAccumulator::default();\n+\n+                        let dummy_body_id = ObligationCause::dummy().body_id;\n+                        let (output_ty, opaque_type_map) =\n+                            obligations.add(infcx.instantiate_opaque_types(\n+                                parent_def_id,\n+                                dummy_body_id,\n+                                param_env,\n+                                &anon_ty,\n+                            ));\n+                        debug!(\n+                            \"eq_opaque_type_and_type: \\\n+                             instantiated output_ty={:?} \\\n+                             opaque_type_map={:#?} \\\n+                             revealed_ty={:?}\",\n+                            output_ty,\n+                            opaque_type_map,\n+                            revealed_ty\n+                        );\n+                        obligations.add(\n+                            infcx\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(output_ty, revealed_ty)?,\n+                        );\n+\n+                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                            let opaque_defn_ty = renumber::renumber_regions(\n+                                infcx,\n+                                &opaque_defn_ty,\n+                            );\n+                            debug!(\n+                                \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n+                                opaque_decl.concrete_ty,\n+                                opaque_defn_ty\n+                            );\n+                            obligations.add(\n+                                infcx\n+                                    .at(&ObligationCause::dummy(), param_env)\n+                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n+                            );\n+                        }\n+\n+                        debug!(\"eq_opaque_type_and_type: equated\");\n+\n+                        Ok(InferOk {\n+                            value: Some(opaque_type_map),\n+                            obligations: obligations.into_vec(),\n+                        })\n+                    },\n+                    || \"input_output\".to_string(),\n+                ),\n+            )?;\n+\n+        let universal_region_relations = match self.universal_region_relations {\n+            Some(rel) => rel,\n+            None => return Ok(()),\n+        };\n+\n+        // Finally, if we instantiated the anon types successfully, we\n+        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n+        // prove that `T: Iterator` where `T` is the type we\n+        // instantiated it with).\n+        if let Some(opaque_type_map) = opaque_type_map {\n+            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+                self.fully_perform_op(\n+                    locations,\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |_cx| {\n+                            infcx.constrain_opaque_type(\n+                                opaque_def_id,\n+                                &opaque_decl,\n+                                universal_region_relations\n+                            );\n+                            Ok(InferOk {\n+                                value: (),\n+                                obligations: vec![],\n+                            })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -942,7 +1073,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(\n+                if let Err(terr) = self.sub_types_or_anon(\n                     rv_ty,\n                     place_ty,\n                     location.to_locations(),\n@@ -1235,7 +1366,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types(\n+                if let Err(terr) = self.sub_types_or_anon(\n                     sig.output(),\n                     dest_ty,\n                     locations,\n@@ -2104,6 +2235,7 @@ impl MirPass for TypeckMir {\n                 &[],\n                 None,\n                 None,\n+                None,\n                 |_| (),\n             );\n \n@@ -2128,3 +2260,21 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n+\n+#[derive(Debug, Default)]\n+struct ObligationAccumulator<'tcx> {\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'tcx> ObligationAccumulator<'tcx> {\n+    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = value;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+\n+    fn into_vec(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+"}, {"sha": "ac754f9af58fc348fb2d9085ae71179d94cd1600", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .pat_binding_modes_mut()\n                     .insert(pat.hir_id, bm);\n                 debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let typ = self.local_ty(pat.span, pat.id);\n+                let local_ty = self.local_ty(pat.span, pat.id).decl_ty;\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n                         // if the binding is like\n@@ -249,28 +249,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n                         // an explanation.\n-                        self.demand_eqtype(pat.span, region_ty, typ);\n+                        self.demand_eqtype(pat.span, region_ty, local_ty);\n                     }\n                     // otherwise the type of x is the expected type T\n                     ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n-                        self.demand_eqtype(pat.span, expected, typ);\n+                        self.demand_eqtype(pat.span, expected, local_ty);\n                     }\n                 }\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n                 if var_id != pat.id {\n-                    let vt = self.local_ty(pat.span, var_id);\n-                    self.demand_eqtype(pat.span, vt, typ);\n+                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n+                    self.demand_eqtype(pat.span, vt, local_ty);\n                 }\n \n                 if let Some(ref p) = *sub {\n                     self.check_pat_walk(&p, expected, def_bm, true);\n                 }\n \n-                typ\n+                local_ty\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n                 self.check_pat_tuple_struct(pat, qpath, &subpats, ddpos, expected, def_bm)"}, {"sha": "716dfce32fdcbf49ce71eaaecb42181a39341269", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -1039,8 +1039,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     }\n \n     /// Indicates that the value generated by `expression`, which is\n-    /// of type `expression_ty`, is one of the possibility that we\n-    /// could coerce from. This will record `expression` and later\n+    /// of type `expression_ty`, is one of the possibilities that we\n+    /// could coerce from. This will record `expression`, and later\n     /// calls to `coerce` may come back and add adjustments and things\n     /// if necessary.\n     pub fn coerce<'a>(&mut self,"}, {"sha": "5f6cc4c60c38c7284aaa70d64bf180308a15a386", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 158, "deletions": 125, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -65,7 +65,7 @@ nodes within the function.\n The types of top-level items, which never contain unbound type\n variables, are stored directly into the `tcx` tables.\n \n-n.b.: A type variable is not the same thing as a type parameter.  A\n+N.B.: A type variable is not the same thing as a type parameter.  A\n type variable is rather an \"instance\" of a type parameter: that is,\n given a generic function `fn foo<T>(t: T)`: while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n@@ -154,6 +154,13 @@ mod generator_interior;\n mod intrinsic;\n mod op;\n \n+/// The type of a local binding, including the revealed type for anon types.\n+#[derive(Copy, Clone)]\n+pub struct LocalTy<'tcx> {\n+    decl_ty: Ty<'tcx>,\n+    revealed_ty: Ty<'tcx>\n+}\n+\n /// A wrapper for InferCtxt's `in_progress_tables` field.\n #[derive(Copy, Clone)]\n struct MaybeInProgressTables<'a, 'tcx: 'a> {\n@@ -180,7 +187,6 @@ impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n     }\n }\n \n-\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n@@ -195,7 +201,7 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     tables: MaybeInProgressTables<'a, 'tcx>,\n \n-    locals: RefCell<NodeMap<Ty<'tcx>>>,\n+    locals: RefCell<NodeMap<LocalTy<'tcx>>>,\n \n     fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n@@ -815,8 +821,8 @@ fn has_typeck_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn used_trait_imports<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              def_id: DefId)\n-                              -> Lrc<DefIdSet> {\n+                                def_id: DefId)\n+                                -> Lrc<DefIdSet> {\n     tcx.typeck_tables_of(def_id).used_trait_imports.clone()\n }\n \n@@ -846,7 +852,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             check_abi(tcx, span, fn_sig.abi());\n \n-            // Compute the fty from point of view of inside fn.\n+            // Compute the fty from point of view of inside the fn.\n             let fn_sig =\n                 tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n@@ -863,10 +869,19 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n+            let revealed_ty = if tcx.features().impl_trait_in_bindings {\n+                fcx.instantiate_opaque_types_from_value(\n+                    id,\n+                    &expected_type\n+                )\n+            } else {\n+                expected_type\n+            };\n+\n             // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor { fcx: &fcx }.visit_body(body);\n+            GatherLocalsVisitor { fcx: &fcx, parent_id: id, }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n \n             fcx\n         };\n@@ -914,22 +929,26 @@ fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n }\n \n struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    parent_id: ast::NodeId,\n }\n \n impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n-    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n+    fn assign(&mut self, span: Span, nid: ast::NodeId, ty_opt: Option<LocalTy<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n                 let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n-                self.fcx.locals.borrow_mut().insert(nid, var_ty);\n+                self.fcx.locals.borrow_mut().insert(nid, LocalTy {\n+                    decl_ty: var_ty,\n+                    revealed_ty: var_ty\n+                });\n                 var_ty\n             }\n             Some(typ) => {\n                 // take type that the user specified\n                 self.fcx.locals.borrow_mut().insert(nid, typ);\n-                typ\n+                typ.revealed_ty\n             }\n         }\n     }\n@@ -942,24 +961,34 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'gcx hir::Local) {\n-        let o_ty = match local.ty {\n+        let local_ty = match local.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_response(&o_ty);\n-                debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, c_ty);\n+                let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n+                    self.fcx.instantiate_opaque_types_from_value(\n+                        self.parent_id,\n+                        &o_ty\n+                    )\n+                } else {\n+                    o_ty\n+                };\n+\n+                let c_ty = self.fcx.inh.infcx.canonicalize_response(&revealed_ty);\n+                debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n+                       ty.hir_id, o_ty, revealed_ty, c_ty);\n                 self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n \n-                Some(o_ty)\n+                Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             },\n             None => None,\n         };\n-        self.assign(local.span, local.id, o_ty);\n+        self.assign(local.span, local.id, local_ty);\n \n         debug!(\"Local variable {:?} is assigned type {}\",\n                local.pat,\n                self.fcx.ty_to_string(\n-                   self.fcx.locals.borrow().get(&local.id).unwrap().clone()));\n+                   self.fcx.locals.borrow().get(&local.id).unwrap().clone().decl_ty));\n         intravisit::walk_local(self, local);\n     }\n \n@@ -976,7 +1005,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                    ident,\n                    self.fcx.ty_to_string(\n-                       self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n+                       self.fcx.locals.borrow().get(&p.id).unwrap().clone().decl_ty),\n                    var_ty);\n         }\n         intravisit::walk_pat(self, p);\n@@ -1027,7 +1056,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let revealed_ret_ty = fcx.instantiate_opaque_types_from_return_value(fn_id, &declared_ret_ty);\n+    let revealed_ret_ty = fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1045,7 +1074,9 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    GatherLocalsVisitor { fcx: &fcx, }.visit_body(body);\n+    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir.local_def_id(fn_id));\n+    let outer_node_id = fcx.tcx.hir.as_local_node_id(outer_def_id).unwrap();\n+    GatherLocalsVisitor { fcx: &fcx, parent_id: outer_node_id, }.visit_body(body);\n \n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n@@ -1274,90 +1305,96 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n-    debug!(\"check_item_type(it.id={}, it.name={})\",\n-           it.id,\n-           tcx.item_path_str(tcx.hir.local_def_id(it.id)));\n+pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n+    debug!(\n+        \"check_item_type(it.id={}, it.name={})\",\n+        it.id,\n+        tcx.item_path_str(tcx.hir.local_def_id(it.id))\n+    );\n     let _indenter = indenter();\n     match it.node {\n-      // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemKind::Static(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        tcx.typeck_tables_of(def_id);\n-        maybe_check_static_with_link_section(tcx, def_id, it.span);\n-      }\n-      hir::ItemKind::Const(..) => {\n-        tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n-      }\n-      hir::ItemKind::Enum(ref enum_definition, _) => {\n-        check_enum(tcx,\n-                   it.span,\n-                   &enum_definition.variants,\n-                   it.id);\n-      }\n-      hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-      hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-          debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n-          let impl_def_id = tcx.hir.local_def_id(it.id);\n-          if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-              check_impl_items_against_trait(tcx,\n-                                             it.span,\n-                                             impl_def_id,\n-                                             impl_trait_ref,\n-                                             impl_item_refs);\n-              let trait_def_id = impl_trait_ref.def_id;\n-              check_on_unimplemented(tcx, trait_def_id, it);\n-          }\n-      }\n-      hir::ItemKind::Trait(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        check_on_unimplemented(tcx, def_id, it);\n-      }\n-      hir::ItemKind::Struct(..) => {\n-        check_struct(tcx, it.id, it.span);\n-      }\n-      hir::ItemKind::Union(..) => {\n-        check_union(tcx, it.id, it.span);\n-      }\n-      hir::ItemKind::Existential(..) |\n-      hir::ItemKind::Ty(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        let pty_ty = tcx.type_of(def_id);\n-        let generics = tcx.generics_of(def_id);\n-        check_bounds_are_used(tcx, &generics, pty_ty);\n-      }\n-      hir::ItemKind::ForeignMod(ref m) => {\n-        check_abi(tcx, it.span, m.abi);\n-\n-        if m.abi == Abi::RustIntrinsic {\n-            for item in &m.items {\n-                intrinsic::check_intrinsic_type(tcx, item);\n-            }\n-        } else if m.abi == Abi::PlatformIntrinsic {\n-            for item in &m.items {\n-                intrinsic::check_platform_intrinsic_type(tcx, item);\n+        // Consts can play a role in type-checking, so they are included here.\n+        hir::ItemKind::Static(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            tcx.typeck_tables_of(def_id);\n+            maybe_check_static_with_link_section(tcx, def_id, it.span);\n+        }\n+        hir::ItemKind::Const(..) => {\n+            tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n+        }\n+        hir::ItemKind::Enum(ref enum_definition, _) => {\n+            check_enum(tcx, it.span, &enum_definition.variants, it.id);\n+        }\n+        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+            debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n+            let impl_def_id = tcx.hir.local_def_id(it.id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+                check_impl_items_against_trait(\n+                    tcx,\n+                    it.span,\n+                    impl_def_id,\n+                    impl_trait_ref,\n+                    impl_item_refs,\n+                );\n+                let trait_def_id = impl_trait_ref.def_id;\n+                check_on_unimplemented(tcx, trait_def_id, it);\n             }\n-        } else {\n-            for item in &m.items {\n-                let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-                if generics.params.len() - generics.own_counts().lifetimes != 0 {\n-                    let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n-                        \"foreign items may not have type parameters\");\n-                    err.span_label(item.span, \"can't have type parameters\");\n-                    // FIXME: once we start storing spans for type arguments, turn this into a\n-                    // suggestion.\n-                    err.help(\"use specialization instead of type parameters by replacing them \\\n-                              with concrete types like `u32`\");\n-                    err.emit();\n+        }\n+        hir::ItemKind::Trait(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            check_on_unimplemented(tcx, def_id, it);\n+        }\n+        hir::ItemKind::Struct(..) => {\n+            check_struct(tcx, it.id, it.span);\n+        }\n+        hir::ItemKind::Union(..) => {\n+            check_union(tcx, it.id, it.span);\n+        }\n+        hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            let pty_ty = tcx.type_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n+            check_bounds_are_used(tcx, &generics, pty_ty);\n+        }\n+        hir::ItemKind::ForeignMod(ref m) => {\n+            check_abi(tcx, it.span, m.abi);\n+\n+            if m.abi == Abi::RustIntrinsic {\n+                for item in &m.items {\n+                    intrinsic::check_intrinsic_type(tcx, item);\n+                }\n+            } else if m.abi == Abi::PlatformIntrinsic {\n+                for item in &m.items {\n+                    intrinsic::check_platform_intrinsic_type(tcx, item);\n                 }\n+            } else {\n+                for item in &m.items {\n+                    let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n+                    if generics.params.len() - generics.own_counts().lifetimes != 0 {\n+                        let mut err = struct_span_err!(\n+                            tcx.sess,\n+                            item.span,\n+                            E0044,\n+                            \"foreign items may not have type parameters\"\n+                        );\n+                        err.span_label(item.span, \"can't have type parameters\");\n+                        // FIXME: once we start storing spans for type arguments, turn this into a\n+                        // suggestion.\n+                        err.help(\n+                            \"use specialization instead of type parameters by replacing them \\\n+                             with concrete types like `u32`\",\n+                        );\n+                        err.emit();\n+                    }\n \n-                if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n-                    require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n+                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n+                        require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n+                    }\n                 }\n             }\n         }\n-      }\n-      _ => {/* nothing to do */ }\n+        _ => { /* nothing to do */ }\n     }\n }\n \n@@ -2040,7 +2077,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         format!(\"{:?}\", self_ptr)\n     }\n \n-    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n+    pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> LocalTy<'tcx> {\n         match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n@@ -2225,25 +2262,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    /// Replace the opaque types from the return value of the\n-    /// function with type variables and records the `OpaqueTypeMap` for\n-    /// later use during writeback. See\n+    /// Replace the opaque types from the given value with type variables,\n+    /// and records the `OpaqueTypeMap` for later use during writeback. See\n     /// `InferCtxt::instantiate_opaque_types` for more details.\n-    fn instantiate_opaque_types_from_return_value<T: TypeFoldable<'tcx>>(\n+    fn instantiate_opaque_types_from_value<T: TypeFoldable<'tcx>>(\n         &self,\n-        fn_id: ast::NodeId,\n+        parent_id: ast::NodeId,\n         value: &T,\n     ) -> T {\n-        let fn_def_id = self.tcx.hir.local_def_id(fn_id);\n-        debug!(\n-            \"instantiate_opaque_types_from_return_value(fn_def_id={:?}, value={:?})\",\n-            fn_def_id,\n-            value\n-        );\n+        let parent_def_id = self.tcx.hir.local_def_id(parent_id);\n+        debug!(\"instantiate_opaque_types_from_value(parent_def_id={:?}, value={:?})\",\n+               parent_def_id,\n+               value);\n \n         let (value, opaque_type_map) = self.register_infer_ok_obligations(\n             self.instantiate_opaque_types(\n-                fn_def_id,\n+                parent_def_id,\n                 self.body_id,\n                 self.param_env,\n                 value,\n@@ -2889,7 +2923,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n                 // We're processing function arguments so we definitely want to use\n                 // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty,  AllowTwoPhase::Yes);\n+                self.demand_coerce(&arg, checked_ty, coerce_ty, AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -3048,7 +3082,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n-    fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n+    fn check_expr_with_hint(&self,\n+                            expr: &'gcx hir::Expr,\n                             expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n@@ -3197,7 +3232,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-\n     // A generic function for checking the then and else in an if\n     // or if-else.\n     fn check_then_else(&self,\n@@ -3739,9 +3773,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// that there are actually multiple representations for `Error`, so avoid\n     /// that when err needs to be handled differently.\n     fn check_expr_with_expectation_and_needs(&self,\n-                                                   expr: &'gcx hir::Expr,\n-                                                   expected: Expectation<'tcx>,\n-                                                   needs: Needs) -> Ty<'tcx> {\n+                                             expr: &'gcx hir::Expr,\n+                                             expected: Expectation<'tcx>,\n+                                             needs: Needs) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n \n@@ -3827,8 +3861,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => Needs::None\n                 };\n                 let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                                    expected_inner,\n-                                                                                    needs);\n+                                                                             expected_inner,\n+                                                                             needs);\n \n                 if !oprnd_t.references_error() {\n                     oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n@@ -3858,8 +3892,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 self.write_method_call(expr.hir_id, method);\n                             } else {\n                                 type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n-                                                    \"type `{}` cannot be dereferenced\",\n-                                                    oprnd_t).emit();\n+                                                   \"type `{}` cannot be dereferenced\",\n+                                                   oprnd_t).emit();\n                                 oprnd_t = tcx.types.err;\n                             }\n                         }\n@@ -4083,7 +4117,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::If(ref cond, ref then_expr, ref opt_else_expr) => {\n                 self.check_then_else(&cond, then_expr, opt_else_expr.as_ref().map(|e| &**e),\n-                                    expr.span, expected)\n+                                     expr.span, expected)\n             }\n             hir::ExprKind::While(ref cond, ref body, _) => {\n                 let ctxt = BreakableCtxt {\n@@ -4471,7 +4505,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // See #44848.\n         let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n-        let local_ty = self.local_ty(init.span, local.id);\n+        let local_ty = self.local_ty(init.span, local.id).revealed_ty;\n         if let Some(m) = ref_bindings {\n             // Somewhat subtle: if we have a `ref` binding in the pattern,\n             // we want to avoid introducing coercions for the RHS. This is\n@@ -4490,7 +4524,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n-        let t = self.local_ty(local.span, local.id);\n+        let t = self.local_ty(local.span, local.id).decl_ty;\n         self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n@@ -4827,7 +4861,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-\n     /// A possible error is to forget to add a return type that is needed:\n     ///\n     /// ```\n@@ -5069,7 +5102,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         match def {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n-                let ty = self.local_ty(span, nid);\n+                let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n                 self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n                 return (ty, def);"}, {"sha": "6595ce0facf696baf23005bbeabd7f5ef1613fdb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -75,7 +75,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// The Writerback context. This visitor walks the AST, checking the\n+// The Writeback context. This visitor walks the AST, checking the\n // fn-specific tables to find references to types or regions. It\n // resolves those regions to remove inference variables and writes the\n // final result back into the master tables in the tcx. Here and\n@@ -290,7 +290,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n-        let var_ty = self.fcx.local_ty(l.span, l.id);\n+        let var_ty = self.fcx.local_ty(l.span, l.id).decl_ty;\n         let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.hir_id, var_ty);\n     }"}, {"sha": "2faa38fd9f87799559a81cbea1b3fb7762143d7b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -497,7 +497,7 @@ declare_features! (\n     // Allows `Self` in type definitions\n     (active, self_in_typedefs, \"1.30.0\", Some(49303), None),\n \n-    // unsized rvalues at arguments and parameters\n+    // Allows unsized rvalues at arguments and parameters\n     (active, unsized_locals, \"1.30.0\", Some(48055), None),\n \n     // #![test_runner]\n@@ -508,13 +508,16 @@ declare_features! (\n     (active, custom_inner_attributes, \"1.30.0\", Some(38356), None),\n \n     // Self struct constructor  (RFC 2302)\n-    (active, self_struct_ctor, \"1.31.0\", Some(51994), None),\n+    (active, self_struct_ctor, \"1.30.0\", Some(51994), None),\n \n     // allow mixing of bind-by-move in patterns and references to\n     // those identifiers in guards, *if* we are using MIR-borrowck\n     // (aka NLL). Essentially this means you need to be on\n     // edition:2018 or later.\n     (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n+\n+    // Allows `impl Trait` in bindings (`let`, `const`, `static`)\n+    (active, impl_trait_in_bindings, \"1.30.0\", Some(34511), None),\n );\n \n declare_features! ("}, {"sha": "631967c3f08b0edf758e0c90e895feee0927a60f", "filename": "src/test/run-pass/impl-trait-in-bindings.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Frun-pass%2Fimpl-trait-in-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Frun-pass%2Fimpl-trait-in-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait-in-bindings.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(impl_trait_in_bindings)]\n+\n+use std::fmt::Debug;\n+\n+const FOO: impl Debug + Clone + PartialEq<i32> = 42;\n+\n+static BAR: impl Debug + Clone + PartialEq<i32> = 42;\n+\n+fn a<T: Clone>(x: T) {\n+    let y: impl Clone = x;\n+    let _ = y.clone();\n+}\n+\n+fn b<T: Clone>(x: T) {\n+    let f = move || {\n+        let y: impl Clone = x;\n+        let _ = y.clone();\n+    };\n+    f();\n+}\n+\n+trait Foo<T: Clone> {\n+    fn a(x: T) {\n+        let y: impl Clone = x;\n+        let _ = y.clone();\n+    }\n+}\n+\n+impl<T: Clone> Foo<T> for i32 {\n+    fn a(x: T) {\n+        let y: impl Clone = x;\n+        let _ = y.clone();\n+    }\n+}\n+\n+fn main() {\n+    let foo: impl Debug + Clone + PartialEq<i32> = 42;\n+\n+    assert_eq!(FOO.clone(), 42);\n+    assert_eq!(BAR.clone(), 42);\n+    assert_eq!(foo.clone(), 42);\n+\n+    a(42);\n+    b(42);\n+    i32::a(42);\n+}"}, {"sha": "9c76719e26cf20fc6af6818464b590b26c88b14e", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_bindings.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: impl Copy = 42;\n+\n+static BAR: impl Copy = 42;\n+\n+fn main() {\n+    let foo = impl Copy = 42;\n+}"}, {"sha": "52c99a7b159e381e8369aaa3630d8f9145124b1b", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_bindings.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,21 @@\n+error: expected expression, found keyword `impl`\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:16:15\n+   |\n+LL |     let foo = impl Copy = 42;\n+   |               ^^^^ expected expression\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:11:12\n+   |\n+LL | const FOO: impl Copy = 42;\n+   |            ^^^^^^^^^\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:13:13\n+   |\n+LL | static BAR: impl Copy = 42;\n+   |             ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0562`."}, {"sha": "4b476a0a645b1541900a37d9536985c75ceb5e98", "filename": "src/test/ui/feature-gates/feature-gate-self_in_typedefs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "previous_filename": "src/test/ui/feature-gates/feature-gate-self-in-typedefs.rs"}, {"sha": "22ca92bbe1391b50c999faf0f5de838f19316c15", "filename": "src/test/ui/feature-gates/feature-gate-self_in_typedefs.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -1,5 +1,5 @@\n error[E0411]: cannot find type `Self` in this scope\n-  --> $DIR/feature-gate-self-in-typedefs.rs:13:17\n+  --> $DIR/feature-gate-self_in_typedefs.rs:13:17\n    |\n LL |     Cons(T, &'a Self)\n    |                 ^^^^ `Self` is only available in traits and impls", "previous_filename": "src/test/ui/feature-gates/feature-gate-self-in-typedefs.stderr"}, {"sha": "88b7a52af7fd36d15715543da012c0ec2e6b8bb7", "filename": "src/test/ui/impl-trait/bindings-opaque.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(impl_trait_in_bindings)]\n+\n+const FOO: impl Copy = 42;\n+\n+static BAR: impl Copy = 42;\n+\n+fn main() {\n+    let foo: impl Copy = 42;\n+\n+    let _ = FOO.count_ones();\n+    let _ = BAR.count_ones();\n+    let _ = foo.count_ones();\n+}"}, {"sha": "00358ee502e8686d6bf1c5481135870f3fbdefa0", "filename": "src/test/ui/impl-trait/bindings-opaque.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings-opaque.stderr?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,21 @@\n+error[E0599]: no method named `count_ones` found for type `impl std::marker::Copy` in the current scope\n+  --> $DIR/bindings-opaque.rs:20:17\n+   |\n+LL |     let _ = FOO.count_ones();\n+   |                 ^^^^^^^^^^\n+\n+error[E0599]: no method named `count_ones` found for type `impl std::marker::Copy` in the current scope\n+  --> $DIR/bindings-opaque.rs:21:17\n+   |\n+LL |     let _ = BAR.count_ones();\n+   |                 ^^^^^^^^^^\n+\n+error[E0599]: no method named `count_ones` found for type `impl std::marker::Copy` in the current scope\n+  --> $DIR/bindings-opaque.rs:22:17\n+   |\n+LL |     let _ = foo.count_ones();\n+   |                 ^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "571571aa75141b1b3723be78d78eb8d58c2dc3a0", "filename": "src/test/ui/impl-trait/bindings.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(impl_trait_in_bindings)]\n+\n+fn a<T: Clone>(x: T) {\n+    const foo: impl Clone = x;\n+}\n+\n+fn b<T: Clone>(x: T) {\n+    let _ = move || {\n+        const foo: impl Clone = x;\n+    };\n+}\n+\n+trait Foo<T: Clone> {\n+    fn a(x: T) {\n+        const foo: impl Clone = x;\n+    }\n+}\n+\n+impl<T: Clone> Foo<T> for i32 {\n+    fn a(x: T) {\n+        const foo: impl Clone = x;\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "70a736d2fd18a075d90df51d8d6bd66124d9d250", "filename": "src/test/ui/impl-trait/bindings.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbindings.stderr?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -0,0 +1,35 @@\n+error[E0434]: can't capture dynamic environment in a fn item\n+  --> $DIR/bindings.rs:14:29\n+   |\n+LL |     const foo: impl Clone = x;\n+   |                             ^\n+   |\n+   = help: use the `|| { ... }` closure form instead\n+\n+error[E0434]: can't capture dynamic environment in a fn item\n+  --> $DIR/bindings.rs:19:33\n+   |\n+LL |         const foo: impl Clone = x;\n+   |                                 ^\n+   |\n+   = help: use the `|| { ... }` closure form instead\n+\n+error[E0434]: can't capture dynamic environment in a fn item\n+  --> $DIR/bindings.rs:25:33\n+   |\n+LL |         const foo: impl Clone = x;\n+   |                                 ^\n+   |\n+   = help: use the `|| { ... }` closure form instead\n+\n+error[E0434]: can't capture dynamic environment in a fn item\n+  --> $DIR/bindings.rs:31:33\n+   |\n+LL |         const foo: impl Clone = x;\n+   |                                 ^\n+   |\n+   = help: use the `|| { ... }` closure form instead\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0434`."}, {"sha": "4c5592c119c974c034e44812ec6f44baf222aafa", "filename": "src/test/ui/impl-trait/where-allowed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4141a4079e3e6b2c4ac104fed042a9b7241467eb/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fwhere-allowed.rs?ref=4141a4079e3e6b2c4ac104fed042a9b7241467eb", "patch": "@@ -232,4 +232,3 @@ fn main() {\n     let _in_return_in_local_variable = || -> impl Fn() { || {} };\n     //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n }\n-"}]}