{"sha": "7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZjIxZTUyZWJkOGFjMmIzY2U2ZDBhYWM4MjkyYmY1NWMzOTQ3N2U=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T19:22:32Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-13T21:31:24Z"}, "message": "Implement rwlock.downgrade and tests", "tree": {"sha": "9ce4980bbc4cb8cb5a21d1cfdbc4a290a26b404c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ce4980bbc4cb8cb5a21d1cfdbc4a290a26b404c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "html_url": "https://github.com/rust-lang/rust/commit/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c4843d9da70aeb402fc788e07e7912ecbee3559", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c4843d9da70aeb402fc788e07e7912ecbee3559", "html_url": "https://github.com/rust-lang/rust/commit/6c4843d9da70aeb402fc788e07e7912ecbee3559"}], "stats": {"total": 238, "additions": 202, "deletions": 36}, "files": [{"sha": "2650c1f734d55e5e5f93152c3d61db830227ab29", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 202, "deletions": 36, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=7cf21e52ebd8ac2b3ce6d0aac8292bf55c39477e", "patch": "@@ -142,9 +142,9 @@ struct sem_and_signal_release {\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-struct condvar { priv sem: &sem<waitqueue>; }\n+struct condvar { priv sem: &sem<waitqueue>; drop { } }\n \n-impl condvar {\n+impl &condvar {\n     /// Atomically drop the associated lock, and block until a signal is sent.\n     fn wait() {\n         // Create waiter nobe.\n@@ -212,8 +212,9 @@ impl condvar {\n }\n \n impl &sem<waitqueue> {\n-    fn access_cond<U>(blk: fn(condvar) -> U) -> U {\n-        do self.access { blk(condvar { sem: self }) }\n+    // The only other place that condvars get built is rwlock_write_mode.\n+    fn access_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n+        do self.access { blk(&condvar { sem: self }) }\n     }\n }\n \n@@ -272,7 +273,7 @@ impl &mutex {\n     fn lock<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(blk: fn(condvar) -> U) -> U {\n+    fn lock_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -321,12 +322,18 @@ impl &rwlock {\n                 do (&self.order_lock).access {\n                     let mut first_reader = false;\n                     do self.state.with |state| {\n-                        state.read_mode = true;\n                         first_reader = (state.read_count == 0);\n                         state.read_count += 1;\n                     }\n                     if first_reader {\n                         (&self.access_lock).acquire();\n+                        do self.state.with |state| {\n+                            // Must happen *after* getting access_lock. If\n+                            // this is set while readers are waiting, but\n+                            // while a writer holds the lock, the writer will\n+                            // be confused if they downgrade-then-unlock.\n+                            state.read_mode = true;\n+                        }\n                     }\n                 }\n                 release = some(rwlock_release_read(self));\n@@ -357,7 +364,7 @@ impl &rwlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(blk: fn(condvar) -> U) -> U {\n+    fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -374,7 +381,62 @@ impl &rwlock {\n         }\n     }\n \n-    // to-do implement downgrade\n+    /**\n+     * As write(), but with the ability to atomically 'downgrade' the lock;\n+     * i.e., to become a reader without letting other writers get the lock in\n+     * the meantime (such as unlocking and then re-locking as a reader would\n+     * do). The block takes a \"write mode token\" argument, which can be\n+     * transformed into a \"read mode token\" by calling downgrade(). Example:\n+     *\n+     *     do lock.write_downgrade |write_mode| {\n+     *         do (&write_mode).write_cond |condvar| {\n+     *             ... exclusive access ...\n+     *         }\n+     *         let read_mode = lock.downgrade(write_mode);\n+     *         do (&read_mode).read {\n+     *             ... shared access ...\n+     *         }\n+     *     }\n+     */\n+    fn write_downgrade<U>(blk: fn(+rwlock_write_mode) -> U) -> U {\n+        // Implementation slightly different from the slicker 'write's above.\n+        // The exit path is conditional on whether the caller downgrades.\n+        let mut _release = none;\n+        unsafe {\n+            do task::unkillable {\n+                (&self.order_lock).acquire();\n+                (&self.access_lock).acquire();\n+                (&self.order_lock).release();\n+            }\n+            _release = some(rwlock_release_downgrade(self));\n+        }\n+        blk(rwlock_write_mode { lock: self })\n+    }\n+\n+    fn downgrade(+token: rwlock_write_mode) -> rwlock_read_mode {\n+        if !ptr::ref_eq(self, token.lock) {\n+            fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n+        }\n+        unsafe {\n+            do task::unkillable {\n+                let mut first_reader = false;\n+                do self.state.with |state| {\n+                    assert !state.read_mode;\n+                    state.read_mode = true;\n+                    first_reader = (state.read_count == 0);\n+                    state.read_count += 1;\n+                }\n+                if !first_reader {\n+                    // Guaranteed not to let another writer in, because\n+                    // another reader was holding the order_lock. Hence they\n+                    // must be the one to get the access_lock (because all\n+                    // access_locks are acquired with order_lock held).\n+                    (&self.access_lock).release();\n+                }\n+            }\n+        }\n+        rwlock_read_mode { lock: token.lock }\n+    }\n }\n \n // FIXME(#3136) should go inside of read()\n@@ -386,8 +448,12 @@ struct rwlock_release_read {\n             let mut last_reader = false;\n             do self.lock.state.with |state| {\n                 assert state.read_mode;\n+                assert state.read_count > 0;\n                 state.read_count -= 1;\n-                last_reader = (state.read_count == 0);\n+                if state.read_count == 0 {\n+                    last_reader = true;\n+                    state.read_mode = false;\n+                }\n             }\n             if last_reader {\n                 (&self.lock.access_lock).release();\n@@ -396,6 +462,56 @@ struct rwlock_release_read {\n     }\n }\n \n+// FIXME(#3136) should go inside of downgrade()\n+struct rwlock_release_downgrade {\n+    lock: &rwlock;\n+    new(lock: &rwlock) { self.lock = lock; }\n+    drop unsafe {\n+        do task::unkillable {\n+            let mut writer_or_last_reader = false;\n+            do self.lock.state.with |state| {\n+                if state.read_mode {\n+                    assert state.read_count > 0;\n+                    state.read_count -= 1;\n+                    if state.read_count == 0 {\n+                        // Case 1: Writer downgraded & was the last reader\n+                        writer_or_last_reader = true;\n+                        state.read_mode = false;\n+                    } else {\n+                        // Case 2: Writer downgraded & was not the last reader\n+                    }\n+                } else {\n+                    // Case 3: Writer did not downgrade\n+                    writer_or_last_reader = true;\n+                }\n+            }\n+            if writer_or_last_reader {\n+                (&self.lock.access_lock).release();\n+            }\n+        }\n+    }\n+}\n+\n+/// The \"write permission\" token used for rwlock.write_downgrade().\n+// FIXME(#3145): make lock priv somehow\n+struct rwlock_write_mode { lock: &rwlock; drop { } }\n+/// The \"read permission\" token used for rwlock.write_downgrade().\n+struct rwlock_read_mode  { priv lock: &rwlock; drop { } }\n+\n+// FIXME(#3145) XXX Region invariance forbids \"mode.write(blk)\"\n+impl rwlock_write_mode {\n+    /// Access the pre-downgrade rwlock in write mode.\n+    fn write<U>(blk: fn() -> U) -> U { blk() }\n+    /// Access the pre-downgrade rwlock in write mode with a condvar.\n+    fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n+        blk(&condvar { sem: &self.lock.access_lock })\n+    }\n+}\n+impl rwlock_read_mode {\n+    /// Access the post-downgrade rwlock in read mode.\n+    fn read<U>(blk: fn() -> U) -> U { blk() }\n+}\n+\n /****************************************************************************\n  * Tests\n  ****************************************************************************/\n@@ -510,9 +626,11 @@ mod tests {\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n-            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n+            let sharedstate: &mut int =\n+                unsafe { unsafe::reinterpret_cast(ptr) };\n             access_shared(sharedstate, m2, 10);\n             c.send(());\n+\n         }\n         access_shared(sharedstate, m, 10);\n         let _ = p.recv();\n@@ -645,21 +763,27 @@ mod tests {\n         // child task must have finished by the time try returns\n         do m.lock_cond |cond| {\n             let _woken = cond.signal();\n-            // FIXME(#3145) - The semantics of pipes are not quite what I want\n-            // here - the pipe doesn't get 'terminated' if the child was\n-            // punted awake during failure.\n-            // assert !woken;\n+            // FIXME(#3145) this doesn't work\n+            //assert !woken;\n         }\n     }\n     /************************************************************************\n      * Reader/writer lock tests\n      ************************************************************************/\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &rwlock, reader: bool, blk: fn()) {\n-        if reader { x.read(blk); } else { x.write(blk); }\n+    enum rwlock_mode { read, write, downgrade, downgrade_read }\n+    #[cfg(test)]\n+    fn lock_rwlock_in_mode(x: &rwlock, mode: rwlock_mode, blk: fn()) {\n+        match mode {\n+            read => x.read(blk),\n+            write => x.write(blk),\n+            downgrade => do x.write_downgrade |mode| { mode.write(blk); },\n+            downgrade_read =>\n+                do x.write_downgrade |mode| { x.downgrade(mode).read(blk); },\n+        }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(reader1: bool, reader2: bool) {\n+    fn test_rwlock_exclusion(mode1: rwlock_mode, mode2: rwlock_mode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (c,p) = pipes::stream();\n@@ -668,19 +792,20 @@ mod tests {\n         let sharedstate = ~0;\n         let ptr = ptr::addr_of(*sharedstate);\n         do task::spawn {\n-            let sharedstate = unsafe { unsafe::reinterpret_cast(ptr) };\n-            access_shared(sharedstate, x2, reader1, 10);\n+            let sharedstate: &mut int =\n+                unsafe { unsafe::reinterpret_cast(ptr) };\n+            access_shared(sharedstate, x2, mode1, 10);\n             c.send(());\n         }\n-        access_shared(sharedstate, x, reader2, 10);\n+        access_shared(sharedstate, x, mode2, 10);\n         let _ = p.recv();\n \n         assert *sharedstate == 20;\n \n-        fn access_shared(sharedstate: &mut int, x: &rwlock, reader: bool,\n+        fn access_shared(sharedstate: &mut int, x: &rwlock, mode: rwlock_mode,\n                          n: uint) {\n             for n.times {\n-                do lock_rwlock_in_mode(x, reader) {\n+                do lock_rwlock_in_mode(x, mode) {\n                     let oldval = *sharedstate;\n                     task::yield();\n                     *sharedstate = oldval + 1;\n@@ -690,32 +815,59 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(true, false);\n-        test_rwlock_exclusion(false, true);\n+        test_rwlock_exclusion(read, write);\n+        test_rwlock_exclusion(write, read);\n+        test_rwlock_exclusion(read, downgrade);\n+        test_rwlock_exclusion(downgrade, read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(false, false);\n+        test_rwlock_exclusion(write, write);\n+        test_rwlock_exclusion(write, downgrade);\n+        test_rwlock_exclusion(downgrade, write);\n+        test_rwlock_exclusion(downgrade, downgrade);\n     }\n-    #[test]\n-    fn test_rwlock_readers_and_readers() {\n+    #[cfg(test)]\n+    fn test_rwlock_handshake(mode1: rwlock_mode, mode2: rwlock_mode,\n+                             make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x = ~rwlock();\n         let x2 = ~x.clone();\n         let (c1,p1) = pipes::stream();\n         let (c2,p2) = pipes::stream();\n         do task::spawn {\n-            do x2.read {\n+            if !make_mode2_go_first {\n+                let _ = p2.recv(); // parent sends to us once it locks, or ...\n+            }\n+            do lock_rwlock_in_mode(x2, mode2) {\n+                if make_mode2_go_first {\n+                    c1.send(()); // ... we send to it once we lock\n+                }\n                 let _ = p2.recv();\n                 c1.send(());\n             }\n         }\n-        do x.read {\n+        if make_mode2_go_first {\n+            let _ = p1.recv(); // child sends to us once it locks, or ...\n+        }\n+        do lock_rwlock_in_mode(x, mode1) {\n+            if !make_mode2_go_first {\n+                c2.send(()); // ... we send to it once we lock\n+            }\n             c2.send(());\n             let _ = p1.recv();\n         }\n     }\n     #[test]\n+    fn test_rwlock_readers_and_readers() {\n+        test_rwlock_handshake(read, read, false);\n+        // The downgrader needs to get in before the reader gets in, otherwise\n+        // they cannot end up reading at the same time.\n+        test_rwlock_handshake(downgrade_read, read, false);\n+        test_rwlock_handshake(read, downgrade_read, true);\n+        // Two downgrade_reads can never both end up reading at the same time.\n+    }\n+    #[test]\n     fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = ~rwlock();\n@@ -751,26 +903,40 @@ mod tests {\n         do x.read { } // Just for good measure\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    fn rwlock_kill_helper(reader1: bool, reader2: bool) {\n+    fn rwlock_kill_helper(mode1: rwlock_mode, mode2: rwlock_mode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let x = ~rwlock();\n         let x2 = ~x.clone();\n \n         let result: result::result<(),()> = do task::try {\n-            do lock_rwlock_in_mode(x2, reader1) {\n+            do lock_rwlock_in_mode(x2, mode1) {\n                 fail;\n             }\n         };\n         assert result.is_err();\n         // child task must have finished by the time try returns\n-        do lock_rwlock_in_mode(x, reader2) { }\n+        do lock_rwlock_in_mode(x, mode2) { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(true, false); }\n+    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(read, write); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(false,true ); }\n+    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(write,read ); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(true, true ); }\n+    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(read, read ); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(false,false); }\n+    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(write,write); }\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn test_rwlock_downgrade_cant_swap() {\n+        // Tests that you can't downgrade with a different rwlock's token.\n+        let x = ~rwlock();\n+        let y = ~rwlock();\n+        do x.write_downgrade |xwrite| {\n+            let mut xopt = some(xwrite);\n+            do y.write_downgrade |_ywrite| {\n+                do y.downgrade(option::swap_unwrap(&mut xopt)).read {\n+                    error!(\"oops, y.downgrade(x) should have failed!\");\n+                }\n+            }\n+        }\n+    }\n }"}]}