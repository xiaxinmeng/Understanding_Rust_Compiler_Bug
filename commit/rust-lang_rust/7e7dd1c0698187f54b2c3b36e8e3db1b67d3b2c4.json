{"sha": "7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "node_id": "C_kwDOAAsO6NoAKDdlN2RkMWMwNjk4MTg3ZjU0YjJjM2IzNmU4ZTNkYjFiNjdkM2IyYzQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-05-28T06:45:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-28T06:45:52Z"}, "message": "Rollup merge of #97327 - davidtwco:diagnostic-translation-compile-time-validation, r=oli-obk\n\nmacros: introduce `fluent_messages` macro\n\nAdds a new `fluent_messages` macro which performs compile-time validation of the compiler's Fluent resources (i.e. that the resources parse and don't multiply define the same messages) and generates constants that make using those messages in diagnostics more ergonomic.\n\nFor example, given the following invocation of the macro..\n\n```rust\nfluent_messages! {\n    typeck => \"./typeck.ftl\",\n}\n```\n\n..where `typeck.ftl` has the following contents..\n\n```fluent\ntypeck-field-multiply-specified-in-initializer =\n    field `{$ident}` specified more than once\n    .label = used more than once\n    .label-previous-use = first use of `{$ident}`\n```\n\n...then the macro parse the Fluent resource, emitting a diagnostic if it fails to do so...\n\n```text\nerror: could not parse Fluent resource\n  --> $DIR/test.rs:35:28\n   |\nLL |         missing_message => \"./missing-message.ftl\",\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: see additional errors emitted\n\nerror: expected a message field for \"missing-message\"\n --> ./missing-message.ftl:1:1\n  |\n1 | missing-message =\n  | ^^^^^^^^^^^^^^^^^^\n  |\n```\n...or generating the following code if it succeeds:\n\n```rust\npub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n    include_str!(\"./typeck.ftl\"),\n];\n\nmod fluent_generated {\n    mod typeck {\n        pub const field_multiply_specified_in_initializer: DiagnosticMessage =\n            DiagnosticMessage::fluent(\"typeck-field-multiply-specified-in-initializer\");\n        pub const field_multiply_specified_in_initializer_label_previous_use: DiagnosticMessage =\n            DiagnosticMessage::fluent_attr(\n                \"typeck-field-multiply-specified-in-initializer\",\n                \"previous-use-label\"\n            );\n    }\n}\n```\n\nWhen emitting a diagnostic, the generated constants can be used as follows:\n\n```rust\nlet mut err = sess.struct_span_err(\n    span,\n    fluent::typeck::field_multiply_specified_in_initializer\n);\nerr.span_label(\n    span,\n    fluent::typeck::field_multiply_specified_in_initializer_label\n);\nerr.span_label(\n    previous_use_span,\n    fluent::typeck::field_multiply_specified_in_initializer_label_previous_use\n);\nerr.emit();\n```\n\nI'd like to reduce the verbosity of referring to labels/notes/helps with this scheme (though it wasn't much better before), but I'll leave that for a follow-up.\n\nr? `@oli-obk`\ncc `@pvdrz` `@compiler-errors`", "tree": {"sha": "faa7d38ed03cd7bc729f121b6234c04a106dd14b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa7d38ed03cd7bc729f121b6234c04a106dd14b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJikcUhCRBK7hj4Ov3rIwAAS2oIAADzLUBF/IWRjU45MS0dr3m2\n4qRcNjFIZNc2Vye2k1/p2QC5GxxyASBmLarQtGjAmQ9pYNlLTlwFcGxdyS0P49pH\n5NwCjrLuRKFbiWG7F6H2YeSBAal6vwA7B3hKpqHA6XzFZie9HrIrj3I/wJ9PnLP6\nrg0/BUFlQnSN3Cz6ZXtIuAoPmrWw49tD2Lp0/Vn3VoVwixBMF0DnW244zJXagsXM\n/Glqfvl0/ruy9AVszDBUl26WdOzc8AiBiMtbav8zg/G4PQBz1EgWpbgZTlLYsy3V\ng9PlKRuTRMLpWM9HGlCxfO8+YQxuQWaP1R3nSfL9QIZ3FKPNd4DRtPIOKCfIQr8=\n=ZYzx\n-----END PGP SIGNATURE-----\n", "payload": "tree faa7d38ed03cd7bc729f121b6234c04a106dd14b\nparent 880d3ea3c22dbdfdcaa288ac2b60fb1126bb828d\nparent ce9901fcee396764aaea7b1bce3f82b1b4f554d2\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1653720352 +0200\ncommitter GitHub <noreply@github.com> 1653720352 +0200\n\nRollup merge of #97327 - davidtwco:diagnostic-translation-compile-time-validation, r=oli-obk\n\nmacros: introduce `fluent_messages` macro\n\nAdds a new `fluent_messages` macro which performs compile-time validation of the compiler's Fluent resources (i.e. that the resources parse and don't multiply define the same messages) and generates constants that make using those messages in diagnostics more ergonomic.\n\nFor example, given the following invocation of the macro..\n\n```rust\nfluent_messages! {\n    typeck => \"./typeck.ftl\",\n}\n```\n\n..where `typeck.ftl` has the following contents..\n\n```fluent\ntypeck-field-multiply-specified-in-initializer =\n    field `{$ident}` specified more than once\n    .label = used more than once\n    .label-previous-use = first use of `{$ident}`\n```\n\n...then the macro parse the Fluent resource, emitting a diagnostic if it fails to do so...\n\n```text\nerror: could not parse Fluent resource\n  --> $DIR/test.rs:35:28\n   |\nLL |         missing_message => \"./missing-message.ftl\",\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: see additional errors emitted\n\nerror: expected a message field for \"missing-message\"\n --> ./missing-message.ftl:1:1\n  |\n1 | missing-message =\n  | ^^^^^^^^^^^^^^^^^^\n  |\n```\n...or generating the following code if it succeeds:\n\n```rust\npub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n    include_str!(\"./typeck.ftl\"),\n];\n\nmod fluent_generated {\n    mod typeck {\n        pub const field_multiply_specified_in_initializer: DiagnosticMessage =\n            DiagnosticMessage::fluent(\"typeck-field-multiply-specified-in-initializer\");\n        pub const field_multiply_specified_in_initializer_label_previous_use: DiagnosticMessage =\n            DiagnosticMessage::fluent_attr(\n                \"typeck-field-multiply-specified-in-initializer\",\n                \"previous-use-label\"\n            );\n    }\n}\n```\n\nWhen emitting a diagnostic, the generated constants can be used as follows:\n\n```rust\nlet mut err = sess.struct_span_err(\n    span,\n    fluent::typeck::field_multiply_specified_in_initializer\n);\nerr.span_label(\n    span,\n    fluent::typeck::field_multiply_specified_in_initializer_label\n);\nerr.span_label(\n    previous_use_span,\n    fluent::typeck::field_multiply_specified_in_initializer_label_previous_use\n);\nerr.emit();\n```\n\nI'd like to reduce the verbosity of referring to labels/notes/helps with this scheme (though it wasn't much better before), but I'll leave that for a follow-up.\n\nr? `@oli-obk`\ncc `@pvdrz` `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "html_url": "https://github.com/rust-lang/rust/commit/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880d3ea3c22dbdfdcaa288ac2b60fb1126bb828d", "url": "https://api.github.com/repos/rust-lang/rust/commits/880d3ea3c22dbdfdcaa288ac2b60fb1126bb828d", "html_url": "https://github.com/rust-lang/rust/commit/880d3ea3c22dbdfdcaa288ac2b60fb1126bb828d"}, {"sha": "ce9901fcee396764aaea7b1bce3f82b1b4f554d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce9901fcee396764aaea7b1bce3f82b1b4f554d2", "html_url": "https://github.com/rust-lang/rust/commit/ce9901fcee396764aaea7b1bce3f82b1b4f554d2"}], "stats": {"total": 473, "additions": 455, "deletions": 18}, "files": [{"sha": "42bf166a71cb2002da876f58427d844f84644fec", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -4010,10 +4010,14 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n+ \"annotate-snippets\",\n+ \"fluent-bundle\",\n+ \"fluent-syntax\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n  \"synstructure\",\n+ \"unic-langid\",\n ]\n \n [[package]]"}, {"sha": "7faf14a2472416701beec3b3782f4e916bc5d2c6", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -6,7 +6,7 @@\n use fluent_bundle::FluentResource;\n use fluent_syntax::parser::ParserError;\n use rustc_data_structures::sync::Lrc;\n-use rustc_macros::{Decodable, Encodable};\n+use rustc_macros::{fluent_messages, Decodable, Encodable};\n use rustc_span::Span;\n use std::borrow::Cow;\n use std::error::Error;\n@@ -29,8 +29,13 @@ use intl_memoizer::IntlLangMemoizer;\n pub use fluent_bundle::{FluentArgs, FluentError, FluentValue};\n pub use unic_langid::{langid, LanguageIdentifier};\n \n-pub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] =\n-    &[include_str!(\"../locales/en-US/typeck.ftl\"), include_str!(\"../locales/en-US/parser.ftl\")];\n+// Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n+fluent_messages! {\n+    parser => \"../locales/en-US/parser.ftl\",\n+    typeck => \"../locales/en-US/typeck.ftl\",\n+}\n+\n+pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};\n \n pub type FluentBundle = fluent_bundle::bundle::FluentBundle<FluentResource, IntlLangMemoizer>;\n "}, {"sha": "5b9b65da34364a3724977b6ee3370022da84e316", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -31,8 +31,8 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n-    fallback_fluent_bundle, fluent_bundle, DiagnosticMessage, FluentBundle, LanguageIdentifier,\n-    LazyFallbackBundle, MultiSpan, SpanLabel, DEFAULT_LOCALE_RESOURCES,\n+    fallback_fluent_bundle, fluent, fluent_bundle, DiagnosticMessage, FluentBundle,\n+    LanguageIdentifier, LazyFallbackBundle, MultiSpan, SpanLabel, DEFAULT_LOCALE_RESOURCES,\n };\n pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_span::source_map::SourceMap;"}, {"sha": "25b3aadc1c527c6e241a4e3a91f6067f7fcfc247", "filename": "compiler/rustc_macros/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2FCargo.toml?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -7,7 +7,11 @@ edition = \"2021\"\n proc-macro = true\n \n [dependencies]\n+annotate-snippets = \"0.8.0\"\n+fluent-bundle = \"0.15.2\"\n+fluent-syntax = \"0.11\"\n synstructure = \"0.12.1\"\n syn = { version = \"1\", features = [\"full\"] }\n proc-macro2 = \"1\"\n quote = \"1\"\n+unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "8523d7fa9f9882d2d9d3111aa0068cf91452da79", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "added", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1,254 @@\n+use annotate_snippets::{\n+    display_list::DisplayList,\n+    snippet::{Annotation, AnnotationType, Slice, Snippet, SourceAnnotation},\n+};\n+use fluent_bundle::{FluentBundle, FluentError, FluentResource};\n+use fluent_syntax::{\n+    ast::{Attribute, Entry, Identifier, Message},\n+    parser::ParserError,\n+};\n+use proc_macro::{Diagnostic, Level, Span};\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+use std::{\n+    collections::HashMap,\n+    fs::File,\n+    io::Read,\n+    path::{Path, PathBuf},\n+};\n+use syn::{\n+    parse::{Parse, ParseStream},\n+    parse_macro_input,\n+    punctuated::Punctuated,\n+    token, Ident, LitStr, Result,\n+};\n+use unic_langid::langid;\n+\n+struct Resource {\n+    ident: Ident,\n+    #[allow(dead_code)]\n+    fat_arrow_token: token::FatArrow,\n+    resource: LitStr,\n+}\n+\n+impl Parse for Resource {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        Ok(Resource {\n+            ident: input.parse()?,\n+            fat_arrow_token: input.parse()?,\n+            resource: input.parse()?,\n+        })\n+    }\n+}\n+\n+struct Resources(Punctuated<Resource, token::Comma>);\n+\n+impl Parse for Resources {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let mut resources = Punctuated::new();\n+        loop {\n+            if input.is_empty() || input.peek(token::Brace) {\n+                break;\n+            }\n+            let value = input.parse()?;\n+            resources.push_value(value);\n+            if !input.peek(token::Comma) {\n+                break;\n+            }\n+            let punct = input.parse()?;\n+            resources.push_punct(punct);\n+        }\n+        Ok(Resources(resources))\n+    }\n+}\n+\n+/// Helper function for returning an absolute path for macro-invocation relative file paths.\n+///\n+/// If the input is already absolute, then the input is returned. If the input is not absolute,\n+/// then it is appended to the directory containing the source file with this macro invocation.\n+fn invocation_relative_path_to_absolute(span: Span, path: &str) -> PathBuf {\n+    let path = Path::new(path);\n+    if path.is_absolute() {\n+        path.to_path_buf()\n+    } else {\n+        // `/a/b/c/foo/bar.rs` contains the current macro invocation\n+        let mut source_file_path = span.source_file().path();\n+        // `/a/b/c/foo/`\n+        source_file_path.pop();\n+        // `/a/b/c/foo/../locales/en-US/example.ftl`\n+        source_file_path.push(path);\n+        source_file_path\n+    }\n+}\n+\n+/// See [rustc_macros::fluent_messages].\n+pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    let resources = parse_macro_input!(input as Resources);\n+\n+    // Cannot iterate over individual messages in a bundle, so do that using the\n+    // `FluentResource` instead. Construct a bundle anyway to find out if there are conflicting\n+    // messages in the resources.\n+    let mut bundle = FluentBundle::new(vec![langid!(\"en-US\")]);\n+\n+    // Map of Fluent identifiers to the `Span` of the resource that defined them, used for better\n+    // diagnostics.\n+    let mut previous_defns = HashMap::new();\n+\n+    let mut includes = TokenStream::new();\n+    let mut generated = TokenStream::new();\n+    for res in resources.0 {\n+        let ident_span = res.ident.span().unwrap();\n+        let path_span = res.resource.span().unwrap();\n+\n+        let relative_ftl_path = res.resource.value();\n+        let absolute_ftl_path =\n+            invocation_relative_path_to_absolute(ident_span, &relative_ftl_path);\n+        // As this macro also outputs an `include_str!` for this file, the macro will always be\n+        // re-executed when the file changes.\n+        let mut resource_file = match File::open(absolute_ftl_path) {\n+            Ok(resource_file) => resource_file,\n+            Err(e) => {\n+                Diagnostic::spanned(path_span, Level::Error, \"could not open Fluent resource\")\n+                    .note(e.to_string())\n+                    .emit();\n+                continue;\n+            }\n+        };\n+        let mut resource_contents = String::new();\n+        if let Err(e) = resource_file.read_to_string(&mut resource_contents) {\n+            Diagnostic::spanned(path_span, Level::Error, \"could not read Fluent resource\")\n+                .note(e.to_string())\n+                .emit();\n+            continue;\n+        }\n+        let resource = match FluentResource::try_new(resource_contents) {\n+            Ok(resource) => resource,\n+            Err((this, errs)) => {\n+                Diagnostic::spanned(path_span, Level::Error, \"could not parse Fluent resource\")\n+                    .help(\"see additional errors emitted\")\n+                    .emit();\n+                for ParserError { pos, slice: _, kind } in errs {\n+                    let mut err = kind.to_string();\n+                    // Entirely unnecessary string modification so that the error message starts\n+                    // with a lowercase as rustc errors do.\n+                    err.replace_range(\n+                        0..1,\n+                        &err.chars().next().unwrap().to_lowercase().to_string(),\n+                    );\n+\n+                    let line_starts: Vec<usize> = std::iter::once(0)\n+                        .chain(\n+                            this.source()\n+                                .char_indices()\n+                                .filter_map(|(i, c)| Some(i + 1).filter(|_| c == '\\n')),\n+                        )\n+                        .collect();\n+                    let line_start = line_starts\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(line, idx)| (line + 1, idx))\n+                        .filter(|(_, idx)| **idx <= pos.start)\n+                        .last()\n+                        .unwrap()\n+                        .0;\n+\n+                    let snippet = Snippet {\n+                        title: Some(Annotation {\n+                            label: Some(&err),\n+                            id: None,\n+                            annotation_type: AnnotationType::Error,\n+                        }),\n+                        footer: vec![],\n+                        slices: vec![Slice {\n+                            source: this.source(),\n+                            line_start,\n+                            origin: Some(&relative_ftl_path),\n+                            fold: true,\n+                            annotations: vec![SourceAnnotation {\n+                                label: \"\",\n+                                annotation_type: AnnotationType::Error,\n+                                range: (pos.start, pos.end - 1),\n+                            }],\n+                        }],\n+                        opt: Default::default(),\n+                    };\n+                    let dl = DisplayList::from(snippet);\n+                    eprintln!(\"{}\\n\", dl);\n+                }\n+                continue;\n+            }\n+        };\n+\n+        let mut constants = TokenStream::new();\n+        for entry in resource.entries() {\n+            let span = res.ident.span();\n+            if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n+                let _ = previous_defns.entry(name.to_string()).or_insert(ident_span);\n+\n+                // `typeck-foo-bar` => `foo_bar`\n+                let snake_name = Ident::new(\n+                    &name.replace(&format!(\"{}-\", res.ident), \"\").replace(\"-\", \"_\"),\n+                    span,\n+                );\n+                constants.extend(quote! {\n+                    pub const #snake_name: crate::DiagnosticMessage =\n+                        crate::DiagnosticMessage::FluentIdentifier(\n+                            std::borrow::Cow::Borrowed(#name),\n+                            None\n+                        );\n+                });\n+\n+                for Attribute { id: Identifier { name: attr_name }, .. } in attributes {\n+                    let attr_snake_name = attr_name.replace(\"-\", \"_\");\n+                    let snake_name = Ident::new(&format!(\"{snake_name}_{attr_snake_name}\"), span);\n+                    constants.extend(quote! {\n+                        pub const #snake_name: crate::DiagnosticMessage =\n+                            crate::DiagnosticMessage::FluentIdentifier(\n+                                std::borrow::Cow::Borrowed(#name),\n+                                Some(std::borrow::Cow::Borrowed(#attr_name))\n+                            );\n+                    });\n+                }\n+            }\n+        }\n+\n+        if let Err(errs) = bundle.add_resource(resource) {\n+            for e in errs {\n+                match e {\n+                    FluentError::Overriding { kind, id } => {\n+                        Diagnostic::spanned(\n+                            ident_span,\n+                            Level::Error,\n+                            format!(\"overrides existing {}: `{}`\", kind, id),\n+                        )\n+                        .span_help(previous_defns[&id], \"previously defined in this resource\")\n+                        .emit();\n+                    }\n+                    FluentError::ResolverError(_) | FluentError::ParserError(_) => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        includes.extend(quote! { include_str!(#relative_ftl_path), });\n+\n+        let ident = res.ident;\n+        generated.extend(quote! {\n+            pub mod #ident {\n+                #constants\n+            }\n+        });\n+    }\n+\n+    quote! {\n+        #[allow(non_upper_case_globals)]\n+        #[doc(hidden)]\n+        pub mod fluent_generated {\n+            pub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n+                #includes\n+            ];\n+\n+            #generated\n+        }\n+    }\n+    .into()\n+}"}, {"sha": "69573d904d4a9c3475eb844c3119602218bfacf9", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -1,9 +1,11 @@\n mod diagnostic;\n mod error;\n+mod fluent;\n mod subdiagnostic;\n mod utils;\n \n use diagnostic::SessionDiagnosticDerive;\n+pub(crate) use fluent::fluent_messages;\n use proc_macro2::TokenStream;\n use quote::format_ident;\n use subdiagnostic::SessionSubdiagnosticDerive;\n@@ -12,7 +14,7 @@ use synstructure::Structure;\n /// Implements `#[derive(SessionDiagnostic)]`, which allows for errors to be specified as a struct,\n /// independent from the actual diagnostics emitting code.\n ///\n-/// ```ignore (pseudo-rust)\n+/// ```ignore (rust)\n /// # extern crate rustc_errors;\n /// # use rustc_errors::Applicability;\n /// # extern crate rustc_span;\n@@ -43,7 +45,7 @@ use synstructure::Structure;\n ///\n /// Then, later, to emit the error:\n ///\n-/// ```ignore (pseudo-rust)\n+/// ```ignore (rust)\n /// sess.emit_err(MoveOutOfBorrowError {\n ///     expected,\n ///     actual,\n@@ -67,7 +69,7 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// suggestions to be specified as a structs or enums, independent from the actual diagnostics\n /// emitting code or diagnostic derives.\n ///\n-/// ```ignore (pseudo-rust)\n+/// ```ignore (rust)\n /// #[derive(SessionSubdiagnostic)]\n /// pub enum ExpectedIdentifierLabel<'tcx> {\n ///     #[label(slug = \"parser-expected-identifier\")]\n@@ -104,7 +106,7 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n ///\n /// Then, later, to add the subdiagnostic:\n ///\n-/// ```ignore (pseudo-rust)\n+/// ```ignore (rust)\n /// diag.subdiagnostic(ExpectedIdentifierLabel::WithoutFound { span });\n ///\n /// diag.subdiagnostic(RawIdentifierSuggestion { span, applicability, ident });"}, {"sha": "7c8e3c6d1402474882a6071c32caa496c7c69bf1", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -2,6 +2,7 @@\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(proc_macro_diagnostic)]\n+#![feature(proc_macro_span)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -49,6 +50,64 @@ pub fn newtype_index(input: TokenStream) -> TokenStream {\n     newtype::newtype(input)\n }\n \n+/// Implements the `fluent_messages` macro, which performs compile-time validation of the\n+/// compiler's Fluent resources (i.e. that the resources parse and don't multiply define the same\n+/// messages) and generates constants that make using those messages in diagnostics more ergonomic.\n+///\n+/// For example, given the following invocation of the macro..\n+///\n+/// ```ignore (rust)\n+/// fluent_messages! {\n+///     typeck => \"./typeck.ftl\",\n+/// }\n+/// ```\n+/// ..where `typeck.ftl` has the following contents..\n+///\n+/// ```fluent\n+/// typeck-field-multiply-specified-in-initializer =\n+///     field `{$ident}` specified more than once\n+///     .label = used more than once\n+///     .label-previous-use = first use of `{$ident}`\n+/// ```\n+/// ...then the macro parse the Fluent resource, emitting a diagnostic if it fails to do so, and\n+/// will generate the following code:\n+///\n+/// ```ignore (rust)\n+/// pub static DEFAULT_LOCALE_RESOURCES: &'static [&'static str] = &[\n+///     include_str!(\"./typeck.ftl\"),\n+/// ];\n+///\n+/// mod fluent_generated {\n+///     mod typeck {\n+///         pub const field_multiply_specified_in_initializer: DiagnosticMessage =\n+///             DiagnosticMessage::fluent(\"typeck-field-multiply-specified-in-initializer\");\n+///         pub const field_multiply_specified_in_initializer_label_previous_use: DiagnosticMessage =\n+///             DiagnosticMessage::fluent_attr(\n+///                 \"typeck-field-multiply-specified-in-initializer\",\n+///                 \"previous-use-label\"\n+///             );\n+///     }\n+/// }\n+/// ```\n+/// When emitting a diagnostic, the generated constants can be used as follows:\n+///\n+/// ```ignore (rust)\n+/// let mut err = sess.struct_span_err(\n+///     span,\n+///     fluent::typeck::field_multiply_specified_in_initializer\n+/// );\n+/// err.span_default_label(span);\n+/// err.span_label(\n+///     previous_use_span,\n+///     fluent::typeck::field_multiply_specified_in_initializer_label_previous_use\n+/// );\n+/// err.emit();\n+/// ```\n+#[proc_macro]\n+pub fn fluent_messages(input: TokenStream) -> TokenStream {\n+    diagnostics::fluent_messages(input)\n+}\n+\n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);\n decl_derive!(\n     [HashStable_Generic, attributes(stable_hasher)] =>"}, {"sha": "d9c9f2920b07911719bd6813d8b1cdd4c51ef5d8", "filename": "compiler/rustc_typeck/src/errors.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Ferrors.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -1,7 +1,5 @@\n //! Errors emitted by typeck.\n-use rustc_errors::{\n-    error_code, Applicability, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed,\n-};\n+use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_session::{parse::ParseSess, SessionDiagnostic};\n@@ -264,10 +262,9 @@ pub struct MissingTypeParams {\n // Manual implementation of `SessionDiagnostic` to be able to call `span_to_snippet`.\n impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n     fn into_diagnostic(self, sess: &'a ParseSess) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        static SLUG: &'static str = \"typeck-missing-type-params\";\n         let mut err = sess.span_diagnostic.struct_span_err_with_code(\n             self.span,\n-            DiagnosticMessage::fluent(SLUG),\n+            rustc_errors::fluent::typeck::missing_type_params,\n             error_code!(E0393),\n         );\n         err.set_arg(\"parameterCount\", self.missing_type_params.len());\n@@ -280,7 +277,7 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n                 .join(\", \"),\n         );\n \n-        err.span_label(self.def_span, DiagnosticMessage::fluent_attr(SLUG, \"label\"));\n+        err.span_label(self.def_span, rustc_errors::fluent::typeck::missing_type_params_label);\n \n         let mut suggested = false;\n         if let (Ok(snippet), true) = (\n@@ -298,18 +295,21 @@ impl<'a> SessionDiagnostic<'a> for MissingTypeParams {\n                 // least we can clue them to the correct syntax `Iterator<Type>`.\n                 err.span_suggestion(\n                     self.span,\n-                    DiagnosticMessage::fluent_attr(SLUG, \"suggestion\"),\n+                    rustc_errors::fluent::typeck::missing_type_params_suggestion,\n                     format!(\"{}<{}>\", snippet, self.missing_type_params.join(\", \")),\n                     Applicability::HasPlaceholders,\n                 );\n                 suggested = true;\n             }\n         }\n         if !suggested {\n-            err.span_label(self.span, DiagnosticMessage::fluent_attr(SLUG, \"no-suggestion-label\"));\n+            err.span_label(\n+                self.span,\n+                rustc_errors::fluent::typeck::missing_type_params_no_suggestion_label,\n+            );\n         }\n \n-        err.note(DiagnosticMessage::fluent_attr(SLUG, \"note\"));\n+        err.note(rustc_errors::fluent::typeck::missing_type_params_note);\n         err\n     }\n }"}, {"sha": "fd9976b5a414686fe8d1b317710292a151d4c827", "filename": "src/test/ui-fulldeps/fluent-messages/duplicate-a.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-a.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-a.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-a.ftl?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1 @@\n+key = Value"}, {"sha": "fd9976b5a414686fe8d1b317710292a151d4c827", "filename": "src/test/ui-fulldeps/fluent-messages/duplicate-b.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-b.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-b.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fduplicate-b.ftl?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1 @@\n+key = Value"}, {"sha": "372b1a2e453d210edbc8608b7e3d4f23c3881017", "filename": "src/test/ui-fulldeps/fluent-messages/missing-message.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fmissing-message.ftl?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1 @@\n+missing-message = "}, {"sha": "b05d3d08ccb0915936ac8560eeb0e0d168c41ad9", "filename": "src/test/ui-fulldeps/fluent-messages/test.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.rs?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1,60 @@\n+// normalize-stderr-test \"note.*\" -> \"note: os-specific message\"\n+\n+#![feature(rustc_private)]\n+#![crate_type = \"lib\"]\n+\n+extern crate rustc_macros;\n+use rustc_macros::fluent_messages;\n+\n+/// Copy of the relevant `DiagnosticMessage` variant constructed by `fluent_messages` as it\n+/// expects `crate::DiagnosticMessage` to exist.\n+pub enum DiagnosticMessage {\n+    FluentIdentifier(std::borrow::Cow<'static, str>, Option<std::borrow::Cow<'static, str>>),\n+}\n+\n+mod missing_absolute {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        missing_absolute => \"/definitely_does_not_exist.ftl\",\n+//~^ ERROR could not open Fluent resource\n+    }\n+}\n+\n+mod missing_relative {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        missing_relative => \"../definitely_does_not_exist.ftl\",\n+//~^ ERROR could not open Fluent resource\n+    }\n+}\n+\n+mod missing_message {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        missing_message => \"./missing-message.ftl\",\n+//~^ ERROR could not parse Fluent resource\n+    }\n+}\n+\n+mod duplicate {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        a => \"./duplicate-a.ftl\",\n+        b => \"./duplicate-b.ftl\",\n+//~^ ERROR overrides existing message: `key`\n+    }\n+}\n+\n+mod valid {\n+    use super::fluent_messages;\n+\n+    fluent_messages! {\n+        valid => \"./valid.ftl\",\n+    }\n+\n+    use self::fluent_generated::{DEFAULT_LOCALE_RESOURCES, valid::valid};\n+}"}, {"sha": "f88d09bee6e88388b135f9ae79994f20ceb0bd65", "filename": "src/test/ui-fulldeps/fluent-messages/test.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Ftest.stderr?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1,45 @@\n+error: could not open Fluent resource\n+  --> $DIR/test.rs:19:29\n+   |\n+LL |         missing_absolute => \"/definitely_does_not_exist.ftl\",\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: os-specific message\n+\n+error: could not open Fluent resource\n+  --> $DIR/test.rs:28:29\n+   |\n+LL |         missing_relative => \"../definitely_does_not_exist.ftl\",\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: os-specific message\n+\n+error: could not parse Fluent resource\n+  --> $DIR/test.rs:37:28\n+   |\n+LL |         missing_message => \"./missing-message.ftl\",\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: see additional errors emitted\n+\n+error: expected a message field for \"missing-message\"\n+ --> ./missing-message.ftl:1:1\n+  |\n+1 | missing-message = \n+  | ^^^^^^^^^^^^^^^^^^\n+  |\n+\n+error: overrides existing message: `key`\n+  --> $DIR/test.rs:47:9\n+   |\n+LL |         b => \"./duplicate-b.ftl\",\n+   |         ^\n+   |\n+help: previously defined in this resource\n+  --> $DIR/test.rs:46:9\n+   |\n+LL |         a => \"./duplicate-a.ftl\",\n+   |         ^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "0eee4a02b96ae41fad9bd7518078866727b6bc9f", "filename": "src/test/ui-fulldeps/fluent-messages/valid.ftl", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fvalid.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fvalid.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Ffluent-messages%2Fvalid.ftl?ref=7e7dd1c0698187f54b2c3b36e8e3db1b67d3b2c4", "patch": "@@ -0,0 +1 @@\n+valid = Valid!"}]}