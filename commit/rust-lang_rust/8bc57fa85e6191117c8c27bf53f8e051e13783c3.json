{"sha": "8bc57fa85e6191117c8c27bf53f8e051e13783c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYzU3ZmE4NWU2MTkxMTE3YzhjMjdiZjUzZjhlMDUxZTEzNzgzYzM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T15:58:16Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-01-21T15:59:56Z"}, "message": "Tweak effect-checking rules in rustboot, remove/rewrite/re-auth impure cases in trans.rs", "tree": {"sha": "663f8d067457d0abe92e319e0b5c63a001fa1127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/663f8d067457d0abe92e319e0b5c63a001fa1127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bc57fa85e6191117c8c27bf53f8e051e13783c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bc57fa85e6191117c8c27bf53f8e051e13783c3", "html_url": "https://github.com/rust-lang/rust/commit/8bc57fa85e6191117c8c27bf53f8e051e13783c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bc57fa85e6191117c8c27bf53f8e051e13783c3/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c27feb76a4754faee6e997339826c6f2afc1432", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c27feb76a4754faee6e997339826c6f2afc1432", "html_url": "https://github.com/rust-lang/rust/commit/2c27feb76a4754faee6e997339826c6f2afc1432"}], "stats": {"total": 404, "additions": 221, "deletions": 183}, "files": [{"sha": "fc4d03b17d3ed9fb57e3b5b36bddfef38395553e", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=8bc57fa85e6191117c8c27bf53f8e051e13783c3", "patch": "@@ -179,8 +179,7 @@ let effect_checking_visitor\n               then Ast.EFF_pure\n               else Stack.top auth_stack\n             in\n-            let next = lower_effect_of e curr in\n-              Stack.push next auth_stack;\n+              Stack.push e auth_stack;\n               iflog cx\n                 begin\n                   fun _ ->\n@@ -189,40 +188,62 @@ let effect_checking_visitor\n                         \"entering '%a', adjusting auth effect: '%a' -> '%a'\"\n                         Ast.sprintf_name name\n                         Ast.sprintf_effect curr\n-                        Ast.sprintf_effect next\n+                        Ast.sprintf_effect e\n                 end\n     end;\n+    let report_mismatch declared_effect calculated_effect =\n+      let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n+        err (Some i.id)\n+          \"%a claims effect '%a' but calculated effect is '%a'%s\"\n+          Ast.sprintf_name name\n+          Ast.sprintf_effect declared_effect\n+          Ast.sprintf_effect calculated_effect\n+          begin\n+            if Stack.is_empty auth_stack\n+            then \"\"\n+            else\n+              Printf.sprintf \" (auth effects are '%s')\"\n+                (stk_fold\n+                   auth_stack\n+                   (fun e s ->\n+                      if s = \"\"\n+                      then\n+                        Printf.sprintf \"%a\"\n+                          Ast.sprintf_effect e\n+                      else\n+                        Printf.sprintf \"%s, %a\" s\n+                          Ast.sprintf_effect e) \"\")\n+          end\n+    in\n     begin\n       match i.node.Ast.decl_item with\n           Ast.MOD_ITEM_fn f\n             when htab_search cx.ctxt_required_items i.id = None ->\n-            let e =\n+            let calculated_effect =\n               match htab_search item_effect i.id with\n                 None -> Ast.EFF_pure\n               | Some e -> e\n             in\n-            let fe = f.Ast.fn_aux.Ast.fn_effect in\n-            let ae =\n-              if Stack.is_empty auth_stack\n-              then None\n-              else Some (Stack.top auth_stack)\n-            in\n-              if e <> fe && (ae <> (Some e))\n+            let declared_effect = f.Ast.fn_aux.Ast.fn_effect in\n+              if calculated_effect <> declared_effect\n               then\n+                (* Something's fishy in this case. If the calculated effect\n+                 * is equal to one auth'ed by an enclosing scope -- not just\n+                 * a lower one -- we accept this mismatch; otherwise we\n+                 * complain.\n+                 * \n+                 * FIXME: this choice of \"what constitutes an error\" in\n+                 * auth/effect mismatches is subjective and could do\n+                 * with some discussion.  *)\n                 begin\n-                  let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n-                    err (Some i.id)\n-                      \"%a claims effect '%a' but calculated effect is '%a'%s\"\n-                      Ast.sprintf_name name\n-                      Ast.sprintf_effect fe\n-                      Ast.sprintf_effect e\n-                      begin\n-                        match ae with\n-                            Some ae when ae <> fe ->\n-                              Printf.sprintf \" (auth effect is '%a')\"\n-                                Ast.sprintf_effect ae\n-                          | _ -> \"\"\n-                      end\n+                  match\n+                    stk_search auth_stack\n+                      (fun e ->\n+                         if e = calculated_effect then Some e else None)\n+                  with\n+                      Some _ -> ()\n+                    | None ->\n+                        report_mismatch declared_effect calculated_effect\n                 end\n         | _ -> ()\n     end;\n@@ -239,16 +260,16 @@ let effect_checking_visitor\n             then Ast.EFF_pure\n             else Stack.top auth_stack\n           in\n-          iflog cx\n-            begin\n-              fun _ ->\n-                let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n-                  log cx\n-                    \"leaving '%a', restoring auth effect: '%a' -> '%a'\"\n-                    Ast.sprintf_name name\n-                    Ast.sprintf_effect curr\n-                    Ast.sprintf_effect next\n-            end\n+            iflog cx\n+              begin\n+                fun _ ->\n+                  let name = Hashtbl.find cx.ctxt_all_item_names i.id in\n+                    log cx\n+                      \"leaving '%a', restoring auth effect: '%a' -> '%a'\"\n+                      Ast.sprintf_name name\n+                      Ast.sprintf_effect curr\n+                      Ast.sprintf_effect next\n+              end\n   in\n     { inner with\n         Walk.visit_mod_item_pre = visit_mod_item_pre;"}, {"sha": "a7770b942e2fcfd6f6558148ba07b1cfbe3fc871", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 164, "deletions": 149, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=8bc57fa85e6191117c8c27bf53f8e051e13783c3", "patch": "@@ -1504,7 +1504,7 @@ fn copy_ty(@block_ctxt cx,\n     fail;\n }\n \n-impure fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n+fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n     alt (lit.node) {\n         case (ast.lit_int(?i)) {\n             ret res(cx, C_int(i));\n@@ -1547,12 +1547,12 @@ impure fn trans_lit(@block_ctxt cx, &ast.lit lit, &ast.ann ann) -> result {\n             auto sub = trans_upcall(cx, \"upcall_new_str\",\n                                     vec(p2i(C_str(cx.fcx.ccx, s)),\n                                         C_int(len)));\n-            sub.val = sub.bcx.build.IntToPtr(sub.val,\n-                                             T_ptr(T_str()));\n+            auto val = sub.bcx.build.IntToPtr(sub.val,\n+                                              T_ptr(T_str()));\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             find_scope_cx(cx).cleanups +=\n-                clean(bind drop_ty(_, sub.val, t));\n-            ret sub;\n+                clean(bind drop_ty(_, val, t));\n+            ret res(sub.bcx, val);\n         }\n     }\n }\n@@ -1587,24 +1587,21 @@ fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n     ret type_of(cx, node_ann_type(cx, a));\n }\n \n-impure fn trans_unary(@block_ctxt cx, ast.unop op,\n-                      @ast.expr e, &ast.ann a) -> result {\n+fn trans_unary(@block_ctxt cx, ast.unop op,\n+               @ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n \n     alt (op) {\n         case (ast.bitnot) {\n-            sub.val = cx.build.Not(sub.val);\n-            ret sub;\n+            ret res(sub.bcx, cx.build.Not(sub.val));\n         }\n         case (ast.not) {\n-            sub.val = cx.build.Not(sub.val);\n-            ret sub;\n+            ret res(sub.bcx, cx.build.Not(sub.val));\n         }\n         case (ast.neg) {\n             // FIXME: switch by signedness.\n-            sub.val = cx.build.Neg(sub.val);\n-            ret sub;\n+            ret res(sub.bcx, cx.build.Neg(sub.val));\n         }\n         case (ast.box) {\n             auto e_ty = ty.expr_ty(e);\n@@ -1622,15 +1619,15 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n             ret res(sub.bcx, box);\n         }\n         case (ast.deref) {\n-            sub.val = sub.bcx.build.GEP(sub.val,\n-                                        vec(C_int(0),\n-                                            C_int(abi.box_rc_field_body)));\n+            auto val = sub.bcx.build.GEP(sub.val,\n+                                         vec(C_int(0),\n+                                             C_int(abi.box_rc_field_body)));\n             auto e_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n             if (ty.type_is_scalar(e_ty) ||\n                 ty.type_is_nil(e_ty)) {\n-                sub.val = sub.bcx.build.Load(sub.val);\n+                val = sub.bcx.build.Load(val);\n             }\n-            ret sub;\n+            ret res(sub.bcx, val);\n         }\n     }\n     fail;\n@@ -1672,8 +1669,8 @@ fn trans_eager_binop(@block_ctxt cx, ast.binop op,\n     fail;\n }\n \n-impure fn trans_binary(@block_ctxt cx, ast.binop op,\n-                       @ast.expr a, @ast.expr b) -> result {\n+fn trans_binary(@block_ctxt cx, ast.binop op,\n+                @ast.expr a, @ast.expr b) -> result {\n \n     // First couple cases are lazy:\n \n@@ -1769,8 +1766,8 @@ fn join_results(@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-impure fn trans_if(@block_ctxt cx, @ast.expr cond,\n-                   &ast.block thn, &option.t[ast.block] els) -> result {\n+fn trans_if(@block_ctxt cx, @ast.expr cond,\n+            &ast.block thn, &option.t[ast.block] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -1796,8 +1793,8 @@ impure fn trans_if(@block_ctxt cx, @ast.expr cond,\n                      vec(then_res, else_res));\n }\n \n-impure fn trans_while(@block_ctxt cx, @ast.expr cond,\n-                      &ast.block body) -> result {\n+fn trans_while(@block_ctxt cx, @ast.expr cond,\n+               &ast.block body) -> result {\n \n     auto cond_cx = new_scope_block_ctxt(cx, \"while cond\");\n     auto body_cx = new_scope_block_ctxt(cx, \"while loop body\");\n@@ -1815,8 +1812,8 @@ impure fn trans_while(@block_ctxt cx, @ast.expr cond,\n     ret res(next_cx, C_nil());\n }\n \n-impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n-                         @ast.expr cond) -> result {\n+fn trans_do_while(@block_ctxt cx, &ast.block body,\n+                  @ast.expr cond) -> result {\n \n     auto body_cx = new_scope_block_ctxt(cx, \"do-while loop body\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -1850,8 +1847,8 @@ fn get_pat_union_ptr(@block_ctxt cx, vec[@ast.pat] subpats, ValueRef llval)\n     ret cx.build.TruncOrBitCast(llblobptr, T_ptr(llunionty));\n }\n \n-impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n-                          @block_ctxt next_cx) -> result {\n+fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n+                   @block_ctxt next_cx) -> result {\n     alt (pat.node) {\n         case (ast.pat_wild(_)) { ret res(cx, llval); }\n         case (ast.pat_bind(_, _, _)) { ret res(cx, llval); }\n@@ -1903,8 +1900,8 @@ impure fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n     fail;\n }\n \n-impure fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n-        -> result {\n+fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n+    -> result {\n     alt (pat.node) {\n         case (ast.pat_wild(_)) { ret res(cx, llval); }\n         case (ast.pat_bind(?id, ?def_id, ?ann)) {\n@@ -1941,8 +1938,8 @@ impure fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n     }\n }\n \n-impure fn trans_alt(@block_ctxt cx, @ast.expr expr, vec[ast.arm] arms)\n-        -> result {\n+fn trans_alt(@block_ctxt cx, @ast.expr expr, vec[ast.arm] arms)\n+    -> result {\n     auto expr_res = trans_expr(cx, expr);\n \n     auto last_cx = new_sub_block_ctxt(expr_res.bcx, \"last\");\n@@ -2068,8 +2065,8 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n     fail;\n }\n \n-impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n-                      &ast.ident field, &ast.ann ann) -> lval_result {\n+fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+               &ast.ident field, &ast.ann ann) -> lval_result {\n     auto lv = trans_lval(cx, base);\n     auto r = lv.res;\n     check (lv.is_mem);\n@@ -2102,8 +2099,8 @@ impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     fail;\n }\n \n-impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n-                      @ast.expr idx, &ast.ann ann) -> lval_result {\n+fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+               @ast.expr idx, &ast.ann ann) -> lval_result {\n \n     auto lv = trans_expr(cx, base);\n     auto ix = trans_expr(lv.bcx, idx);\n@@ -2140,7 +2137,7 @@ impure fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n \n-impure fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n+fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     alt (e.node) {\n         case (ast.expr_path(?p, ?dopt, ?ann)) {\n             ret trans_path(cx, p, dopt, ann);\n@@ -2156,7 +2153,7 @@ impure fn trans_lval(@block_ctxt cx, @ast.expr e) -> lval_result {\n     fail;\n }\n \n-impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n+fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n@@ -2189,12 +2186,12 @@ impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n \n \n // NB: this must match type_of_fn_full and create_llargs_for_fn_args.\n-impure fn trans_args(@block_ctxt cx,\n-                     ValueRef llclosure,\n-                     option.t[ValueRef] llobj,\n-                     option.t[generic_info] gen,\n-                     &vec[@ast.expr] es,\n-                     @ty.t fn_ty)\n+fn trans_args(@block_ctxt cx,\n+              ValueRef llclosure,\n+              option.t[ValueRef] llobj,\n+              option.t[generic_info] gen,\n+              &vec[@ast.expr] es,\n+              @ty.t fn_ty)\n     -> tup(@block_ctxt, vec[ValueRef], option.t[ValueRef]) {\n     let vec[ValueRef] vs = vec(cx.fcx.lltaskptr);\n     let @block_ctxt bcx = cx;\n@@ -2236,13 +2233,15 @@ impure fn trans_args(@block_ctxt cx,\n     for (@ast.expr e in es) {\n         auto mode = args.(i).mode;\n \n-        auto re;\n+        auto val;\n         if (ty.type_is_structural(ty.expr_ty(e))) {\n-            re = trans_expr(bcx, e);\n+            auto re = trans_expr(bcx, e);\n+            val = re.val;\n+            bcx = re.bcx;\n             if (mode == ast.val) {\n                 // Until here we've been treating structures by pointer;\n                 // we are now passing it as an arg, so need to load it.\n-                re.val = re.bcx.build.Load(re.val);\n+                val = bcx.build.Load(val);\n             }\n         } else if (mode == ast.alias) {\n             let lval_result lv;\n@@ -2252,42 +2251,42 @@ impure fn trans_args(@block_ctxt cx,\n                 auto r = trans_expr(bcx, e);\n                 lv = lval_val(r.bcx, r.val);\n             }\n+            bcx = lv.res.bcx;\n \n-            if (!lv.is_mem) {\n+            if (lv.is_mem) {\n+                val = lv.res.val;\n+            } else {\n                 // Non-mem but we're trying to alias; synthesize an\n                 // alloca, spill to it and pass its address.\n                 auto llty = val_ty(lv.res.val);\n                 auto llptr = lv.res.bcx.build.Alloca(llty);\n                 lv.res.bcx.build.Store(lv.res.val, llptr);\n-                re = res(lv.res.bcx, llptr);\n-            } else {\n-                re = lv.res;\n+                val = llptr;\n             }\n \n         } else {\n-            re = trans_expr(bcx, e);\n+            auto re = trans_expr(bcx, e);\n+            val = re.val;\n+            bcx = re.bcx;\n         }\n \n         if (ty.type_has_dynamic_size(args.(i).ty)) {\n-            re.val = re.bcx.build.PointerCast(re.val,\n-                                              T_typaram_ptr());\n+            val = bcx.build.PointerCast(val, T_typaram_ptr());\n         }\n \n-        vs += re.val;\n-        bcx = re.bcx;\n-\n+        vs += val;\n         i += 1u;\n     }\n \n     ret tup(bcx, vs, llretslot_opt);\n }\n \n-impure fn trans_bind_thunk(@crate_ctxt cx,\n-                           @ty.t incoming_fty,\n-                           @ty.t outgoing_fty,\n-                           vec[option.t[@ast.expr]] args,\n-                           TypeRef llclosure_ty,\n-                           vec[@ty.t] bound_tys) -> ValueRef {\n+fn trans_bind_thunk(@crate_ctxt cx,\n+                    @ty.t incoming_fty,\n+                    @ty.t outgoing_fty,\n+                    vec[option.t[@ast.expr]] args,\n+                    TypeRef llclosure_ty,\n+                    vec[@ty.t] bound_tys) -> ValueRef {\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n \n@@ -2371,9 +2370,9 @@ impure fn trans_bind_thunk(@crate_ctxt cx,\n     ret llthunk;\n }\n \n-impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n-                     vec[option.t[@ast.expr]] args,\n-                     &ast.ann ann) -> result {\n+fn trans_bind(@block_ctxt cx, @ast.expr f,\n+              vec[option.t[@ast.expr]] args,\n+              &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     if (f_res.is_mem) {\n         cx.fcx.ccx.sess.unimpl(\"re-binding existing function\");\n@@ -2483,8 +2482,8 @@ impure fn trans_bind(@block_ctxt cx, @ast.expr f,\n     }\n }\n \n-impure fn trans_call(@block_ctxt cx, @ast.expr f,\n-                     vec[@ast.expr] args, &ast.ann ann) -> result {\n+fn trans_call(@block_ctxt cx, @ast.expr f,\n+              vec[@ast.expr] args, &ast.ann ann) -> result {\n     auto f_res = trans_lval(cx, f);\n     auto faddr = f_res.res.val;\n     auto llclosure = C_null(T_opaque_closure_ptr());\n@@ -2551,8 +2550,8 @@ impure fn trans_call(@block_ctxt cx, @ast.expr f,\n     ret res(bcx, retval);\n }\n \n-impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n-                    &ast.ann ann) -> result {\n+fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n+             &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto llty = type_of(cx.fcx.ccx, t);\n     auto tup_val = cx.build.Alloca(llty);\n@@ -2569,8 +2568,8 @@ impure fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     ret res(r.bcx, tup_val);\n }\n \n-impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n-                    &ast.ann ann) -> result {\n+fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n+             &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto unit_ty = t;\n     alt (t.struct) {\n@@ -2610,8 +2609,8 @@ impure fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     ret res(sub.bcx, vec_val);\n }\n \n-impure fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n-                    &ast.ann ann) -> result {\n+fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n+             &ast.ann ann) -> result {\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto llty = type_of(cx.fcx.ccx, t);\n     auto rec_val = cx.build.Alloca(llty);\n@@ -2631,7 +2630,7 @@ impure fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n \n \n \n-impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, ?ann)) {\n             ret trans_lit(cx, *lit, ann);\n@@ -2745,7 +2744,7 @@ fn load_scalar_or_boxed(@block_ctxt cx,\n     }\n }\n \n-impure fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n \n     auto sub = trans_expr(cx, e);\n     auto e_ty = ty.expr_ty(e);\n@@ -2765,7 +2764,7 @@ impure fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n     fail;\n }\n \n-impure fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n+fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     // FIXME: need pretty-printer.\n@@ -2785,23 +2784,27 @@ impure fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n-    auto r = res(cx, C_nil());\n+fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n+    auto bcx = cx;\n+    auto val = C_nil();\n+\n     alt (e) {\n         case (some[@ast.expr](?x)) {\n             auto t = ty.expr_ty(x);\n-            r = trans_expr(cx, x);\n+            auto r = trans_expr(cx, x);\n+            bcx = r.bcx;\n+            val = r.val;\n \n             // A return is an implicit copy into a newborn anonymous\n             // 'return value' in the caller frame.\n-            r.bcx = incr_all_refcnts(r.bcx, r.val, t).bcx;\n+            bcx = incr_all_refcnts(bcx, val, t).bcx;\n \n             if (ty.type_is_structural(t)) {\n                 // We usually treat structurals by-pointer; in particular,\n                 // trans_expr will have given us a structure pointer. But in\n                 // this case we're about to return. LLVM wants a first-class\n                 // value here (which makes sense; the frame is going away!)\n-                r.val = r.bcx.build.Load(r.val);\n+                val = r.bcx.build.Load(val);\n             }\n         }\n         case (_) { /* fall through */  }\n@@ -2811,7 +2814,7 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     let bool more_cleanups = true;\n     auto cleanup_cx = cx;\n     while (more_cleanups) {\n-        r.bcx = trans_block_cleanups(r.bcx, cleanup_cx);\n+        bcx = trans_block_cleanups(bcx, cleanup_cx);\n         alt (cleanup_cx.parent) {\n             case (parent_some(?b)) {\n                 cleanup_cx = b;\n@@ -2827,80 +2830,87 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n             auto t = ty.expr_ty(ex);\n \n             if (ty.type_is_nil(t)) {\n-                r.bcx.build.RetVoid();\n-                r.val = C_nil();\n-                ret r;  // FIXME: early return needed due to typestate bug\n+                bcx.build.RetVoid();\n+                val = C_nil();\n+                ret res(bcx, val);  // FIXME: early return needed due to\n+                                    // typestate bug\n             }\n \n             alt (cx.fcx.llretptr) {\n                 case (some[ValueRef](?llptr)) {\n                     // Generic return via tydesc + retptr.\n-                    r = copy_ty(r.bcx, true, llptr, r.val, t);\n-                    r.bcx.build.RetVoid();\n+                    bcx = copy_ty(bcx, true, llptr, val, t).bcx;\n+                    bcx.build.RetVoid();\n                 }\n                 case (none[ValueRef]) {\n-                    r.val = r.bcx.build.Ret(r.val);\n+                    val = bcx.build.Ret(val);\n                 }\n             }\n-            ret r;\n+            ret res(bcx, val);\n         }\n         case (_) { /* fall through */  }\n     }\n \n     // FIXME: until LLVM has a unit type, we are moving around\n     // C_nil values rather than their void type.\n-    r.bcx.build.RetVoid();\n-    r.val = C_nil();\n-    ret r;\n+    bcx.build.RetVoid();\n+    ret res(bcx, C_nil());\n+}\n+\n+fn init_local(@block_ctxt cx, @ast.local local) -> result {\n+\n+    // Make a note to drop this slot on the way out.\n+    check (cx.fcx.lllocals.contains_key(local.id));\n+    auto llptr = cx.fcx.lllocals.get(local.id);\n+    auto ty = node_ann_type(cx.fcx.ccx, local.ann);\n+    auto bcx = cx;\n+\n+    find_scope_cx(cx).cleanups +=\n+        clean(bind drop_slot(_, llptr, ty));\n+\n+    alt (local.init) {\n+        case (some[@ast.expr](?e)) {\n+            auto sub = trans_expr(bcx, e);\n+            bcx = copy_ty(sub.bcx, true, llptr, sub.val, ty).bcx;\n+        }\n+        case (_) {\n+            if (middle.ty.type_has_dynamic_size(ty)) {\n+                auto llsz = size_of(cx, ty);\n+                bcx = call_bzero(cx, llptr, llsz).bcx;\n+\n+            } else {\n+                auto llty = type_of(bcx.fcx.ccx, ty);\n+                auto null = lib.llvm.llvm.LLVMConstNull(llty);\n+                bcx.build.Store(null, llptr);\n+            }\n+        }\n+    }\n+    ret res(bcx, llptr);\n }\n \n-impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n-    auto sub = res(cx, C_nil());\n+fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n+    auto bcx = cx;\n     alt (s.node) {\n         case (ast.stmt_log(?a)) {\n-            sub.bcx = trans_log(cx, a).bcx;\n+            bcx = trans_log(cx, a).bcx;\n         }\n \n         case (ast.stmt_check_expr(?a)) {\n-            sub.bcx = trans_check_expr(cx, a).bcx;\n+            bcx = trans_check_expr(cx, a).bcx;\n         }\n \n         case (ast.stmt_ret(?e)) {\n-            sub.bcx = trans_ret(cx, e).bcx;\n+            bcx = trans_ret(cx, e).bcx;\n         }\n \n         case (ast.stmt_expr(?e)) {\n-            sub.bcx = trans_expr(cx, e).bcx;\n+            bcx = trans_expr(cx, e).bcx;\n         }\n \n         case (ast.stmt_decl(?d)) {\n             alt (d.node) {\n                 case (ast.decl_local(?local)) {\n-\n-                    // Make a note to drop this slot on the way out.\n-                    check (cx.fcx.lllocals.contains_key(local.id));\n-                    auto llptr = cx.fcx.lllocals.get(local.id);\n-                    auto ty = node_ann_type(cx.fcx.ccx, local.ann);\n-                    find_scope_cx(cx).cleanups +=\n-                        clean(bind drop_slot(_, llptr, ty));\n-\n-                    alt (local.init) {\n-                        case (some[@ast.expr](?e)) {\n-                            sub = trans_expr(cx, e);\n-                            sub = copy_ty(sub.bcx, true, llptr, sub.val, ty);\n-                        }\n-                        case (_) {\n-                            if (middle.ty.type_has_dynamic_size(ty)) {\n-                                auto llsz = size_of(cx, ty);\n-                                sub = call_bzero(cx, llptr, llsz);\n-\n-                            } else {\n-                                auto llty = type_of(cx.fcx.ccx, ty);\n-                                auto null = lib.llvm.llvm.LLVMConstNull(llty);\n-                                sub = res(cx, cx.build.Store(null, llptr));\n-                            }\n-                        }\n-                    }\n+                    bcx = init_local(bcx, local).bcx;\n                 }\n                 case (ast.decl_item(?i)) {\n                     trans_item(cx.fcx.ccx, *i);\n@@ -2911,7 +2921,7 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n             cx.fcx.ccx.sess.unimpl(\"stmt variant\");\n         }\n     }\n-    ret sub;\n+    ret res(bcx, C_nil());\n }\n \n fn new_builder(BasicBlockRef llbb) -> builder {\n@@ -2990,19 +3000,24 @@ iter block_locals(&ast.block b) -> @ast.local {\n     }\n }\n \n-impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n+fn alloc_local(@block_ctxt cx, @ast.local local) -> result {\n+    auto t = node_ann_type(cx.fcx.ccx, local.ann);\n+    auto val = C_int(0);\n+    if (ty.type_has_dynamic_size(t)) {\n+        auto n = size_of(cx, t);\n+        val = cx.build.ArrayAlloca(T_i8(), n);\n+    } else {\n+        val = cx.build.Alloca(type_of(cx.fcx.ccx, t));\n+    }\n+    cx.fcx.lllocals.insert(local.id, val);\n+    ret res(cx, val);\n+}\n+\n+fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n-        auto t = node_ann_type(cx.fcx.ccx, local.ann);\n-        auto val = C_int(0);\n-        if (ty.type_has_dynamic_size(t)) {\n-            auto n = size_of(bcx, t);\n-            val = bcx.build.ArrayAlloca(T_i8(), n);\n-        } else {\n-            val = bcx.build.Alloca(type_of(cx.fcx.ccx, t));\n-        }\n-        cx.fcx.lllocals.insert(local.id, val);\n+        bcx = alloc_local(bcx, local).bcx;\n     }\n     auto r = res(bcx, C_nil());\n \n@@ -3102,10 +3117,10 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // allocas immediately upon entry; this permits us to GEP into structures we\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n-impure fn copy_args_to_allocas(@block_ctxt cx,\n-                               option.t[TypeRef] ty_self,\n-                               vec[ast.arg] args,\n-                               vec[ty.arg] arg_tys) {\n+fn copy_args_to_allocas(@block_ctxt cx,\n+                        option.t[TypeRef] ty_self,\n+                        vec[ast.arg] args,\n+                        vec[ty.arg] arg_tys) {\n \n     let uint arg_n = 0u;\n \n@@ -3203,9 +3218,9 @@ fn create_llobjfields_for_fields(@block_ctxt cx, ValueRef llself) {\n     }\n }\n \n-impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n-                   option.t[TypeRef] ty_self,\n-                   &vec[ast.ty_param] ty_params, &ast.ann ann) {\n+fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n+            option.t[TypeRef] ty_self,\n+            &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llfndecl = cx.item_ids.get(fid);\n     cx.item_names.insert(cx.path, llfndecl);\n@@ -3234,9 +3249,9 @@ impure fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n     }\n }\n \n-impure fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n-                     &ast._obj ob,\n-                     &vec[ast.ty_param] ty_params) -> ValueRef {\n+fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n+              &ast._obj ob,\n+              &vec[ast.ty_param] ty_params) -> ValueRef {\n     let vec[ValueRef] methods = vec();\n \n     fn meth_lteq(&@ast.method a, &@ast.method b) -> bool {\n@@ -3279,8 +3294,8 @@ impure fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n     ret gvar;\n }\n \n-impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n-                    &vec[ast.ty_param] ty_params, &ast.ann ann) {\n+fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n+             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llctor_decl = cx.item_ids.get(oid);\n     cx.item_names.insert(cx.path, llctor_decl);\n@@ -3442,7 +3457,7 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n     bcx.build.Ret(lltagval);\n }\n \n-impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n+fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n@@ -3469,7 +3484,7 @@ impure fn trans_item(@crate_ctxt cx, &ast.item item) {\n     }\n }\n \n-impure fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n+fn trans_mod(@crate_ctxt cx, &ast._mod m) {\n     for (@ast.item item in m.items) {\n         trans_item(cx, *item);\n     }"}, {"sha": "b439632cfbcd8b50c23e2041bfd2950de497a9f4", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8bc57fa85e6191117c8c27bf53f8e051e13783c3/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=8bc57fa85e6191117c8c27bf53f8e051e13783c3", "patch": "@@ -34,6 +34,8 @@ mod util {\n \n auth driver.rustc.main = impure;\n auth middle.trans = unsafe;\n+auth middle.trans.copy_args_to_allocas = impure;\n+auth middle.trans.trans_block = impure;\n auth lib.llvm = unsafe;\n \n "}]}