{"sha": "e42c448077ca2b7675320da3c5294bf4bebaedeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MmM0NDgwNzdjYTJiNzY3NTMyMGRhM2M1Mjk0YmY0YmViYWVkZWI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T20:18:52Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T20:19:52Z"}, "message": "More completion pattern tests", "tree": {"sha": "e6d76df5212db7589ef8dc6583b32d6c64871a33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6d76df5212db7589ef8dc6583b32d6c64871a33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e42c448077ca2b7675320da3c5294bf4bebaedeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e42c448077ca2b7675320da3c5294bf4bebaedeb", "html_url": "https://github.com/rust-lang/rust/commit/e42c448077ca2b7675320da3c5294bf4bebaedeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e42c448077ca2b7675320da3c5294bf4bebaedeb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ad752e6cca5eb5499168ec7f859879e384a5ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ad752e6cca5eb5499168ec7f859879e384a5ab", "html_url": "https://github.com/rust-lang/rust/commit/47ad752e6cca5eb5499168ec7f859879e384a5ab"}], "stats": {"total": 195, "additions": 109, "deletions": 86}, "files": [{"sha": "e71a04b6eca38440b37f8e3b5909fec0509591b4", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e42c448077ca2b7675320da3c5294bf4bebaedeb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42c448077ca2b7675320da3c5294bf4bebaedeb/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=e42c448077ca2b7675320da3c5294bf4bebaedeb", "patch": "@@ -39,8 +39,6 @@ pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n     }\n }\n \n-trait Foo {}\n-\n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.token.kind() == SyntaxKind::COMMENT {\n         cov_mark::hit!(no_keyword_completion_in_comments);"}, {"sha": "caf0ef39fc2b154d5f5a4a04359c0ba5378e2f1e", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 109, "deletions": 84, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/e42c448077ca2b7675320da3c5294bf4bebaedeb/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e42c448077ca2b7675320da3c5294bf4bebaedeb/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=e42c448077ca2b7675320da3c5294bf4bebaedeb", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<Immedi\n     let res = match_ast! {\n         match prev_sibling {\n             ast::ExprStmt(it) => {\n-                let node = it.expr()?.syntax().clone();\n+                let node = it.expr().filter(|_| it.semicolon_token().is_none())?.syntax().clone();\n                 match_ast! {\n                     match node {\n                         ast::IfExpr(_it) => ImmediatePrevSibling::IfExpr,\n@@ -149,59 +149,6 @@ fn maximize_name_ref(name_like: &ast::NameLike) -> Option<SyntaxNode> {\n     Some(node)\n }\n \n-#[cfg(test)]\n-fn check_location(code: &str, loc: ImmediateLocation) {\n-    check_pattern_is_applicable(code, |e| {\n-        let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n-        assert_eq!(determine_location(name), Some(loc));\n-        true\n-    });\n-}\n-\n-#[test]\n-fn test_has_trait_parent() {\n-    check_location(r\"trait A { f$0 }\", ImmediateLocation::Trait);\n-}\n-\n-#[test]\n-fn test_has_use_parent() {\n-    check_location(r\"use f$0\", ImmediateLocation::Use);\n-}\n-\n-#[test]\n-fn test_has_impl_parent() {\n-    check_location(r\"impl A { f$0 }\", ImmediateLocation::Impl);\n-}\n-#[test]\n-fn test_has_field_list_parent() {\n-    check_location(r\"struct Foo { f$0 }\", ImmediateLocation::RecordField);\n-    check_location(r\"struct Foo { f$0 pub f: i32}\", ImmediateLocation::RecordField);\n-}\n-\n-#[test]\n-fn test_has_block_expr_parent() {\n-    check_location(r\"fn my_fn() { let a = 2; f$0 }\", ImmediateLocation::BlockExpr);\n-}\n-\n-#[test]\n-fn test_has_ident_pat_parent() {\n-    check_location(r\"fn my_fn(m$0) {}\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn() { let m$0 }\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn(&m$0) {}\", ImmediateLocation::IdentPat);\n-    check_location(r\"fn my_fn() { let &m$0 }\", ImmediateLocation::IdentPat);\n-}\n-\n-#[test]\n-fn test_has_ref_expr_parent() {\n-    check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n-}\n-\n-#[test]\n-fn test_has_item_list_or_source_file_parent() {\n-    check_location(r\"i$0\", ImmediateLocation::ItemList);\n-    check_location(r\"mod foo { f$0 }\", ImmediateLocation::ItemList);\n-}\n-\n pub(crate) fn inside_impl_trait_block(element: SyntaxElement) -> bool {\n     // Here we search `impl` keyword up through the all ancestors, unlike in `has_impl_parent`,\n     // where we only check the first parent with different text range.\n@@ -251,36 +198,6 @@ fn test_for_is_prev2() {\n     check_pattern_is_applicable(r\"for i i$0\", for_is_prev2);\n }\n \n-#[cfg(test)]\n-fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {\n-    check_pattern_is_applicable(code, |e| {\n-        let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n-        assert_eq!(determine_prev_sibling(name), sibling.into());\n-        true\n-    });\n-}\n-\n-#[test]\n-fn test_has_impl_as_prev_sibling() {\n-    check_prev_sibling(r\"impl A w$0 \", ImmediatePrevSibling::ImplDefType);\n-    check_prev_sibling(r\"impl A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n-    check_prev_sibling(r\"impl A for A w$0 \", ImmediatePrevSibling::ImplDefType);\n-    check_prev_sibling(r\"impl A for A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n-    check_prev_sibling(r\"impl A for w$0 {}\", None);\n-    check_prev_sibling(r\"impl A for w$0\", None);\n-}\n-\n-#[test]\n-fn test_has_trait_as_prev_sibling() {\n-    check_prev_sibling(r\"trait A w$0 \", ImmediatePrevSibling::TraitDefName);\n-    check_prev_sibling(r\"trait A w$0 {}\", ImmediatePrevSibling::TraitDefName);\n-}\n-\n-#[test]\n-fn test_has_if_expr_as_prev_sibling() {\n-    check_prev_sibling(r\"fn foo() { if true {} w$0\", ImmediatePrevSibling::IfExpr);\n-}\n-\n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n     element\n         .ancestors()\n@@ -329,3 +246,111 @@ fn previous_sibling_or_ancestor_sibling(element: SyntaxElement) -> Option<Syntax\n         non_trivia_sibling(NodeOrToken::Node(prev_sibling_node), Direction::Prev)\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    fn check_location(code: &str, loc: impl Into<Option<ImmediateLocation>>) {\n+        check_pattern_is_applicable(code, |e| {\n+            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+            assert_eq!(determine_location(name), loc.into());\n+            true\n+        });\n+    }\n+\n+    fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {\n+        check_pattern_is_applicable(code, |e| {\n+            let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+            assert_eq!(determine_prev_sibling(name), sibling.into());\n+            true\n+        });\n+    }\n+\n+    #[test]\n+    fn test_trait_loc() {\n+        check_location(r\"trait A { f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { #[attr] f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { f$0 fn f() {} }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A { fn f() {} f$0 }\", ImmediateLocation::Trait);\n+        check_location(r\"trait A$0 {}\", None);\n+        check_location(r\"trait A { fn f$0 }\", None);\n+    }\n+\n+    #[test]\n+    fn test_impl_loc() {\n+        check_location(r\"impl A { f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { #[attr] f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { f$0 fn f() {} }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A { fn f() {} f$0 }\", ImmediateLocation::Impl);\n+        check_location(r\"impl A$0 {}\", None);\n+        check_location(r\"impl A { fn f$0 }\", None);\n+    }\n+\n+    #[test]\n+    fn test_use_loc() {\n+        check_location(r\"use f$0\", ImmediateLocation::Use);\n+        check_location(r\"use f$0;\", ImmediateLocation::Use);\n+        check_location(r\"use f::{f$0}\", None);\n+        check_location(r\"use {f$0}\", None);\n+    }\n+\n+    #[test]\n+    fn test_record_field_loc() {\n+        check_location(r\"struct Foo { f$0 }\", ImmediateLocation::RecordField);\n+        check_location(r\"struct Foo { f$0 pub f: i32}\", ImmediateLocation::RecordField);\n+        check_location(r\"struct Foo { pub f: i32, f$0 }\", ImmediateLocation::RecordField);\n+    }\n+\n+    #[test]\n+    fn test_block_expr_loc() {\n+        check_location(r\"fn my_fn() { let a = 2; f$0 }\", ImmediateLocation::BlockExpr);\n+        check_location(r\"fn my_fn() { f$0 f }\", ImmediateLocation::BlockExpr);\n+    }\n+\n+    #[test]\n+    fn test_ident_pat_loc() {\n+        check_location(r\"fn my_fn(m$0) {}\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn() { let m$0 }\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn(&m$0) {}\", ImmediateLocation::IdentPat);\n+        check_location(r\"fn my_fn() { let &m$0 }\", ImmediateLocation::IdentPat);\n+    }\n+\n+    #[test]\n+    fn test_ref_expr_loc() {\n+        check_location(r\"fn my_fn() { let x = &m$0 foo; }\", ImmediateLocation::RefExpr);\n+    }\n+\n+    #[test]\n+    fn test_item_list_loc() {\n+        check_location(r\"i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"#[attr] i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"fn f() {} i$0\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { #[attr] f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo { fn f() {} f$0 }\", ImmediateLocation::ItemList);\n+        check_location(r\"mod foo$0 {}\", None);\n+    }\n+\n+    #[test]\n+    fn test_impl_prev_sibling() {\n+        check_prev_sibling(r\"impl A w$0 \", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for A w$0 \", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+        check_prev_sibling(r\"impl A for w$0 {}\", None);\n+        check_prev_sibling(r\"impl A for w$0\", None);\n+    }\n+\n+    #[test]\n+    fn test_trait_prev_sibling() {\n+        check_prev_sibling(r\"trait A w$0 \", ImmediatePrevSibling::TraitDefName);\n+        check_prev_sibling(r\"trait A w$0 {}\", ImmediatePrevSibling::TraitDefName);\n+    }\n+\n+    #[test]\n+    fn test_if_expr_prev_sibling() {\n+        check_prev_sibling(r\"fn foo() { if true {} w$0\", ImmediatePrevSibling::IfExpr);\n+        check_prev_sibling(r\"fn foo() { if true {}; w$0\", None);\n+    }\n+}"}]}