{"sha": "6386f887a7e7ac1581075ba296edf1a66f375f08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzODZmODg3YTdlN2FjMTU4MTA3NWJhMjk2ZWRmMWE2NmYzNzVmMDg=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-12T03:14:27Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-17T04:22:27Z"}, "message": "Crypto: update checked addition functions to use CheckedAdd intrinsic.\n\nThe shift_add_check_overflow and shift_add_check_overflow_tuple functions are\nre-written to be more efficient and to make use of the CheckedAdd instrinsic\ninstead of manually checking for integer overflow.\n\n* The invokation leading_zeros() is removed and replaced with simple integer\n  comparison. The leading_zeros() method results in a ctpop LLVM instruction\n  and it may not be efficient on all architectures; integer comparisons,\n  however, are efficient on just about any architecture.\n* The methods lose the ability for the caller to specify a particular shift\n  value - that functionality wasn't being used and removing it allows for the\n  code to be simplified.\n* Finally, the methods are renamed to add_bytes_to_bits and\n  add_bytes_to_bits_tuple to reflect their very specific purposes.", "tree": {"sha": "9d0b7d7b5b09d5b570cee7eb151b0aae81f1f6ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d0b7d7b5b09d5b570cee7eb151b0aae81f1f6ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6386f887a7e7ac1581075ba296edf1a66f375f08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6386f887a7e7ac1581075ba296edf1a66f375f08", "html_url": "https://github.com/rust-lang/rust/commit/6386f887a7e7ac1581075ba296edf1a66f375f08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6386f887a7e7ac1581075ba296edf1a66f375f08/comments", "author": null, "committer": null, "parents": [{"sha": "c7070653252be9a103f7068ae6a38619de76d913", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7070653252be9a103f7068ae6a38619de76d913", "html_url": "https://github.com/rust-lang/rust/commit/c7070653252be9a103f7068ae6a38619de76d913"}], "stats": {"total": 107, "additions": 65, "deletions": 42}, "files": [{"sha": "9fd02baf541f36f2547eeb9f07fb455193392d8f", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=6386f887a7e7ac1581075ba296edf1a66f375f08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::num::One;\n+use std::num::{One, Zero, CheckedAdd};\n use std::vec::bytes::{MutableByteVector, copy_memory};\n \n \n@@ -97,50 +97,73 @@ pub fn read_u32v_le(dst: &mut[u32], input: &[u8]) {\n }\n \n \n-/// Returns true if adding the two parameters will result in integer overflow\n-pub fn will_add_overflow<T: Int + Unsigned>(x: T, y: T) -> bool {\n-    // This doesn't handle negative values! Don't copy this code elsewhere without considering if\n-    // negative values are important to you!\n-    let max: T = Bounded::max_value();\n-    return x > max - y;\n+trait ToBits {\n+    /// Convert the value in bytes to the number of bits, a tuple where the 1st item is the\n+    /// high-order value and the 2nd item is the low order value.\n+    fn to_bits(self) -> (Self, Self);\n }\n \n-/// Shifts the second parameter and then adds it to the first. fails!() if there would be unsigned\n-/// integer overflow.\n-pub fn shift_add_check_overflow<T: Int + Unsigned + Clone>(x: T, mut y: T, shift: T) -> T {\n-    if y.leading_zeros() < shift {\n-        fail!(\"Could not add values - integer overflow.\");\n+impl ToBits for u64 {\n+    fn to_bits(self) -> (u64, u64) {\n+        return (self >> 61, self << 3);\n     }\n-    y = y << shift;\n+}\n \n-    if will_add_overflow(x.clone(), y.clone()) {\n-        fail!(\"Could not add values - integer overflow.\");\n-    }\n+/// Adds the specified number of bytes to the bit count. fail!() if this would cause numeric\n+/// overflow.\n+pub fn add_bytes_to_bits<T: Int + CheckedAdd + ToBits>(bits: T, bytes: T) -> T {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n \n-    return x + y;\n-}\n+    if new_high_bits > Zero::zero() {\n+        fail!(\"Numeric overflow occured.\")\n+    }\n \n-/// Shifts the second parameter and then adds it to the first, which is a tuple where the first\n-/// element is the high order value. fails!() if there would be unsigned integer overflow.\n-pub fn shift_add_check_overflow_tuple\n-        <T: Int + Unsigned + Clone>\n-        (x: (T, T), mut y: T, shift: T) -> (T, T) {\n-    if y.leading_zeros() < shift {\n-        fail!(\"Could not add values - integer overflow.\");\n+    match bits.checked_add(&new_low_bits) {\n+        Some(x) => return x,\n+        None => fail!(\"Numeric overflow occured.\")\n     }\n-    y = y << shift;\n+}\n \n-    match x {\n-        (hi, low) => {\n-            let one: T = One::one();\n-            if will_add_overflow(low.clone(), y.clone()) {\n-                if will_add_overflow(hi.clone(), one.clone()) {\n-                    fail!(\"Could not add values - integer overflow.\");\n-                } else {\n-                    return (hi + one, low + y);\n-                }\n+/// Adds the specified number of bytes to the bit count, which is a tuple where the first element is\n+/// the high order value. fail!() if this would cause numeric overflow.\n+pub fn add_bytes_to_bits_tuple\n+        <T: Int + Unsigned + CheckedAdd + ToBits>\n+        (bits: (T, T), bytes: T) -> (T, T) {\n+    let (new_high_bits, new_low_bits) = bytes.to_bits();\n+    let (hi, low) = bits;\n+\n+    // Add the low order value - if there is no overflow, then add the high order values\n+    // If the addition of the low order values causes overflow, add one to the high order values\n+    // before adding them.\n+    match low.checked_add(&new_low_bits) {\n+        Some(x) => {\n+            if new_high_bits == Zero::zero() {\n+                // This is the fast path - every other alternative will rarely occur in practice\n+                // considering how large an input would need to be for those paths to be used.\n+                return (hi, x);\n             } else {\n-                return (hi, low + y);\n+                match hi.checked_add(&new_high_bits) {\n+                    Some(y) => return (y, x),\n+                    None => fail!(\"Numeric overflow occured.\")\n+                }\n+            }\n+        },\n+        None => {\n+            let one: T = One::one();\n+            let z = match new_high_bits.checked_add(&one) {\n+                Some(w) => w,\n+                None => fail!(\"Numeric overflow occured.\")\n+            };\n+            match hi.checked_add(&z) {\n+                // This re-executes the addition that was already performed earlier when overflow\n+                // occured, this time allowing the overflow to happen. Technically, this could be\n+                // avoided by using the checked add intrinsic directly, but that involves using\n+                // unsafe code and is not really worthwhile considering how infrequently code will\n+                // run in practice. This is the reason that this function requires that the type T\n+                // be Unsigned - overflow is not defined for Signed types. This function could be\n+                // implemented for signed types as well if that were needed.\n+                Some(y) => return (y, low + new_low_bits),\n+                None => fail!(\"Numeric overflow occured.\")\n             }\n         }\n     }"}, {"sha": "4d4d47feee817c0bb07f4136215d88c327ad027f", "filename": "src/libextra/crypto/sha1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=6386f887a7e7ac1581075ba296edf1a66f375f08", "patch": "@@ -23,7 +23,7 @@\n  */\n \n \n-use cryptoutil::{write_u32_be, read_u32v_be, shift_add_check_overflow, FixedBuffer, FixedBuffer64,\n+use cryptoutil::{write_u32_be, read_u32v_be, add_bytes_to_bits, FixedBuffer, FixedBuffer64,\n     StandardPadding};\n use digest::Digest;\n \n@@ -52,7 +52,7 @@ pub struct Sha1 {\n fn add_input(st: &mut Sha1, msg: &[u8]) {\n     assert!((!st.computed));\n     // Assumes that msg.len() can be converted to u64 without overflow\n-    st.length_bits = shift_add_check_overflow(st.length_bits, msg.len() as u64, 3);\n+    st.length_bits = add_bytes_to_bits(st.length_bits, msg.len() as u64);\n     st.buffer.input(msg, |d: &[u8]| { process_msg_block(d, &mut st.h); });\n }\n "}, {"sha": "96f3e13eb2202530edf5125c5b4ce336a3aae44d", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386f887a7e7ac1581075ba296edf1a66f375f08/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=6386f887a7e7ac1581075ba296edf1a66f375f08", "patch": "@@ -10,8 +10,8 @@\n \n use std::uint;\n \n-use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, shift_add_check_overflow,\n-    shift_add_check_overflow_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n+use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, add_bytes_to_bits,\n+    add_bytes_to_bits_tuple, FixedBuffer, FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n \n@@ -210,7 +210,7 @@ impl Engine512 {\n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n         // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = shift_add_check_overflow_tuple(self.length_bits, input.len() as u64, 3);\n+        self.length_bits = add_bytes_to_bits_tuple(self.length_bits, input.len() as u64);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n \n@@ -602,7 +602,7 @@ impl Engine256 {\n     fn input(&mut self, input: &[u8]) {\n         assert!(!self.finished)\n         // Assumes that input.len() can be converted to u64 without overflow\n-        self.length_bits = shift_add_check_overflow(self.length_bits, input.len() as u64, 3);\n+        self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n         self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n     }\n "}]}