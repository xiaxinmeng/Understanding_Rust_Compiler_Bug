{"sha": "2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkODQ3ZGM5MGZkOWRjZmViNTQ5YmFkOTFhMzA2MDk2ZGJlMDhmMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-05T11:05:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-05T11:05:23Z"}, "message": "Auto merge of #50370 - nikomatsakis:nll-alias-analysis-flat, r=pnkfelix\n\nintroduce `-Znll-facts` to dump base-facts for the NLL analysis\n\nr? @pnkfelix", "tree": {"sha": "87d2f0a1fd9bd5168b7dbaf4acdca0ccb0a6f9bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87d2f0a1fd9bd5168b7dbaf4acdca0ccb0a6f9bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "html_url": "https://github.com/rust-lang/rust/commit/2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e471c206cf472b54acee83a231560e16c439ab63", "url": "https://api.github.com/repos/rust-lang/rust/commits/e471c206cf472b54acee83a231560e16c439ab63", "html_url": "https://github.com/rust-lang/rust/commit/e471c206cf472b54acee83a231560e16c439ab63"}, {"sha": "b36cbcb0c4ab342fdc575e323535965ce6711d37", "url": "https://api.github.com/repos/rust-lang/rust/commits/b36cbcb0c4ab342fdc575e323535965ce6711d37", "html_url": "https://github.com/rust-lang/rust/commit/b36cbcb0c4ab342fdc575e323535965ce6711d37"}], "stats": {"total": 795, "additions": 689, "deletions": 106}, "files": [{"sha": "37f6d47ff849d563d5ca3fae76dd616fa123bc50", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -1978,6 +1978,11 @@ impl fmt::Debug for Location {\n }\n \n impl Location {\n+    pub const START: Location = Location {\n+        block: START_BLOCK,\n+        statement_index: 0,\n+    };\n+\n     /// Returns the location immediately after this one within the enclosing block.\n     ///\n     /// Note that if this location represents a terminator, then the"}, {"sha": "0beda679e69592794be9d46f30235eaaf668f551", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -1250,6 +1250,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll_subminimal_causes: bool = (false, parse_bool, [UNTRACKED],\n         \"when tracking region error causes, accept subminimal results for faster execution.\"),\n+    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n+                       \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n     trans_time_graph: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "28da1b2d733577c114a1c61d2c745a74a1a6aa79", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+\n+/// Maps between a MIR Location, which identifies the a particular\n+/// statement within a basic block, to a \"rich location\", which\n+/// identifies at a finer granularity. In particular, we distinguish\n+/// the *start* of a statement and the *mid-point*. The mid-point is\n+/// the point *just* before the statement takes effect; in particular,\n+/// for an assignment `A = B`, it is the point where B is about to be\n+/// written into A. This mid-point is a kind of hack to work around\n+/// our inability to track the position information at sufficient\n+/// granularity through outlives relations; however, the rich location\n+/// table serves another purpose: it compresses locations from\n+/// multiple words into a single u32.\n+crate struct LocationTable {\n+    num_points: usize,\n+    statements_before_block: IndexVec<BasicBlock, usize>,\n+}\n+\n+newtype_index!(LocationIndex { DEBUG_FORMAT = \"LocationIndex({})\" });\n+\n+#[derive(Copy, Clone, Debug)]\n+crate enum RichLocation {\n+    Start(Location),\n+    Mid(Location),\n+}\n+\n+impl LocationTable {\n+    crate fn new(mir: &Mir<'_>) -> Self {\n+        let mut num_points = 0;\n+        let statements_before_block = mir.basic_blocks()\n+            .iter()\n+            .map(|block_data| {\n+                let v = num_points;\n+                num_points += (block_data.statements.len() + 1) * 2;\n+                v\n+            })\n+            .collect();\n+\n+        debug!(\n+            \"LocationTable(statements_before_block={:#?})\",\n+            statements_before_block\n+        );\n+        debug!(\"LocationTable: num_points={:#?}\", num_points);\n+\n+        Self {\n+            num_points,\n+            statements_before_block,\n+        }\n+    }\n+\n+    crate fn all_points(&self) -> impl Iterator<Item = LocationIndex> {\n+        (0..self.num_points).map(LocationIndex::new)\n+    }\n+\n+    crate fn start_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2)\n+    }\n+\n+    crate fn mid_index(&self, location: Location) -> LocationIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        LocationIndex::new(start_index + statement_index * 2 + 1)\n+    }\n+\n+    crate fn to_location(&self, index: LocationIndex) -> RichLocation {\n+        let point_index = index.index();\n+\n+        // Find the basic block. We have a vector with the\n+        // starting index of the statement in each block. Imagine\n+        // we have statement #22, and we have a vector like:\n+        //\n+        // [0, 10, 20]\n+        //\n+        // In that case, this represents point_index 2 of\n+        // basic block BB2. We know this because BB0 accounts for\n+        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+        // 20...\n+        //\n+        // To compute this, we could do a binary search, but\n+        // because I am lazy we instead iterate through to find\n+        // the last point where the \"first index\" (0, 10, or 20)\n+        // was less than the statement index (22). In our case, this will\n+        // be (BB2, 20).\n+        let (block, &first_index) = self.statements_before_block\n+            .iter_enumerated()\n+            .filter(|(_, first_index)| **first_index <= point_index)\n+            .last()\n+            .unwrap();\n+\n+        let statement_index = (point_index - first_index) / 2;\n+        if index.is_start() {\n+            RichLocation::Start(Location { block, statement_index })\n+        } else {\n+            RichLocation::Mid(Location { block, statement_index })\n+        }\n+    }\n+}\n+\n+impl LocationIndex {\n+    fn is_start(&self) -> bool {\n+        // even indices are start points; odd indices are mid points\n+        (self.index() % 2) == 0\n+    }\n+}"}, {"sha": "3e3f510e308c330b82fbd16e524aa2e033c2ce2a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -50,12 +50,14 @@ use std::iter;\n \n use self::borrow_set::{BorrowSet, BorrowData};\n use self::flows::Flows;\n+use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n \n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n+mod location;\n crate mod place_ext;\n mod prefixes;\n \n@@ -110,6 +112,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     let mut mir: Mir<'tcx> = input_mir.clone();\n     let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n     let mir = &mir; // no further changes\n+    let location_table = &LocationTable::new(mir);\n \n     let move_data: MoveData<'tcx> = match MoveData::gather_moves(mir, tcx) {\n         Ok(move_data) => move_data,\n@@ -199,6 +202,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         def_id,\n         free_regions,\n         mir,\n+        location_table,\n         param_env,\n         &mut flow_inits,\n         &mdpe.move_data,"}, {"sha": "d34e9434fbf2a0352a5cc4ec36b796f5cf1436f0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 151, "deletions": 36, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -8,28 +8,37 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::hir;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n+use rustc::infer::InferCtxt;\n+use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n-use rustc::mir::visit::TyContext;\n-use rustc::infer::InferCtxt;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n-use rustc::ty::subst::Substs;\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts};\n \n+use super::region_infer::{Cause, RegionInferenceContext};\n use super::ToRegionVid;\n-use super::region_infer::{RegionInferenceContext, Cause};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n+        borrow_set,\n         infcx,\n         regioncx,\n+        location_table,\n+        all_facts,\n         mir,\n     };\n \n@@ -41,8 +50,11 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n /// 'cg = the duration of the constraint generation process itself.\n struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    all_facts: &'cg mut Option<AllFacts>,\n+    location_table: &'cg LocationTable,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n+    borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n@@ -68,12 +80,14 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n     /// call. Make them live at the location where they appear.\n     fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n         match ty_context {\n-            TyContext::ReturnTy(source_info) |\n-            TyContext::YieldTy(source_info) |\n-            TyContext::LocalDecl { source_info, .. } => {\n-                span_bug!(source_info.span,\n-                          \"should not be visiting outside of the CFG: {:?}\",\n-                          ty_context);\n+            TyContext::ReturnTy(source_info)\n+            | TyContext::YieldTy(source_info)\n+            | TyContext::LocalDecl { source_info, .. } => {\n+                span_bug!(\n+                    source_info.span,\n+                    \"should not be visiting outside of the CFG: {:?}\",\n+                    ty_context\n+                );\n             }\n             TyContext::Location(location) => {\n                 self.add_regular_live_constraint(*ty, location, Cause::LiveOther(location));\n@@ -90,25 +104,117 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_closure_substs(substs);\n     }\n \n+    fn visit_statement(\n+        &mut self,\n+        block: BasicBlock,\n+        statement: &Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            all_facts.cfg_edge.push((\n+                self.location_table.mid_index(location),\n+                self.location_table\n+                    .start_index(location.successor_within_block()),\n+            ));\n+        }\n+\n+        self.super_statement(block, statement, location);\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        block: BasicBlock,\n+        place: &Place<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        // When we see `X = ...`, then kill borrows of\n+        // `(*X).foo` and so forth.\n+        if let Some(all_facts) = self.all_facts {\n+            if let Place::Local(temp) = place {\n+                if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n+                    for &borrow_index in borrow_indices {\n+                        let location_index = self.location_table.mid_index(location);\n+                        all_facts.killed.push((borrow_index, location_index));\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_assign(block, place, rvalue, location);\n+    }\n+\n+    fn visit_terminator(\n+        &mut self,\n+        block: BasicBlock,\n+        terminator: &Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        if let Some(all_facts) = self.all_facts {\n+            all_facts.cfg_edge.push((\n+                self.location_table.start_index(location),\n+                self.location_table.mid_index(location),\n+            ));\n+\n+            for successor_block in terminator.successors() {\n+                all_facts.cfg_edge.push((\n+                    self.location_table.mid_index(location),\n+                    self.location_table\n+                        .start_index(successor_block.start_location()),\n+                ));\n+            }\n+        }\n+\n+        self.super_terminator(block, terminator, location);\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n \n-        // Look for an rvalue like:\n-        //\n-        //     & L\n-        //\n-        // where L is the path that is borrowed. In that case, we have\n-        // to add the reborrow constraints (which don't fall out\n-        // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        match rvalue {\n+            Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n+                // In some cases, e.g. when borrowing from an unsafe\n+                // place, we don't bother to create a loan, since\n+                // there are no conditions to validate.\n+                if let Some(all_facts) = self.all_facts {\n+                    if let Some(borrow_index) = self.borrow_set.location_map.get(&location) {\n+                        let region_vid = region.to_region_vid();\n+                        all_facts.borrow_region.push((\n+                            region_vid,\n+                            *borrow_index,\n+                            self.location_table.mid_index(location),\n+                        ));\n+                    }\n+                }\n+\n+                // Look for an rvalue like:\n+                //\n+                //     & L\n+                //\n+                // where L is the path that is borrowed. In that case, we have\n+                // to add the reborrow constraints (which don't fall out\n+                // naturally from the type-checker).\n+                self.add_reborrow_constraint(location, region, borrowed_place);\n+            }\n+\n+            _ => { }\n         }\n \n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_user_assert_ty(&mut self, _c_ty: &CanonicalTy<'tcx>,\n-                            _local: &Local, _location: Location) { }\n+    fn visit_user_assert_ty(\n+        &mut self,\n+        _c_ty: &CanonicalTy<'tcx>,\n+        _local: &Local,\n+        _location: Location,\n+    ) {\n+    }\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n@@ -122,8 +228,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     {\n         debug!(\n             \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n-            live_ty,\n-            location\n+            live_ty, location\n         );\n \n         self.infcx\n@@ -144,8 +249,10 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n     ) {\n         let mut borrowed_place = borrowed_place;\n \n-        debug!(\"add_reborrow_constraint({:?}, {:?}, {:?})\",\n-               location, borrow_region, borrowed_place);\n+        debug!(\n+            \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n+            location, borrow_region, borrowed_place\n+        );\n         while let Projection(box PlaceProjection { base, elem }) = borrowed_place {\n             debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_place);\n \n@@ -165,12 +272,20 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                                 location.successor_within_block(),\n                             );\n \n+                            if let Some(all_facts) = self.all_facts {\n+                                all_facts.outlives.push((\n+                                    ref_region.to_region_vid(),\n+                                    borrow_region.to_region_vid(),\n+                                    self.location_table.mid_index(location),\n+                                ));\n+                            }\n+\n                             match mutbl {\n                                 hir::Mutability::MutImmutable => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n-                                    break\n+                                    break;\n                                 }\n                                 hir::Mutability::MutMutable => {\n                                     // Mutable reference. We *do* need the base\n@@ -199,19 +314,19 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                         }\n                         ty::TyRawPtr(..) => {\n                             // deref of raw pointer, guaranteed to be valid\n-                            break\n+                            break;\n                         }\n                         ty::TyAdt(def, _) if def.is_box() => {\n                             // deref of `Box`, need the base to be valid - propagate\n                         }\n-                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place)\n+                        _ => bug!(\"unexpected deref ty {:?} in {:?}\", base_ty, borrowed_place),\n                     }\n                 }\n-                ProjectionElem::Field(..) |\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Index(..) |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Subslice { .. } => {\n+                ProjectionElem::Field(..)\n+                | ProjectionElem::Downcast(..)\n+                | ProjectionElem::Index(..)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {\n                     // other field access\n                 }\n             }"}, {"sha": "2802aa0dff4e23553430ca6651f149d87c5327bb", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -0,0 +1,194 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::location::{LocationIndex, LocationTable};\n+use dataflow::indexes::BorrowIndex;\n+use rustc::ty::RegionVid;\n+use std::error::Error;\n+use std::fmt::Debug;\n+use std::fs::{self, File};\n+use std::io::Write;\n+use std::path::Path;\n+\n+/// The \"facts\" which are the basis of the NLL borrow analysis.\n+#[derive(Default)]\n+crate struct AllFacts {\n+    // `borrow_region(R, B, P)` -- the region R may refer to data from borrow B\n+    // starting at the point P (this is usually the point *after* a borrow rvalue)\n+    crate borrow_region: Vec<(RegionVid, BorrowIndex, LocationIndex)>,\n+\n+    // universal_region(R) -- this is a \"free region\" within fn body\n+    crate universal_region: Vec<RegionVid>,\n+\n+    // `cfg_edge(P,Q)` for each edge P -> Q in the control flow\n+    crate cfg_edge: Vec<(LocationIndex, LocationIndex)>,\n+\n+    // `killed(B,P)` when some prefix of the path borrowed at B is assigned at point P\n+    crate killed: Vec<(BorrowIndex, LocationIndex)>,\n+\n+    // `outlives(R1, R2, P)` when we require `R1@P: R2@P`\n+    crate outlives: Vec<(RegionVid, RegionVid, LocationIndex)>,\n+\n+    // `region_live_at(R, P)` when the region R appears in a live variable at P\n+    crate region_live_at: Vec<(RegionVid, LocationIndex)>,\n+}\n+\n+impl AllFacts {\n+    crate fn write_to_dir(\n+        &self,\n+        dir: impl AsRef<Path>,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        let dir: &Path = dir.as_ref();\n+        fs::create_dir_all(dir)?;\n+        let wr = FactWriter { location_table, dir };\n+        macro_rules! write_facts_to_path {\n+            ($wr:ident . write_facts_to_path($this:ident . [\n+                $($field:ident,)*\n+            ])) => {\n+                $(\n+                    $wr.write_facts_to_path(\n+                        &$this.$field,\n+                        &format!(\"{}.facts\", stringify!($field))\n+                    )?;\n+                )*\n+            }\n+        }\n+        write_facts_to_path! {\n+            wr.write_facts_to_path(self.[\n+                borrow_region,\n+                universal_region,\n+                cfg_edge,\n+                killed,\n+                outlives,\n+                region_live_at,\n+            ])\n+        }\n+        Ok(())\n+    }\n+}\n+\n+struct FactWriter<'w> {\n+    location_table: &'w LocationTable,\n+    dir: &'w Path,\n+}\n+\n+impl<'w> FactWriter<'w> {\n+    fn write_facts_to_path<T>(\n+        &self,\n+        rows: &Vec<T>,\n+        file_name: &str,\n+    ) -> Result<(), Box<dyn Error>>\n+    where\n+        T: FactRow,\n+    {\n+        let file = &self.dir.join(file_name);\n+        let mut file = File::create(file)?;\n+        for row in rows {\n+            row.write(&mut file, self.location_table)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+trait FactRow {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>>;\n+}\n+\n+impl FactRow for RegionVid {\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[self])\n+    }\n+}\n+\n+impl<A, B> FactRow for (A, B)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1])\n+    }\n+}\n+\n+impl<A, B, C> FactRow for (A, B, C)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2])\n+    }\n+}\n+\n+impl<A, B, C, D> FactRow for (A, B, C, D)\n+where\n+    A: FactCell,\n+    B: FactCell,\n+    C: FactCell,\n+    D: FactCell,\n+{\n+    fn write(\n+        &self,\n+        out: &mut File,\n+        location_table: &LocationTable,\n+    ) -> Result<(), Box<dyn Error>> {\n+        write_row(out, location_table, &[&self.0, &self.1, &self.2, &self.3])\n+    }\n+}\n+\n+fn write_row(\n+    out: &mut dyn Write,\n+    location_table: &LocationTable,\n+    columns: &[&dyn FactCell],\n+) -> Result<(), Box<dyn Error>> {\n+    for (index, c) in columns.iter().enumerate() {\n+        let tail = if index == columns.len() - 1 {\n+            \"\\n\"\n+        } else {\n+            \"\\t\"\n+        };\n+        write!(out, \"{:?}{}\", c.to_string(location_table), tail)?;\n+    }\n+    Ok(())\n+}\n+\n+trait FactCell {\n+    fn to_string(&self, location_table: &LocationTable) -> String;\n+}\n+\n+impl<A: Debug> FactCell for A {\n+    default fn to_string(&self, _location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+}\n+\n+impl FactCell for LocationIndex {\n+    fn to_string(&self, location_table: &LocationTable) -> String {\n+        format!(\"{:?}\", location_table.to_location(*self))\n+    }\n+}"}, {"sha": "0b1729294d8494b3ba74e8c61b482015f0789977", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -9,36 +9,39 @@\n // except according to those terms.\n \n use borrow_check::borrow_set::BorrowSet;\n+use borrow_check::location::LocationTable;\n+use dataflow::move_paths::MoveData;\n+use dataflow::FlowAtLocation;\n+use dataflow::MaybeInitializedPlaces;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{ClosureRegionRequirements, ClosureOutlivesSubject, Mir};\n use rustc::infer::InferCtxt;\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::io;\n+use std::path::PathBuf;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n-use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedPlaces;\n-use dataflow::move_paths::MoveData;\n \n+use self::mir_util::PassWhere;\n use util as mir_util;\n use util::pretty::{self, ALIGN};\n-use self::mir_util::PassWhere;\n \n mod constraint_generation;\n pub mod explain_borrow;\n-pub(crate) mod region_infer;\n+mod facts;\n+crate mod region_infer;\n mod renumber;\n mod subtype_constraint_generation;\n-pub(crate) mod type_check;\n+crate mod type_check;\n mod universal_regions;\n \n+use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n-\n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n@@ -71,10 +74,11 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n+    location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-    _borrow_set: &BorrowSet<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n     Option<ClosureRegionRequirements<'gcx>>,\n@@ -92,15 +96,47 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         move_data,\n     );\n \n+    let mut all_facts = if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n+        Some(AllFacts::default())\n+    } else {\n+        None\n+    };\n+\n+    if let Some(all_facts) = &mut all_facts {\n+        all_facts\n+            .universal_region\n+            .extend(universal_regions.universal_regions());\n+    }\n+\n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n-\n+    let mut regioncx =\n+        RegionInferenceContext::new(var_origins, universal_regions, mir);\n+\n+    // Generate various constraints.\n+    subtype_constraint_generation::generate(\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        mir,\n+        constraint_sets,\n+    );\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut regioncx,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        borrow_set,\n+    );\n \n-    // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir);\n+    // Dump facts if requested.\n+    if let Some(all_facts) = all_facts {\n+        let def_path = infcx.tcx.hir.def_path(def_id);\n+        let dir_path = PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n+        all_facts.write_to_dir(dir_path, location_table).unwrap();\n+    }\n \n     // Solve the region constraints.\n     let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);"}, {"sha": "9db19085a39654b630dc4833d9a4b09fb2c45c70", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::mir::Mir;\n+use borrow_check::location::LocationTable;\n+use borrow_check::nll::facts::AllFacts;\n use rustc::infer::region_constraints::Constraint;\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::infer::region_constraints::{Verify, VerifyBound};\n+use rustc::mir::{Location, Mir};\n use rustc::ty;\n+use std::iter;\n use syntax::codemap::Span;\n \n-use super::region_infer::{TypeTest, RegionInferenceContext, RegionTest};\n+use super::region_infer::{RegionInferenceContext, RegionTest, TypeTest};\n use super::type_check::Locations;\n use super::type_check::MirTypeckRegionConstraints;\n use super::type_check::OutlivesSet;\n@@ -27,19 +30,30 @@ use super::type_check::OutlivesSet;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n+    all_facts: &mut Option<AllFacts>,\n+    location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n-    SubtypeConstraintGenerator { regioncx, mir }.generate(constraints);\n+    SubtypeConstraintGenerator {\n+        regioncx,\n+        location_table,\n+        mir,\n+    }.generate(constraints, all_facts);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n+    location_table: &'cx LocationTable,\n     mir: &'cx Mir<'tcx>,\n }\n \n impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n-    fn generate(&mut self, constraints: &MirTypeckRegionConstraints<'tcx>) {\n+    fn generate(\n+        &mut self,\n+        constraints: &MirTypeckRegionConstraints<'tcx>,\n+        all_facts: &mut Option<AllFacts>,\n+    ) {\n         let MirTypeckRegionConstraints {\n             liveness_set,\n             outlives_sets,\n@@ -57,6 +71,17 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n             self.regioncx.add_live_point(region_vid, *location, &cause);\n         }\n \n+        if let Some(all_facts) = all_facts {\n+            all_facts\n+                .region_live_at\n+                .extend(liveness_set.into_iter().flat_map(|(region, location, _)| {\n+                    let r = self.to_region_vid(region);\n+                    let p1 = self.location_table.start_index(*location);\n+                    let p2 = self.location_table.mid_index(*location);\n+                    iter::once((r, p1)).chain(iter::once((r, p2)))\n+                }));\n+        }\n+\n         for OutlivesSet { locations, data } in outlives_sets {\n             debug!(\"generate: constraints at: {:#?}\", locations);\n             let RegionConstraintData {\n@@ -65,7 +90,11 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 givens,\n             } = data;\n \n-            let span = self.mir.source_info(locations.from_location).span;\n+            let span = self.mir\n+                .source_info(locations.from_location().unwrap_or(Location::START))\n+                .span;\n+\n+            let at_location = locations.at_location().unwrap_or(Location::START);\n \n             for constraint in constraints.keys() {\n                 debug!(\"generate: constraint: {:?}\", constraint);\n@@ -83,8 +112,24 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n                 // reverse direction, because `regioncx` talks about\n                 // \"outlives\" (`>=`) whereas the region constraints\n                 // talk about `<=`.\n-                self.regioncx\n-                    .add_outlives(span, b_vid, a_vid, locations.at_location);\n+                self.regioncx.add_outlives(span, b_vid, a_vid, at_location);\n+\n+                // In the new analysis, all outlives relations etc\n+                // \"take effect\" at the mid point of the statement\n+                // that requires them, so ignore the `at_location`.\n+                if let Some(all_facts) = all_facts {\n+                    if let Some(from_location) = locations.from_location() {\n+                        all_facts.outlives.push((\n+                            b_vid,\n+                            a_vid,\n+                            self.location_table.mid_index(from_location),\n+                        ));\n+                    } else {\n+                        for location in self.location_table.all_points() {\n+                            all_facts.outlives.push((b_vid, a_vid, location));\n+                        }\n+                    }\n+                }\n             }\n \n             for verify in verifys {\n@@ -109,7 +154,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n \n         let lower_bound = self.to_region_vid(verify.region);\n \n-        let point = locations.at_location;\n+        let point = locations.at_location().unwrap_or(Location::START);\n \n         let test = self.verify_bound_to_region_test(&verify.bound);\n \n@@ -149,14 +194,6 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n     }\n \n     fn to_region_vid(&self, r: ty::Region<'tcx>) -> ty::RegionVid {\n-        // Every region that we see in the constraints came from the\n-        // MIR or from the parameter environment. If the former, it\n-        // will be a region variable.  If the latter, it will be in\n-        // the set of universal regions *somewhere*.\n-        if let ty::ReVar(vid) = r {\n-            *vid\n-        } else {\n-            self.regioncx.to_region_vid(r)\n-        }\n+        self.regioncx.to_region_vid(r)\n     }\n }"}, {"sha": "2b1878c33e90b78f877672427d6c7f6703fae1de", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -29,7 +29,7 @@ use rustc::traits::PredicateObligations;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::{AtLocation, TypeChecker};\n+use super::{Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n@@ -47,26 +47,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         } = universal_regions;\n         let infcx = self.infcx;\n \n-        let start_position = Location {\n-            block: START_BLOCK,\n-            statement_index: 0,\n-        };\n-\n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n         for (&unnormalized_input_ty, local) in unnormalized_input_tys.iter().zip(argument_locals) {\n-            let input_ty = self.normalize(&unnormalized_input_ty, start_position);\n+            let input_ty = self.normalize(&unnormalized_input_ty, Locations::All);\n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(start_position, input_ty, mir_input_ty);\n+            self.equate_normalized_input_or_output(input_ty, mir_input_ty);\n         }\n \n         assert!(\n             mir.yield_ty.is_some() && universal_regions.yield_ty.is_some() ||\n             mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n-            );\n+        );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            self.equate_normalized_input_or_output(start_position, ur_yield_ty, mir_yield_ty);\n+            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n@@ -75,13 +70,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n             unnormalized_output_ty\n         );\n-        let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        let output_ty = self.normalize(&unnormalized_output_ty, Locations::All);\n         debug!(\n             \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n             output_ty\n         );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let anon_type_map = self.fully_perform_op(start_position.at_self(), |cx| {\n+        let anon_type_map = self.fully_perform_op(Locations::All, |cx| {\n             let mut obligations = ObligationAccumulator::default();\n \n             let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n@@ -112,7 +107,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n                 let anon_defn_ty = renumber::renumber_regions(\n                     cx.infcx,\n-                    TyContext::Location(start_position),\n+                    TyContext::Location(Location::START),\n                     &anon_defn_ty,\n                 );\n                 debug!(\n@@ -134,7 +129,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }).unwrap_or_else(|terr| {\n                 span_mirbug!(\n                     self,\n-                    start_position,\n+                    Location::START,\n                     \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n                     output_ty,\n                     mir_output_ty,\n@@ -148,7 +143,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(anon_type_map) = anon_type_map {\n-            self.fully_perform_op(start_position.at_self(), |_cx| {\n+            self.fully_perform_op(Locations::All, |_cx| {\n                 infcx.constrain_anon_types(&anon_type_map, universal_regions);\n                 Ok(InferOk {\n                     value: (),\n@@ -158,13 +153,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n         debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n \n-        if let Err(terr) = self.eq_types(a, b, location.at_self()) {\n+        if let Err(terr) = self.eq_types(a, b, Locations::All) {\n             span_mirbug!(\n                 self,\n-                location,\n+                Location::START,\n                 \"equate_normalized_input_or_output: `{:?}=={:?}` failed with `{:?}`\",\n                 a,\n                 b,"}, {"sha": "42a1745addff75de36333f0f7047e59e2af05aea", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 90, "deletions": 19, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -618,17 +618,72 @@ pub struct OutlivesSet<'tcx> {\n     pub data: RegionConstraintData<'tcx>,\n }\n \n+/// The `Locations` type summarizes *where* region constraints are\n+/// required to hold. Normally, this is at a particular point which\n+/// created the obligation, but for constraints that the user gave, we\n+/// want the constraint to hold at all points.\n #[derive(Copy, Clone, Debug)]\n-pub struct Locations {\n-    /// The location in the MIR that generated these constraints.\n-    /// This is intended for error reporting and diagnosis; the\n-    /// constraints may *take effect* at a distinct spot.\n-    pub from_location: Location,\n-\n-    /// The constraints must be met at this location. In terms of the\n-    /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n-    /// is the `P` value.\n-    pub at_location: Location,\n+pub enum Locations {\n+    /// Indicates that a type constraint should always be true. This\n+    /// is particularly important in the new borrowck analysis for\n+    /// things like the type of the return slot. Consider this\n+    /// example:\n+    ///\n+    /// ```\n+    /// fn foo<'a>(x: &'a u32) -> &'a u32 {\n+    ///     let y = 22;\n+    ///     return &y; // error\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, we wind up with the signature from the return type being\n+    /// something like `&'1 u32` where `'1` is a universal region. But\n+    /// the type of the return slot `_0` is something like `&'2 u32`\n+    /// where `'2` is an existential region variable. The type checker\n+    /// requires that `&'2 u32 = &'1 u32` -- but at what point? In the\n+    /// older NLL analysis, we required this only at the entry point\n+    /// to the function. By the nature of the constraints, this wound\n+    /// up propagating to all points reachable from start (because\n+    /// `'1` -- as a universal region -- is live everywhere).  In the\n+    /// newer analysis, though, this doesn't work: `_0` is considered\n+    /// dead at the start (it has no usable value) and hence this type\n+    /// equality is basically a no-op. Then, later on, when we do `_0\n+    /// = &'3 y`, that region `'3` never winds up related to the\n+    /// universal region `'1` and hence no error occurs. Therefore, we\n+    /// use Locations::All instead, which ensures that the `'1` and\n+    /// `'2` are equal everything. We also use this for other\n+    /// user-given type annotations; e.g., if the user wrote `let mut\n+    /// x: &'static u32 = ...`, we would ensure that all values\n+    /// assigned to `x` are of `'static` lifetime.\n+    All,\n+\n+    Pair {\n+        /// The location in the MIR that generated these constraints.\n+        /// This is intended for error reporting and diagnosis; the\n+        /// constraints may *take effect* at a distinct spot.\n+        from_location: Location,\n+\n+        /// The constraints must be met at this location. In terms of the\n+        /// NLL RFC, when you have a constraint `R1: R2 @ P`, this field\n+        /// is the `P` value.\n+        at_location: Location,\n+    }\n+}\n+\n+impl Locations {\n+    pub fn from_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { from_location, .. } => Some(*from_location),\n+        }\n+    }\n+\n+    pub fn at_location(&self) -> Option<Location> {\n+        match self {\n+            Locations::All => None,\n+            Locations::Pair { at_location, .. } => Some(*at_location),\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -770,7 +825,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n                     ty, local_ty\n                 );\n-                if let Err(terr) = self.eq_types(ty, local_ty, location.at_self()) {\n+                if let Err(terr) = self.eq_types(ty, local_ty, Locations::All) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -820,7 +875,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target.start_location(),\n                 };\n@@ -839,7 +894,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // *both* blocks, so we need to ensure that it holds\n                 // at both locations.\n                 if let Some(unwind) = unwind {\n-                    let locations = Locations {\n+                    let locations = Locations::Pair {\n                         from_location: term_location,\n                         at_location: unwind.start_location(),\n                     };\n@@ -971,7 +1026,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let locations = Locations {\n+                let locations = Locations::Pair {\n                     from_location: term_location,\n                     at_location: target_block.start_location(),\n                 };\n@@ -1375,7 +1430,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             };\n             let operand_ty = operand.ty(mir, tcx);\n             if let Err(terr) =\n-                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+                self.sub_types(operand_ty, field_ty, location.at_self())\n             {\n                 span_mirbug!(\n                     self,\n@@ -1514,12 +1569,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn normalize<T>(&mut self, value: &T, location: Location) -> T\n+    fn normalize<T>(&mut self, value: &T, location: impl ToLocations) -> T\n     where\n         T: fmt::Debug + TypeFoldable<'tcx>,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n-        self.fully_perform_op(location.at_self(), |this| {\n+        self.fully_perform_op(location.to_locations(), |this| {\n             let Normalized { value, obligations } = this.infcx\n                 .at(&this.misc(this.last_span), this.param_env)\n                 .normalize(value)\n@@ -1585,16 +1640,32 @@ trait AtLocation {\n \n impl AtLocation for Location {\n     fn at_self(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self,\n         }\n     }\n \n     fn at_successor_within_block(self) -> Locations {\n-        Locations {\n+        Locations::Pair {\n             from_location: self,\n             at_location: self.successor_within_block(),\n         }\n     }\n }\n+\n+trait ToLocations: fmt::Debug + Copy {\n+    fn to_locations(self) -> Locations;\n+}\n+\n+impl ToLocations for Locations {\n+    fn to_locations(self) -> Locations {\n+        self\n+    }\n+}\n+\n+impl ToLocations for Location {\n+    fn to_locations(self) -> Locations {\n+        self.at_self()\n+    }\n+}"}, {"sha": "2545ba3a94af12215c6a4a15437304944a2ee358", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -34,6 +34,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(inclusive_range_methods)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n+#![feature(specialization)]\n #![cfg_attr(stage0, feature(try_trait))]\n \n extern crate arena;"}, {"sha": "5397d18cdd720be1b0d185fe4359e88d10bb07d3", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d847dc90fd9dcfeb549bad91a306096dbe08f2d/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=2d847dc90fd9dcfeb549bad91a306096dbe08f2d", "patch": "@@ -550,7 +550,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_on_init(&mut self) {\n-        let loc = Location { block: START_BLOCK, statement_index: 0 };\n+        let loc = Location::START;\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n@@ -576,7 +576,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_args(&mut self) {\n-        let loc = Location { block: START_BLOCK, statement_index: 0 };\n+        let loc = Location::START;\n         dataflow::drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);"}]}