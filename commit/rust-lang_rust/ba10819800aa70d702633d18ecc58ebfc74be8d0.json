{"sha": "ba10819800aa70d702633d18ecc58ebfc74be8d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTA4MTk4MDBhYTcwZDcwMjYzM2QxOGVjYzU4ZWJmYzc0YmU4ZDA=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-12T22:57:12Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-07-13T01:16:01Z"}, "message": "Added a message send that uses shared chans. They are slower than port selectors, but scale better.", "tree": {"sha": "87e9d120b9f62951be0f5c572016a99dab374b0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e9d120b9f62951be0f5c572016a99dab374b0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba10819800aa70d702633d18ecc58ebfc74be8d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba10819800aa70d702633d18ecc58ebfc74be8d0", "html_url": "https://github.com/rust-lang/rust/commit/ba10819800aa70d702633d18ecc58ebfc74be8d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba10819800aa70d702633d18ecc58ebfc74be8d0/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75e55c1b1260bc0c9f20624820b6c84160b9585c", "url": "https://api.github.com/repos/rust-lang/rust/commits/75e55c1b1260bc0c9f20624820b6c84160b9585c", "html_url": "https://github.com/rust-lang/rust/commit/75e55c1b1260bc0c9f20624820b6c84160b9585c"}], "stats": {"total": 208, "additions": 208, "deletions": 0}, "files": [{"sha": "ea4834609537f8d323e652b9252c6863a8b52d25", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/ba10819800aa70d702633d18ecc58ebfc74be8d0/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba10819800aa70d702633d18ecc58ebfc74be8d0/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=ba10819800aa70d702633d18ecc58ebfc74be8d0", "patch": "@@ -0,0 +1,208 @@\n+// A port of the simplistic benchmark from\n+//\n+//    http://github.com/PaulKeeble/ScalaVErlangAgents\n+//\n+// I *think* it's the same, more or less.\n+\n+// This version uses pipes with a shared send endpoint. It should have\n+// different scalability characteristics compared to the select\n+// version.\n+\n+use std;\n+import io::writer;\n+import io::writer_util;\n+\n+import arc::methods;\n+import pipes::{port, chan};\n+\n+macro_rules! move {\n+    { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n+}\n+\n+enum request {\n+    get_count,\n+    bytes(uint),\n+    stop\n+}\n+\n+fn server(requests: port<request>, responses: pipes::chan<uint>) {\n+    let mut count = 0u;\n+    let mut done = false;\n+    while !done {\n+        alt requests.try_recv() {\n+          some(get_count) { responses.send(copy count); }\n+          some(bytes(b)) {\n+            //#error(\"server: received %? bytes\", b);\n+            count += b;\n+          }\n+          none { done = true; }\n+          _ { }\n+        }\n+    }\n+    responses.send(count);\n+    //#error(\"server exiting\");\n+}\n+\n+fn run(args: &[str]) {\n+    let (to_parent, from_child) = pipes::stream();\n+    let (to_child, from_parent) = pipes::stream();\n+\n+    let to_child = shared_chan(to_child);\n+\n+    let size = option::get(uint::from_str(args[1]));\n+    let workers = option::get(uint::from_str(args[2]));\n+    let num_bytes = 100;\n+    let start = std::time::precise_time_s();\n+    let mut worker_results = ~[];\n+    for uint::range(0u, workers) |i| {\n+        let builder = task::builder();\n+        vec::push(worker_results, task::future_result(builder));\n+        let to_child = to_child.clone();\n+        do task::run(builder) {\n+            for uint::range(0u, size / workers) |_i| {\n+                //#error(\"worker %?: sending %? bytes\", i, num_bytes);\n+                to_child.send(bytes(num_bytes));\n+            }\n+            //#error(\"worker %? exiting\", i);\n+        };\n+    }\n+    do task::spawn {\n+        server(from_parent, to_parent);\n+    }\n+\n+    vec::iter(worker_results, |r| { future::get(r); } );\n+    //#error(\"sending stop message\");\n+    to_child.send(stop);\n+    move!{to_child};\n+    let result = from_child.recv();\n+    let end = std::time::precise_time_s();\n+    let elapsed = end - start;\n+    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n+    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    let thruput = ((size / workers * workers) as float) / (elapsed as float);\n+    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    assert result == num_bytes * size;\n+}\n+\n+fn main(args: ~[str]) {\n+    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        ~[\"\", \"1000000\", \"10000\"]\n+    } else if args.len() <= 1u {\n+        ~[\"\", \"10000\", \"4\"]\n+    } else {\n+        copy args\n+    };        \n+\n+    #debug(\"%?\", args);\n+    run(args);\n+}\n+\n+// Treat a whole bunch of ports as one.\n+class box<T> {\n+    let mut contents: option<T>;\n+    new(+x: T) { self.contents = some(x); }\n+\n+    fn swap(f: fn(+T) -> T) {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        self.contents = some(f(option::unwrap(tmp)));\n+    }\n+\n+    fn unwrap() -> T {\n+        let mut tmp = none;\n+        self.contents <-> tmp;\n+        option::unwrap(tmp)\n+    }\n+}\n+\n+class port_set<T: send> {\n+    let mut ports: ~[pipes::port<T>];\n+\n+    new() { self.ports = ~[]; }\n+\n+    fn add(+port: pipes::port<T>) {\n+        vec::push(self.ports, port)\n+    }\n+\n+    fn try_recv() -> option<T> {\n+        let mut result = none;\n+        while result == none && self.ports.len() > 0 {\n+            let i = pipes::wait_many(self.ports.map(|p| p.header()));\n+            // dereferencing an unsafe pointer nonsense to appease the\n+            // borrowchecker.\n+            alt unsafe {(*ptr::addr_of(self.ports[i])).try_recv()} {\n+              some(m) {\n+                result = some(move!{m});\n+              }\n+              none {\n+                // Remove this port.\n+                let mut ports = ~[];\n+                self.ports <-> ports;\n+                vec::consume(ports,\n+                             |j, x| if i != j { vec::push(self.ports, x) });\n+              }\n+            }\n+        }\n+/*        \n+        while !done {\n+            do self.ports.swap |ports| {\n+                if ports.len() > 0 {\n+                    let old_len = ports.len();\n+                    let (_, m, ports) = pipes::select(ports);\n+                    alt m {\n+                      some(pipes::streamp::data(x, next)) {\n+                        result = some(move!{x});\n+                        done = true;\n+                        assert ports.len() == old_len - 1;\n+                        vec::append_one(ports, move!{next})\n+                      }\n+                      none {\n+                        //#error(\"pipe closed\");\n+                        assert ports.len() == old_len - 1;\n+                        ports\n+                      }\n+                    }\n+                }\n+                else {\n+                    //#error(\"no more pipes\");\n+                    done = true;\n+                    ~[]\n+                }\n+            }\n+        }\n+*/\n+        result\n+    }\n+\n+    fn recv() -> T {\n+        option::unwrap(self.try_recv())\n+    }\n+}\n+\n+impl private_methods/&<T: send> for pipes::port<T> {\n+    pure fn header() -> *pipes::packet_header unchecked {\n+        alt self.endp {\n+          some(endp) {\n+            endp.header()\n+          }\n+          none { fail \"peeking empty stream\" }\n+        }\n+    }\n+}\n+\n+type shared_chan<T: send> = arc::exclusive<pipes::chan<T>>;\n+\n+impl chan<T: send> for shared_chan<T> {\n+    fn send(+x: T) {\n+        let mut xx = some(x);\n+        do self.with |_c, chan| {\n+            let mut x = none;\n+            x <-> xx;\n+            chan.send(option::unwrap(x))\n+        }\n+    }\n+}\n+\n+fn shared_chan<T:send>(+c: pipes::chan<T>) -> shared_chan<T> {\n+    arc::exclusive(c)\n+}\n\\ No newline at end of file"}]}