{"sha": "cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "node_id": "C_kwDOAAsO6NoAKGNmMGU3OGJkM2JjZmQxMDEwZjg5MzNhY2M2ZTEzNDQxMDAxNmY2ZjA", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-03-13T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2023-03-14T20:29:32Z"}, "message": "Use index based drop loop for slices and arrays\n\nInstead of building two kinds of drop pair loops, of which only one will\nbe eventually used at runtime in a given monomorphization, always use\nindex based loop.", "tree": {"sha": "52880008ad597de7f5d2f1338646e403288289f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52880008ad597de7f5d2f1338646e403288289f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "html_url": "https://github.com/rust-lang/rust/commit/cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf0e78bd3bcfd1010f8933acc6e134410016f6f0/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7034ebf7f57066c260b680c5e9dfcf04ca4cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7034ebf7f57066c260b680c5e9dfcf04ca4cd5", "html_url": "https://github.com/rust-lang/rust/commit/2e7034ebf7f57066c260b680c5e9dfcf04ca4cd5"}], "stats": {"total": 213, "additions": 49, "deletions": 164}, "files": [{"sha": "486275570bd111f93075d7565fb12880abf2d43b", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 32, "deletions": 101, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cf0e78bd3bcfd1010f8933acc6e134410016f6f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf0e78bd3bcfd1010f8933acc6e134410016f6f0/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "patch": "@@ -655,26 +655,20 @@ where\n     ///\n     /// ```text\n     /// loop-block:\n-    ///    can_go = cur == length_or_end\n+    ///    can_go = cur == len\n     ///    if can_go then succ else drop-block\n     /// drop-block:\n-    ///    if ptr_based {\n-    ///        ptr = cur\n-    ///        cur = cur.offset(1)\n-    ///    } else {\n-    ///        ptr = &raw mut P[cur]\n-    ///        cur = cur + 1\n-    ///    }\n+    ///    ptr = &raw mut P[cur]\n+    ///    cur = cur + 1\n     ///    drop(ptr)\n     /// ```\n     fn drop_loop(\n         &mut self,\n         succ: BasicBlock,\n         cur: Local,\n-        length_or_end: Place<'tcx>,\n+        len: Local,\n         ety: Ty<'tcx>,\n         unwind: Unwind,\n-        ptr_based: bool,\n     ) -> BasicBlock {\n         let copy = |place: Place<'tcx>| Operand::Copy(place);\n         let move_ = |place: Place<'tcx>| Operand::Move(place);\n@@ -683,22 +677,19 @@ where\n         let ptr_ty = tcx.mk_ptr(ty::TypeAndMut { ty: ety, mutbl: hir::Mutability::Mut });\n         let ptr = Place::from(self.new_temp(ptr_ty));\n         let can_go = Place::from(self.new_temp(tcx.types.bool));\n-\n         let one = self.constant_usize(1);\n-        let (ptr_next, cur_next) = if ptr_based {\n-            (\n-                Rvalue::Use(copy(cur.into())),\n-                Rvalue::BinaryOp(BinOp::Offset, Box::new((move_(cur.into()), one))),\n-            )\n-        } else {\n-            (\n-                Rvalue::AddressOf(Mutability::Mut, tcx.mk_place_index(self.place, cur)),\n-                Rvalue::BinaryOp(BinOp::Add, Box::new((move_(cur.into()), one))),\n-            )\n-        };\n \n         let drop_block = BasicBlockData {\n-            statements: vec![self.assign(ptr, ptr_next), self.assign(Place::from(cur), cur_next)],\n+            statements: vec![\n+                self.assign(\n+                    ptr,\n+                    Rvalue::AddressOf(Mutability::Mut, tcx.mk_place_index(self.place, cur)),\n+                ),\n+                self.assign(\n+                    cur.into(),\n+                    Rvalue::BinaryOp(BinOp::Add, Box::new((move_(cur.into()), one))),\n+                ),\n+            ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n@@ -711,10 +702,7 @@ where\n         let loop_block = BasicBlockData {\n             statements: vec![self.assign(\n                 can_go,\n-                Rvalue::BinaryOp(\n-                    BinOp::Eq,\n-                    Box::new((copy(Place::from(cur)), copy(length_or_end))),\n-                ),\n+                Rvalue::BinaryOp(BinOp::Eq, Box::new((copy(Place::from(cur)), copy(len.into())))),\n             )],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -738,13 +726,6 @@ where\n \n     fn open_drop_for_array(&mut self, ety: Ty<'tcx>, opt_size: Option<u64>) -> BasicBlock {\n         debug!(\"open_drop_for_array({:?}, {:?})\", ety, opt_size);\n-\n-        // if size_of::<ety>() == 0 {\n-        //     index_based_loop\n-        // } else {\n-        //     ptr_based_loop\n-        // }\n-\n         let tcx = self.tcx();\n \n         if let Some(size) = opt_size {\n@@ -770,86 +751,36 @@ where\n             }\n         }\n \n-        let move_ = |place: Place<'tcx>| Operand::Move(place);\n-        let elem_size = Place::from(self.new_temp(tcx.types.usize));\n-        let len = Place::from(self.new_temp(tcx.types.usize));\n-\n-        let base_block = BasicBlockData {\n-            statements: vec![\n-                self.assign(elem_size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n-                self.assign(len, Rvalue::Len(self.place)),\n-            ],\n-            is_cleanup: self.unwind.is_cleanup(),\n-            terminator: Some(Terminator {\n-                source_info: self.source_info,\n-                kind: TerminatorKind::SwitchInt {\n-                    discr: move_(elem_size),\n-                    targets: SwitchTargets::static_if(\n-                        0,\n-                        self.drop_loop_pair(ety, false, len),\n-                        self.drop_loop_pair(ety, true, len),\n-                    ),\n-                },\n-            }),\n-        };\n-        self.elaborator.patch().new_block(base_block)\n+        self.drop_loop_pair(ety)\n     }\n \n     /// Creates a pair of drop-loops of `place`, which drops its contents, even\n-    /// in the case of 1 panic. If `ptr_based`, creates a pointer loop,\n-    /// otherwise create an index loop.\n-    fn drop_loop_pair(\n-        &mut self,\n-        ety: Ty<'tcx>,\n-        ptr_based: bool,\n-        length: Place<'tcx>,\n-    ) -> BasicBlock {\n-        debug!(\"drop_loop_pair({:?}, {:?})\", ety, ptr_based);\n+    /// in the case of 1 panic.\n+    fn drop_loop_pair(&mut self, ety: Ty<'tcx>) -> BasicBlock {\n+        debug!(\"drop_loop_pair({:?})\", ety);\n         let tcx = self.tcx();\n-        let iter_ty = if ptr_based { tcx.mk_mut_ptr(ety) } else { tcx.types.usize };\n+        let len = self.new_temp(tcx.types.usize);\n+        let cur = self.new_temp(tcx.types.usize);\n \n-        let cur = self.new_temp(iter_ty);\n-        let length_or_end = if ptr_based { Place::from(self.new_temp(iter_ty)) } else { length };\n+        let unwind =\n+            self.unwind.map(|unwind| self.drop_loop(unwind, cur, len, ety, Unwind::InCleanup));\n \n-        let unwind = self.unwind.map(|unwind| {\n-            self.drop_loop(unwind, cur, length_or_end, ety, Unwind::InCleanup, ptr_based)\n-        });\n+        let loop_block = self.drop_loop(self.succ, cur, len, ety, unwind);\n \n-        let loop_block = self.drop_loop(self.succ, cur, length_or_end, ety, unwind, ptr_based);\n-\n-        let cur = Place::from(cur);\n-        let drop_block_stmts = if ptr_based {\n-            let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n-            let tmp = Place::from(self.new_temp(tmp_ty));\n-            // tmp = &raw mut P;\n-            // cur = tmp as *mut T;\n-            // end = Offset(cur, len);\n-            let mir_cast_kind = ty::cast::mir_cast_kind(iter_ty, tmp_ty);\n-            vec![\n-                self.assign(tmp, Rvalue::AddressOf(Mutability::Mut, self.place)),\n-                self.assign(cur, Rvalue::Cast(mir_cast_kind, Operand::Move(tmp), iter_ty)),\n-                self.assign(\n-                    length_or_end,\n-                    Rvalue::BinaryOp(\n-                        BinOp::Offset,\n-                        Box::new((Operand::Copy(cur), Operand::Move(length))),\n-                    ),\n-                ),\n-            ]\n-        } else {\n-            // cur = 0 (length already pushed)\n-            let zero = self.constant_usize(0);\n-            vec![self.assign(cur, Rvalue::Use(zero))]\n-        };\n-        let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n-            statements: drop_block_stmts,\n+        let zero = self.constant_usize(0);\n+        let block = BasicBlockData {\n+            statements: vec![\n+                self.assign(len.into(), Rvalue::Len(self.place)),\n+                self.assign(cur.into(), Rvalue::Use(zero)),\n+            ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::Goto { target: loop_block },\n             }),\n-        });\n+        };\n \n+        let drop_block = self.elaborator.patch().new_block(block);\n         // FIXME(#34708): handle partially-dropped array/slice elements.\n         let reset_block = self.drop_flag_reset_block(DropFlagMode::Deep, drop_block, unwind);\n         self.drop_flag_test_block(reset_block, self.succ, unwind)"}, {"sha": "3884d29db41776f9eec87dd90c21ddffa5dab695", "filename": "tests/mir-opt/slice_drop_shim.core.ptr-drop_in_place.[String].AddMovesForPackedDrops.before.mir", "status": "modified", "additions": 17, "deletions": 63, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cf0e78bd3bcfd1010f8933acc6e134410016f6f0/tests%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cf0e78bd3bcfd1010f8933acc6e134410016f6f0/tests%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fslice_drop_shim.core.ptr-drop_in_place.%5BString%5D.AddMovesForPackedDrops.before.mir?ref=cf0e78bd3bcfd1010f8933acc6e134410016f6f0", "patch": "@@ -4,21 +4,13 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n     let mut _0: ();                      // return place in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     let mut _2: usize;                   // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     let mut _3: usize;                   // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _4: usize;                   // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _5: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _6: bool;                    // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _7: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _8: bool;                    // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _9: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _10: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _11: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _12: bool;                   // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _13: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _14: bool;                   // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _15: *mut [std::string::String]; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _4: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _5: bool;                    // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _6: *mut std::string::String; // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _7: bool;                    // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n \n     bb0: {\n-        goto -> bb15;                    // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        goto -> bb8;                     // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb1: {\n@@ -30,72 +22,34 @@ fn std::ptr::drop_in_place(_1: *mut [String]) -> () {\n     }\n \n     bb3 (cleanup): {\n-        _5 = &raw mut (*_1)[_4];         // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _4 = Add(move _4, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        drop((*_5)) -> bb4;              // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _4 = &raw mut (*_1)[_3];         // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _3 = Add(move _3, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        drop((*_4)) -> bb4;              // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb4 (cleanup): {\n-        _6 = Eq(_4, _3);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _6) -> [0: bb3, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _5 = Eq(_3, _2);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _5) -> [0: bb3, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb5: {\n-        _7 = &raw mut (*_1)[_4];         // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _4 = Add(move _4, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        drop((*_7)) -> [return: bb6, unwind: bb4]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _6 = &raw mut (*_1)[_3];         // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _3 = Add(move _3, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        drop((*_6)) -> [return: bb6, unwind: bb4]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb6: {\n-        _8 = Eq(_4, _3);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _8) -> [0: bb5, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _7 = Eq(_3, _2);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        switchInt(move _7) -> [0: bb5, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb7: {\n-        _4 = const 0_usize;              // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _2 = Len((*_1));                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _3 = const 0_usize;              // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n         goto -> bb6;                     // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n \n     bb8: {\n         goto -> bb7;                     // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     }\n-\n-    bb9 (cleanup): {\n-        _11 = _9;                        // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _9 = Offset(move _9, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        drop((*_11)) -> bb10;            // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb10 (cleanup): {\n-        _12 = Eq(_9, _10);               // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _12) -> [0: bb9, otherwise: bb2]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb11: {\n-        _13 = _9;                        // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _9 = Offset(move _9, const 1_usize); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        drop((*_13)) -> [return: bb12, unwind: bb10]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb12: {\n-        _14 = Eq(_9, _10);               // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _14) -> [0: bb11, otherwise: bb1]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb13: {\n-        _15 = &raw mut (*_1);            // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _9 = move _15 as *mut std::string::String (PtrToPtr); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _10 = Offset(_9, move _3);       // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        goto -> bb12;                    // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb14: {\n-        goto -> bb13;                    // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n-\n-    bb15: {\n-        _2 = SizeOf(std::string::String); // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _3 = Len((*_1));                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        switchInt(move _2) -> [0: bb8, otherwise: bb14]; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    }\n }"}]}