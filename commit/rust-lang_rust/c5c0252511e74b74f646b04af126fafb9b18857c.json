{"sha": "c5c0252511e74b74f646b04af126fafb9b18857c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YzAyNTI1MTFlNzRiNzRmNjQ2YjA0YWYxMjZmYWZiOWIxODg1N2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T20:31:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-20T20:31:34Z"}, "message": "auto merge of #7908 : anasazi/rust/fix_udp_mut, r=brson", "tree": {"sha": "5cac9c8381d05b63a0b1a88bf57a192a207bb387", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cac9c8381d05b63a0b1a88bf57a192a207bb387"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5c0252511e74b74f646b04af126fafb9b18857c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c0252511e74b74f646b04af126fafb9b18857c", "html_url": "https://github.com/rust-lang/rust/commit/c5c0252511e74b74f646b04af126fafb9b18857c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5c0252511e74b74f646b04af126fafb9b18857c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c999d4ecac0b4fb4b64c3e174f89bb5165abfd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c999d4ecac0b4fb4b64c3e174f89bb5165abfd3", "html_url": "https://github.com/rust-lang/rust/commit/5c999d4ecac0b4fb4b64c3e174f89bb5165abfd3"}, {"sha": "b03f1e7357d84667973b5a549388edbf35c7196b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b03f1e7357d84667973b5a549388edbf35c7196b", "html_url": "https://github.com/rust-lang/rust/commit/b03f1e7357d84667973b5a549388edbf35c7196b"}], "stats": {"total": 163, "additions": 81, "deletions": 82}, "files": [{"sha": "59649dee5b914f2cc302e4869736d50b59497dff", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=c5c0252511e74b74f646b04af126fafb9b18857c", "patch": "@@ -30,7 +30,7 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn recvfrom(&self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n+    pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n         match (**self).recvfrom(buf) {\n             Ok((nread, src)) => Some((nread, src)),\n             Err(ioerr) => {\n@@ -43,7 +43,7 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn sendto(&self, buf: &[u8], dst: IpAddr) {\n+    pub fn sendto(&mut self, buf: &[u8], dst: IpAddr) {\n         match (**self).sendto(buf, dst) {\n             Ok(_) => (),\n             Err(ioerr) => io_error::cond.raise(ioerr),\n@@ -61,16 +61,17 @@ pub struct UdpStream {\n }\n \n impl UdpStream {\n-    pub fn as_socket<T>(&self, f: &fn(&UdpSocket) -> T) -> T { f(&self.socket) }\n+    pub fn as_socket<T>(&mut self, f: &fn(&mut UdpSocket) -> T) -> T { f(&mut self.socket) }\n \n     pub fn disconnect(self) -> UdpSocket { self.socket }\n }\n \n impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let peer = self.connectedTo;\n         do self.as_socket |sock| {\n             match sock.recvfrom(buf) {\n-                Some((_nread, src)) if src != self.connectedTo => Some(0),\n+                Some((_nread, src)) if src != peer => Some(0),\n                 Some((nread, _src)) => Some(nread),\n                 None => None,\n             }\n@@ -122,7 +123,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n+                    Some(ref mut server) => {\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -139,7 +140,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(client_ip) {\n-                    Some(client) => client.sendto([99], server_ip),\n+                    Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n                 }\n             }\n@@ -154,7 +155,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(server_ip) {\n-                    Some(server) => {\n+                    Some(ref mut server) => {\n                         let mut buf = [0];\n                         match server.recvfrom(buf) {\n                             Some((nread, src)) => {\n@@ -171,7 +172,7 @@ mod test {\n \n             do spawntask_immediately {\n                 match UdpSocket::bind(client_ip) {\n-                    Some(client) => client.sendto([99], server_ip),\n+                    Some(ref mut client) => client.sendto([99], server_ip),\n                     None => fail!()\n                 }\n             }"}, {"sha": "10eba85188ef0aea153dd80a0809a54ebb4e24c8", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=c5c0252511e74b74f646b04af126fafb9b18857c", "patch": "@@ -50,37 +50,37 @@ pub trait IoFactory {\n \n pub trait RtioTcpListener : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n-    fn accept_simultaneously(&self);\n-    fn dont_accept_simultaneously(&self);\n+    fn accept_simultaneously(&mut self);\n+    fn dont_accept_simultaneously(&mut self);\n }\n \n pub trait RtioTcpStream : RtioSocket {\n-    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&self, buf: &[u8]) -> Result<(), IoError>;\n-    fn peer_name(&self) -> IpAddr;\n-    fn control_congestion(&self);\n-    fn nodelay(&self);\n-    fn keepalive(&self, delay_in_seconds: uint);\n-    fn letdie(&self);\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn peer_name(&mut self) -> IpAddr;\n+    fn control_congestion(&mut self);\n+    fn nodelay(&mut self);\n+    fn keepalive(&mut self, delay_in_seconds: uint);\n+    fn letdie(&mut self);\n }\n \n pub trait RtioSocket {\n-    fn socket_name(&self) -> IpAddr;\n+    fn socket_name(&mut self) -> IpAddr;\n }\n \n pub trait RtioUdpSocket : RtioSocket {\n-    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n-    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n+    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n \n-    fn join_multicast(&self, multi: IpAddr);\n-    fn leave_multicast(&self, multi: IpAddr);\n+    fn join_multicast(&mut self, multi: IpAddr);\n+    fn leave_multicast(&mut self, multi: IpAddr);\n \n-    fn loop_multicast_locally(&self);\n-    fn dont_loop_multicast_locally(&self);\n+    fn loop_multicast_locally(&mut self);\n+    fn dont_loop_multicast_locally(&mut self);\n \n-    fn multicast_time_to_live(&self, ttl: int);\n-    fn time_to_live(&self, ttl: int);\n+    fn multicast_time_to_live(&mut self, ttl: int);\n+    fn time_to_live(&mut self, ttl: int);\n \n-    fn hear_broadcasts(&self);\n-    fn ignore_broadcasts(&self);\n+    fn hear_broadcasts(&mut self);\n+    fn ignore_broadcasts(&mut self);\n }"}, {"sha": "86891a9df8aded4b75cc8c7b86ec96057397a6f9", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=c5c0252511e74b74f646b04af126fafb9b18857c", "patch": "@@ -359,7 +359,7 @@ impl UdpWatcher {\n         }\n     }\n \n-    pub fn bind(&self, address: IpAddr) -> Result<(), UvError> {\n+    pub fn bind(&mut self, address: IpAddr) -> Result<(), UvError> {\n         do ip_as_uv_ip(address) |addr| {\n             let result = unsafe {\n                 match addr {\n@@ -374,10 +374,9 @@ impl UdpWatcher {\n         }\n     }\n \n-    pub fn recv_start(&self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n+    pub fn recv_start(&mut self, alloc: AllocCallback, cb: UdpReceiveCallback) {\n         {\n-            let mut this = *self;\n-            let data = this.get_watcher_data();\n+            let data = self.get_watcher_data();\n             data.alloc_cb = Some(alloc);\n             data.udp_recv_cb = Some(cb);\n         }\n@@ -409,14 +408,13 @@ impl UdpWatcher {\n         }\n     }\n \n-    pub fn recv_stop(&self) {\n+    pub fn recv_stop(&mut self) {\n         unsafe { uvll::udp_recv_stop(self.native_handle()); }\n     }\n \n-    pub fn send(&self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n+    pub fn send(&mut self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n         {\n-            let mut this = *self;\n-            let data = this.get_watcher_data();\n+            let data = self.get_watcher_data();\n             assert!(data.udp_send_cb.is_none());\n             data.udp_send_cb = Some(cb);\n         }\n@@ -620,7 +618,7 @@ mod test {\n     fn udp_bind_close_ip4() {\n         do run_in_bare_thread() {\n             let mut loop_ = Loop::new();\n-            let udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n             let addr = next_test_ip4();\n             udp_watcher.bind(addr);\n             udp_watcher.close(||());\n@@ -633,7 +631,7 @@ mod test {\n     fn udp_bind_close_ip6() {\n         do run_in_bare_thread() {\n             let mut loop_ = Loop::new();\n-            let udp_watcher = { UdpWatcher::new(&mut loop_) };\n+            let mut udp_watcher = { UdpWatcher::new(&mut loop_) };\n             let addr = next_test_ip6();\n             udp_watcher.bind(addr);\n             udp_watcher.close(||());\n@@ -798,15 +796,15 @@ mod test {\n             let server_addr = next_test_ip4();\n             let client_addr = next_test_ip4();\n \n-            let server = UdpWatcher::new(&loop_);\n+            let mut server = UdpWatcher::new(&loop_);\n             assert!(server.bind(server_addr).is_ok());\n \n             rtdebug!(\"starting read\");\n             let alloc: AllocCallback = |size| {\n                 vec_to_uv_buf(vec::from_elem(size, 0u8))\n             };\n \n-            do server.recv_start(alloc) |server, nread, buf, src, flags, status| {\n+            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n                 server.recv_stop();\n                 rtdebug!(\"i'm reading!\");\n                 assert!(status.is_none());\n@@ -830,7 +828,7 @@ mod test {\n \n             do Thread::start {\n                 let mut loop_ = Loop::new();\n-                let client = UdpWatcher::new(&loop_);\n+                let mut client = UdpWatcher::new(&loop_);\n                 assert!(client.bind(client_addr).is_ok());\n                 let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n                 let buf = slice_to_uv_buf(msg);\n@@ -857,15 +855,15 @@ mod test {\n             let server_addr = next_test_ip6();\n             let client_addr = next_test_ip6();\n \n-            let server = UdpWatcher::new(&loop_);\n+            let mut server = UdpWatcher::new(&loop_);\n             assert!(server.bind(server_addr).is_ok());\n \n             rtdebug!(\"starting read\");\n             let alloc: AllocCallback = |size| {\n                 vec_to_uv_buf(vec::from_elem(size, 0u8))\n             };\n \n-            do server.recv_start(alloc) |server, nread, buf, src, flags, status| {\n+            do server.recv_start(alloc) |mut server, nread, buf, src, flags, status| {\n                 server.recv_stop();\n                 rtdebug!(\"i'm reading!\");\n                 assert!(status.is_none());\n@@ -889,7 +887,7 @@ mod test {\n \n             do Thread::start {\n                 let mut loop_ = Loop::new();\n-                let client = UdpWatcher::new(&loop_);\n+                let mut client = UdpWatcher::new(&loop_);\n                 assert!(client.bind(client_addr).is_ok());\n                 let msg = ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n                 let buf = slice_to_uv_buf(msg);"}, {"sha": "9b96c8717346d26186d80dd0719c4b6c413e4522", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5c0252511e74b74f646b04af126fafb9b18857c/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=c5c0252511e74b74f646b04af126fafb9b18857c", "patch": "@@ -264,7 +264,7 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError> {\n-        let /*mut*/ watcher = UdpWatcher::new(self.uv_loop());\n+        let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => Ok(~UvUdpSocket(watcher)),\n             Err(uverr) => {\n@@ -317,7 +317,7 @@ impl Drop for UvTcpListener {\n \n impl RtioSocket for UvTcpListener {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioTcpListener for UvTcpListener {\n@@ -357,8 +357,8 @@ impl RtioTcpListener for UvTcpListener {\n     }\n \n     // XXX implement\n-    fn accept_simultaneously(&self) { fail!(); }\n-    fn dont_accept_simultaneously(&self) { fail!(); }\n+    fn accept_simultaneously(&mut self) { fail!(); }\n+    fn dont_accept_simultaneously(&mut self) { fail!(); }\n }\n \n // FIXME #6090: Prefer newtype structs but Drop doesn't work\n@@ -380,11 +380,11 @@ impl Drop for UvTcpStream {\n \n impl RtioSocket for UvTcpStream {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioTcpStream for UvTcpStream {\n-    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n@@ -427,7 +427,7 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    fn write(&self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -456,11 +456,11 @@ impl RtioTcpStream for UvTcpStream {\n     }\n \n     // XXX implement\n-    fn peer_name(&self) -> IpAddr { fail!(); }\n-    fn control_congestion(&self) { fail!(); }\n-    fn nodelay(&self) { fail!(); }\n-    fn keepalive(&self, _delay_in_seconds: uint) { fail!(); }\n-    fn letdie(&self) { fail!(); }\n+    fn peer_name(&mut self) -> IpAddr { fail!(); }\n+    fn control_congestion(&mut self) { fail!(); }\n+    fn nodelay(&mut self) { fail!(); }\n+    fn keepalive(&mut self, _delay_in_seconds: uint) { fail!(); }\n+    fn letdie(&mut self) { fail!(); }\n }\n \n pub struct UvUdpSocket(UdpWatcher);\n@@ -481,11 +481,11 @@ impl Drop for UvUdpSocket {\n \n impl RtioSocket for UvUdpSocket {\n     // XXX implement\n-    fn socket_name(&self) -> IpAddr { fail!(); }\n+    fn socket_name(&mut self) -> IpAddr { fail!(); }\n }\n \n impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n+    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n \n@@ -497,7 +497,7 @@ impl RtioUdpSocket for UvUdpSocket {\n             assert!(!sched.in_task_context());\n             let task_cell = Cell::new(task);\n             let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.recv_start(alloc) |watcher, nread, _buf, addr, flags, status| {\n+            do self.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n                 let _ = flags; // XXX add handling for partials?\n \n                 watcher.recv_stop();\n@@ -521,7 +521,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         return result_cell.take();\n     }\n \n-    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n+    fn sendto(&mut self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -549,17 +549,17 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n \n     // XXX implement\n-    fn join_multicast(&self, _multi: IpAddr) { fail!(); }\n-    fn leave_multicast(&self, _multi: IpAddr) { fail!(); }\n+    fn join_multicast(&mut self, _multi: IpAddr) { fail!(); }\n+    fn leave_multicast(&mut self, _multi: IpAddr) { fail!(); }\n \n-    fn loop_multicast_locally(&self) { fail!(); }\n-    fn dont_loop_multicast_locally(&self) { fail!(); }\n+    fn loop_multicast_locally(&mut self) { fail!(); }\n+    fn dont_loop_multicast_locally(&mut self) { fail!(); }\n \n-    fn multicast_time_to_live(&self, _ttl: int) { fail!(); }\n-    fn time_to_live(&self, _ttl: int) { fail!(); }\n+    fn multicast_time_to_live(&mut self, _ttl: int) { fail!(); }\n+    fn time_to_live(&mut self, _ttl: int) { fail!(); }\n \n-    fn hear_broadcasts(&self) { fail!(); }\n-    fn ignore_broadcasts(&self) { fail!(); }\n+    fn hear_broadcasts(&mut self) { fail!(); }\n+    fn ignore_broadcasts(&mut self) { fail!(); }\n }\n \n #[test]\n@@ -596,7 +596,7 @@ fn test_simple_tcp_server_and_client() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let stream = listener.accept().unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -610,7 +610,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n@@ -626,7 +626,7 @@ fn test_simple_udp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server_socket = (*io).udp_bind(server_addr).unwrap();\n+                let mut server_socket = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let (nread,src) = server_socket.recvfrom(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -641,7 +641,7 @@ fn test_simple_udp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client_socket = (*io).udp_bind(client_addr).unwrap();\n+                let mut client_socket = (*io).udp_bind(client_addr).unwrap();\n                 client_socket.sendto([0, 1, 2, 3, 4, 5, 6, 7], server_addr);\n             }\n         }\n@@ -656,7 +656,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n-            let stream = listener.accept().unwrap();\n+            let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -689,7 +689,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -710,7 +710,7 @@ fn test_read_read_read() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let stream = listener.accept().unwrap();\n+                let mut stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n@@ -723,7 +723,7 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let stream = (*io).tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {\n@@ -749,7 +749,7 @@ fn test_udp_twice() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client = (*io).udp_bind(client_addr).unwrap();\n+                let mut client = (*io).udp_bind(client_addr).unwrap();\n                 assert!(client.sendto([1], server_addr).is_ok());\n                 assert!(client.sendto([2], server_addr).is_ok());\n             }\n@@ -758,7 +758,7 @@ fn test_udp_twice() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server = (*io).udp_bind(server_addr).unwrap();\n+                let mut server = (*io).udp_bind(server_addr).unwrap();\n                 let mut buf1 = [0];\n                 let mut buf2 = [0];\n                 let (nread1, src1) = server.recvfrom(buf1).unwrap();\n@@ -786,8 +786,8 @@ fn test_udp_many_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let server_out = (*io).udp_bind(server_out_addr).unwrap();\n-                let server_in = (*io).udp_bind(server_in_addr).unwrap();\n+                let mut server_out = (*io).udp_bind(server_out_addr).unwrap();\n+                let mut server_in = (*io).udp_bind(server_in_addr).unwrap();\n                 let msg = [1, .. 2048];\n                 let mut total_bytes_sent = 0;\n                 let mut buf = [1];\n@@ -809,8 +809,8 @@ fn test_udp_many_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let client_out = (*io).udp_bind(client_out_addr).unwrap();\n-                let client_in = (*io).udp_bind(client_in_addr).unwrap();\n+                let mut client_out = (*io).udp_bind(client_out_addr).unwrap();\n+                let mut client_in = (*io).udp_bind(client_in_addr).unwrap();\n                 let mut total_bytes_recv = 0;\n                 let mut buf = [0, .. 2048];\n                 while total_bytes_recv < MAX {"}]}