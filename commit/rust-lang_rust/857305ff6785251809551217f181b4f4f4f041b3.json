{"sha": "857305ff6785251809551217f181b4f4f4f041b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NzMwNWZmNjc4NTI1MTgwOTU1MTIxN2YxODFiNGY0ZjRmMDQxYjM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-29T12:04:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-29T12:04:50Z"}, "message": "Merge remote-tracking branch 'ralf/machine' into rustup", "tree": {"sha": "9ca569e6aebfa687ea8afff3d4a1845477220c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca569e6aebfa687ea8afff3d4a1845477220c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/857305ff6785251809551217f181b4f4f4f041b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/857305ff6785251809551217f181b4f4f4f041b3", "html_url": "https://github.com/rust-lang/rust/commit/857305ff6785251809551217f181b4f4f4f041b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/857305ff6785251809551217f181b4f4f4f041b3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "373a4ee1e99661dd9d708626b41d0ed0e9fbe254", "url": "https://api.github.com/repos/rust-lang/rust/commits/373a4ee1e99661dd9d708626b41d0ed0e9fbe254", "html_url": "https://github.com/rust-lang/rust/commit/373a4ee1e99661dd9d708626b41d0ed0e9fbe254"}, {"sha": "67d3779b0ce5a1f2e735e4497af5321a9000105a", "url": "https://api.github.com/repos/rust-lang/rust/commits/67d3779b0ce5a1f2e735e4497af5321a9000105a", "html_url": "https://github.com/rust-lang/rust/commit/67d3779b0ce5a1f2e735e4497af5321a9000105a"}], "stats": {"total": 1288, "additions": 651, "deletions": 637}, "files": [{"sha": "15bfeed4da06ccda3d0b11d799fd64ba65d9380e", "filename": "miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/miri", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/miri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -89,7 +89,7 @@ find_sysroot() {\n \n # Determine command.\n COMMAND=\"$1\"\n-shift\n+[ $# -gt 0 ] && shift\n \n # Determine flags passed to all cargo invocations.\n # This is a bit more annoying that one would hope due to"}, {"sha": "fd5404a981d2c192ded07b18321f7bfef5ee6019", "filename": "src/eval.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -0,0 +1,246 @@\n+use rand::rngs::StdRng;\n+use rand::SeedableRng;\n+\n+use syntax::source_map::DUMMY_SP;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::layout::{LayoutOf, Size, Align};\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+\n+use crate::{\n+    InterpResult, InterpError, InterpretCx, StackPopCleanup, struct_error,\n+    Scalar, Tag, Pointer,\n+    MemoryExtra, MiriMemoryKind, Evaluator, TlsEvalContextExt,\n+};\n+\n+/// Configuration needed to spawn a Miri instance.\n+#[derive(Clone)]\n+pub struct MiriConfig {\n+    pub validate: bool,\n+    pub args: Vec<String>,\n+\n+    // The seed to use when non-determinism is required (e.g. getrandom())\n+    pub seed: Option<u64>\n+}\n+\n+// Used by priroda.\n+pub fn create_ecx<'mir, 'tcx: 'mir>(\n+    tcx: TyCtxt<'tcx>,\n+    main_id: DefId,\n+    config: MiriConfig,\n+) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n+    let mut ecx = InterpretCx::new(\n+        tcx.at(syntax::source_map::DUMMY_SP),\n+        ty::ParamEnv::reveal_all(),\n+        Evaluator::new(config.validate),\n+        MemoryExtra::with_rng(config.seed.map(StdRng::seed_from_u64)),\n+    );\n+    \n+    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n+    let main_mir = ecx.load_mir(main_instance.def)?;\n+\n+    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n+        return err!(Unimplemented(\n+            \"miri does not support main functions without `fn()` type signatures\"\n+                .to_owned(),\n+        ));\n+    }\n+\n+    let start_id = tcx.lang_items().start_fn().unwrap();\n+    let main_ret_ty = tcx.fn_sig(main_id).output();\n+    let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n+    let start_instance = ty::Instance::resolve(\n+        ecx.tcx.tcx,\n+        ty::ParamEnv::reveal_all(),\n+        start_id,\n+        ecx.tcx.mk_substs(\n+            ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n+        ).unwrap();\n+    let start_mir = ecx.load_mir(start_instance.def)?;\n+\n+    if start_mir.arg_count != 3 {\n+        return err!(AbiViolation(format!(\n+            \"'start' lang item should have three arguments, but has {}\",\n+            start_mir.arg_count\n+        )));\n+    }\n+\n+    // Return value (in static memory so that it does not count as leak).\n+    let ret = ecx.layout_of(start_mir.return_ty())?;\n+    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n+\n+    // Push our stack frame.\n+    ecx.push_stack_frame(\n+        start_instance,\n+        // There is no call site.\n+        DUMMY_SP,\n+        start_mir,\n+        Some(ret_ptr.into()),\n+        StackPopCleanup::None { cleanup: true },\n+    )?;\n+\n+    let mut args = ecx.frame().body.args_iter();\n+\n+    // First argument: pointer to `main()`.\n+    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n+\n+    // Second argument (argc): `1`.\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n+    ecx.write_scalar(argc, dest)?;\n+    // Store argc for macOS's `_NSGetArgc`.\n+    {\n+        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n+        ecx.write_scalar(argc, argc_place.into())?;\n+        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n+    }\n+\n+    // FIXME: extract main source file path.\n+    // Third argument (`argv`): created from `config.args`.\n+    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+    // For Windows, construct a command string with all the aguments.\n+    let mut cmd = String::new();\n+    for arg in config.args.iter() {\n+        if !cmd.is_empty() {\n+            cmd.push(' ');\n+        }\n+        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n+    }\n+    // Don't forget `0` terminator.\n+    cmd.push(std::char::from_u32(0).unwrap());\n+    // Collect the pointers to the individual strings.\n+    let mut argvs = Vec::<Pointer<Tag>>::new();\n+    for arg in config.args {\n+        // Add `0` terminator.\n+        let mut arg = arg.into_bytes();\n+        arg.push(0);\n+        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n+    }\n+    // Make an array with all these pointers, in the Miri memory.\n+    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n+    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n+    for (idx, arg) in argvs.into_iter().enumerate() {\n+        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n+        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n+    }\n+    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n+    // Write a pointer to that place as the argument.\n+    let argv = argvs_place.ptr;\n+    ecx.write_scalar(argv, dest)?;\n+    // Store `argv` for macOS `_NSGetArgv`.\n+    {\n+        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n+        ecx.write_scalar(argv, argv_place.into())?;\n+        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n+    }\n+    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n+    {\n+        let tcx = &{ecx.tcx.tcx};\n+        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n+        let cmd_ptr = ecx.memory_mut().allocate(\n+            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n+            Align::from_bytes(2).unwrap(),\n+            MiriMemoryKind::Env.into(),\n+        );\n+        ecx.machine.cmd_line = Some(cmd_ptr);\n+        // Store the UTF-16 string.\n+        let char_size = Size::from_bytes(2);\n+        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n+        let mut cur_ptr = cmd_ptr;\n+        for &c in cmd_utf16.iter() {\n+            cmd_alloc.write_scalar(\n+                tcx,\n+                cur_ptr,\n+                Scalar::from_uint(c, char_size).into(),\n+                char_size,\n+            )?;\n+            cur_ptr = cur_ptr.offset(char_size, tcx)?;\n+        }\n+    }\n+ \n+    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n+\n+    Ok(ecx)\n+}\n+\n+pub fn eval_main<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    main_id: DefId,\n+    config: MiriConfig,\n+) {\n+    let mut ecx = match create_ecx(tcx, main_id, config) {\n+        Ok(ecx) => ecx,\n+        Err(mut err) => {\n+            err.print_backtrace();\n+            panic!(\"Miri initialziation error: {}\", err.kind)\n+        }\n+    };\n+\n+    // Perform the main execution.\n+    let res: InterpResult = (|| {\n+        ecx.run()?;\n+        ecx.run_tls_dtors()\n+    })();\n+\n+    // Process the result.\n+    match res {\n+        Ok(()) => {\n+            let leaks = ecx.memory().leak_report();\n+            // Disable the leak test on some platforms where we do not\n+            // correctly implement TLS destructors.\n+            let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n+            let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n+            if !ignore_leaks && leaks != 0 {\n+                tcx.sess.err(\"the evaluated program leaked memory\");\n+            }\n+        }\n+        Err(mut e) => {\n+            // Special treatment for some error kinds\n+            let msg = match e.kind {\n+                InterpError::Exit(code) => std::process::exit(code),\n+                InterpError::NoMirFor(..) =>\n+                    format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n+                _ => e.to_string()\n+            };\n+            e.print_backtrace();\n+            if let Some(frame) = ecx.stack().last() {\n+                let block = &frame.body.basic_blocks()[frame.block];\n+                let span = if frame.stmt < block.statements.len() {\n+                    block.statements[frame.stmt].source_info.span\n+                } else {\n+                    block.terminator().source_info.span\n+                };\n+\n+                let msg = format!(\"Miri evaluation error: {}\", msg);\n+                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n+                let frames = ecx.generate_stacktrace(None);\n+                err.span_label(span, msg);\n+                // We iterate with indices because we need to look at the next frame (the caller).\n+                for idx in 0..frames.len() {\n+                    let frame_info = &frames[idx];\n+                    let call_site_is_local = frames.get(idx+1).map_or(false,\n+                        |caller_info| caller_info.instance.def_id().is_local());\n+                    if call_site_is_local {\n+                        err.span_note(frame_info.call_site, &frame_info.to_string());\n+                    } else {\n+                        err.note(&frame_info.to_string());\n+                    }\n+                }\n+                err.emit();\n+            } else {\n+                ecx.tcx.sess.err(&msg);\n+            }\n+\n+            for (i, frame) in ecx.stack().iter().enumerate() {\n+                trace!(\"-------------------\");\n+                trace!(\"Frame {}\", i);\n+                trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n+                for (i, local) in frame.locals.iter().enumerate() {\n+                    trace!(\"    local {}: {:?}\", i, local.value);\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "f65eef557c967260fafc1c0b7dc6d6ca0425a7e8", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc::ty::{self, layout};\n+use rustc::ty::{self, layout::{self, Size}};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n \n use crate::*;"}, {"sha": "176e1bc591c2e6b3259853818c1ec881f38ccdd9", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -89,6 +89,7 @@ impl<'mir, 'tcx> GlobalState {\n             }\n         };\n \n+        debug_assert_eq!(base_addr % alloc.align.bytes(), 0); // sanity check\n         Ok(base_addr + ptr.offset.bytes())\n     }\n "}, {"sha": "ab9e9854c34cbd84ea27ccd14ebce84f47945557", "filename": "src/lib.rs", "status": "modified", "additions": 8, "deletions": 568, "changes": 576, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -21,39 +21,24 @@ mod range_map;\n mod mono_hash_map;\n mod stacked_borrows;\n mod intptrcast;\n-mod memory;\n+mod machine;\n+mod eval;\n \n-use std::collections::HashMap;\n-use std::borrow::Cow;\n-use std::rc::Rc;\n-\n-use rand::rngs::StdRng;\n-use rand::SeedableRng;\n-\n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{LayoutOf, Size, Align};\n-use rustc::hir::def_id::DefId;\n-use rustc::mir;\n+// Make all those symbols available in the same place as our own.\n pub use rustc_mir::interpret::*;\n // Resolve ambiguity.\n pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n-use syntax::attr;\n-use syntax::source_map::DUMMY_SP;\n-use syntax::symbol::sym;\n \n pub use crate::fn_call::EvalContextExt as MissingFnsEvalContextExt;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::intrinsic::EvalContextExt as IntrinsicEvalContextExt;\n pub use crate::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n-use crate::range_map::RangeMap;\n-#[allow(unused_imports)] // FIXME: rustc bug, issue <https://github.com/rust-lang/rust/issues/53682>.\n+pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n-use crate::mono_hash_map::MonoHashMap;\n-pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n-use crate::memory::{MemoryExtra, AllocExtra};\n-\n-// Used by priroda.\n-pub use crate::stacked_borrows::{Tag, Permission, Stack, Stacks, Item};\n+pub use crate::mono_hash_map::MonoHashMap;\n+pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Tag, Permission, Stack, Stacks, Item};\n+pub use crate::machine::{MemoryExtra, AllocExtra, MiriMemoryKind, Evaluator, MiriEvalContext, MiriEvalContextExt};\n+pub use crate::eval::{eval_main, create_ecx, MiriConfig};\n \n /// Insert rustc arguments at the beginning of the argument list that Miri wants to be\n /// set per default, for maximal validation power.\n@@ -62,548 +47,3 @@ pub fn miri_default_args() -> &'static [&'static str] {\n     // set, which happens in `bootstrap/bin/rustc.rs` in the rustc sources.\n     &[\"-Zalways-encode-mir\", \"-Zmir-emit-retag\", \"-Zmir-opt-level=0\", \"--cfg=miri\"]\n }\n-\n-/// Configuration needed to spawn a Miri instance.\n-#[derive(Clone)]\n-pub struct MiriConfig {\n-    pub validate: bool,\n-    pub args: Vec<String>,\n-\n-    // The seed to use when non-determinism is required (e.g. getrandom())\n-    pub seed: Option<u64>\n-}\n-\n-// Used by priroda.\n-pub fn create_ecx<'mir, 'tcx: 'mir>(\n-    tcx: TyCtxt<'tcx>,\n-    main_id: DefId,\n-    config: MiriConfig,\n-) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n-    let mut ecx = InterpretCx::new(\n-        tcx.at(syntax::source_map::DUMMY_SP),\n-        ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n-        MemoryExtra::with_rng(config.seed.map(StdRng::seed_from_u64)),\n-    );\n-    \n-    let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n-    let main_mir = ecx.load_mir(main_instance.def)?;\n-\n-    if !main_mir.return_ty().is_unit() || main_mir.arg_count != 0 {\n-        return err!(Unimplemented(\n-            \"miri does not support main functions without `fn()` type signatures\"\n-                .to_owned(),\n-        ));\n-    }\n-\n-    let start_id = tcx.lang_items().start_fn().unwrap();\n-    let main_ret_ty = tcx.fn_sig(main_id).output();\n-    let main_ret_ty = main_ret_ty.no_bound_vars().unwrap();\n-    let start_instance = ty::Instance::resolve(\n-        ecx.tcx.tcx,\n-        ty::ParamEnv::reveal_all(),\n-        start_id,\n-        ecx.tcx.mk_substs(\n-            ::std::iter::once(ty::subst::Kind::from(main_ret_ty)))\n-        ).unwrap();\n-    let start_mir = ecx.load_mir(start_instance.def)?;\n-\n-    if start_mir.arg_count != 3 {\n-        return err!(AbiViolation(format!(\n-            \"'start' lang item should have three arguments, but has {}\",\n-            start_mir.arg_count\n-        )));\n-    }\n-\n-    // Return value (in static memory so that it does not count as leak).\n-    let ret = ecx.layout_of(start_mir.return_ty())?;\n-    let ret_ptr = ecx.allocate(ret, MiriMemoryKind::Static.into());\n-\n-    // Push our stack frame.\n-    ecx.push_stack_frame(\n-        start_instance,\n-        // There is no call site.\n-        DUMMY_SP,\n-        start_mir,\n-        Some(ret_ptr.into()),\n-        StackPopCleanup::None { cleanup: true },\n-    )?;\n-\n-    let mut args = ecx.frame().body.args_iter();\n-\n-    // First argument: pointer to `main()`.\n-    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n-\n-    // Second argument (argc): `1`.\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    let argc = Scalar::from_uint(config.args.len() as u128, dest.layout.size);\n-    ecx.write_scalar(argc, dest)?;\n-    // Store argc for macOS's `_NSGetArgc`.\n-    {\n-        let argc_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argc, argc_place.into())?;\n-        ecx.machine.argc = Some(argc_place.ptr.to_ptr()?);\n-    }\n-\n-    // FIXME: extract main source file path.\n-    // Third argument (`argv`): created from `config.args`.\n-    let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-    // For Windows, construct a command string with all the aguments.\n-    let mut cmd = String::new();\n-    for arg in config.args.iter() {\n-        if !cmd.is_empty() {\n-            cmd.push(' ');\n-        }\n-        cmd.push_str(&*shell_escape::windows::escape(arg.as_str().into()));\n-    }\n-    // Don't forget `0` terminator.\n-    cmd.push(std::char::from_u32(0).unwrap());\n-    // Collect the pointers to the individual strings.\n-    let mut argvs = Vec::<Pointer<Tag>>::new();\n-    for arg in config.args {\n-        // Add `0` terminator.\n-        let mut arg = arg.into_bytes();\n-        arg.push(0);\n-        argvs.push(ecx.memory_mut().allocate_static_bytes(arg.as_slice(), MiriMemoryKind::Static.into()));\n-    }\n-    // Make an array with all these pointers, in the Miri memory.\n-    let argvs_layout = ecx.layout_of(ecx.tcx.mk_array(ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8), argvs.len() as u64))?;\n-    let argvs_place = ecx.allocate(argvs_layout, MiriMemoryKind::Env.into());\n-    for (idx, arg) in argvs.into_iter().enumerate() {\n-        let place = ecx.mplace_field(argvs_place, idx as u64)?;\n-        ecx.write_scalar(Scalar::Ptr(arg), place.into())?;\n-    }\n-    ecx.memory_mut().mark_immutable(argvs_place.to_ptr()?.alloc_id)?;\n-    // Write a pointer to that place as the argument.\n-    let argv = argvs_place.ptr;\n-    ecx.write_scalar(argv, dest)?;\n-    // Store `argv` for macOS `_NSGetArgv`.\n-    {\n-        let argv_place = ecx.allocate(dest.layout, MiriMemoryKind::Env.into());\n-        ecx.write_scalar(argv, argv_place.into())?;\n-        ecx.machine.argv = Some(argv_place.ptr.to_ptr()?);\n-    }\n-    // Store command line as UTF-16 for Windows `GetCommandLineW`.\n-    {\n-        let tcx = &{ecx.tcx.tcx};\n-        let cmd_utf16: Vec<u16> = cmd.encode_utf16().collect();\n-        let cmd_ptr = ecx.memory_mut().allocate(\n-            Size::from_bytes(cmd_utf16.len() as u64 * 2),\n-            Align::from_bytes(2).unwrap(),\n-            MiriMemoryKind::Env.into(),\n-        );\n-        ecx.machine.cmd_line = Some(cmd_ptr);\n-        // Store the UTF-16 string.\n-        let char_size = Size::from_bytes(2);\n-        let cmd_alloc = ecx.memory_mut().get_mut(cmd_ptr.alloc_id)?;\n-        let mut cur_ptr = cmd_ptr;\n-        for &c in cmd_utf16.iter() {\n-            cmd_alloc.write_scalar(\n-                tcx,\n-                cur_ptr,\n-                Scalar::from_uint(c, char_size).into(),\n-                char_size,\n-            )?;\n-            cur_ptr = cur_ptr.offset(char_size, tcx)?;\n-        }\n-    }\n- \n-    assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n-\n-    Ok(ecx)\n-}\n-\n-pub fn eval_main<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    main_id: DefId,\n-    config: MiriConfig,\n-) {\n-    let mut ecx = match create_ecx(tcx, main_id, config) {\n-        Ok(ecx) => ecx,\n-        Err(mut err) => {\n-            err.print_backtrace();\n-            panic!(\"Miri initialziation error: {}\", err.kind)\n-        }\n-    };\n-\n-    // Perform the main execution.\n-    let res: InterpResult = (|| {\n-        ecx.run()?;\n-        ecx.run_tls_dtors()\n-    })();\n-\n-    // Process the result.\n-    match res {\n-        Ok(()) => {\n-            let leaks = ecx.memory().leak_report();\n-            // Disable the leak test on some platforms where we do not\n-            // correctly implement TLS destructors.\n-            let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n-            let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n-            if !ignore_leaks && leaks != 0 {\n-                tcx.sess.err(\"the evaluated program leaked memory\");\n-            }\n-        }\n-        Err(mut e) => {\n-            // Special treatment for some error kinds\n-            let msg = match e.kind {\n-                InterpError::Exit(code) => std::process::exit(code),\n-                InterpError::NoMirFor(..) =>\n-                    format!(\"{}. Did you set `MIRI_SYSROOT` to a Miri-enabled sysroot? You can prepare one with `cargo miri setup`.\", e),\n-                _ => e.to_string()\n-            };\n-            e.print_backtrace();\n-            if let Some(frame) = ecx.stack().last() {\n-                let block = &frame.body.basic_blocks()[frame.block];\n-                let span = if frame.stmt < block.statements.len() {\n-                    block.statements[frame.stmt].source_info.span\n-                } else {\n-                    block.terminator().source_info.span\n-                };\n-\n-                let msg = format!(\"Miri evaluation error: {}\", msg);\n-                let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n-                let frames = ecx.generate_stacktrace(None);\n-                err.span_label(span, msg);\n-                // We iterate with indices because we need to look at the next frame (the caller).\n-                for idx in 0..frames.len() {\n-                    let frame_info = &frames[idx];\n-                    let call_site_is_local = frames.get(idx+1).map_or(false,\n-                        |caller_info| caller_info.instance.def_id().is_local());\n-                    if call_site_is_local {\n-                        err.span_note(frame_info.call_site, &frame_info.to_string());\n-                    } else {\n-                        err.note(&frame_info.to_string());\n-                    }\n-                }\n-                err.emit();\n-            } else {\n-                ecx.tcx.sess.err(&msg);\n-            }\n-\n-            for (i, frame) in ecx.stack().iter().enumerate() {\n-                trace!(\"-------------------\");\n-                trace!(\"Frame {}\", i);\n-                trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));\n-                for (i, local) in frame.locals.iter().enumerate() {\n-                    trace!(\"    local {}: {:?}\", i, local.value);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum MiriMemoryKind {\n-    /// `__rust_alloc` memory.\n-    Rust,\n-    /// `malloc` memory.\n-    C,\n-    /// Part of env var emulation.\n-    Env,\n-    /// Statics.\n-    Static,\n-}\n-\n-impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n-    #[inline(always)]\n-    fn into(self) -> MemoryKind<MiriMemoryKind> {\n-        MemoryKind::Machine(self)\n-    }\n-}\n-\n-impl MayLeak for MiriMemoryKind {\n-    #[inline(always)]\n-    fn may_leak(self) -> bool {\n-        use self::MiriMemoryKind::*;\n-        match self {\n-            Rust | C => false,\n-            Env | Static => true,\n-        }\n-    }\n-}\n-\n-pub struct Evaluator<'tcx> {\n-    /// Environment variables set by `setenv`.\n-    /// Miri does not expose env vars from the host to the emulated program.\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Tag>>,\n-\n-    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n-    /// These are *pointers* to argc/argv because macOS.\n-    /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<Pointer<Tag>>,\n-    pub(crate) argv: Option<Pointer<Tag>>,\n-    pub(crate) cmd_line: Option<Pointer<Tag>>,\n-\n-    /// Last OS error.\n-    pub(crate) last_error: u32,\n-\n-    /// TLS state.\n-    pub(crate) tls: TlsData<'tcx>,\n-\n-    /// Whether to enforce the validity invariant.\n-    pub(crate) validate: bool,\n-}\n-\n-impl<'tcx> Evaluator<'tcx> {\n-    fn new(validate: bool) -> Self {\n-        Evaluator {\n-            env_vars: HashMap::default(),\n-            argc: None,\n-            argv: None,\n-            cmd_line: None,\n-            last_error: 0,\n-            tls: TlsData::default(),\n-            validate,\n-        }\n-    }\n-}\n-\n-// FIXME: rustc issue <https://github.com/rust-lang/rust/issues/47131>.\n-#[allow(dead_code)]\n-type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n-\n-// A little trait that's useful to be inherited by extension traits.\n-pub trait MiriEvalContextExt<'mir, 'tcx> {\n-    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx>;\n-    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx>;\n-}\n-impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {\n-    #[inline(always)]\n-    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx> {\n-        self\n-    }\n-    #[inline(always)]\n-    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n-    type MemoryKinds = MiriMemoryKind;\n-\n-    type FrameExtra = stacked_borrows::CallId;\n-    type MemoryExtra = memory::MemoryExtra;\n-    type AllocExtra = memory::AllocExtra;\n-    type PointerTag = Tag;\n-\n-    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n-\n-    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n-\n-    #[inline(always)]\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.machine.validate\n-    }\n-\n-    /// Returns `Ok()` when the function was handled; fail otherwise.\n-    #[inline(always)]\n-    fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: Option<PlaceTy<'tcx, Tag>>,\n-        ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        ecx.find_fn(instance, args, dest, ret)\n-    }\n-\n-    #[inline(always)]\n-    fn call_intrinsic(\n-        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        ecx.call_intrinsic(instance, args, dest)\n-    }\n-\n-    #[inline(always)]\n-    fn ptr_op(\n-        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n-        bin_op: mir::BinOp,\n-        left: ImmTy<'tcx, Tag>,\n-        right: ImmTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n-        ecx.ptr_op(bin_op, left, right)\n-    }\n-\n-    fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        dest: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\"box_alloc for {:?}\", dest.layout.ty);\n-        // Call the `exchange_malloc` lang item.\n-        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n-        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n-        let malloc_mir = ecx.load_mir(malloc.def)?;\n-        ecx.push_stack_frame(\n-            malloc,\n-            malloc_mir.span,\n-            malloc_mir,\n-            Some(dest),\n-            // Don't do anything when we are done. The `statement()` function will increment\n-            // the old stack frame's stmt counter to the next statement, which means that when\n-            // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n-            StackPopCleanup::None { cleanup: true },\n-        )?;\n-\n-        let mut args = ecx.frame().body.args_iter();\n-        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n-\n-        // First argument: `size`.\n-        // (`0` is allowed here -- this is expected to be handled by the lang item).\n-        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-        let size = layout.size.bytes();\n-        ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n-\n-        // Second argument: `align`.\n-        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n-        let align = layout.align.abi.bytes();\n-        ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n-\n-        // No more arguments.\n-        assert!(\n-            args.next().is_none(),\n-            \"`exchange_malloc` lang item has more arguments than expected\"\n-        );\n-        Ok(())\n-    }\n-\n-    fn find_foreign_static(\n-        def_id: DefId,\n-        tcx: TyCtxtAt<'tcx>,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n-        let attrs = tcx.get_attrs(def_id);\n-        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n-            Some(name) => name.as_str(),\n-            None => tcx.item_name(def_id).as_str(),\n-        };\n-\n-        let alloc = match link_name.get() {\n-            \"__cxa_thread_atexit_impl\" => {\n-                // This should be all-zero, pointer-sized.\n-                let size = tcx.data_layout.pointer_size;\n-                let data = vec![0; size.bytes() as usize];\n-                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n-            }\n-            _ => return err!(Unimplemented(\n-                    format!(\"can't access foreign static: {}\", link_name),\n-                )),\n-        };\n-        Ok(Cow::Owned(alloc))\n-    }\n-\n-    #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n-    {\n-        // We are not interested in detecting loops.\n-        Ok(())\n-    }\n-\n-    fn tag_allocation<'b>(\n-        id: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        kind: Option<MemoryKind<Self::MemoryKinds>>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n-        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n-        let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = Stacks::new_allocation(\n-            id,\n-            Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked_borrows),\n-            kind,\n-        );\n-        if kind != MiriMemoryKind::Static.into() {\n-            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n-            // Now we can rely on the inner pointers being static, too.\n-        }\n-        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n-        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n-            bytes: alloc.bytes,\n-            relocations: Relocations::from_presorted(\n-                alloc.relocations.iter()\n-                    // The allocations in the relocations (pointers stored *inside* this allocation)\n-                    // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n-                    .collect()\n-            ),\n-            undef_mask: alloc.undef_mask,\n-            align: alloc.align,\n-            mutability: alloc.mutability,\n-            extra: AllocExtra {\n-                stacked_borrows: stacks,\n-                intptrcast: Default::default(),\n-            },\n-        };\n-        (Cow::Owned(alloc), base_tag)\n-    }\n-\n-    #[inline(always)]\n-    fn tag_static_base_pointer(\n-        id: AllocId,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> Self::PointerTag {\n-        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n-    }\n-\n-    #[inline(always)]\n-    fn retag(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        kind: mir::RetagKind,\n-        place: PlaceTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n-            // uninitialized data.\n-             Ok(())\n-        } else {\n-            ecx.retag(kind, place)\n-        }\n-    }\n-\n-    #[inline(always)]\n-    fn stack_push(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n-    }\n-\n-    #[inline(always)]\n-    fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n-        extra: stacked_borrows::CallId,\n-    ) -> InterpResult<'tcx> {\n-        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n-    }\n-\n-    fn int_to_ptr(\n-        int: u64,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n-        } else if memory.extra.rng.is_none() {\n-            err!(ReadBytesAsPointer)\n-        } else {\n-           intptrcast::GlobalState::int_to_ptr(int, memory)\n-        }\n-    }\n- \n-    fn ptr_to_int(\n-        ptr: Pointer<Self::PointerTag>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, u64> {\n-        if memory.extra.rng.is_none() {\n-            err!(ReadPointerAsBytes)\n-        } else {\n-            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n-        }\n-    }\n-}"}, {"sha": "8ef5410f395f4383f4c1ded6653f38f01b78e306", "filename": "src/machine.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -0,0 +1,384 @@\n+use std::rc::Rc;\n+use std::borrow::Cow;\n+use std::collections::HashMap;\n+\n+use rand::rngs::StdRng;\n+\n+use syntax::attr;\n+use syntax::symbol::sym;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, layout::{Size, LayoutOf}, query::TyCtxtAt};\n+use rustc::mir;\n+\n+use crate::*;\n+\n+/// Extra memory kinds\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum MiriMemoryKind {\n+    /// `__rust_alloc` memory.\n+    Rust,\n+    /// `malloc` memory.\n+    C,\n+    /// Part of env var emulation.\n+    Env,\n+    /// Statics.\n+    Static,\n+}\n+\n+impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n+    #[inline(always)]\n+    fn into(self) -> MemoryKind<MiriMemoryKind> {\n+        MemoryKind::Machine(self)\n+    }\n+}\n+\n+/// Extra per-allocation data\n+#[derive(Debug, Clone)]\n+pub struct AllocExtra {\n+    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    pub intptrcast: intptrcast::AllocExtra,\n+}\n+\n+/// Extra global memory data\n+#[derive(Clone, Debug)]\n+pub struct MemoryExtra {\n+    pub stacked_borrows: stacked_borrows::MemoryExtra,\n+    pub intptrcast: intptrcast::MemoryExtra,\n+    /// The random number generator to use if Miri is running in non-deterministic mode and to\n+    /// enable intptrcast\n+    pub(crate) rng: Option<StdRng>\n+}\n+\n+impl MemoryExtra {\n+    pub fn with_rng(rng: Option<StdRng>) -> Self {\n+        MemoryExtra {\n+            stacked_borrows: Default::default(),\n+            intptrcast: Default::default(),\n+            rng,\n+        }\n+    }\n+}\n+\n+/// The machine itself.\n+pub struct Evaluator<'tcx> {\n+    /// Environment variables set by `setenv`.\n+    /// Miri does not expose env vars from the host to the emulated program.\n+    pub(crate) env_vars: HashMap<Vec<u8>, Pointer<Tag>>,\n+\n+    /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n+    /// These are *pointers* to argc/argv because macOS.\n+    /// We also need the full command line as one string because of Windows.\n+    pub(crate) argc: Option<Pointer<Tag>>,\n+    pub(crate) argv: Option<Pointer<Tag>>,\n+    pub(crate) cmd_line: Option<Pointer<Tag>>,\n+\n+    /// Last OS error.\n+    pub(crate) last_error: u32,\n+\n+    /// TLS state.\n+    pub(crate) tls: TlsData<'tcx>,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n+}\n+\n+impl<'tcx> Evaluator<'tcx> {\n+    pub(crate) fn new(validate: bool) -> Self {\n+        Evaluator {\n+            env_vars: HashMap::default(),\n+            argc: None,\n+            argv: None,\n+            cmd_line: None,\n+            last_error: 0,\n+            tls: TlsData::default(),\n+            validate,\n+        }\n+    }\n+}\n+\n+/// A rustc InterpretCx for Miri.\n+pub type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n+\n+/// A little trait that's useful to be inherited by extension traits.\n+pub trait MiriEvalContextExt<'mir, 'tcx> {\n+    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx>;\n+    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx>;\n+}\n+impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {\n+    #[inline(always)]\n+    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx> {\n+        self\n+    }\n+    #[inline(always)]\n+    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n+        self\n+    }\n+}\n+\n+/// Machine hook implementations.\n+impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n+    type MemoryKinds = MiriMemoryKind;\n+\n+    type FrameExtra = stacked_borrows::CallId;\n+    type MemoryExtra = MemoryExtra;\n+    type AllocExtra = AllocExtra;\n+    type PointerTag = Tag;\n+\n+    type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n+\n+    const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n+\n+    #[inline(always)]\n+    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n+        ecx.machine.validate\n+    }\n+\n+    /// Returns `Ok()` when the function was handled; fail otherwise.\n+    #[inline(always)]\n+    fn find_fn(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        ecx.find_fn(instance, args, dest, ret)\n+    }\n+\n+    #[inline(always)]\n+    fn call_intrinsic(\n+        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        ecx.call_intrinsic(instance, args, dest)\n+    }\n+\n+    #[inline(always)]\n+    fn ptr_op(\n+        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        bin_op: mir::BinOp,\n+        left: ImmTy<'tcx, Tag>,\n+        right: ImmTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n+        ecx.ptr_op(bin_op, left, right)\n+    }\n+\n+    fn box_alloc(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        dest: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\"box_alloc for {:?}\", dest.layout.ty);\n+        // Call the `exchange_malloc` lang item.\n+        let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n+        let malloc = ty::Instance::mono(ecx.tcx.tcx, malloc);\n+        let malloc_mir = ecx.load_mir(malloc.def)?;\n+        ecx.push_stack_frame(\n+            malloc,\n+            malloc_mir.span,\n+            malloc_mir,\n+            Some(dest),\n+            // Don't do anything when we are done. The `statement()` function will increment\n+            // the old stack frame's stmt counter to the next statement, which means that when\n+            // `exchange_malloc` returns, we go on evaluating exactly where we want to be.\n+            StackPopCleanup::None { cleanup: true },\n+        )?;\n+\n+        let mut args = ecx.frame().body.args_iter();\n+        let layout = ecx.layout_of(dest.layout.ty.builtin_deref(false).unwrap().ty)?;\n+\n+        // First argument: `size`.\n+        // (`0` is allowed here -- this is expected to be handled by the lang item).\n+        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+        let size = layout.size.bytes();\n+        ecx.write_scalar(Scalar::from_uint(size, arg.layout.size), arg)?;\n+\n+        // Second argument: `align`.\n+        let arg = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n+        let align = layout.align.abi.bytes();\n+        ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n+\n+        // No more arguments.\n+        assert!(\n+            args.next().is_none(),\n+            \"`exchange_malloc` lang item has more arguments than expected\"\n+        );\n+        Ok(())\n+    }\n+\n+    fn find_foreign_static(\n+        def_id: DefId,\n+        tcx: TyCtxtAt<'tcx>,\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n+        let attrs = tcx.get_attrs(def_id);\n+        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n+            Some(name) => name.as_str(),\n+            None => tcx.item_name(def_id).as_str(),\n+        };\n+\n+        let alloc = match link_name.get() {\n+            \"__cxa_thread_atexit_impl\" => {\n+                // This should be all-zero, pointer-sized.\n+                let size = tcx.data_layout.pointer_size;\n+                let data = vec![0; size.bytes() as usize];\n+                Allocation::from_bytes(&data, tcx.data_layout.pointer_align.abi)\n+            }\n+            _ => return err!(Unimplemented(\n+                    format!(\"can't access foreign static: {}\", link_name),\n+                )),\n+        };\n+        Ok(Cow::Owned(alloc))\n+    }\n+\n+    #[inline(always)]\n+    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n+    {\n+        // We are not interested in detecting loops.\n+        Ok(())\n+    }\n+\n+    fn tag_allocation<'b>(\n+        id: AllocId,\n+        alloc: Cow<'b, Allocation>,\n+        kind: Option<MemoryKind<Self::MemoryKinds>>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n+        let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n+        let alloc = alloc.into_owned();\n+        let (stacks, base_tag) = Stacks::new_allocation(\n+            id,\n+            Size::from_bytes(alloc.bytes.len() as u64),\n+            Rc::clone(&memory.extra.stacked_borrows),\n+            kind,\n+        );\n+        if kind != MiriMemoryKind::Static.into() {\n+            assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n+            // Now we can rely on the inner pointers being static, too.\n+        }\n+        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n+        let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n+            bytes: alloc.bytes,\n+            relocations: Relocations::from_presorted(\n+                alloc.relocations.iter()\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n+                    .collect()\n+            ),\n+            undef_mask: alloc.undef_mask,\n+            align: alloc.align,\n+            mutability: alloc.mutability,\n+            extra: AllocExtra {\n+                stacked_borrows: stacks,\n+                intptrcast: Default::default(),\n+            },\n+        };\n+        (Cow::Owned(alloc), base_tag)\n+    }\n+\n+    #[inline(always)]\n+    fn tag_static_base_pointer(\n+        id: AllocId,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> Self::PointerTag {\n+        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+    }\n+\n+    #[inline(always)]\n+    fn retag(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        kind: mir::RetagKind,\n+        place: PlaceTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx> {\n+        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n+            // No tracking, or no retagging. The latter is possible because a dependency of ours\n+            // might be called with different flags than we are, so there are `Retag`\n+            // statements but we do not want to execute them.\n+            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n+            // uninitialized data.\n+             Ok(())\n+        } else {\n+            ecx.retag(kind, place)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn stack_push(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n+    }\n+\n+    #[inline(always)]\n+    fn stack_pop(\n+        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        extra: stacked_borrows::CallId,\n+    ) -> InterpResult<'tcx> {\n+        Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n+    }\n+\n+    fn int_to_ptr(\n+        int: u64,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n+        if int == 0 {\n+            err!(InvalidNullPointerUsage)\n+        } else if memory.extra.rng.is_none() {\n+            err!(ReadBytesAsPointer)\n+        } else {\n+           intptrcast::GlobalState::int_to_ptr(int, memory)\n+        }\n+    }\n+\n+    fn ptr_to_int(\n+        ptr: Pointer<Self::PointerTag>,\n+        memory: &Memory<'mir, 'tcx, Self>,\n+    ) -> InterpResult<'tcx, u64> {\n+        if memory.extra.rng.is_none() {\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n+        }\n+    }\n+}\n+\n+impl AllocationExtra<Tag> for AllocExtra {\n+    #[inline(always)]\n+    fn memory_read<'tcx>(\n+        alloc: &Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_written<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+    }\n+\n+    #[inline(always)]\n+    fn memory_deallocated<'tcx>(\n+        alloc: &mut Allocation<Tag, AllocExtra>,\n+        ptr: Pointer<Tag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+    }\n+}\n+\n+impl MayLeak for MiriMemoryKind {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        use self::MiriMemoryKind::*;\n+        match self {\n+            Rust | C => false,\n+            Env | Static => true,\n+        }\n+    }\n+}"}, {"sha": "e1ccafaae2821da8e40e5b57ef4b156b511a9791", "filename": "src/memory.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/373a4ee1e99661dd9d708626b41d0ed0e9fbe254/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/373a4ee1e99661dd9d708626b41d0ed0e9fbe254/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=373a4ee1e99661dd9d708626b41d0ed0e9fbe254", "patch": "@@ -1,61 +0,0 @@\n-use rand::rngs::StdRng;\n-\n-use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n-use rustc_target::abi::Size;\n-\n-use crate::{stacked_borrows, intptrcast};\n-use crate::stacked_borrows::Tag;\n-\n-#[derive(Clone, Debug)]\n-pub struct MemoryExtra {\n-    pub stacked_borrows: stacked_borrows::MemoryExtra,\n-    pub intptrcast: intptrcast::MemoryExtra,\n-    /// The random number generator to use if Miri is running in non-deterministic mode and to\n-    /// enable intptrcast\n-    pub(crate) rng: Option<StdRng>\n-}\n-\n-impl MemoryExtra {\n-    pub fn with_rng(rng: Option<StdRng>) -> Self {\n-        MemoryExtra {\n-            stacked_borrows: Default::default(),\n-            intptrcast: Default::default(),\n-            rng,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone)]\n-pub struct AllocExtra {\n-    pub stacked_borrows: stacked_borrows::AllocExtra,\n-    pub intptrcast: intptrcast::AllocExtra,\n-}\n-\n-impl AllocationExtra<Tag> for AllocExtra {\n-    #[inline(always)]\n-    fn memory_read<'tcx>(\n-        alloc: &Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_read(ptr, size)\n-    }\n-\n-    #[inline(always)]\n-    fn memory_written<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_written(ptr, size)\n-    }\n-\n-    #[inline(always)]\n-    fn memory_deallocated<'tcx>(\n-        alloc: &mut Allocation<Tag, AllocExtra>,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n-    }\n-}"}, {"sha": "0e25de7da5a95282c4f4b901c0d75d14b614f55a", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -1,4 +1,4 @@\n-use rustc::ty::Ty;\n+use rustc::ty::{Ty, layout::{Size, LayoutOf}};\n use rustc::mir;\n \n use crate::*;"}, {"sha": "d404872f9db6d1a94c353cbc11ba91875bd7845f", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -29,7 +29,7 @@ name = \"cargo-miri-test\"\n version = \"0.1.0\"\n dependencies = [\n  \"byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rand 0.7.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -73,10 +73,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rand\"\n-version = \"0.7.0-pre.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getrandom 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -150,7 +149,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6281b86796ba5e4366000be6e9e18bf35580adf9e63fbe2294aadb587613a319\"\n \"checksum ppv-lite86 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e3cbf9f658cdb5000fcf6f362b8ea2ba154b9f146a61c7a20d647034c6b6561b\"\n-\"checksum rand 0.7.0-pre.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"866531c9bb6613da04a1e6ad99d27a7c8acd488020d7a8b177b058a10c900eec\"\n+\"checksum rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d47eab0e83d9693d40f825f86948aa16eff6750ead4bdffc4ab95b8b3a7f052c\"\n \"checksum rand_chacha 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e193067942ef6f485a349a113329140d0ab9e2168ce92274499bb0e9a4190d9d\"\n \"checksum rand_core 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"615e683324e75af5d43d8f7a39ffe3ee4a9dc42c5c701167a71dc59c3a493aca\"\n \"checksum rand_hc 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\""}, {"sha": "c7fc62b79e840d8ad2cd7aa69e58d12892d73072", "filename": "test-cargo-miri/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/test-cargo-miri%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/test-cargo-miri%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.toml?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -8,4 +8,4 @@ edition = \"2018\"\n byteorder = \"1.0\"\n \n [dev-dependencies]\n-rand = { version = \"0.7.0-pre.0\", features = [\"small_rng\"] }\n+rand = { version = \"0.7\", features = [\"small_rng\"] }"}, {"sha": "40b21f9a4729ee1510dd15dd1998d94be14de046", "filename": "tests/run-pass/intptrcast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/857305ff6785251809551217f181b4f4f4f041b3/tests%2Frun-pass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/857305ff6785251809551217f181b4f4f4f041b3/tests%2Frun-pass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast.rs?ref=857305ff6785251809551217f181b4f4f4f041b3", "patch": "@@ -1,9 +1,14 @@\n // compile-flags: -Zmiri-seed=0000000000000000\n \n fn main() {\n+    // Some casting-to-int with arithmetic.\n     let x = &42 as *const i32 as usize; \n     let y = x * 2;\n     assert_eq!(y, x + x);\n     let z = y as u8 as usize;\n     assert_eq!(z, y % 256);\n+\n+    // Pointer string formatting! We can't check the output as it changes when libstd changes,\n+    // but we can make sure Miri does not error.\n+    format!(\"{:?}\", &mut 13 as *mut _);\n }"}]}