{"sha": "e2ebb467bdf3ebb7d29260adb95c56594c6db282", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZWJiNDY3YmRmM2ViYjdkMjkyNjBhZGI5NWM1NjU5NGM2ZGIyODI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-09T22:06:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-09T22:06:25Z"}, "message": "Merge #1803\n\n1803: introduce bump as a better-checked alternative to bump_any r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "e0c25226d8a13b3ff2a13d1100315e8455ea98bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0c25226d8a13b3ff2a13d1100315e8455ea98bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2ebb467bdf3ebb7d29260adb95c56594c6db282", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJddszhCRBK7hj4Ov3rIwAAdHIIAD6dGnf9DK51GqAMRvAab5a6\nkajc2MgxP8n908sBQdfIbETreEg1OMnmM1Q/Lz6nYqsiHiGWf7nthoywzCHAkUYn\nNqORCJ74xSb7yd5NcUwNB9LNqpnJxX2WiUiY0bcpEuvdmHvEG5iy7z3eROs0Jzl/\nzgj54OGm7jX1gSFBdEoQCioTtE51N8FAiRXTfuXZiuU++hFyxEZSeOkKgtx307sc\nE5MDy7npJMpcmspoh+YsLu8KCR8QIZHFdVfu0NWGlevrr3yLx3Jc3zjzxeDhauLI\nr9R0wRFk5At3Fm3AXzIj6tUACn7423iSSyW9Y8KBF3IRdQTCeaj7Bcca9agVBNA=\n=rxEn\n-----END PGP SIGNATURE-----\n", "payload": "tree e0c25226d8a13b3ff2a13d1100315e8455ea98bd\nparent c3d96f64ef1b2a5ded9cf5950f8e0f5798de4e1b\nparent d8aa9a1d81529cdc39e8353f2915c3c4d04ac263\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1568066785 +0000\ncommitter GitHub <noreply@github.com> 1568066785 +0000\n\nMerge #1803\n\n1803: introduce bump as a better-checked alternative to bump_any r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebb467bdf3ebb7d29260adb95c56594c6db282", "html_url": "https://github.com/rust-lang/rust/commit/e2ebb467bdf3ebb7d29260adb95c56594c6db282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2ebb467bdf3ebb7d29260adb95c56594c6db282/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3d96f64ef1b2a5ded9cf5950f8e0f5798de4e1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d96f64ef1b2a5ded9cf5950f8e0f5798de4e1b", "html_url": "https://github.com/rust-lang/rust/commit/c3d96f64ef1b2a5ded9cf5950f8e0f5798de4e1b"}, {"sha": "d8aa9a1d81529cdc39e8353f2915c3c4d04ac263", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8aa9a1d81529cdc39e8353f2915c3c4d04ac263", "html_url": "https://github.com/rust-lang/rust/commit/d8aa9a1d81529cdc39e8353f2915c3c4d04ac263"}], "stats": {"total": 270, "additions": 138, "deletions": 132}, "files": [{"sha": "4e6f2f558cce0fa9acc4109c89bd9a1137d2f3dc", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -93,12 +93,12 @@ pub(crate) mod fragments {\n                 // https://doc.rust-lang.org/reference/paths.html#simple-paths\n                 // The start of an meta must be a simple path\n                 match p.current() {\n-                    IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n+                    IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump_any(),\n                     T![=] => {\n-                        p.bump();\n+                        p.bump_any();\n                         match p.current() {\n-                            c if c.is_literal() => p.bump(),\n-                            T![true] | T![false] => p.bump(),\n+                            c if c.is_literal() => p.bump_any(),\n+                            T![true] | T![false] => p.bump_any(),\n                             _ => {}\n                         }\n                         break;\n@@ -126,7 +126,7 @@ pub(crate) mod fragments {\n \n         while !p.at(EOF) {\n             if p.at(T![;]) {\n-                p.bump();\n+                p.bump(T![;]);\n                 continue;\n             }\n \n@@ -179,7 +179,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n     match p.current() {\n         T![pub] => {\n             let m = p.start();\n-            p.bump();\n+            p.bump(T![pub]);\n             if p.at(T!['(']) {\n                 match p.nth(1) {\n                     // test crate_visibility\n@@ -188,13 +188,13 @@ fn opt_visibility(p: &mut Parser) -> bool {\n                     // pub(self) struct S;\n                     // pub(self) struct S;\n                     T![crate] | T![self] | T![super] => {\n-                        p.bump();\n-                        p.bump();\n+                        p.bump_any();\n+                        p.bump_any();\n                         p.expect(T![')']);\n                     }\n                     T![in] => {\n-                        p.bump();\n-                        p.bump();\n+                        p.bump_any();\n+                        p.bump_any();\n                         paths::use_path(p);\n                         p.expect(T![')']);\n                     }\n@@ -212,7 +212,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n         // fn foo() { crate::foo(); }\n         T![crate] if p.nth(1) != T![::] => {\n             let m = p.start();\n-            p.bump();\n+            p.bump_any();\n             m.complete(p, VISIBILITY);\n         }\n         _ => return false,\n@@ -223,7 +223,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n fn opt_alias(p: &mut Parser) {\n     if p.at(T![as]) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         if !p.eat(T![_]) {\n             name(p);\n         }\n@@ -234,9 +234,9 @@ fn opt_alias(p: &mut Parser) {\n fn abi(p: &mut Parser) {\n     assert!(p.at(T![extern]));\n     let abi = p.start();\n-    p.bump();\n+    p.bump_any();\n     match p.current() {\n-        STRING | RAW_STRING => p.bump(),\n+        STRING | RAW_STRING => p.bump_any(),\n         _ => (),\n     }\n     abi.complete(p, ABI);\n@@ -245,7 +245,7 @@ fn abi(p: &mut Parser) {\n fn opt_fn_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         types::type_(p);\n         m.complete(p, RET_TYPE);\n         true\n@@ -257,7 +257,7 @@ fn opt_fn_ret_type(p: &mut Parser) -> bool {\n fn name_r(p: &mut Parser, recovery: TokenSet) {\n     if p.at(IDENT) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         m.complete(p, NAME);\n     } else {\n         p.err_recover(\"expected a name\", recovery);\n@@ -271,11 +271,11 @@ fn name(p: &mut Parser) {\n fn name_ref(p: &mut Parser) {\n     if p.at(IDENT) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         m.complete(p, NAME_REF);\n     } else if p.at(T![self]) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         m.complete(p, T![self]);\n     } else {\n         p.err_and_bump(\"expected identifier\");\n@@ -285,7 +285,7 @@ fn name_ref(p: &mut Parser) {\n fn name_ref_or_index(p: &mut Parser) {\n     if p.at(IDENT) || p.at(INT_NUMBER) {\n         let m = p.start();\n-        p.bump();\n+        p.bump_any();\n         m.complete(p, NAME_REF);\n     } else {\n         p.err_and_bump(\"expected identifier\");\n@@ -296,7 +296,7 @@ fn error_block(p: &mut Parser, message: &str) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.error(message);\n-    p.bump();\n+    p.bump_any();\n     expressions::expr_block_contents(p);\n     p.eat(T!['}']);\n     m.complete(p, ERROR);"}, {"sha": "81a363a57939958e2592fcd4d19393e25d9c6ffc", "filename": "crates/ra_parser/src/grammar/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -15,11 +15,11 @@ pub(super) fn outer_attributes(p: &mut Parser) {\n fn attribute(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n     assert!(p.at(T![#]));\n-    p.bump();\n+    p.bump_any();\n \n     if inner {\n         assert!(p.at(T![!]));\n-        p.bump();\n+        p.bump_any();\n     }\n \n     if p.at(T!['[']) {"}, {"sha": "30036eb463e8a0454456e4fe9a30425452240f8d", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn block(p: &mut Parser) {\n pub(crate) fn naked_block(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     expr_block_contents(p);\n     p.expect(T!['}']);\n     m.complete(p, BLOCK);\n@@ -153,7 +153,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     // }\n     fn let_stmt(p: &mut Parser, m: Marker, with_semi: StmtWithSemi) {\n         assert!(p.at(T![let]));\n-        p.bump();\n+        p.bump_any();\n         patterns::pattern(p);\n         if p.at(T![:]) {\n             types::ascription(p);\n@@ -198,7 +198,7 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n         // }\n \n         if p.at(T![;]) {\n-            p.bump();\n+            p.bump_any();\n             continue;\n         }\n \n@@ -309,7 +309,7 @@ fn expr_bp(\n         }\n         let m = lhs.precede(p);\n         match op {\n-            Op::Simple => p.bump(),\n+            Op::Simple => p.bump_any(),\n             Op::Composite(kind, n) => {\n                 p.bump_compound(kind, n);\n             }\n@@ -338,7 +338,7 @@ fn lhs(\n         // }\n         T![&] => {\n             m = p.start();\n-            p.bump();\n+            p.bump_any();\n             p.eat(T![mut]);\n             REF_EXPR\n         }\n@@ -350,14 +350,14 @@ fn lhs(\n         // }\n         T![*] | T![!] | T![-] => {\n             m = p.start();\n-            p.bump();\n+            p.bump_any();\n             PREFIX_EXPR\n         }\n         // test full_range_expr\n         // fn foo() { xs[..]; }\n         T![..] | T![..=] => {\n             m = p.start();\n-            p.bump();\n+            p.bump_any();\n             if p.at_ts(EXPR_FIRST) {\n                 expr_bp(p, r, 2, dollar_lvl);\n             }\n@@ -410,16 +410,16 @@ fn postfix_expr(\n                 //     x.0().await?.hello();\n                 // }\n                 let m = lhs.precede(p);\n-                p.bump();\n-                p.bump();\n+                p.bump_any();\n+                p.bump_any();\n                 m.complete(p, AWAIT_EXPR)\n             }\n             T![.] => field_expr(p, lhs),\n             // test postfix_range\n             // fn foo() { let x = 1..; }\n             T![..] | T![..=] if !EXPR_FIRST.contains(p.nth(1)) => {\n                 let m = lhs.precede(p);\n-                p.bump();\n+                p.bump_any();\n                 m.complete(p, RANGE_EXPR)\n             }\n             T![?] => try_expr(p, lhs),\n@@ -453,7 +453,7 @@ fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = lhs.precede(p);\n-    p.bump();\n+    p.bump_any();\n     expr(p);\n     p.expect(T![']']);\n     m.complete(p, INDEX_EXPR)\n@@ -467,7 +467,7 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]));\n     let m = lhs.precede(p);\n-    p.bump();\n+    p.bump_any();\n     name_ref(p);\n     type_args::opt_type_arg_list(p, true);\n     if p.at(T!['(']) {\n@@ -493,12 +493,12 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]));\n     let m = lhs.precede(p);\n-    p.bump();\n+    p.bump_any();\n     if p.at(IDENT) || p.at(INT_NUMBER) {\n         name_ref_or_index(p)\n     } else if p.at(FLOAT_NUMBER) {\n         // FIXME: How to recover and instead parse INT + T![.]?\n-        p.bump();\n+        p.bump_any();\n     } else {\n         p.error(\"expected field name or number\")\n     }\n@@ -512,7 +512,7 @@ fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![?]));\n     let m = lhs.precede(p);\n-    p.bump();\n+    p.bump_any();\n     m.complete(p, TRY_EXPR)\n }\n \n@@ -526,7 +526,7 @@ fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![as]));\n     let m = lhs.precede(p);\n-    p.bump();\n+    p.bump_any();\n     // Use type_no_bounds(), because cast expressions are not\n     // allowed to have bounds.\n     types::type_no_bounds(p);\n@@ -536,7 +536,7 @@ fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n fn arg_list(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(T![')']) && !p.at(EOF) {\n         if !p.at_ts(EXPR_FIRST) {\n             p.error(\"expected expression\");\n@@ -585,7 +585,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n pub(crate) fn record_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n             // test record_literal_field_with_attr\n@@ -602,7 +602,7 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n                 m.complete(p, RECORD_FIELD);\n             }\n             T![..] => {\n-                p.bump();\n+                p.bump_any();\n                 expr(p);\n             }\n             T!['{'] => error_block(p, \"expected a field\"),"}, {"sha": "cea79cf6fe4219bc09e595eb085548aee12a4d13", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -31,7 +31,7 @@ pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n         return None;\n     }\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     Some(m.complete(p, LITERAL))\n }\n \n@@ -100,14 +100,14 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         }\n         T![async] if la == T!['{'] || (la == T![move] && p.nth(2) == T!['{']) => {\n             let m = p.start();\n-            p.bump();\n+            p.bump_any();\n             p.eat(T![move]);\n             block_expr(p, Some(m))\n         }\n         T![match] => match_expr(p),\n         T![unsafe] if la == T!['{'] => {\n             let m = p.start();\n-            p.bump();\n+            p.bump_any();\n             block_expr(p, Some(m))\n         }\n         T!['{'] => {\n@@ -179,7 +179,7 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n fn array_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     if p.eat(T![']']) {\n         return m.complete(p, ARRAY_EXPR);\n     }\n@@ -261,11 +261,11 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n fn if_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     cond(p);\n     block(p);\n     if p.at(T![else]) {\n-        p.bump();\n+        p.bump_any();\n         if p.at(T![if]) {\n             if_expr(p);\n         } else {\n@@ -284,8 +284,8 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n fn label(p: &mut Parser) {\n     assert!(p.at(LIFETIME) && p.nth(1) == T![:]);\n     let m = p.start();\n-    p.bump();\n-    p.bump();\n+    p.bump_any();\n+    p.bump_any();\n     m.complete(p, LABEL);\n }\n \n@@ -296,7 +296,7 @@ fn label(p: &mut Parser) {\n fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![loop]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump();\n+    p.bump_any();\n     block(p);\n     m.complete(p, LOOP_EXPR)\n }\n@@ -309,7 +309,7 @@ fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump();\n+    p.bump_any();\n     cond(p);\n     block(p);\n     m.complete(p, WHILE_EXPR)\n@@ -322,7 +322,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![for]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump();\n+    p.bump_any();\n     patterns::pattern(p);\n     p.expect(T![in]);\n     expr_no_struct(p);\n@@ -356,7 +356,7 @@ fn cond(p: &mut Parser) {\n fn match_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![match]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     expr_no_struct(p);\n     if p.at(T!['{']) {\n         match_arm_list(p);\n@@ -452,7 +452,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n fn match_guard(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     expr(p);\n     m.complete(p, MATCH_GUARD)\n }\n@@ -478,7 +478,7 @@ pub(super) fn block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn return_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![return]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     if p.at_ts(EXPR_FIRST) {\n         expr(p);\n     }\n@@ -495,7 +495,7 @@ fn return_expr(p: &mut Parser) -> CompletedMarker {\n fn continue_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![continue]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     p.eat(LIFETIME);\n     m.complete(p, CONTINUE_EXPR)\n }\n@@ -512,7 +512,7 @@ fn continue_expr(p: &mut Parser) -> CompletedMarker {\n fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n     assert!(p.at(T![break]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     p.eat(LIFETIME);\n     // test break_ambiguity\n     // fn foo(){\n@@ -534,7 +534,7 @@ fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![try]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump();\n+    p.bump_any();\n     block(p);\n     m.complete(p, TRY_EXPR)\n }\n@@ -548,7 +548,7 @@ fn try_block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n fn box_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = m.unwrap_or_else(|| p.start());\n-    p.bump();\n+    p.bump_any();\n     if p.at_ts(EXPR_FIRST) {\n         expr(p);\n     }"}, {"sha": "f27cc85ff6d527b8349b4987d5f6ad1000017994", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -64,7 +64,7 @@ pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemF\n         } else if p.at(T!['}']) && !stop_on_r_curly {\n             let e = p.start();\n             p.error(\"unmatched `}`\");\n-            p.bump();\n+            p.bump_any();\n             e.complete(p, ERROR);\n         } else if !p.at(EOF) && !p.at(T!['}']) {\n             p.err_and_bump(\"expected an item\");\n@@ -276,9 +276,9 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n \n fn extern_crate_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![extern]));\n-    p.bump();\n+    p.bump_any();\n     assert!(p.at(T![crate]));\n-    p.bump();\n+    p.bump_any();\n     name_ref(p);\n     opt_alias(p);\n     p.expect(T![;]);\n@@ -288,15 +288,15 @@ fn extern_crate_item(p: &mut Parser, m: Marker) {\n pub(crate) fn extern_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     mod_contents(p, true);\n     p.expect(T!['}']);\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     assert!(p.at(T![fn]));\n-    p.bump();\n+    p.bump_any();\n \n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n@@ -323,7 +323,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n     // test fn_decl\n     // trait T { fn foo(); }\n     if p.at(T![;]) {\n-        p.bump();\n+        p.bump_any();\n     } else {\n         expressions::block(p)\n     }\n@@ -333,7 +333,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n // type Foo = Bar;\n fn type_def(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![type]));\n-    p.bump();\n+    p.bump_any();\n \n     name(p);\n \n@@ -357,7 +357,7 @@ fn type_def(p: &mut Parser, m: Marker) {\n \n pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![mod]));\n-    p.bump();\n+    p.bump_any();\n \n     name(p);\n     if p.at(T!['{']) {\n@@ -371,7 +371,7 @@ pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n pub(crate) fn mod_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     mod_contents(p, true);\n     p.expect(T!['}']);\n     m.complete(p, ITEM_LIST);\n@@ -412,7 +412,7 @@ pub(crate) fn token_tree(p: &mut Parser) {\n         _ => unreachable!(),\n     };\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(closing_paren_kind) {\n         match p.current() {\n             T!['{'] | T!['('] | T!['['] => token_tree(p),"}, {"sha": "e115463333e4f474b939a1fe521d297526b59ad1", "filename": "crates/ra_parser/src/grammar/items/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -10,7 +10,7 @@ pub(super) fn const_def(p: &mut Parser, m: Marker) {\n \n fn const_or_static(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     assert!(p.at(kw));\n-    p.bump();\n+    p.bump_any();\n     p.eat(T![mut]); // FIXME: validator to forbid const mut\n     name(p);\n     types::ascription(p);"}, {"sha": "460acd65eb994bbad156fe5dec2cca1f76b20528", "filename": "crates/ra_parser/src/grammar/items/nominal.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -11,7 +11,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n             type_params::opt_where_clause(p);\n             match p.current() {\n                 T![;] => {\n-                    p.bump();\n+                    p.bump_any();\n                 }\n                 T!['{'] => record_field_def_list(p),\n                 _ => {\n@@ -21,7 +21,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n             }\n         }\n         T![;] if kind == T![struct] => {\n-            p.bump();\n+            p.bump_any();\n         }\n         T!['{'] => record_field_def_list(p),\n         T!['('] if kind == T![struct] => {\n@@ -44,7 +44,7 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n \n pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![enum]));\n-    p.bump();\n+    p.bump_any();\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     type_params::opt_where_clause(p);\n@@ -59,7 +59,7 @@ pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n pub(crate) fn enum_variant_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected enum variant\");\n@@ -73,7 +73,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n                 T!['{'] => record_field_def_list(p),\n                 T!['('] => tuple_field_def_list(p),\n                 T![=] => {\n-                    p.bump();\n+                    p.bump_any();\n                     expressions::expr(p);\n                 }\n                 _ => (),\n@@ -94,7 +94,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n pub(crate) fn record_field_def_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(T!['}']) && !p.at(EOF) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected field\");"}, {"sha": "b49221a4be6d0d271f6a7ffb9231712b5c4f7ebb", "filename": "crates/ra_parser/src/grammar/items/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -5,7 +5,7 @@ use super::*;\n // trait X<U: Debug + Display>: Hash + Clone where U: Copy {}\n pub(super) fn trait_def(p: &mut Parser) {\n     assert!(p.at(T![trait]));\n-    p.bump();\n+    p.bump_any();\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     if p.at(T![:]) {\n@@ -29,7 +29,7 @@ pub(super) fn trait_def(p: &mut Parser) {\n pub(crate) fn trait_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n@@ -45,7 +45,7 @@ pub(crate) fn trait_item_list(p: &mut Parser) {\n // impl Foo {}\n pub(super) fn impl_block(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n-    p.bump();\n+    p.bump_any();\n     if choose_type_params_over_qpath(p) {\n         type_params::opt_type_param_list(p);\n     }\n@@ -78,7 +78,7 @@ pub(super) fn impl_block(p: &mut Parser) {\n pub(crate) fn impl_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     // test impl_inner_attributes\n     // enum F{}\n     // impl F {"}, {"sha": "7a1693a349b50092c71b43e9dffcd7daedd39f17", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -2,7 +2,7 @@ use super::*;\n \n pub(super) fn use_item(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![use]));\n-    p.bump();\n+    p.bump_any();\n     use_tree(p);\n     p.expect(T![;]);\n     m.complete(p, USE_ITEM);\n@@ -28,15 +28,15 @@ fn use_tree(p: &mut Parser) {\n         // use ::*;\n         // use some::path::{*};\n         // use some::path::{::*};\n-        (T![*], _) => p.bump(),\n+        (T![*], _) => p.bump_any(),\n         (T![::], T![*]) => {\n             // Parse `use ::*;`, which imports all from the crate root in Rust 2015\n             // This is invalid inside a use_tree_list, (e.g. `use some::path::{::*}`)\n             // but still parses and errors later: ('crate root in paths can only be used in start position')\n             // FIXME: Add this error (if not out of scope)\n             // In Rust 2018, it is always invalid (see above)\n-            p.bump();\n-            p.bump();\n+            p.bump_any();\n+            p.bump_any();\n         }\n         // Open a use tree list\n         // Handles cases such as `use {some::path};` or `{inner::path}` in\n@@ -49,7 +49,7 @@ fn use_tree(p: &mut Parser) {\n         // use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n         (T!['{'], _) | (T![::], T!['{']) => {\n             if p.at(T![::]) {\n-                p.bump();\n+                p.bump_any();\n             }\n             use_tree_list(p);\n         }\n@@ -81,10 +81,10 @@ fn use_tree(p: &mut Parser) {\n                     opt_alias(p);\n                 }\n                 T![::] => {\n-                    p.bump();\n+                    p.bump_any();\n                     match p.current() {\n                         T![*] => {\n-                            p.bump();\n+                            p.bump_any();\n                         }\n                         // test use_tree_list_after_path\n                         // use crate::{Item};\n@@ -114,7 +114,7 @@ fn use_tree(p: &mut Parser) {\n pub(crate) fn use_tree_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         use_tree(p);\n         if !p.at(T!['}']) {"}, {"sha": "56e4573258c438671103c5418ea57b77ab47a237", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -39,7 +39,7 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     let (bra, ket) = if flavor.type_required() { (T!['('], T![')']) } else { (T![|], T![|]) };\n     assert!(p.at(bra));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     if flavor.type_required() {\n         // test self_param_outer_attr\n         // fn f(#[must_use] self) {}\n@@ -146,7 +146,7 @@ fn opt_self_param(p: &mut Parser) {\n         };\n         m = p.start();\n         for _ in 0..n_toks {\n-            p.bump();\n+            p.bump_any();\n         }\n     }\n     m.complete(p, SELF_PARAM);"}, {"sha": "345c93f55b8ff92c1324a041558ac7ff13d41272", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -44,7 +44,7 @@ fn path(p: &mut Parser, mode: Mode) {\n         };\n         if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n-            p.bump();\n+            p.bump_any();\n             path_segment(p, mode, false);\n             let path = path.complete(p, PATH);\n             qual = path;\n@@ -80,7 +80,7 @@ fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n             }\n             // test crate_path\n             // use crate::foo;\n-            T![self] | T![super] | T![crate] => p.bump(),\n+            T![self] | T![super] | T![crate] => p.bump_any(),\n             _ => {\n                 p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n             }"}, {"sha": "d2f4296f874a98b021ecc2eb4a82f931a3546176", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -36,7 +36,7 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n         // }\n         if p.at(T![...]) || p.at(T![..=]) || p.at(T![..]) {\n             let m = lhs.precede(p);\n-            p.bump();\n+            p.bump_any();\n             atom_pat(p, recovery_set);\n             m.complete(p, RANGE_PAT);\n         }\n@@ -100,7 +100,7 @@ fn literal_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(is_literal_pat_start(p));\n     let m = p.start();\n     if p.at(T![-]) {\n-        p.bump();\n+        p.bump_any();\n     }\n     expressions::literal(p);\n     m.complete(p, LITERAL_PAT)\n@@ -140,7 +140,7 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n // }\n fn tuple_pat_fields(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n-    p.bump();\n+    p.bump_any();\n     pat_list(p, T![')']);\n     p.expect(T![')']);\n }\n@@ -155,10 +155,10 @@ fn tuple_pat_fields(p: &mut Parser) {\n fn record_field_pat_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n-            T![..] => p.bump(),\n+            T![..] => p.bump_any(),\n             IDENT if p.nth(1) == T![:] => record_field_pat(p),\n             T!['{'] => error_block(p, \"expected ident\"),\n             T![box] => {\n@@ -182,7 +182,7 @@ fn record_field_pat(p: &mut Parser) {\n \n     let m = p.start();\n     name(p);\n-    p.bump();\n+    p.bump_any();\n     pattern(p);\n     m.complete(p, RECORD_FIELD_PAT);\n }\n@@ -192,7 +192,7 @@ fn record_field_pat(p: &mut Parser) {\n fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![_]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     m.complete(p, PLACEHOLDER_PAT)\n }\n \n@@ -204,7 +204,7 @@ fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n fn ref_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![&]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     p.eat(T![mut]);\n     pattern(p);\n     m.complete(p, REF_PAT)\n@@ -228,7 +228,7 @@ fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n fn slice_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     pat_list(p, T![']']);\n     p.expect(T![']']);\n     m.complete(p, SLICE_PAT)\n@@ -237,7 +237,7 @@ fn slice_pat(p: &mut Parser) -> CompletedMarker {\n fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n         match p.current() {\n-            T![..] => p.bump(),\n+            T![..] => p.bump_any(),\n             _ => {\n                 if !p.at_ts(PATTERN_FIRST) {\n                     p.error(\"expected a pattern\");\n@@ -281,7 +281,7 @@ fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n fn box_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![box]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     pattern(p);\n     m.complete(p, BOX_PAT)\n }"}, {"sha": "e100af53155f8380e70df538128d1e32893a508a", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -5,13 +5,13 @@ pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     match (colon_colon_required, p.nth(0), p.nth(1)) {\n         (_, T![::], T![<]) => {\n             m = p.start();\n-            p.bump();\n-            p.bump();\n+            p.bump_any();\n+            p.bump_any();\n         }\n         (false, T![<], T![=]) => return,\n         (false, T![<], _) => {\n             m = p.start();\n-            p.bump();\n+            p.bump_any();\n         }\n         _ => return,\n     };\n@@ -32,7 +32,7 @@ fn type_arg(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n-            p.bump();\n+            p.bump_any();\n             m.complete(p, LIFETIME_ARG);\n         }\n         // test associated_type_bounds\n@@ -44,7 +44,7 @@ fn type_arg(p: &mut Parser) {\n         }\n         IDENT if p.nth(1) == T![=] => {\n             name_ref(p);\n-            p.bump();\n+            p.bump_any();\n             types::type_(p);\n             m.complete(p, ASSOC_TYPE_ARG);\n         }"}, {"sha": "31d709d81149f53e78480f8e796a73dc675c82cf", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -10,7 +10,7 @@ pub(super) fn opt_type_param_list(p: &mut Parser) {\n fn type_param_list(p: &mut Parser) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n \n     while !p.at(EOF) && !p.at(T![>]) {\n         let m = p.start();\n@@ -38,7 +38,7 @@ fn type_param_list(p: &mut Parser) {\n \n fn lifetime_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(LIFETIME));\n-    p.bump();\n+    p.bump_any();\n     if p.at(T![:]) {\n         lifetime_bounds(p);\n     }\n@@ -54,7 +54,7 @@ fn type_param(p: &mut Parser, m: Marker) {\n     // test type_param_default\n     // struct S<T = i32>;\n     if p.at(T![=]) {\n-        p.bump();\n+        p.bump_any();\n         types::type_(p)\n     }\n     m.complete(p, TYPE_PARAM);\n@@ -64,15 +64,15 @@ fn type_param(p: &mut Parser, m: Marker) {\n // struct S<T: 'a + ?Sized + (Copy)>;\n pub(super) fn bounds(p: &mut Parser) {\n     assert!(p.at(T![:]));\n-    p.bump();\n+    p.bump_any();\n     bounds_without_colon(p);\n }\n \n fn lifetime_bounds(p: &mut Parser) {\n     assert!(p.at(T![:]));\n-    p.bump();\n+    p.bump_any();\n     while p.at(LIFETIME) {\n-        p.bump();\n+        p.bump_any();\n         if !p.eat(T![+]) {\n             break;\n         }\n@@ -99,7 +99,7 @@ fn type_bound(p: &mut Parser) -> bool {\n     let has_paren = p.eat(T!['(']);\n     p.eat(T![?]);\n     match p.current() {\n-        LIFETIME => p.bump(),\n+        LIFETIME => p.bump_any(),\n         T![for] => types::for_type(p),\n         _ if paths::is_use_path_start(p) => types::path_type_(p, false),\n         _ => {\n@@ -128,7 +128,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n         return;\n     }\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n \n     while is_where_predicate(p) {\n         where_predicate(p);\n@@ -166,7 +166,7 @@ fn where_predicate(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n-            p.bump();\n+            p.bump_any();\n             if p.at(T![:]) {\n                 bounds(p);\n             } else {"}, {"sha": "0eb28ef09032d6332831f63761d06603c822fd1f", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -44,7 +44,7 @@ pub(super) fn ascription(p: &mut Parser) {\n fn paren_or_tuple_type(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     let mut n_types: u32 = 0;\n     let mut trailing_comma: bool = false;\n     while !p.at(EOF) && !p.at(T![')']) {\n@@ -79,20 +79,20 @@ fn paren_or_tuple_type(p: &mut Parser) {\n fn never_type(p: &mut Parser) {\n     assert!(p.at(T![!]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     m.complete(p, NEVER_TYPE);\n }\n \n fn pointer_type(p: &mut Parser) {\n     assert!(p.at(T![*]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n \n     match p.current() {\n         // test pointer_type_mut\n         // type M = *mut ();\n         // type C = *mut ();\n-        T![mut] | T![const] => p.bump(),\n+        T![mut] | T![const] => p.bump_any(),\n         _ => {\n             // test_err pointer_type_no_mutability\n             // type T = *();\n@@ -110,21 +110,21 @@ fn pointer_type(p: &mut Parser) {\n fn array_or_slice_type(p: &mut Parser) {\n     assert!(p.at(T!['[']));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n \n     type_(p);\n     let kind = match p.current() {\n         // test slice_type\n         // type T = [()];\n         T![']'] => {\n-            p.bump();\n+            p.bump_any();\n             SLICE_TYPE\n         }\n \n         // test array_type\n         // type T = [(); 92];\n         T![;] => {\n-            p.bump();\n+            p.bump_any();\n             expressions::expr(p);\n             p.expect(T![']']);\n             ARRAY_TYPE\n@@ -146,7 +146,7 @@ fn array_or_slice_type(p: &mut Parser) {\n fn reference_type(p: &mut Parser) {\n     assert!(p.at(T![&]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     p.eat(LIFETIME);\n     p.eat(T![mut]);\n     type_no_bounds(p);\n@@ -158,7 +158,7 @@ fn reference_type(p: &mut Parser) {\n fn placeholder_type(p: &mut Parser) {\n     assert!(p.at(T![_]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     m.complete(p, PLACEHOLDER_TYPE);\n }\n \n@@ -193,7 +193,7 @@ fn fn_pointer_type(p: &mut Parser) {\n \n pub(super) fn for_binder(p: &mut Parser) {\n     assert!(p.at(T![for]));\n-    p.bump();\n+    p.bump_any();\n     if p.at(T![<]) {\n         type_params::opt_type_param_list(p);\n     } else {\n@@ -224,7 +224,7 @@ pub(super) fn for_type(p: &mut Parser) {\n fn impl_trait_type(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     type_params::bounds_without_colon(p);\n     m.complete(p, IMPL_TRAIT_TYPE);\n }\n@@ -234,7 +234,7 @@ fn impl_trait_type(p: &mut Parser) {\n fn dyn_trait_type(p: &mut Parser) {\n     assert!(p.at(T![dyn ]));\n     let m = p.start();\n-    p.bump();\n+    p.bump_any();\n     type_params::bounds_without_colon(p);\n     m.complete(p, DYN_TRAIT_TYPE);\n }"}, {"sha": "d8567e84be5dc988d25e36f0900919057d114d2d", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2ebb467bdf3ebb7d29260adb95c56594c6db282/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=e2ebb467bdf3ebb7d29260adb95c56594c6db282", "patch": "@@ -148,7 +148,7 @@ impl<'t> Parser<'t> {\n     }\n \n     /// Advances the parser by one token with composite puncts handled\n-    pub(crate) fn bump(&mut self) {\n+    pub(crate) fn bump_any(&mut self) {\n         let kind = self.nth(0);\n         if kind == EOF {\n             return;\n@@ -170,6 +170,12 @@ impl<'t> Parser<'t> {\n         }\n     }\n \n+    /// Advances the parser by one token, asserting that it is exactly the expected token\n+    pub(crate) fn bump(&mut self, expected: SyntaxKind) {\n+        debug_assert!(self.nth(0) == expected);\n+        self.bump_any()\n+    }\n+\n     /// Advances the parser by one token, remapping its kind.\n     /// This is useful to create contextual keywords from\n     /// identifiers. For example, the lexer creates an `union`\n@@ -205,7 +211,7 @@ impl<'t> Parser<'t> {\n         if !self.at(kind) {\n             return false;\n         }\n-        self.bump();\n+        self.bump_any();\n         true\n     }\n \n@@ -231,7 +237,7 @@ impl<'t> Parser<'t> {\n         } else {\n             let m = self.start();\n             self.error(message);\n-            self.bump();\n+            self.bump_any();\n             m.complete(self, ERROR);\n         };\n     }"}]}