{"sha": "50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjNkNmVjY2I4NWEyNGEwMmI3YzFkYWY1ZTI0Mjc2OGRkZGYzYjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-24T12:31:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-24T12:31:41Z"}, "message": "Auto merge of #57094 - Centril:rollup, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #55470 (box: Add documentation for `From` impls)\n - #56242 (Add missing link in docs)\n - #56944 (bootstrap: Link LLVM as a dylib with ThinLTO)\n - #56978 (Add `std::os::fortanix_sgx` module)\n - #56985 (Allow testing pointers for inboundedness while forbidding dangling pointers)\n - #56986 (rustc: Move jemalloc from rustc_driver to rustc)\n - #57010 (Actually run compiletest tests on CI)\n - #57021 (Enable emission of alignment attrs for pointer params)\n - #57074 (Fix recursion limits)\n - #57085 (librustc_codegen_llvm: Don't eliminate empty structs in C ABI on linux-sparc64)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ef2f9e32d0738813c1a64f489ba1b528b14b77c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef2f9e32d0738813c1a64f489ba1b528b14b77c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "html_url": "https://github.com/rust-lang/rust/commit/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94bf2c15eb3d072e92855a605783a29920df9e46", "url": "https://api.github.com/repos/rust-lang/rust/commits/94bf2c15eb3d072e92855a605783a29920df9e46", "html_url": "https://github.com/rust-lang/rust/commit/94bf2c15eb3d072e92855a605783a29920df9e46"}, {"sha": "6ce748ac381d8faf83725eb179640e3ab89835ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ce748ac381d8faf83725eb179640e3ab89835ed", "html_url": "https://github.com/rust-lang/rust/commit/6ce748ac381d8faf83725eb179640e3ab89835ed"}], "stats": {"total": 894, "additions": 515, "deletions": 379}, "files": [{"sha": "ff289ab163f841e19765d2a69050a7508ad8b1e1", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -819,7 +819,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"fortanix-sgx-abi\"\n-version = \"0.3.1\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2216,6 +2216,7 @@ dependencies = [\n name = \"rustc-main\"\n version = \"0.0.0\"\n dependencies = [\n+ \"jemalloc-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_codegen_ssa 0.0.0\",\n  \"rustc_driver 0.0.0\",\n  \"rustc_target 0.0.0\",\n@@ -2402,7 +2403,6 @@ dependencies = [\n  \"arena 0.0.0\",\n  \"env_logger 0.5.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n- \"jemalloc-sys 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2892,7 +2892,7 @@ dependencies = [\n  \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"fortanix-sgx-abi 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n@@ -3449,7 +3449,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\n \"checksum foreign-types-shared 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b\"\n-\"checksum fortanix-sgx-abi 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"26105e20b4c3f7a319db1376b54ac9a46e5761e949405553375095d05a0cee4d\"\n+\"checksum fortanix-sgx-abi 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3f8cbee5e872cf7db61a999a041f9bc4706ca7bf7df4cb914f53fabb1c1bc550\"\n \"checksum fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213\"\n \"checksum fs_extra 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5f2a4a2034423744d2cc7ca2068453168dcdb82c438419e639a26bd87839c674\"\n \"checksum fst 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d94485a00b1827b861dd9d1a2cc9764f9044d4c535514c0760a5a2012ef3399f\""}, {"sha": "5d486c04b427ea6a6e210ddb079bd8ee72e41bcb", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -48,7 +48,6 @@ impl Step for Std {\n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &libstd_stamp(builder, compiler, target),\n                   true);\n \n@@ -95,7 +94,6 @@ impl Step for Rustc {\n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &librustc_stamp(builder, compiler, target),\n                   true);\n \n@@ -146,7 +144,6 @@ impl Step for CodegenBackend {\n         let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n                   true);\n     }\n@@ -184,7 +181,6 @@ impl Step for Test {\n         builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &libtest_stamp(builder, compiler, target),\n                   true);\n \n@@ -232,7 +228,6 @@ impl Step for Rustdoc {\n         println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &rustdoc_stamp(builder, compiler, target),\n                   true);\n "}, {"sha": "366df4b0ad5cc2a151e64b44ae535e0f85f2ad29", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -29,6 +29,7 @@ use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n+use crate::dist;\n use crate::util::{exe, libdir, is_dylib};\n use crate::{Compiler, Mode, GitRepo};\n use crate::native;\n@@ -114,7 +115,6 @@ impl Step for Std {\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &libstd_stamp(builder, compiler, target),\n                   false);\n \n@@ -375,7 +375,6 @@ impl Step for Test {\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &libtest_stamp(builder, compiler, target),\n                   false);\n \n@@ -503,7 +502,6 @@ impl Step for Rustc {\n                  compiler.stage, &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n-                  vec![],\n                   &librustc_stamp(builder, compiler, target),\n                   false);\n \n@@ -646,47 +644,18 @@ impl Step for CodegenBackend {\n \n         let out_dir = builder.cargo_out(compiler, Mode::Codegen, target);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"rustc\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"build\");\n         cargo.arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         let features = build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n \n-        let mut cargo_tails_args = vec![];\n-\n-        if builder.config.llvm_thin_lto {\n-            cargo_tails_args.push(\"--\".to_string());\n-\n-            let num_jobs = builder.jobs();\n-\n-            if !target.contains(\"msvc\") {\n-                // Here we assume that the linker is clang. If it's not, there'll\n-                // be linker errors.\n-                cargo_tails_args.push(\"-Clink-arg=-fuse-ld=lld\".to_string());\n-                cargo_tails_args.push(\"-Clink-arg=-flto=thin\".to_string());\n-\n-                if builder.config.llvm_optimize {\n-                    cargo_tails_args.push(\"-Clink-arg=-O2\".to_string());\n-                }\n-\n-                // Let's make LLD respect the `-j` option.\n-                let num_jobs_arg = format!(\"-Clink-arg=-Wl,--thinlto-jobs={}\", num_jobs);\n-                cargo_tails_args.push(num_jobs_arg);\n-            } else {\n-                // Here we assume that the linker is lld-link.exe. lld-link.exe\n-                // does not need the extra arguments except for num_jobs\n-                let num_jobs_arg = format!(\"-Clink-arg=/opt:lldltojobs={}\", num_jobs);\n-                cargo_tails_args.push(num_jobs_arg);\n-            }\n-        }\n-\n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n-                              cargo_tails_args,\n                               &tmp_stamp,\n                               false);\n         if builder.config.dry_run {\n@@ -759,7 +728,9 @@ pub fn build_codegen_backend(builder: &Builder,\n                                          \"libstdc++.a\");\n                 cargo.env(\"LLVM_STATIC_STDCPP\", file);\n             }\n-            if builder.config.llvm_link_shared {\n+            if builder.config.llvm_link_shared ||\n+                (builder.config.llvm_thin_lto && backend != \"emscripten\")\n+            {\n                 cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n             }\n         }\n@@ -999,6 +970,8 @@ impl Step for Assemble {\n             copy_lld_to_sysroot(builder, target_compiler, &lld_install);\n         }\n \n+        dist::maybe_install_llvm_dylib(builder, target_compiler.host, &sysroot);\n+\n         // Link the compiler binary itself into place\n         let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n         let rustc = out_dir.join(exe(\"rustc_binary\", &*host));\n@@ -1025,7 +998,6 @@ pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n \n pub fn run_cargo(builder: &Builder,\n                  cargo: &mut Command,\n-                 tail_args: Vec<String>,\n                  stamp: &Path,\n                  is_check: bool)\n     -> Vec<PathBuf>\n@@ -1048,7 +1020,7 @@ pub fn run_cargo(builder: &Builder,\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(builder, cargo, tail_args, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, &mut |msg| {\n         let filenames = match msg {\n             CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n             _ => return,\n@@ -1173,7 +1145,6 @@ pub fn run_cargo(builder: &Builder,\n pub fn stream_cargo(\n     builder: &Builder,\n     cargo: &mut Command,\n-    tail_args: Vec<String>,\n     cb: &mut dyn FnMut(CargoMessage),\n ) -> bool {\n     if builder.config.dry_run {\n@@ -1184,10 +1155,6 @@ pub fn stream_cargo(\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n-    for arg in tail_args {\n-        cargo.arg(arg);\n-    }\n-\n     builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n         Ok(child) => child,"}, {"sha": "55ec4af0382b025b1d798dbd195b98c3a3d7cea8", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -1888,13 +1888,13 @@ impl Step for HashSign {\n // LLVM tools are linked dynamically.\n // Note: This function does no yet support Windows but we also don't support\n //       linking LLVM tools dynamically on Windows yet.\n-fn maybe_install_llvm_dylib(builder: &Builder,\n-                            target: Interned<String>,\n-                            image: &Path) {\n+pub fn maybe_install_llvm_dylib(builder: &Builder,\n+                                target: Interned<String>,\n+                                sysroot: &Path) {\n     let src_libdir = builder\n         .llvm_out(target)\n         .join(\"lib\");\n-    let dst_libdir = image.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n+    let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n     t!(fs::create_dir_all(&dst_libdir));\n \n     if target.contains(\"apple-darwin\") {"}, {"sha": "d2fc26e5812c2184acc6f0bc4e4e844fc727a33e", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -87,7 +87,7 @@ impl Step for ToolBuild {\n         let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(builder, &mut cargo, vec![], &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n                 | \"rls\""}, {"sha": "24e2dea4ca773bf713e859bca9cb94dcf2585d20", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -21,4 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n-           python2.7 ../x.py build --stage 0 src/tools/build-manifest\n+           python2.7 ../x.py build --stage 0 src/tools/build-manifest && \\\n+           python2.7 ../x.py test --stage 0 src/tools/compiletest"}, {"sha": "859749780b472d6722b39bb74bcb332de26ad454", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -443,13 +443,28 @@ impl<T: ?Sized + Hasher> Hasher for Box<T> {\n \n #[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n impl<T> From<T> for Box<T> {\n+    /// Converts a generic type `T` into a `Box<T>`\n+    ///\n+    /// The conversion allocates on the heap and moves `t`\n+    /// from the stack into it.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let x = 5;\n+    /// let boxed = Box::new(5);\n+    ///\n+    /// assert_eq!(Box::from(x), boxed);\n+    /// ```\n     fn from(t: T) -> Self {\n         Box::new(t)\n     }\n }\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T> From<Box<T>> for Pin<Box<T>> {\n+    /// Converts a `Box<T>` into a `Pin<Box<T>>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n     fn from(boxed: Box<T>) -> Self {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n         // when `T: !Unpin`,  so it's safe to pin it directly without any\n@@ -460,6 +475,19 @@ impl<T> From<Box<T>> for Pin<Box<T>> {\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n+    /// Converts a `&[T]` into a `Box<[T]>`\n+    ///\n+    /// This conversion allocates on the heap\n+    /// and performs a copy of `slice`.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// // create a &[u8] which will be used to create a Box<[u8]>\n+    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n+    /// let boxed_slice: Box<[u8]> = Box::from(slice);\n+    ///\n+    /// println!(\"{:?}\", boxed_slice);\n+    /// ```\n     fn from(slice: &'a [T]) -> Box<[T]> {\n         let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n         boxed.copy_from_slice(slice);\n@@ -469,6 +497,16 @@ impl<'a, T: Copy> From<&'a [T]> for Box<[T]> {\n \n #[stable(feature = \"box_from_slice\", since = \"1.17.0\")]\n impl<'a> From<&'a str> for Box<str> {\n+    /// Converts a `&str` into a `Box<str>`\n+    ///\n+    /// This conversion allocates on the heap\n+    /// and performs a copy of `s`.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let boxed: Box<str> = Box::from(\"hello\");\n+    /// println!(\"{}\", boxed);\n+    /// ```\n     #[inline]\n     fn from(s: &'a str) -> Box<str> {\n         unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }\n@@ -477,6 +515,22 @@ impl<'a> From<&'a str> for Box<str> {\n \n #[stable(feature = \"boxed_str_conv\", since = \"1.19.0\")]\n impl From<Box<str>> for Box<[u8]> {\n+    /// Converts a `Box<str>>` into a `Box<[u8]>`\n+    ///\n+    /// This conversion does not allocate on the heap and happens in place.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// // create a Box<str> which will be used to create a Box<[u8]>\n+    /// let boxed: Box<str> = Box::from(\"hello\");\n+    /// let boxed_str: Box<[u8]> = Box::from(boxed);\n+    ///\n+    /// // create a &[u8] which will be used to create a Box<[u8]>\n+    /// let slice: &[u8] = &[104, 101, 108, 108, 111];\n+    /// let boxed_slice = Box::from(slice);\n+    ///\n+    /// assert_eq!(boxed_slice, boxed_str);\n+    /// ```\n     #[inline]\n     fn from(s: Box<str>) -> Self {\n         unsafe { Box::from_raw(Box::into_raw(s) as *mut [u8]) }"}, {"sha": "c1dcfcb7985c42120cc863cfed55f33d6807c9b2", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -162,7 +162,7 @@ pub trait Iterator {\n     /// That said, the implementation should provide a correct estimation,\n     /// because otherwise it would be a violation of the trait's protocol.\n     ///\n-    /// The default implementation returns `(0, None)` which is correct for any\n+    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n     /// iterator.\n     ///\n     /// [`usize`]: ../../std/primitive.usize.html"}, {"sha": "8bb3fc129520570b95ac8398744b7a7ad881a987", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -1271,8 +1271,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"set the MIR optimization level (0-3, default: 1)\"),\n     mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"emit noalias metadata for mutable references (default: yes on LLVM >= 6)\"),\n-    arg_align_attributes: bool = (false, parse_bool, [TRACKED],\n-        \"emit align metadata for reference arguments\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"dump MIR state to file.\n         `val` is used to select which passes and functions to dump. For example:"}, {"sha": "8c4f7a58dab40a9c480957eb4eec4e425d46f948", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -456,6 +456,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         let linux_s390x = target.target_os == \"linux\"\n                        && target.arch == \"s390x\"\n                        && target.target_env == \"gnu\";\n+        let linux_sparc64 = target.target_os == \"linux\"\n+                       && target.arch == \"sparc64\"\n+                       && target.target_env == \"gnu\";\n         let rust_abi = match sig.abi {\n             RustIntrinsic | PlatformIntrinsic | Rust | RustCall => true,\n             _ => false\n@@ -489,12 +492,6 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     attrs.pointee_size = pointee.size;\n                     attrs.pointee_align = Some(pointee.align);\n \n-                    // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n-                    // with align attributes, and those calls later block optimizations.\n-                    if !is_return && !cx.tcx.sess.opts.debugging_opts.arg_align_attributes {\n-                        attrs.pointee_align = None;\n-                    }\n-\n                     // `Box` pointer parameters never alias because ownership is transferred\n                     // `&mut` pointer parameters never alias other parameters,\n                     // or mutable global data\n@@ -526,8 +523,9 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n-                // The same is true for s390x-unknown-linux-gnu.\n-                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x) {\n+                // The same is true for s390x-unknown-linux-gnu\n+                // and sparc64-unknown-linux-gnu.\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x && !linux_sparc64) {\n                     arg.mode = PassMode::Ignore;\n                 }\n             }"}, {"sha": "090ff83ecc1a8b904204c1f8208c0a08352a3005", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -74,6 +74,10 @@ unsafe fn configure_llvm(sess: &Session) {\n             add(\"-mergefunc-use-aliases\");\n         }\n \n+        // HACK(eddyb) LLVM inserts `llvm.assume` calls to preserve align attributes\n+        // during inlining. Unfortunately these may block other optimizations.\n+        add(\"-preserve-alignment-assumptions-during-inlining=false\");\n+\n         for arg in &sess.opts.cg.llvm_args {\n             add(&(*arg));\n         }"}, {"sha": "43198937e3db6ef810940027ddfb55d4674175b4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -24,6 +24,8 @@\n #![allow(dead_code)]\n #![feature(quote)]\n \n+#![recursion_limit=\"256\"]\n+\n //! This crate contains codegen code that is used by all codegen backends (LLVM and others).\n //! The backend-agnostic functions of this crate use functions defined in various traits that\n //! have to be implemented by each backends."}, {"sha": "8bcda409e6663f8aa8c6969aaf67d3120a74c84c", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -38,8 +38,3 @@ syntax = { path = \"../libsyntax\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n syntax_ext = { path = \"../libsyntax_ext\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-\n-[dependencies.jemalloc-sys]\n-version = '0.1.8'\n-optional = true\n-features = ['unprefixed_malloc_on_supported_platforms']"}, {"sha": "b56ae61227c855d1297dad39c6487af282cf9af8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -63,14 +63,6 @@ extern crate syntax;\n extern crate syntax_ext;\n extern crate syntax_pos;\n \n-// Note that the linkage here should be all that we need, on Linux we're not\n-// prefixing the symbols here so this should naturally override our default\n-// allocator. On OSX it should override via the zone allocator. We shouldn't\n-// enable this by default on other platforms, so other platforms aren't handled\n-// here yet.\n-#[cfg(feature = \"jemalloc-sys\")]\n-extern crate jemalloc_sys;\n-\n use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n \n@@ -218,14 +210,7 @@ pub fn run<F>(run_compiler: F) -> isize\n }\n \n fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n-    // Note that we're specifically using `open_global_now` here rather than\n-    // `open`, namely we want the behavior on Unix of RTLD_GLOBAL and RTLD_NOW,\n-    // where NOW means \"bind everything right now\" because we don't want\n-    // surprises later on and RTLD_GLOBAL allows the symbols to be made\n-    // available for future dynamic libraries opened. This is currently used by\n-    // loading LLVM and then making its symbols available for other dynamic\n-    // libraries.\n-    let lib = DynamicLibrary::open_global_now(path).unwrap_or_else(|err| {\n+    let lib = DynamicLibrary::open(Some(path)).unwrap_or_else(|err| {\n         let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n         early_error(ErrorOutputType::default(), &err);\n     });"}, {"sha": "921be95c6a29fe7e5d874cb7ca308ec18121bce4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -30,6 +30,8 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n+#![recursion_limit=\"256\"]\n+\n #[macro_use]\n extern crate syntax;\n #[macro_use]"}, {"sha": "1b6453893375ef170d9bb13e5aec65caedaacb41", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -142,6 +142,10 @@ fn main() {\n             continue;\n         }\n \n+        if flag.starts_with(\"-flto\") {\n+            continue;\n+        }\n+\n         // -Wdate-time is not supported by the netbsd cross compiler\n         if is_crossed && target.contains(\"netbsd\") && flag.contains(\"date-time\") {\n             continue;"}, {"sha": "c44339775686db8f936151eccb8bfccf4e62eecb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             Scalar::Ptr(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n-                let align = self.check_bounds_ptr_maybe_dead(ptr)?;\n+                let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n                 (ptr.offset.bytes(), align)\n             }\n             Scalar::Bits { bits, size } => {\n@@ -297,17 +297,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n     /// in-bounds!  This follows C's/LLVM's rules.\n-    /// This function also works for deallocated allocations.\n-    /// Use `.get(ptr.alloc_id)?.check_bounds_ptr(ptr)` if you want to force the allocation\n-    /// to still be live.\n     /// If you want to check bounds before doing a memory access, better first obtain\n     /// an `Allocation` and call `check_bounds`.\n-    pub fn check_bounds_ptr_maybe_dead(\n+    pub fn check_bounds_ptr(\n         &self,\n         ptr: Pointer<M::PointerTag>,\n+        liveness: InboundsCheck,\n     ) -> EvalResult<'tcx, Align> {\n-        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id);\n-        ptr.check_in_alloc(allocation_size, InboundsCheck::MaybeDead)?;\n+        let (allocation_size, align) = self.get_size_and_align(ptr.alloc_id, liveness)?;\n+        ptr.check_in_alloc(allocation_size, liveness)?;\n         Ok(align)\n     }\n }\n@@ -429,27 +427,37 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_size_and_align(&self, id: AllocId) -> (Size, Align) {\n+    /// Obtain the size and alignment of an allocation, even if that allocation has been deallocated\n+    ///\n+    /// If `liveness` is `InboundsCheck::Dead`, this function always returns `Ok`\n+    pub fn get_size_and_align(\n+        &self,\n+        id: AllocId,\n+        liveness: InboundsCheck,\n+    ) -> EvalResult<'static, (Size, Align)> {\n         if let Ok(alloc) = self.get(id) {\n-            return (Size::from_bytes(alloc.bytes.len() as u64), alloc.align);\n+            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n         // Could also be a fn ptr or extern static\n         match self.tcx.alloc_map.lock().get(id) {\n-            Some(AllocKind::Function(..)) => (Size::ZERO, Align::from_bytes(1).unwrap()),\n+            Some(AllocKind::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n             Some(AllocKind::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                (layout.size, layout.align.abi)\n-            }\n-            _ => {\n-                // Must be a deallocated pointer\n-                *self.dead_alloc_map.get(&id).expect(\n-                    \"allocation missing in dead_alloc_map\"\n-                )\n+                Ok((layout.size, layout.align.abi))\n             }\n+            _ => match liveness {\n+                InboundsCheck::MaybeDead => {\n+                    // Must be a deallocated pointer\n+                    Ok(*self.dead_alloc_map.get(&id).expect(\n+                        \"allocation missing in dead_alloc_map\"\n+                    ))\n+                },\n+                InboundsCheck::Live => err!(DanglingPointerDeref),\n+            },\n         }\n     }\n "}, {"sha": "2fb9939c2ab54fdc61c2a469d3d6b75701e72c74", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -17,7 +17,7 @@ use rustc::mir;\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n-    GlobalId, AllocId,\n+    GlobalId, AllocId, InboundsCheck,\n     ConstValue, Pointer, Scalar,\n     EvalResult, EvalErrorKind,\n };\n@@ -647,7 +647,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n-                            self.memory.check_bounds_ptr_maybe_dead(ptr).is_ok();\n+                            self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok();\n                         if !ptr_valid {\n                             return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n                         }"}, {"sha": "81e2a3b3ff5411779a093982b9d0cdf82014ffe5", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -21,6 +21,8 @@\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n+#![recursion_limit=\"256\"]\n+\n #[macro_use]\n extern crate rustc;\n extern crate rustc_mir;"}, {"sha": "5228d9de653270a3ff2650766d93931b9e978407", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -67,6 +67,8 @@\n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]\n \n+#![recursion_limit=\"256\"]\n+\n #[macro_use] extern crate syntax;\n \n extern crate rustc;"}, {"sha": "87bbf93777b912af695839aed11636ff419e2227", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -18,6 +18,8 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n \n+#![recursion_limit=\"256\"]\n+\n #[macro_use]\n extern crate bitflags;\n #[macro_use]"}, {"sha": "9e3d9af5ba253bab47e363510ce471c7ba1c7e60", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -40,7 +40,7 @@ rustc_tsan = { path = \"../librustc_tsan\" }\n dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n \n [target.x86_64-fortanix-unknown-sgx.dependencies]\n-fortanix-sgx-abi = { version = \"0.3.1\", features = ['rustc-dep-of-std'] }\n+fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [build-dependencies]\n cc = \"1.0\""}, {"sha": "4a693bffddfc16f9ab2b86453af8ee8d83a82c0b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -314,7 +314,7 @@\n #![feature(alloc_layout_extra)]\n #![feature(maybe_uninit)]\n #![cfg_attr(target_env = \"sgx\", feature(global_asm, range_contains, slice_index_methods,\n-                                        decl_macro, coerce_unsized))]\n+                                        decl_macro, coerce_unsized, sgx_platform))]\n \n #![default_lib_allocator]\n "}, {"sha": "825e7f359d64c0bd62b5a65bfa851863fda4c3a0", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Functionality specific to the `x86_64-fortanix-unknown-sgx` target.\n+//!\n+//! This includes functions to deal with memory isolation, usercalls, and the\n+//! SGX instruction set.\n+\n+#![deny(missing_docs, missing_debug_implementations)]\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+/// Low-level interfaces to usercalls. See the [ABI documentation] for more\n+/// information.\n+///\n+/// [ABI documentation]: https://docs.rs/fortanix-sgx-abi/\n+pub mod usercalls {\n+    pub use sys::abi::usercalls::*;\n+\n+    /// Primitives for allocating memory in userspace as well as copying data\n+    /// to and from user memory.\n+    pub mod alloc {\n+        pub use sys::abi::usercalls::alloc;\n+    }\n+\n+    /// Lowest-level interfaces to usercalls and usercall ABI type definitions.\n+    pub mod raw {\n+        use sys::abi::usercalls::raw::invoke_with_usercalls;\n+        pub use sys::abi::usercalls::raw::do_usercall;\n+        pub use sys::abi::usercalls::raw::{accept_stream, alloc, async_queues, bind_stream, close,\n+                                           connect_stream, exit, flush, free, insecure_time,\n+                                           launch_thread, read, read_alloc, send, wait, write};\n+\n+        macro_rules! define_usercallnrs {\n+            ($(fn $f:ident($($n:ident: $t:ty),*) $(-> $r:ty)*; )*) => {\n+                /// Usercall numbers as per the ABI.\n+                #[repr(C)]\n+                #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+                #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n+                #[allow(missing_docs)]\n+                pub enum UsercallNrs {\n+                    $($f,)*\n+                }\n+            };\n+        }\n+        invoke_with_usercalls!(define_usercallnrs);\n+\n+        // fortanix-sgx-abi re-exports\n+        pub use sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n+        pub use sys::abi::usercalls::raw::Error;\n+        pub use sys::abi::usercalls::raw::{EV_RETURNQ_NOT_EMPTY, EV_UNPARK, EV_USERCALLQ_NOT_FULL,\n+                                           FD_STDERR, FD_STDIN, FD_STDOUT, RESULT_SUCCESS,\n+                                           USERCALL_USER_DEFINED, WAIT_INDEFINITE, WAIT_NO};\n+        pub use sys::abi::usercalls::raw::{Fd, Result, Tcs};\n+    }\n+}\n+\n+/// Functions for querying mapping information for pointers.\n+pub mod mem {\n+    pub use sys::abi::mem::*;\n+}"}, {"sha": "ba5b938ed4ccf7ce8c61720b0ce493e86a564be9", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -29,25 +29,10 @@ cfg_if! {\n \n         #[doc(cfg(target_os = \"linux\"))]\n         pub mod linux;\n-\n     } else {\n \n-        // If we're not documenting libstd then we just expose everything as we\n-        // otherwise would.\n-\n-        #[cfg(target_os = \"android\")]    pub mod android;\n-        #[cfg(target_os = \"bitrig\")]     pub mod bitrig;\n-        #[cfg(target_os = \"dragonfly\")]  pub mod dragonfly;\n-        #[cfg(target_os = \"freebsd\")]    pub mod freebsd;\n-        #[cfg(target_os = \"haiku\")]      pub mod haiku;\n-        #[cfg(target_os = \"ios\")]        pub mod ios;\n-        #[cfg(target_os = \"macos\")]      pub mod macos;\n-        #[cfg(target_os = \"netbsd\")]     pub mod netbsd;\n-        #[cfg(target_os = \"openbsd\")]    pub mod openbsd;\n-        #[cfg(target_os = \"solaris\")]    pub mod solaris;\n-        #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n-        #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n-        #[cfg(target_os = \"hermit\")]     pub mod hermit;\n+        // If we're not documenting libstd then we just expose the main modules\n+        // as we otherwise would.\n \n         #[cfg(any(target_os = \"redox\", unix))]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -63,4 +48,19 @@ cfg_if! {\n     }\n }\n \n+#[cfg(target_os = \"android\")]    pub mod android;\n+#[cfg(target_os = \"bitrig\")]     pub mod bitrig;\n+#[cfg(target_os = \"dragonfly\")]  pub mod dragonfly;\n+#[cfg(target_os = \"freebsd\")]    pub mod freebsd;\n+#[cfg(target_os = \"haiku\")]      pub mod haiku;\n+#[cfg(target_os = \"ios\")]        pub mod ios;\n+#[cfg(target_os = \"macos\")]      pub mod macos;\n+#[cfg(target_os = \"netbsd\")]     pub mod netbsd;\n+#[cfg(target_os = \"openbsd\")]    pub mod openbsd;\n+#[cfg(target_os = \"solaris\")]    pub mod solaris;\n+#[cfg(target_os = \"emscripten\")] pub mod emscripten;\n+#[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n+#[cfg(target_os = \"hermit\")]     pub mod hermit;\n+#[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))] pub mod fortanix_sgx;\n+\n pub mod raw;"}, {"sha": "625202e5604941b56beda06d0395c8db9869cd1c", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -65,7 +65,7 @@ cfg_if! {\n     if #[cfg(any(unix, target_os = \"redox\"))] {\n         // On unix we'll document what's already available\n         pub use self::ext as unix_ext;\n-    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\"))] {\n+    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\", target_env = \"sgx\"))] {\n         // On CloudABI and wasm right now the module below doesn't compile\n         // (missing things in `libc` which is empty) so just omit everything\n         // with an empty module\n@@ -86,7 +86,7 @@ cfg_if! {\n         // On windows we'll just be documenting what's already available\n         #[allow(missing_docs)]\n         pub use self::ext as windows_ext;\n-    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\"))] {\n+    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\", target_env = \"sgx\"))] {\n         // On CloudABI and wasm right now the shim below doesn't compile, so\n         // just omit it\n         #[unstable(issue = \"0\", feature = \"std_internals\")]"}, {"sha": "11eb64606c43ed104eaffdb329620995f450ee68", "filename": "src/libstd/sys/sgx/abi/mem.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmem.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -10,13 +10,13 @@\n \n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n-pub unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n+pub(crate) unsafe fn rel_ptr<T>(offset: u64) -> *const T {\n     (image_base() + offset) as *const T\n }\n \n // Do not remove inline: will result in relocation failure\n #[inline(always)]\n-pub unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n+pub(crate) unsafe fn rel_ptr_mut<T>(offset: u64) -> *mut T {\n     (image_base() + offset) as *mut T\n }\n \n@@ -34,6 +34,17 @@ fn image_base() -> u64 {\n     base\n }\n \n+/// Returns `true` if the specified memory range is in the enclave.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn is_enclave_range(p: *const u8, len: usize) -> bool {\n+    let start=p as u64;\n+    let end=start + (len as u64);\n+    start >= image_base() &&\n+        end <= image_base() + (unsafe { ENCLAVE_SIZE } as u64) // unsafe ok: link-time constant\n+}\n+\n+/// Returns `true` if the specified memory range is in userspace.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn is_user_range(p: *const u8, len: usize) -> bool {\n     let start=p as u64;\n     let end=start + (len as u64);"}, {"sha": "18ba221af5a2376b175a2350d90993f62fdc6cdc", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -13,10 +13,10 @@ use io::Write;\n \n // runtime features\n mod reloc;\n-mod mem;\n pub(super) mod panic;\n \n // library features\n+pub mod mem;\n pub mod thread;\n pub mod tls;\n #[macro_use]"}, {"sha": "f1689091eb593a9069feeebe036e59e64008fc94", "filename": "src/libstd/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 180, "deletions": 31, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(unused)]\n \n-use ptr;\n+use ptr::{self, NonNull};\n use mem;\n use cell::UnsafeCell;\n use slice;\n@@ -39,39 +39,78 @@ use super::super::mem::is_user_range;\n ///   as vtable pointers) must not be leaked for confidentiality reasons.\n ///\n /// Non-exhaustive list of specific requirements for reading from userspace:\n-/// * Any bit pattern is valid for this type (no `enum`s). There can be no\n+/// * **Any bit pattern is valid** for this type (no `enum`s). There can be no\n ///   guarantee that the value correctly adheres to the expectations of the\n ///   type, so any value must be valid for this type.\n ///\n /// Non-exhaustive list of specific requirements for writing to userspace:\n-/// * No pointers to enclave memory. Memory addresses of data in enclave memory\n-///   must not be leaked for confidentiality reasons.\n-/// * No internal padding. Padding might contain previously-initialized secret\n-///   data stored at that memory location and must not be leaked for\n+/// * **No pointers to enclave memory.** Memory addresses of data in enclave\n+///   memory must not be leaked for confidentiality reasons.\n+/// * **No internal padding.** Padding might contain previously-initialized\n+///   secret data stored at that memory location and must not be leaked for\n ///   confidentiality reasons.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe trait UserSafeSized: Copy + Sized {}\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for u8 {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T> UserSafeSized for FifoDescriptor<T> {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for ByteBuffer {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for Usercall {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl UserSafeSized for Return {}\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafeSized for [T; 2] {}\n \n /// A type that can be represented in memory as one or more `UserSafeSized`s.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub unsafe trait UserSafe {\n-    unsafe fn align_of() -> usize;\n+    /// Equivalent to `mem::align_of::<Self>`.\n+    fn align_of() -> usize;\n \n+    /// Construct a pointer to `Self` given a memory range in user space.\n+    ///\n     /// NB. This takes a size, not a length!\n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self;\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range is in user memory, is the\n+    /// correct size and is correctly aligned and points to the right type.\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self;\n \n+    /// Construct a pointer to `Self` given a memory range.\n+    ///\n     /// NB. This takes a size, not a length!\n-    unsafe fn from_raw_sized(ptr: *const u8, size: usize) -> *const Self {\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range points to the correct type.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n+    unsafe fn from_raw_sized(ptr: *mut u8, size: usize) -> NonNull<Self> {\n         let ret = Self::from_raw_sized_unchecked(ptr, size);\n         Self::check_ptr(ret);\n-        ret\n+        NonNull::new_unchecked(ret as _)\n     }\n \n+    /// Check if a pointer may point to Self in user memory.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure the memory range points to the correct type and\n+    /// length (if this is a slice).\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer is not aligned\n+    /// * The pointer is null\n+    /// * The pointed-to range is not in user memory\n     unsafe fn check_ptr(ptr: *const Self) {\n         let is_aligned = |p| -> bool {\n             0 == (p as usize) & (Self::align_of() - 1)\n@@ -83,42 +122,70 @@ pub unsafe trait UserSafe {\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafe for T {\n-    unsafe fn align_of() -> usize {\n+    fn align_of() -> usize {\n         mem::align_of::<T>()\n     }\n \n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n         assert_eq!(size, mem::size_of::<T>());\n         ptr as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n unsafe impl<T: UserSafeSized> UserSafe for [T] {\n-    unsafe fn align_of() -> usize {\n+    fn align_of() -> usize {\n         mem::align_of::<T>()\n     }\n \n-    unsafe fn from_raw_sized_unchecked(ptr: *const u8, size: usize) -> *const Self {\n+    unsafe fn from_raw_sized_unchecked(ptr: *mut u8, size: usize) -> *mut Self {\n         let elem_size = mem::size_of::<T>();\n         assert_eq!(size % elem_size, 0);\n         let len = size / elem_size;\n-        slice::from_raw_parts(ptr as _, len)\n+        slice::from_raw_parts_mut(ptr as _, len)\n     }\n }\n \n /// A reference to some type in userspace memory. `&UserRef<T>` is equivalent\n /// to `&T` in enclave memory. Access to the memory is only allowed by copying\n /// to avoid TOCTTOU issues. After copying, code should make sure to completely\n /// check the value before use.\n+///\n+/// It is also possible to obtain a mutable reference `&mut UserRef<T>`. Unlike\n+/// regular mutable references, these are not exclusive. Userspace may always\n+/// write to the backing memory at any time, so it can't be assumed that there\n+/// the pointed-to memory is uniquely borrowed. The two different refence types\n+/// are used solely to indicate intent: a mutable reference is for writing to\n+/// user memory, an immutable reference for reading from user memory.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct UserRef<T: ?Sized>(UnsafeCell<T>);\n /// An owned type in userspace memory. `User<T>` is equivalent to `Box<T>` in\n /// enclave memory. Access to the memory is only allowed by copying to avoid\n /// TOCTTOU issues. The user memory will be freed when the value is dropped.\n /// After copying, code should make sure to completely check the value before\n /// use.\n-pub struct User<T: UserSafe + ?Sized>(*mut UserRef<T>);\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub struct User<T: UserSafe + ?Sized>(NonNull<UserRef<T>>);\n+\n+trait NewUserRef<T: ?Sized> {\n+    unsafe fn new_userref(v: T) -> Self;\n+}\n+\n+impl<T: ?Sized> NewUserRef<*mut T> for NonNull<UserRef<T>> {\n+    unsafe fn new_userref(v: *mut T) -> Self {\n+        NonNull::new_unchecked(v as _)\n+    }\n+}\n \n+impl<T: ?Sized> NewUserRef<NonNull<T>> for NonNull<UserRef<T>> {\n+    unsafe fn new_userref(v: NonNull<T>) -> Self {\n+        NonNull::new_userref(v.as_ptr())\n+    }\n+}\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> User<T> where T: UserSafe {\n     // This function returns memory that is practically uninitialized, but is\n     // not considered \"unspecified\" or \"undefined\" for purposes of an\n@@ -127,24 +194,28 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n     fn new_uninit_bytes(size: usize) -> Self {\n         unsafe {\n             let ptr = super::alloc(size, T::align_of()).expect(\"User memory allocation failed\");\n-            User(T::from_raw_sized(ptr as _, size) as _)\n+            User(NonNull::new_userref(T::from_raw_sized(ptr as _, size)))\n         }\n     }\n \n+    /// Copy `val` into freshly allocated space in user memory.\n     pub fn new_from_enclave(val: &T) -> Self {\n         unsafe {\n             let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n             ptr::copy(\n                 val as *const T as *const u8,\n-                ret.0 as *mut T as *mut u8,\n+                ret.0.as_ptr() as *mut u8,\n                 mem::size_of_val(val)\n             );\n             ret\n         }\n     }\n \n-    /// Create an owned `User<T>` from a raw pointer. The pointer should be\n-    /// freeable with the `free` usercall and the alignment of `T`.\n+    /// Create an owned `User<T>` from a raw pointer.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`, is freeable with the `free`\n+    /// usercall and the alignment of `T`, and is uniquely owned.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -154,32 +225,39 @@ impl<T: ?Sized> User<T> where T: UserSafe {\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw(ptr: *mut T) -> Self {\n         T::check_ptr(ptr);\n-        User(ptr as _)\n+        User(NonNull::new_userref(ptr))\n     }\n \n     /// Convert this value into a raw pointer. The value will no longer be\n     /// automatically freed.\n     pub fn into_raw(self) -> *mut T {\n         let ret = self.0;\n         mem::forget(self);\n-        ret as _\n+        ret.as_ptr() as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> User<T> where T: UserSafe {\n+    /// Allocate space for `T` in user memory.\n     pub fn uninitialized() -> Self {\n         Self::new_uninit_bytes(mem::size_of::<T>())\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> User<[T]> where [T]: UserSafe {\n+    /// Allocate space for a `[T]` of `n` elements in user memory.\n     pub fn uninitialized(n: usize) -> Self {\n         Self::new_uninit_bytes(n * mem::size_of::<T>())\n     }\n \n     /// Create an owned `User<[T]>` from a raw thin pointer and a slice length.\n-    /// The pointer should be freeable with the `free` usercall and the\n-    /// alignment of `T`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `len` elements of `T`, is\n+    /// freeable with the `free` usercall and the alignment of `T`, and is\n+    /// uniquely owned.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -188,13 +266,17 @@ impl<T> User<[T]> where [T]: UserSafe {\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts(ptr: *mut T, len: usize) -> Self {\n-        User(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as _)\n+        User(NonNull::new_userref(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>())))\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T> where T: UserSafe {\n     /// Create a `&UserRef<[T]>` from a raw pointer.\n     ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`.\n+    ///\n     /// # Panics\n     /// This function panics if:\n     ///\n@@ -206,7 +288,11 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &*(ptr as *const Self)\n     }\n \n-    /// Create a `&mut UserRef<[T]>` from a raw pointer.\n+    /// Create a `&mut UserRef<[T]>` from a raw pointer. See the struct\n+    /// documentation for the nuances regarding a `&mut UserRef<T>`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `T`.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -219,6 +305,8 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         &mut*(ptr as *mut Self)\n     }\n \n+    /// Copy `val` into user memory.\n+    ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n     /// the source. This can happen for dynamically-sized types such as slices.\n@@ -233,6 +321,8 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         }\n     }\n \n+    /// Copy the value from user memory and place it into `dest`.\n+    ///\n     /// # Panics\n     /// This function panics if the destination doesn't have the same size as\n     /// the source. This can happen for dynamically-sized types such as slices.\n@@ -247,35 +337,48 @@ impl<T: ?Sized> UserRef<T> where T: UserSafe {\n         }\n     }\n \n+    /// Obtain a raw pointer from this reference.\n     pub fn as_raw_ptr(&self) -> *const T {\n         self as *const _ as _\n     }\n \n+    /// Obtain a raw pointer from this reference.\n     pub fn as_raw_mut_ptr(&mut self) -> *mut T {\n         self as *mut _ as _\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<T> where T: UserSafe {\n+    /// Copy the value from user memory into enclave memory.\n     pub fn to_enclave(&self) -> T {\n         unsafe { ptr::read(self.0.get()) }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// Create a `&UserRef<[T]>` from a raw thin pointer and a slice length.\n     ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `n` elements of `T`.\n+    ///\n     /// # Panics\n     /// This function panics if:\n     ///\n     /// * The pointer is not aligned\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts<'a>(ptr: *const T, len: usize) -> &'a Self {\n-        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *const Self)\n+        &*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *const Self)\n     }\n \n     /// Create a `&mut UserRef<[T]>` from a raw thin pointer and a slice length.\n+    /// See the struct documentation for the nuances regarding a\n+    /// `&mut UserRef<T>`.\n+    ///\n+    /// # Safety\n+    /// The caller must ensure `ptr` points to `n` elements of `T`.\n     ///\n     /// # Panics\n     /// This function panics if:\n@@ -284,21 +387,30 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     /// * The pointer is null\n     /// * The pointed-to range is not in user memory\n     pub unsafe fn from_raw_parts_mut<'a>(ptr: *mut T, len: usize) -> &'a mut Self {\n-        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()) as *mut Self)\n+        &mut*(<[T]>::from_raw_sized(ptr as _, len * mem::size_of::<T>()).as_ptr() as *mut Self)\n     }\n \n+    /// Obtain a raw pointer to the first element of this user slice.\n     pub fn as_ptr(&self) -> *const T {\n         self.0.get() as _\n     }\n \n+    /// Obtain a raw pointer to the first element of this user slice.\n     pub fn as_mut_ptr(&mut self) -> *mut T {\n         self.0.get() as _\n     }\n \n+    /// Obtain the number of elements in this user slice.\n     pub fn len(&self) -> usize {\n         unsafe { (*self.0.get()).len() }\n     }\n \n+    /// Copy the value from user memory and place it into `dest`. Afterwards,\n+    /// `dest` will contain exactly `self.len()` elements.\n+    ///\n+    /// # Panics\n+    /// This function panics if the destination doesn't have the same size as\n+    /// the source. This can happen for dynamically-sized types such as slices.\n     pub fn copy_to_enclave_vec(&self, dest: &mut Vec<T>) {\n         unsafe {\n             if let Some(missing) = self.len().checked_sub(dest.capacity()) {\n@@ -309,12 +421,14 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         }\n     }\n \n+    /// Copy the value from user memory into a vector in enclave memory.\n     pub fn to_enclave(&self) -> Vec<T> {\n         let mut ret = Vec::with_capacity(self.len());\n         self.copy_to_enclave_vec(&mut ret);\n         ret\n     }\n \n+    /// Returns an iterator over the slice.\n     pub fn iter(&self) -> Iter<T>\n         where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n     {\n@@ -323,6 +437,7 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n         }\n     }\n \n+    /// Returns an iterator that allows modifying each value.\n     pub fn iter_mut(&mut self) -> IterMut<T>\n         where T: UserSafe // FIXME: should be implied by [T]: UserSafe?\n     {\n@@ -332,8 +447,13 @@ impl<T> UserRef<[T]> where [T]: UserSafe {\n     }\n }\n \n+/// Immutable user slice iterator\n+///\n+/// This struct is created by the `iter` method on `UserRef<[T]>`.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct Iter<'a, T: 'a + UserSafe>(slice::Iter<'a, T>);\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n     type Item = &'a UserRef<T>;\n \n@@ -345,8 +465,13 @@ impl<'a, T: UserSafe> Iterator for Iter<'a, T> {\n     }\n }\n \n+/// Mutable user slice iterator\n+///\n+/// This struct is created by the `iter_mut` method on `UserRef<[T]>`.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub struct IterMut<'a, T: 'a + UserSafe>(slice::IterMut<'a, T>);\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n     type Item = &'a mut UserRef<T>;\n \n@@ -358,31 +483,36 @@ impl<'a, T: UserSafe> Iterator for IterMut<'a, T> {\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> Deref for User<T> where T: UserSafe {\n     type Target = UserRef<T>;\n \n     fn deref(&self) -> &Self::Target {\n-        unsafe { &*self.0 }\n+        unsafe { &*self.0.as_ptr() }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> DerefMut for User<T> where T: UserSafe {\n     fn deref_mut(&mut self) -> &mut Self::Target {\n-        unsafe { &mut*self.0 }\n+        unsafe { &mut*self.0.as_ptr() }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> Drop for User<T> where T: UserSafe {\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = (*self.0).0.get();\n+            let ptr = (*self.0.as_ptr()).0.get();\n             super::free(ptr as _, mem::size_of_val(&mut*ptr), T::align_of());\n         }\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: CoerceUnsized<U>, U> CoerceUnsized<UserRef<U>> for UserRef<T> {}\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n     type Output = UserRef<I::Output>;\n \n@@ -394,6 +524,7 @@ impl<T, I: SliceIndex<[T]>> Index<I> for UserRef<[T]> where [T]: UserSafe, I::Ou\n     }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I::Output: UserSafe {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut UserRef<I::Output> {\n@@ -402,3 +533,21 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for UserRef<[T]> where [T]: UserSafe, I:\n         }\n     }\n }\n+\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+impl UserRef<super::raw::ByteBuffer> {\n+    /// Copy the user memory range pointed to by the user `ByteBuffer` to\n+    /// enclave memory.\n+    ///\n+    /// # Panics\n+    /// This function panics if:\n+    ///\n+    /// * The pointer in the user `ByteBuffer` is null\n+    /// * The pointed-to range in the user `ByteBuffer` is not in user memory\n+    pub fn copy_user_buffer(&self) -> Vec<u8> {\n+        unsafe {\n+            let buf = self.to_enclave();\n+            User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n+        }\n+    }\n+}"}, {"sha": "a5066abc14462325780eab248734a03e4b2e3b9f", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 44, "deletions": 13, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -8,22 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use fortanix_sgx_abi::*;\n-\n use io::{Error as IoError, Result as IoResult};\n use time::Duration;\n \n-pub mod alloc;\n+pub(crate) mod alloc;\n #[macro_use]\n-mod raw;\n+pub(crate) mod raw;\n \n-pub(crate) fn copy_user_buffer(buf: &alloc::UserRef<ByteBuffer>) -> Vec<u8> {\n-    unsafe {\n-        let buf = buf.to_enclave();\n-        alloc::User::from_raw_parts(buf.data as _, buf.len).to_enclave()\n-    }\n-}\n+use self::raw::*;\n \n+/// Usercall `read`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n     unsafe {\n         let mut userbuf = alloc::User::<[u8]>::uninitialized(buf.len());\n@@ -33,26 +28,44 @@ pub fn read(fd: Fd, buf: &mut [u8]) -> IoResult<usize> {\n     }\n }\n \n+/// Usercall `read_alloc`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn read_alloc(fd: Fd) -> IoResult<Vec<u8>> {\n+    unsafe {\n+        let mut userbuf = alloc::User::<ByteBuffer>::uninitialized();\n+        raw::read_alloc(fd, userbuf.as_raw_mut_ptr()).from_sgx_result()?;\n+        Ok(userbuf.copy_user_buffer())\n+    }\n+}\n+\n+/// Usercall `write`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn write(fd: Fd, buf: &[u8]) -> IoResult<usize> {\n     unsafe {\n         let userbuf = alloc::User::new_from_enclave(buf);\n         raw::write(fd, userbuf.as_ptr(), userbuf.len()).from_sgx_result()\n     }\n }\n \n+/// Usercall `flush`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn flush(fd: Fd) -> IoResult<()> {\n     unsafe { raw::flush(fd).from_sgx_result() }\n }\n \n+/// Usercall `close`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn close(fd: Fd) {\n     unsafe { raw::close(fd) }\n }\n \n fn string_from_bytebuffer(buf: &alloc::UserRef<ByteBuffer>, usercall: &str, arg: &str) -> String {\n-    String::from_utf8(copy_user_buffer(buf))\n+    String::from_utf8(buf.copy_user_buffer())\n         .unwrap_or_else(|_| panic!(\"Usercall {}: expected {} to be valid UTF-8\", usercall, arg))\n }\n \n+/// Usercall `bind_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n@@ -67,6 +80,8 @@ pub fn bind_stream(addr: &str) -> IoResult<(Fd, String)> {\n     }\n }\n \n+/// Usercall `accept_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let mut bufs = alloc::User::<[ByteBuffer; 2]>::uninitialized();\n@@ -84,6 +99,8 @@ pub fn accept_stream(fd: Fd) -> IoResult<(Fd, String, String)> {\n     }\n }\n \n+/// Usercall `connect_stream`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n     unsafe {\n         let addr_user = alloc::User::new_from_enclave(addr.as_bytes());\n@@ -103,31 +120,45 @@ pub fn connect_stream(addr: &str) -> IoResult<(Fd, String, String)> {\n     }\n }\n \n-pub fn launch_thread() -> IoResult<()> {\n-    unsafe { raw::launch_thread().from_sgx_result() }\n+/// Usercall `launch_thread`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub unsafe fn launch_thread() -> IoResult<()> {\n+    raw::launch_thread().from_sgx_result()\n }\n \n+/// Usercall `exit`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn exit(panic: bool) -> ! {\n     unsafe { raw::exit(panic) }\n }\n \n+/// Usercall `wait`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn wait(event_mask: u64, timeout: u64) -> IoResult<u64> {\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }\n }\n \n+/// Usercall `send`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn send(event_set: u64, tcs: Option<Tcs>) -> IoResult<()> {\n     unsafe { raw::send(event_set, tcs).from_sgx_result() }\n }\n \n+/// Usercall `insecure_time`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn insecure_time() -> Duration {\n     let t = unsafe { raw::insecure_time() };\n     Duration::new(t / 1_000_000_000, (t % 1_000_000_000) as _)\n }\n \n+/// Usercall `alloc`. See the ABI documentation for more information.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n pub fn alloc(size: usize, alignment: usize) -> IoResult<*mut u8> {\n     unsafe { raw::alloc(size, alignment).from_sgx_result() }\n }\n \n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+#[doc(inline)]\n pub use self::raw::free;\n \n fn check_os_error(err: Result) -> i32 {"}, {"sha": "44b370c44c636b496b97a2fc757479f0c689e254", "filename": "src/libstd/sys/sgx/abi/usercalls/raw.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fraw.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -10,7 +10,8 @@\n \n #![allow(unused)]\n \n-use fortanix_sgx_abi::*;\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub use fortanix_sgx_abi::*;\n \n use ptr::NonNull;\n \n@@ -21,7 +22,16 @@ extern \"C\" {\n     fn usercall(nr: u64, p1: u64, p2: u64, _ignore: u64, p3: u64, p4: u64) -> UsercallReturn;\n }\n \n-unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n+/// Perform the raw usercall operation as defined in the ABI calling convention.\n+///\n+/// # Safety\n+/// The caller must ensure to pass parameters appropriate for the usercall `nr`\n+/// and to observe all requirements specified in the ABI.\n+///\n+/// # Panics\n+/// Panics if `nr` is 0.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub unsafe fn do_usercall(nr: u64, p1: u64, p2: u64, p3: u64, p4: u64) -> (u64, u64) {\n     if nr==0 { panic!(\"Invalid usercall number {}\",nr) }\n     let UsercallReturn(a, b) = usercall(nr,p1,p2,0,p3,p4);\n     (a, b)\n@@ -169,6 +179,9 @@ impl<T: RegisterArgument, U: RegisterArgument> ReturnValue for (T, U) {\n macro_rules! enclave_usercalls_internal_define_usercalls {\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty,\n                      $n3:ident: $t3:ty, $n4:ident: $t4:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3, $n4: $t4) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -181,6 +194,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty, $n3:ident: $t3:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2, $n3: $t3) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -193,6 +209,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty, $n2:ident: $t2:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1, $n2: $t2) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -204,6 +223,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident($n1:ident: $t1:ty) -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f($n1: $t1) -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall(\n@@ -214,6 +236,9 @@ macro_rules! enclave_usercalls_internal_define_usercalls {\n         }\n     );\n     (def fn $f:ident() -> $r:ty) => (\n+        /// This is the raw function definition, see the ABI documentation for\n+        /// more information.\n+        #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n         #[inline(always)]\n         pub unsafe fn $f() -> $r {\n             ReturnValue::from_registers(stringify!($f), do_usercall("}, {"sha": "50627b8c9130218134aee07953ba205a26a4f67a", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ffi::OsString;\n-use super::abi::usercalls::{copy_user_buffer, alloc, ByteBuffer};\n+use super::abi::usercalls::{alloc, raw::ByteBuffer};\n use sync::atomic::{AtomicUsize, Ordering};\n use sys::os_str::Buf;\n use sys_common::FromInner;\n@@ -22,7 +22,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     if argc != 0 {\n         let args = alloc::User::<[ByteBuffer]>::from_raw_parts(argv as _, argc as _);\n         let args = args.iter()\n-            .map( |a| OsString::from_inner(Buf { inner: copy_user_buffer(a) }) )\n+            .map( |a| OsString::from_inner(Buf { inner: a.copy_user_buffer() }) )\n             .collect::<ArgsStore>();\n         ARGS.store(Box::into_raw(Box::new(args)) as _, Ordering::Relaxed);\n     }"}, {"sha": "9cfe821fe5154fdf204161504be41b11aa5a59c4", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -29,7 +29,7 @@ struct Socket {\n }\n \n impl Socket {\n-    fn new(fd: usercalls::Fd, local_addr: String) -> Socket {\n+    fn new(fd: usercalls::raw::Fd, local_addr: String) -> Socket {\n         Socket { inner: Arc::new(FileDesc::new(fd)), local_addr }\n     }\n }"}, {"sha": "b8d5b17d8d2d9c76b6dadbc27a03436ca9f51c61", "filename": "src/libstd/sys/sgx/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fthread.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -75,7 +75,7 @@ impl Thread {\n \n     pub fn yield_now() {\n         assert_eq!(\n-            usercalls::wait(0, usercalls::WAIT_NO).unwrap_err().kind(),\n+            usercalls::wait(0, usercalls::raw::WAIT_NO).unwrap_err().kind(),\n             io::ErrorKind::WouldBlock\n         );\n     }"}, {"sha": "2bbe3a69ce8bbb196c04cc4f2bc56cbb790ba8c1", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -24,6 +24,8 @@\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n+#![recursion_limit=\"256\"]\n+\n extern crate fmt_macros;\n #[macro_use]\n extern crate syntax;"}, {"sha": "164a3c6ad0d80eb5667368da13ef0e5f987e7cc5", "filename": "src/rustc/Cargo.toml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -15,5 +15,10 @@ rustc_driver = { path = \"../librustc_driver\" }\n # crate is intended to be used by codegen backends, which may not be in-tree.\n rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n \n+[dependencies.jemalloc-sys]\n+version = '0.1.8'\n+optional = true\n+features = ['unprefixed_malloc_on_supported_platforms']\n+\n [features]\n-jemalloc = ['rustc_driver/jemalloc-sys']\n+jemalloc = ['jemalloc-sys']"}, {"sha": "1c1c7b4bb8e3239d41a28e4628c7f5389e5d20e7", "filename": "src/rustc/rustc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Frustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Frustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -23,6 +23,14 @@ extern {}\n \n extern crate rustc_driver;\n \n+// Note that the linkage here should be all that we need, on Linux we're not\n+// prefixing the symbols here so this should naturally override our default\n+// allocator. On OSX it should override via the zone allocator. We shouldn't\n+// enable this by default on other platforms, so other platforms aren't handled\n+// here yet.\n+#[cfg(feature = \"jemalloc-sys\")]\n+extern crate jemalloc_sys;\n+\n fn main() {\n     rustc_driver::set_sigpipe_handler();\n     rustc_driver::main()"}, {"sha": "69632c9c82b709b652fdadf3af2dc73ec001704f", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f3d6eccb85a24a02b7c1daf5e242768dddf3b5/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=50f3d6eccb85a24a02b7c1daf5e242768dddf3b5", "patch": "@@ -28,37 +28,37 @@ pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n+// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n+// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly dereferenceable(4) %arg0)\n+// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* dereferenceable(4) %arg0)\n+// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %arg0)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n@@ -69,13 +69,13 @@ pub fn mutable_borrow(_: &mut i32) {\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly dereferenceable(32) %arg0)\n+// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %arg0)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n }\n \n-// CHECK: noalias align 4 dereferenceable(4) i32* @_box(i32* noalias dereferenceable(4) %x)\n+// CHECK: noalias align 4 dereferenceable(4) i32* @_box(i32* noalias align 4 dereferenceable(4) %x)\n #[no_mangle]\n pub fn _box(x: Box<i32>) -> Box<i32> {\n   x\n@@ -95,48 +95,48 @@ pub fn struct_return() -> S {\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* nonnull %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %arg0.0, [[USIZE]] %arg0.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias nonnull readonly %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull %arg0.0, [3 x [[USIZE]]]* noalias readonly dereferenceable({{.*}}) %arg0.1)\n+// CHECK: @trait_borrow({}* nonnull align 1 %arg0.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %arg0.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box({}* noalias nonnull, [3 x [[USIZE]]]* noalias readonly dereferenceable({{.*}}))\n+// CHECK: @trait_box({}* noalias nonnull align 1, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}))\n #[no_mangle]\n pub fn trait_box(_: Box<Drop>) {\n }\n \n-// CHECK: { i8*, i8* } @trait_option(i8* noalias %x.0, i8* %x.1)\n+// CHECK: { i8*, i8* } @trait_option(i8* noalias align 1 %x.0, i8* %x.1)\n #[no_mangle]\n pub fn trait_option(x: Option<Box<Drop>>) -> Option<Box<Drop>> {\n   x\n }\n \n-// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias nonnull readonly %x.0, [[USIZE]] %x.1)\n+// CHECK: { [0 x i16]*, [[USIZE]] } @return_slice([0 x i16]* noalias nonnull readonly align 2 %x.0, [[USIZE]] %x.1)\n #[no_mangle]\n pub fn return_slice(x: &[u16]) -> &[u16] {\n   x"}, {"sha": "8a18aadf36a8bb635684927b165c09f869f0c862", "filename": "src/test/run-make-fulldeps/llvm-pass/Makefile", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2FMakefile?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,28 +0,0 @@\n--include ../tools.mk\n-\n-ifeq ($(UNAME),Darwin)\n-PLUGIN_FLAGS := -C link-args=-Wl,-undefined,dynamic_lookup\n-endif\n-\n-ifeq ($(findstring stage1,$(RUST_BUILD_STAGE)),stage1)\n-# ignore stage1\n-all:\n-\n-else\n-# Windows doesn't correctly handle include statements with escaping paths,\n-# so this test will not get run on Windows.\n-ifdef IS_WINDOWS\n-all:\n-else\n-all: $(call NATIVE_STATICLIB,llvm-function-pass) $(call NATIVE_STATICLIB,llvm-module-pass)\n-\t$(RUSTC) plugin.rs -C prefer-dynamic $(PLUGIN_FLAGS)\n-\t$(RUSTC) main.rs\n-\n-$(TMPDIR)/libllvm-function-pass.o:\n-\t$(CXX) $(CFLAGS) $(LLVM_CXXFLAGS) -c llvm-function-pass.so.cc -o $(TMPDIR)/libllvm-function-pass.o\n-\n-$(TMPDIR)/libllvm-module-pass.o:\n-\t$(CXX) $(CFLAGS) $(LLVM_CXXFLAGS) -c llvm-module-pass.so.cc -o $(TMPDIR)/libllvm-module-pass.o\n-endif\n-\n-endif"}, {"sha": "c0a17d920cffc91154ee4b0e22d473225a408b92", "filename": "src/test/run-make-fulldeps/llvm-pass/llvm-function-pass.so.cc", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-function-pass.so.cc", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-function-pass.so.cc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-function-pass.so.cc?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-\n-#include \"llvm/Pass.h\"\n-#include \"llvm/IR/Function.h\"\n-\n-using namespace llvm;\n-\n-namespace {\n-\n-  class TestLLVMPass : public FunctionPass {\n-\n-  public:\n-\n-    static char ID;\n-    TestLLVMPass() : FunctionPass(ID) { }\n-\n-    bool runOnFunction(Function &F) override;\n-\n-    StringRef getPassName() const override {\n-      return \"Some LLVM pass\";\n-    }\n-\n-  };\n-\n-}\n-\n-bool TestLLVMPass::runOnFunction(Function &F) {\n-  // A couple examples of operations that previously caused segmentation faults\n-  // https://github.com/rust-lang/rust/issues/31067\n-\n-  for (auto N = F.begin(); N != F.end(); ++N) {\n-    /* code */\n-  }\n-\n-  LLVMContext &C = F.getContext();\n-  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);\n-  PointerType::get(Int8Ty, 0);\n-  return true;\n-}\n-\n-char TestLLVMPass::ID = 0;\n-\n-static RegisterPass<TestLLVMPass> RegisterAFLPass(\n-  \"some-llvm-function-pass\", \"Some LLVM pass\");"}, {"sha": "70051681ab0350393a8f25eae75e5becce325974", "filename": "src/test/run-make-fulldeps/llvm-pass/llvm-module-pass.so.cc", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-module-pass.so.cc", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-module-pass.so.cc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fllvm-module-pass.so.cc?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,55 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-\n-#include \"llvm/IR/Module.h\"\n-\n-using namespace llvm;\n-\n-namespace {\n-\n-  class TestLLVMPass : public ModulePass {\n-\n-  public:\n-\n-    static char ID;\n-    TestLLVMPass() : ModulePass(ID) { }\n-\n-    bool runOnModule(Module &M) override;\n-\n-    StringRef getPassName() const override {\n-      return \"Some LLVM pass\";\n-    }\n-\n-  };\n-\n-}\n-\n-bool TestLLVMPass::runOnModule(Module &M) {\n-  // A couple examples of operations that previously caused segmentation faults\n-  // https://github.com/rust-lang/rust/issues/31067\n-\n-  for (auto F = M.begin(); F != M.end(); ++F) {\n-    /* code */\n-  }\n-\n-  LLVMContext &C = M.getContext();\n-  IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);\n-  PointerType::get(Int8Ty, 0);\n-  return true;\n-}\n-\n-char TestLLVMPass::ID = 0;\n-\n-static RegisterPass<TestLLVMPass> RegisterAFLPass(\n-  \"some-llvm-module-pass\", \"Some LLVM pass\");"}, {"sha": "5b5ab94bcef02c139cb8493936050b5b2c0ca5ce", "filename": "src/test/run-make-fulldeps/llvm-pass/main.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fmain.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(plugin)]\n-#![plugin(some_plugin)]\n-\n-fn main() {}"}, {"sha": "f77b2fca857a613e3759bb50b4fec40995186fc6", "filename": "src/test/run-make-fulldeps/llvm-pass/plugin.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94bf2c15eb3d072e92855a605783a29920df9e46/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fllvm-pass%2Fplugin.rs?ref=94bf2c15eb3d072e92855a605783a29920df9e46", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(plugin_registrar, rustc_private)]\n-#![crate_type = \"dylib\"]\n-#![crate_name = \"some_plugin\"]\n-\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-#[link(name = \"llvm-function-pass\", kind = \"static\")]\n-#[link(name = \"llvm-module-pass\", kind = \"static\")]\n-extern {}\n-\n-use rustc_plugin::registry::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_llvm_pass(\"some-llvm-function-pass\");\n-    reg.register_llvm_pass(\"some-llvm-module-pass\");\n-}"}]}