{"sha": "3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNGU5NDM4ODFmYzkzMTM2YzRiNmFkODBmMjNhZWFkOWZlZTlkMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T21:56:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-03T21:56:22Z"}, "message": "auto merge of #8954 : anasazi/rust/tcp-acceptor, r=catamorphism\n\nThe Listener trait takes two type parameters, the type of connection and the type of Acceptor,\r\nand specifies only one method, listen, which consumes the listener and produces an Acceptor.\r\n\r\nThe Acceptor trait takes one type parameter, the type of connection, and defines two methods.\r\nThe accept() method waits for an incoming connection attempt and returns the result.\r\nThe incoming() method creates an iterator over incoming connections and is a default method.\r\n\r\nExample:\r\n\r\n```rust\r\nlet listener = TcpListener.bind(addr); // Bind to a socket\r\nlet acceptor = listener.listen(); // Start the listener\r\nfor stream in acceptor.incoming() {\r\n    // Process incoming connections forever (a failure will kill the task).\r\n}\r\n```\r\n\r\nCloses #8689", "tree": {"sha": "94fad443f0a29b4429d942b345a6259af04c7bd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94fad443f0a29b4429d942b345a6259af04c7bd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "html_url": "https://github.com/rust-lang/rust/commit/3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4ff0bca4c123399f8be8d44877e271767c5871c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4ff0bca4c123399f8be8d44877e271767c5871c", "html_url": "https://github.com/rust-lang/rust/commit/b4ff0bca4c123399f8be8d44877e271767c5871c"}, {"sha": "58b2ff9f564833f5f4fa077a5708c139738dad8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b2ff9f564833f5f4fa077a5708c139738dad8e", "html_url": "https://github.com/rust-lang/rust/commit/58b2ff9f564833f5f4fa077a5708c139738dad8e"}], "stats": {"total": 394, "additions": 234, "deletions": 160}, "files": [{"sha": "c56b20453e5bbed339ee8cc5df81261374fa65f8", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -474,17 +474,43 @@ pub trait Seek {\n     fn seek(&mut self, pos: i64, style: SeekStyle);\n }\n \n-/// A listener is a value that listens for connections\n-pub trait Listener<S> {\n-    /// Wait for and accept an incoming connection\n-    ///\n-    /// Returns `None` on timeout.\n+/// A listener is a value that can consume itself to start listening for connections.\n+/// Doing so produces some sort of Acceptor.\n+pub trait Listener<T, A: Acceptor<T>> {\n+    /// Spin up the listener and start queueing incoming connections\n     ///\n     /// # Failure\n     ///\n     /// Raises `io_error` condition. If the condition is handled,\n+    /// then `listen` returns `None`.\n+    fn listen(self) -> Option<A>;\n+}\n+\n+/// An acceptor is a value that presents incoming connections\n+pub trait Acceptor<T> {\n+    /// Wait for and accept an incoming connection\n+    ///\n+    /// # Failure\n+    /// Raise `io_error` condition. If the condition is handled,\n     /// then `accept` returns `None`.\n-    fn accept(&mut self) -> Option<S>;\n+    fn accept(&mut self) -> Option<T>;\n+\n+    /// Create an iterator over incoming connections\n+    fn incoming<'r>(&'r mut self) -> IncomingIterator<'r, Self> {\n+        IncomingIterator { inc: self }\n+    }\n+}\n+\n+/// An infinite iterator over incoming connection attempts.\n+/// Calling `next` will block the task until a connection is attempted.\n+struct IncomingIterator<'self, A> {\n+    priv inc: &'self mut A,\n+}\n+\n+impl<'self, T, A: Acceptor<T>> Iterator<T> for IncomingIterator<'self, A> {\n+    fn next(&mut self) -> Option<T> {\n+        self.inc.accept()\n+    }\n }\n \n /// Common trait for decorator types."}, {"sha": "b7cb703eb25477fb8018c2492d241718c8abc2e9", "filename": "src/libstd/rt/io/net/tcp.rs", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -11,12 +11,13 @@\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::io::net::ip::SocketAddr;\n-use rt::io::{Reader, Writer, Listener};\n+use rt::io::{Reader, Writer, Listener, Acceptor};\n use rt::io::{io_error, read_error, EndOfFile};\n use rt::rtio::{IoFactory, IoFactoryObject,\n-               RtioSocket, RtioTcpListener,\n-               RtioTcpListenerObject, RtioTcpStream,\n-               RtioTcpStreamObject};\n+               RtioSocket,\n+               RtioTcpListener, RtioTcpListenerObject,\n+               RtioTcpAcceptor, RtioTcpAcceptorObject,\n+               RtioTcpStream, RtioTcpStreamObject};\n use rt::local::Local;\n \n pub struct TcpStream(~RtioTcpStreamObject);\n@@ -124,13 +125,27 @@ impl TcpListener {\n     }\n }\n \n-impl Listener<TcpStream> for TcpListener {\n+impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n+    fn listen(self) -> Option<TcpAcceptor> {\n+        match (**self).listen() {\n+            Ok(acceptor) => Some(TcpAcceptor(acceptor)),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+pub struct TcpAcceptor(~RtioTcpAcceptorObject);\n+\n+impl Acceptor<TcpStream> for TcpAcceptor {\n     fn accept(&mut self) -> Option<TcpStream> {\n         match (**self).accept() {\n             Ok(s) => Some(TcpStream::new(s)),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n-                return None;\n+                None\n             }\n         }\n     }\n@@ -184,8 +199,8 @@ mod test {\n             let addr = next_test_ip4();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n@@ -204,8 +219,8 @@ mod test {\n             let addr = next_test_ip6();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 stream.read(buf);\n                 assert!(buf[0] == 99);\n@@ -224,8 +239,8 @@ mod test {\n             let addr = next_test_ip4();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n@@ -244,8 +259,8 @@ mod test {\n             let addr = next_test_ip6();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n@@ -265,8 +280,8 @@ mod test {\n             let addr = next_test_ip4();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n@@ -288,8 +303,8 @@ mod test {\n             let addr = next_test_ip6();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let mut buf = [0];\n                 let nread = stream.read(buf);\n                 assert!(nread.is_none());\n@@ -311,8 +326,8 @@ mod test {\n             let addr = next_test_ip4();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n                     let mut stop = false;\n@@ -341,8 +356,8 @@ mod test {\n             let addr = next_test_ip6();\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                let mut stream = acceptor.accept();\n                 let buf = [0];\n                 loop {\n                     let mut stop = false;\n@@ -371,9 +386,8 @@ mod test {\n             let max = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                do max.times {\n-                    let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert_eq!(buf[0], 99);\n@@ -396,9 +410,8 @@ mod test {\n             let max = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                do max.times {\n-                    let mut stream = listener.accept();\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for ref mut stream in acceptor.incoming().take(max) {\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert_eq!(buf[0], 99);\n@@ -421,10 +434,9 @@ mod test {\n             static MAX: int = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                for i in range(0, MAX) {\n-                    let stream = Cell::new(listener.accept());\n-                    rtdebug!(\"accepted\");\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n                         let mut stream = stream.take();\n@@ -460,10 +472,9 @@ mod test {\n             static MAX: int = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                for i in range(0, MAX) {\n-                    let stream = Cell::new(listener.accept());\n-                    rtdebug!(\"accepted\");\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask {\n                         let mut stream = stream.take();\n@@ -499,10 +510,9 @@ mod test {\n             static MAX: int = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                for _ in range(0, MAX) {\n-                    let stream = Cell::new(listener.accept());\n-                    rtdebug!(\"accepted\");\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for stream in acceptor.incoming().take(MAX as uint) {\n+                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n                         let mut stream = stream.take();\n@@ -537,10 +547,9 @@ mod test {\n             static MAX: int = 10;\n \n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n-                for _ in range(0, MAX) {\n-                    let stream = Cell::new(listener.accept());\n-                    rtdebug!(\"accepted\");\n+                let mut acceptor = TcpListener::bind(addr).listen();\n+                for stream in acceptor.incoming().take(MAX as uint) {\n+                    let stream = Cell::new(stream);\n                     // Start another task to handle the connection\n                     do spawntask_later {\n                         let mut stream = stream.take();\n@@ -573,10 +582,7 @@ mod test {\n     fn socket_name(addr: SocketAddr) {\n         do run_in_newsched_task {\n             do spawntask {\n-                let listener = TcpListener::bind(addr);\n-\n-                assert!(listener.is_some());\n-                let mut listener = listener.unwrap();\n+                let mut listener = TcpListener::bind(addr).unwrap();\n \n                 // Make sure socket_name gives\n                 // us the socket we binded to.\n@@ -592,9 +598,9 @@ mod test {\n     fn peer_name(addr: SocketAddr) {\n         do run_in_newsched_task {\n             do spawntask {\n-                let mut listener = TcpListener::bind(addr);\n+                let mut acceptor = TcpListener::bind(addr).listen();\n \n-                listener.accept();\n+                acceptor.accept();\n             }\n \n             do spawntask {"}, {"sha": "1771a963ba78cdf6dacb6b49aa3bf905e37eed84", "filename": "src/libstd/rt/io/net/unix.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Funix.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -40,6 +40,12 @@ impl UnixListener {\n     }\n }\n \n-impl Listener<UnixStream> for UnixListener {\n+impl Listener<UnixStream, UnixAcceptor> for UnixListener {\n+    fn listen(self) -> Option<UnixAcceptor> { fail!() }\n+}\n+\n+pub struct UnixAcceptor;\n+\n+impl Acceptor<UnixStream> for UnixAcceptor {\n     fn accept(&mut self) -> Option<UnixStream> { fail!() }\n }"}, {"sha": "098433f299c1744041bf743a435290fb38faa53b", "filename": "src/libstd/rt/io/option.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fio%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Foption.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -17,7 +17,7 @@\n //! # XXX Seek and Close\n \n use option::*;\n-use super::{Reader, Writer, Listener};\n+use super::{Reader, Writer, Listener, Acceptor};\n use super::{standard_error, PreviousIoError, io_error, read_error, IoError};\n \n fn prev_io_error() -> IoError {\n@@ -62,10 +62,22 @@ impl<R: Reader> Reader for Option<R> {\n     }\n }\n \n-impl<L: Listener<S>, S> Listener<S> for Option<L> {\n-    fn accept(&mut self) -> Option<S> {\n+impl<T, A: Acceptor<T>, L: Listener<T, A>> Listener<T, A> for Option<L> {\n+    fn listen(self) -> Option<A> {\n+        match self {\n+            Some(listener) => listener.listen(),\n+            None => {\n+                io_error::cond.raise(prev_io_error());\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl<T, A: Acceptor<T>> Acceptor<T> for Option<A> {\n+    fn accept(&mut self) -> Option<T> {\n         match *self {\n-            Some(ref mut listener) => listener.accept(),\n+            Some(ref mut acceptor) => acceptor.accept(),\n             None => {\n                 io_error::cond.raise(prev_io_error());\n                 None"}, {"sha": "6f1b33d1e219fc6b0dcd84a40410effc0baef5b0", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -26,6 +26,7 @@ pub type EventLoopObject = uvio::UvEventLoop;\n pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n+pub type RtioTcpAcceptorObject = uvio::UvTcpAcceptor;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n@@ -75,6 +76,10 @@ pub trait IoFactory {\n }\n \n pub trait RtioTcpListener : RtioSocket {\n+    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError>;\n+}\n+\n+pub trait RtioTcpAcceptor : RtioSocket {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n     fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;"}, {"sha": "e37dfba0cc192c9f0ad4b217a26dd982deeb925e", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 118, "deletions": 99, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4e943881fc93136c4b6ad80f23aead9fee9d1b/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=3c4e943881fc93136c4b6ad80f23aead9fee9d1b", "patch": "@@ -26,6 +26,7 @@ use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::tube::Tube;\n+use rt::task::SchedHome;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n@@ -47,76 +48,80 @@ use task;\n // XXX we should not be calling uvll functions in here.\n \n trait HomingIO {\n+\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n+\n     /* XXX This will move pinned tasks to do IO on the proper scheduler\n      * and then move them back to their home.\n      */\n-    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n-        use rt::sched::{PinnedTask, TaskFromFriend};\n-        // go home\n-        let old_home = Cell::new_empty();\n-        let old_home_ptr = &old_home;\n+    fn go_to_IO_home(&mut self) -> SchedHome {\n+        use rt::sched::PinnedTask;\n+\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                // get the old home first\n-                do task.wake().map_move |mut task| {\n-                    old_home_ptr.put_back(task.take_unwrap_home());\n-                    self.home().send(PinnedTask(task));\n-                };\n+            let mut old = None;\n+            {\n+                let ptr = &mut old;\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    /* FIXME(#8674) if the task was already killed then wake\n+                     * will return None. In that case, the home pointer will never be set.\n+                     *\n+                     * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n+                     */\n+                    do task.wake().map_move |mut task| {\n+                        *ptr = Some(task.take_unwrap_home());\n+                        self.home().send(PinnedTask(task));\n+                    };\n+                }\n             }\n+            old.expect(\"No old home because task had already been killed.\")\n         }\n+    }\n \n-        // do IO\n-        let a = io(self);\n+    // XXX dummy self param\n+    fn restore_original_home(_dummy_self: Option<Self>, old: SchedHome) {\n+        use rt::sched::TaskFromFriend;\n \n-        // unhome home\n+        let old = Cell::new(old);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+                /* FIXME(#8674) if the task was already killed then wake\n+                 * will return None. In that case, the home pointer will never be restored.\n+                 *\n+                 * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n+                 */\n                 do task.wake().map_move |mut task| {\n-                    task.give_home(old_home.take());\n+                    task.give_home(old.take());\n                     scheduler.make_handle().send(TaskFromFriend(task));\n                 };\n             }\n         }\n-\n-        // return the result of the IO\n-        a\n     }\n \n-    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n-        use rt::sched::{PinnedTask, TaskFromFriend};\n-\n-        do task::unkillable { // FIXME(#8674)\n-            // go home\n-            let old_home = Cell::new_empty();\n-            let old_home_ptr = &old_home;\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                // get the old home first\n-                do task.wake().map_move |mut task| {\n-                    old_home_ptr.put_back(task.take_unwrap_home());\n-                    self.home().send(PinnedTask(task));\n-                };\n-            }\n+    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = io(self); // do IO\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return the result of the IO\n+    }\n \n-            // do IO\n-            let scheduler: ~Scheduler = Local::take();\n-            let a = io_sched(self, scheduler);\n+    fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n+        let mut this = self;\n+        let home = this.go_to_IO_home();\n+        let a = io(this); // do IO\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return the result of the IO\n+    }\n \n-            // unhome home\n+    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                do task.wake().map_move |mut task| {\n-                    task.give_home(old_home.take());\n-                    scheduler.make_handle().send(TaskFromFriend(task));\n-                };\n-            }\n-\n-            // return the result of the IO\n-            a\n-        }\n+            io_sched(self, scheduler) // do IO and scheduling action\n+        };\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return result of IO\n     }\n }\n \n@@ -594,9 +599,7 @@ impl IoFactory for UvIoFactory {\n }\n \n pub struct UvTcpListener {\n-    watcher: TcpWatcher,\n-    listening: bool,\n-    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    watcher : TcpWatcher,\n     home: SchedHandle,\n }\n \n@@ -606,15 +609,8 @@ impl HomingIO for UvTcpListener {\n \n impl UvTcpListener {\n     fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n-        UvTcpListener {\n-            watcher: watcher,\n-            listening: false,\n-            incoming_streams: Tube::new(),\n-            home: home,\n-        }\n+        UvTcpListener { watcher: watcher, home: home }\n     }\n-\n-    fn watcher(&self) -> TcpWatcher { self.watcher }\n }\n \n impl Drop for UvTcpListener {\n@@ -623,10 +619,10 @@ impl Drop for UvTcpListener {\n         let self_ = unsafe { transmute::<&UvTcpListener, &mut UvTcpListener>(self) };\n         do self_.home_for_io_with_sched |self_, scheduler| {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do self_.watcher().as_stream().close {\n+                let task = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n                     let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    scheduler.resume_blocked_task_immediately(task.take());\n                 }\n             }\n         }\n@@ -636,50 +632,71 @@ impl Drop for UvTcpListener {\n impl RtioSocket for UvTcpListener {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n         do self.home_for_io |self_| {\n-          socket_name(Tcp, self_.watcher)\n+            socket_name(Tcp, self_.watcher)\n         }\n     }\n }\n \n impl RtioTcpListener for UvTcpListener {\n-\n-    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n-        do self.home_for_io |self_| {\n-\n-            if !self_.listening {\n-                self_.listening = true;\n-\n-                let incoming_streams_cell = Cell::new(self_.incoming_streams.clone());\n-\n-                do self_.watcher().listen |mut server, status| {\n-                    let stream = match status {\n+    fn listen(self) -> Result<~RtioTcpAcceptorObject, IoError> {\n+        do self.home_for_io_consume |self_| {\n+            let mut acceptor = ~UvTcpAcceptor::new(self_);\n+            let incoming = Cell::new(acceptor.incoming.clone());\n+            do acceptor.listener.watcher.listen |mut server, status| {\n+                do incoming.with_mut_ref |incoming| {\n+                    let inc = match status {\n                         Some(_) => Err(standard_error(OtherIoError)),\n                         None => {\n-                            let client = TcpWatcher::new(&server.event_loop());\n-                            // XXX: needs to be surfaced in interface\n-                            server.accept(client.as_stream());\n+                            let inc = TcpWatcher::new(&server.event_loop());\n+                            // first accept call in the callback guarenteed to succeed\n+                            server.accept(inc.as_stream());\n                             let home = get_handle_to_current_scheduler!();\n-                            Ok(~UvTcpStream { watcher: client, home: home })\n+                            Ok(~UvTcpStream { watcher: inc, home: home })\n                         }\n                     };\n-\n-                    let mut incoming_streams = incoming_streams_cell.take();\n-                    incoming_streams.send(stream);\n-                    incoming_streams_cell.put_back(incoming_streams);\n+                    incoming.send(inc);\n                 }\n+            };\n+            Ok(acceptor)\n+        }\n+    }\n+}\n \n-            }\n-            self_.incoming_streams.recv()\n+pub struct UvTcpAcceptor {\n+    listener: UvTcpListener,\n+    incoming: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+}\n+\n+impl HomingIO for UvTcpAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}\n+\n+impl UvTcpAcceptor {\n+    fn new(listener: UvTcpListener) -> UvTcpAcceptor {\n+        UvTcpAcceptor { listener: listener, incoming: Tube::new() }\n+    }\n+}\n+\n+impl RtioSocket for UvTcpAcceptor {\n+    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.listener.watcher)\n         }\n     }\n+}\n+\n+impl RtioTcpAcceptor for UvTcpAcceptor {\n+    fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n+        self.incoming.recv()\n+    }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 1 as c_int)\n+                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 1 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher(), r) {\n+            match status_to_maybe_uv_error(self_.listener.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -689,10 +706,10 @@ impl RtioTcpListener for UvTcpListener {\n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n-                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 0 as c_int)\n+                uvll::tcp_simultaneous_accepts(self_.listener.watcher.native_handle(), 0 as c_int)\n             };\n \n-            match status_to_maybe_uv_error(self_.watcher(), r) {\n+            match status_to_maybe_uv_error(self_.listener.watcher, r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n                 None => Ok(())\n             }\n@@ -1435,8 +1452,9 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask {\n             unsafe {\n                 let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let listener = (*io).tcp_bind(addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                let mut stream = acceptor.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -1493,11 +1511,10 @@ fn test_simple_tcp_server_and_client_on_diff_threads() {\n         };\n \n         let server_fn: ~fn() = || {\n-            let io: *mut IoFactoryObject = unsafe {\n-                Local::unsafe_borrow()\n-            };\n-            let mut listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n-            let mut stream = listener.accept().unwrap();\n+            let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n+            let listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n+            let mut acceptor = listener.listen().unwrap();\n+            let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n             let nread = stream.read(buf).unwrap();\n             assert_eq!(nread, 8);\n@@ -1578,8 +1595,9 @@ fn test_read_and_block() {\n \n         do spawntask {\n             let io: *mut IoFactoryObject = unsafe { Local::unsafe_borrow() };\n-            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n-            let mut stream = listener.accept().unwrap();\n+            let listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n+            let mut acceptor = listener.listen().unwrap();\n+            let mut stream = acceptor.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -1634,8 +1652,9 @@ fn test_read_read_read() {\n         do spawntask {\n             unsafe {\n                 let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-                let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let listener = (*io).tcp_bind(addr).unwrap();\n+                let mut acceptor = listener.listen().unwrap();\n+                let mut stream = acceptor.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {"}]}