{"sha": "06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZmMzOWY5MDUyNjFkMmU1ZThmNjBiNGI4Y2MxZTExZGI5Y2YxNzc=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-03-05T11:54:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-05T11:54:50Z"}, "message": "Merge pull request #3424 from Xanewok/modified-lines-for-stdin\n\nSupport EmitMode::ModifiedLines with stdin input", "tree": {"sha": "ea52e3a14f6953a1de2a9687516642590d36fa89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea52e3a14f6953a1de2a9687516642590d36fa89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcfmOKCRBK7hj4Ov3rIwAAdHIIAALsJgaj1e7JcwdQKz19ufym\njEHlOSwJeZnWTqqOfnnNOZ+HmVOEh25g1Ev5vv4tq18khcp7c/2beEofUh619MXB\nD28Ce1YLZm1YoS/GbHsx2d/1OOuOBIxSo0ZSYTP/he1qzylrCy5kZy+/yAetwVm5\nCY72Aez1WKTsHeR76pySvthVN6uzmU84rO8nr5IFSv0vZ1228FCO3cny0gOfGCNR\nvBXOirjREmAwrAbkm/Wp+KlKcF+F/EVoVbKVR0tTtLtm+Pa6mM4GcdCHfbTEczJc\new1QuaJEIS875B0/Ze4suF1F7hPu1eObXYIclJMZwktkDATGCAoBM1f3fUZa2Is=\n=FEMf\n-----END PGP SIGNATURE-----\n", "payload": "tree ea52e3a14f6953a1de2a9687516642590d36fa89\nparent a4da1e94663e12d87495209966fa3ae975d32876\nparent fbfda614be1f666a57e44ae2f981b0ff0ef64c5b\nauthor Seiichi Uchida <seuchida@gmail.com> 1551786890 +0900\ncommitter GitHub <noreply@github.com> 1551786890 +0900\n\nMerge pull request #3424 from Xanewok/modified-lines-for-stdin\n\nSupport EmitMode::ModifiedLines with stdin input"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "html_url": "https://github.com/rust-lang/rust/commit/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4da1e94663e12d87495209966fa3ae975d32876", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4da1e94663e12d87495209966fa3ae975d32876", "html_url": "https://github.com/rust-lang/rust/commit/a4da1e94663e12d87495209966fa3ae975d32876"}, {"sha": "fbfda614be1f666a57e44ae2f981b0ff0ef64c5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbfda614be1f666a57e44ae2f981b0ff0ef64c5b", "html_url": "https://github.com/rust-lang/rust/commit/fbfda614be1f666a57e44ae2f981b0ff0ef64c5b"}], "stats": {"total": 316, "additions": 227, "deletions": 89}, "files": [{"sha": "9ec887ebbdff17ccfe626bea40de63ea2d6c0653", "filename": "src/formatting.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "patch": "@@ -181,15 +181,20 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         self.report\n             .add_non_formatted_ranges(visitor.skipped_range.clone());\n \n-        self.handler\n-            .handle_formatted_file(path, visitor.buffer.to_owned(), &mut self.report)\n+        self.handler.handle_formatted_file(\n+            self.parse_session.source_map(),\n+            path,\n+            visitor.buffer.to_owned(),\n+            &mut self.report,\n+        )\n     }\n }\n \n // Handle the results of formatting.\n trait FormatHandler {\n     fn handle_formatted_file(\n         &mut self,\n+        source_map: &SourceMap,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n@@ -200,13 +205,14 @@ impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n     // Called for each formatted file.\n     fn handle_formatted_file(\n         &mut self,\n+        source_map: &SourceMap,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n     ) -> Result<(), ErrorKind> {\n         if let Some(ref mut out) = self.out {\n-            match source_file::write_file(&result, &path, out, &self.config) {\n-                Ok(b) if b => report.add_diff(),\n+            match source_file::write_file(Some(source_map), &path, &result, out, &self.config) {\n+                Ok(has_diff) if has_diff => report.add_diff(),\n                 Err(e) => {\n                     // Create a new error with path_str to help users see which files failed\n                     let err_msg = format!(\"{}: {}\", path, e);\n@@ -299,7 +305,7 @@ impl FormattingError {\n \n pub(crate) type FormatErrorMap = HashMap<FileName, Vec<FormattingError>>;\n \n-#[derive(Default, Debug)]\n+#[derive(Default, Debug, PartialEq)]\n pub(crate) struct ReportedErrors {\n     // Encountered e.g., an IO error.\n     pub(crate) has_operational_errors: bool,\n@@ -332,25 +338,6 @@ impl ReportedErrors {\n     }\n }\n \n-/// A single span of changed lines, with 0 or more removed lines\n-/// and a vector of 0 or more inserted lines.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModifiedChunk {\n-    /// The first to be removed from the original text\n-    pub line_number_orig: u32,\n-    /// The number of lines which have been replaced\n-    pub lines_removed: u32,\n-    /// The new lines\n-    pub lines: Vec<String>,\n-}\n-\n-/// Set of changed sections of a file.\n-#[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ModifiedLines {\n-    /// The set of changed chunks.\n-    pub chunks: Vec<ModifiedChunk>,\n-}\n-\n #[derive(Clone, Copy, Debug)]\n enum Timer {\n     Disabled,"}, {"sha": "53e74210ede764d5f7e56f018ce8d2ac77fb2b94", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "patch": "@@ -33,6 +33,8 @@ pub use crate::config::{\n     Range, Verbosity,\n };\n \n+pub use crate::rustfmt_diff::{ModifiedChunk, ModifiedLines};\n+\n #[macro_use]\n mod utils;\n "}, {"sha": "c83eb1080a630b9a9dc1afc5cb89268f024dd1a5", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 143, "deletions": 39, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "patch": "@@ -1,4 +1,5 @@\n use std::collections::VecDeque;\n+use std::fmt;\n use std::io;\n use std::io::Write;\n \n@@ -33,6 +34,116 @@ impl Mismatch {\n     }\n }\n \n+/// A single span of changed lines, with 0 or more removed lines\n+/// and a vector of 0 or more inserted lines.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ModifiedChunk {\n+    /// The first to be removed from the original text\n+    pub line_number_orig: u32,\n+    /// The number of lines which have been replaced\n+    pub lines_removed: u32,\n+    /// The new lines\n+    pub lines: Vec<String>,\n+}\n+\n+/// Set of changed sections of a file.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct ModifiedLines {\n+    /// The set of changed chunks.\n+    pub chunks: Vec<ModifiedChunk>,\n+}\n+\n+impl From<Vec<Mismatch>> for ModifiedLines {\n+    fn from(mismatches: Vec<Mismatch>) -> ModifiedLines {\n+        let chunks = mismatches.into_iter().map(|mismatch| {\n+            let lines = mismatch.lines.iter();\n+            let num_removed = lines\n+                .filter(|line| match line {\n+                    DiffLine::Resulting(_) => true,\n+                    _ => false,\n+                })\n+                .count();\n+\n+            let new_lines = mismatch.lines.into_iter().filter_map(|line| match line {\n+                DiffLine::Context(_) | DiffLine::Resulting(_) => None,\n+                DiffLine::Expected(str) => Some(str),\n+            });\n+\n+            ModifiedChunk {\n+                line_number_orig: mismatch.line_number_orig,\n+                lines_removed: num_removed as u32,\n+                lines: new_lines.collect(),\n+            }\n+        });\n+\n+        ModifiedLines {\n+            chunks: chunks.collect(),\n+        }\n+    }\n+}\n+\n+// Converts a `Mismatch` into a serialized form, which just includes\n+// enough information to modify the original file.\n+// Each section starts with a line with three integers, space separated:\n+//     lineno num_removed num_added\n+// followed by (`num_added`) lines of added text. The line numbers are\n+// relative to the original file.\n+impl fmt::Display for ModifiedLines {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for chunk in &self.chunks {\n+            writeln!(\n+                f,\n+                \"{} {} {}\",\n+                chunk.line_number_orig,\n+                chunk.lines_removed,\n+                chunk.lines.iter().count()\n+            )?;\n+\n+            for line in &chunk.lines {\n+                writeln!(f, \"{}\", line)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+// Allows to convert `Display`ed `ModifiedLines` back to the structural data.\n+impl std::str::FromStr for ModifiedLines {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<ModifiedLines, ()> {\n+        let mut chunks = vec![];\n+\n+        let mut lines = s.lines();\n+        while let Some(header) = lines.next() {\n+            let mut header = header.split_whitespace();\n+            let (orig, rem, new_lines) = match (header.next(), header.next(), header.next()) {\n+                (Some(orig), Some(removed), Some(added)) => (orig, removed, added),\n+                _ => return Err(()),\n+            };\n+            let (orig, rem, new_lines): (u32, u32, usize) =\n+                match (orig.parse(), rem.parse(), new_lines.parse()) {\n+                    (Ok(a), Ok(b), Ok(c)) => (a, b, c),\n+                    _ => return Err(()),\n+                };\n+            let lines = lines.by_ref().take(new_lines);\n+            let lines: Vec<_> = lines.map(ToOwned::to_owned).collect();\n+            if lines.len() != new_lines {\n+                return Err(());\n+            }\n+\n+            chunks.push(ModifiedChunk {\n+                line_number_orig: orig,\n+                lines_removed: rem,\n+                lines,\n+            });\n+        }\n+\n+        Ok(ModifiedLines { chunks })\n+    }\n+}\n+\n // This struct handles writing output to stdout and abstracts away the logic\n // of printing in color, if it's possible in the executing environment.\n pub struct OutputWriter {\n@@ -174,49 +285,11 @@ where\n     }\n }\n \n-/// Converts a `Mismatch` into a serialized form, which just includes\n-/// enough information to modify the original file.\n-/// Each section starts with a line with three integers, space separated:\n-///     lineno num_removed num_added\n-/// followed by (`num_added`) lines of added text. The line numbers are\n-/// relative to the original file.\n-pub fn output_modified<W>(mut out: W, diff: Vec<Mismatch>)\n-where\n-    W: Write,\n-{\n-    for mismatch in diff {\n-        let (num_removed, num_added) =\n-            mismatch\n-                .lines\n-                .iter()\n-                .fold((0, 0), |(rem, add), line| match *line {\n-                    DiffLine::Context(_) => panic!(\"No Context expected\"),\n-                    DiffLine::Expected(_) => (rem, add + 1),\n-                    DiffLine::Resulting(_) => (rem + 1, add),\n-                });\n-        // Write a header with enough information to separate the modified lines.\n-        writeln!(\n-            out,\n-            \"{} {} {}\",\n-            mismatch.line_number_orig, num_removed, num_added\n-        )\n-        .unwrap();\n-\n-        for line in mismatch.lines {\n-            match line {\n-                DiffLine::Context(_) | DiffLine::Resulting(_) => (),\n-                DiffLine::Expected(ref str) => {\n-                    writeln!(out, \"{}\", str).unwrap();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use super::DiffLine::*;\n     use super::{make_diff, Mismatch};\n+    use super::{ModifiedChunk, ModifiedLines};\n \n     #[test]\n     fn diff_simple() {\n@@ -298,4 +371,35 @@ mod test {\n             }]\n         );\n     }\n+\n+    #[test]\n+    fn modified_lines_from_str() {\n+        use std::str::FromStr;\n+\n+        let src = \"1 6 2\\nfn some() {}\\nfn main() {}\\n25 3 1\\n  struct Test {}\";\n+        let lines = ModifiedLines::from_str(src).unwrap();\n+        assert_eq!(\n+            lines,\n+            ModifiedLines {\n+                chunks: vec![\n+                    ModifiedChunk {\n+                        line_number_orig: 1,\n+                        lines_removed: 6,\n+                        lines: vec![\"fn some() {}\".to_owned(), \"fn main() {}\".to_owned(),]\n+                    },\n+                    ModifiedChunk {\n+                        line_number_orig: 25,\n+                        lines_removed: 3,\n+                        lines: vec![\"  struct Test {}\".to_owned()]\n+                    }\n+                ]\n+            }\n+        );\n+\n+        let src = \"1 5 3\";\n+        assert_eq!(ModifiedLines::from_str(src), Err(()));\n+\n+        let src = \"1 5 3\\na\\nb\";\n+        assert_eq!(ModifiedLines::from_str(src), Err(()));\n+    }\n }"}, {"sha": "a779c4dfbe27f23bbda393400c44283356d2cae8", "filename": "src/source_file.rs", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_file.rs?ref=06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "patch": "@@ -1,9 +1,12 @@\n use std::fs;\n use std::io::{self, Write};\n+use std::path::Path;\n+\n+use syntax::source_map::SourceMap;\n \n use crate::checkstyle::output_checkstyle_file;\n use crate::config::{Config, EmitMode, FileName, Verbosity};\n-use crate::rustfmt_diff::{make_diff, output_modified, print_diff};\n+use crate::rustfmt_diff::{make_diff, print_diff, ModifiedLines};\n \n #[cfg(test)]\n use crate::formatting::FileRecord;\n@@ -26,7 +29,7 @@ where\n         write!(out, \"{}\", crate::checkstyle::header())?;\n     }\n     for &(ref filename, ref text) in source_file {\n-        write_file(text, filename, out, config)?;\n+        write_file(None, filename, text, out, config)?;\n     }\n     if config.emit_mode() == EmitMode::Checkstyle {\n         write!(out, \"{}\", crate::checkstyle::footer())?;\n@@ -36,24 +39,46 @@ where\n }\n \n pub fn write_file<T>(\n-    formatted_text: &str,\n+    source_map: Option<&SourceMap>,\n     filename: &FileName,\n+    formatted_text: &str,\n     out: &mut T,\n     config: &Config,\n ) -> Result<bool, io::Error>\n where\n     T: Write,\n {\n-    let filename_to_path = || match *filename {\n-        FileName::Real(ref path) => path,\n-        _ => panic!(\"cannot format `{}` and emit to files\", filename),\n+    fn ensure_real_path(filename: &FileName) -> &Path {\n+        match *filename {\n+            FileName::Real(ref path) => path,\n+            _ => panic!(\"cannot format `{}` and emit to files\", filename),\n+        }\n+    }\n+\n+    impl From<&FileName> for syntax_pos::FileName {\n+        fn from(filename: &FileName) -> syntax_pos::FileName {\n+            match filename {\n+                FileName::Real(path) => syntax_pos::FileName::Real(path.to_owned()),\n+                FileName::Stdin => syntax_pos::FileName::Custom(\"stdin\".to_owned()),\n+            }\n+        }\n+    }\n+\n+    // If parse session is around (cfg(not(test))) then try getting source from\n+    // there instead of hitting the file system. This also supports getting\n+    // original text for `FileName::Stdin`.\n+    let original_text = source_map\n+        .and_then(|x| x.get_source_file(&filename.into()))\n+        .and_then(|x| x.src.as_ref().map(|x| x.to_string()));\n+    let original_text = match original_text {\n+        Some(ori) => ori,\n+        None => fs::read_to_string(ensure_real_path(filename))?,\n     };\n \n     match config.emit_mode() {\n         EmitMode::Files if config.make_backup() => {\n-            let filename = filename_to_path();\n-            let ori = fs::read_to_string(filename)?;\n-            if ori != formatted_text {\n+            let filename = ensure_real_path(filename);\n+            if original_text != formatted_text {\n                 // Do a little dance to make writing safer - write to a temp file\n                 // rename the original to a .bk, then rename the temp file to the\n                 // original.\n@@ -67,9 +92,9 @@ where\n         }\n         EmitMode::Files => {\n             // Write text directly over original file if there is a diff.\n-            let filename = filename_to_path();\n-            let ori = fs::read_to_string(filename)?;\n-            if ori != formatted_text {\n+            let filename = ensure_real_path(filename);\n+\n+            if original_text != formatted_text {\n                 fs::write(filename, formatted_text)?;\n             }\n         }\n@@ -80,27 +105,23 @@ where\n             write!(out, \"{}\", formatted_text)?;\n         }\n         EmitMode::ModifiedLines => {\n-            let filename = filename_to_path();\n-            let ori = fs::read_to_string(filename)?;\n-            let mismatch = make_diff(&ori, formatted_text, 0);\n+            let mismatch = make_diff(&original_text, formatted_text, 0);\n             let has_diff = !mismatch.is_empty();\n-            output_modified(out, mismatch);\n+            write!(out, \"{}\", ModifiedLines::from(mismatch))?;\n             return Ok(has_diff);\n         }\n         EmitMode::Checkstyle => {\n-            let filename = filename_to_path();\n-            let ori = fs::read_to_string(filename)?;\n-            let diff = make_diff(&ori, formatted_text, 3);\n+            let filename = ensure_real_path(filename);\n+\n+            let diff = make_diff(&original_text, formatted_text, 3);\n             output_checkstyle_file(out, filename, diff)?;\n         }\n         EmitMode::Diff => {\n-            let filename = filename_to_path();\n-            let ori = fs::read_to_string(filename)?;\n-            let mismatch = make_diff(&ori, formatted_text, 3);\n+            let mismatch = make_diff(&original_text, formatted_text, 3);\n             let has_diff = !mismatch.is_empty();\n             print_diff(\n                 mismatch,\n-                |line_num| format!(\"Diff in {} at line {}:\", filename.display(), line_num),\n+                |line_num| format!(\"Diff in {} at line {}:\", filename, line_num),\n                 config,\n             );\n             return Ok(has_diff);"}, {"sha": "1992190bb62e20f627084444ee8737f87d34d793", "filename": "src/test/mod.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06fc39f905261d2e5e8f60b4b8cc1e11db9cf177/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=06fc39f905261d2e5e8f60b4b8cc1e11db9cf177", "patch": "@@ -8,9 +8,9 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str::Chars;\n \n-use crate::config::{Color, Config, EmitMode, FileName, ReportTactic};\n-use crate::formatting::{ModifiedChunk, SourceFile};\n-use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, OutputWriter};\n+use crate::config::{Color, Config, EmitMode, FileName, NewlineStyle, ReportTactic};\n+use crate::formatting::{ReportedErrors, SourceFile};\n+use crate::rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, ModifiedChunk, OutputWriter};\n use crate::source_file;\n use crate::{FormatReport, Input, Session};\n \n@@ -290,6 +290,30 @@ fn stdin_parser_panic_caught() {\n     }\n }\n \n+/// Ensures that `EmitMode::ModifiedLines` works with input from `stdin`. Useful\n+/// when embedding Rustfmt (e.g. inside RLS).\n+#[test]\n+fn stdin_works_with_modified_lines() {\n+    let input = \"\\nfn\\n some( )\\n{\\n}\\nfn main () {}\\n\";\n+    let output = \"1 6 2\\nfn some() {}\\nfn main() {}\\n\";\n+\n+    let input = Input::Text(input.to_owned());\n+    let mut config = Config::default();\n+    config.set().newline_style(NewlineStyle::Unix);\n+    config.set().emit_mode(EmitMode::ModifiedLines);\n+    let mut buf: Vec<u8> = vec![];\n+    {\n+        let mut session = Session::new(config, Some(&mut buf));\n+        session.format(input).unwrap();\n+        let errors = ReportedErrors {\n+            has_diff: true,\n+            ..Default::default()\n+        };\n+        assert_eq!(session.errors, errors);\n+    }\n+    assert_eq!(buf, output.as_bytes());\n+}\n+\n #[test]\n fn stdin_disable_all_formatting_test() {\n     match option_env!(\"CFG_RELEASE_CHANNEL\") {"}]}