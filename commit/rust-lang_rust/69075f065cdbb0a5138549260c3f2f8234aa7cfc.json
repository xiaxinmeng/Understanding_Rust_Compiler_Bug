{"sha": "69075f065cdbb0a5138549260c3f2f8234aa7cfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5MDc1ZjA2NWNkYmIwYTUxMzg1NDkyNjBjM2YyZjgyMzRhYTdjZmM=", "commit": {"author": {"name": "Josh White", "email": "jwhite927@gmail.com", "date": "2020-02-08T04:56:44Z"}, "committer": {"name": "Josh White", "email": "jwhite927@gmail.com", "date": "2020-02-08T04:56:44Z"}, "message": "Merge branch 'master' of https://github.com/jwhite927/rust into E0637", "tree": {"sha": "e318c22f9a55a89626f70e02753928377a0a2a6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e318c22f9a55a89626f70e02753928377a0a2a6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69075f065cdbb0a5138549260c3f2f8234aa7cfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69075f065cdbb0a5138549260c3f2f8234aa7cfc", "html_url": "https://github.com/rust-lang/rust/commit/69075f065cdbb0a5138549260c3f2f8234aa7cfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69075f065cdbb0a5138549260c3f2f8234aa7cfc/comments", "author": {"login": "jwhite927", "id": 48882175, "node_id": "MDQ6VXNlcjQ4ODgyMTc1", "avatar_url": "https://avatars.githubusercontent.com/u/48882175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwhite927", "html_url": "https://github.com/jwhite927", "followers_url": "https://api.github.com/users/jwhite927/followers", "following_url": "https://api.github.com/users/jwhite927/following{/other_user}", "gists_url": "https://api.github.com/users/jwhite927/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwhite927/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwhite927/subscriptions", "organizations_url": "https://api.github.com/users/jwhite927/orgs", "repos_url": "https://api.github.com/users/jwhite927/repos", "events_url": "https://api.github.com/users/jwhite927/events{/privacy}", "received_events_url": "https://api.github.com/users/jwhite927/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwhite927", "id": 48882175, "node_id": "MDQ6VXNlcjQ4ODgyMTc1", "avatar_url": "https://avatars.githubusercontent.com/u/48882175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwhite927", "html_url": "https://github.com/jwhite927", "followers_url": "https://api.github.com/users/jwhite927/followers", "following_url": "https://api.github.com/users/jwhite927/following{/other_user}", "gists_url": "https://api.github.com/users/jwhite927/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwhite927/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwhite927/subscriptions", "organizations_url": "https://api.github.com/users/jwhite927/orgs", "repos_url": "https://api.github.com/users/jwhite927/repos", "events_url": "https://api.github.com/users/jwhite927/events{/privacy}", "received_events_url": "https://api.github.com/users/jwhite927/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92fc98c695d133ae28fb9d386d22efef57e2fc87", "url": "https://api.github.com/repos/rust-lang/rust/commits/92fc98c695d133ae28fb9d386d22efef57e2fc87", "html_url": "https://github.com/rust-lang/rust/commit/92fc98c695d133ae28fb9d386d22efef57e2fc87"}, {"sha": "8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f", "html_url": "https://github.com/rust-lang/rust/commit/8498c5f5b02dbb4ed58a1eb4901b0b733342c35f"}], "stats": {"total": 4473, "additions": 3435, "deletions": 1038}, "files": [{"sha": "9aef3ebe637a1d1b325266165389786032876f93", "filename": ".github/ISSUE_TEMPLATE/blank_issue.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fblank_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,4 @@\n+---\n+name: Blank Issue\n+about: Create a blank issue.\n+---"}, {"sha": "5675579bc964a6aab3827db3b3c519c731f98143", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,44 @@\n+---\n+name: Bug Report\n+about: Create a bug report for Rust.\n+labels: C-bug\n+---\n+<!--\n+Thank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\n+along with any information you feel relevant to replicating the bug.\n+-->\n+\n+I tried this code:\n+\n+```rust\n+<code>\n+```\n+\n+I expected to see this happen: *explanation*\n+\n+Instead, this happened: *explanation*\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary>Backtrace</summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>"}, {"sha": "bd7dc0ac95c1fc6a4c96c7357315f779daf77aef", "filename": ".github/ISSUE_TEMPLATE/config.yml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fconfig.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fconfig.yml?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,5 @@\n+blank_issues_enabled: true\n+contact_links:\n+  - name: Rust Programming Language Forum\n+    url: https://users.rust-lang.org\n+    about: Please ask and answer questions about Rust here."}, {"sha": "e669e4912f8c95c2b54a6beea4d428407a2cbd18", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,52 @@\n+---\n+name: Internal Compiler Error\n+about: Create a report for an internal compiler error in rustc.\n+labels: C-bug, I-ICE, T-compiler\n+---\n+<!--\n+Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n+a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n+how to create smaller examples.\n+\n+http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n+\n+-->\n+\n+### Code\n+\n+```\n+<code>\n+```\n+\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+### Error output\n+\n+```\n+<output>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary><strong>Backtrace</strong></summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>\n+"}, {"sha": "f93591204cd98cbdff70b5c4341c60d56c105995", "filename": ".github/ISSUE_TEMPLATE/tracking_issue.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ftracking_issue.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,58 @@\n+---\n+name: Tracking Issue\n+about: A tracking issue for a feature in Rust.\n+title: Tracking Issue for XXX\n+labels: C-tracking-issue\n+---\n+<!--\n+Thank you for creating a tracking issue! \ud83d\udcdc Tracking issues are for tracking a\n+feature from implementation to stabilisation. Make sure to include the relevant\n+RFC for the feature if it has one. Otherwise provide a short summary of the\n+feature and link any relevant PRs or issues, and remove any sections that are\n+not relevant to the feature.\n+\n+Remember to add team labels to the tracking issue.\n+For a language team feature, this would e.g., be `T-lang`.\n+Such a feature should also be labeled with e.g., `F-my_feature`.\n+This label is used to associate issues (e.g., bugs and design questions) to the feature.\n+-->\n+\n+This is a tracking issue for the RFC \"XXX\" (rust-lang/rfcs#NNN).\n+The feature gate for the issue is `#![feature(FFF)]`.\n+\n+### About tracking issues\n+\n+Tracking issues are used to record the overall progress of implementation.\n+They are also uses as hubs connecting to other relevant issues, e.g., bugs or open design questions.\n+A tracking issue is however *not* meant for large scale discussion, questions, or bug reports about a feature.\n+Instead, open a dedicated issue for the specific matter and add the relevant feature gate label.\n+\n+### Steps\n+<!--\n+Include each step required to complete the feature. Typically this is a PR\n+implementing a feature, followed by a PR that stabilises the feature. However\n+for larger features an implementation could be broken up into multiple PRs.\n+-->\n+\n+- [ ] Implement the RFC (cc @rust-lang/XXX -- can anyone write up mentoring\n+      instructions?)\n+- [ ] Adjust documentation ([see instructions on rustc-guide][doc-guide])\n+- [ ] Stabilization PR ([see instructions on rustc-guide][stabilization-guide])\n+\n+[stabilization-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#stabilization-pr\n+[doc-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs\n+\n+### Unresolved Questions\n+<!--\n+Include any open questions that need to be answered before the feature can be\n+stabilised.\n+-->\n+\n+XXX --- list all the \"unresolved questions\" found in the RFC to ensure they are\n+not forgotten\n+\n+### Implementation history\n+\n+<!--\n+Include a list of all the PRs that were involved in implementing the feature.\n+-->"}, {"sha": "14797092475a296a37cf7ef92f35e2f2425e6cee", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -100,6 +100,7 @@ Graydon Hoare <graydon@pobox.com> Graydon Hoare <graydon@mozilla.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com>\n Guillaume Gomez <guillaume1.gomez@gmail.com> ggomez <ggomez@ggo.ifr.lan>\n Guillaume Gomez <guillaume1.gomez@gmail.com> Guillaume Gomez <ggomez@ggo.ifr.lan>\n+Hanna Kruppe <hanna.kruppe@gmail.com> <robin.kruppe@gmail.com>\n Heather <heather@cynede.net> <Cynede@Gentoo.org>\n Heather <heather@cynede.net> <Heather@cynede.net>\n Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtke@gmail.com>"}, {"sha": "bbfda0fa2c846f303ac68eda511049a74643c4cc", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3067,6 +3067,7 @@ name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n  \"clap\",\n+ \"codespan\",\n  \"codespan-reporting\",\n  \"failure\",\n  \"mdbook\","}, {"sha": "d12ee2935ebf587bb771a9cd869d885d080483b7", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -847,7 +847,13 @@ impl<'a> Builder<'a> {\n             rustflags.arg(\"-Zforce-unstable-if-unmarked\");\n         }\n \n-        rustflags.arg(\"-Zexternal-macro-backtrace\");\n+        // cfg(bootstrap): the flag was renamed from `-Zexternal-macro-backtrace`\n+        // to `-Zmacro-backtrace`, keep only the latter after beta promotion.\n+        if stage == 0 {\n+            rustflags.arg(\"-Zexternal-macro-backtrace\");\n+        } else {\n+            rustflags.arg(\"-Zmacro-backtrace\");\n+        }\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n "}, {"sha": "5bd60bc51efaec04e69e2e18b59678e2af066433", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1 +1 @@\n-Subproject commit 92baf7293dd2d418d2ac4b141b0faa822075d9f7\n+Subproject commit 5bd60bc51efaec04e69e2e18b59678e2af066433"}, {"sha": "8bc62418b3969c1e3c73d306571b81f10cf5f710", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -37,11 +37,11 @@ fn main() {\n         return \"foo\"\n     };\n \n-    match Pin::new(&mut generator).resume() {\n+    match Pin::new(&mut generator).resume(()) {\n         GeneratorState::Yielded(1) => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n-    match Pin::new(&mut generator).resume() {\n+    match Pin::new(&mut generator).resume(()) {\n         GeneratorState::Complete(\"foo\") => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n@@ -71,9 +71,9 @@ fn main() {\n     };\n \n     println!(\"1\");\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n     println!(\"3\");\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n     println!(\"5\");\n }\n ```\n@@ -92,10 +92,10 @@ The `Generator` trait in `std::ops` currently looks like:\n # use std::ops::GeneratorState;\n # use std::pin::Pin;\n \n-pub trait Generator {\n+pub trait Generator<R = ()> {\n     type Yield;\n     type Return;\n-    fn resume(self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>;\n+    fn resume(self: Pin<&mut Self>, resume: R) -> GeneratorState<Self::Yield, Self::Return>;\n }\n ```\n \n@@ -152,10 +152,6 @@ closure-like semantics. Namely:\n * Whenever a generator is dropped it will drop all captured environment\n   variables.\n \n-Note that unlike closures, generators at this time cannot take any arguments.\n-That is, generators must always look like `|| { ... }`. This restriction may be\n-lifted at a future date, the design is ongoing!\n-\n ### Generators as state machines\n \n In the compiler, generators are currently compiled as state machines. Each\n@@ -179,8 +175,8 @@ fn main() {\n         return ret\n     };\n \n-    Pin::new(&mut generator).resume();\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n+    Pin::new(&mut generator).resume(());\n }\n ```\n \n@@ -205,7 +201,7 @@ fn main() {\n             type Yield = i32;\n             type Return = &'static str;\n \n-            fn resume(mut self: Pin<&mut Self>) -> GeneratorState<i32, &'static str> {\n+            fn resume(mut self: Pin<&mut Self>, resume: ()) -> GeneratorState<i32, &'static str> {\n                 use std::mem;\n                 match mem::replace(&mut *self, __Generator::Done) {\n                     __Generator::Start(s) => {\n@@ -228,8 +224,8 @@ fn main() {\n         __Generator::Start(ret)\n     };\n \n-    Pin::new(&mut generator).resume();\n-    Pin::new(&mut generator).resume();\n+    Pin::new(&mut generator).resume(());\n+    Pin::new(&mut generator).resume(());\n }\n ```\n "}, {"sha": "28c683934d4ed10d0454f039418e7c2d2ed1b603", "filename": "src/doc/unstable-book/src/language-features/no-sanitize.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fno-sanitize.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,29 @@\n+# `no_sanitize`\n+\n+The tracking issue for this feature is: [#39699]\n+\n+[#39699]: https://github.com/rust-lang/rust/issues/39699\n+\n+------------------------\n+\n+The `no_sanitize` attribute can be used to selectively disable sanitizer\n+instrumentation in an annotated function. This might be useful to: avoid\n+instrumentation overhead in a performance critical function, or avoid\n+instrumenting code that contains constructs unsupported by given sanitizer.\n+\n+The precise effect of this annotation depends on particular sanitizer in use.\n+For example, with `no_sanitize(thread)`, the thread sanitizer will no longer\n+instrument non-atomic store / load operations, but it will instrument atomic\n+operations to avoid reporting false positives and provide meaning full stack\n+traces.\n+\n+## Examples\n+\n+``` rust\n+#![feature(no_sanitize)]\n+\n+#[no_sanitize(address)]\n+fn foo() {\n+  // ...\n+}\n+```"}, {"sha": "83cdebf0e3f4a7d89e5c6b7e30aac80d55b65185", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n+use std::ops::Bound::{Excluded, Unbounded};\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -200,3 +201,58 @@ pub fn first_and_last_100(b: &mut Bencher) {\n pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n+\n+#[bench]\n+pub fn range_excluded_excluded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first + 1..size {\n+                black_box(map.range((Excluded(first), Excluded(last))));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_excluded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range((Excluded(first), Unbounded)));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_included(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            for last in first..size {\n+                black_box(map.range(first..=last));\n+            }\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_included_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| {\n+        for first in 0..size {\n+            black_box(map.range(first..));\n+        }\n+    });\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    let size = 144;\n+    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+    b.iter(|| map.range(..));\n+}"}, {"sha": "d65aee09232807bec31eca96e521f31daf333f37", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1104,6 +1104,7 @@ impl<T: ?Sized> AsMut<T> for Box<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Box<T> {}\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n     type Yield = G::Yield;\n@@ -1114,6 +1115,7 @@ impl<G: ?Sized + Generator + Unpin> Generator for Box<G> {\n     }\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     type Yield = G::Yield;\n@@ -1124,6 +1126,28 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for Box<G> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume(Pin::new(&mut *self), arg)\n+    }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<Box<G>> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume((*self).as_mut(), arg)\n+    }\n+}\n+\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;"}, {"sha": "0b3f603686dc6e1e3f3ed996adf4568394a9e52b", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 26, "deletions": 40, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1861,65 +1861,51 @@ where\n     let mut max_node = root2;\n     let mut min_found = false;\n     let mut max_found = false;\n-    let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start_bound()) {\n-            (false, Included(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+        let front = match (min_found, range.start_bound()) {\n+            (false, Included(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&min_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(min_node, key) {\n+                Found(kv) => {\n                     min_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.len(),\n-            (true, Excluded(_)) => 0,\n+            (true, Included(_)) => min_node.last_edge(),\n+            (true, Excluded(_)) => min_node.first_edge(),\n+            (_, Unbounded) => min_node.first_edge(),\n         };\n \n-        let max_edge = match (max_found, range.end_bound()) {\n-            (false, Included(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+        let back = match (max_found, range.end_bound()) {\n+            (false, Included(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i + 1\n+                    kv.right_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (false, Excluded(key)) => match search::search_linear(&max_node, key) {\n-                (i, true) => {\n+            (false, Excluded(key)) => match search::search_node(max_node, key) {\n+                Found(kv) => {\n                     max_found = true;\n-                    i\n+                    kv.left_edge()\n                 }\n-                (i, false) => i,\n+                GoDown(edge) => edge,\n             },\n-            (_, Unbounded) => max_node.len(),\n-            (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.len(),\n+            (true, Included(_)) => max_node.first_edge(),\n+            (true, Excluded(_)) => max_node.last_edge(),\n+            (_, Unbounded) => max_node.last_edge(),\n         };\n \n-        if !diverged {\n-            if max_edge < min_edge {\n-                panic!(\"Ord is ill-defined in BTreeMap range\")\n-            }\n-            if min_edge != max_edge {\n-                diverged = true;\n-            }\n+        if front.partial_cmp(&back) == Some(Ordering::Greater) {\n+            panic!(\"Ord is ill-defined in BTreeMap range\");\n         }\n-\n-        // Safety guarantee: `min_edge` is always in range for `min_node`, because\n-        // `min_edge` is unconditionally calculated for each iteration's value of `min_node`,\n-        // either (if not found) as the edge index returned by `search_linear`,\n-        // or (if found) as the KV index returned by `search_linear`, possibly + 1.\n-        // Likewise for `max_node` versus `max_edge`.\n-        let front = unsafe { Handle::new_edge(min_node, min_edge) };\n-        let back = unsafe { Handle::new_edge(max_node, max_edge) };\n         match (front.force(), back.force()) {\n             (Leaf(f), Leaf(b)) => {\n                 return (f, b);"}, {"sha": "abf926186e82c1d3a12e16e874623d3890c7ddce", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -31,6 +31,7 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n+use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n use core::ptr::{self, NonNull, Unique};\n@@ -832,6 +833,14 @@ impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n     }\n }\n \n+impl<BorrowType, K, V, NodeType, HandleType> PartialOrd\n+    for Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        if self.node.node == other.node.node { Some(self.idx.cmp(&other.idx)) } else { None }\n+    }\n+}\n+\n impl<BorrowType, K, V, NodeType, HandleType>\n     Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType>\n {"}, {"sha": "2ba5cebbdee74f788da20f6f88b1092df21a24b3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,10 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n+/// Looks up a given key in a (sub)tree headed by the given node, recursively.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the possible leaf edge where the key\n+/// belongs.\n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     key: &Q,\n@@ -32,6 +36,10 @@ where\n     }\n }\n \n+/// Looks up a given key in a given node, without recursion.\n+/// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n+/// returns a `GoDown` with the handle of the edge where the key might be found.\n+/// If the node is a leaf, a `GoDown` edge is not an actual edge but a possible edge.\n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n@@ -50,8 +58,8 @@ where\n /// or could exist, and whether it exists in the node itself. If it doesn't\n /// exist in the node itself, it may exist in the subtree with that index\n /// (if the node has subtrees). If the key doesn't exist in node or subtree,\n-/// the returned index is the position or subtree to insert at.\n-pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n+/// the returned index is the position or subtree where the key belongs.\n+fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n     key: &Q,\n ) -> (usize, bool)"}, {"sha": "4e43561996c370ee7c151ef6f632925c7ac35d1a", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -50,11 +50,11 @@ pub enum GeneratorState<Y, R> {\n ///         return \"foo\"\n ///     };\n ///\n-///     match Pin::new(&mut generator).resume() {\n+///     match Pin::new(&mut generator).resume(()) {\n ///         GeneratorState::Yielded(1) => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n-///     match Pin::new(&mut generator).resume() {\n+///     match Pin::new(&mut generator).resume(()) {\n ///         GeneratorState::Complete(\"foo\") => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n@@ -67,7 +67,7 @@ pub enum GeneratorState<Y, R> {\n #[lang = \"generator\"]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n #[fundamental]\n-pub trait Generator {\n+pub trait Generator<#[cfg(not(bootstrap))] R = ()> {\n     /// The type of value this generator yields.\n     ///\n     /// This associated type corresponds to the `yield` expression and the\n@@ -110,9 +110,13 @@ pub trait Generator {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(self: Pin<&mut Self>) -> GeneratorState<Self::Yield, Self::Return>;\n+    fn resume(\n+        self: Pin<&mut Self>,\n+        #[cfg(not(bootstrap))] arg: R,\n+    ) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n     type Yield = G::Yield;\n@@ -123,6 +127,7 @@ impl<G: ?Sized + Generator> Generator for Pin<&mut G> {\n     }\n }\n \n+#[cfg(bootstrap)]\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n impl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n     type Yield = G::Yield;\n@@ -132,3 +137,25 @@ impl<G: ?Sized + Generator + Unpin> Generator for &mut G {\n         G::resume(Pin::new(&mut *self))\n     }\n }\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R>, R> Generator<R> for Pin<&mut G> {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume((*self).as_mut(), arg)\n+    }\n+}\n+\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"generator_trait\", issue = \"43122\")]\n+impl<G: ?Sized + Generator<R> + Unpin, R> Generator<R> for &mut G {\n+    type Yield = G::Yield;\n+    type Return = G::Return;\n+\n+    fn resume(mut self: Pin<&mut Self>, arg: R) -> GeneratorState<Self::Yield, Self::Return> {\n+        G::resume(Pin::new(&mut *self), arg)\n+    }\n+}"}, {"sha": "e35c91206b8d426a00b976d30f188c91b14e623a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -455,6 +455,12 @@ impl<T> Option<T> {\n     /// Applies a function to the contained value (if any),\n     /// or returns the provided default (if not).\n     ///\n+    /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`map_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n+    /// [`map_or_else`]: #method.map_or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "809d4bace8e845ae3b77f3d186f8933b12ba428c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -524,6 +524,12 @@ impl<T, E> Result<T, E> {\n     /// Applies a function to the contained value (if any),\n     /// or returns the provided default (if not).\n     ///\n+    /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n+    /// the result of a function call, it is recommended to use [`map_or_else`],\n+    /// which is lazily evaluated.\n+    ///\n+    /// [`map_or_else`]: #method.map_or_else\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "dd242686d26f202aa82c7cf7027b09f73e1d946f", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -127,7 +127,7 @@ macro_rules! arena_types {\n             [] tys: rustc::ty::TyS<$tcx>,\n \n             // HIR types\n-            [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n+            [few] hir_krate: rustc_hir::Crate<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n             [] attribute: syntax::ast::Attribute,\n             [] block: rustc_hir::Block<$tcx>,"}, {"sha": "29b94986a5f3a00b6effa877341231b78011b645", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -35,7 +35,7 @@\n //! \"infer\" some properties for each kind of `DepNode`:\n //!\n //! * Whether a `DepNode` of a given kind has any parameters at all. Some\n-//!   `DepNode`s, like `Krate`, represent global concepts with only one value.\n+//!   `DepNode`s, like `AllLocalTraitImpls`, represent global concepts with only one value.\n //! * Whether it is possible, in principle, to reconstruct a query key from a\n //!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n //!   in which case it is possible to map the node's fingerprint back to the\n@@ -400,19 +400,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n \n-    // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n-    // distinct from the krate module). This is basically a hash of\n-    // the entire krate, so if you read from `Krate` (e.g., by calling\n-    // `tcx.hir().krate()`), we will have to assume that any change\n-    // means that you need to be recompiled. This is because the\n-    // `Krate` value gives you access to all other items. To avoid\n-    // this fate, do not call `tcx.hir().krate()`; instead, prefer\n-    // wrappers like `tcx.visit_all_items_in_krate()`.  If there is no\n-    // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n-    // access to the krate, but you must remember to add suitable\n-    // edges yourself for the individual items that you read.\n-    [eval_always] Krate,\n-\n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n     [eval_always] HirBody(DefId),"}, {"sha": "4c922654e02d57bd7ca836a5d4d780eb15806e87", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -223,12 +223,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             (commandline_args_hash, crate_disambiguator.to_fingerprint()),\n         );\n \n-        let (_, crate_hash) = input_dep_node_and_hash(\n-            self.dep_graph,\n-            &mut self.hcx,\n-            DepNode::new_no_params(DepKind::Krate),\n-            crate_hash_input,\n-        );\n+        let mut stable_hasher = StableHasher::new();\n+        crate_hash_input.hash_stable(&mut self.hcx, &mut stable_hasher);\n+        let crate_hash: Fingerprint = stable_hasher.finish();\n \n         let svh = Svh::new(crate_hash.to_smaller_hash());\n         (self.map, svh)"}, {"sha": "c721faafbecaf408ea04765882477834001be719", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,7 +12,7 @@ pub fn check_crate(hir_map: &Map<'_>) {\n \n     let errors = Lock::new(Vec::new());\n \n-    par_iter(&hir_map.krate().modules).for_each(|(module_id, _)| {\n+    par_iter(&hir_map.krate.modules).for_each(|(module_id, _)| {\n         let local_def_id = hir_map.local_def_id(*module_id);\n         hir_map.visit_item_likes_in_module(\n             local_def_id,"}, {"sha": "1645420892a7531c7eebb061f989c4f66f06d0a9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 31, "deletions": 67, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -129,30 +129,6 @@ impl<'hir> Entry<'hir> {\n     }\n }\n \n-/// Stores a crate and any number of inlined items from other crates.\n-pub struct Forest<'hir> {\n-    krate: Crate<'hir>,\n-    pub dep_graph: DepGraph,\n-}\n-\n-impl Forest<'hir> {\n-    pub fn new(krate: Crate<'hir>, dep_graph: &DepGraph) -> Forest<'hir> {\n-        Forest { krate, dep_graph: dep_graph.clone() }\n-    }\n-\n-    pub fn krate(&self) -> &Crate<'hir> {\n-        self.dep_graph.read(DepNode::new_no_params(DepKind::Krate));\n-        &self.krate\n-    }\n-\n-    /// This is used internally in the dependency tracking system.\n-    /// Use the `krate` method to ensure your dependency on the\n-    /// crate is tracked.\n-    pub fn untracked_krate(&self) -> &Crate<'hir> {\n-        &self.krate\n-    }\n-}\n-\n /// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n /// but it is implemented as 2 layers of arrays.\n /// - first we have `A = IndexVec<DefIndex, B>` mapping `DefIndex`s to an inner value\n@@ -162,11 +138,8 @@ pub(super) type HirEntryMap<'hir> = IndexVec<DefIndex, IndexVec<ItemLocalId, Opt\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n-    /// The backing storage for all the AST nodes.\n-    pub forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n \n-    /// Same as the dep_graph in forest, just available with one fewer\n-    /// deref. This is a gratuitous micro-optimization.\n     pub dep_graph: DepGraph,\n \n     /// The SVH of the local crate.\n@@ -217,6 +190,13 @@ impl<'hir> Iterator for ParentHirIterator<'_, 'hir> {\n }\n \n impl<'hir> Map<'hir> {\n+    /// This is used internally in the dependency tracking system.\n+    /// Use the `krate` method to ensure your dependency on the\n+    /// crate is tracked.\n+    pub fn untracked_krate(&self) -> &Crate<'hir> {\n+        &self.krate\n+    }\n+\n     #[inline]\n     fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n         let local_map = self.map.get(id.owner)?;\n@@ -401,40 +381,36 @@ impl<'hir> Map<'hir> {\n         self.lookup(id).cloned()\n     }\n \n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n-        self.forest.krate()\n-    }\n-\n     pub fn item(&self, id: HirId) -> &'hir Item<'hir> {\n         self.read(id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.item(id)\n+        self.krate.item(id)\n     }\n \n     pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_item(id)\n+        self.krate.trait_item(id)\n     }\n \n     pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.impl_item(id)\n+        self.krate.impl_item(id)\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.read(id.hir_id);\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.body(id)\n+        self.krate.body(id)\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -530,9 +506,9 @@ impl<'hir> Map<'hir> {\n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [HirId] {\n         self.dep_graph.read(DepNode::new_no_params(DepKind::AllLocalTraitImpls));\n \n-        // N.B., intentionally bypass `self.forest.krate()` so that we\n+        // N.B., intentionally bypass `self.krate()` so that we\n         // do not trigger a read of the whole krate here\n-        self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n+        self.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n@@ -542,15 +518,15 @@ impl<'hir> Map<'hir> {\n         let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n \n         self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-        &self.forest.krate.attrs\n+        &self.krate.attrs\n     }\n \n     pub fn get_module(&self, module: DefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n-            Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n+            Node::Crate => (&self.krate.module, self.krate.span, hir_id),\n             node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n@@ -567,7 +543,7 @@ impl<'hir> Map<'hir> {\n         // in the expect_* calls the loops below\n         self.read(hir_id);\n \n-        let module = &self.forest.krate.modules[&hir_id];\n+        let module = &self.krate.modules[&hir_id];\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));\n@@ -984,7 +960,7 @@ impl<'hir> Map<'hir> {\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n             Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n-            Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n+            Some(Node::Crate) => Some(&self.krate.attrs[..]),\n             _ => None,\n         };\n         attrs.unwrap_or(&[])\n@@ -1063,7 +1039,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Visibility(v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(Node::Local(local)) => local.span,\n             Some(Node::MacroDef(macro_def)) => macro_def.span,\n-            Some(Node::Crate) => self.forest.krate.span,\n+            Some(Node::Crate) => self.krate.span,\n             None => bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id),\n         }\n     }\n@@ -1231,7 +1207,8 @@ impl Named for ImplItem<'_> {\n pub fn map_crate<'hir>(\n     sess: &rustc_session::Session,\n     cstore: &CrateStoreDyn,\n-    forest: &'hir Forest<'hir>,\n+    krate: &'hir Crate<'hir>,\n+    dep_graph: DepGraph,\n     definitions: Definitions,\n ) -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n@@ -1244,31 +1221,18 @@ pub fn map_crate<'hir>(\n         .collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n-\n-        let mut collector = NodeCollector::root(\n-            sess,\n-            &forest.krate,\n-            &forest.dep_graph,\n-            &definitions,\n-            &hir_to_node_id,\n-            hcx,\n-        );\n-        intravisit::walk_crate(&mut collector, &forest.krate);\n+        let hcx = crate::ich::StableHashingContext::new(sess, krate, &definitions, cstore);\n+\n+        let mut collector =\n+            NodeCollector::root(sess, krate, &dep_graph, &definitions, &hir_to_node_id, hcx);\n+        intravisit::walk_crate(&mut collector, krate);\n \n         let crate_disambiguator = sess.local_crate_disambiguator();\n         let cmdline_args = sess.opts.dep_tracking_hash();\n         collector.finalize_and_compute_crate_hash(crate_disambiguator, cstore, cmdline_args)\n     };\n \n-    let map = Map {\n-        forest,\n-        dep_graph: forest.dep_graph.clone(),\n-        crate_hash,\n-        map,\n-        hir_to_node_id,\n-        definitions,\n-    };\n+    let map = Map { krate, dep_graph, crate_hash, map, hir_to_node_id, definitions };\n \n     sess.time(\"validate_HIR_map\", || {\n         hir_id_validator::check_crate(&map);"}, {"sha": "2e7e8fdd724916614e618c59b7cf8711f1414cda", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,48 @@ pub mod exports;\n pub mod map;\n \n use crate::ty::query::Providers;\n+use crate::ty::TyCtxt;\n+use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::print;\n+use rustc_hir::Crate;\n+use std::ops::Deref;\n+\n+/// A wrapper type which allows you to access HIR.\n+#[derive(Clone)]\n+pub struct Hir<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    map: &'tcx map::Map<'tcx>,\n+}\n+\n+impl<'tcx> Hir<'tcx> {\n+    pub fn krate(&self) -> &'tcx Crate<'tcx> {\n+        self.tcx.hir_crate(LOCAL_CRATE)\n+    }\n+}\n+\n+impl<'tcx> Deref for Hir<'tcx> {\n+    type Target = &'tcx map::Map<'tcx>;\n+\n+    #[inline(always)]\n+    fn deref(&self) -> &Self::Target {\n+        &self.map\n+    }\n+}\n+\n+impl<'hir> print::PpAnn for Hir<'hir> {\n+    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n+        self.map.nested(state, nested)\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    #[inline(always)]\n+    pub fn hir(self) -> Hir<'tcx> {\n+        Hir { tcx: self, map: &self.hir_map }\n+    }\n+}\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    providers.hir_crate = |tcx, _| tcx.hir_map.untracked_krate();\n     map::provide(providers);\n }"}, {"sha": "d1815d5e320dba01023e2e1d16f0dc1616e388e0", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,13 +12,6 @@ use smallvec::SmallVec;\n \n impl<'ctx> rustc_target::HashStableContext for StableHashingContext<'ctx> {}\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Lifetime {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        self.id.hash_stable(hcx, hasher);\n-        self.ident.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         if self.len() == 0 {"}, {"sha": "844250f51a099536b67d57446d93ab57abb4ab5d", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -63,9 +63,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ty::ReErased | ty::ReStatic | ty::ReEmpty => {\n+            ty::ReErased | ty::ReStatic => {\n                 // No variant fields to hash for these ...\n             }\n+            ty::ReEmpty(universe) => {\n+                universe.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);"}, {"sha": "48a6c6d7413d195b93635543b559f30ee9b1ebf5", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -167,18 +167,29 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReFree(_) | ty::ReEmpty | ty::ReErased | ty::ReStatic | ty::ReEarlyBound(..) => r,\n+            ty::ReFree(_)\n+            | ty::ReErased\n+            | ty::ReStatic\n+            | ty::ReEmpty(ty::UniverseIndex::ROOT)\n+            | ty::ReEarlyBound(..) => r,\n+\n             ty::RePlaceholder(placeholder) => canonicalizer.canonical_var_for_region(\n                 CanonicalVarInfo { kind: CanonicalVarKind::PlaceholderRegion(*placeholder) },\n                 r,\n             ),\n+\n             ty::ReVar(vid) => {\n                 let universe = canonicalizer.region_var_universe(*vid);\n                 canonicalizer.canonical_var_for_region(\n                     CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n                     r,\n                 )\n             }\n+\n+            ty::ReEmpty(ui) => {\n+                bug!(\"canonicalizing 'empty in universe {:?}\", ui) // FIXME\n+            }\n+\n             _ => {\n                 // Other than `'static` or `'empty`, the query\n                 // response should be executing in a fully\n@@ -213,7 +224,7 @@ impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReEmpty | ty::ReStatic => r,\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n             _ => {\n                 // We only expect region names that the user can type.\n@@ -320,8 +331,8 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReScope(_)\n+            | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n \n             ty::ReClosureBound(..) => {"}, {"sha": "2518805a1ecfc618a7dc6b793509e9729349b768", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -577,7 +577,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReStatic\n             | ty::ReScope(..)\n             | ty::ReEarlyBound(..)"}, {"sha": "57a52a991edc85b0767e573e1e161cf452f777c1", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -138,7 +138,10 @@ pub(super) fn note_and_explain_region(\n             msg_span_from_free_region(tcx, region)\n         }\n \n-        ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"the empty lifetime\".to_owned(), None),\n+\n+        // uh oh, hope no user ever sees THIS\n+        ty::ReEmpty(ui) => (format!(\"the empty lifetime in universe {:?}\", ui), None),\n \n         ty::RePlaceholder(_) => (format!(\"any other region\"), None),\n \n@@ -181,7 +184,8 @@ fn msg_span_from_free_region(\n             msg_span_from_early_bound_and_free_regions(tcx, region)\n         }\n         ty::ReStatic => (\"the static lifetime\".to_owned(), None),\n-        ty::ReEmpty => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ty::UniverseIndex::ROOT) => (\"an empty lifetime\".to_owned(), None),\n+        ty::ReEmpty(ui) => (format!(\"an empty lifetime in universe {:?}\", ui), None),\n         _ => bug!(\"{:?}\", region),\n     }\n }\n@@ -375,6 +379,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n+                    RegionResolutionError::UpperBoundUniverseConflict(\n+                        _,\n+                        _,\n+                        var_universe,\n+                        sup_origin,\n+                        sup_r,\n+                    ) => {\n+                        assert!(sup_r.is_placeholder());\n+\n+                        // Make a dummy value for the \"sub region\" --\n+                        // this is the initial value of the\n+                        // placeholder. In practice, we expect more\n+                        // tailored errors that don't really use this\n+                        // value.\n+                        let sub_r = self.tcx.mk_region(ty::ReEmpty(var_universe));\n+\n+                        self.report_placeholder_failure(\n+                            region_scope_tree,\n+                            sup_origin,\n+                            sub_r,\n+                            sup_r,\n+                        )\n+                        .emit();\n+                    }\n+\n                     RegionResolutionError::MemberConstraintFailure {\n                         opaque_type_def_id,\n                         hidden_ty,\n@@ -429,6 +458,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n             | RegionResolutionError::SubSupConflict(..)\n+            | RegionResolutionError::UpperBoundUniverseConflict(..)\n             | RegionResolutionError::MemberConstraintFailure { .. } => false,\n         };\n \n@@ -443,6 +473,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::UpperBoundUniverseConflict(_, ref rvo, _, _, _) => rvo.span(),\n             RegionResolutionError::MemberConstraintFailure { span, .. } => span,\n         });\n         errors"}, {"sha": "6a9fe19e1ac3d19948352db61564439d1da58e44", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ///\n     /// It will later be extended to trait objects.\n     pub(super) fn try_report_anon_anon_conflict(&self) -> Option<ErrorReported> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let anon_reg_sup = self.tcx().is_suitable_region(sup)?;"}, {"sha": "b10a60ef6f11fbee7c9c75dc9827ae65663bd536", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -17,11 +17,6 @@ mod util;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     pub fn try_report_nice_region_error(&self, error: &RegionResolutionError<'tcx>) -> bool {\n-        match *error {\n-            ConcreteFailure(..) | SubSupConflict(..) => {}\n-            _ => return false, // inapplicable\n-        }\n-\n         if let Some(tables) = self.in_progress_tables {\n             let tables = tables.borrow();\n             NiceRegionError::new(self, error.clone(), Some(&tables)).try_report().is_some()\n@@ -79,13 +74,14 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n             .or_else(|| self.try_report_impl_not_conforming_to_trait())\n     }\n \n-    pub fn regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {\n+    pub fn regions(&self) -> Option<(Span, ty::Region<'tcx>, ty::Region<'tcx>)> {\n         match (&self.error, self.regions) {\n-            (Some(ConcreteFailure(origin, sub, sup)), None) => (origin.span(), sub, sup),\n-            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => (origin.span(), sub, sup),\n-            (None, Some((span, sub, sup))) => (span, sub, sup),\n-            (Some(_), Some(_)) => panic!(\"incorrectly built NiceRegionError\"),\n-            _ => panic!(\"trying to report on an incorrect lifetime failure\"),\n+            (Some(ConcreteFailure(origin, sub, sup)), None) => Some((origin.span(), sub, sup)),\n+            (Some(SubSupConflict(_, _, origin, sub, _, sup)), None) => {\n+                Some((origin.span(), sub, sup))\n+            }\n+            (None, Some((span, sub, sup))) => Some((span, sub, sup)),\n+            _ => None,\n         }\n     }\n }"}, {"sha": "250dcff372c593b5e35af1695a8ce80773a83464", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,7 +9,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n-        let (span, sub, sup) = self.regions();\n+        let (span, sub, sup) = self.regions()?;\n \n         debug!(\n             \"try_report_named_anon_conflict(sub={:?}, sup={:?}, error={:?})\","}, {"sha": "0b0bd61ce771e770a7dcd2a919aff509b4916ef5", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -107,6 +107,25 @@ impl NiceRegionError<'me, 'tcx> {\n                 found.substs,\n             )),\n \n+            Some(RegionResolutionError::UpperBoundUniverseConflict(\n+                vid,\n+                _,\n+                _,\n+                SubregionOrigin::Subtype(box TypeTrace {\n+                    cause,\n+                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n+                }),\n+                sup_placeholder @ ty::RePlaceholder(_),\n+            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+                Some(self.tcx().mk_region(ty::ReVar(*vid))),\n+                cause,\n+                None,\n+                Some(*sup_placeholder),\n+                expected.def_id,\n+                expected.substs,\n+                found.substs,\n+            )),\n+\n             Some(RegionResolutionError::ConcreteFailure(\n                 SubregionOrigin::Subtype(box TypeTrace {\n                     cause,"}, {"sha": "cf61cac0ac4bbf9042763ba7196c3e918e6e0afb", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             | ty::ReScope(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased"}, {"sha": "d25d186f4d74e86756fc66abca5f134b78748db9", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -128,6 +128,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         placeholder_map: &PlaceholderMap<'tcx>,\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n+        // If the user gave `-Zno-leak-check`, or we have been\n+        // configured to skip the leak check, then skip the leak check\n+        // completely. The leak check is deprecated. Any legitimate\n+        // subtyping errors that it would have caught will now be\n+        // caught later on, during region checking. However, we\n+        // continue to use it for a transition period.\n+        if self.tcx.sess.opts.debugging_opts.no_leak_check || self.skip_leak_check.get() {\n+            return Ok(());\n+        }\n+\n         self.borrow_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,"}, {"sha": "e0a8c3b4e654a6f4eae4d9a796776425d644e1f8", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 123, "deletions": 25, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -82,6 +82,16 @@ pub enum RegionResolutionError<'tcx> {\n         Region<'tcx>,\n     ),\n \n+    /// Indicates a `'b: 'a` constraint where `'a` is in a universe that\n+    /// cannot name the placeholder `'b`.\n+    UpperBoundUniverseConflict(\n+        RegionVid,\n+        RegionVariableOrigin,\n+        ty::UniverseIndex,     // the universe index of the region variable\n+        SubregionOrigin<'tcx>, // cause of the constraint\n+        Region<'tcx>,          // the placeholder `'b`\n+    ),\n+\n     /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n@@ -149,7 +159,14 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n+            values: IndexVec::from_fn_n(\n+                |vid| {\n+                    let vid_universe = self.var_infos[vid].universe;\n+                    let re_empty = tcx.mk_region(ty::ReEmpty(vid_universe));\n+                    VarValue::Value(re_empty)\n+                },\n+                self.num_vars(),\n+            ),\n         }\n     }\n \n@@ -381,8 +398,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // This is a specialized version of the `lub_concrete_regions`\n                 // check below for a common case, here purely as an\n                 // optimization.\n-                if let ReEmpty = a_region {\n-                    return false;\n+                let b_universe = self.var_infos[b_vid].universe;\n+                if let ReEmpty(a_universe) = a_region {\n+                    if *a_universe == b_universe {\n+                        return false;\n+                    }\n                 }\n \n                 let mut lub = self.lub_concrete_regions(a_region, cur_region);\n@@ -399,7 +419,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // tighter bound than `'static`.\n                 //\n                 // (This might e.g. arise from being asked to prove `for<'a> { 'b: 'a }`.)\n-                let b_universe = self.var_infos[b_vid].universe;\n                 if let ty::RePlaceholder(p) = lub {\n                     if b_universe.cannot_name(p.universe) {\n                         lub = self.tcx().lifetimes.re_static;\n@@ -420,12 +439,38 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n     /// True if `a <= b`, but not defined over inference variables.\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        let tcx = self.tcx();\n+        let sub_free_regions = |r1, r2| self.region_rels.free_regions.sub_free_regions(tcx, r1, r2);\n+\n+        // Check for the case where we know that `'b: 'static` -- in that case,\n+        // `a <= b` for all `a`.\n+        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n+            return true;\n+        }\n+\n+        // If both `a` and `b` are free, consult the declared\n+        // relationships.  Note that this can be more precise than the\n+        // `lub` relationship defined below, since sometimes the \"lub\"\n+        // is actually the `postdom_upper_bound` (see\n+        // `TransitiveRelation` for more details).\n+        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        if a_free_or_static && b_free_or_static {\n+            return sub_free_regions(a, b);\n+        }\n+\n+        // For other cases, leverage the LUB code to find the LUB and\n+        // check if it is equal to `b`.\n         self.lub_concrete_regions(a, b) == b\n     }\n \n-    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n+    /// Returns the least-upper-bound of `a` and `b`; i.e., the\n+    /// smallest region `c` such that `a <= c` and `b <= c`.\n+    ///\n+    /// Neither `a` nor `b` may be an inference variable (hence the\n+    /// term \"concrete regions\").\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        match (a, b) {\n+        let r = match (a, b) {\n             (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n             | (&ReLateBound(..), _)\n@@ -435,14 +480,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n-                r // nothing lives longer than static\n-            }\n-\n-            (&ReEmpty, r) | (r, &ReEmpty) => {\n-                r // everything lives longer than empty\n-            }\n-\n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n                     self.var_infos[v_id].origin.span(),\n@@ -453,6 +490,41 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 );\n             }\n \n+            (&ReStatic, _) | (_, &ReStatic) => {\n+                // nothing lives longer than `'static`\n+                self.tcx().lifetimes.re_static\n+            }\n+\n+            (&ReEmpty(_), r @ ReEarlyBound(_))\n+            | (r @ ReEarlyBound(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReFree(_))\n+            | (r @ ReFree(_), &ReEmpty(_))\n+            | (&ReEmpty(_), r @ ReScope(_))\n+            | (r @ ReScope(_), &ReEmpty(_)) => {\n+                // All empty regions are less than early-bound, free,\n+                // and scope regions.\n+                r\n+            }\n+\n+            (&ReEmpty(a_ui), &ReEmpty(b_ui)) => {\n+                // Empty regions are ordered according to the universe\n+                // they are associated with.\n+                let ui = a_ui.min(b_ui);\n+                self.tcx().mk_region(ReEmpty(ui))\n+            }\n+\n+            (&ReEmpty(empty_ui), &RePlaceholder(placeholder))\n+            | (&RePlaceholder(placeholder), &ReEmpty(empty_ui)) => {\n+                // If this empty region is from a universe that can\n+                // name the placeholder, then the placeholder is\n+                // larger; otherwise, the only ancestor is `'static`.\n+                if empty_ui.can_name(placeholder.universe) {\n+                    self.tcx().mk_region(RePlaceholder(placeholder))\n+                } else {\n+                    self.tcx().lifetimes.re_static\n+                }\n+            }\n+\n             (&ReEarlyBound(_), &ReScope(s_id))\n             | (&ReScope(s_id), &ReEarlyBound(_))\n             | (&ReFree(_), &ReScope(s_id))\n@@ -509,7 +581,11 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     self.tcx().lifetimes.re_static\n                 }\n             }\n-        }\n+        };\n+\n+        debug!(\"lub_concrete_regions({:?}, {:?}) = {:?}\", a, b, r);\n+\n+        r\n     }\n \n     /// After expansion is complete, go and check upper bounds (i.e.,\n@@ -528,7 +604,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 }\n \n                 Constraint::RegSubReg(sub, sup) => {\n-                    if self.region_rels.is_subregion_of(sub, sup) {\n+                    if self.sub_concrete_regions(sub, sup) {\n                         continue;\n                     }\n \n@@ -557,7 +633,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !self.region_rels.is_subregion_of(a_region, b_region) {\n+                    if !self.sub_concrete_regions(a_region, b_region) {\n                         debug!(\n                             \"collect_errors: region error at {:?}: \\\n                              cannot verify that {:?}={:?} <= {:?}\",\n@@ -592,12 +668,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);\n \n-            // This was an inference variable which didn't get\n-            // constrained, therefore it can be assume to hold.\n-            if let ty::ReEmpty = *sub {\n-                continue;\n-            }\n-\n             let verify_kind_ty = verify.kind.to_ty(self.tcx());\n             if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n@@ -760,7 +830,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n+                if !self.sub_concrete_regions(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin;\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -780,6 +850,26 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n+        // 'a } }`, we wind up without any lower-bound -- all we have\n+        // are placeholders as upper bounds, but the universe of the\n+        // variable `'a` doesn't permit those placeholders.\n+        for upper_bound in &upper_bounds {\n+            if let ty::RePlaceholder(p) = upper_bound.region {\n+                if node_universe.cannot_name(p.universe) {\n+                    let origin = self.var_infos[node_idx].origin.clone();\n+                    errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n+                        node_idx,\n+                        origin,\n+                        node_universe,\n+                        upper_bound.origin.clone(),\n+                        upper_bound.region,\n+                    ));\n+                    return;\n+                }\n+            }\n+        }\n+\n         // Errors in earlier passes can yield error variables without\n         // resolution errors here; delay ICE in favor of those errors.\n         self.tcx().sess.delay_span_bug(\n@@ -890,7 +980,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), r))\n+            }\n+\n+            VerifyBound::IsEmpty => {\n+                if let ty::ReEmpty(_) = min {\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n \n             VerifyBound::AnyBound(bs) => {"}, {"sha": "b93f4408cdc4627c888947d9a26da4359031659c", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -125,6 +125,13 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// order, represented by its upper and lower bounds.\n     pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n+    /// If set, this flag causes us to skip the 'leak check' during\n+    /// higher-ranked subtyping operations. This flag is a temporary one used\n+    /// to manage the removal of the leak-check: for the time being, we still run the\n+    /// leak-check, but we issue warnings. This flag can only be set to true\n+    /// when entering a snapshot.\n+    skip_leak_check: Cell<bool>,\n+\n     /// Map from const parameter variable to the kind of const it represents.\n     const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n \n@@ -246,7 +253,7 @@ pub enum ValuePairs<'tcx> {\n /// encounter an error or subtyping constraint.\n ///\n /// See the `error_reporting` module for more details.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct TypeTrace<'tcx> {\n     cause: ObligationCause<'tcx>,\n     values: ValuePairs<'tcx>,\n@@ -550,6 +557,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 tainted_by_errors_flag: Cell::new(false),\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),\n+                skip_leak_check: Cell::new(false),\n                 region_obligations: RefCell::new(vec![]),\n                 universe: Cell::new(ty::UniverseIndex::ROOT),\n             })\n@@ -593,6 +601,7 @@ pub struct CombinedSnapshot<'a, 'tcx> {\n     region_obligations_snapshot: usize,\n     universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n+    was_skip_leak_check: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n \n@@ -720,6 +729,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n+            was_skip_leak_check: self.skip_leak_check.get(),\n             // Borrow tables \"in progress\" (i.e., during typeck)\n             // to ban writes from within a snapshot to them.\n             _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n@@ -738,11 +748,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot,\n             universe,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n         self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n         self.type_variables.borrow_mut().rollback_to(type_snapshot);\n@@ -765,10 +777,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             region_obligations_snapshot: _,\n             universe: _,\n             was_in_snapshot,\n+            was_skip_leak_check,\n             _in_progress_tables,\n         } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n+        self.skip_leak_check.set(was_skip_leak_check);\n \n         self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n         self.type_variables.borrow_mut().commit(type_snapshot);\n@@ -822,6 +836,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n+    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n+    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_snapshot();\n+        let skip_leak_check = should_skip || self.skip_leak_check.get();\n+        self.skip_leak_check.set(skip_leak_check);\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n+        r\n+    }\n+\n     /// Scan the constraints produced since `snapshot` began and returns:\n     ///\n     /// - `None` -- if none of them involve \"region outlives\" constraints\n@@ -1647,12 +1675,6 @@ impl<'tcx> TypeTrace<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for TypeTrace<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"TypeTrace({:?})\", self.cause)\n-    }\n-}\n-\n impl<'tcx> SubregionOrigin<'tcx> {\n     pub fn span(&self) -> Span {\n         match *self {"}, {"sha": "7fef9d27c4d4a353f5aa1c1950165baf8e73c052", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -384,9 +384,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             match least_region {\n                 None => least_region = Some(subst_arg),\n                 Some(lr) => {\n-                    if free_region_relations.sub_free_regions(lr, subst_arg) {\n+                    if free_region_relations.sub_free_regions(self.tcx, lr, subst_arg) {\n                         // keep the current least region\n-                    } else if free_region_relations.sub_free_regions(subst_arg, lr) {\n+                    } else if free_region_relations.sub_free_regions(self.tcx, subst_arg, lr) {\n                         // switch to `subst_arg`\n                         least_region = Some(subst_arg);\n                     } else {\n@@ -611,7 +611,7 @@ pub fn unexpected_hidden_region_diagnostic(\n     );\n \n     // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n         // Assuming regionck succeeded (*), we ought to always be\n         // capturing *some* region from the fn header, and hence it\n         // ought to be free. So under normal circumstances, we will go\n@@ -744,6 +744,7 @@ where\n \n                 substs.as_generator().return_ty(def_id, self.tcx).visit_with(self);\n                 substs.as_generator().yield_ty(def_id, self.tcx).visit_with(self);\n+                substs.as_generator().resume_ty(def_id, self.tcx).visit_with(self);\n             }\n             _ => {\n                 ty.super_visit_with(self);\n@@ -843,7 +844,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                         .emit();\n                     }\n                 }\n-                self.tcx.lifetimes.re_empty\n+                self.tcx.lifetimes.re_root_empty\n             }\n             None => {\n                 self.tcx"}, {"sha": "a2c99064caa4e0c6b0e4ee79d70bb039789b41f2", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -60,7 +60,18 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         // scope type parameters:\n         let param_bounds = param_bounds.chain(self.implicit_region_bound);\n \n-        VerifyBound::AnyBound(param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect())\n+        let any_bounds: Vec<_> = param_bounds.map(|r| VerifyBound::OutlivedBy(r)).collect();\n+\n+        if any_bounds.is_empty() {\n+            // We know that all types `T` outlive `'empty`, so if we\n+            // can find no other bound, then check that the region\n+            // being tested is `'empty`.\n+            VerifyBound::IsEmpty\n+        } else {\n+            // If we can find any other bound `R` such that `T: R`, then\n+            // we don't need to check for `'empty`, because `R: 'empty`.\n+            VerifyBound::AnyBound(any_bounds)\n+        }\n     }\n \n     /// Given a projection like `T::Item`, searches the environment"}, {"sha": "29290cef2d28825b7e91ad98d959f419692240ad", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -33,18 +33,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n         assert!(self.in_snapshot());\n \n-        // If the user gave `-Zno-leak-check`, then skip the leak\n-        // check completely. This is wildly unsound and also not\n-        // unlikely to cause an ICE or two. It is intended for use\n-        // only during a transition period, in which the MIR typeck\n-        // uses the \"universe-style\" check, and the rest of typeck\n-        // uses the more conservative leak check.  Since the leak\n-        // check is more conservative, we can't test the\n-        // universe-style check without disabling it.\n-        if tcx.sess.opts.debugging_opts.no_leak_check {\n-            return Ok(());\n-        }\n-\n         // Go through each placeholder that we created.\n         for (_, &placeholder_region) in placeholder_map {\n             // Find the universe this placeholder inhabits."}, {"sha": "2c580e2e3490a4e0bcef02a6aa1e8c6727cb8bdc", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -233,6 +233,9 @@ pub enum VerifyBound<'tcx> {\n     /// if `R: min`, then by transitivity `G: min`.\n     OutlivedBy(Region<'tcx>),\n \n+    /// Given a region `R`, true if it is `'empty`.\n+    IsEmpty,\n+\n     /// Given a set of bounds `B`, expands to the function:\n     ///\n     /// ```rust\n@@ -792,10 +795,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         match *region {\n             ty::ReScope(..)\n             | ty::ReStatic\n-            | ty::ReEmpty\n             | ty::ReErased\n             | ty::ReFree(..)\n             | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n@@ -867,6 +870,7 @@ impl<'tcx> VerifyBound<'tcx> {\n             VerifyBound::IfEq(..) => false,\n             VerifyBound::OutlivedBy(ty::ReStatic) => true,\n             VerifyBound::OutlivedBy(_) => false,\n+            VerifyBound::IsEmpty => false,\n             VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n@@ -875,7 +879,7 @@ impl<'tcx> VerifyBound<'tcx> {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             VerifyBound::IfEq(_, b) => b.cannot_hold(),\n-            VerifyBound::OutlivedBy(ty::ReEmpty) => true,\n+            VerifyBound::IsEmpty => false,\n             VerifyBound::OutlivedBy(_) => false,\n             VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n             VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),"}, {"sha": "82adcfddc289ed5891d90ce31e4d699299ee5c99", "filename": "src/librustc/middle/codegen_fn_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcodegen_fn_attrs.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -72,6 +72,14 @@ bitflags! {\n         const FFI_RETURNS_TWICE         = 1 << 10;\n         /// `#[track_caller]`: allow access to the caller location\n         const TRACK_CALLER              = 1 << 11;\n+        /// `#[no_sanitize(address)]`: disables address sanitizer instrumentation\n+        const NO_SANITIZE_ADDRESS = 1 << 12;\n+        /// `#[no_sanitize(memory)]`: disables memory sanitizer instrumentation\n+        const NO_SANITIZE_MEMORY  = 1 << 13;\n+        /// `#[no_sanitize(thread)]`: disables thread sanitizer instrumentation\n+        const NO_SANITIZE_THREAD  = 1 << 14;\n+        /// All `#[no_sanitize(...)]` attributes.\n+        const NO_SANITIZE_ANY = Self::NO_SANITIZE_ADDRESS.bits | Self::NO_SANITIZE_MEMORY.bits | Self::NO_SANITIZE_THREAD.bits;\n     }\n }\n "}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 2, "deletions": 58, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,8 +4,8 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use crate::middle::region;\n-use crate::ty::free_region_map::{FreeRegionMap, FreeRegionRelations};\n-use crate::ty::{self, Region, TyCtxt};\n+use crate::ty::free_region_map::FreeRegionMap;\n+use crate::ty::{Region, TyCtxt};\n use rustc_hir::def_id::DefId;\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n@@ -38,62 +38,6 @@ impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n         Self { tcx, context, region_scope_tree, free_regions }\n     }\n \n-    /// Determines whether one region is a subregion of another. This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(\n-        &self,\n-        sub_region: ty::Region<'tcx>,\n-        super_region: ty::Region<'tcx>,\n-    ) -> bool {\n-        let result = sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (ty::ReEmpty, _) | (_, ty::ReStatic) => true,\n-\n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) => {\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, *super_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReEarlyBound(ref br)) => {\n-                    let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReScope(sub_scope), ty::ReFree(fr)) => {\n-                    let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n-                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n-                }\n-\n-                (ty::ReEarlyBound(_), ty::ReEarlyBound(_))\n-                | (ty::ReFree(_), ty::ReEarlyBound(_))\n-                | (ty::ReEarlyBound(_), ty::ReFree(_))\n-                | (ty::ReFree(_), ty::ReFree(_)) => {\n-                    self.free_regions.sub_free_regions(sub_region, super_region)\n-                }\n-\n-                _ => false,\n-            }\n-        };\n-        let result = result || self.is_static(super_region);\n-        debug!(\n-            \"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n-            sub_region, super_region, result\n-        );\n-        result\n-    }\n-\n-    /// Determines whether this free region is required to be `'static`.\n-    fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n-        debug!(\"is_static(super_region={:?})\", super_region);\n-        match *super_region {\n-            ty::ReStatic => true,\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                let re_static = self.tcx.mk_region(ty::ReStatic);\n-                self.free_regions.sub_free_regions(&re_static, &super_region)\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {\n         self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n     }"}, {"sha": "f6c7174649fe8338333cffdf44155c62811fb407", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1120,6 +1120,8 @@ pub enum TerminatorKind<'tcx> {\n         value: Operand<'tcx>,\n         /// Where to resume to.\n         resume: BasicBlock,\n+        /// The place to store the resume argument in.\n+        resume_arg: Place<'tcx>,\n         /// Cleanup to be done if the generator is dropped at this suspend point.\n         drop: Option<BasicBlock>,\n     },\n@@ -2645,9 +2647,12 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                 target,\n                 unwind,\n             },\n-            Yield { ref value, resume, drop } => {\n-                Yield { value: value.fold_with(folder), resume: resume, drop: drop }\n-            }\n+            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n+                value: value.fold_with(folder),\n+                resume,\n+                resume_arg: resume_arg.fold_with(folder),\n+                drop,\n+            },\n             Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n                 let dest =\n                     destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));"}, {"sha": "2f094516a35d9e561003333775602be3da75aa05", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -516,8 +516,14 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Yield {\n                         value,\n                         resume: _,\n+                        resume_arg,\n                         drop: _,\n                     } => {\n+                        self.visit_place(\n+                            resume_arg,\n+                            PlaceContext::MutatingUse(MutatingUseContext::Store),\n+                            source_location,\n+                        );\n                         self.visit_operand(value, source_location);\n                     }\n "}, {"sha": "d1bccb961c48bbd3ebf6f5cf012a26829f672fd6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -43,6 +43,18 @@ rustc_queries! {\n     }\n \n     Other {\n+        // Represents crate as a whole (as distinct from the top-level crate module).\n+        // If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n+        // we will have to assume that any change means that you need to be recompiled.\n+        // This is because the `hir_crate` query gives you access to all other items.\n+        // To avoid this fate, do not call `tcx.hir().krate()`; instead,\n+        // prefer wrappers like `tcx.visit_all_items_in_krate()`.\n+        query hir_crate(key: CrateNum) -> &'tcx Crate<'tcx> {\n+            eval_always\n+            no_hash\n+            desc { \"get the crate HIR\" }\n+        }\n+\n         /// Records the type of every item.\n         query type_of(key: DefId) -> Ty<'tcx> {\n             cache_on_disk_if { key.is_local() }"}, {"sha": "855da0367de067b71de012caea5567de95ac2e55", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,6 +7,7 @@\n use crate::infer::{CombinedSnapshot, InferOk};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::IntercrateMode;\n+use crate::traits::SkipLeakCheck;\n use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::Subst;\n@@ -53,6 +54,7 @@ pub fn overlapping_impls<F1, F2, R>(\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     intercrate_mode: IntercrateMode,\n+    skip_leak_check: SkipLeakCheck,\n     on_overlap: F1,\n     no_overlap: F2,\n ) -> R\n@@ -70,7 +72,7 @@ where\n \n     let overlaps = tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n-        overlap(selcx, impl1_def_id, impl2_def_id).is_some()\n+        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).is_some()\n     });\n \n     if !overlaps {\n@@ -83,7 +85,7 @@ where\n     tcx.infer_ctxt().enter(|infcx| {\n         let selcx = &mut SelectionContext::intercrate(&infcx, intercrate_mode);\n         selcx.enable_tracking_intercrate_ambiguity_causes();\n-        on_overlap(overlap(selcx, impl1_def_id, impl2_def_id).unwrap())\n+        on_overlap(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id).unwrap())\n     })\n }\n \n@@ -113,12 +115,15 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n fn overlap<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n+    skip_leak_check: SkipLeakCheck,\n     a_def_id: DefId,\n     b_def_id: DefId,\n ) -> Option<OverlapResult<'tcx>> {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\", a_def_id, b_def_id);\n \n-    selcx.infcx().probe(|snapshot| overlap_within_probe(selcx, a_def_id, b_def_id, snapshot))\n+    selcx.infcx().probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n+        overlap_within_probe(selcx, a_def_id, b_def_id, snapshot)\n+    })\n }\n \n fn overlap_within_probe(\n@@ -146,7 +151,9 @@ fn overlap_within_probe(\n         .eq_impl_headers(&a_impl_header, &b_impl_header)\n     {\n         Ok(InferOk { obligations, value: () }) => obligations,\n-        Err(_) => return None,\n+        Err(_) => {\n+            return None;\n+        }\n     };\n \n     debug!(\"overlap: unification check succeeded\");"}, {"sha": "50068b89687ba9a66f8cdaa431afd2a08dc21f43", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -83,6 +83,28 @@ pub enum IntercrateMode {\n     Fixed,\n }\n \n+/// Whether to skip the leak check, as part of a future compatibility warning step.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum SkipLeakCheck {\n+    Yes,\n+    No,\n+}\n+\n+impl SkipLeakCheck {\n+    fn is_yes(self) -> bool {\n+        self == SkipLeakCheck::Yes\n+    }\n+}\n+\n+/// The \"default\" for skip-leak-check corresponds to the current\n+/// behavior (do not skip the leak check) -- not the behavior we are\n+/// transitioning into.\n+impl Default for SkipLeakCheck {\n+    fn default() -> Self {\n+        SkipLeakCheck::No\n+    }\n+}\n+\n /// The mode that trait queries run in.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {"}, {"sha": "8b68d6f26039966f6b486b929005127b6f32f7c3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -19,6 +19,7 @@ use crate::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n \n@@ -97,7 +98,7 @@ pub fn translate_substs<'a, 'tcx>(\n                 |_| {\n                     bug!(\n                         \"When translating substitutions for specialization, the expected \\\n-                          specialization failed to hold\"\n+                         specialization failed to hold\"\n                     )\n                 },\n             )\n@@ -268,7 +269,7 @@ fn fulfill_implication<'a, 'tcx>(\n                 // no dice!\n                 debug!(\n                     \"fulfill_implication: for impls on {:?} and {:?}, \\\n-                        could not fulfill: {:?} given {:?}\",\n+                     could not fulfill: {:?} given {:?}\",\n                     source_trait_ref, target_trait_ref, errors, param_env.caller_bounds\n                 );\n                 Err(())\n@@ -342,6 +343,7 @@ pub(super) fn specialization_graph_provider(\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n                                 ORDER_DEPENDENT_TRAIT_OBJECTS\n                             }\n+                            FutureCompatOverlapErrorKind::LeakCheck => COHERENCE_LEAK_CHECK,\n                         };\n                         tcx.struct_span_lint_hir(\n                             lint,"}, {"sha": "98908e672f0aa1f9966a760e7c82588e4a829ac8", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -11,6 +11,7 @@ pub use rustc::traits::types::specialization_graph::*;\n pub enum FutureCompatOverlapErrorKind {\n     Issue43355,\n     Issue33140,\n+    LeakCheck,\n }\n \n #[derive(Debug)]\n@@ -111,6 +112,7 @@ impl<'tcx> Children {\n                 possible_sibling,\n                 impl_def_id,\n                 traits::IntercrateMode::Issue43355,\n+                traits::SkipLeakCheck::default(),\n                 |overlap| {\n                     if let Some(overlap_kind) =\n                         tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n@@ -161,6 +163,7 @@ impl<'tcx> Children {\n                         possible_sibling,\n                         impl_def_id,\n                         traits::IntercrateMode::Fixed,\n+                        traits::SkipLeakCheck::default(),\n                         |overlap| {\n                             last_lint = Some(FutureCompatOverlapError {\n                                 error: overlap_error(overlap),\n@@ -169,6 +172,23 @@ impl<'tcx> Children {\n                         },\n                         || (),\n                     );\n+\n+                    if last_lint.is_none() {\n+                        traits::overlapping_impls(\n+                            tcx,\n+                            possible_sibling,\n+                            impl_def_id,\n+                            traits::IntercrateMode::Fixed,\n+                            traits::SkipLeakCheck::Yes,\n+                            |overlap| {\n+                                last_lint = Some(FutureCompatOverlapError {\n+                                    error: overlap_error(overlap),\n+                                    kind: FutureCompatOverlapErrorKind::LeakCheck,\n+                                });\n+                            },\n+                            || (),\n+                        );\n+                    }\n                 }\n \n                 // no overlap (error bailed already via ?)\n@@ -247,7 +267,7 @@ impl<'tcx> Graph {\n         if trait_ref.references_error() {\n             debug!(\n                 \"insert: inserting dummy node for erroneous TraitRef {:?}, \\\n-                    impl_def_id={:?}, trait_def_id={:?}\",\n+                 impl_def_id={:?}, trait_def_id={:?}\",\n                 trait_ref, impl_def_id, trait_def_id\n             );\n \n@@ -326,7 +346,7 @@ impl<'tcx> Graph {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\n                 \"When recording an impl from the crate store, information about its parent \\\n-                  was already present.\"\n+                 was already present.\"\n             );\n         }\n "}, {"sha": "d4c3518260c602be532f9f99d24c0b6ae756db04", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -643,8 +643,10 @@ pub fn generator_trait_ref_and_outputs(\n     self_ty: Ty<'tcx>,\n     sig: ty::PolyGenSig<'tcx>,\n ) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n-    let trait_ref =\n-        ty::TraitRef { def_id: fn_trait_def_id, substs: tcx.mk_substs_trait(self_ty, &[]) };\n+    let trait_ref = ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs_trait(self_ty, &[sig.skip_binder().resume_ty.into()]),\n+    };\n     ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n }\n "}, {"sha": "92c5600362e01768a2a1bde61f53f1a916772a4e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -173,8 +173,13 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct CommonLifetimes<'tcx> {\n-    pub re_empty: Region<'tcx>,\n+    /// `ReEmpty` in the root universe.\n+    pub re_root_empty: Region<'tcx>,\n+\n+    /// `ReStatic`\n     pub re_static: Region<'tcx>,\n+\n+    /// Erased region, used after type-checking\n     pub re_erased: Region<'tcx>,\n }\n \n@@ -876,7 +881,7 @@ impl<'tcx> CommonLifetimes<'tcx> {\n         let mk = |r| interners.region.intern(r, |r| Interned(interners.arena.alloc(r))).0;\n \n         CommonLifetimes {\n-            re_empty: mk(RegionKind::ReEmpty),\n+            re_root_empty: mk(RegionKind::ReEmpty(ty::UniverseIndex::ROOT)),\n             re_static: mk(RegionKind::ReStatic),\n             re_erased: mk(RegionKind::ReErased),\n         }\n@@ -966,7 +971,8 @@ pub struct GlobalCtxt<'tcx> {\n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n \n-    hir_map: hir_map::Map<'tcx>,\n+    /// This should usually be accessed with the `tcx.hir()` method.\n+    pub(crate) hir_map: hir_map::Map<'tcx>,\n \n     /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n@@ -1019,11 +1025,6 @@ pub struct GlobalCtxt<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline(always)]\n-    pub fn hir(self) -> &'tcx hir_map::Map<'tcx> {\n-        &self.hir_map\n-    }\n-\n     pub fn alloc_steal_mir(self, mir: BodyAndCache<'tcx>) -> &'tcx Steal<BodyAndCache<'tcx>> {\n         self.arena.alloc(Steal::new(mir))\n     }\n@@ -1328,7 +1329,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let krate = self.gcx.hir_map.forest.untracked_krate();\n+        let krate = self.gcx.hir_map.untracked_krate();\n \n         StableHashingContext::new(self.sess, krate, self.hir().definitions(), &*self.cstore)\n     }"}, {"sha": "2ab12a4acbfa4affd6c5658da0a614b352f1c9e7", "filename": "src/librustc/ty/free_region_map.rs", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffree_region_map.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -23,11 +23,61 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if is_free_or_static(sub) && is_free(sup) {\n+        if self.is_free_or_static(sub) && self.is_free(sup) {\n             self.relation.add(sub, sup)\n         }\n     }\n \n+    /// Tests whether `r_a <= r_b`.\n+    ///\n+    /// Both regions must meet `is_free_or_static`.\n+    ///\n+    /// Subtle: one tricky case that this code gets correct is as\n+    /// follows. If we know that `r_b: 'static`, then this function\n+    /// will return true, even though we don't know anything that\n+    /// directly relates `r_a` and `r_b`.\n+    ///\n+    /// Also available through the `FreeRegionRelations` trait below.\n+    pub fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r_a: Region<'tcx>,\n+        r_b: Region<'tcx>,\n+    ) -> bool {\n+        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        let re_static = tcx.lifetimes.re_static;\n+        if self.check_relation(re_static, r_b) {\n+            // `'a <= 'static` is always true, and not stored in the\n+            // relation explicitly, so check if `'b` is `'static` (or\n+            // equivalent to it)\n+            true\n+        } else {\n+            self.check_relation(r_a, r_b)\n+        }\n+    }\n+\n+    /// Check whether `r_a <= r_b` is found in the relation.\n+    fn check_relation(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        r_a == r_b || self.relation.contains(&r_a, &r_b)\n+    }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// True if `r` is a free region or static of the sort that this\n+    /// free region map can be used with.\n+    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n+        match *r {\n+            ty::ReStatic => true,\n+            _ => self.is_free(r),\n+        }\n+    }\n+\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -39,13 +89,13 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n+        assert!(self.is_free(r_a));\n+        assert!(self.is_free(r_b));\n         let result = if r_a == r_b {\n             r_a\n         } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => tcx.mk_region(ty::ReStatic),\n+                None => tcx.lifetimes.re_static,\n                 Some(r) => *r,\n             }\n         };\n@@ -60,31 +110,18 @@ impl<'tcx> FreeRegionMap<'tcx> {\n pub trait FreeRegionRelations<'tcx> {\n     /// Tests whether `r_a <= r_b`. Both must be free regions or\n     /// `'static`.\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool;\n+    fn sub_free_regions(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool;\n }\n \n impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n-    fn sub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n-        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n-        if let ty::ReStatic = r_b {\n-            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n-        } else {\n-            r_a == r_b || self.relation.contains(&r_a, &r_b)\n-        }\n-    }\n-}\n-\n-fn is_free(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-        _ => false,\n-    }\n-}\n-\n-fn is_free_or_static(r: Region<'_>) -> bool {\n-    match *r {\n-        ty::ReStatic => true,\n-        _ => is_free(r),\n+    fn sub_free_regions(&self, tcx: TyCtxt<'tcx>, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n+        // invoke the \"inherent method\"\n+        self.sub_free_regions(tcx, r_a, r_b)\n     }\n }\n "}, {"sha": "0a5ab790adbab2d97eac1dd160ff7a0dd27d341f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2350,8 +2350,9 @@ impl<'tcx> ty::Instance<'tcx> {\n                     ]);\n                     let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n-                    tcx.mk_fn_sig(iter::once(env_ty),\n-                        ret_ty,\n+                    tcx.mk_fn_sig(\n+                        [env_ty, sig.resume_ty].iter(),\n+                        &ret_ty,\n                         false,\n                         hir::Unsafety::Normal,\n                         rustc_target::spec::abi::Abi::Rust"}, {"sha": "0da680d1f915ee8c872640a41277d28a25e78276", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1382,7 +1382,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n             ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n \n-            ty::ReStatic | ty::ReEmpty | ty::ReClosureBound(_) => true,\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n         }\n     }\n }\n@@ -1464,10 +1464,14 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                 p!(write(\"'static\"));\n                 return Ok(self);\n             }\n-            ty::ReEmpty => {\n+            ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n                 p!(write(\"'<empty>\"));\n                 return Ok(self);\n             }\n+            ty::ReEmpty(ui) => {\n+                p!(write(\"'<empty:{:?}>\", ui));\n+                return Ok(self);\n+            }\n \n             // The user should never encounter these in unsubstituted form.\n             ty::ReClosureBound(vid) => {"}, {"sha": "e7b95af103cc939e2b45c51adabb547835ce99c4", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -45,7 +45,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex};\n-use rustc_hir::{HirIdSet, ItemLocalId, TraitCandidate};\n+use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n use rustc_target::spec::PanicStrategy;\n "}, {"sha": "6d9fff351e9b80d5bb21d4e3a963498fa5352cd6", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1177,7 +1177,6 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n         DepKind::AllLocalTraitImpls |\n-        DepKind::Krate |\n         DepKind::CrateMetadata |\n         DepKind::HirBody |\n         DepKind::Hir |"}, {"sha": "acd6c9597518d361eafcd06e76eba44987039f1f", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -108,7 +108,7 @@ impl fmt::Debug for ty::RegionKind {\n \n             ty::RePlaceholder(placeholder) => write!(f, \"RePlaceholder({:?})\", placeholder),\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+            ty::ReEmpty(ui) => write!(f, \"ReEmpty({:?})\", ui),\n \n             ty::ReErased => write!(f, \"ReErased\"),\n         }\n@@ -598,8 +598,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.yield_ty, self.return_ty))\n-            .map(|(yield_ty, return_ty)| ty::GenSig { yield_ty, return_ty })\n+        tcx.lift(&(self.resume_ty, self.yield_ty, self.return_ty))\n+            .map(|(resume_ty, yield_ty, return_ty)| ty::GenSig { resume_ty, yield_ty, return_ty })\n     }\n }\n "}, {"sha": "4c5bc3debde54ebb2945d6c55bc12e160788ddd3", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 102, "deletions": 24, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -346,9 +346,17 @@ static_assert_size!(TyKind<'_>, 24);\n /// ## Generators\n ///\n /// Generators are handled similarly in `GeneratorSubsts`.  The set of\n-/// type parameters is similar, but the role of CK and CS are\n-/// different. CK represents the \"yield type\" and CS represents the\n-/// \"return type\" of the generator.\n+/// type parameters is similar, but `CK` and `CS` are replaced by the\n+/// following type parameters:\n+///\n+/// * `GS`: The generator's \"resume type\", which is the type of the\n+///   argument passed to `resume`, and the type of `yield` expressions\n+///   inside the generator.\n+/// * `GY`: The \"yield type\", which is the type of values passed to\n+///   `yield` inside the generator.\n+/// * `GR`: The \"return type\", which is the type of value returned upon\n+///   completion of the generator.\n+/// * `GW`: The \"generator witness\".\n #[derive(Copy, Clone, Debug, TypeFoldable)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function,\n@@ -442,6 +450,7 @@ pub struct GeneratorSubsts<'tcx> {\n }\n \n struct SplitGeneratorSubsts<'tcx> {\n+    resume_ty: Ty<'tcx>,\n     yield_ty: Ty<'tcx>,\n     return_ty: Ty<'tcx>,\n     witness: Ty<'tcx>,\n@@ -453,10 +462,11 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         let generics = tcx.generics_of(def_id);\n         let parent_len = generics.parent_count;\n         SplitGeneratorSubsts {\n-            yield_ty: self.substs.type_at(parent_len),\n-            return_ty: self.substs.type_at(parent_len + 1),\n-            witness: self.substs.type_at(parent_len + 2),\n-            upvar_kinds: &self.substs[parent_len + 3..],\n+            resume_ty: self.substs.type_at(parent_len),\n+            yield_ty: self.substs.type_at(parent_len + 1),\n+            return_ty: self.substs.type_at(parent_len + 2),\n+            witness: self.substs.type_at(parent_len + 3),\n+            upvar_kinds: &self.substs[parent_len + 4..],\n         }\n     }\n \n@@ -485,6 +495,11 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         })\n     }\n \n+    /// Returns the type representing the resume type of the generator.\n+    pub fn resume_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n+        self.split(def_id, tcx).resume_ty\n+    }\n+\n     /// Returns the type representing the yield type of the generator.\n     pub fn yield_ty(self, def_id: DefId, tcx: TyCtxt<'_>) -> Ty<'tcx> {\n         self.split(def_id, tcx).yield_ty\n@@ -505,10 +520,14 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n         ty::Binder::dummy(self.sig(def_id, tcx))\n     }\n \n-    /// Returns the \"generator signature\", which consists of its yield\n+    /// Returns the \"generator signature\", which consists of its resume, yield\n     /// and return types.\n     pub fn sig(self, def_id: DefId, tcx: TyCtxt<'_>) -> GenSig<'tcx> {\n-        ty::GenSig { yield_ty: self.yield_ty(def_id, tcx), return_ty: self.return_ty(def_id, tcx) }\n+        ty::GenSig {\n+            resume_ty: self.resume_ty(def_id, tcx),\n+            yield_ty: self.yield_ty(def_id, tcx),\n+            return_ty: self.return_ty(def_id, tcx),\n+        }\n     }\n }\n \n@@ -1072,13 +1091,17 @@ impl<'tcx> ProjectionTy<'tcx> {\n \n #[derive(Clone, Debug, TypeFoldable)]\n pub struct GenSig<'tcx> {\n+    pub resume_ty: Ty<'tcx>,\n     pub yield_ty: Ty<'tcx>,\n     pub return_ty: Ty<'tcx>,\n }\n \n pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n \n impl<'tcx> PolyGenSig<'tcx> {\n+    pub fn resume_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.map_bound_ref(|sig| sig.resume_ty)\n+    }\n     pub fn yield_ty(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|sig| sig.yield_ty)\n     }\n@@ -1269,11 +1292,67 @@ rustc_index::newtype_index! {\n \n pub type Region<'tcx> = &'tcx RegionKind;\n \n-/// Representation of regions.\n+/// Representation of (lexical) regions. Note that the NLL checker\n+/// uses a distinct representation of regions. For this reason, it\n+/// internally replaces all the regions with inference variables --\n+/// the index of the variable is then used to index into internal NLL\n+/// data structures. See `rustc_mir::borrow_check` module for more\n+/// information.\n+///\n+/// ## The Region lattice within a given function\n+///\n+/// In general, the (lexical, and hence deprecated) region lattice\n+/// looks like\n+///\n+/// ```\n+/// static ----------+-----...------+       (greatest)\n+/// |                |              |\n+/// early-bound and  |              |\n+/// free regions     |              |\n+/// |                |              |\n+/// scope regions    |              |\n+/// |                |              |\n+/// empty(root)   placeholder(U1)   |\n+/// |            /                  |\n+/// |           /         placeholder(Un)\n+/// empty(U1) --         /\n+/// |                   /\n+/// ...                /\n+/// |                 /\n+/// empty(Un) --------                      (smallest)\n+/// ```\n+///\n+/// Early-bound/free regions are the named lifetimes in scope from the\n+/// function declaration. They have relationships to one another\n+/// determined based on the declared relationships from the\n+/// function. They all collectively outlive the scope regions. (See\n+/// `RegionRelations` type, and particularly\n+/// `crate::infer::outlives::free_region_map::FreeRegionMap`.)\n+///\n+/// The scope regions are related to one another based on the AST\n+/// structure. (See `RegionRelations` type, and particularly the\n+/// `rustc::middle::region::ScopeTree`.)\n+///\n+/// Note that inference variables and bound regions are not included\n+/// in this diagram. In the case of inference variables, they should\n+/// be inferred to some other region from the diagram.  In the case of\n+/// bound regions, they are excluded because they don't make sense to\n+/// include -- the diagram indicates the relationship between free\n+/// regions.\n+///\n+/// ## Inference variables\n+///\n+/// During region inference, we sometimes create inference variables,\n+/// represented as `ReVar`. These will be inferred by the code in\n+/// `infer::lexical_region_resolve` to some free region from the\n+/// lattice above (the minimal region that meets the\n+/// constraints).\n ///\n-/// Unlike types, most region variants are \"fictitious\", not concrete,\n-/// regions. Among these, `ReStatic`, `ReEmpty` and `ReScope` are the only\n-/// ones representing concrete regions.\n+/// During NLL checking, where regions are defined differently, we\n+/// also use `ReVar` -- in that case, the index is used to index into\n+/// the NLL region checker's data structures. The variable may in fact\n+/// represent either a free region or an inference variable, in that\n+/// case.\n ///\n /// ## Bound Regions\n ///\n@@ -1356,14 +1435,13 @@ pub enum RegionKind {\n     /// Should not exist after typeck.\n     RePlaceholder(ty::PlaceholderRegion),\n \n-    /// Empty lifetime is for data that is never accessed.\n-    /// Bottom in the region lattice. We treat ReEmpty somewhat\n-    /// specially; at least right now, we do not generate instances of\n-    /// it during the GLB computations, but rather\n-    /// generate an error instead. This is to improve error messages.\n-    /// The only way to get an instance of ReEmpty is to have a region\n-    /// variable with no constraints.\n-    ReEmpty,\n+    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// empty lifetime with a universe -- the idea is that we don't\n+    /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n+    /// Therefore, the `'empty` in a universe `U` is less than all\n+    /// regions visible from `U`, but not less than regions not visible\n+    /// from `U`.\n+    ReEmpty(ty::UniverseIndex),\n \n     /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n@@ -1612,7 +1690,7 @@ impl RegionKind {\n             RegionKind::ReStatic => true,\n             RegionKind::ReVar(..) => false,\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n-            RegionKind::ReEmpty => false,\n+            RegionKind::ReEmpty(_) => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n         }\n@@ -1695,7 +1773,7 @@ impl RegionKind {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_EARLY_BOUND;\n             }\n-            ty::ReEmpty | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n+            ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n             ty::ReErased => {}\n@@ -1705,7 +1783,7 @@ impl RegionKind {\n         }\n \n         match *self {\n-            ty::ReStatic | ty::ReEmpty | ty::ReErased | ty::ReLateBound(..) => (),\n+            ty::ReStatic | ty::ReEmpty(_) | ty::ReErased | ty::ReLateBound(..) => (),\n             _ => flags = flags | TypeFlags::HAS_FREE_LOCAL_NAMES,\n         }\n "}, {"sha": "dd3316979f6a2206bcdd209158bdc5ca74272aa8", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -688,12 +688,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> Option<hir::Movability> {\n         match generator_kind {\n             Some(hir::GeneratorKind::Gen) => {\n-                if !decl.inputs.is_empty() {\n+                if decl.inputs.len() > 1 {\n                     struct_span_err!(\n                         self.sess,\n                         fn_decl_span,\n                         E0628,\n-                        \"generators cannot have explicit parameters\"\n+                        \"too many parameters for a generator (expected 0 or 1 parameters)\"\n                     )\n                     .emit();\n                 }"}, {"sha": "a9e4fdba030366ee60a2d104da1290cdcd68ae14", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -46,6 +46,31 @@ fn inline(cx: &CodegenCx<'ll, '_>, val: &'ll Value, inline: InlineAttr) {\n     };\n }\n \n+/// Apply LLVM sanitize attributes.\n+#[inline]\n+pub fn sanitize(cx: &CodegenCx<'ll, '_>, codegen_fn_flags: CodegenFnAttrFlags, llfn: &'ll Value) {\n+    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n+        match *sanitizer {\n+            Sanitizer::Address => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n+                    llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Memory => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n+                    llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Thread => {\n+                if !codegen_fn_flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n+                    llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n+                }\n+            }\n+            Sanitizer::Leak => {}\n+        }\n+    }\n+}\n+\n /// Tell LLVM to emit or not emit the information necessary to unwind the stack for the function.\n #[inline]\n pub fn emit_uwtable(val: &'ll Value, emit: bool) {\n@@ -288,6 +313,7 @@ pub fn from_fn_attrs(\n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::ALLOCATOR) {\n         Attribute::NoAlias.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n     }\n+    sanitize(cx, codegen_fn_attrs.flags, llfn);\n \n     unwind(\n         llfn,"}, {"sha": "04c084e459eab662f2b441eafcc2ba5715b76ca4", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,7 @@\n \n use super::ModuleLlvm;\n \n+use crate::attributes;\n use crate::builder::Builder;\n use crate::common;\n use crate::context::CodegenCx;\n@@ -23,7 +24,7 @@ use crate::metadata;\n use crate::value::Value;\n \n use rustc::dep_graph;\n-use rustc::middle::codegen_fn_attrs::CodegenFnAttrs;\n+use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::middle::cstore::EncodedMetadata;\n use rustc::middle::exported_symbols;\n use rustc::mir::mono::{Linkage, Visibility};\n@@ -131,7 +132,9 @@ pub fn compile_codegen_unit(\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx);\n+            if let Some(entry) = maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx) {\n+                attributes::sanitize(&cx, CodegenFnAttrFlags::empty(), entry);\n+            }\n \n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {"}, {"sha": "691f32dd85a05b8faee5ebc835fa9960107e7ee7", "filename": "src/librustc_codegen_llvm/declare.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_llvm%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdeclare.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -19,7 +19,6 @@ use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n use log::debug;\n-use rustc::session::config::Sanitizer;\n use rustc::ty::Ty;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::small_c_str::SmallCStr;\n@@ -47,21 +46,6 @@ fn declare_raw_fn(\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n     }\n \n-    if let Some(ref sanitizer) = cx.tcx.sess.opts.debugging_opts.sanitizer {\n-        match *sanitizer {\n-            Sanitizer::Address => {\n-                llvm::Attribute::SanitizeAddress.apply_llfn(Function, llfn);\n-            }\n-            Sanitizer::Memory => {\n-                llvm::Attribute::SanitizeMemory.apply_llfn(Function, llfn);\n-            }\n-            Sanitizer::Thread => {\n-                llvm::Attribute::SanitizeThread.apply_llfn(Function, llfn);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     attributes::default_optimisation_attrs(cx.tcx.sess, llfn);\n     attributes::non_lazy_bind(cx.sess(), llfn);\n     llfn"}, {"sha": "900150913842c5f20e76aaa9d031463491358264", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -391,36 +391,36 @@ pub fn codegen_instance<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n \n /// Creates the `main` function which will initialize the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'a Bx::CodegenCx) {\n+pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    cx: &'a Bx::CodegenCx,\n+) -> Option<Bx::Function> {\n     let (main_def_id, span) = match cx.tcx().entry_fn(LOCAL_CRATE) {\n         Some((def_id, _)) => (def_id, cx.tcx().def_span(def_id)),\n-        None => return,\n+        None => return None,\n     };\n \n     let instance = Instance::mono(cx.tcx(), main_def_id);\n \n     if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n-        return;\n+        return None;\n     }\n \n     let main_llfn = cx.get_fn_addr(instance);\n \n-    let et = cx.tcx().entry_fn(LOCAL_CRATE).map(|e| e.1);\n-    match et {\n-        Some(EntryFnType::Main) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, true),\n-        Some(EntryFnType::Start) => create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, false),\n-        None => {} // Do nothing.\n-    }\n+    return cx.tcx().entry_fn(LOCAL_CRATE).map(|(_, et)| {\n+        let use_start_lang_item = EntryFnType::Start != et;\n+        create_entry_fn::<Bx>(cx, span, main_llfn, main_def_id, use_start_lang_item)\n+    });\n \n     fn create_entry_fn<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         sp: Span,\n         rust_main: Bx::Value,\n         rust_main_def_id: DefId,\n         use_start_lang_item: bool,\n-    ) {\n+    ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,\n         // depending on whether the target needs `argc` and `argv` to be passed in.\n         let llfty = if cx.sess().target.target.options.main_needs_argc_argv {\n@@ -481,6 +481,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(cx: &'\n         let result = bx.call(start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n+\n+        llfn\n     }\n }\n "}, {"sha": "dbc54291f4087c25858d77cbefdaf5931d3b0813", "filename": "src/librustc_data_structures/box_region.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -25,6 +25,7 @@ pub struct PinnedGenerator<I, A, R> {\n }\n \n impl<I, A, R> PinnedGenerator<I, A, R> {\n+    #[cfg(bootstrap)]\n     pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n         generator: T,\n     ) -> (I, Self) {\n@@ -39,6 +40,22 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n         (init, result)\n     }\n \n+    #[cfg(not(bootstrap))]\n+    pub fn new<T: Generator<Yield = YieldType<I, A>, Return = R> + 'static>(\n+        generator: T,\n+    ) -> (I, Self) {\n+        let mut result = PinnedGenerator { generator: Box::pin(generator) };\n+\n+        // Run it to the first yield to set it up\n+        let init = match Pin::new(&mut result.generator).resume(()) {\n+            GeneratorState::Yielded(YieldType::Initial(y)) => y,\n+            _ => panic!(),\n+        };\n+\n+        (init, result)\n+    }\n+\n+    #[cfg(bootstrap)]\n     pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n         BOX_REGION_ARG.with(|i| {\n             i.set(Action::Access(AccessAction(closure)));\n@@ -50,13 +67,35 @@ impl<I, A, R> PinnedGenerator<I, A, R> {\n         }\n     }\n \n+    #[cfg(not(bootstrap))]\n+    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n+        BOX_REGION_ARG.with(|i| {\n+            i.set(Action::Access(AccessAction(closure)));\n+        });\n+\n+        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n+        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume(()) {\n+            panic!()\n+        }\n+    }\n+\n+    #[cfg(bootstrap)]\n     pub fn complete(&mut self) -> R {\n         // Tell the generator we want it to complete, consuming it and yielding a result\n         BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n \n         let result = Pin::new(&mut self.generator).resume();\n         if let GeneratorState::Complete(r) = result { r } else { panic!() }\n     }\n+\n+    #[cfg(not(bootstrap))]\n+    pub fn complete(&mut self) -> R {\n+        // Tell the generator we want it to complete, consuming it and yielding a result\n+        BOX_REGION_ARG.with(|i| i.set(Action::Complete));\n+\n+        let result = Pin::new(&mut self.generator).resume(());\n+        if let GeneratorState::Complete(r) = result { r } else { panic!() }\n+    }\n }\n \n #[derive(PartialEq)]"}, {"sha": "d4f014904994102a7d30f06754104628b6fe08c9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -69,19 +69,19 @@ where\n     match *ppmode {\n         PpmNormal => {\n             let annotation = NoAnn { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().forest.krate())\n+            f(&annotation, tcx.hir().krate())\n         }\n \n         PpmIdentified => {\n             let annotation = IdentifiedAnnotation { sess: tcx.sess, tcx: Some(tcx) };\n-            f(&annotation, tcx.hir().forest.krate())\n+            f(&annotation, tcx.hir().krate())\n         }\n         PpmTyped => {\n             abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n \n             let empty_tables = ty::TypeckTables::empty(None);\n             let annotation = TypedAnnotation { tcx, tables: Cell::new(&empty_tables) };\n-            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().forest.krate()))\n+            tcx.dep_graph.with_ignore(|| f(&annotation, tcx.hir().krate()))\n         }\n         _ => panic!(\"Should use call_with_pp_support\"),\n     }\n@@ -143,7 +143,7 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.tcx.map(|tcx| tcx.hir())\n+        self.tcx.map(|tcx| *tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -155,7 +155,7 @@ impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(*tcx.hir(), state, nested)\n         }\n     }\n }\n@@ -217,7 +217,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.tcx.map(|tcx| tcx.hir())\n+        self.tcx.map(|tcx| *tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -228,7 +228,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(*tcx.hir(), state, nested)\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(self.tcx.hir(), state, nested);\n+        pprust_hir::PpAnn::nested(*self.tcx.hir(), state, nested);\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {"}, {"sha": "ad76968c5897d7f772473c758ae7725e94fb13ba", "filename": "src/librustc_error_codes/error_codes/E0276.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,5 +1,6 @@\n-This error occurs when a bound in an implementation of a trait does not match\n-the bounds specified in the original trait. For example:\n+A trait implementation has stricter requirements than the trait definition.\n+\n+Erroneous code example:\n \n ```compile_fail,E0276\n trait Foo {"}, {"sha": "4f6644f358291bf6d6ca7cc1eb264aaec8c42192", "filename": "src/librustc_error_codes/error_codes/E0511.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,7 +1,7 @@\n Invalid monomorphization of an intrinsic function was used. Erroneous code\n example:\n \n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+```compile_fail,E0511\n #![feature(platform_intrinsics)]\n \n extern \"platform-intrinsic\" {"}, {"sha": "0afa4a8c9581167e27bb1b93413d96ce8936a267", "filename": "src/librustc_error_codes/error_codes/E0534.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0534.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,7 +2,7 @@ The `inline` attribute was malformed.\n \n Erroneous code example:\n \n-```ignore (compile_fail not working here; see Issue #43707)\n+```compile_fail,E0534\n #[inline()] // error: expected one argument\n pub fn something() {}\n "}, {"sha": "035d395b76fe7040a7ab71dc86a060be3e819012", "filename": "src/librustc_error_codes/error_codes/E0535.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0535.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,7 +2,7 @@ An unknown argument was given to the `inline` attribute.\n \n Erroneous code example:\n \n-```ignore (compile_fail not working here; see Issue #43707)\n+```compile_fail,E0535\n #[inline(unknown)] // error: invalid argument\n pub fn something() {}\n "}, {"sha": "d5bba941c1dd21fb040fca888f1af56de6415ce6", "filename": "src/librustc_error_codes/error_codes/E0565.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0565.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,16 +2,20 @@ A literal was used in a built-in attribute that doesn't support literals.\n \n Erroneous code example:\n \n-```ignore (compile_fail not working here; see Issue #43707)\n-#[inline(\"always\")] // error: unsupported literal\n-pub fn something() {}\n+```compile_fail,E0565\n+#[repr(\"C\")] // error: meta item in `repr` must be an identifier\n+struct Repr {}\n+\n+fn main() {}\n ```\n \n Literals in attributes are new and largely unsupported in built-in attributes.\n Work to support literals where appropriate is ongoing. Try using an unquoted\n name instead:\n \n ```\n-#[inline(always)]\n-pub fn something() {}\n+#[repr(C)] // ok!\n+struct Repr {}\n+\n+fn main() {}\n ```"}, {"sha": "cc6e03d1ca70f9ff0d56752faabb96899c349b57", "filename": "src/librustc_error_codes/error_codes/E0626.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0626.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0626.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0626.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,7 +12,7 @@ let mut b = || {\n     yield (); // ...is still in scope here, when the yield occurs.\n     println!(\"{}\", a);\n };\n-Pin::new(&mut b).resume();\n+Pin::new(&mut b).resume(());\n ```\n \n At present, it is not permitted to have a yield that occurs while a\n@@ -31,7 +31,7 @@ let mut b = || {\n     yield ();\n     println!(\"{}\", a);\n };\n-Pin::new(&mut b).resume();\n+Pin::new(&mut b).resume(());\n ```\n \n This is a very simple case, of course. In more complex cases, we may\n@@ -50,7 +50,7 @@ let mut b = || {\n     yield x; // ...when this yield occurs.\n   }\n };\n-Pin::new(&mut b).resume();\n+Pin::new(&mut b).resume(());\n ```\n \n Such cases can sometimes be resolved by iterating \"by value\" (or using\n@@ -66,7 +66,7 @@ let mut b = || {\n     yield x; // <-- Now yield is OK.\n   }\n };\n-Pin::new(&mut b).resume();\n+Pin::new(&mut b).resume(());\n ```\n \n If taking ownership is not an option, using indices can work too:\n@@ -83,7 +83,7 @@ let mut b = || {\n     yield x; // <-- Now yield is OK.\n   }\n };\n-Pin::new(&mut b).resume();\n+Pin::new(&mut b).resume(());\n \n // (*) -- Unfortunately, these temporaries are currently required.\n // See <https://github.com/rust-lang/rust/issues/43122>."}, {"sha": "7f488cde664d94859cfe17920775b11be27b3e71", "filename": "src/librustc_error_codes/error_codes/E0633.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0633.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,7 +2,9 @@ The `unwind` attribute was malformed.\n \n Erroneous code example:\n \n-```ignore (compile_fail not working here; see Issue #43707)\n+```compile_fail,E0633\n+#![feature(unwind_attributes)]\n+\n #[unwind()] // error: expected one argument\n pub extern fn something() {}\n "}, {"sha": "f5d26244fb961e15abe11e1b8ed946502e4eafee", "filename": "src/librustc_error_codes/error_codes/E0668.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0668.md", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_error_codes%2Ferror_codes%2FE0668.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0668.md?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ assembly call.\n \n In particular, it can happen if you forgot the closing bracket of a register\n constraint (see issue #51430):\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+```compile_fail,E0668\n #![feature(asm)]\n \n fn main() {"}, {"sha": "d83175694f407933ff9fa1eff575ddf06965f418", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -23,7 +23,7 @@ pub struct AnnotateSnippetEmitterWriter {\n     /// If true, will normalize line numbers with `LL` to prevent noise in UI test diffs.\n     ui_testing: bool,\n \n-    external_macro_backtrace: bool,\n+    macro_backtrace: bool,\n }\n \n impl Emitter for AnnotateSnippetEmitterWriter {\n@@ -32,12 +32,12 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n-        self.fix_multispans_in_std_macros(\n+        self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &self.source_map,\n             &mut primary_span,\n             &mut children,\n             &diag.level,\n-            self.external_macro_backtrace,\n+            self.macro_backtrace,\n         );\n \n         self.emit_messages_default(\n@@ -172,9 +172,9 @@ impl AnnotateSnippetEmitterWriter {\n     pub fn new(\n         source_map: Option<Lrc<SourceMap>>,\n         short_message: bool,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> Self {\n-        Self { source_map, short_message, ui_testing: false, external_macro_backtrace }\n+        Self { source_map, short_message, ui_testing: false, macro_backtrace }\n     }\n \n     /// Allows to modify `Self` to enable or disable the `ui_testing` flag."}, {"sha": "f3653da4be6663d3e4577b98e14cd9cda869037b", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 140, "deletions": 91, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -14,7 +14,6 @@ use rustc_span::{MultiSpan, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n-use crate::Level::Error;\n use crate::{\n     pluralize, CodeSuggestion, Diagnostic, DiagnosticId, Level, SubDiagnostic, SuggestionStyle,\n };\n@@ -27,6 +26,7 @@ use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n use std::io;\n use std::io::prelude::*;\n+use std::iter;\n use std::path::Path;\n use termcolor::{Ansi, BufferWriter, ColorChoice, ColorSpec, StandardStream};\n use termcolor::{Buffer, Color, WriteColor};\n@@ -54,19 +54,11 @@ impl HumanReadableErrorType {\n         source_map: Option<Lrc<SourceMap>>,\n         teach: bool,\n         terminal_width: Option<usize>,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n-        EmitterWriter::new(\n-            dst,\n-            source_map,\n-            short,\n-            teach,\n-            color,\n-            terminal_width,\n-            external_macro_backtrace,\n-        )\n+        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width, macro_backtrace)\n     }\n }\n \n@@ -280,138 +272,195 @@ pub trait Emitter {\n         }\n     }\n \n-    // This does a small \"fix\" for multispans by looking to see if it can find any that\n-    // point directly at <*macros>. Since these are often difficult to read, this\n-    // will change the span to point at the use site.\n-    fn fix_multispans_in_std_macros(\n+    fn fix_multispans_in_extern_macros_and_render_macro_backtrace(\n         &self,\n         source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n         children: &mut Vec<SubDiagnostic>,\n         level: &Level,\n         backtrace: bool,\n     ) {\n-        let mut spans_updated = self.fix_multispan_in_std_macros(source_map, span, backtrace);\n-        for child in children.iter_mut() {\n-            spans_updated |=\n-                self.fix_multispan_in_std_macros(source_map, &mut child.span, backtrace);\n+        // Check for spans in macros, before `fix_multispans_in_extern_macros`\n+        // has a chance to replace them.\n+        let has_macro_spans = iter::once(&*span)\n+            .chain(children.iter().map(|child| &child.span))\n+            .flat_map(|span| span.primary_spans())\n+            .copied()\n+            .flat_map(|sp| {\n+                sp.macro_backtrace().filter_map(|expn_data| {\n+                    match expn_data.kind {\n+                        ExpnKind::Root => None,\n+\n+                        // Skip past non-macro entries, just in case there\n+                        // are some which do actually involve macros.\n+                        ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n+\n+                        ExpnKind::Macro(macro_kind, _) => Some(macro_kind),\n+                    }\n+                })\n+            })\n+            .next();\n+\n+        if !backtrace {\n+            self.fix_multispans_in_extern_macros(source_map, span, children);\n         }\n-        let msg = if level == &Error {\n-            \"this error originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\"\n-                .to_string()\n-        } else {\n-            \"this warning originates in a macro outside of the current crate \\\n-             (in Nightly builds, run with -Z external-macro-backtrace \\\n-              for more info)\"\n-                .to_string()\n-        };\n \n-        if spans_updated {\n-            children.push(SubDiagnostic {\n-                level: Level::Note,\n-                message: vec![(msg, Style::NoStyle)],\n-                span: MultiSpan::new(),\n-                render_span: None,\n-            });\n+        self.render_multispans_macro_backtrace(span, children, backtrace);\n+\n+        if !backtrace {\n+            if let Some(macro_kind) = has_macro_spans {\n+                let msg = format!(\n+                    \"this {} originates in {} {} \\\n+                    (in Nightly builds, run with -Z macro-backtrace for more info)\",\n+                    level,\n+                    macro_kind.article(),\n+                    macro_kind.descr(),\n+                );\n+\n+                children.push(SubDiagnostic {\n+                    level: Level::Note,\n+                    message: vec![(msg, Style::NoStyle)],\n+                    span: MultiSpan::new(),\n+                    render_span: None,\n+                });\n+            }\n         }\n     }\n \n-    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n-    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n-    // <*macros> to their corresponding use site.\n-    fn fix_multispan_in_std_macros(\n+    fn render_multispans_macro_backtrace(\n         &self,\n-        source_map: &Option<Lrc<SourceMap>>,\n         span: &mut MultiSpan,\n-        always_backtrace: bool,\n-    ) -> bool {\n-        let sm = match source_map {\n-            Some(ref sm) => sm,\n-            None => return false,\n-        };\n+        children: &mut Vec<SubDiagnostic>,\n+        backtrace: bool,\n+    ) {\n+        for span in iter::once(span).chain(children.iter_mut().map(|child| &mut child.span)) {\n+            self.render_multispan_macro_backtrace(span, backtrace);\n+        }\n+    }\n \n-        let mut before_after: Vec<(Span, Span)> = vec![];\n+    fn render_multispan_macro_backtrace(&self, span: &mut MultiSpan, always_backtrace: bool) {\n         let mut new_labels: Vec<(Span, String)> = vec![];\n \n-        // First, find all the spans in <*macros> and point instead at their use site\n-        for sp in span.primary_spans() {\n+        for &sp in span.primary_spans() {\n             if sp.is_dummy() {\n                 continue;\n             }\n-            let call_sp = sm.call_span_if_macro(*sp);\n-            if call_sp != *sp && !always_backtrace {\n-                before_after.push((*sp, call_sp));\n-            }\n+\n+            // FIXME(eddyb) use `retain` on `macro_backtrace` to remove all the\n+            // entries we don't want to print, to make sure the indices being\n+            // printed are contiguous (or omitted if there's only one entry).\n             let macro_backtrace: Vec<_> = sp.macro_backtrace().collect();\n-            let backtrace_len = macro_backtrace.len();\n             for (i, trace) in macro_backtrace.iter().rev().enumerate() {\n-                // Only show macro locations that are local\n-                // and display them like a span_note\n                 if trace.def_site.is_dummy() {\n                     continue;\n                 }\n+\n                 if always_backtrace {\n                     new_labels.push((\n                         trace.def_site,\n                         format!(\n                             \"in this expansion of `{}`{}\",\n                             trace.kind.descr(),\n-                            if backtrace_len > 2 {\n-                                // if backtrace_len == 1 it'll be pointed\n-                                // at by \"in this macro invocation\"\n+                            if macro_backtrace.len() > 2 {\n+                                // if macro_backtrace.len() == 1 it'll be\n+                                // pointed at by \"in this macro invocation\"\n                                 format!(\" (#{})\", i + 1)\n                             } else {\n                                 String::new()\n-                            }\n+                            },\n                         ),\n                     ));\n                 }\n-                // Check to make sure we're not in any <*macros>\n-                if !sm.span_to_filename(trace.def_site).is_macros()\n-                    && matches!(trace.kind, ExpnKind::Macro(MacroKind::Bang, _))\n+\n+                // Don't add a label on the call site if the diagnostic itself\n+                // already points to (a part of) that call site, as the label\n+                // is meant for showing the relevant invocation when the actual\n+                // diagnostic is pointing to some part of macro definition.\n+                //\n+                // This also handles the case where an external span got replaced\n+                // with the call site span by `fix_multispans_in_extern_macros`.\n+                //\n+                // NB: `-Zmacro-backtrace` overrides this, for uniformity, as the\n+                // \"in this expansion of\" label above is always added in that mode,\n+                // and it needs an \"in this macro invocation\" label to match that.\n+                let redundant_span = trace.call_site.contains(sp);\n+\n+                if !redundant_span && matches!(trace.kind, ExpnKind::Macro(MacroKind::Bang, _))\n                     || always_backtrace\n                 {\n                     new_labels.push((\n                         trace.call_site,\n                         format!(\n                             \"in this macro invocation{}\",\n-                            if backtrace_len > 2 && always_backtrace {\n+                            if macro_backtrace.len() > 2 && always_backtrace {\n                                 // only specify order when the macro\n                                 // backtrace is multiple levels deep\n                                 format!(\" (#{})\", i + 1)\n                             } else {\n                                 String::new()\n-                            }\n+                            },\n                         ),\n                     ));\n-                    if !always_backtrace {\n-                        break;\n-                    }\n+                }\n+                if !always_backtrace {\n+                    break;\n                 }\n             }\n         }\n+\n         for (label_span, label_text) in new_labels {\n             span.push_span_label(label_span, label_text);\n         }\n-        for sp_label in span.span_labels() {\n-            if sp_label.span.is_dummy() {\n-                continue;\n-            }\n-            if sm.span_to_filename(sp_label.span.clone()).is_macros() && !always_backtrace {\n-                if let Some(use_site) = sp_label.span.macro_backtrace().last() {\n-                    before_after.push((sp_label.span, use_site.call_site));\n-                }\n-            }\n+    }\n+\n+    // This does a small \"fix\" for multispans by looking to see if it can find any that\n+    // point directly at <*macros>. Since these are often difficult to read, this\n+    // will change the span to point at the use site.\n+    fn fix_multispans_in_extern_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+        children: &mut Vec<SubDiagnostic>,\n+    ) {\n+        for span in iter::once(span).chain(children.iter_mut().map(|child| &mut child.span)) {\n+            self.fix_multispan_in_extern_macros(source_map, span);\n         }\n+    }\n+\n+    // This \"fixes\" MultiSpans that contain Spans that are pointing to locations inside of\n+    // <*macros>. Since these locations are often difficult to read, we move these Spans from\n+    // <*macros> to their corresponding use site.\n+    fn fix_multispan_in_extern_macros(\n+        &self,\n+        source_map: &Option<Lrc<SourceMap>>,\n+        span: &mut MultiSpan,\n+    ) {\n+        let sm = match source_map {\n+            Some(ref sm) => sm,\n+            None => return,\n+        };\n+\n+        // First, find all the spans in <*macros> and point instead at their use site\n+        let replacements: Vec<(Span, Span)> = span\n+            .primary_spans()\n+            .iter()\n+            .copied()\n+            .chain(span.span_labels().iter().map(|sp_label| sp_label.span))\n+            .filter_map(|sp| {\n+                if !sp.is_dummy() && sm.span_to_filename(sp).is_macros() {\n+                    let maybe_callsite = sp.source_callsite();\n+                    if sp != maybe_callsite {\n+                        return Some((sp, maybe_callsite));\n+                    }\n+                }\n+                None\n+            })\n+            .collect();\n+\n         // After we have them, make sure we replace these 'bad' def sites with their use sites\n-        let spans_updated = !before_after.is_empty();\n-        for (before, after) in before_after {\n-            span.replace(before, after);\n+        for (from, to) in replacements {\n+            span.replace(from, to);\n         }\n-\n-        spans_updated\n     }\n }\n \n@@ -424,12 +473,12 @@ impl Emitter for EmitterWriter {\n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n \n-        self.fix_multispans_in_std_macros(\n+        self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &self.sm,\n             &mut primary_span,\n             &mut children,\n             &diag.level,\n-            self.external_macro_backtrace,\n+            self.macro_backtrace,\n         );\n \n         self.emit_messages_default(\n@@ -508,7 +557,7 @@ pub struct EmitterWriter {\n     ui_testing: bool,\n     terminal_width: Option<usize>,\n \n-    external_macro_backtrace: bool,\n+    macro_backtrace: bool,\n }\n \n #[derive(Debug)]\n@@ -525,7 +574,7 @@ impl EmitterWriter {\n         short_message: bool,\n         teach: bool,\n         terminal_width: Option<usize>,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n@@ -535,7 +584,7 @@ impl EmitterWriter {\n             teach,\n             ui_testing: false,\n             terminal_width,\n-            external_macro_backtrace,\n+            macro_backtrace,\n         }\n     }\n \n@@ -546,7 +595,7 @@ impl EmitterWriter {\n         teach: bool,\n         colored: bool,\n         terminal_width: Option<usize>,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n@@ -555,7 +604,7 @@ impl EmitterWriter {\n             teach,\n             ui_testing: false,\n             terminal_width,\n-            external_macro_backtrace,\n+            macro_backtrace,\n         }\n     }\n "}, {"sha": "ffdff6acec5de1b0a08553198c048fda445667b3", "filename": "src/librustc_errors/json.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fjson.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -36,7 +36,7 @@ pub struct JsonEmitter {\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n-    external_macro_backtrace: bool,\n+    macro_backtrace: bool,\n }\n \n impl JsonEmitter {\n@@ -45,7 +45,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::stderr()),\n@@ -54,22 +54,22 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n-            external_macro_backtrace,\n+            macro_backtrace,\n         }\n     }\n \n     pub fn basic(\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(\n             None,\n             Lrc::new(SourceMap::new(file_path_mapping)),\n             pretty,\n             json_rendered,\n-            external_macro_backtrace,\n+            macro_backtrace,\n         )\n     }\n \n@@ -79,7 +79,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n-        external_macro_backtrace: bool,\n+        macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n@@ -88,7 +88,7 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n-            external_macro_backtrace,\n+            macro_backtrace,\n         }\n     }\n \n@@ -245,13 +245,7 @@ impl Diagnostic {\n         let buf = BufWriter::default();\n         let output = buf.clone();\n         je.json_rendered\n-            .new_emitter(\n-                Box::new(buf),\n-                Some(je.sm.clone()),\n-                false,\n-                None,\n-                je.external_macro_backtrace,\n-            )\n+            .new_emitter(Box::new(buf), Some(je.sm.clone()), false, None, je.macro_backtrace)\n             .ui_testing(je.ui_testing)\n             .emit_diagnostic(diag);\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();"}, {"sha": "97667febc3ca235d5b1c2429dd46b86f89f545a8", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -336,9 +336,9 @@ pub struct HandlerFlags {\n     /// If true, immediately print bugs registered with `delay_span_bug`.\n     /// (rustc: see `-Z report-delayed-bugs`)\n     pub report_delayed_bugs: bool,\n-    /// show macro backtraces even for non-local macros.\n-    /// (rustc: see `-Z external-macro-backtrace`)\n-    pub external_macro_backtrace: bool,\n+    /// Show macro backtraces.\n+    /// (rustc: see `-Z macro-backtrace`)\n+    pub macro_backtrace: bool,\n     /// If true, identical diagnostics are reported only once.\n     pub deduplicate_diagnostics: bool,\n }\n@@ -385,7 +385,7 @@ impl Handler {\n             false,\n             false,\n             None,\n-            flags.external_macro_backtrace,\n+            flags.macro_backtrace,\n         ));\n         Self::with_emitter_and_flags(emitter, flags)\n     }"}, {"sha": "d7fd15a8a7b5fd681bd7928f62c0e2c6e382d525", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -541,6 +541,9 @@ declare_features! (\n     /// Allows `T: ?const Trait` syntax in bounds.\n     (active, const_trait_bound_opt_out, \"1.42.0\", Some(67794), None),\n \n+    /// Allows the use of `no_sanitize` attribute.\n+    (active, no_sanitize, \"1.42.0\", Some(39699), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "e2e061c185c03f58adfa29f42f02d94b0da9ac1b", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -261,6 +261,11 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(cold, Whitelisted, template!(Word)),\n     ungated!(no_builtins, Whitelisted, template!(Word)),\n     ungated!(target_feature, Whitelisted, template!(List: r#\"enable = \"name\"\"#)),\n+    gated!(\n+        no_sanitize, Whitelisted,\n+        template!(List: \"address, memory, thread\"),\n+        experimental!(no_sanitize)\n+    ),\n \n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     ungated!(doc, Whitelisted, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),"}, {"sha": "1dfe97238a3df8b7f6235f08b0383733d7e86992", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -574,6 +574,14 @@ impl<I: Idx, T> IndexVec<I, T> {\n         IndexVec { raw: vec![elem; n], _marker: PhantomData }\n     }\n \n+    /// Create an `IndexVec` with `n` elements, where the value of each\n+    /// element is the result of `func(i)`\n+    #[inline]\n+    pub fn from_fn_n(func: impl FnMut(I) -> T, n: usize) -> Self {\n+        let indices = (0..n).map(I::new);\n+        Self::from_raw(indices.map(func).collect())\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());"}, {"sha": "6224c4654d695df818e05ad25ec31082bc3e9e62", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -25,6 +25,7 @@ use rustc_data_structures::{box_region_allow_access, declare_box_region_type, pa\n use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc_hir::Crate;\n use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;\n@@ -422,7 +423,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n     dep_graph: &'res DepGraph,\n     krate: &'res ast::Crate,\n     arena: &'tcx Arena<'tcx>,\n-) -> Result<map::Forest<'tcx>> {\n+) -> Crate<'tcx> {\n     // Lower AST to HIR.\n     let hir_crate = rustc_ast_lowering::lower_crate(\n         sess,\n@@ -437,8 +438,6 @@ pub fn lower_to_hir<'res, 'tcx>(\n         hir_stats::print_hir_stats(&hir_crate);\n     }\n \n-    let hir_forest = map::Forest::new(hir_crate, &dep_graph);\n-\n     sess.time(\"early_lint_checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n@@ -455,7 +454,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n         rustc_span::hygiene::clear_syntax_context_map();\n     }\n \n-    Ok(hir_forest)\n+    hir_crate\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -705,7 +704,8 @@ impl<'tcx> QueryContext<'tcx> {\n pub fn create_global_ctxt<'tcx>(\n     compiler: &'tcx Compiler,\n     lint_store: Lrc<LintStore>,\n-    hir_forest: &'tcx map::Forest<'tcx>,\n+    krate: &'tcx Crate<'tcx>,\n+    dep_graph: DepGraph,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n@@ -716,7 +716,7 @@ pub fn create_global_ctxt<'tcx>(\n     let defs = mem::take(&mut resolver_outputs.definitions);\n \n     // Construct the HIR map.\n-    let hir_map = map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs);\n+    let hir_map = map::map_crate(sess, &*resolver_outputs.cstore, krate, dep_graph, defs);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n "}, {"sha": "720d162ac819e439e3ece957dd6df9031faf527c", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,7 +3,6 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n-use rustc::hir::map;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n@@ -12,6 +11,7 @@ use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::Crate;\n use rustc_incremental::DepGraphFuture;\n use rustc_lint::LintStore;\n use std::any::Any;\n@@ -74,7 +74,7 @@ pub struct Queries<'tcx> {\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(&'tcx map::Forest<'tcx>, Steal<ResolverOutputs>)>,\n+    lower_to_hir: Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n     global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n@@ -207,24 +207,22 @@ impl<'tcx> Queries<'tcx> {\n         })\n     }\n \n-    pub fn lower_to_hir(\n-        &'tcx self,\n-    ) -> Result<&Query<(&'tcx map::Forest<'tcx>, Steal<ResolverOutputs>)>> {\n+    pub fn lower_to_hir(&'tcx self) -> Result<&Query<(&'tcx Crate<'tcx>, Steal<ResolverOutputs>)>> {\n         self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n             let lint_store = &peeked.2;\n             let hir = resolver.borrow_mut().access(|resolver| {\n-                passes::lower_to_hir(\n+                Ok(passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate,\n                     &self.arena,\n-                )\n+                ))\n             })?;\n             let hir = self.arena.alloc(hir);\n             Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n@@ -253,12 +251,14 @@ impl<'tcx> Queries<'tcx> {\n             let outputs = self.prepare_outputs()?.peek().clone();\n             let lint_store = self.expansion()?.peek().2.clone();\n             let hir = self.lower_to_hir()?.peek();\n-            let (ref hir_forest, ref resolver_outputs) = &*hir;\n+            let dep_graph = self.dep_graph()?.peek().clone();\n+            let (ref krate, ref resolver_outputs) = &*hir;\n             let _timer = self.session().timer(\"create_global_ctxt\");\n             Ok(passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n-                hir_forest,\n+                krate,\n+                dep_graph,\n                 resolver_outputs.steal(),\n                 outputs,\n                 &crate_name,"}, {"sha": "4133047af78fed193724f18fffb5a40667a33b96", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -796,7 +796,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered =\n-                    hir::print::to_string(self.tcx.hir(), |s| s.print_trait_item(ast_item));\n+                    hir::print::to_string(&self.tcx.hir(), |s| s.print_trait_item(ast_item));\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(\n@@ -1009,7 +1009,7 @@ impl EncodeContext<'tcx> {\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n         let body = self.tcx.hir().body(body_id);\n-        let rendered = hir::print::to_string(self.tcx.hir(), |s| s.print_expr(&body.value));\n+        let rendered = hir::print::to_string(&self.tcx.hir(), |s| s.print_expr(&body.value));\n         let rendered_const = &RenderedConst(rendered);\n         self.lazy(rendered_const)\n     }"}, {"sha": "09d61d9ad9ad130e5836cc98b4c6137c89ebc583", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased\n             | ty::ReClosureBound(..) => None,\n         }"}, {"sha": "392f164d3148c49434e54a5cd7f4637712dc8bed", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -159,7 +159,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     self.consume_operand(location, index);\n                 }\n             }\n-            TerminatorKind::Yield { ref value, resume, drop: _ } => {\n+            TerminatorKind::Yield { ref value, resume, resume_arg, drop: _ } => {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n@@ -170,6 +170,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                         self.all_facts.invalidates.push((resume, i));\n                     }\n                 }\n+\n+                self.mutate_place(location, resume_arg, Deep, JustWrite);\n             }\n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {\n                 // Invalidate all borrows of local places"}, {"sha": "e528159fcef17d4a373db566c3bd5095fab56e71", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -684,7 +684,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, drop: _ } => {\n+            TerminatorKind::Yield { ref value, resume: _, ref resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n \n                 if self.movable_generator {\n@@ -697,6 +697,8 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                         }\n                     });\n                 }\n+\n+                self.mutate_place(loc, (resume_arg, span), Deep, JustWrite, flow_state);\n             }\n \n             TerminatorKind::Resume | TerminatorKind::Return | TerminatorKind::GeneratorDrop => {"}, {"sha": "6abca481eac9c12302c09bb9b381a175079ccdd8", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1108,6 +1108,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 self.eval_if_eq(tcx, body, generic_ty, lower_bound, test_ty, verify_bound1)\n             }\n \n+            VerifyBound::IsEmpty => {\n+                let lower_bound_scc = self.constraint_sccs.scc(lower_bound);\n+                self.scc_values.elements_contained_in(lower_bound_scc).next().is_none()\n+            }\n+\n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n                 self.eval_outlives(r_vid, lower_bound)"}, {"sha": "a3e38cd7a5f856deb6096b0e62e08e00cf76ec72", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -160,7 +160,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME -- this is not the fix I would prefer\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let b = self.to_region_vid(b);\n@@ -175,7 +176,8 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n-        if let ty::ReEmpty = a {\n+        // FIXME: I'd prefer if NLL had a notion of empty\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n             return;\n         }\n         let type_test = self.verify_to_type_test(kind, a, bound);"}, {"sha": "cf8c3449d666be4476f3fc2df59c868c02f2b2cd", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::ConstraintCategory;\n use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::free_region_map::FreeRegionRelations;\n-use rustc::ty::{self, RegionVid, Ty};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_span::DUMMY_SP;\n use std::rc::Rc;\n@@ -333,7 +333,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n                     // `where Type:` is lowered to `where Type: 'empty` so that\n                     // we check `Type` is well formed, but there's no use for\n                     // this bound here.\n-                    if let ty::ReEmpty = r1 {\n+                    if let ty::ReEmpty(_) = r1 {\n                         return;\n                     }\n \n@@ -359,7 +359,12 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n /// over the `FreeRegionMap` from lexical regions and\n /// `UniversalRegions` (from NLL)`.\n impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegionRelations<'tcx> {\n-    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+    fn sub_free_regions(\n+        &self,\n+        _tcx: TyCtxt<'tcx>,\n+        shorter: ty::Region<'tcx>,\n+        longer: ty::Region<'tcx>,\n+    ) -> bool {\n         let shorter = shorter.to_region_vid();\n         assert!(self.universal_regions.is_universal_region(shorter));\n         let longer = longer.to_region_vid();"}, {"sha": "f6e3ca2f80900d2a555e386621bbca4d8f44d6bf", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -581,9 +581,11 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n                 assert_eq!(self.mir_def_id, def_id);\n+                let resume_ty = substs.as_generator().resume_ty(def_id, tcx);\n                 let output = substs.as_generator().return_ty(def_id, tcx);\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n-                let inputs_and_output = self.infcx.tcx.intern_type_list(&[generator_ty, output]);\n+                let inputs_and_output =\n+                    self.infcx.tcx.intern_type_list(&[generator_ty, resume_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }\n "}, {"sha": "040c13e8210ea056bc8eb23219d8744740ecbd94", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -31,10 +31,12 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n         self.body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n-        // Nothing is live on function entry (generators only have a self\n-        // argument, and we don't care about that)\n-        assert_eq!(1, self.body.arg_count);\n+    fn start_block_effect(&self, on_entry: &mut BitSet<Local>) {\n+        // The resume argument is live on function entry (we don't care about\n+        // the `self` argument)\n+        for arg in self.body.args_iter().skip(1) {\n+            on_entry.insert(arg);\n+        }\n     }\n \n     fn statement_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n@@ -100,10 +102,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         self.body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n-        // Nothing is live on function entry (generators only have a self\n-        // argument, and we don't care about that)\n-        assert_eq!(1, self.body.arg_count);\n+    fn start_block_effect(&self, on_entry: &mut BitSet<Local>) {\n+        // The resume argument is live on function entry (we don't care about\n+        // the `self` argument)\n+        for arg in self.body.args_iter().skip(1) {\n+            on_entry.insert(arg);\n+        }\n     }\n \n     fn before_statement_effect(&self, sets: &mut GenKillSet<Self::Idx>, loc: Location) {"}, {"sha": "6f8caca5e21ef1125ee66f2dfd25b798ac2f7542", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -380,7 +380,9 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.gather_operand(discr);\n             }\n \n-            TerminatorKind::Yield { ref value, .. } => {\n+            TerminatorKind::Yield { ref value, resume_arg: ref place, .. } => {\n+                self.create_move_path(place);\n+                self.gather_init(place.as_ref(), InitKind::Deep);\n                 self.gather_operand(value);\n             }\n "}, {"sha": "a6fc65731780a506037e4b26c446cd3b8a4c8b03", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 94, "deletions": 26, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -192,9 +192,10 @@ const RETURNED: usize = GeneratorSubsts::RETURNED;\n /// Generator has been poisoned\n const POISONED: usize = GeneratorSubsts::POISONED;\n \n-struct SuspensionPoint {\n+struct SuspensionPoint<'tcx> {\n     state: usize,\n     resume: BasicBlock,\n+    resume_arg: Place<'tcx>,\n     drop: Option<BasicBlock>,\n     storage_liveness: liveness::LiveVarSet,\n }\n@@ -216,7 +217,7 @@ struct TransformVisitor<'tcx> {\n     storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n \n     // A list of suspension points, generated during the transform\n-    suspension_points: Vec<SuspensionPoint>,\n+    suspension_points: Vec<SuspensionPoint<'tcx>>,\n \n     // The original RETURN_PLACE local\n     new_ret_local: Local,\n@@ -303,8 +304,8 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                 Operand::Move(Place::from(self.new_ret_local)),\n                 None,\n             )),\n-            TerminatorKind::Yield { ref value, resume, drop } => {\n-                Some((VariantIdx::new(0), Some(resume), value.clone(), drop))\n+            TerminatorKind::Yield { ref value, resume, resume_arg, drop } => {\n+                Some((VariantIdx::new(0), Some((resume, resume_arg)), value.clone(), drop))\n             }\n             _ => None,\n         };\n@@ -319,13 +320,14 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n                     self.make_state(state_idx, v),\n                 )),\n             });\n-            let state = if let Some(resume) = resume {\n+            let state = if let Some((resume, resume_arg)) = resume {\n                 // Yield\n                 let state = 3 + self.suspension_points.len();\n \n                 self.suspension_points.push(SuspensionPoint {\n                     state,\n                     resume,\n+                    resume_arg,\n                     drop,\n                     storage_liveness: self.storage_liveness.get(&block).unwrap().clone(),\n                 });\n@@ -378,28 +380,35 @@ fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body\n     PinArgVisitor { ref_gen_ty, tcx }.visit_body(body);\n }\n \n-fn replace_result_variable<'tcx>(\n-    ret_ty: Ty<'tcx>,\n+/// Allocates a new local and replaces all references of `local` with it. Returns the new local.\n+///\n+/// `local` will be changed to a new local decl with type `ty`.\n+///\n+/// Note that the new local will be uninitialized. It is the caller's responsibility to assign some\n+/// valid value to it before its first use.\n+fn replace_local<'tcx>(\n+    local: Local,\n+    ty: Ty<'tcx>,\n     body: &mut BodyAndCache<'tcx>,\n     tcx: TyCtxt<'tcx>,\n ) -> Local {\n     let source_info = source_info(body);\n-    let new_ret = LocalDecl {\n+    let new_decl = LocalDecl {\n         mutability: Mutability::Mut,\n-        ty: ret_ty,\n+        ty,\n         user_ty: UserTypeProjections::none(),\n         source_info,\n         internal: false,\n         is_block_tail: None,\n         local_info: LocalInfo::Other,\n     };\n-    let new_ret_local = Local::new(body.local_decls.len());\n-    body.local_decls.push(new_ret);\n-    body.local_decls.swap(RETURN_PLACE, new_ret_local);\n+    let new_local = Local::new(body.local_decls.len());\n+    body.local_decls.push(new_decl);\n+    body.local_decls.swap(local, new_local);\n \n-    RenameLocalVisitor { from: RETURN_PLACE, to: new_ret_local, tcx }.visit_body(body);\n+    RenameLocalVisitor { from: local, to: new_local, tcx }.visit_body(body);\n \n-    new_ret_local\n+    new_local\n }\n \n struct StorageIgnored(liveness::LiveVarSet);\n@@ -792,6 +801,10 @@ fn compute_layout<'tcx>(\n     (remap, layout, storage_liveness)\n }\n \n+/// Replaces the entry point of `body` with a block that switches on the generator discriminant and\n+/// dispatches to blocks according to `cases`.\n+///\n+/// After this function, the former entry point of the function will be bb1.\n fn insert_switch<'tcx>(\n     body: &mut BodyAndCache<'tcx>,\n     cases: Vec<(usize, BasicBlock)>,\n@@ -885,10 +898,11 @@ fn create_generator_drop_shim<'tcx>(\n     drop_clean: BasicBlock,\n ) -> BodyAndCache<'tcx> {\n     let mut body = body.clone();\n+    body.arg_count = 1; // make sure the resume argument is not included here\n \n     let source_info = source_info(&body);\n \n-    let mut cases = create_cases(&mut body, transform, |point| point.drop);\n+    let mut cases = create_cases(&mut body, transform, Operation::Drop);\n \n     cases.insert(0, (UNRESUMED, drop_clean));\n \n@@ -1006,7 +1020,7 @@ fn create_generator_resume_function<'tcx>(\n         }\n     }\n \n-    let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n+    let mut cases = create_cases(body, &transform, Operation::Resume);\n \n     use rustc::mir::interpret::PanicInfo::{ResumedAfterPanic, ResumedAfterReturn};\n \n@@ -1056,34 +1070,66 @@ fn insert_clean_drop(body: &mut BodyAndCache<'_>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'tcx, F>(\n+/// An operation that can be performed on a generator.\n+#[derive(PartialEq, Copy, Clone)]\n+enum Operation {\n+    Resume,\n+    Drop,\n+}\n+\n+impl Operation {\n+    fn target_block(self, point: &SuspensionPoint<'_>) -> Option<BasicBlock> {\n+        match self {\n+            Operation::Resume => Some(point.resume),\n+            Operation::Drop => point.drop,\n+        }\n+    }\n+}\n+\n+fn create_cases<'tcx>(\n     body: &mut BodyAndCache<'tcx>,\n     transform: &TransformVisitor<'tcx>,\n-    target: F,\n-) -> Vec<(usize, BasicBlock)>\n-where\n-    F: Fn(&SuspensionPoint) -> Option<BasicBlock>,\n-{\n+    operation: Operation,\n+) -> Vec<(usize, BasicBlock)> {\n     let source_info = source_info(body);\n \n     transform\n         .suspension_points\n         .iter()\n         .filter_map(|point| {\n             // Find the target for this suspension point, if applicable\n-            target(point).map(|target| {\n+            operation.target_block(point).map(|target| {\n                 let block = BasicBlock::new(body.basic_blocks().len());\n                 let mut statements = Vec::new();\n \n                 // Create StorageLive instructions for locals with live storage\n                 for i in 0..(body.local_decls.len()) {\n+                    if i == 2 {\n+                        // The resume argument is live on function entry. Don't insert a\n+                        // `StorageLive`, or the following `Assign` will read from uninitialized\n+                        // memory.\n+                        continue;\n+                    }\n+\n                     let l = Local::new(i);\n                     if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n                         statements\n                             .push(Statement { source_info, kind: StatementKind::StorageLive(l) });\n                     }\n                 }\n \n+                if operation == Operation::Resume {\n+                    // Move the resume argument to the destination place of the `Yield` terminator\n+                    let resume_arg = Local::new(2); // 0 = return, 1 = self\n+                    statements.push(Statement {\n+                        source_info,\n+                        kind: StatementKind::Assign(box (\n+                            point.resume_arg,\n+                            Rvalue::Use(Operand::Move(resume_arg.into())),\n+                        )),\n+                    });\n+                }\n+\n                 // Then jump to the real target\n                 body.basic_blocks_mut().push(BasicBlockData {\n                     statements,\n@@ -1138,7 +1184,29 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n+        let new_ret_local = replace_local(RETURN_PLACE, ret_ty, body, tcx);\n+\n+        // We also replace the resume argument and insert an `Assign`.\n+        // This is needed because the resume argument `_2` might be live across a `yield`, in which\n+        // case there is no `Assign` to it that the transform can turn into a store to the generator\n+        // state. After the yield the slot in the generator state would then be uninitialized.\n+        let resume_local = Local::new(2);\n+        let new_resume_local =\n+            replace_local(resume_local, body.local_decls[resume_local].ty, body, tcx);\n+\n+        // When first entering the generator, move the resume argument into its new local.\n+        let source_info = source_info(body);\n+        let stmts = &mut body.basic_blocks_mut()[BasicBlock::new(0)].statements;\n+        stmts.insert(\n+            0,\n+            Statement {\n+                source_info,\n+                kind: StatementKind::Assign(box (\n+                    new_resume_local.into(),\n+                    Rvalue::Use(Operand::Move(resume_local.into())),\n+                )),\n+            },\n+        );\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n@@ -1162,9 +1230,9 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n         };\n         transform.visit_body(body);\n \n-        // Update our MIR struct to reflect the changed we've made\n+        // Update our MIR struct to reflect the changes we've made\n         body.yield_ty = None;\n-        body.arg_count = 1;\n+        body.arg_count = 2; // self, resume arg\n         body.spread_arg = None;\n         body.generator_layout = Some(layout);\n "}, {"sha": "b6802505df73f0b255f27c3b5c45e630e8f06baa", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::mir::visit::*;\n use rustc::mir::*;\n+use rustc::session::config::Sanitizer;\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeFoldable};\n \n@@ -228,6 +229,28 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n+        // Avoid inlining functions marked as no_sanitize if sanitizer is enabled,\n+        // since instrumentation might be enabled and performed on the caller.\n+        match self.tcx.sess.opts.debugging_opts.sanitizer {\n+            Some(Sanitizer::Address) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_ADDRESS) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Memory) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_MEMORY) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Thread) => {\n+                if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_SANITIZE_THREAD) {\n+                    return false;\n+                }\n+            }\n+            Some(Sanitizer::Leak) => {}\n+            None => {}\n+        }\n+\n         let hinted = match codegen_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we"}, {"sha": "6f5c5f0dd4c5013b795c7cdd4eea0457235930ec", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -230,18 +230,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block = unpack!(this.stmt_expr(block, expr, None));\n                 block.and(this.unit_rvalue())\n             }\n-            ExprKind::Yield { value } => {\n-                let value = unpack!(block = this.as_operand(block, scope, value));\n-                let resume = this.cfg.start_new_block();\n-                let cleanup = this.generator_drop_cleanup();\n-                this.cfg.terminate(\n-                    block,\n-                    source_info,\n-                    TerminatorKind::Yield { value: value, resume: resume, drop: cleanup },\n-                );\n-                resume.and(this.unit_rvalue())\n-            }\n-            ExprKind::Literal { .. }\n+            ExprKind::Yield { .. }\n+            | ExprKind::Literal { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }"}, {"sha": "cc139dee63f92b86100045d40fd406db2764d37c", "filename": "src/librustc_mir_build/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -50,6 +50,7 @@ impl Category {\n             | ExprKind::Adt { .. }\n             | ExprKind::Borrow { .. }\n             | ExprKind::AddressOf { .. }\n+            | ExprKind::Yield { .. }\n             | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }\n@@ -63,7 +64,6 @@ impl Category {\n             | ExprKind::Repeat { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n-            | ExprKind::Yield { .. }\n             | ExprKind::InlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n             ExprKind::Literal { .. } | ExprKind::StaticRef { .. } => Some(Category::Constant),"}, {"sha": "51b0b5bc7cb0b73c320df8bae29c8a8b4b9ea87e", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -365,6 +365,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n \n+            ExprKind::Yield { value } => {\n+                let scope = this.local_scope();\n+                let value = unpack!(block = this.as_operand(block, scope, value));\n+                let resume = this.cfg.start_new_block();\n+                let cleanup = this.generator_drop_cleanup();\n+                this.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Yield {\n+                        value,\n+                        resume,\n+                        resume_arg: destination.clone(),\n+                        drop: cleanup,\n+                    },\n+                );\n+                resume.unit()\n+            }\n+\n             // these are the cases that are more naturally handled by some other mode\n             ExprKind::Unary { .. }\n             | ExprKind::Binary { .. }\n@@ -376,8 +394,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Tuple { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n-            | ExprKind::StaticRef { .. }\n-            | ExprKind::Yield { .. } => {\n+            | ExprKind::StaticRef { .. } => {\n                 debug_assert!(match Category::of(&expr.kind).unwrap() {\n                     // should be handled above\n                     Category::Rvalue(RvalueFunc::Into) => false,"}, {"sha": "32b1f2b6e1368d6d060321e6c7d09be3c2bca971", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -68,28 +68,38 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             let fn_sig = cx.tables().liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n+            let safety = match fn_sig.unsafety {\n+                hir::Unsafety::Normal => Safety::Safe,\n+                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+            };\n+\n+            let body = tcx.hir().body(body_id);\n             let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.kind {\n                 ty::Closure(..) => {\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n-                    Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n+                    vec![ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None)]\n                 }\n                 ty::Generator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_type(id);\n-                    Some(ArgInfo(gen_ty, None, None, None))\n-                }\n-                _ => None,\n-            };\n \n-            let safety = match fn_sig.unsafety {\n-                hir::Unsafety::Normal => Safety::Safe,\n-                hir::Unsafety::Unsafe => Safety::FnUnsafe,\n+                    // The resume argument may be missing, in that case we need to provide it here.\n+                    // It will always be `()` in this case.\n+                    if body.params.is_empty() {\n+                        vec![\n+                            ArgInfo(gen_ty, None, None, None),\n+                            ArgInfo(tcx.mk_unit(), None, None, None),\n+                        ]\n+                    } else {\n+                        vec![ArgInfo(gen_ty, None, None, None)]\n+                    }\n+                }\n+                _ => vec![],\n             };\n \n-            let body = tcx.hir().body(body_id);\n             let explicit_arguments = body.params.iter().enumerate().map(|(index, arg)| {\n                 let owner_id = tcx.hir().body_owner(body_id);\n                 let opt_ty_info;"}, {"sha": "b178110f4f954104881f2a5fcd0b22e884aa618a", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@\n //! through, but errors for structured control flow in a `const` should be emitted here.\n \n use rustc::hir::map::Map;\n+use rustc::hir::Hir;\n use rustc::session::config::nightly_options;\n use rustc::session::parse::feature_err;\n use rustc::ty::query::Providers;\n@@ -74,7 +75,7 @@ enum ConstKind {\n }\n \n impl ConstKind {\n-    fn for_body(body: &hir::Body<'_>, hir_map: &Map<'_>) -> Option<Self> {\n+    fn for_body(body: &hir::Body<'_>, hir_map: Hir<'_>) -> Option<Self> {\n         let is_const_fn = |id| hir_map.fn_sig_by_hir_id(id).unwrap().header.is_const();\n \n         let owner = hir_map.body_owner(body.id());"}, {"sha": "ebd93e9ab85b813db0ca9c3249ef68f9ab261a79", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::map as hir_map;\n+use rustc::hir::Hir;\n use rustc::session::config::EntryFnType;\n use rustc::session::{config, Session};\n use rustc::ty::query::Providers;\n@@ -15,7 +15,7 @@ use syntax::entry::EntryPointType;\n struct EntryContext<'a, 'tcx> {\n     session: &'a Session,\n \n-    map: &'a hir_map::Map<'tcx>,\n+    map: Hir<'tcx>,\n \n     /// The top-level function called `main`.\n     main_fn: Option<(HirId, Span)>,"}, {"sha": "87522d28d1e80fab52e2c292ddce4a36518d647d", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -612,7 +612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n                                 let parent_trait_id = hir::TraitItemId { hir_id: parent_id };\n-                                let krate = self.tcx.hir().forest.krate();\n+                                let krate = self.tcx.hir().krate();\n \n                                 if !(krate.items.contains_key(&parent_id)\n                                     || krate.impl_items.contains_key(&parent_impl_id)"}, {"sha": "75b5e37b2df694f61e29dd2e810156d2b53e28c4", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -624,7 +624,7 @@ impl DebuggingOptions {\n             treat_err_as_bug: self.treat_err_as_bug,\n             dont_buffer_diagnostics: self.dont_buffer_diagnostics,\n             report_delayed_bugs: self.report_delayed_bugs,\n-            external_macro_backtrace: self.external_macro_backtrace,\n+            macro_backtrace: self.macro_backtrace,\n             deduplicate_diagnostics: self.deduplicate_diagnostics.unwrap_or(true),\n         }\n     }"}, {"sha": "5a360b40d61b576fdd2fd7e064711c0cd8328569", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -260,6 +260,16 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    pub COHERENCE_LEAK_CHECK,\n+    Warn,\n+    \"distinct impls distinguished only by the leak-check code\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #56105 <https://github.com/rust-lang/rust/issues/56105>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -474,6 +484,12 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    pub INLINE_NO_SANITIZE,\n+    Warn,\n+    \"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -509,6 +525,7 @@ declare_lint_pass! {\n         MISSING_FRAGMENT_SPECIFIER,\n         LATE_BOUND_LIFETIME_ARGUMENTS,\n         ORDER_DEPENDENT_TRAIT_OBJECTS,\n+        COHERENCE_LEAK_CHECK,\n         DEPRECATED,\n         UNUSED_UNSAFE,\n         UNUSED_MUT,\n@@ -537,5 +554,6 @@ declare_lint_pass! {\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n+        INLINE_NO_SANITIZE,\n     ]\n }"}, {"sha": "0250c40bcdcf1b81e3c799a4c5899cba4d18713c", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -776,8 +776,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"treat error number `val` that occurs as bug\"),\n     report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n         \"immediately print bugs registered with `delay_span_bug`\"),\n-    external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n-        \"show macro backtraces even for non-local macros\"),\n+    macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n+        \"show macro backtraces\"),\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help\"),\n     terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],"}, {"sha": "648dd6ad32a6b01cc94478f69c5eb92da3fbef94", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -858,7 +858,7 @@ fn default_emitter(\n     source_map: &Lrc<source_map::SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n-    let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n+    let macro_backtrace = sopts.debugging_opts.macro_backtrace;\n     match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(kind), dst) => {\n             let (short, color_config) = kind.unzip();\n@@ -867,7 +867,7 @@ fn default_emitter(\n                 let emitter = AnnotateSnippetEmitterWriter::new(\n                     Some(source_map.clone()),\n                     short,\n-                    external_macro_backtrace,\n+                    macro_backtrace,\n                 );\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing()))\n             } else {\n@@ -878,7 +878,7 @@ fn default_emitter(\n                         short,\n                         sopts.debugging_opts.teach,\n                         sopts.debugging_opts.terminal_width,\n-                        external_macro_backtrace,\n+                        macro_backtrace,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n@@ -887,7 +887,7 @@ fn default_emitter(\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n                         None,  // no terminal width\n-                        external_macro_backtrace,\n+                        macro_backtrace,\n                     ),\n                 };\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing()))\n@@ -899,7 +899,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n-                external_macro_backtrace,\n+                macro_backtrace,\n             )\n             .ui_testing(sopts.debugging_opts.ui_testing()),\n         ),\n@@ -910,7 +910,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n-                external_macro_backtrace,\n+                macro_backtrace,\n             )\n             .ui_testing(sopts.debugging_opts.ui_testing()),\n         ),"}, {"sha": "45c4d6dbc6cf4ecdf2867f58e794048b975abce1", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -945,14 +945,6 @@ impl SourceMap {\n             _ => None,\n         })\n     }\n-    pub fn call_span_if_macro(&self, sp: Span) -> Span {\n-        if self.span_to_filename(sp.clone()).is_macros() {\n-            if let Some(use_site) = sp.macro_backtrace().last() {\n-                return use_site.call_site;\n-            }\n-        }\n-        sp\n-    }\n }\n \n #[derive(Clone)]"}, {"sha": "931a3c15cf08ec2ca1a8f3adf620feabc95a47d4", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -120,6 +120,7 @@ symbols! {\n         abi_vectorcall,\n         abi_x86_interrupt,\n         aborts,\n+        address,\n         add_with_overflow,\n         advanced_slice_patterns,\n         adx_target_feature,\n@@ -445,6 +446,7 @@ symbols! {\n         mem_uninitialized,\n         mem_zeroed,\n         member_constraints,\n+        memory,\n         message,\n         meta,\n         min_align_of,\n@@ -487,6 +489,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        no_sanitize,\n         no_stack_check,\n         no_start,\n         no_std,\n@@ -721,6 +724,7 @@ symbols! {\n         test_removed_feature,\n         test_runner,\n         then_with,\n+        thread,\n         thread_local,\n         tool_attributes,\n         tool_lints,"}, {"sha": "301ebf8adc5c700086ba7977bc8d5dab4b80b29c", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -246,9 +246,11 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n                 assert_eq!(a_bound.assert_bound_var(), b_bound.assert_bound_var());\n             }\n \n-            (ty::ReStatic, ty::ReStatic)\n-            | (ty::ReErased, ty::ReErased)\n-            | (ty::ReEmpty, ty::ReEmpty) => (),\n+            (ty::ReStatic, ty::ReStatic) | (ty::ReErased, ty::ReErased) => (),\n+\n+            (ty::ReEmpty(a_ui), ty::ReEmpty(b_ui)) => {\n+                assert_eq!(a_ui, b_ui);\n+            }\n \n             (&ty::ReFree(a_free), &ty::ReFree(b_free)) => {\n                 assert_eq!(a_free, b_free);"}, {"sha": "346d2a931d10b4b6ed068639339a19298ae99a10", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -227,15 +227,16 @@ fn dtorck_constraint_for_ty<'tcx>(\n             // In particular, skipping over `_interior` is safe\n             // because any side-effects from dropping `_interior` can\n             // only take place through references with lifetimes\n-            // derived from lifetimes attached to the upvars, and we\n-            // *do* incorporate the upvars here.\n+            // derived from lifetimes attached to the upvars and resume\n+            // argument, and we *do* incorporate those here.\n \n             constraints.outlives.extend(\n                 substs\n                     .as_generator()\n                     .upvar_tys(def_id, tcx)\n                     .map(|t| -> ty::subst::GenericArg<'tcx> { t.into() }),\n             );\n+            constraints.outlives.push(substs.as_generator().resume_ty(def_id, tcx).into());\n         }\n \n         ty::Adt(def, substs) => {"}, {"sha": "26777b3b0104882c567e248616e1a8142134a61a", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -92,8 +92,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .into(),\n             GenericParamDefKind::Const => span_bug!(expr.span, \"closure has const param\"),\n         });\n-        if let Some(GeneratorTypes { yield_ty, interior, movability }) = generator_types {\n+        if let Some(GeneratorTypes { resume_ty, yield_ty, interior, movability }) = generator_types\n+        {\n             let generator_substs = substs.as_generator();\n+            self.demand_eqtype(\n+                expr.span,\n+                resume_ty,\n+                generator_substs.resume_ty(expr_def_id, self.tcx),\n+            );\n             self.demand_eqtype(\n                 expr.span,\n                 yield_ty,\n@@ -259,8 +265,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => return None,\n             }\n         } else {\n-            // Generators cannot have explicit arguments.\n-            vec![]\n+            // Generators with a `()` resume type may be defined with 0 or 1 explicit arguments,\n+            // else they must have exactly 1 argument. For now though, just give up in this case.\n+            return None;\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;"}, {"sha": "9ce89bd636304ea6a5d404318b882f84582a8416", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1796,16 +1796,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n         src: &'tcx hir::YieldSource,\n     ) -> Ty<'tcx> {\n-        match self.yield_ty {\n-            Some(ty) => {\n-                self.check_expr_coercable_to_type(&value, ty);\n+        match self.resume_yield_tys {\n+            Some((resume_ty, yield_ty)) => {\n+                self.check_expr_coercable_to_type(&value, yield_ty);\n+\n+                resume_ty\n             }\n             // Given that this `yield` expression was generated as a result of lowering a `.await`,\n             // we know that the yield type must be `()`; however, the context won't contain this\n             // information. Hence, we check the source of the yield expression here and check its\n             // value's type against `()` (this check should always hold).\n             None if src == &hir::YieldSource::Await => {\n                 self.check_expr_coercable_to_type(&value, self.tcx.mk_unit());\n+                self.tcx.mk_unit()\n             }\n             _ => {\n                 struct_span_err!(\n@@ -1815,9 +1818,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"yield expression outside of generator literal\"\n                 )\n                 .emit();\n+                self.tcx.mk_unit()\n             }\n         }\n-        self.tcx.mk_unit()\n     }\n }\n "}, {"sha": "7e5d27d93b3cb2bfcc6bb87d20ef6196ce29eee7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -573,7 +573,7 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// First span of a return site that we find. Used in error messages.\n     ret_coercion_span: RefCell<Option<Span>>,\n \n-    yield_ty: Option<Ty<'tcx>>,\n+    resume_yield_tys: Option<(Ty<'tcx>, Ty<'tcx>)>,\n \n     ps: RefCell<UnsafetyState>,\n \n@@ -1251,6 +1251,9 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n /// includes yield), it returns back some information about the yield\n /// points.\n struct GeneratorTypes<'tcx> {\n+    /// Type of generator argument / values returned by `yield`.\n+    resume_ty: Ty<'tcx>,\n+\n     /// Type of value that is yielded.\n     yield_ty: Ty<'tcx>,\n \n@@ -1311,7 +1314,11 @@ fn check_fn<'a, 'tcx>(\n         let yield_ty = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n-        fcx.yield_ty = Some(yield_ty);\n+\n+        // Resume type defaults to `()` if the generator has no argument.\n+        let resume_ty = fn_sig.inputs().get(0).map(|ty| *ty).unwrap_or_else(|| tcx.mk_unit());\n+\n+        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n     }\n \n     let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n@@ -1364,8 +1371,11 @@ fn check_fn<'a, 'tcx>(\n         let interior = fcx\n             .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n         fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+\n+        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n         Some(GeneratorTypes {\n-            yield_ty: fcx.yield_ty.unwrap(),\n+            resume_ty,\n+            yield_ty,\n             interior,\n             movability: can_be_generator.unwrap(),\n         })\n@@ -2588,7 +2598,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &\n         E0533,\n         \"expected unit struct, unit variant or constant, found {} `{}`\",\n         res.descr(),\n-        hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false))\n+        hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false))\n     )\n     .emit();\n }\n@@ -2767,7 +2777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n             ret_coercion_span: RefCell::new(None),\n-            yield_ty: None,\n+            resume_yield_tys: None,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n             diverges: Cell::new(Diverges::Maybe),\n             has_errors: Cell::new(false),"}, {"sha": "47baae68608963eea32a097bf3522cee8a0a5968", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -693,7 +693,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let msg = format!(\n                 \"expected tuple struct or tuple variant, found {} `{}`\",\n                 res.descr(),\n-                hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)),\n+                hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false)),\n             );\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n             match (res, &pat.kind) {"}, {"sha": "3e17b661cf4cea49d55f17fe8f3267c54358ed79", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,5 +1,5 @@\n use crate::namespace::Namespace;\n-use rustc::traits::{self, IntercrateMode};\n+use rustc::traits::{self, IntercrateMode, SkipLeakCheck};\n use rustc::ty::TyCtxt;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n@@ -76,6 +76,9 @@ impl InherentOverlapChecker<'tcx> {\n                     impl1_def_id,\n                     impl2_def_id,\n                     IntercrateMode::Issue43355,\n+                    // We go ahead and just skip the leak check for\n+                    // inherent impls without warning.\n+                    SkipLeakCheck::Yes,\n                     |overlap| {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap);\n                         false"}, {"sha": "2a450f4b4e8b1852e7f1c9d1f9f68a35a5d38ae8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-filelength\n+\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -1189,7 +1191,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     // and we don't do that for closures.\n     if let Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., gen), .. }) = node {\n         let dummy_args = if gen.is_some() {\n-            &[\"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n+            &[\"<resume_ty>\", \"<yield_ty>\", \"<return_ty>\", \"<witness>\"][..]\n         } else {\n             &[\"<closure_kind>\", \"<closure_signature>\"][..]\n         };\n@@ -2322,7 +2324,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        let predicate = ty::OutlivesPredicate(ty, tcx.mk_region(ty::ReEmpty));\n+                        let re_root_empty = tcx.lifetimes.re_root_empty;\n+                        let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n                             ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)),\n                             span,\n@@ -2743,6 +2746,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n \n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n+    let mut no_sanitize_span = None;\n     for attr in attrs.iter() {\n         if attr.check_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n@@ -2832,6 +2836,24 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n             if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n                 codegen_fn_attrs.link_ordinal = ordinal;\n             }\n+        } else if attr.check_name(sym::no_sanitize) {\n+            no_sanitize_span = Some(attr.span);\n+            if let Some(list) = attr.meta_item_list() {\n+                for item in list.iter() {\n+                    if item.check_name(sym::address) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_ADDRESS;\n+                    } else if item.check_name(sym::memory) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_MEMORY;\n+                    } else if item.check_name(sym::thread) {\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_SANITIZE_THREAD;\n+                    } else {\n+                        tcx.sess\n+                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                            .note(\"expected one of: `address`, `memory` or `thread`\")\n+                            .emit();\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -2911,7 +2933,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     // purpose functions as they wouldn't have the right target features\n     // enabled. For that reason we also forbid #[inline(always)] as it can't be\n     // respected.\n-\n     if codegen_fn_attrs.target_features.len() > 0 {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let Some(span) = inline_span {\n@@ -2924,6 +2945,22 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n     }\n \n+    if codegen_fn_attrs.flags.intersects(CodegenFnAttrFlags::NO_SANITIZE_ANY) {\n+        if codegen_fn_attrs.inline == InlineAttr::Always {\n+            if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n+                let hir_id = tcx.hir().as_local_hir_id(id).unwrap();\n+                tcx.struct_span_lint_hir(\n+                    lint::builtin::INLINE_NO_SANITIZE,\n+                    hir_id,\n+                    no_sanitize_span,\n+                    \"`no_sanitize` will have no effect after inlining\",\n+                )\n+                .span_note(inline_span, \"inlining requested here\")\n+                .emit();\n+            }\n+        }\n+    }\n+\n     // Weak lang items have the same semantics as \"std internal\" symbols in the\n     // sense that they're preserved through all our LTO passes and only\n     // strippable by the linker."}, {"sha": "0cc322f8c2d3da900a4d66542a44106acc02f619", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -166,7 +166,7 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n         //\n         //     struct Bar<T>(<Self as Foo>::Type) where Self: ;\n         //     struct Baz<'a>(&'a Self) where Self: ;\n-        RegionKind::ReEmpty => false,\n+        RegionKind::ReEmpty(_) => false,\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased"}, {"sha": "6f5caea250b0719efda46dc9f36d521b529f132b", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -453,7 +453,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types."}, {"sha": "f140f11b090980ec295ba17176dfee9013440354", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -447,7 +447,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n-            | ty::ReEmpty\n+            | ty::ReEmpty(_)\n             | ty::ReClosureBound(_)\n             | ty::ReErased => {\n                 debug!(\"cannot clean region {:?}\", self);\n@@ -521,7 +521,7 @@ impl<'tcx> Clean<Option<WherePredicate>>\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n-            (ty::ReEmpty, ty::ReEmpty) => {\n+            (ty::ReEmpty(_), ty::ReEmpty(_)) => {\n                 return None;\n             }\n             _ => {}\n@@ -539,7 +539,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n-            ty::ReEmpty => return None,\n+            ty::ReEmpty(_) => return None,\n             _ => {}\n         }\n "}, {"sha": "0c7dfa1417a97812266a7bc5101bdee20b49b5cf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -87,7 +87,7 @@ pub fn run(options: Options) -> i32 {\n         compiler.enter(|queries| {\n             let lower_to_hir = queries.lower_to_hir()?;\n \n-            let mut opts = scrape_test_config(lower_to_hir.peek().0.krate());\n+            let mut opts = scrape_test_config(lower_to_hir.peek().0);\n             opts.display_warnings |= options.display_warnings;\n             let enable_per_target_ignores = options.enable_per_target_ignores;\n             let mut collector = Collector::new(\n@@ -107,7 +107,7 @@ pub fn run(options: Options) -> i32 {\n                 let mut hir_collector = HirCollector {\n                     sess: compiler.session(),\n                     collector: &mut collector,\n-                    map: tcx.hir(),\n+                    map: *tcx.hir(),\n                     codes: ErrorCodes::from(\n                         compiler.session().opts.unstable_features.is_nightly_build(),\n                     ),"}, {"sha": "f74c84e6dfd4862f60362a73aeb756b7cd7539ab", "filename": "src/libstd/future.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -40,7 +40,10 @@ impl<T: Generator<Yield = ()>> Future for GenFuture<T> {\n         // Safe because we're !Unpin + !Drop mapping to a ?Unpin value\n         let gen = unsafe { Pin::map_unchecked_mut(self, |s| &mut s.0) };\n         let _guard = unsafe { set_task_context(cx) };\n-        match gen.resume() {\n+        match gen.resume(\n+            #[cfg(not(bootstrap))]\n+            (),\n+        ) {\n             GeneratorState::Yielded(()) => Poll::Pending,\n             GeneratorState::Complete(x) => Poll::Ready(x),\n         }"}, {"sha": "de001cacbe19591cfd2dcf3e423a48fd1e920e17", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -63,8 +63,7 @@ use std::{\n     env, io,\n     io::prelude::Write,\n     panic::{self, catch_unwind, AssertUnwindSafe, PanicInfo},\n-    process,\n-    process::{Command, Termination},\n+    process::{self, Command, Termination},\n     sync::mpsc::{channel, Sender},\n     sync::{Arc, Mutex},\n     thread,\n@@ -457,9 +456,13 @@ pub fn run_test(\n                 monitor_ch,\n                 opts.time,\n             ),\n-            RunStrategy::SpawnPrimary => {\n-                spawn_test_subprocess(desc, opts.time.is_some(), monitor_ch, opts.time)\n-            }\n+            RunStrategy::SpawnPrimary => spawn_test_subprocess(\n+                desc,\n+                opts.nocapture,\n+                opts.time.is_some(),\n+                monitor_ch,\n+                opts.time,\n+            ),\n         };\n \n         // If the platform is single-threaded we're just going to run\n@@ -558,6 +561,7 @@ fn run_test_in_process(\n \n fn spawn_test_subprocess(\n     desc: TestDesc,\n+    nocapture: bool,\n     report_time: bool,\n     monitor_ch: Sender<CompletedTest>,\n     time_opts: Option<time::TestTimeOptions>,\n@@ -566,11 +570,15 @@ fn spawn_test_subprocess(\n         let args = env::args().collect::<Vec<_>>();\n         let current_exe = &args[0];\n \n+        let mut command = Command::new(current_exe);\n+        command.env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice());\n+        if nocapture {\n+            command.stdout(process::Stdio::inherit());\n+            command.stderr(process::Stdio::inherit());\n+        }\n+\n         let start = report_time.then(Instant::now);\n-        let output = match Command::new(current_exe)\n-            .env(SECONDARY_TEST_INVOKER_VAR, desc.name.as_slice())\n-            .output()\n-        {\n+        let output = match command.output() {\n             Ok(out) => out,\n             Err(e) => {\n                 let err = format!(\"Failed to spawn {} as child for test: {:?}\", args[0], e);"}, {"sha": "d96e76618d32501e33f91ac03276b177563ddf8c", "filename": "src/test/codegen/sanitizer-no-sanitize-inlining.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize-inlining.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,32 @@\n+// Verifies that no_sanitize attribute prevents inlining when\n+// given sanitizer is enabled, but has no effect on inlining otherwise.\n+//\n+// needs-sanitizer-support\n+// only-x86_64\n+//\n+// revisions: ASAN LSAN\n+//\n+//[ASAN] compile-flags: -Zsanitizer=address -C opt-level=3 -Z mir-opt-level=3\n+//[LSAN] compile-flags: -Zsanitizer=leak    -C opt-level=3 -Z mir-opt-level=3\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_sanitize)]\n+\n+// ASAN-LABEL: define void @test\n+// ASAN:         tail call fastcc void @random_inline\n+// ASAN:       }\n+//\n+// LSAN-LABEL: define void @test\n+// LSAN-NO:      call\n+// LSAN:       }\n+#[no_mangle]\n+pub fn test(n: &mut u32) {\n+    random_inline(n);\n+}\n+\n+#[no_sanitize(address)]\n+#[inline]\n+#[no_mangle]\n+pub fn random_inline(n: &mut u32) {\n+    *n = 42;\n+}"}, {"sha": "dfceb28c8dd107eaaa01eb5c87021c5241c9fe85", "filename": "src/test/codegen/sanitizer-no-sanitize.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-no-sanitize.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,29 @@\n+// Verifies that no_sanitze attribute can be used to\n+// selectively disable sanitizer instrumentation.\n+//\n+// needs-sanitizer-support\n+// compile-flags: -Zsanitizer=address\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_sanitize)]\n+\n+// CHECK-LABEL: ; sanitizer_no_sanitize::unsanitized\n+// CHECK-NEXT:  ; Function Attrs:\n+// CHECK-NOT:   sanitize_address\n+// CHECK:       start:\n+// CHECK-NOT:   call void @__asan_report_load\n+// CHECK:       }\n+#[no_sanitize(address)]\n+pub fn unsanitized(b: &mut u8) -> u8 {\n+    *b\n+}\n+\n+// CHECK-LABEL: ; sanitizer_no_sanitize::sanitized\n+// CHECK-NEXT:  ; Function Attrs:\n+// CHECK:       sanitize_address\n+// CHECK:       start:\n+// CHECK:       call void @__asan_report_load\n+// CHECK:       }\n+pub fn sanitized(b: &mut u8) -> u8 {\n+    *b\n+}"}, {"sha": "fd46c1a8b4db74d7ecae2db5f6119236096e1b00", "filename": "src/test/debuginfo/generator-locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-locals.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -78,9 +78,9 @@ fn main() {\n         _zzz(); // #break\n         a = c;\n     };\n-    Pin::new(&mut b).resume();\n-    Pin::new(&mut b).resume();\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n+    Pin::new(&mut b).resume(());\n+    Pin::new(&mut b).resume(());\n     _zzz(); // #break\n }\n "}, {"sha": "f19a3c71dd8d282f6b8603ce372c4efd5db686cf", "filename": "src/test/debuginfo/generator-objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -57,11 +57,11 @@ fn main() {\n         println!(\"{} {} {}\", a, c, d);\n     };\n     _zzz(); // #break\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n     _zzz(); // #break\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n     _zzz(); // #break\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n     _zzz(); // #break\n }\n "}, {"sha": "4de88e9dae62bc5269f5ead15a56a39d301c4f86", "filename": "src/test/debuginfo/issue-57822.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fissue-57822.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fdebuginfo%2Fissue-57822.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue-57822.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -45,7 +45,7 @@ fn main() {\n         yield;\n     };\n     let mut b = move || {\n-        Pin::new(&mut a).resume();\n+        Pin::new(&mut a).resume(());\n         yield;\n     };\n "}, {"sha": "6e06e67b6682db41050e410695c07b8304f00f8d", "filename": "src/test/incremental/crate_hash_reorder.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcrate_hash_reorder.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,11 +7,9 @@\n \n // Check that reordering otherwise identical items is not considered a\n // change at all.\n-#[rustc_clean(label=\"Krate\", cfg=\"rpass2\")]\n-\n+#[rustc_clean(label = \"hir_crate\", cfg = \"rpass2\")]\n // But removing an item, naturally, is.\n-#[rustc_dirty(label=\"Krate\", cfg=\"rpass3\")]\n-\n+#[rustc_dirty(label = \"hir_crate\", cfg = \"rpass3\")]\n #[cfg(rpass1)]\n pub struct X {\n     pub x: u32,\n@@ -26,4 +24,4 @@ pub struct X {\n     pub x: u32,\n }\n \n-pub fn main() { }\n+pub fn main() {}"}, {"sha": "20d4d4200bc1eefa008d49ee77352cd904152cfe", "filename": "src/test/incremental/issue-38222.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fissue-38222.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fissue-38222.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-38222.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,18 +1,14 @@\n-// Test that debuginfo does not introduce a dependency edge to the Krate\n+// Test that debuginfo does not introduce a dependency edge to the hir_crate\n // dep-node.\n \n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n-\n #![feature(rustc_attrs)]\n-\n-\n-#![rustc_partition_reused(module=\"issue_38222-mod1\", cfg=\"rpass2\")]\n-\n-// If codegen had added a dependency edge to the Krate dep-node, nothing would\n+#![rustc_partition_reused(module = \"issue_38222-mod1\", cfg = \"rpass2\")]\n+// If codegen had added a dependency edge to the hir_crate dep-node, nothing would\n // be re-used, so checking that this module was re-used is sufficient.\n-#![rustc_partition_reused(module=\"issue_38222\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module = \"issue_38222\", cfg = \"rpass2\")]\n \n //[rpass1] compile-flags: -C debuginfo=1\n //[rpass2] compile-flags: -C debuginfo=1"}, {"sha": "2c04e110525a653d15f903ab526fc98617d4ddf1", "filename": "src/test/incremental/krate-inherent.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fkrate-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inherent.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,20 +4,20 @@\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n-#![rustc_partition_reused(module=\"krate_inherent-x\", cfg=\"cfail2\")]\n+#![rustc_partition_reused(module = \"krate_inherent-x\", cfg = \"cfail2\")]\n #![crate_type = \"rlib\"]\n \n pub mod x {\n     pub struct Foo;\n     impl Foo {\n-        pub fn foo(&self) { }\n+        pub fn foo(&self) {}\n     }\n \n     pub fn method() {\n         let x: Foo = Foo;\n-        x.foo(); // inherent methods used to add an edge from Krate\n+        x.foo(); // inherent methods used to add an edge from hir_crate\n     }\n }\n \n #[cfg(cfail1)]\n-pub fn bar() { } // remove this unrelated fn in cfail2, which should not affect `x::method`\n+pub fn bar() {} // remove this unrelated fn in cfail2, which should not affect `x::method`"}, {"sha": "6b1db74a37c66f43a33e84ff0df9c8cb7dc4d3f4", "filename": "src/test/incremental/krate-inlined.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fincremental%2Fkrate-inlined.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fkrate-inlined.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,13 +1,13 @@\n // Regr. test that using HIR inlined from another krate does *not* add\n-// a dependency from the local Krate node. We can't easily test that\n+// a dependency from the local hir_crate node. We can't easily test that\n // directly anymore, so now we test that we get reuse.\n \n // revisions: rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n #![allow(warnings)]\n #![feature(rustc_attrs)]\n-#![rustc_partition_reused(module=\"krate_inlined-x\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module = \"krate_inlined-x\", cfg = \"rpass2\")]\n \n fn main() {\n     x::method();"}, {"sha": "278dc49c9260526b19b8ffd26398d8217e7e93d1", "filename": "src/test/mir-opt/generator-drop-cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-drop-cleanup.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -13,12 +13,12 @@ fn main() {\n \n // START rustc.main-{{closure}}.generator_drop.0.mir\n // bb0: {\n-//     _5 = discriminant((*_1));\n-//     switchInt(move _5) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n+//     _7 = discriminant((*_1));\n+//     switchInt(move _7) -> [0u32: bb4, 3u32: bb7, otherwise: bb8];\n // }\n // bb1: {\n+//     StorageDead(_4);\n //     StorageDead(_3);\n-//     StorageDead(_2);\n //     goto -> bb5;\n // }\n // bb2: {\n@@ -37,8 +37,8 @@ fn main() {\n //     goto -> bb3;\n // }\n // bb7: {\n-//     StorageLive(_2);\n //     StorageLive(_3);\n+//     StorageLive(_4);\n //     goto -> bb1;\n // }\n // bb8: {"}, {"sha": "4442fa5f52126457b6c4d88312c2de8fef0aa12a", "filename": "src/test/mir-opt/generator-storage-dead-unwind.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fgenerator-storage-dead-unwind.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -31,81 +31,81 @@ fn main() {\n \n // START rustc.main-{{closure}}.StateTransform.before.mir\n // ...\n-// let _2: Foo;\n+// let _3: Foo;\n // ...\n-// let mut _7: Foo;\n+// let mut _8: Foo;\n // ...\n-// let mut _9: Bar;\n+// let mut _10: Bar;\n // scope 1 {\n-//     debug a => _2;\n-//     let _3: Bar;\n+//     debug a => _3;\n+//     let _4: Bar;\n //     scope 2 {\n-//         debug b => _3;\n+//         debug b => _4;\n //     }\n // }\n // bb0: {\n-//     StorageLive(_2);\n-//     _2 = Foo(const 5i32,);\n //     StorageLive(_3);\n-//     _3 = Bar(const 6i32,);\n+//     _3 = Foo(const 5i32,);\n+//     StorageLive(_4);\n+//     _4 = Bar(const 6i32,);\n //     ...\n-//     _1 = suspend(move _5) -> [resume: bb2, drop: bb4];\n+//     _1 = suspend(move _6) -> [resume: bb2, drop: bb4];\n // }\n // bb1 (cleanup): {\n //     resume;\n // }\n // bb2: {\n //     ...\n-//     StorageLive(_6);\n //     StorageLive(_7);\n-//     _7 = move _2;\n-//     _6 = const take::<Foo>(move _7) -> [return: bb7, unwind: bb9];\n+//     StorageLive(_8);\n+//     _8 = move _3;\n+//     _7 = const take::<Foo>(move _8) -> [return: bb7, unwind: bb9];\n // }\n // bb3 (cleanup): {\n-//     StorageDead(_2);\n+//     StorageDead(_3);\n //     drop(_1) -> bb1;\n // }\n // bb4: {\n //     ...\n-//     StorageDead(_3);\n-//     drop(_2) -> [return: bb5, unwind: bb3];\n+//     StorageDead(_4);\n+//     drop(_3) -> [return: bb5, unwind: bb3];\n // }\n // bb5: {\n-//     StorageDead(_2);\n+//     StorageDead(_3);\n //     drop(_1) -> [return: bb6, unwind: bb1];\n // }\n // bb6: {\n //     generator_drop;\n // }\n // bb7: {\n+//     StorageDead(_8);\n //     StorageDead(_7);\n-//     StorageDead(_6);\n-//     StorageLive(_8);\n //     StorageLive(_9);\n-//     _9 = move _3;\n-//     _8 = const take::<Bar>(move _9) -> [return: bb10, unwind: bb11];\n+//     StorageLive(_10);\n+//     _10 = move _4;\n+//     _9 = const take::<Bar>(move _10) -> [return: bb10, unwind: bb11];\n // }\n // bb8 (cleanup): {\n+//     StorageDead(_4);\n //     StorageDead(_3);\n-//     StorageDead(_2);\n //     drop(_1) -> bb1;\n // }\n // bb9 (cleanup): {\n+//     StorageDead(_8);\n //     StorageDead(_7);\n-//     StorageDead(_6);\n //     goto -> bb8;\n // }\n // bb10: {\n+//     StorageDead(_10);\n //     StorageDead(_9);\n-//     StorageDead(_8);\n //     ...\n+//     StorageDead(_4);\n //     StorageDead(_3);\n-//     StorageDead(_2);\n //     drop(_1) -> [return: bb12, unwind: bb1];\n // }\n // bb11 (cleanup): {\n+//     StorageDead(_10);\n //     StorageDead(_9);\n-//     StorageDead(_8);\n //     goto -> bb8;\n // }\n // bb12: {"}, {"sha": "1a7c2e80629012ecae140f87c54a24cbd6078304", "filename": "src/test/run-fail/generator-resume-after-panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Frun-fail%2Fgenerator-resume-after-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Frun-fail%2Fgenerator-resume-after-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fgenerator-resume-after-panic.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -16,7 +16,7 @@ fn main() {\n         yield;\n     };\n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        let x = Pin::new(&mut g).resume();\n+        let x = Pin::new(&mut g).resume(());\n     }));\n-    Pin::new(&mut g).resume();\n+    Pin::new(&mut g).resume(());\n }"}, {"sha": "91b1fff5a3a0790c594de5aaa465a01a31c6b128", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -175,4 +175,5 @@ LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n            bar [BarF] bar\n                 ^^^^\n    = help: to escape `[` and `]` characters, just add '\\' before them like `\\[` or `\\]`\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "73b48013de66506d7b1814973be1fe78d1414b89", "filename": "src/test/ui-fulldeps/hash-stable-is-unstable.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fhash-stable-is-unstable.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -42,6 +42,7 @@ LL | #[derive(HashStable)]\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/27812\n    = help: add `#![feature(rustc_private)]` to the crate attributes to enable\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "fe920dba3978e610d977b69e35035f51d12cad0c", "filename": "src/test/ui-fulldeps/internal-lints/lint_pass_impl_without_macro.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Flint_pass_impl_without_macro.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -21,6 +21,7 @@ LL | custom_lint_pass_macro!();\n    | -------------------------- in this macro invocation\n    |\n    = help: try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0d52a23c1f39866e97fabd625d5484209715e0fb", "filename": "src/test/ui/allocator/not-an-allocator.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL | static A: usize = 0;\n    | ^^^^^^^^^^^^^^^^^^^^ the trait `std::alloc::GlobalAlloc` is not implemented for `usize`\n    |\n    = note: required by `std::alloc::GlobalAlloc::alloc`\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: std::alloc::GlobalAlloc` is not satisfied\n   --> $DIR/not-an-allocator.rs:2:1\n@@ -13,6 +14,7 @@ LL | static A: usize = 0;\n    | ^^^^^^^^^^^^^^^^^^^^ the trait `std::alloc::GlobalAlloc` is not implemented for `usize`\n    |\n    = note: required by `std::alloc::GlobalAlloc::dealloc`\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: std::alloc::GlobalAlloc` is not satisfied\n   --> $DIR/not-an-allocator.rs:2:1\n@@ -21,6 +23,7 @@ LL | static A: usize = 0;\n    | ^^^^^^^^^^^^^^^^^^^^ the trait `std::alloc::GlobalAlloc` is not implemented for `usize`\n    |\n    = note: required by `std::alloc::GlobalAlloc::realloc`\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: std::alloc::GlobalAlloc` is not satisfied\n   --> $DIR/not-an-allocator.rs:2:1\n@@ -29,6 +32,7 @@ LL | static A: usize = 0;\n    | ^^^^^^^^^^^^^^^^^^^^ the trait `std::alloc::GlobalAlloc` is not implemented for `usize`\n    |\n    = note: required by `std::alloc::GlobalAlloc::alloc_zeroed`\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "1b46825c5425cf0b0e8c4fdc8e19a860740cc6bc", "filename": "src/test/ui/allocator/two-allocators.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Ftwo-allocators.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,8 @@ LL | static A: System = System;\n LL | #[global_allocator]\n LL | static B: System = System;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot define a new global allocator\n+   |\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "9fc5667d6847e01a42887b1607b48d8e724a7cf5", "filename": "src/test/ui/async-await/issues/issue-65419/issue-65419-generator-resume-after-completion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -19,7 +19,7 @@ fn main() {\n     let mut g = || {\n         yield;\n     };\n-    Pin::new(&mut g).resume(); // Yields once.\n-    Pin::new(&mut g).resume(); // Completes here.\n-    Pin::new(&mut g).resume(); // Panics here.\n+    Pin::new(&mut g).resume(()); // Yields once.\n+    Pin::new(&mut g).resume(()); // Completes here.\n+    Pin::new(&mut g).resume(()); // Panics here.\n }"}, {"sha": "bdb073cdcbcc913928fcc75067cc224577e754a9", "filename": "src/test/ui/borrowck/borrowck-borrowed-uniq-rvalue-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue-2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,7 +9,7 @@ LL |     x.x[0];\n    |     ------ borrow later used here\n    |\n    = note: consider using a `let` binding to create a longer lived value\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "edc496aa2f81b3805d91fcf07571dd8fde7e04b0", "filename": "src/test/ui/borrowck/issue-64453.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ LL | static settings_dir: String = format!(\"\");\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "e0acd45957145041030a70a43dcf162086725b1a", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,6 +9,8 @@ LL |               aaa!(D);\n ...\n LL |   sss!();\n    |   ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "96d7b07b0e253a13306a1bc6541bd6865766de46", "filename": "src/test/ui/codemap_tests/bad-format-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fbad-format-args.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: requires at least a format string argument\n LL |     format!();\n    |     ^^^^^^^^^^\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected token: `,`\n   --> $DIR/bad-format-args.rs:3:16"}, {"sha": "f8820b9efedfcd17cb322bd8a3b9f635e77a7185", "filename": "src/test/ui/codemap_tests/issue-28308.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fissue-28308.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,6 +3,8 @@ error[E0600]: cannot apply unary operator `!` to type `&'static str`\n    |\n LL |     assert!(\"foo\");\n    |     ^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "6ea0b89be74d334a74ff804c66013cc5e9b2eb57", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.old.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.old.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,14 @@\n+error[E0592]: duplicate definitions with name `method1`\n+  --> $DIR/coherence-inherited-subtyping.rs:14:5\n+   |\n+LL |     fn method1(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`\n+...\n+LL |     fn method1(&self) {}\n+   |     -------------------- other definition for `method1`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0592`."}, {"sha": "6ea0b89be74d334a74ff804c66013cc5e9b2eb57", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.re.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.re.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,14 @@\n+error[E0592]: duplicate definitions with name `method1`\n+  --> $DIR/coherence-inherited-subtyping.rs:14:5\n+   |\n+LL |     fn method1(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `method1`\n+...\n+LL |     fn method1(&self) {}\n+   |     -------------------- other definition for `method1`\n+   |\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0592`."}, {"sha": "8587eb77950c7a290080387b42072816c382c5a5", "filename": "src/test/ui/coherence/coherence-inherited-subtyping.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-inherited-subtyping.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,21 @@\n+// Test that two distinct impls which match subtypes of one another\n+// yield coherence errors (or not) depending on the variance.\n+//\n+// Note: This scenario is currently accepted, but as part of the\n+// universe transition (#56105) may eventually become an error.\n+\n+// revisions: old re\n+\n+struct Foo<T> {\n+    t: T,\n+}\n+\n+impl Foo<for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8> {\n+    fn method1(&self) {} //~ ERROR duplicate definitions with name `method1`\n+}\n+\n+impl Foo<for<'a> fn(&'a u8, &'a u8) -> &'a u8> {\n+    fn method1(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "76f5cc1b782325730c720e8643ee817a712e289f", "filename": "src/test/ui/coherence/coherence-subtyping.old.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.old.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,14 @@\n+warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n+  --> $DIR/coherence-subtyping.rs:16:1\n+   |\n+LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n+   | ---------------------------------------------------------- first implementation here\n+LL | \n+LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+   |\n+   = note: `#[warn(coherence_leak_check)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+"}, {"sha": "76f5cc1b782325730c720e8643ee817a712e289f", "filename": "src/test/ui/coherence/coherence-subtyping.re.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.re.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,14 @@\n+warning: conflicting implementations of trait `TheTrait` for type `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`:\n+  --> $DIR/coherence-subtyping.rs:16:1\n+   |\n+LL | impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n+   | ---------------------------------------------------------- first implementation here\n+LL | \n+LL | impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8`\n+   |\n+   = note: `#[warn(coherence_leak_check)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #56105 <https://github.com/rust-lang/rust/issues/56105>\n+   = note: this behavior recently changed as a result of a bug fix; see rust-lang/rust#56105 for details\n+"}, {"sha": "f5c1d92411baafb0dbfa61520298f003ebf15965", "filename": "src/test/ui/coherence/coherence-subtyping.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-subtyping.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,16 +5,19 @@\n // universe transition (#56105) may eventually become an error.\n \n // revisions: old re\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n \n trait TheTrait {\n-    fn foo(&self) { }\n+    fn foo(&self) {}\n }\n \n-impl TheTrait for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n-}\n+impl TheTrait for for<'a, 'b> fn(&'a u8, &'b u8) -> &'a u8 {}\n \n impl TheTrait for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n+    //[re]~^ WARNING conflicting implementation\n+    //[re]~^^ WARNING this was previously accepted by the compiler but is being phased out\n+    //[old]~^^^ WARNING conflicting implementation\n+    //[old]~^^^^ WARNING this was previously accepted by the compiler but is being phased out\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "44063dd1d65d7efa4b7807ec55253c6bca96dc2a", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -60,6 +60,8 @@ LL |         #[cfg(feature = $expr)]\n ...\n LL | generate_s10!(concat!(\"nonexistent\"));\n    | -------------------------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 10 previous errors\n "}, {"sha": "330ce2bd2e1b520408b706fab7742f35942e7b78", "filename": "src/test/ui/conditional-compilation/cfg-attr-unknown-attribute-macro-expansion.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-unknown-attribute-macro-expansion.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,8 @@ LL |         #[cfg_attr(all(), unknown)]\n ...\n LL | foo!();\n    | ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "cba71db86a964baef10ff83e048dc0286424c567", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL |     println!(\"{:?}\", [0_usize; 33]);\n    |\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `[usize; 33]`\n    = note: required by `std::fmt::Debug::fmt`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n   --> $DIR/core-traits-no-impls-length-33.rs:10:16"}, {"sha": "7d95b46790d650e16d6760a23e482b3cd2cf2383", "filename": "src/test/ui/const-generics/broken-mir-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,7 @@ LL | struct S<T: Debug, const N: usize>([T; N]);\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `[T; _]`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[T; _]`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c4aef4c9d4785c1fb12ef09c8ea10d00d1f4f930", "filename": "src/test/ui/const-generics/derive-debug-array-wrapper.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fderive-debug-array-wrapper.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,7 @@ LL |     a: [u32; N],\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `[u32; _]`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[u32; _]`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "4c3ebece0a83986af71b0544a273ef55e2fbbff4", "filename": "src/test/ui/consts/const-eval/const_fn_ptr_fail2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_fn_ptr_fail2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,7 +12,7 @@ LL |     assert_eq!(Y, 4);\n    |                |\n    |                referenced constant has errors\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0080]: evaluation of constant expression failed\n   --> $DIR/const_fn_ptr_fail2.rs:22:5\n@@ -22,7 +22,7 @@ LL |     assert_eq!(Z, 4);\n    |                |\n    |                referenced constant has errors\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "679d8f280cc60f16b281d81eedf3ede56899822d", "filename": "src/test/ui/consts/const-eval/const_panic.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,7 @@ LL | pub const Z: () = panic!(\"cheese\");\n    |                   the evaluated program panicked at 'cheese', $DIR/const_panic.rs:4:19\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic.rs:7:19\n@@ -17,7 +17,7 @@ LL | pub const Y: () = unreachable!();\n    |                   |\n    |                   the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic.rs:7:19\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic.rs:10:19\n@@ -27,7 +27,7 @@ LL | pub const X: () = unimplemented!();\n    |                   |\n    |                   the evaluated program panicked at 'not implemented', $DIR/const_panic.rs:10:19\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2abf158aade5459419fe486926d88ff56058884a", "filename": "src/test/ui/consts/const-eval/const_panic_libcore.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,7 @@ LL | const Z: () = panic!(\"cheese\");\n    |               the evaluated program panicked at 'cheese', $DIR/const_panic_libcore.rs:5:15\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic_libcore.rs:8:15\n@@ -17,7 +17,7 @@ LL | const Y: () = unreachable!();\n    |               |\n    |               the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic_libcore.rs:8:15\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic_libcore.rs:11:15\n@@ -27,7 +27,7 @@ LL | const X: () = unimplemented!();\n    |               |\n    |               the evaluated program panicked at 'not implemented', $DIR/const_panic_libcore.rs:11:15\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c5887ff8c5697c373476633d906f20d78f67e34d", "filename": "src/test/ui/consts/const-eval/const_panic_libcore_main.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst_panic_libcore_main.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,7 @@ LL | const Z: () = panic!(\"cheese\");\n    |               the evaluated program panicked at 'cheese', $DIR/const_panic_libcore_main.rs:9:15\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic_libcore_main.rs:12:15\n@@ -17,7 +17,7 @@ LL | const Y: () = unreachable!();\n    |               |\n    |               the evaluated program panicked at 'internal error: entered unreachable code', $DIR/const_panic_libcore_main.rs:12:15\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/const_panic_libcore_main.rs:15:15\n@@ -27,7 +27,7 @@ LL | const X: () = unimplemented!();\n    |               |\n    |               the evaluated program panicked at 'not implemented', $DIR/const_panic_libcore_main.rs:15:15\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "82edcefb86e7f9e4111c25bb843bbd45cb8cf9ca", "filename": "src/test/ui/consts/const-eval/feature-gate-const_panic.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ffeature-gate-const_panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ffeature-gate-const_panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ffeature-gate-const_panic.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ LL | const Z: () = panic!(\"cheese\");\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51999\n    = help: add `#![feature(const_panic)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: panicking in constants is unstable\n   --> $DIR/feature-gate-const_panic.rs:9:15\n@@ -16,7 +16,7 @@ LL | const X: () = unimplemented!();\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51999\n    = help: add `#![feature(const_panic)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: panicking in constants is unstable\n   --> $DIR/feature-gate-const_panic.rs:6:15\n@@ -26,7 +26,7 @@ LL | const Y: () = unreachable!();\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51999\n    = help: add `#![feature(const_panic)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ea4eba89eb7fc5dbf7232915587060aa327be146", "filename": "src/test/ui/consts/const-eval/panic-assoc-never-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-assoc-never-type.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -11,7 +11,7 @@ note: the lint level is defined here\n    |\n LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0080]: erroneous constant used\n   --> $DIR/panic-assoc-never-type.rs:16:13"}, {"sha": "28333c511dca4f6e2bbc3381c8cd47dbb065fbdb", "filename": "src/test/ui/consts/const-eval/panic-never-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-never-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-never-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpanic-never-type.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -11,7 +11,7 @@ note: the lint level is defined here\n    |\n LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n-   = note: this warning originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0080]: erroneous constant used\n   --> $DIR/panic-never-type.rs:12:13"}, {"sha": "06a630d82d8406ba75e18f92defb2f96bf69cf6e", "filename": "src/test/ui/consts/const-external-macro-const-err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-external-macro-const-err.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,7 +5,7 @@ LL |     static_assert!(2 + 2 == 5);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ index out of bounds: the len is 1 but the index is 1\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "7dd60cfb5458fd6973bbda97ea0b01569638fc0b", "filename": "src/test/ui/consts/control-flow/assert.both.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.both.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.both.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.both.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,7 @@ LL | const _: () = assert!(false);\n    |               the evaluated program panicked at 'assertion failed: false', $DIR/assert.rs:12:15\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "476cf89edf05931e5047971ae0dbff215d10c945", "filename": "src/test/ui/consts/control-flow/assert.if_match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.if_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.if_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.if_match.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ LL | const _: () = assert!(true);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51999\n    = help: add `#![feature(const_panic)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: panicking in constants is unstable\n   --> $DIR/assert.rs:12:15\n@@ -16,7 +16,7 @@ LL | const _: () = assert!(false);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/51999\n    = help: add `#![feature(const_panic)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "043efa038aaa40c2615c4c85179c764b038620dc", "filename": "src/test/ui/consts/control-flow/assert.panic.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.panic.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL | const _: () = assert!(true);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: `if` is not allowed in a `const`\n   --> $DIR/assert.rs:12:15\n@@ -15,6 +16,7 @@ LL | const _: () = assert!(false);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "043efa038aaa40c2615c4c85179c764b038620dc", "filename": "src/test/ui/consts/control-flow/assert.stock.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fassert.stock.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL | const _: () = assert!(true);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: `if` is not allowed in a `const`\n   --> $DIR/assert.rs:12:15\n@@ -15,6 +16,7 @@ LL | const _: () = assert!(false);\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "831360d5652e8ea171f03457ce11df31a88bae43", "filename": "src/test/ui/consts/control-flow/issue-50577.if_match.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.if_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.if_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.if_match.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,7 +9,7 @@ LL |         Drop = assert_eq!(1, 1)\n    |\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "523bd23258f1e2fad422c055d41252724751a5d6", "filename": "src/test/ui/consts/control-flow/issue-50577.stock.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-50577.stock.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ LL |         Drop = assert_eq!(1, 1)\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: `if` is not allowed in a `const`\n   --> $DIR/issue-50577.rs:7:16\n@@ -16,7 +16,7 @@ LL |         Drop = assert_eq!(1, 1)\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0658]: `match` is not allowed in a `const`\n   --> $DIR/issue-50577.rs:7:16\n@@ -26,7 +26,7 @@ LL |         Drop = assert_eq!(1, 1)\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49146\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0317]: `if` may be missing an `else` clause\n   --> $DIR/issue-50577.rs:7:16\n@@ -39,7 +39,7 @@ LL |         Drop = assert_eq!(1, 1)\n    |\n    = note: `if` expressions without `else` evaluate to `()`\n    = help: consider adding an `else` block that evaluates to the expected type\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "f32f248af4557a0255fc7b3485ed52a8423dd6ef", "filename": "src/test/ui/consts/control-flow/short-circuit.stock.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit.stock.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,7 +7,7 @@ LL | const _: bool = true || panic!();\n    |                         the evaluated program panicked at 'explicit panic', $DIR/short-circuit.rs:10:25\n    |\n    = note: `#[deny(const_err)]` on by default\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: any use of this value will cause an error\n   --> $DIR/short-circuit.rs:11:26\n@@ -17,7 +17,7 @@ LL | const _: bool = false && panic!();\n    |                          |\n    |                          the evaluated program panicked at 'explicit panic', $DIR/short-circuit.rs:11:26\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "492b79e2e60213499acd9136510288ab3e6dc7a0", "filename": "src/test/ui/consts/enum-discr-type-err.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fenum-discr-type-err.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |     B = T,\n LL | | }\n    | |_- in this macro invocation\n    |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |             $( $v = $s::V.try_into().unwrap(), )*\n@@ -27,6 +28,7 @@ LL | |     B = T,\n LL | | }\n    | |_- in this macro invocation\n    |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |             $( $v = $s::V.try_into().unwrap(), )*"}, {"sha": "2c68ddd8c9a4df2f871d583bbee5ff7822051f63", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ LL |     vec![1, 2, 3]\n    |\n    = note: for more information, see issue https://github.com/rust-lang/rust/issues/57563\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "9f58f16c1a02a571a60c51d8cdcb98ce4ad240ef", "filename": "src/test/ui/cross/cross-crate-macro-backtrace/main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcross%2Fcross-crate-macro-backtrace%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcross%2Fcross-crate-macro-backtrace%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross%2Fcross-crate-macro-backtrace%2Fmain.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: 1 positional argument in format string, but no arguments were given\n LL |     myprintln!(\"{}\");\n    |     ^^^^^^^^^^^^^^^^^\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "f9101d8a583d35cb1834e825d96f34d46329e60c", "filename": "src/test/ui/cross/cross-file-errors/main.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross%2Fcross-file-errors%2Fmain.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |         _\n    |\n LL |     underscore!();\n    |     -------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "420ddbc3def41e6148fbad0f2f55f66f69a4abe4", "filename": "src/test/ui/custom_test_frameworks/mismatch.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL | fn wrong_kind(){}\n    | ^^^^^^^^^^^^^^^^^ the trait `example_runner::Testable` is not implemented for `test::TestDescAndFn`\n    |\n    = note: required for the cast to the object type `dyn example_runner::Testable`\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "927ea5597783a5f716399e9ef318e2a2feb057f0", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,17 +6,16 @@\n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-\n-fn main() { }\n+#![rustc_if_this_changed(hir_crate)]\n+fn main() {}\n \n struct Foo<T> {\n-    f: T\n+    f: T,\n }\n \n-#[rustc_if_this_changed(Krate)]\n type TypeAlias<T> = Foo<T>;\n \n #[rustc_then_this_would_need(variances_of)] //~ ERROR OK\n struct Use<T> {\n-    x: TypeAlias<T>\n+    x: TypeAlias<T>,\n }"}, {"sha": "2422cb9bb2f52ed93695bd62f1a8f2c388299e30", "filename": "src/test/ui/dep-graph/dep-graph-variance-alias.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdep-graph%2Fdep-graph-variance-alias.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,5 +1,5 @@\n error: OK\n-  --> $DIR/dep-graph-variance-alias.rs:19:1\n+  --> $DIR/dep-graph-variance-alias.rs:18:1\n    |\n LL | #[rustc_then_this_would_need(variances_of)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "65152a2f9ab6d8b1d9cc6334203132c574f1a196", "filename": "src/test/ui/deprecation/deprecation-lint-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,7 +9,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(deprecated)]\n    |         ^^^^^^^^^^\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b450f74d7f36738f623af9bd8da9c8c1d99a7b65", "filename": "src/test/ui/deprecation/deprecation-lint-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-lint-3.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,7 +9,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(deprecated)]\n    |         ^^^^^^^^^^\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "89fd7aae3bea0ca903a25539ef3cf26f67bbdd4a", "filename": "src/test/ui/deref-suggestion.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderef-suggestion.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -42,14 +42,16 @@ LL |     ($x:expr) => { &$x }\n ...\n LL |     foo3(borrow!(0));\n    |          ---------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:36:5\n    |\n LL |     assert_eq!(3i32, &3i32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `&i32`\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n   --> $DIR/deref-suggestion.rs:39:17"}, {"sha": "8ef2d3d30238feb6e25066c2f17af6e6341b3668", "filename": "src/test/ui/derives/derives-span-Clone-enum-struct-variant.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      x: Error\n    |      ^^^^^^^^ the trait `std::clone::Clone` is not implemented for `Error`\n    |\n    = note: required by `std::clone::Clone::clone`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "8c740733e2fa4c626c53f6a70040405f48ca1524", "filename": "src/test/ui/derives/derives-span-Clone-enum.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      Error\n    |      ^^^^^ the trait `std::clone::Clone` is not implemented for `Error`\n    |\n    = note: required by `std::clone::Clone::clone`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "75a59fbf035d4b101190cadb61f118665ef2e80c", "filename": "src/test/ui/derives/derives-span-Clone-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: Error\n    |     ^^^^^^^^ the trait `std::clone::Clone` is not implemented for `Error`\n    |\n    = note: required by `std::clone::Clone::clone`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "1860c5f2ff6ac704d43df46d70436594d04d1fc3", "filename": "src/test/ui/derives/derives-span-Clone-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Clone-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     Error\n    |     ^^^^^ the trait `std::clone::Clone` is not implemented for `Error`\n    |\n    = note: required by `std::clone::Clone::clone`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "ab3c5ef3c1d81dbe74a52380feb461393fd39c99", "filename": "src/test/ui/derives/derives-span-Debug-enum-struct-variant.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL |      x: Error\n    = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&Error`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "e0a76d5251594294f2665b0aa974524e429863ca", "filename": "src/test/ui/derives/derives-span-Debug-enum.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL |      Error\n    = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&Error`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "2f5cba09e4c2a2b8a855269f7c3695425432e159", "filename": "src/test/ui/derives/derives-span-Debug-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL |     x: Error\n    = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&Error`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "58ec131d54155ee4893bf8e701d955adf68b75e5", "filename": "src/test/ui/derives/derives-span-Debug-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Debug-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL |     Error\n    = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`\n    = note: required because of the requirements on the impl of `std::fmt::Debug` for `&Error`\n    = note: required for the cast to the object type `dyn std::fmt::Debug`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "b97dda719ab781803c4937501f516294d1468cd5", "filename": "src/test/ui/derives/derives-span-Default-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: Error\n    |     ^^^^^^^^ the trait `std::default::Default` is not implemented for `Error`\n    |\n    = note: required by `std::default::Default::default`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "d976891f41feaf2439d66a285912dacf97bcecb1", "filename": "src/test/ui/derives/derives-span-Default-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Default-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     Error\n    |     ^^^^^ the trait `std::default::Default` is not implemented for `Error`\n    |\n    = note: required by `std::default::Default::default`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "f886c29c4db9a32c27fc3102293ac4f2d0e2755b", "filename": "src/test/ui/derives/derives-span-Eq-enum-struct-variant.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      x: Error\n    |      ^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::AssertParamIsEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "0b5470138a5b3d1b9067768f322647c011312a68", "filename": "src/test/ui/derives/derives-span-Eq-enum.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      Error\n    |      ^^^^^ the trait `std::cmp::Eq` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::AssertParamIsEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "76904d67235871ae1a3c19a2dc172c7dd32eeb8e", "filename": "src/test/ui/derives/derives-span-Eq-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: Error\n    |     ^^^^^^^^ the trait `std::cmp::Eq` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::AssertParamIsEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "ff94b989d26d5964e7b2d76c09f18eca698042f5", "filename": "src/test/ui/derives/derives-span-Eq-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Eq-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     Error\n    |     ^^^^^ the trait `std::cmp::Eq` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::AssertParamIsEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "889c725c843e75d26bb8c94d620ebe0432cc635e", "filename": "src/test/ui/derives/derives-span-Hash-enum-struct-variant.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |      x: Error\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n    |             - required by this bound in `std::hash::Hash::hash`\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "70b8a85d107f1382039ea7e6c2d00238025049f9", "filename": "src/test/ui/derives/derives-span-Hash-enum.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |      Error\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n    |             - required by this bound in `std::hash::Hash::hash`\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "61897392a726a877a93b81d2b5c9c26d5176b057", "filename": "src/test/ui/derives/derives-span-Hash-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |     x: Error\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n    |             - required by this bound in `std::hash::Hash::hash`\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "fb929ad985b5f10e225321be03e78059cb9b5c0a", "filename": "src/test/ui/derives/derives-span-Hash-tuple-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Hash-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |     Error\n    |\n LL |     fn hash<H: Hasher>(&self, state: &mut H);\n    |             - required by this bound in `std::hash::Hash::hash`\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "7e73392fd51d5e593209310645b86efdb34e6dff", "filename": "src/test/ui/derives/derives-span-Ord-enum-struct-variant.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      x: Error\n    |      ^^^^^^^^ the trait `std::cmp::Ord` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::Ord::cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "68df309e0462f7c264d51778b876f76f8c7d2ca7", "filename": "src/test/ui/derives/derives-span-Ord-enum.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      Error\n    |      ^^^^^ the trait `std::cmp::Ord` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::Ord::cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "5e1ed33509406756a97126addea36fce1b6d619c", "filename": "src/test/ui/derives/derives-span-Ord-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: Error\n    |     ^^^^^^^^ the trait `std::cmp::Ord` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::Ord::cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "d9692e56431efd2d6165411fc376ef51733d160a", "filename": "src/test/ui/derives/derives-span-Ord-tuple-struct.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-Ord-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     Error\n    |     ^^^^^ the trait `std::cmp::Ord` is not implemented for `Error`\n    |\n    = note: required by `std::cmp::Ord::cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c669636c850438a31b5b18ddf0e06c32951f03c7", "filename": "src/test/ui/derives/derives-span-PartialEq-enum-struct-variant.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      x: Error\n    |      ^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-enum-struct-variant.rs:13:6\n@@ -13,6 +14,7 @@ LL |      x: Error\n    |      ^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ff98edea4dcff48c657f85676418a5010c69ee04", "filename": "src/test/ui/derives/derives-span-PartialEq-enum.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |      Error\n    |      ^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-enum.rs:13:6\n@@ -13,6 +14,7 @@ LL |      Error\n    |      ^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "200b8e2d503c83b7f6d14e2a39da2521145a3b58", "filename": "src/test/ui/derives/derives-span-PartialEq-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: Error\n    |     ^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-struct.rs:12:5\n@@ -13,6 +14,7 @@ LL |     x: Error\n    |     ^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9e3d1309c2258403d20b711b5769e1ecb94a7326", "filename": "src/test/ui/derives/derives-span-PartialEq-tuple-struct.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialEq-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     Error\n    |     ^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0369]: binary operation `!=` cannot be applied to type `Error`\n   --> $DIR/derives-span-PartialEq-tuple-struct.rs:12:5\n@@ -13,6 +14,7 @@ LL |     Error\n    |     ^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `Error`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6433d1f5e27a58964b0989ae4cc95b3d615e3641", "filename": "src/test/ui/derives/derives-span-PartialOrd-enum-struct-variant.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum-struct-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum-struct-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum-struct-variant.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL |      x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum-struct-variant.rs:13:6\n@@ -15,6 +16,7 @@ LL |      x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum-struct-variant.rs:13:6\n@@ -24,6 +26,7 @@ LL |      x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum-struct-variant.rs:13:6\n@@ -33,6 +36,7 @@ LL |      x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum-struct-variant.rs:13:6\n@@ -42,6 +46,7 @@ LL |      x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b1be7dd05f9844127f444be000c537bd8b92add2", "filename": "src/test/ui/derives/derives-span-PartialOrd-enum.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-enum.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL |      Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum.rs:13:6\n@@ -15,6 +16,7 @@ LL |      Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum.rs:13:6\n@@ -24,6 +26,7 @@ LL |      Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum.rs:13:6\n@@ -33,6 +36,7 @@ LL |      Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-enum.rs:13:6\n@@ -42,6 +46,7 @@ LL |      Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "064c91fd7ddc3de47ba67a9b76b074e44d6f12bb", "filename": "src/test/ui/derives/derives-span-PartialOrd-struct.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL |     x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-struct.rs:12:5\n@@ -15,6 +16,7 @@ LL |     x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-struct.rs:12:5\n@@ -24,6 +26,7 @@ LL |     x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-struct.rs:12:5\n@@ -33,6 +36,7 @@ LL |     x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-struct.rs:12:5\n@@ -42,6 +46,7 @@ LL |     x: Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5b627022cca4660727ec3af58829c03721acedc3", "filename": "src/test/ui/derives/derives-span-PartialOrd-tuple-struct.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-tuple-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-tuple-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderives-span-PartialOrd-tuple-struct.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,7 @@ LL |     Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-tuple-struct.rs:12:5\n@@ -15,6 +16,7 @@ LL |     Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-tuple-struct.rs:12:5\n@@ -24,6 +26,7 @@ LL |     Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-tuple-struct.rs:12:5\n@@ -33,6 +36,7 @@ LL |     Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `Error` with `Error`\n   --> $DIR/derives-span-PartialOrd-tuple-struct.rs:12:5\n@@ -42,6 +46,7 @@ LL |     Error\n    |\n    = help: the trait `std::cmp::PartialOrd` is not implemented for `Error`\n    = note: required by `std::cmp::PartialOrd::partial_cmp`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "d4995c1d50c730712bd681dacb265a27ccd4086a", "filename": "src/test/ui/derives/deriving-no-inner-impl-error-message.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-no-inner-impl-error-message.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -5,6 +5,7 @@ LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `NoCloneOrEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0369]: binary operation `!=` cannot be applied to type `NoCloneOrEq`\n   --> $DIR/deriving-no-inner-impl-error-message.rs:5:5\n@@ -13,6 +14,7 @@ LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^\n    |\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `NoCloneOrEq`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `NoCloneOrEq: std::clone::Clone` is not satisfied\n   --> $DIR/deriving-no-inner-impl-error-message.rs:10:5\n@@ -21,6 +23,7 @@ LL |     x: NoCloneOrEq\n    |     ^^^^^^^^^^^^^^ the trait `std::clone::Clone` is not implemented for `NoCloneOrEq`\n    |\n    = note: required by `std::clone::Clone::clone`\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "d739257c8de63c83a5eba0c00c863c595b47a701", "filename": "src/test/ui/derives/deriving-with-repr-packed.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-with-repr-packed.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -11,6 +11,7 @@ LL | #![deny(safe_packed_borrows)]\n    |         ^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct with type or const parameters (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:8:23\n@@ -20,6 +21,7 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:16:10\n@@ -29,6 +31,7 @@ LL | #[derive(PartialEq, Eq)]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `#[derive]` can't be used on a `#[repr(packed)]` struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:25:10\n@@ -38,6 +41,7 @@ LL | #[derive(PartialEq)]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "fe3fb43730a8c8187d1bbb5f7f6b56458298e0b5", "filename": "src/test/ui/did_you_mean/bad-assoc-expr.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-expr.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -54,6 +54,8 @@ LL |     ($ty: ty) => ($ty::clone(&0))\n ...\n LL |     expr!(u8);\n    |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 9 previous errors\n "}, {"sha": "924a5d756436d718502659cfa8a58241aebfb032", "filename": "src/test/ui/did_you_mean/bad-assoc-pat.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-pat.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -36,6 +36,8 @@ LL |     ($ty: ty) => ($ty::AssocItem)\n ...\n LL |         pat!(u8) => {}\n    |         -------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0599]: no associated item named `AssocItem` found for slice `[u8]` in the current scope\n   --> $DIR/bad-assoc-pat.rs:3:15\n@@ -69,6 +71,8 @@ LL |     ($ty: ty) => ($ty::AssocItem)\n ...\n LL |         pat!(u8) => {}\n    |         -------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0599]: no associated item named `AssocItem` found for type `u8` in the current scope\n   --> $DIR/bad-assoc-pat.rs:32:16"}, {"sha": "64e49934d876203748c997ebf51f066f8e601d42", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -54,6 +54,8 @@ LL |     ($ty: ty) => ($ty::AssocTy);\n ...\n LL | type J = ty!(u8);\n    |          ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n@@ -111,6 +113,8 @@ LL |     ($ty: ty) => ($ty::AssocTy);\n ...\n LL | type J = ty!(u8);\n    |          ------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:44:10"}, {"sha": "4935c698f2056878d1db64d1c5b9f79b84b02d7b", "filename": "src/test/ui/did_you_mean/recursion_limit_macro.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL |     recurse!(0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9);\n    |     -------------------------------------------------- in this macro invocation\n    |\n    = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate (`recursion_limit_macro`)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "2aad57dee7daabb0d918b785bd1fa9b5438a5b29", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword-2.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword-2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,8 @@ LL |         use a::$crate::b;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0432]: unresolved import `a::$crate`\n   --> $DIR/dollar-crate-is-keyword-2.rs:5:13\n@@ -15,6 +17,8 @@ LL |         use a::$crate;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0433]: failed to resolve: `$crate` in paths can only be used in start position\n   --> $DIR/dollar-crate-is-keyword-2.rs:7:21\n@@ -24,6 +28,8 @@ LL |         type A = a::$crate;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "d424bd2f2858c319bfe5a51fe64c2b4d2f974e15", "filename": "src/test/ui/dollar-crate/dollar-crate-is-keyword.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdollar-crate%2Fdollar-crate-is-keyword.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,8 @@ LL |             struct $crate {}\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: expected identifier, found reserved identifier `$crate`\n   --> $DIR/dollar-crate-is-keyword.rs:10:23\n@@ -15,6 +17,8 @@ LL |         use $crate as $crate;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `$crate` may not be imported\n   --> $DIR/dollar-crate-is-keyword.rs:9:9\n@@ -24,6 +28,8 @@ LL |         use $crate;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: `$crate` may not be imported\n   --> $DIR/dollar-crate-is-keyword.rs:10:9\n@@ -33,6 +39,8 @@ LL |         use $crate as $crate;\n ...\n LL | m!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "659e520d4cd1289f71e6ec7c27edce4aadff1119", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -184,7 +184,7 @@ fn generator(a: &Allocator, run_count: usize) {\n          );\n     };\n     for _ in 0..run_count {\n-        Pin::new(&mut gen).resume();\n+        Pin::new(&mut gen).resume(());\n     }\n }\n "}, {"sha": "ec8b88ecba22b5e776fd29ed1442070ef7dc6934", "filename": "src/test/ui/editions/edition-imports-2015.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2015.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: cannot glob-import all possible crates\n LL |     gen_glob!();\n    |     ^^^^^^^^^^^^\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "087d2e339548c3fedc6e30df75ea2a298e82da36", "filename": "src/test/ui/editions/edition-imports-2018.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-2018.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: cannot glob-import all possible crates\n LL |     gen_glob!();\n    |     ^^^^^^^^^^^^\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "56cbd882cca60814cc9e28bd1dc8a7795a605c1e", "filename": "src/test/ui/editions/edition-imports-virtual-2015-gated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-imports-virtual-2015-gated.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error[E0432]: unresolved import `E`\n LL |     gen_gated!();\n    |     ^^^^^^^^^^^^^ could not find `E` in `{{root}}`\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "f44f81fce7134c3434092146d6bbd8d0877e260b", "filename": "src/test/ui/editions/edition-keywords-2015-2018-expansion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2015-2018-expansion.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: expected identifier, found keyword `async`\n LL |     produces_async! {}\n    |     ^^^^^^^^^^^^^^^^^^ expected identifier, found keyword\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n help: you can escape reserved keywords to use them as identifiers\n    |\n LL | () => (pub fn r#async () { })"}, {"sha": "a8fc58fc0cb8d927a6836b2f86205f58b21a246c", "filename": "src/test/ui/editions/edition-keywords-2018-2018-expansion.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Feditions%2Fedition-keywords-2018-2018-expansion.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -4,7 +4,7 @@ error: expected identifier, found keyword `async`\n LL |     produces_async! {}\n    |     ^^^^^^^^^^^^^^^^^^ expected identifier, found keyword\n    |\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n help: you can escape reserved keywords to use them as identifiers\n    |\n LL | () => (pub fn r#async () { })"}, {"sha": "591ea29ff8c5241e536dc3584c8590e23f805321", "filename": "src/test/ui/error-codes/E0184.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0184.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,6 +3,8 @@ error[E0184]: the trait `Copy` may not be implemented for this type; the type ha\n    |\n LL | #[derive(Copy)]\n    |          ^^^^ Copy not allowed on types with destructors\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "3cb69492eb76d41e350e79c41e4d12626c33b24e", "filename": "src/test/ui/error-codes/E0665.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ferror-codes%2FE0665.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ferror-codes%2FE0665.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0665.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,6 +3,8 @@ error[E0665]: `Default` cannot be derived for enums, only structs\n    |\n LL | #[derive(Default)]\n    |          ^^^^^^^\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "f1e725ec34206d43da9d38b5736c6bfd43de5428", "filename": "src/test/ui/exclusive-drop-and-copy.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-drop-and-copy.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,12 +3,16 @@ error[E0184]: the trait `Copy` may not be implemented for this type; the type ha\n    |\n LL | #[derive(Copy, Clone)]\n    |          ^^^^ Copy not allowed on types with destructors\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0184]: the trait `Copy` may not be implemented for this type; the type has a destructor\n   --> $DIR/exclusive-drop-and-copy.rs:10:10\n    |\n LL | #[derive(Copy, Clone)]\n    |          ^^^^ Copy not allowed on types with destructors\n+   |\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "89c99b89ca804f5348671ebca535ff92c645cebf", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unsafe-nested-macro.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unsafe-nested-macro.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL | bar!();\n    | ------- in this macro invocation\n    |\n    = help: add `#![feature(allow_internal_unsafe)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "935b95668e82b078ab470bc1f8e4ad8ce7141142", "filename": "src/test/ui/feature-gates/feature-gate-allow-internal-unstable-nested-macro.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-allow-internal-unstable-nested-macro.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,7 @@ LL | bar!();\n    | ------- in this macro invocation\n    |\n    = help: add `#![feature(allow_internal_unstable)]` to the crate attributes to enable\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "1c319c6dad4c0719c0589241a066954cf73997b6", "filename": "src/test/ui/feature-gates/feature-gate-concat_idents2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-concat_idents2.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,6 +12,8 @@ error[E0425]: cannot find value `ab` in this scope\n    |\n LL |     concat_idents!(a, b);\n    |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "66a9263e13a53168bf032ff971cad46deeab3343", "filename": "src/test/ui/feature-gates/feature-gate-no_sanitize.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,4 @@\n+#[no_sanitize(address)]\n+//~^ the `#[no_sanitize]` attribute is an experimental feature\n+fn main() {\n+}"}, {"sha": "7359cf03652bcdb93cb4f08fc650d9dadf2107c0", "filename": "src/test/ui/feature-gates/feature-gate-no_sanitize.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-no_sanitize.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: the `#[no_sanitize]` attribute is an experimental feature\n+  --> $DIR/feature-gate-no_sanitize.rs:1:1\n+   |\n+LL | #[no_sanitize(address)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/39699\n+   = help: add `#![feature(no_sanitize)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "30788e3c1864bb1935c4ae4a1ee029b74c6e56a6", "filename": "src/test/ui/generator-yielding-or-returning-itself.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -13,7 +13,7 @@ pub fn want_cyclic_generator_return<T>(_: T)\n \n fn supply_cyclic_generator_return() {\n     want_cyclic_generator_return(|| {\n-        //~^ ERROR closure/generator type that references itself\n+        //~^ ERROR type mismatch\n         if false { yield None.unwrap(); }\n         None.unwrap()\n     })"}, {"sha": "1572219cf4ac8d655c6ec95efa622fc41e72f2c3", "filename": "src/test/ui/generator-yielding-or-returning-itself.stderr", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator-yielding-or-returning-itself.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,13 +1,13 @@\n-error[E0644]: closure/generator type that references itself\n-  --> $DIR/generator-yielding-or-returning-itself.rs:15:34\n+error[E0271]: type mismatch resolving `<[generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6 _] as std::ops::Generator>::Return == [generator@$DIR/generator-yielding-or-returning-itself.rs:15:34: 19:6 _]`\n+  --> $DIR/generator-yielding-or-returning-itself.rs:15:5\n    |\n-LL |       want_cyclic_generator_return(|| {\n-   |  __________________________________^\n-LL | |\n-LL | |         if false { yield None.unwrap(); }\n-LL | |         None.unwrap()\n-LL | |     })\n-   | |_____^ cyclic type of infinite size\n+LL | pub fn want_cyclic_generator_return<T>(_: T)\n+   |        ----------------------------\n+LL |     where T: Generator<Yield = (), Return = T>\n+   |                                    ---------- required by this bound in `want_cyclic_generator_return`\n+...\n+LL |     want_cyclic_generator_return(|| {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n    |\n    = note: closures cannot capture themselves or take themselves as argument;\n            this error may be the result of a recent compiler bug-fix,\n@@ -30,5 +30,4 @@ LL |     want_cyclic_generator_yield(|| {\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0271, E0644.\n-For more information about an error, try `rustc --explain E0271`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "2dd5ea675233ccbeddf4c21e149355fe0e124b86", "filename": "src/test/ui/generator/auxiliary/xcrate-reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate-reachable.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ fn msg() -> u32 {\n     0\n }\n \n-pub fn foo() -> impl Generator<Yield=(), Return=u32> {\n+pub fn foo() -> impl Generator<(), Yield=(), Return=u32> {\n     || {\n         yield;\n         return msg();"}, {"sha": "d07abd0918c7860dabe18800bd3421202b9c1c8d", "filename": "src/test/ui/generator/auxiliary/xcrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauxiliary%2Fxcrate.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -3,15 +3,15 @@\n use std::marker::Unpin;\n use std::ops::Generator;\n \n-pub fn foo() -> impl Generator<Yield = (), Return = ()> {\n+pub fn foo() -> impl Generator<(), Yield = (), Return = ()> {\n     || {\n         if false {\n             yield;\n         }\n     }\n }\n \n-pub fn bar<T: 'static>(t: T) -> Box<Generator<Yield = T, Return = ()> + Unpin> {\n+pub fn bar<T: 'static>(t: T) -> Box<Generator<(), Yield = T, Return = ()> + Unpin> {\n     Box::new(|| {\n         yield t;\n     })"}, {"sha": "d36592583cdc598c70fe0f87b6f9c149d5b5c881", "filename": "src/test/ui/generator/borrowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,7 +6,7 @@ use std::pin::Pin;\n fn main() {\n     let _b = {\n         let a = 3;\n-        Pin::new(&mut || yield &a).resume()\n+        Pin::new(&mut || yield &a).resume(())\n         //~^ ERROR: `a` does not live long enough\n     };\n "}, {"sha": "83987e19839ce81ca82b2d90c3303ece764af3fc", "filename": "src/test/ui/generator/borrowing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,7 +1,7 @@\n error[E0597]: `a` does not live long enough\n   --> $DIR/borrowing.rs:9:33\n    |\n-LL |         Pin::new(&mut || yield &a).resume()\n+LL |         Pin::new(&mut || yield &a).resume(())\n    |                       ----------^\n    |                       |         |\n    |                       |         borrowed value does not live long enough"}, {"sha": "990d94e6efc1bb5245bef77147675f7b34ab945d", "filename": "src/test/ui/generator/conditional-drop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fconditional-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fconditional-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fconditional-drop.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -35,9 +35,9 @@ fn t1() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    Pin::new(&mut a).resume();\n+    Pin::new(&mut a).resume(());\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n-    Pin::new(&mut a).resume();\n+    Pin::new(&mut a).resume(());\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n }\n \n@@ -51,8 +51,8 @@ fn t2() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    Pin::new(&mut a).resume();\n+    Pin::new(&mut a).resume(());\n     assert_eq!(A.load(Ordering::SeqCst), n);\n-    Pin::new(&mut a).resume();\n+    Pin::new(&mut a).resume(());\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n }"}, {"sha": "9d4c217b76ed783bae301916e4585f5d4f6077a2", "filename": "src/test/ui/generator/control-flow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fcontrol-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fcontrol-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fcontrol-flow.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -7,10 +7,10 @@ use std::ops::{GeneratorState, Generator};\n use std::pin::Pin;\n \n fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n-    where T: Generator<Yield = ()> + Unpin,\n+    where T: Generator<(), Yield = ()> + Unpin,\n {\n     loop {\n-        match Pin::new(&mut t).resume() {\n+        match Pin::new(&mut t).resume(()) {\n             GeneratorState::Yielded(()) => amt = amt.checked_sub(1).unwrap(),\n             GeneratorState::Complete(ret) => {\n                 assert_eq!(amt, 0);"}, {"sha": "a9a50a122a19cee290bbfed4eeaa1acc25f2f9ad", "filename": "src/test/ui/generator/drop-and-replace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdrop-and-replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdrop-and-replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-and-replace.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     };\n \n     loop {\n-        match Pin::new(&mut a).resume() {\n+        match Pin::new(&mut a).resume(()) {\n             GeneratorState::Complete(()) => break,\n             _ => (),\n         }"}, {"sha": "7ba711881045dd25c521f67934e492fcdf3c97ea", "filename": "src/test/ui/generator/drop-env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdrop-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdrop-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdrop-env.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -30,7 +30,7 @@ fn t1() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    drop(Pin::new(&mut foo).resume());\n+    drop(Pin::new(&mut foo).resume(()));\n     assert_eq!(A.load(Ordering::SeqCst), n);\n     drop(foo);\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n@@ -43,7 +43,7 @@ fn t2() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    drop(Pin::new(&mut foo).resume());\n+    drop(Pin::new(&mut foo).resume(()));\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n     drop(foo);\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);"}, {"sha": "4c18077f33573e79aeb48647ddd7bb55f6db4580", "filename": "src/test/ui/generator/dropck-resume.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,33 @@\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::pin::Pin;\n+\n+struct SetToNone<'a: 'b, 'b>(&'b mut Option<&'a i32>);\n+\n+impl<'a, 'b> Drop for SetToNone<'a, 'b> {\n+    fn drop(&mut self) {\n+        *self.0 = None;\n+    }\n+}\n+\n+fn drop_using_generator() -> i32 {\n+    let mut y = Some(&0);\n+    let z = &mut y;\n+    let r;\n+    {\n+        let mut g = move |r| {\n+            let _s = SetToNone(r);\n+            yield;\n+        };\n+        let mut g = Pin::new(&mut g);\n+        g.as_mut().resume(z);\n+        r = y.as_ref().unwrap();\n+        //~^ ERROR cannot borrow `y` as immutable because it is also borrowed as mutable\n+    }\n+    **r\n+}\n+\n+fn main() {\n+    println!(\"{}\", drop_using_generator());\n+}"}, {"sha": "ecf92e7e3ae79c179026abd44406f8d90e66706f", "filename": "src/test/ui/generator/dropck-resume.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck-resume.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,15 @@\n+error[E0502]: cannot borrow `y` as immutable because it is also borrowed as mutable\n+  --> $DIR/dropck-resume.rs:25:13\n+   |\n+LL |     let z = &mut y;\n+   |             ------ mutable borrow occurs here\n+...\n+LL |         r = y.as_ref().unwrap();\n+   |             ^ immutable borrow occurs here\n+LL |\n+LL |     }\n+   |     - mutable borrow might be used here, when `g` is dropped and runs the destructor for generator\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0502`."}, {"sha": "da00b230d9fb73b54e7506187a4d9b967772fbfd", "filename": "src/test/ui/generator/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,6 @@ fn main() {\n         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n         yield;\n     };\n-    Pin::new(&mut gen).resume();\n+    Pin::new(&mut gen).resume(());\n     // drops the RefCell and then the Ref, leading to use-after-free\n }"}, {"sha": "5f0a6bb09b7843f452575ed051cb352cfbb95760", "filename": "src/test/ui/generator/generator-region-requirements.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fgenerator-region-requirements.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,7 +8,7 @@ fn dangle(x: &mut i32) -> &'static mut i32 {\n         x\n     };\n     loop {\n-        match Pin::new(&mut g).resume() {\n+        match Pin::new(&mut g).resume(()) {\n             GeneratorState::Complete(c) => return c,\n             //~^ ERROR explicit lifetime required\n             GeneratorState::Yielded(_) => (),"}, {"sha": "389b9d139694195499a6f8be2657e50ad1890eaa", "filename": "src/test/ui/generator/issue-44197.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fissue-44197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fissue-44197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-44197.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,14 +2,14 @@\n \n #![feature(generators, generator_trait)]\n \n-use std::ops::{ Generator, GeneratorState };\n+use std::ops::{Generator, GeneratorState};\n use std::pin::Pin;\n \n fn foo(_: &str) -> String {\n     String::new()\n }\n \n-fn bar(baz: String) -> impl Generator<Yield = String, Return = ()> {\n+fn bar(baz: String) -> impl Generator<(), Yield = String, Return = ()> {\n     move || {\n         yield foo(&baz);\n     }\n@@ -19,7 +19,7 @@ fn foo2(_: &str) -> Result<String, ()> {\n     Err(())\n }\n \n-fn bar2(baz: String) -> impl Generator<Yield = String, Return = ()> {\n+fn bar2(baz: String) -> impl Generator<(), Yield = String, Return = ()> {\n     move || {\n         if let Ok(quux) = foo2(&baz) {\n             yield quux;\n@@ -28,6 +28,9 @@ fn bar2(baz: String) -> impl Generator<Yield = String, Return = ()> {\n }\n \n fn main() {\n-    assert_eq!(Pin::new(&mut bar(String::new())).resume(), GeneratorState::Yielded(String::new()));\n-    assert_eq!(Pin::new(&mut bar2(String::new())).resume(), GeneratorState::Complete(()));\n+    assert_eq!(\n+        Pin::new(&mut bar(String::new())).resume(()),\n+        GeneratorState::Yielded(String::new())\n+    );\n+    assert_eq!(Pin::new(&mut bar2(String::new())).resume(()), GeneratorState::Complete(()));\n }"}, {"sha": "187c374021dcac962c5bd4a8a919cc700e787b28", "filename": "src/test/ui/generator/issue-61442-stmt-expr-with-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fissue-61442-stmt-expr-with-drop.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -18,12 +18,12 @@ fn drop_and_yield() {\n         String::new();\n         yield;\n     };\n-    Box::pin(x).as_mut().resume();\n+    Box::pin(x).as_mut().resume(());\n     let y = static || {\n         String::new();\n         yield;\n     };\n-    Box::pin(y).as_mut().resume();\n+    Box::pin(y).as_mut().resume(());\n }\n \n fn main() {"}, {"sha": "90eefe02f664e46fa7bf8a4ee51e333c340751ef", "filename": "src/test/ui/generator/iterator-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fiterator-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fiterator-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fiterator-count.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,18 +10,18 @@ struct W<T>(T);\n \n // This impl isn't safe in general, but the generator used in this test is movable\n // so it won't cause problems.\n-impl<T: Generator<Return = ()> + Unpin> Iterator for W<T> {\n+impl<T: Generator<(), Return = ()> + Unpin> Iterator for W<T> {\n     type Item = T::Yield;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        match Pin::new(&mut self.0).resume() {\n+        match Pin::new(&mut self.0).resume(()) {\n             GeneratorState::Complete(..) => None,\n             GeneratorState::Yielded(v) => Some(v),\n         }\n     }\n }\n \n-fn test() -> impl Generator<Return=(), Yield=u8> + Unpin {\n+fn test() -> impl Generator<(), Return=(), Yield=u8> + Unpin {\n     || {\n         for i in 1..6 {\n             yield i"}, {"sha": "6a2e42a5573a8486814f17145a15599fc805cb2c", "filename": "src/test/ui/generator/live-upvar-across-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Flive-upvar-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Flive-upvar-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Flive-upvar-across-yield.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let mut a = || {\n         b(yield);\n     };\n-    Pin::new(&mut a).resume();\n+    Pin::new(&mut a).resume(());\n }"}, {"sha": "45519150eec2b560bd64d3e519cf39cd19add0b9", "filename": "src/test/ui/generator/nested_generators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fnested_generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fnested_generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fnested_generators.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -11,7 +11,7 @@ fn main() {\n             yield 2;\n         };\n \n-        match Pin::new(&mut sub_generator).resume() {\n+        match Pin::new(&mut sub_generator).resume(()) {\n             GeneratorState::Yielded(x) => {\n                 yield x;\n             }"}, {"sha": "6b5a557933953381296326acd8fe24b83f27ef35", "filename": "src/test/ui/generator/no-parameters-on-generators.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92fc98c695d133ae28fb9d386d22efef57e2fc87/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92fc98c695d133ae28fb9d386d22efef57e2fc87/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.rs?ref=92fc98c695d133ae28fb9d386d22efef57e2fc87", "patch": "@@ -1,8 +0,0 @@\n-#![feature(generators)]\n-\n-fn main() {\n-    let gen = |start| { //~ ERROR generators cannot have explicit parameters\n-        //~^ ERROR type inside generator must be known in this context\n-        yield;\n-    };\n-}"}, {"sha": "5e8e043a391ce280810483861084730b95dc77c9", "filename": "src/test/ui/generator/no-parameters-on-generators.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92fc98c695d133ae28fb9d386d22efef57e2fc87/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92fc98c695d133ae28fb9d386d22efef57e2fc87/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fno-parameters-on-generators.stderr?ref=92fc98c695d133ae28fb9d386d22efef57e2fc87", "patch": "@@ -1,21 +0,0 @@\n-error[E0628]: generators cannot have explicit parameters\n-  --> $DIR/no-parameters-on-generators.rs:4:15\n-   |\n-LL |     let gen = |start| {\n-   |               ^^^^^^^\n-\n-error[E0698]: type inside generator must be known in this context\n-  --> $DIR/no-parameters-on-generators.rs:4:16\n-   |\n-LL |     let gen = |start| {\n-   |                ^^^^^ cannot infer type\n-   |\n-note: the type is part of the generator because of this `yield`\n-  --> $DIR/no-parameters-on-generators.rs:6:9\n-   |\n-LL |         yield;\n-   |         ^^^^^\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0698`."}, {"sha": "29f4788b2757f5b0be79472d5125c0d76383d868", "filename": "src/test/ui/generator/panic-drops-resume.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops-resume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops-resume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops-resume.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,37 @@\n+//! Tests that panics inside a generator will correctly drop the initial resume argument.\n+\n+// run-pass\n+// ignore-wasm       no unwind support\n+// ignore-emscripten no unwind support\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::pin::Pin;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+static DROP: AtomicUsize = AtomicUsize::new(0);\n+\n+struct Dropper {}\n+\n+impl Drop for Dropper {\n+    fn drop(&mut self) {\n+        DROP.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    let mut gen = |_arg| {\n+        if true {\n+            panic!();\n+        }\n+        yield ();\n+    };\n+    let mut gen = Pin::new(&mut gen);\n+\n+    assert_eq!(DROP.load(Ordering::Acquire), 0);\n+    let res = catch_unwind(AssertUnwindSafe(|| gen.as_mut().resume(Dropper {})));\n+    assert!(res.is_err());\n+    assert_eq!(DROP.load(Ordering::Acquire), 1);\n+}"}, {"sha": "c9a201725aea2705240b99a9c6165992b53f1ff1", "filename": "src/test/ui/generator/panic-drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpanic-drops.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -35,7 +35,7 @@ fn main() {\n \n     assert_eq!(A.load(Ordering::SeqCst), 0);\n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        Pin::new(&mut foo).resume()\n+        Pin::new(&mut foo).resume(())\n     }));\n     assert!(res.is_err());\n     assert_eq!(A.load(Ordering::SeqCst), 1);\n@@ -50,7 +50,7 @@ fn main() {\n \n     assert_eq!(A.load(Ordering::SeqCst), 1);\n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        Pin::new(&mut foo).resume()\n+        Pin::new(&mut foo).resume(())\n     }));\n     assert!(res.is_err());\n     assert_eq!(A.load(Ordering::SeqCst), 1);"}, {"sha": "500a3c9c2950e6177c32b1d466d2b59616e9bbcb", "filename": "src/test/ui/generator/panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fpanic-safe.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -17,13 +17,13 @@ fn main() {\n     };\n \n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        Pin::new(&mut foo).resume()\n+        Pin::new(&mut foo).resume(())\n     }));\n     assert!(res.is_err());\n \n     for _ in 0..10 {\n         let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-            Pin::new(&mut foo).resume()\n+            Pin::new(&mut foo).resume(())\n         }));\n         assert!(res.is_err());\n     }"}, {"sha": "efed08bd4708f2e803c142b2590caeecfc9848f5", "filename": "src/test/ui/generator/resume-after-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-after-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-after-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-after-return.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -16,12 +16,12 @@ fn main() {\n         yield;\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n \n-    match panic::catch_unwind(move || Pin::new(&mut foo).resume()) {\n+    match panic::catch_unwind(move || Pin::new(&mut foo).resume(())) {\n         Ok(_) => panic!(\"generator successfully resumed\"),\n         Err(_) => {}\n     }"}, {"sha": "87b1f1a065bc8c3099b34410267256398fb84765", "filename": "src/test/ui/generator/resume-arg-late-bound.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,17 @@\n+//! Tests that we cannot produce a generator that accepts a resume argument\n+//! with any lifetime and then stores it across a `yield`.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn test(a: impl for<'a> Generator<&'a mut bool>) {}\n+\n+fn main() {\n+    let gen = |arg: &mut bool| {\n+        yield ();\n+        *arg = true;\n+    };\n+    test(gen);\n+    //~^ ERROR type mismatch in function arguments\n+}"}, {"sha": "7719d5123f4663213b110b427869341a905d802a", "filename": "src/test/ui/generator/resume-arg-late-bound.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-arg-late-bound.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,15 @@\n+error[E0631]: type mismatch in function arguments\n+  --> $DIR/resume-arg-late-bound.rs:15:10\n+   |\n+LL | fn test(a: impl for<'a> Generator<&'a mut bool>) {}\n+   |    ----         ------------------------------- required by this bound in `test`\n+...\n+LL |     test(gen);\n+   |          ^^^\n+   |          |\n+   |          expected signature of `for<'a> fn(&'a mut bool) -> _`\n+   |          found signature of `fn(&mut bool) -> _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0631`."}, {"sha": "4c4cf117a556316f58c00b0a41f1821554c1163e", "filename": "src/test/ui/generator/resume-live-across-yield.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-live-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fresume-live-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fresume-live-across-yield.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,45 @@\n+// run-pass\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::{Generator, GeneratorState};\n+use std::pin::Pin;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+static DROP: AtomicUsize = AtomicUsize::new(0);\n+\n+#[derive(PartialEq, Eq, Debug)]\n+struct Dropper(String);\n+\n+impl Drop for Dropper {\n+    fn drop(&mut self) {\n+        DROP.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    let mut g = |mut _d| {\n+        _d = yield;\n+        _d\n+    };\n+\n+    let mut g = Pin::new(&mut g);\n+\n+    assert_eq!(\n+        g.as_mut().resume(Dropper(String::from(\"Hello world!\"))),\n+        GeneratorState::Yielded(())\n+    );\n+    assert_eq!(DROP.load(Ordering::Acquire), 0);\n+    match g.as_mut().resume(Dropper(String::from(\"Number Two\"))) {\n+        GeneratorState::Complete(dropper) => {\n+            assert_eq!(DROP.load(Ordering::Acquire), 1);\n+            assert_eq!(dropper.0, \"Number Two\");\n+            drop(dropper);\n+            assert_eq!(DROP.load(Ordering::Acquire), 2);\n+        }\n+        _ => unreachable!(),\n+    }\n+\n+    drop(g);\n+    assert_eq!(DROP.load(Ordering::Acquire), 2);\n+}"}, {"sha": "0606ea71cdf372a84ef2f504543068146144f2a8", "filename": "src/test/ui/generator/retain-resume-ref.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,25 @@\n+//! This test ensures that a mutable reference cannot be passed as a resume argument twice.\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::marker::Unpin;\n+use std::ops::{\n+    Generator,\n+    GeneratorState::{self, *},\n+};\n+use std::pin::Pin;\n+\n+fn main() {\n+    let mut thing = String::from(\"hello\");\n+\n+    let mut gen = |r| {\n+        if false {\n+            yield r;\n+        }\n+    };\n+\n+    let mut gen = Pin::new(&mut gen);\n+    gen.as_mut().resume(&mut thing);\n+    gen.as_mut().resume(&mut thing);\n+    //~^ cannot borrow `thing` as mutable more than once at a time\n+}"}, {"sha": "bc715c7030eb397e617376c4bb455e74f945d54f", "filename": "src/test/ui/generator/retain-resume-ref.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fretain-resume-ref.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,14 @@\n+error[E0499]: cannot borrow `thing` as mutable more than once at a time\n+  --> $DIR/retain-resume-ref.rs:23:25\n+   |\n+LL |     gen.as_mut().resume(&mut thing);\n+   |                         ---------- first mutable borrow occurs here\n+LL |     gen.as_mut().resume(&mut thing);\n+   |                         ^^^^^^^^^^ second mutable borrow occurs here\n+LL |\n+LL | }\n+   | - first borrow might be used here, when `gen` is dropped and runs the destructor for generator\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "c6dd738d6ac60d370c1857db6bf83153cb97da0e", "filename": "src/test/ui/generator/sized-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,6 +9,6 @@ fn main() {\n    //~^ ERROR the size for values of type\n        yield s[..];\n    };\n-   Pin::new(&mut gen).resume();\n+   Pin::new(&mut gen).resume(());\n    //~^ ERROR the size for values of type\n }"}, {"sha": "79aeec2ec02801df72fd2e4385cb06989b4de022", "filename": "src/test/ui/generator/sized-yield.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,7 +15,7 @@ LL | |    };\n error[E0277]: the size for values of type `str` cannot be known at compilation time\n   --> $DIR/sized-yield.rs:12:23\n    |\n-LL |    Pin::new(&mut gen).resume();\n+LL |    Pin::new(&mut gen).resume(());\n    |                       ^^^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`"}, {"sha": "32f3ee32d77b9d96eb1320eca4ab4edce2c5129c", "filename": "src/test/ui/generator/smoke-resume-args.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsmoke-resume-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsmoke-resume-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsmoke-resume-args.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,97 @@\n+// run-pass\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::fmt::Debug;\n+use std::marker::Unpin;\n+use std::ops::{\n+    Generator,\n+    GeneratorState::{self, *},\n+};\n+use std::pin::Pin;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+fn drain<G: Generator<R, Yield = Y> + Unpin, R, Y>(\n+    gen: &mut G,\n+    inout: Vec<(R, GeneratorState<Y, G::Return>)>,\n+) where\n+    Y: Debug + PartialEq,\n+    G::Return: Debug + PartialEq,\n+{\n+    let mut gen = Pin::new(gen);\n+\n+    for (input, out) in inout {\n+        assert_eq!(gen.as_mut().resume(input), out);\n+    }\n+}\n+\n+static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+#[derive(Debug, PartialEq)]\n+struct DropMe;\n+\n+impl Drop for DropMe {\n+    fn drop(&mut self) {\n+        DROPS.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn expect_drops<T>(expected_drops: usize, f: impl FnOnce() -> T) -> T {\n+    DROPS.store(0, Ordering::SeqCst);\n+\n+    let res = f();\n+\n+    let actual_drops = DROPS.load(Ordering::SeqCst);\n+    assert_eq!(actual_drops, expected_drops);\n+    res\n+}\n+\n+fn main() {\n+    drain(\n+        &mut |mut b| {\n+            while b != 0 {\n+                b = yield (b + 1);\n+            }\n+            -1\n+        },\n+        vec![(1, Yielded(2)), (-45, Yielded(-44)), (500, Yielded(501)), (0, Complete(-1))],\n+    );\n+\n+    expect_drops(2, || drain(&mut |a| yield a, vec![(DropMe, Yielded(DropMe))]));\n+\n+    expect_drops(6, || {\n+        drain(\n+            &mut |a| yield yield a,\n+            vec![(DropMe, Yielded(DropMe)), (DropMe, Yielded(DropMe)), (DropMe, Complete(DropMe))],\n+        )\n+    });\n+\n+    #[allow(unreachable_code)]\n+    expect_drops(2, || drain(&mut |a| yield return a, vec![(DropMe, Complete(DropMe))]));\n+\n+    expect_drops(2, || {\n+        drain(\n+            &mut |a: DropMe| {\n+                if false { yield () } else { a }\n+            },\n+            vec![(DropMe, Complete(DropMe))],\n+        )\n+    });\n+\n+    expect_drops(4, || {\n+        drain(\n+            #[allow(unused_assignments, unused_variables)]\n+            &mut |mut a: DropMe| {\n+                a = yield;\n+                a = yield;\n+                a = yield;\n+            },\n+            vec![\n+                (DropMe, Yielded(())),\n+                (DropMe, Yielded(())),\n+                (DropMe, Yielded(())),\n+                (DropMe, Complete(())),\n+            ],\n+        )\n+    });\n+}"}, {"sha": "9289710b34bf980f58244e0459aad8794ae5b9dd", "filename": "src/test/ui/generator/smoke.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsmoke.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -17,7 +17,7 @@ fn simple() {\n         }\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -33,7 +33,7 @@ fn return_capture() {\n         a\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -45,11 +45,11 @@ fn simple_yield() {\n         yield;\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Yielded(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -62,11 +62,11 @@ fn yield_capture() {\n         yield b;\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Yielded(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -79,11 +79,11 @@ fn simple_yield_value() {\n         return String::from(\"foo\")\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Yielded(ref s) if *s == \"bar\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -97,11 +97,11 @@ fn return_after_yield() {\n         return a\n     };\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Yielded(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -149,11 +149,11 @@ fn send_and_sync() {\n fn send_over_threads() {\n     let mut foo = || { yield };\n     thread::spawn(move || {\n-        match Pin::new(&mut foo).resume() {\n+        match Pin::new(&mut foo).resume(()) {\n             GeneratorState::Yielded(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n-        match Pin::new(&mut foo).resume() {\n+        match Pin::new(&mut foo).resume(()) {\n             GeneratorState::Complete(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n@@ -162,11 +162,11 @@ fn send_over_threads() {\n     let a = String::from(\"a\");\n     let mut foo = || { yield a };\n     thread::spawn(move || {\n-        match Pin::new(&mut foo).resume() {\n+        match Pin::new(&mut foo).resume(()) {\n             GeneratorState::Yielded(ref s) if *s == \"a\" => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n-        match Pin::new(&mut foo).resume() {\n+        match Pin::new(&mut foo).resume(()) {\n             GeneratorState::Complete(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }"}, {"sha": "3980766c4287e73e7947d4af964e969fa4d39129", "filename": "src/test/ui/generator/static-generators.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fstatic-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fstatic-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fstatic-generators.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     // Safety: We shadow the original generator variable so have no safe API to\n     // move it after this point.\n     let mut generator = unsafe { Pin::new_unchecked(&mut generator) };\n-    assert_eq!(generator.as_mut().resume(), GeneratorState::Yielded(()));\n-    assert_eq!(generator.as_mut().resume(), GeneratorState::Complete(()));\n+    assert_eq!(generator.as_mut().resume(()), GeneratorState::Yielded(()));\n+    assert_eq!(generator.as_mut().resume(()), GeneratorState::Complete(()));\n }"}, {"sha": "7a353ea298b26c5c7ce2ac24be6961678c7c32de", "filename": "src/test/ui/generator/too-many-parameters.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,8 @@\n+#![feature(generators)]\n+\n+fn main() {\n+    |(), ()| {\n+        //~^ error: too many parameters for a generator\n+        yield;\n+    };\n+}"}, {"sha": "a297ee43de9695dc0e7a5c7e32de0126b1130eba", "filename": "src/test/ui/generator/too-many-parameters.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,8 @@\n+error[E0628]: too many parameters for a generator (expected 0 or 1 parameters)\n+  --> $DIR/too-many-parameters.rs:4:5\n+   |\n+LL |     |(), ()| {\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d39c788a84bd409eba24c4b4a2c3063f20caf195", "filename": "src/test/ui/generator/type-mismatch-error.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,22 @@\n+//! Test that we get the expected type mismatch error instead of \"closure is expected to take 0\n+//! arguments\" (which got introduced after implementing resume arguments).\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::ops::Generator;\n+\n+fn f<G: Generator>(_: G, _: G::Return) {}\n+\n+fn main() {\n+    f(\n+        |a: u8| {\n+            if false {\n+                yield ();\n+            } else {\n+                a\n+                //~^ error: `if` and `else` have incompatible types\n+            }\n+        },\n+        0u8,\n+    );\n+}"}, {"sha": "8f5949533e2c786c2ae948e883676d1dbda99282", "filename": "src/test/ui/generator/type-mismatch-error.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-error.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/type-mismatch-error.rs:16:17\n+   |\n+LL | /             if false {\n+LL | |                 yield ();\n+   | |                 ---------\n+   | |                 |       |\n+   | |                 |       help: consider removing this semicolon\n+   | |                 expected because of this\n+LL | |             } else {\n+LL | |                 a\n+   | |                 ^ expected `()`, found `u8`\n+LL | |\n+LL | |             }\n+   | |_____________- `if` and `else` have incompatible types\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7774ff48f56b730b7bdc028dccf03771e07cee1e", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -2,15 +2,15 @@\n \n use std::ops::Generator;\n \n-fn foo() -> impl Generator<Return = i32> {\n+fn foo() -> impl Generator<Return = i32> { //~ ERROR type mismatch\n     || {\n         if false {\n-            return Ok(6); //~ ERROR mismatched types [E0308]\n+            return Ok(6);\n         }\n \n         yield ();\n \n-        5\n+        5 //~ ERROR mismatched types [E0308]\n     }\n }\n "}, {"sha": "8de77798ff48e632f3926ad9ba0879b3baf0aa7b", "filename": "src/test/ui/generator/type-mismatch-signature-deduction.stderr", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftype-mismatch-signature-deduction.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -1,12 +1,23 @@\n error[E0308]: mismatched types\n-  --> $DIR/type-mismatch-signature-deduction.rs:8:20\n+  --> $DIR/type-mismatch-signature-deduction.rs:13:9\n    |\n-LL |             return Ok(6);\n-   |                    ^^^^^ expected `i32`, found enum `std::result::Result`\n+LL |         5\n+   |         ^ expected enum `std::result::Result`, found integer\n    |\n-   = note: expected type `i32`\n-              found enum `std::result::Result<{integer}, _>`\n+   = note: expected type `std::result::Result<{integer}, _>`\n+              found type `{integer}`\n \n-error: aborting due to previous error\n+error[E0271]: type mismatch resolving `<[generator@$DIR/type-mismatch-signature-deduction.rs:6:5: 14:6 _] as std::ops::Generator>::Return == i32`\n+  --> $DIR/type-mismatch-signature-deduction.rs:5:13\n+   |\n+LL | fn foo() -> impl Generator<Return = i32> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::result::Result`, found `i32`\n+   |\n+   = note: expected enum `std::result::Result<{integer}, _>`\n+              found type `i32`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0271, E0308.\n+For more information about an error, try `rustc --explain E0271`."}, {"sha": "1b1cff3387d9f7ea34388d4dd17f7c36b95acd75", "filename": "src/test/ui/generator/xcrate-reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fxcrate-reachable.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,5 +10,5 @@ use std::ops::Generator;\n use std::pin::Pin;\n \n fn main() {\n-    Pin::new(&mut foo::foo()).resume();\n+    Pin::new(&mut foo::foo()).resume(());\n }"}, {"sha": "40986bbeb6517243f3f487ce1f2dcafcb32b612d", "filename": "src/test/ui/generator/xcrate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fxcrate.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,18 +12,18 @@ use std::pin::Pin;\n fn main() {\n     let mut foo = xcrate::foo();\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n \n     let mut foo = xcrate::bar(3);\n \n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Yielded(3) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match Pin::new(&mut foo).resume() {\n+    match Pin::new(&mut foo).resume(()) {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }"}, {"sha": "985e5d8bdc83818e1466153e7e931c5e5602bc11", "filename": "src/test/ui/generator/yield-while-iterating.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -43,7 +43,7 @@ fn yield_during_iter_borrowed_slice_3() {\n             yield p;\n         }\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn yield_during_iter_borrowed_slice_4() {\n@@ -56,7 +56,7 @@ fn yield_during_iter_borrowed_slice_4() {\n         }\n     };\n     println!(\"{}\", x[0]); //~ ERROR\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn yield_during_range_iter() {\n@@ -69,7 +69,7 @@ fn yield_during_range_iter() {\n             yield x;\n         }\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn main() { }"}, {"sha": "b6563475235c244da583e9d335a13e8543b0b754", "filename": "src/test/ui/generator/yield-while-iterating.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -16,7 +16,7 @@ LL |         for p in &mut x {\n ...\n LL |     println!(\"{}\", x[0]);\n    |                    ^ immutable borrow occurs here\n-LL |     Pin::new(&mut b).resume();\n+LL |     Pin::new(&mut b).resume(());\n    |              ------ mutable borrow later used here\n \n error: aborting due to 2 previous errors"}, {"sha": "061a64dbc364d9143dbe310e31ba589fad76ef92", "filename": "src/test/ui/generator/yield-while-local-borrowed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,7 +15,7 @@ fn borrow_local_inline() {\n         yield();\n         println!(\"{}\", a);\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn borrow_local_inline_done() {\n@@ -26,7 +26,7 @@ fn borrow_local_inline_done() {\n         }\n         yield();\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn borrow_local() {\n@@ -43,7 +43,7 @@ fn borrow_local() {\n             println!(\"{}\", b);\n         }\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn main() { }"}, {"sha": "a03ef945dd231c2b6cf4929ae06332340e1a8dd3", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -12,7 +12,7 @@ fn reborrow_shared_ref(x: &i32) {\n         yield();\n         println!(\"{}\", a);\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn reborrow_mutable_ref(x: &mut i32) {\n@@ -23,7 +23,7 @@ fn reborrow_mutable_ref(x: &mut i32) {\n         yield();\n         println!(\"{}\", a);\n     };\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn reborrow_mutable_ref_2(x: &mut i32) {\n@@ -34,7 +34,7 @@ fn reborrow_mutable_ref_2(x: &mut i32) {\n         println!(\"{}\", a);\n     };\n     println!(\"{}\", x); //~ ERROR\n-    Pin::new(&mut b).resume();\n+    Pin::new(&mut b).resume(());\n }\n \n fn main() { }"}, {"sha": "fd885660d092758f61ff23236596e98bbb5a8ec1", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,7 +8,7 @@ LL |         let a = &mut *x;\n ...\n LL |     println!(\"{}\", x);\n    |                    ^ second borrow occurs here\n-LL |     Pin::new(&mut b).resume();\n+LL |     Pin::new(&mut b).resume(());\n    |              ------ first borrow later used here\n \n error: aborting due to previous error"}, {"sha": "3a9c918cd3720f652e4d5cf49f342e874cd48a5a", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-dotdotdot-bad-syntax.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -30,6 +30,8 @@ LL |             let ...$e;\n ...\n LL |     mac!(0);\n    |     -------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 5 previous errors\n "}, {"sha": "871c9b57e5444878ae7987f1319b65abdf97a4f0", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-inclusive-no-end.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-inclusive-no-end.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -40,6 +40,7 @@ LL |     mac!(0);\n    |     -------- in this macro invocation\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0586]: inclusive range with no end\n   --> $DIR/half-open-range-pats-inclusive-no-end.rs:21:19\n@@ -51,6 +52,7 @@ LL |     mac!(0);\n    |     -------- in this macro invocation\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 6 previous errors\n "}, {"sha": "b91798fa1237913a168ea43df13fb5f4eebd4c95", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_ret_a_vs_bound_a_ret_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                             for<'a>    fn(&'a u32, &'a u3\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32>`\n               found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32) -> &'a u32>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "45f53d4fe99db100ec221ad503ca80717c510b44", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_b_vs_bound_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_b_vs_bound_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                 for<'a>    fn(&'a u32, &'a u32)) }\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(&'a u32, &'b u32)>`\n               found enum `std::option::Option<for<'a> fn(&'a u32, &'a u32)>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c3e4f6d2ed0c1c91e348822f324bcacb0e28f386", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_a_vs_free_x.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_a_vs_free_x.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                              fn(&'x u32)) }\n    |\n    = note: expected enum `std::option::Option<for<'a> fn(&'a u32)>`\n               found enum `std::option::Option<fn(&'x u32)>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "4d7b86027f56463d68b380b4bd73d51b354d1f93", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_b_vs_bound_co_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                       for<'a>    fn(Co<'a>, Co<'a>)) }\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>)>`\n               found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>)>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "7f0a4197dd7fe412d5602ba145b5a0c8970e48bc", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_co_a_co_b_ret_contra_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                         for<'a>    fn(Co<'a>, Co<'a>) ->\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Co<'a>, Co<'b>) -> Contra<'a>>`\n               found enum `std::option::Option<for<'a> fn(Co<'a>, Co<'a>) -> Contra<'a>>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "c12e543a44e79e29a8cd21449e220cbfd0a96864", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_contra_a_contra_b_ret_co_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                             for<'a>    fn(Contra<'a>, Con\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>>`\n               found enum `std::option::Option<for<'a> fn(Contra<'a>, Contra<'a>) -> Co<'a>>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "460356856bd562cd9f229b1f832c5cb04982635d", "filename": "src/test/ui/hr-subtype/hr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.bound_inv_a_b_vs_bound_inv_a.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL | |                                         for<'a>    fn(Inv<'a>, Inv<'a>))\n    |\n    = note: expected enum `std::option::Option<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>`\n               found enum `std::option::Option<for<'a> fn(Inv<'a>, Inv<'a>)>`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "6b5e7a5a6345a5ecf515af8b60aca007e25054a3", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.nll.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -13,6 +13,7 @@ LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: lifetime may not live long enough\n   --> $DIR/hr-subtype.rs:39:13\n@@ -29,6 +30,7 @@ LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "fc3643306e628cf0a1cb0185a1a674f495df2557", "filename": "src/test/ui/hr-subtype/hr-subtype.free_inv_x_vs_free_inv_y.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_inv_x_vs_free_inv_y.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -28,6 +28,7 @@ LL |           fn subtype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0308]: mismatched types\n   --> $DIR/hr-subtype.rs:39:26\n@@ -59,6 +60,7 @@ LL |           fn supertype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n LL | |                                     fn(Inv<'y>)) }\n    | |__________________________________________________- in this macro invocation\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7c0770924daaac4c54807f3824e57b3b24c45e92", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.nll.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.nll.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -13,6 +13,7 @@ LL | |                             fn(&'y u32)) }\n    | |__________________________________________- in this macro invocation\n    |\n    = help: consider adding the following bound: `'x: 'y`\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "0dde27788f6296212d46f897aa762803c7ea0fcc", "filename": "src/test/ui/hr-subtype/hr-subtype.free_x_vs_free_y.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhr-subtype%2Fhr-subtype.free_x_vs_free_y.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -28,6 +28,7 @@ LL |           fn supertype<'x,'y:'x,'z:'y>() {\n LL | / check! { free_x_vs_free_y: (fn(&'x u32),\n LL | |                             fn(&'y u32)) }\n    | |__________________________________________- in this macro invocation\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "dec1bd62ca936fa8d03a547b8a8368635f28c2e3", "filename": "src/test/ui/hygiene/assoc_item_ctxt.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fassoc_item_ctxt.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -6,6 +6,8 @@ LL |             fn method() {}\n ...\n LL |     mac_trait_impl!();\n    |     ------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0046]: not all trait items implemented, missing: `method`\n   --> $DIR/assoc_item_ctxt.rs:34:9\n@@ -18,6 +20,8 @@ LL |         impl Tr for u8 {\n ...\n LL |     mac_trait_impl!();\n    |     ------------------ in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "04f5bed5e05eaff01baf550d7fd67c0083973b52", "filename": "src/test/ui/hygiene/duplicate_lifetimes.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fduplicate_lifetimes.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -9,6 +9,8 @@ LL | m!('a);\n    | |  |\n    | |  previous declaration here\n    | in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0263]: lifetime name `'a` declared twice in the same scope\n   --> $DIR/duplicate_lifetimes.rs:13:14\n@@ -21,6 +23,8 @@ LL | n!('a);\n    | |  |\n    | |  previous declaration here\n    | in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b9e05c84a8aea887e02e5fb209acca159579b478", "filename": "src/test/ui/hygiene/extern-prelude-from-opaque-fail.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fextern-prelude-from-opaque-fail.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -15,6 +15,8 @@ LL |         use my_core;\n ...\n LL | a!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0433]: failed to resolve: use of undeclared type or module `my_core`\n   --> $DIR/extern-prelude-from-opaque-fail.rs:11:18\n@@ -24,6 +26,8 @@ LL |         fn f() { my_core::mem::drop(0); }\n ...\n LL | a!();\n    | ----- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0433]: failed to resolve: use of undeclared type or module `my_core`\n   --> $DIR/extern-prelude-from-opaque-fail.rs:24:14"}, {"sha": "8070ffdfdeb89cfc6d744432655e140edb2c720e", "filename": "src/test/ui/hygiene/fields-definition.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -8,6 +8,8 @@ LL |             $a: u8,\n ...\n LL | legacy!(a);\n    | ----------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "5ce786dce837c078706231893d2c5bd7241a9787", "filename": "src/test/ui/hygiene/fields-move.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69075f065cdbb0a5138549260c3f2f8234aa7cfc/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.stderr?ref=69075f065cdbb0a5138549260c3f2f8234aa7cfc", "patch": "@@ -10,6 +10,7 @@ LL |     assert_two_copies(copy_legacy!(foo), foo.x);\n    |                       ----------------- in this macro invocation\n    |\n    = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0382]: use of moved value: `foo.x`\n   --> $DIR/fields-move.rs:28:42"}]}