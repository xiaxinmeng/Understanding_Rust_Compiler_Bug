{"sha": "8b16af590dd3d241bec07f69f4d4dadae9a4b523", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMTZhZjU5MGRkM2QyNDFiZWMwN2Y2OWY0ZDRkYWRhZTlhNGI1MjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-19T21:20:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-19T21:20:43Z"}, "message": "Merge #8112\n\n8112: Revamp `hir_def` attribute API r=Veykril a=jonas-schievink\n\nThis adds `AttrsWithOwner`, which can construct an accurate `AttrSourceMap` without requiring additional information from the caller.\r\n\r\nr? @Veykril \n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "79729a2efc6d2cdb2557cd313ee79a25245983d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79729a2efc6d2cdb2557cd313ee79a25245983d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b16af590dd3d241bec07f69f4d4dadae9a4b523", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgVRWrCRBK7hj4Ov3rIwAAdHIIAATJPobbtJceduI2LplAidzr\nsM+K+ZgQW0X8JgXFghVuVU3MPaQaYDKnO7J6+DMITa4nqOz7qXPEGb0IzWlCwlq8\n0jIWwqIx/CPpxskHlYTUFT99ehnWVYM+1BkHvMpKZX0t4FD6JEf/WUKeG2d3yvcX\nP7UPW2b8i9l8MHYGUE4nagjwLOjq26MAXbp4RBwPXEwP3Ypen4wDgtqWc2XoP3g4\nPqvP/DO2CDwOzDEiV36n2MPeuIKe7RXE6AOPdvvtEeq/2voG8ffNDx5bXEf4eGT8\n9HPeYY9dJCSF6L/nxlI6VxI+w1grWOZifSZQI8vI71IUynWZFUOLpoDNGZHiB6o=\n=CNdt\n-----END PGP SIGNATURE-----\n", "payload": "tree 79729a2efc6d2cdb2557cd313ee79a25245983d3\nparent fc21640a65b5caef8dbbc9e85e9616b843847fb4\nparent 636de3c709a7c86a1d3a870dc5dc3566310e9d92\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1616188843 +0000\ncommitter GitHub <noreply@github.com> 1616188843 +0000\n\nMerge #8112\n\n8112: Revamp `hir_def` attribute API r=Veykril a=jonas-schievink\n\nThis adds `AttrsWithOwner`, which can construct an accurate `AttrSourceMap` without requiring additional information from the caller.\r\n\r\nr? @Veykril \n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b16af590dd3d241bec07f69f4d4dadae9a4b523", "html_url": "https://github.com/rust-lang/rust/commit/8b16af590dd3d241bec07f69f4d4dadae9a4b523", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b16af590dd3d241bec07f69f4d4dadae9a4b523/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc21640a65b5caef8dbbc9e85e9616b843847fb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc21640a65b5caef8dbbc9e85e9616b843847fb4", "html_url": "https://github.com/rust-lang/rust/commit/fc21640a65b5caef8dbbc9e85e9616b843847fb4"}, {"sha": "636de3c709a7c86a1d3a870dc5dc3566310e9d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/636de3c709a7c86a1d3a870dc5dc3566310e9d92", "html_url": "https://github.com/rust-lang/rust/commit/636de3c709a7c86a1d3a870dc5dc3566310e9d92"}], "stats": {"total": 435, "additions": 248, "deletions": 187}, "files": [{"sha": "4a11622fc919840a0ad976144690bd1a0bc6b67c", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -1,6 +1,6 @@\n //! Attributes & documentation for hir types.\n use hir_def::{\n-    attr::{Attrs, Documentation},\n+    attr::{AttrsWithOwner, Documentation},\n     path::ModPath,\n     per_ns::PerNs,\n     resolver::HasResolver,\n@@ -16,7 +16,7 @@ use crate::{\n };\n \n pub trait HasAttrs {\n-    fn attrs(self, db: &dyn HirDatabase) -> Attrs;\n+    fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner;\n     fn docs(self, db: &dyn HirDatabase) -> Option<Documentation>;\n     fn resolve_doc_path(\n         self,\n@@ -36,7 +36,7 @@ pub enum Namespace {\n macro_rules! impl_has_attrs {\n     ($(($def:ident, $def_id:ident),)*) => {$(\n         impl HasAttrs for $def {\n-            fn attrs(self, db: &dyn HirDatabase) -> Attrs {\n+            fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner {\n                 let def = AttrDefId::$def_id(self.into());\n                 db.attrs(def)\n             }\n@@ -70,7 +70,7 @@ impl_has_attrs![\n macro_rules! impl_has_attrs_enum {\n     ($($variant:ident),* for $enum:ident) => {$(\n         impl HasAttrs for $variant {\n-            fn attrs(self, db: &dyn HirDatabase) -> Attrs {\n+            fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner {\n                 $enum::$variant(self).attrs(db)\n             }\n             fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {"}, {"sha": "300087f1f9d9b779d3ec59bd182a84149f89eec9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -89,7 +89,7 @@ pub use crate::{\n pub use {\n     hir_def::{\n         adt::StructKind,\n-        attr::{Attr, Attrs, Documentation},\n+        attr::{Attr, Attrs, AttrsWithOwner, Documentation},\n         body::scope::ExprScopes,\n         find_path::PrefixKind,\n         import_map,"}, {"sha": "2c10f46d8a1b7ed238cfd41b742fca08a971fcfb", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 189, "deletions": 123, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     item_tree::{ItemTreeId, ItemTreeNode},\n     nameres::ModuleSource,\n     path::{ModPath, PathKind},\n-    src::HasChildSource,\n+    src::{HasChildSource, HasSource},\n     AdtId, AttrDefId, EnumId, GenericParamId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup,\n     VariantId,\n };\n@@ -51,6 +51,12 @@ pub(crate) struct RawAttrs {\n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct Attrs(RawAttrs);\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct AttrsWithOwner {\n+    attrs: Attrs,\n+    owner: AttrDefId,\n+}\n+\n impl ops::Deref for RawAttrs {\n     type Target = [Attr];\n \n@@ -73,6 +79,14 @@ impl ops::Deref for Attrs {\n     }\n }\n \n+impl ops::Deref for AttrsWithOwner {\n+    type Target = Attrs;\n+\n+    fn deref(&self) -> &Attrs {\n+        &self.attrs\n+    }\n+}\n+\n impl RawAttrs {\n     pub(crate) const EMPTY: Self = Self { entries: None };\n \n@@ -169,78 +183,6 @@ impl RawAttrs {\n impl Attrs {\n     pub const EMPTY: Self = Self(RawAttrs::EMPTY);\n \n-    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n-        let raw_attrs = match def {\n-            AttrDefId::ModuleId(module) => {\n-                let def_map = module.def_map(db);\n-                let mod_data = &def_map[module.local_id];\n-                match mod_data.declaration_source(db) {\n-                    Some(it) => {\n-                        let raw_attrs = RawAttrs::from_attrs_owner(\n-                            db,\n-                            it.as_ref().map(|it| it as &dyn ast::AttrsOwner),\n-                        );\n-                        match mod_data.definition_source(db) {\n-                            InFile { file_id, value: ModuleSource::SourceFile(file) } => raw_attrs\n-                                .merge(RawAttrs::from_attrs_owner(db, InFile::new(file_id, &file))),\n-                            _ => raw_attrs,\n-                        }\n-                    }\n-                    None => RawAttrs::from_attrs_owner(\n-                        db,\n-                        mod_data.definition_source(db).as_ref().map(|src| match src {\n-                            ModuleSource::SourceFile(file) => file as &dyn ast::AttrsOwner,\n-                            ModuleSource::Module(module) => module as &dyn ast::AttrsOwner,\n-                            ModuleSource::BlockExpr(block) => block as &dyn ast::AttrsOwner,\n-                        }),\n-                    ),\n-                }\n-            }\n-            AttrDefId::FieldId(it) => {\n-                return db.fields_attrs(it.parent)[it.local_id].clone();\n-            }\n-            AttrDefId::EnumVariantId(it) => {\n-                return db.variants_attrs(it.parent)[it.local_id].clone();\n-            }\n-            AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            },\n-            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::MacroDefId(it) => it\n-                .ast_id()\n-                .left()\n-                .map_or_else(Default::default, |ast_id| attrs_from_ast(ast_id, db)),\n-            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::GenericParamId(it) => match it {\n-                GenericParamId::TypeParamId(it) => {\n-                    let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(\n-                        db,\n-                        src.with_value(\n-                            src.value[it.local_id].as_ref().either(|it| it as _, |it| it as _),\n-                        ),\n-                    )\n-                }\n-                GenericParamId::LifetimeParamId(it) => {\n-                    let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n-                }\n-                GenericParamId::ConstParamId(it) => {\n-                    let src = it.parent.child_source(db);\n-                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n-                }\n-            },\n-        };\n-\n-        raw_attrs.filter(db, def.krate(db))\n-    }\n-\n     pub(crate) fn variants_attrs_query(\n         db: &dyn DefDatabase,\n         e: EnumId,\n@@ -281,56 +223,6 @@ impl Attrs {\n         Arc::new(res)\n     }\n \n-    /// Constructs a map that maps the lowered `Attr`s in this `Attrs` back to its original syntax nodes.\n-    ///\n-    /// `owner` must be the original owner of the attributes.\n-    // FIXME: figure out a better api that doesnt require the for_module hack\n-    pub fn source_map(&self, owner: InFile<&dyn ast::AttrsOwner>) -> AttrSourceMap {\n-        // FIXME: This doesn't work correctly for modules, as the attributes there can have up to\n-        // two different owners\n-        AttrSourceMap {\n-            attrs: collect_attrs(owner.value)\n-                .map(|attr| InFile::new(owner.file_id, attr))\n-                .collect(),\n-        }\n-    }\n-\n-    pub fn source_map_for_module(\n-        &self,\n-        db: &dyn DefDatabase,\n-        module: crate::ModuleId,\n-    ) -> AttrSourceMap {\n-        let def_map = module.def_map(db);\n-        let mod_data = &def_map[module.local_id];\n-        let attrs = match mod_data.declaration_source(db) {\n-            Some(it) => {\n-                let mut attrs: Vec<_> = collect_attrs(&it.value as &dyn ast::AttrsOwner)\n-                    .map(|attr| InFile::new(it.file_id, attr))\n-                    .collect();\n-                if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n-                    mod_data.definition_source(db)\n-                {\n-                    attrs.extend(\n-                        collect_attrs(&file as &dyn ast::AttrsOwner)\n-                            .map(|attr| InFile::new(file_id, attr)),\n-                    )\n-                }\n-                attrs\n-            }\n-            None => {\n-                let InFile { file_id, value } = mod_data.definition_source(db);\n-                match &value {\n-                    ModuleSource::SourceFile(file) => collect_attrs(file as &dyn ast::AttrsOwner),\n-                    ModuleSource::Module(module) => collect_attrs(module as &dyn ast::AttrsOwner),\n-                    ModuleSource::BlockExpr(block) => collect_attrs(block as &dyn ast::AttrsOwner),\n-                }\n-                .map(|attr| InFile::new(file_id, attr))\n-                .collect()\n-            }\n-        };\n-        AttrSourceMap { attrs }\n-    }\n-\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n@@ -387,6 +279,180 @@ impl Attrs {\n     }\n }\n \n+impl AttrsWithOwner {\n+    pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Self {\n+        // FIXME: this should use `Trace` to avoid duplication in `source_map` below\n+        let raw_attrs = match def {\n+            AttrDefId::ModuleId(module) => {\n+                let def_map = module.def_map(db);\n+                let mod_data = &def_map[module.local_id];\n+                match mod_data.declaration_source(db) {\n+                    Some(it) => {\n+                        let raw_attrs = RawAttrs::from_attrs_owner(\n+                            db,\n+                            it.as_ref().map(|it| it as &dyn ast::AttrsOwner),\n+                        );\n+                        match mod_data.definition_source(db) {\n+                            InFile { file_id, value: ModuleSource::SourceFile(file) } => raw_attrs\n+                                .merge(RawAttrs::from_attrs_owner(db, InFile::new(file_id, &file))),\n+                            _ => raw_attrs,\n+                        }\n+                    }\n+                    None => RawAttrs::from_attrs_owner(\n+                        db,\n+                        mod_data.definition_source(db).as_ref().map(|src| match src {\n+                            ModuleSource::SourceFile(file) => file as &dyn ast::AttrsOwner,\n+                            ModuleSource::Module(module) => module as &dyn ast::AttrsOwner,\n+                            ModuleSource::BlockExpr(block) => block as &dyn ast::AttrsOwner,\n+                        }),\n+                    ),\n+                }\n+            }\n+            AttrDefId::FieldId(it) => {\n+                return Self { attrs: db.fields_attrs(it.parent)[it.local_id].clone(), owner: def };\n+            }\n+            AttrDefId::EnumVariantId(it) => {\n+                return Self {\n+                    attrs: db.variants_attrs(it.parent)[it.local_id].clone(),\n+                    owner: def,\n+                };\n+            }\n+            AttrDefId::AdtId(it) => match it {\n+                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            },\n+            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::MacroDefId(it) => it\n+                .ast_id()\n+                .left()\n+                .map_or_else(Default::default, |ast_id| attrs_from_ast(ast_id, db)),\n+            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::GenericParamId(it) => match it {\n+                GenericParamId::TypeParamId(it) => {\n+                    let src = it.parent.child_source(db);\n+                    RawAttrs::from_attrs_owner(\n+                        db,\n+                        src.with_value(\n+                            src.value[it.local_id].as_ref().either(|it| it as _, |it| it as _),\n+                        ),\n+                    )\n+                }\n+                GenericParamId::LifetimeParamId(it) => {\n+                    let src = it.parent.child_source(db);\n+                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n+                }\n+                GenericParamId::ConstParamId(it) => {\n+                    let src = it.parent.child_source(db);\n+                    RawAttrs::from_attrs_owner(db, src.with_value(&src.value[it.local_id]))\n+                }\n+            },\n+        };\n+\n+        let attrs = raw_attrs.filter(db, def.krate(db));\n+        Self { attrs, owner: def }\n+    }\n+\n+    pub fn source_map(&self, db: &dyn DefDatabase) -> AttrSourceMap {\n+        let owner = match self.owner {\n+            AttrDefId::ModuleId(module) => {\n+                // Modules can have 2 attribute owners (the `mod x;` item, and the module file itself).\n+\n+                let def_map = module.def_map(db);\n+                let mod_data = &def_map[module.local_id];\n+                let attrs = match mod_data.declaration_source(db) {\n+                    Some(it) => {\n+                        let mut attrs: Vec<_> = collect_attrs(&it.value as &dyn ast::AttrsOwner)\n+                            .map(|attr| InFile::new(it.file_id, attr))\n+                            .collect();\n+                        if let InFile { file_id, value: ModuleSource::SourceFile(file) } =\n+                            mod_data.definition_source(db)\n+                        {\n+                            attrs.extend(\n+                                collect_attrs(&file as &dyn ast::AttrsOwner)\n+                                    .map(|attr| InFile::new(file_id, attr)),\n+                            )\n+                        }\n+                        attrs\n+                    }\n+                    None => {\n+                        let InFile { file_id, value } = mod_data.definition_source(db);\n+                        match &value {\n+                            ModuleSource::SourceFile(file) => {\n+                                collect_attrs(file as &dyn ast::AttrsOwner)\n+                            }\n+                            ModuleSource::Module(module) => {\n+                                collect_attrs(module as &dyn ast::AttrsOwner)\n+                            }\n+                            ModuleSource::BlockExpr(block) => {\n+                                collect_attrs(block as &dyn ast::AttrsOwner)\n+                            }\n+                        }\n+                        .map(|attr| InFile::new(file_id, attr))\n+                        .collect()\n+                    }\n+                };\n+                return AttrSourceMap { attrs };\n+            }\n+            AttrDefId::FieldId(id) => {\n+                id.parent.child_source(db).map(|source| match &source[id.local_id] {\n+                    Either::Left(field) => ast::AttrsOwnerNode::new(field.clone()),\n+                    Either::Right(field) => ast::AttrsOwnerNode::new(field.clone()),\n+                })\n+            }\n+            AttrDefId::AdtId(adt) => match adt {\n+                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            },\n+            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::EnumVariantId(id) => id\n+                .parent\n+                .child_source(db)\n+                .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::MacroDefId(id) => match id.ast_id() {\n+                Either::Left(it) => {\n+                    it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast())))\n+                }\n+                Either::Right(it) => {\n+                    it.with_value(ast::AttrsOwnerNode::new(it.to_node(db.upcast())))\n+                }\n+            },\n+            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AttrsOwnerNode::new),\n+            AttrDefId::GenericParamId(id) => match id {\n+                GenericParamId::TypeParamId(id) => {\n+                    id.parent.child_source(db).map(|source| match &source[id.local_id] {\n+                        Either::Left(id) => ast::AttrsOwnerNode::new(id.clone()),\n+                        Either::Right(id) => ast::AttrsOwnerNode::new(id.clone()),\n+                    })\n+                }\n+                GenericParamId::LifetimeParamId(id) => id\n+                    .parent\n+                    .child_source(db)\n+                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+                GenericParamId::ConstParamId(id) => id\n+                    .parent\n+                    .child_source(db)\n+                    .map(|source| ast::AttrsOwnerNode::new(source[id.local_id].clone())),\n+            },\n+        };\n+\n+        AttrSourceMap {\n+            attrs: collect_attrs(&owner.value)\n+                .map(|attr| InFile::new(owner.file_id, attr))\n+                .collect(),\n+        }\n+    }\n+}\n+\n fn inner_attributes(\n     syntax: &SyntaxNode,\n ) -> Option<(impl Iterator<Item = ast::Attr>, impl Iterator<Item = ast::Comment>)> {"}, {"sha": "53df85089ae0fe8b9f14a8f958489816b70b22e7", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -8,7 +8,7 @@ use syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n-    attr::Attrs,\n+    attr::{Attrs, AttrsWithOwner},\n     body::{scope::ExprScopes, Body, BodySourceMap},\n     data::{ConstData, FunctionData, ImplData, StaticData, TraitData, TypeAliasData},\n     generics::GenericParams,\n@@ -120,8 +120,8 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     #[salsa::invoke(Attrs::fields_attrs_query)]\n     fn fields_attrs(&self, def: VariantId) -> Arc<ArenaMap<LocalFieldId, Attrs>>;\n \n-    #[salsa::invoke(Attrs::attrs_query)]\n-    fn attrs(&self, def: AttrDefId) -> Attrs;\n+    #[salsa::invoke(AttrsWithOwner::attrs_query)]\n+    fn attrs(&self, def: AttrDefId) -> AttrsWithOwner;\n \n     #[salsa::invoke(LangItems::crate_lang_items_query)]\n     fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;"}, {"sha": "00493a6b5754f2ad438cdae5644d68206914ed6c", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 19, "deletions": 54, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -6,7 +6,7 @@ use either::Either;\n use hir::{HasAttrs, InFile, Semantics};\n use ide_db::{call_info::ActiveParameter, defs::Definition, SymbolKind};\n use syntax::{\n-    ast::{self, AstNode, AttrsOwner, DocCommentsOwner},\n+    ast::{self, AstNode},\n     match_ast, AstToken, NodeOrToken, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n \n@@ -89,57 +89,27 @@ const RUSTDOC_FENCE_TOKENS: &[&'static str] = &[\n     \"edition2021\",\n ];\n \n-// Basically an owned dyn AttrsOwner without extra Boxing\n-struct AttrsOwnerNode {\n-    node: SyntaxNode,\n-}\n-\n-impl AttrsOwnerNode {\n-    fn new<N: DocCommentsOwner>(node: N) -> Self {\n-        AttrsOwnerNode { node: node.syntax().clone() }\n-    }\n-}\n-\n-impl AttrsOwner for AttrsOwnerNode {}\n-impl AstNode for AttrsOwnerNode {\n-    fn can_cast(_: syntax::SyntaxKind) -> bool\n-    where\n-        Self: Sized,\n-    {\n-        false\n-    }\n-    fn cast(_: SyntaxNode) -> Option<Self>\n-    where\n-        Self: Sized,\n-    {\n-        None\n-    }\n-    fn syntax(&self) -> &SyntaxNode {\n-        &self.node\n-    }\n-}\n-\n fn doc_attributes<'node>(\n     sema: &Semantics<RootDatabase>,\n     node: &'node SyntaxNode,\n-) -> Option<(AttrsOwnerNode, hir::Attrs, Definition)> {\n+) -> Option<(hir::AttrsWithOwner, Definition)> {\n     match_ast! {\n         match node {\n-            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Module(it)      => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-            ast::Fn(it)          => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-            ast::Struct(it)      => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-            ast::Union(it)       => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-            ast::Enum(it)        => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-            ast::Variant(it)     => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-            ast::Trait(it)       => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-            ast::Static(it)      => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-            ast::Const(it)       => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n-            ast::Impl(it)        => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::SelfType(def))),\n-            ast::RecordField(it) => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::Field(def))),\n-            ast::TupleField(it)  => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::Field(def))),\n-            ast::MacroRules(it)  => sema.to_def(&it).map(|def| (AttrsOwnerNode::new(it), def.attrs(sema.db), Definition::Macro(def))),\n+            ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Module(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+            ast::Fn(it)          => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+            ast::Struct(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+            ast::Union(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+            ast::Enum(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+            ast::Variant(it)     => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+            ast::Trait(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+            ast::Static(it)      => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+            ast::Const(it)       => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+            ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+            ast::Impl(it)        => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::SelfType(def))),\n+            ast::RecordField(it) => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Field(def))),\n+            ast::MacroRules(it)  => sema.to_def(&it).map(|def| (def.attrs(sema.db), Definition::Macro(def))),\n             // ast::MacroDef(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n             // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n             _ => return None\n@@ -153,20 +123,15 @@ pub(super) fn doc_comment(\n     sema: &Semantics<RootDatabase>,\n     node: InFile<&SyntaxNode>,\n ) {\n-    let (owner, attributes, def) = match doc_attributes(sema, node.value) {\n+    let (attributes, def) = match doc_attributes(sema, node.value) {\n         Some(it) => it,\n         None => return,\n     };\n \n     let mut inj = Injector::default();\n     inj.add_unmapped(\"fn doctest() {\\n\");\n \n-    let attrs_source_map = match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n-            attributes.source_map_for_module(sema.db, module.into())\n-        }\n-        _ => attributes.source_map(node.with_value(&owner)),\n-    };\n+    let attrs_source_map = attributes.source_map(sema.db);\n \n     let mut is_codeblock = false;\n     let mut is_doctest = false;"}, {"sha": "7f472d4dbed653ef4d5f30ecf75586a2a1df12c6", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -20,8 +20,8 @@ pub use self::{\n     expr_ext::{ArrayExprKind, BinOp, Effect, ElseBranch, LiteralKind, PrefixOp, RangeOp},\n     generated::{nodes::*, tokens::*},\n     node_ext::{\n-        AttrKind, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind, SelfParamKind,\n-        SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n+        AttrKind, AttrsOwnerNode, FieldKind, Macro, NameLike, NameOrNameRef, PathSegmentKind,\n+        SelfParamKind, SlicePatComponents, StructKind, TypeBoundKind, VisibilityKind,\n     },\n     token_ext::*,\n     traits::*,"}, {"sha": "01f580a4094185bbc1dbb8d1ded1f1f67607c9fc", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b16af590dd3d241bec07f69f4d4dadae9a4b523/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=8b16af590dd3d241bec07f69f4d4dadae9a4b523", "patch": "@@ -90,6 +90,36 @@ impl NameOwner for Macro {\n \n impl AttrsOwner for Macro {}\n \n+/// Basically an owned `dyn AttrsOwner` without extra boxing.\n+pub struct AttrsOwnerNode {\n+    node: SyntaxNode,\n+}\n+\n+impl AttrsOwnerNode {\n+    pub fn new<N: AttrsOwner>(node: N) -> Self {\n+        AttrsOwnerNode { node: node.syntax().clone() }\n+    }\n+}\n+\n+impl AttrsOwner for AttrsOwnerNode {}\n+impl AstNode for AttrsOwnerNode {\n+    fn can_cast(_: SyntaxKind) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        false\n+    }\n+    fn cast(_: SyntaxNode) -> Option<Self>\n+    where\n+        Self: Sized,\n+    {\n+        None\n+    }\n+    fn syntax(&self) -> &SyntaxNode {\n+        &self.node\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,"}]}