{"sha": "cb3324851c3f8279c7569375bb2efeb880bf67bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMzMyNDg1MWMzZjgyNzljNzU2OTM3NWJiMmVmZWI4ODBiZjY3YmI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-23T18:07:28Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-23T18:36:26Z"}, "message": "use `usize` for self instead of `ty`", "tree": {"sha": "e2471ed45f586c90552773cf711e0afa9b4950b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2471ed45f586c90552773cf711e0afa9b4950b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb3324851c3f8279c7569375bb2efeb880bf67bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb3324851c3f8279c7569375bb2efeb880bf67bb", "html_url": "https://github.com/rust-lang/rust/commit/cb3324851c3f8279c7569375bb2efeb880bf67bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb3324851c3f8279c7569375bb2efeb880bf67bb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3860eabbb64d2b53b1a05bd4dba96ac7751441f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3860eabbb64d2b53b1a05bd4dba96ac7751441f3", "html_url": "https://github.com/rust-lang/rust/commit/3860eabbb64d2b53b1a05bd4dba96ac7751441f3"}], "stats": {"total": 55, "additions": 24, "deletions": 31}, "files": [{"sha": "3ecb5e6d296e371c972fa8f0cd9934155d7262e0", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cb3324851c3f8279c7569375bb2efeb880bf67bb/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb3324851c3f8279c7569375bb2efeb880bf67bb/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=cb3324851c3f8279c7569375bb2efeb880bf67bb", "patch": "@@ -12,7 +12,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n \n use super::explicit::ExplicitPredicatesMap;\n@@ -191,43 +191,35 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                     substs,\n                     required_predicates,\n                     explicit_map,\n-                    false,\n+                    IgnoreSelfTy(false),\n                 );\n             }\n \n             ty::Dynamic(obj, ..) => {\n                 // This corresponds to `dyn Trait<..>`. In this case, we should\n                 // use the explicit predicates as well.\n \n-                // We are passing type `ty` as a placeholder value with the function\n-                // `with_self_ty`, since there is no concrete type `Self` for a\n-                // `dyn Trait` at this stage. Therefore when checking explicit\n-                // predicates in `check_explicit_predicates` we need to ignore\n-                // checking the explicit_map for Self type.\n                 debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n                 if let Some(ex_trait_ref) = obj.principal() {\n-                    // The method `has_escaping_regions` checks if\n-                    // there are any late-bound regions, which is\n-                    // the lifetime `'r`. It is safe to ignore\n-                    // these since `'r` is not in scope for `Foo`.\n-                    //\n-                    // ```\n-                    // struct Foo {\n-                    //   bar: for<'r> Fn(usize, &'r FnMut())\n-                    // }\n-                    // ```\n-                    if !ty.has_escaping_regions() {\n-                        check_explicit_predicates(\n-                            tcx,\n-                            &ex_trait_ref.skip_binder().def_id,\n-                            ex_trait_ref.with_self_ty(tcx, ty).skip_binder().substs,\n-                            required_predicates,\n-                            explicit_map,\n-                            true,\n-                        );\n-                    }\n+                    // Here, we are passing the type `usize` as a\n+                    // placeholder value with the function\n+                    // `with_self_ty`, since there is no concrete type\n+                    // `Self` for a `dyn Trait` at this\n+                    // stage. Therefore when checking explicit\n+                    // predicates in `check_explicit_predicates` we\n+                    // need to ignore checking the explicit_map for\n+                    // Self type.\n+                    let substs = ex_trait_ref.with_self_ty(tcx, tcx.types.usize).skip_binder().substs;\n+                    check_explicit_predicates(\n+                        tcx,\n+                        &ex_trait_ref.skip_binder().def_id,\n+                        substs,\n+                        required_predicates,\n+                        explicit_map,\n+                        IgnoreSelfTy(true),\n+                    );\n                 }\n             }\n \n@@ -241,7 +233,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                     obj.substs,\n                     required_predicates,\n                     explicit_map,\n-                    false,\n+                    IgnoreSelfTy(false),\n                 );\n             }\n \n@@ -250,6 +242,8 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     }\n }\n \n+pub struct IgnoreSelfTy(bool);\n+\n /// We also have to check the explicit predicates\n /// declared on the type.\n ///\n@@ -271,7 +265,7 @@ pub fn check_explicit_predicates<'tcx>(\n     substs: &[Kind<'tcx>],\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n-    ignore_self_ty: bool,\n+    ignore_self_ty: IgnoreSelfTy,\n ) {\n     debug!(\"def_id = {:?}\", &def_id);\n     debug!(\"substs = {:?}\", &substs);\n@@ -309,7 +303,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // to apply the substs, and not filter this predicate, we might then falsely\n         // conclude that e.g. `X: 'x` was a reasonable inferred requirement.\n         if let UnpackedKind::Type(ty) = outlives_predicate.0.unpack() {\n-            if ty.is_self() && ignore_self_ty {\n+            if ty.is_self() && ignore_self_ty.0 {\n                 debug!(\"skipping self ty = {:?}\", &ty);\n                 continue;\n             }\n@@ -319,5 +313,4 @@ pub fn check_explicit_predicates<'tcx>(\n         debug!(\"predicate = {:?}\", &predicate);\n         insert_outlives_predicate(tcx, predicate.0.into(), predicate.1, required_predicates);\n     }\n-    // }\n }"}]}