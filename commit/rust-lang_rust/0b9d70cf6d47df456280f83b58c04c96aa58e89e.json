{"sha": "0b9d70cf6d47df456280f83b58c04c96aa58e89e", "node_id": "C_kwDOAAsO6NoAKDBiOWQ3MGNmNmQ0N2RmNDU2MjgwZjgzYjU4YzA0Yzk2YWE1OGU4OWU", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2022-01-26T03:39:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2022-02-23T06:08:06Z"}, "message": "rustc_errors: take `self` by value in `DiagnosticBuilder::cancel`.", "tree": {"sha": "ade43c09a3ffb7bad3aab2f031dec6ebc4e292a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ade43c09a3ffb7bad3aab2f031dec6ebc4e292a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b9d70cf6d47df456280f83b58c04c96aa58e89e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9d70cf6d47df456280f83b58c04c96aa58e89e", "html_url": "https://github.com/rust-lang/rust/commit/0b9d70cf6d47df456280f83b58c04c96aa58e89e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b9d70cf6d47df456280f83b58c04c96aa58e89e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8562d6b7523b498f731f78dd740d0bc612983ffc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8562d6b7523b498f731f78dd740d0bc612983ffc", "html_url": "https://github.com/rust-lang/rust/commit/8562d6b7523b498f731f78dd740d0bc612983ffc"}], "stats": {"total": 322, "additions": 176, "deletions": 146}, "files": [{"sha": "04f446ebcf104fd5db8a157ca3c1278cae377b1b", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -379,7 +379,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::take(&mut mbcx.reservation_warnings);\n     for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n+        let initial_diag = mbcx.report_conflicting_borrow(location, (place, span), bk, &borrow);\n \n         let scope = mbcx.body.source_info(location).scope;\n         let lint_root = match &mbcx.body.source_scopes[scope].local_data {\n@@ -2329,7 +2329,7 @@ mod error {\n             move_out_indices: Vec<MoveOutIndex>,\n             place_and_err: (PlaceRef<'tcx>, DiagnosticBuilder<'tcx>),\n         ) -> bool {\n-            if let Some((_, mut diag)) =\n+            if let Some((_, diag)) =\n                 self.errors.buffered_move_errors.insert(move_out_indices, place_and_err)\n             {\n                 // Cancel the old diagnostic so we don't ICE"}, {"sha": "7d7ab1ed4e5e6e26752ef3cb0f50abb10fd8b0e3", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -72,8 +72,8 @@ fn annotation_type_for_level(level: Level) -> AnnotationType {\n         Level::Warning => AnnotationType::Warning,\n         Level::Note => AnnotationType::Note,\n         Level::Help => AnnotationType::Help,\n-        // FIXME(#59346): Not sure how to map these two levels\n-        Level::Cancelled | Level::FailureNote => AnnotationType::Error,\n+        // FIXME(#59346): Not sure how to map this level\n+        Level::FailureNote => AnnotationType::Error,\n         Level::Allow => panic!(\"Should not call with Allow\"),\n     }\n }"}, {"sha": "6d6ada86428db4fab448da52c7040f7e0483f6ae", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -133,7 +133,7 @@ impl Diagnostic {\n             | Level::Error { .. }\n             | Level::FailureNote => true,\n \n-            Level::Warning | Level::Note | Level::Help | Level::Cancelled | Level::Allow => false,\n+            Level::Warning | Level::Note | Level::Help | Level::Allow => false,\n         }\n     }\n \n@@ -151,17 +151,6 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// canceled or it will panic when dropped).\n-    pub fn cancel(&mut self) {\n-        self.level = Level::Cancelled;\n-    }\n-\n-    /// Check if this diagnostic [was cancelled][Self::cancel()].\n-    pub fn cancelled(&self) -> bool {\n-        self.level == Level::Cancelled\n-    }\n-\n     /// Delay emission of this diagnostic as a bug.\n     ///\n     /// This can be useful in contexts where an error indicates a bug but\n@@ -174,17 +163,12 @@ impl Diagnostic {\n     /// locally in whichever way makes the most sense.\n     #[track_caller]\n     pub fn downgrade_to_delayed_bug(&mut self) -> &mut Self {\n-        // FIXME(eddyb) this check is only necessary because cancellation exists,\n-        // but hopefully that can be removed in the future, if enough callers\n-        // of `.cancel()` can take `DiagnosticBuilder`, and by-value.\n-        if !self.cancelled() {\n-            assert!(\n-                self.is_error(),\n-                \"downgrade_to_delayed_bug: cannot downgrade {:?} to DelayedBug: not an error\",\n-                self.level\n-            );\n-            self.level = Level::DelayedBug;\n-        }\n+        assert!(\n+            self.is_error(),\n+            \"downgrade_to_delayed_bug: cannot downgrade {:?} to DelayedBug: not an error\",\n+            self.level\n+        );\n+        self.level = Level::DelayedBug;\n \n         self\n     }"}, {"sha": "7978e1cc162b86e0189819057e9b5c1ea5b7c857", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 89, "deletions": 23, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -16,7 +16,7 @@ use tracing::debug;\n #[must_use]\n #[derive(Clone)]\n pub struct DiagnosticBuilder<'a> {\n-    handler: &'a Handler,\n+    state: DiagnosticBuilderState<'a>,\n \n     /// `Diagnostic` is a large type, and `DiagnosticBuilder` is often used as a\n     /// return value, especially within the frequently-used `PResult` type.\n@@ -25,6 +25,34 @@ pub struct DiagnosticBuilder<'a> {\n     diagnostic: Box<Diagnostic>,\n }\n \n+#[derive(Clone)]\n+enum DiagnosticBuilderState<'a> {\n+    /// Initial state of a `DiagnosticBuilder`, before `.emit()` or `.cancel()`.\n+    ///\n+    /// The `Diagnostic` will be emitted through this `Handler`.\n+    Emittable(&'a Handler),\n+\n+    /// State of a `DiagnosticBuilder`, after `.emit()` or *during* `.cancel()`.\n+    ///\n+    /// The `Diagnostic` will be ignored when calling `.emit()`, and it can be\n+    /// assumed that `.emit()` was previously called, to end up in this state.\n+    ///\n+    /// While this is also used by `.cancel()`, this state is only observed by\n+    /// the `Drop` `impl` of `DiagnosticBuilder`, as `.cancel()` takes `self`\n+    /// by-value specifically to prevent any attempts to `.emit()`.\n+    ///\n+    // FIXME(eddyb) currently this doesn't prevent extending the `Diagnostic`,\n+    // despite that being potentially lossy, if important information is added\n+    // *after* the original `.emit()` call.\n+    AlreadyEmittedOrDuringCancellation,\n+}\n+\n+// `DiagnosticBuilderState` should be pointer-sized.\n+rustc_data_structures::static_assert_size!(\n+    DiagnosticBuilderState<'_>,\n+    std::mem::size_of::<&Handler>()\n+);\n+\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to\n@@ -78,8 +106,18 @@ impl<'a> DerefMut for DiagnosticBuilder<'a> {\n impl<'a> DiagnosticBuilder<'a> {\n     /// Emit the diagnostic.\n     pub fn emit(&mut self) {\n-        self.handler.emit_diagnostic(&self);\n-        self.cancel();\n+        match self.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                handler.emit_diagnostic(&self);\n+                self.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {\n+                // FIXME(eddyb) rely on this to return a \"proof\" that an error\n+                // was/will be emitted, despite doing no emission *here and now*.\n+            }\n+        }\n     }\n \n     /// Emit the diagnostic unless `delay` is true,\n@@ -93,6 +131,17 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.emit();\n     }\n \n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    ///\n+    /// This method takes `self` by-value to disallow calling `.emit()` on it,\n+    /// which may be expected to *guarantee* the emission of an error, either\n+    /// at the time of the call, or through a prior `.emit()` call.\n+    pub fn cancel(mut self) {\n+        self.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+        drop(self);\n+    }\n+\n     /// Stashes diagnostic for possible later improvement in a different,\n     /// later stage of the compiler. The diagnostic can be accessed with\n     /// the provided `span` and `key` through [`Handler::steal_diagnostic()`].\n@@ -105,22 +154,29 @@ impl<'a> DiagnosticBuilder<'a> {\n     }\n \n     /// Converts the builder to a `Diagnostic` for later emission,\n-    /// unless handler has disabled such buffering.\n+    /// unless handler has disabled such buffering, or `.emit()` was called.\n     pub fn into_diagnostic(mut self) -> Option<(Diagnostic, &'a Handler)> {\n-        if self.handler.flags.dont_buffer_diagnostics\n-            || self.handler.flags.treat_err_as_bug.is_some()\n-        {\n+        let handler = match self.state {\n+            // No `.emit()` calls, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => handler,\n+            // `.emit()` was previously called, nothing we can do.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {\n+                return None;\n+            }\n+        };\n+\n+        if handler.flags.dont_buffer_diagnostics || handler.flags.treat_err_as_bug.is_some() {\n             self.emit();\n             return None;\n         }\n \n-        let handler = self.handler;\n-\n-        // We must use `Level::Cancelled` for `dummy` to avoid an ICE about an\n-        // unused diagnostic.\n-        let dummy = Diagnostic::new(Level::Cancelled, \"\");\n+        // Take the `Diagnostic` by replacing it with a dummy.\n+        let dummy = Diagnostic::new(Level::Allow, \"\");\n         let diagnostic = std::mem::replace(&mut *self.diagnostic, dummy);\n \n+        // Disable the ICE on `Drop`.\n+        self.cancel();\n+\n         // Logging here is useful to help track down where in logs an error was\n         // actually emitted.\n         debug!(\"buffer: diagnostic={:?}\", diagnostic);\n@@ -314,7 +370,10 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// diagnostic.\n     crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n         debug!(\"Created new diagnostic\");\n-        DiagnosticBuilder { handler, diagnostic: Box::new(diagnostic) }\n+        DiagnosticBuilder {\n+            state: DiagnosticBuilderState::Emittable(handler),\n+            diagnostic: Box::new(diagnostic),\n+        }\n     }\n }\n \n@@ -324,19 +383,26 @@ impl<'a> Debug for DiagnosticBuilder<'a> {\n     }\n }\n \n-/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or canceled\n+/// Destructor bomb - a `DiagnosticBuilder` must be either emitted or cancelled\n /// or we emit a bug.\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n-        if !panicking() && !self.cancelled() {\n-            let mut db = DiagnosticBuilder::new(\n-                self.handler,\n-                Level::Bug,\n-                \"the following error was constructed but not emitted\",\n-            );\n-            db.emit();\n-            self.emit();\n-            panic!();\n+        match self.state {\n+            // No `.emit()` or `.cancel()` calls.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                if !panicking() {\n+                    let mut db = DiagnosticBuilder::new(\n+                        handler,\n+                        Level::Bug,\n+                        \"the following error was constructed but not emitted\",\n+                    );\n+                    db.emit();\n+                    handler.emit_diagnostic(&self);\n+                    panic!();\n+                }\n+            }\n+            // `.emit()` was previously called, or maybe we're during `.cancel()`.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n         }\n     }\n }"}, {"sha": "b92b1cac2e89ceb30ab19066ec3c87f3b716f2b8", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -911,10 +911,6 @@ impl HandlerInner {\n \n     // FIXME(eddyb) this should ideally take `diagnostic` by value.\n     fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n-        if diagnostic.cancelled() {\n-            return;\n-        }\n-\n         if diagnostic.level == Level::DelayedBug {\n             // FIXME(eddyb) this should check for `has_errors` and stop pushing\n             // once *any* errors were emitted (and truncate `delayed_span_bugs`\n@@ -1238,7 +1234,6 @@ pub enum Level {\n     Warning,\n     Note,\n     Help,\n-    Cancelled,\n     FailureNote,\n     Allow,\n }\n@@ -1266,7 +1261,7 @@ impl Level {\n                 spec.set_fg(Some(Color::Cyan)).set_intense(true);\n             }\n             FailureNote => {}\n-            Allow | Cancelled => unreachable!(),\n+            Allow => unreachable!(),\n         }\n         spec\n     }\n@@ -1279,7 +1274,6 @@ impl Level {\n             Note => \"note\",\n             Help => \"help\",\n             FailureNote => \"failure-note\",\n-            Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n             Allow => panic!(\"Shouldn't call on allowed error\"),\n         }\n     }"}, {"sha": "37e9f6adf0db8eaa7769eab6ac266e76f3809a59", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -95,7 +95,7 @@ fn emit_frag_parse_err(\n     match kind {\n         // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n         AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n-            Err(mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n             Ok(_) => {\n                 e.note(\n                     \"the macro call doesn't expand to an expression, but it can expand to a statement\","}, {"sha": "cbf28d48e14318c7647df1eea96bcbf0d9700cad", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -1598,7 +1598,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Some((expected, found)) => Some((expected, found)),\n                     None => {\n                         // Derived error. Cancel the emitter.\n-                        diag.cancel();\n+                        // NOTE(eddyb) this was `.cancel()`, but `diag`\n+                        // is borrowed, so we can't fully defuse it.\n+                        diag.downgrade_to_delayed_bug();\n                         return;\n                     }\n                 };"}, {"sha": "e518edcff02b996b779a78ddbb26c646157246fa", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -102,7 +102,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                 }\n \n                 match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n-                    Ok(mut parser) => match &mut parser.parse_meta_item() {\n+                    Ok(mut parser) => match parser.parse_meta_item() {\n                         Ok(meta_item) if parser.token == token::Eof => {\n                             if meta_item.path.segments.len() != 1 {\n                                 error!(\"argument key must be an identifier\");\n@@ -121,7 +121,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                         Ok(..) => {}\n                         Err(err) => err.cancel(),\n                     },\n-                    Err(errs) => errs.into_iter().for_each(|mut err| err.cancel()),\n+                    Err(errs) => drop(errs),\n                 }\n \n                 // If the user tried to use a key=\"value\" flag, but is missing the quotes, provide\n@@ -165,7 +165,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n             }\n \n             match maybe_new_parser_from_source_str(&sess, filename, s.to_string()) {\n-                Ok(mut parser) => match &mut parser.parse_meta_item() {\n+                Ok(mut parser) => match parser.parse_meta_item() {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n@@ -210,7 +210,7 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                     Ok(..) => {}\n                     Err(err) => err.cancel(),\n                 },\n-                Err(errs) => errs.into_iter().for_each(|mut err| err.cancel()),\n+                Err(errs) => drop(errs),\n             }\n \n             error!("}, {"sha": "379e47077ea18b85377618fbcfc6ab8b3b1879f7", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -165,7 +165,7 @@ impl<'a> Parser<'a> {\n         loop {\n             // skip any other attributes, we want the item\n             if snapshot.token.kind == token::Pound {\n-                if let Err(mut err) = snapshot.parse_attribute(InnerAttrPolicy::Permitted) {\n+                if let Err(err) = snapshot.parse_attribute(InnerAttrPolicy::Permitted) {\n                     err.cancel();\n                     return Some(replacement_span);\n                 }\n@@ -206,7 +206,7 @@ impl<'a> Parser<'a> {\n                 );\n                 return None;\n             }\n-            Err(mut item_err) => {\n+            Err(item_err) => {\n                 item_err.cancel();\n             }\n             Ok(None) => {}\n@@ -412,12 +412,12 @@ impl<'a> Parser<'a> {\n     fn parse_meta_item_inner(&mut self) -> PResult<'a, ast::NestedMetaItem> {\n         match self.parse_unsuffixed_lit() {\n             Ok(lit) => return Ok(ast::NestedMetaItem::Literal(lit)),\n-            Err(ref mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => return Ok(ast::NestedMetaItem::MetaItem(mi)),\n-            Err(ref mut err) => err.cancel(),\n+            Err(err) => err.cancel(),\n         }\n \n         let found = pprust::token_to_string(&self.token);"}, {"sha": "d56d3124a565280d81d35f73b4e4fe1c4fde5939", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -461,12 +461,12 @@ impl<'a> Parser<'a> {\n                     tail.could_be_bare_literal = true;\n                     Ok(tail)\n                 }\n-                (Err(mut err), Ok(tail)) => {\n+                (Err(err), Ok(tail)) => {\n                     // We have a block tail that contains a somehow valid type ascription expr.\n                     err.cancel();\n                     Ok(tail)\n                 }\n-                (Err(mut snapshot_err), Err(err)) => {\n+                (Err(snapshot_err), Err(err)) => {\n                     // We don't know what went wrong, emit the normal error.\n                     snapshot_err.cancel();\n                     self.consume_block(token::Brace, ConsumeClosingDelim::Yes);\n@@ -537,7 +537,7 @@ impl<'a> Parser<'a> {\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     pub(super) fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n-        if let Err(ref mut err) =\n+        if let Err(err) =\n             self.parse_seq_to_before_tokens(kets, SeqSep::none(), TokenExpectType::Expect, |p| {\n                 Ok(p.parse_token_tree())\n             })\n@@ -703,7 +703,7 @@ impl<'a> Parser<'a> {\n                         *self = snapshot;\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     // We couldn't parse generic parameters, unlikely to be a turbofish. Rely on\n                     // generic parse error instead.\n                     err.cancel();\n@@ -744,14 +744,14 @@ impl<'a> Parser<'a> {\n                                             self.mk_expr_err(expr.span.to(self.prev_token.span));\n                                         return Ok(());\n                                     }\n-                                    Err(mut err) => {\n+                                    Err(err) => {\n                                         *expr = self.mk_expr_err(expr.span);\n                                         err.cancel();\n                                     }\n                                 }\n                             }\n                         }\n-                        Err(mut err) => {\n+                        Err(err) => {\n                             err.cancel();\n                         }\n                         _ => {}\n@@ -821,7 +821,7 @@ impl<'a> Parser<'a> {\n                             enclose(r1.span, r2.span);\n                             true\n                         }\n-                        Err(mut expr_err) => {\n+                        Err(expr_err) => {\n                             expr_err.cancel();\n                             *self = snapshot;\n                             false\n@@ -838,7 +838,7 @@ impl<'a> Parser<'a> {\n                             enclose(l1.span, r1.span);\n                             true\n                         }\n-                        Err(mut expr_err) => {\n+                        Err(expr_err) => {\n                             expr_err.cancel();\n                             *self = snapshot;\n                             false\n@@ -938,7 +938,7 @@ impl<'a> Parser<'a> {\n                                 // `ExprKind::Err` placeholder.\n                                 mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n                             }\n-                            Err(mut expr_err) => {\n+                            Err(expr_err) => {\n                                 expr_err.cancel();\n                                 // Not entirely sure now, but we bubble the error up with the\n                                 // suggestion.\n@@ -1946,17 +1946,14 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n-    fn recover_const_param_decl(\n-        &mut self,\n-        ty_generics: Option<&Generics>,\n-    ) -> PResult<'a, Option<GenericArg>> {\n+    fn recover_const_param_decl(&mut self, ty_generics: Option<&Generics>) -> Option<GenericArg> {\n         let snapshot = self.clone();\n         let param = match self.parse_const_param(vec![]) {\n             Ok(param) => param,\n-            Err(mut err) => {\n+            Err(err) => {\n                 err.cancel();\n                 *self = snapshot;\n-                return Err(err);\n+                return None;\n             }\n         };\n         let mut err =\n@@ -1977,16 +1974,16 @@ impl<'a> Parser<'a> {\n         }\n         let value = self.mk_expr_err(param.span());\n         err.emit();\n-        return Ok(Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })));\n+        Some(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }))\n     }\n \n     pub fn recover_const_param_declaration(\n         &mut self,\n         ty_generics: Option<&Generics>,\n     ) -> PResult<'a, Option<GenericArg>> {\n         // We have to check for a few different cases.\n-        if let Ok(arg) = self.recover_const_param_decl(ty_generics) {\n-            return Ok(arg);\n+        if let Some(arg) = self.recover_const_param_decl(ty_generics) {\n+            return Ok(Some(arg));\n         }\n \n         // We haven't consumed `const` yet.\n@@ -2085,7 +2082,7 @@ impl<'a> Parser<'a> {\n                     return Ok(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }));\n                 }\n             }\n-            Err(mut err) => {\n+            Err(err) => {\n                 err.cancel();\n             }\n         }\n@@ -2139,7 +2136,7 @@ impl<'a> Parser<'a> {\n             Err(mut err) => {\n                 self.bump(); // Skip the `:`.\n                 match self.parse_pat_no_top_alt(expected) {\n-                    Err(mut inner_err) => {\n+                    Err(inner_err) => {\n                         // Carry on as if we had not done anything, callers will emit a\n                         // reasonable error.\n                         inner_err.cancel();\n@@ -2246,7 +2243,7 @@ impl<'a> Parser<'a> {\n         // suggestion-enhanced error here rather than choking on the comma later.\n         let comma_span = self.token.span;\n         self.bump();\n-        if let Err(mut err) = self.skip_pat_list() {\n+        if let Err(err) = self.skip_pat_list() {\n             // We didn't expect this to work anyway; we just wanted to advance to the\n             // end of the comma-sequence so we know the span to suggest parenthesizing.\n             err.cancel();"}, {"sha": "a66307bcbe04d9e23472799f443c6591e39d46f1", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -684,7 +684,7 @@ impl<'a> Parser<'a> {\n         let parser_snapshot_before_type = self.clone();\n         let cast_expr = match self.parse_as_cast_ty() {\n             Ok(rhs) => mk_expr(self, lhs, rhs),\n-            Err(mut type_err) => {\n+            Err(type_err) => {\n                 // Rewind to before attempting to parse the type with generics, to recover\n                 // from situations like `x as usize < y` in which we first tried to parse\n                 // `usize < y` as a type with generic arguments.\n@@ -717,7 +717,7 @@ impl<'a> Parser<'a> {\n                                     .emit();\n                                 return Ok(expr);\n                             }\n-                            Err(mut err) => {\n+                            Err(err) => {\n                                 err.cancel();\n                                 *self = snapshot;\n                             }\n@@ -773,7 +773,7 @@ impl<'a> Parser<'a> {\n \n                         expr\n                     }\n-                    Err(mut path_err) => {\n+                    Err(path_err) => {\n                         // Couldn't parse as a path, return original error and parser state.\n                         path_err.cancel();\n                         *self = parser_snapshot_after_type;\n@@ -1127,7 +1127,7 @@ impl<'a> Parser<'a> {\n         snapshot: Option<(Self, ExprKind)>,\n     ) -> Option<P<Expr>> {\n         match (seq.as_mut(), snapshot) {\n-            (Err(ref mut err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n+            (Err(err), Some((mut snapshot, ExprKind::Path(None, path)))) => {\n                 let name = pprust::path_to_string(&path);\n                 snapshot.bump(); // `(`\n                 match snapshot.parse_struct_fields(path, false, token::Paren) {\n@@ -1138,11 +1138,12 @@ impl<'a> Parser<'a> {\n                         let close_paren = self.prev_token.span;\n                         let span = lo.to(self.prev_token.span);\n                         if !fields.is_empty() {\n-                            err.cancel();\n-                            let mut err = self.struct_span_err(\n+                            let replacement_err = self.struct_span_err(\n                                 span,\n                                 \"invalid `struct` delimiters or `fn` call arguments\",\n                             );\n+                            mem::replace(err, replacement_err).cancel();\n+\n                             err.multipart_suggestion(\n                                 &format!(\"if `{}` is a struct, use braces as delimiters\", name),\n                                 vec![\n@@ -1878,7 +1879,7 @@ impl<'a> Parser<'a> {\n                 *self = snapshot;\n                 Some(self.mk_expr_err(arr.span))\n             }\n-            Err(mut e) => {\n+            Err(e) => {\n                 e.cancel();\n                 None\n             }\n@@ -2381,7 +2382,7 @@ impl<'a> Parser<'a> {\n                         return Some(err(self, stmts));\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                 }\n             }\n@@ -2398,7 +2399,7 @@ impl<'a> Parser<'a> {\n                 }\n                 // We couldn't parse either yet another statement missing it's\n                 // enclosing block nor the next arm's pattern or closing brace.\n-                Err(mut stmt_err) => {\n+                Err(stmt_err) => {\n                     stmt_err.cancel();\n                     *self = start_snapshot;\n                     break;"}, {"sha": "1b9eeab0298624efb5de6ce9d2e818715520ab92", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -130,7 +130,7 @@ impl<'a> Parser<'a> {\n                                 // FIXME - try to continue parsing other generics?\n                                 return Ok((None, TrailingToken::None));\n                             }\n-                            Err(mut err) => {\n+                            Err(err) => {\n                                 err.cancel();\n                                 // FIXME - maybe we should overwrite 'self' outside of `collect_tokens`?\n                                 *this = snapshot;"}, {"sha": "1fd8472f3806f2798b6676fd7ad301b0837f1e4e", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -1114,7 +1114,7 @@ impl<'a> Parser<'a> {\n         // Only try to recover if this is implementing a trait for a type\n         let mut impl_info = match self.parse_item_impl(attrs, defaultness) {\n             Ok(impl_info) => impl_info,\n-            Err(mut recovery_error) => {\n+            Err(recovery_error) => {\n                 // Recovery failed, raise the \"expected identifier\" error\n                 recovery_error.cancel();\n                 return Err(err);\n@@ -1476,7 +1476,9 @@ impl<'a> Parser<'a> {\n                             // after the comma\n                             self.eat(&token::Comma);\n                             // `check_trailing_angle_brackets` already emitted a nicer error\n-                            err.cancel();\n+                            // NOTE(eddyb) this was `.cancel()`, but `err`\n+                            // gets returned, so we can't fully defuse it.\n+                            err.downgrade_to_delayed_bug();\n                         }\n                     }\n                 }\n@@ -2073,7 +2075,7 @@ impl<'a> Parser<'a> {\n                         if let Ok(snippet) = self.span_to_snippet(sp) {\n                             let current_vis = match self.parse_visibility(FollowedByType::No) {\n                                 Ok(v) => v,\n-                                Err(mut d) => {\n+                                Err(d) => {\n                                     d.cancel();\n                                     return Err(err);\n                                 }\n@@ -2216,7 +2218,7 @@ impl<'a> Parser<'a> {\n                     // If this is a C-variadic argument and we hit an error, return the error.\n                     Err(err) if this.token == token::DotDotDot => return Err(err),\n                     // Recover from attempting to parse the argument as a type without pattern.\n-                    Err(mut err) => {\n+                    Err(err) => {\n                         err.cancel();\n                         *this = parser_snapshot_before_ty;\n                         this.recover_arg_parse()?\n@@ -2358,7 +2360,7 @@ impl<'a> Parser<'a> {\n         match self\n             .parse_outer_attributes()\n             .and_then(|_| self.parse_self_param())\n-            .map_err(|mut e| e.cancel())\n+            .map_err(|e| e.cancel())\n         {\n             Ok(Some(_)) => \"method\",\n             _ => \"function\","}, {"sha": "b30705d8d758cf3d196d750b0a32ae4a19273f36", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -849,7 +849,7 @@ impl<'a> Parser<'a> {\n                                     v.push(t);\n                                     continue;\n                                 }\n-                                Err(mut e) => {\n+                                Err(e) => {\n                                     // Parsing failed, therefore it must be something more serious\n                                     // than just a missing separator.\n                                     expect_err.emit();"}, {"sha": "986a8c2b47d4218f6ed5859d3b0ac3368f7eccd0", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -655,7 +655,7 @@ impl<'a> Parser<'a> {\n \n     fn fatal_unexpected_non_pat(\n         &mut self,\n-        mut err: DiagnosticBuilder<'a>,\n+        err: DiagnosticBuilder<'a>,\n         expected: Expected,\n     ) -> PResult<'a, P<Pat>> {\n         err.cancel();\n@@ -722,7 +722,7 @@ impl<'a> Parser<'a> {\n             // Ensure the user doesn't receive unhelpful unexpected token errors\n             self.bump();\n             if self.is_pat_range_end_start(0) {\n-                let _ = self.parse_pat_range_end().map_err(|mut e| e.cancel());\n+                let _ = self.parse_pat_range_end().map_err(|e| e.cancel());\n             }\n \n             self.error_inclusive_range_with_extra_equals(span_with_eq);"}, {"sha": "b5857e0597055cd7b347c9865797c8e7a7871444", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -394,7 +394,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n         match self.parse_angle_args(ty_generics) {\n             Ok(args) => Ok(args),\n-            Err(mut e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n+            Err(e) if is_first_invocation && self.unmatched_angle_bracket_count > 0 => {\n                 // Swap `self` with our backup of the parser state before attempting to parse\n                 // generic arguments.\n                 let snapshot = mem::replace(self, snapshot.unwrap());"}, {"sha": "bbd24289b15cd1950c08169e4e8874b8d74b5379", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -296,7 +296,7 @@ impl<'a> Parser<'a> {\n                 // extra noise.\n                 init\n             }\n-            (Err(mut init_err), Some((snapshot, _, ty_err))) => {\n+            (Err(init_err), Some((snapshot, _, ty_err))) => {\n                 // init error, ty error\n                 init_err.cancel();\n                 // Couldn't parse the type nor the initializer, only raise the type error and\n@@ -449,7 +449,7 @@ impl<'a> Parser<'a> {\n                     );\n                 }\n             }\n-            Err(mut e) => {\n+            Err(e) => {\n                 self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n                 e.cancel();\n             }"}, {"sha": "91695257137cb3811b6bd5edfa83358de854e422", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -2001,13 +2001,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // into a single one.\n             let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n \n-            parent_err.cancel();\n-\n             err.message = take(&mut parent_err.message);\n             err.code = take(&mut parent_err.code);\n             err.children = take(&mut parent_err.children);\n \n-            drop(parent_err);\n+            parent_err.cancel();\n \n             let def_id = this.parent_scope.module.nearest_parent_mod();\n "}, {"sha": "c8d9ddb4a4d35c728ce3e8d6a9d353ba56f0a3db", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -1962,7 +1962,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             // Avoid complaining about other inference issues for expressions like\n             // `42 >> 1`, where the types are still `{integer}`, but we want to\n             // Do we need `trait_ref.skip_binder().self_ty().is_numeric() &&` too?\n-            err.cancel();\n+            // NOTE(eddyb) this was `.cancel()`, but `err`\n+            // is borrowed, so we can't fully defuse it.\n+            err.downgrade_to_delayed_bug();\n             return;\n         }\n         let post = if post.len() > 4 {"}, {"sha": "293f388ff9ceee15cb313f2a03cb58b52a4cd7e5", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -2114,7 +2114,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 if parent_trait_ref.references_error() {\n-                    err.cancel();\n+                    // NOTE(eddyb) this was `.cancel()`, but `err`\n+                    // is borrowed, so we can't fully defuse it.\n+                    err.downgrade_to_delayed_bug();\n                     return;\n                 }\n "}, {"sha": "58ca8869ea9d7b745a73875103f284e3e7b196df", "filename": "src/librustdoc/clean/render_macro_matchers.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Frender_macro_matchers.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -69,17 +69,15 @@ fn snippet_equal_to_token(tcx: TyCtxt<'_>, matcher: &TokenTree) -> Option<String\n         match rustc_parse::maybe_new_parser_from_source_str(&sess, file_name, snippet.clone()) {\n             Ok(parser) => parser,\n             Err(diagnostics) => {\n-                for mut diagnostic in diagnostics {\n-                    diagnostic.cancel();\n-                }\n+                drop(diagnostics);\n                 return None;\n             }\n         };\n \n     // Reparse a single token tree.\n     let mut reparsed_trees = match parser.parse_all_token_trees() {\n         Ok(reparsed_trees) => reparsed_trees,\n-        Err(mut diagnostic) => {\n+        Err(diagnostic) => {\n             diagnostic.cancel();\n             return None;\n         }"}, {"sha": "96182b0da130fdaa75971803d6358d38bd5a2c57", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -551,10 +551,7 @@ crate fn make_test(\n             let mut parser = match maybe_new_parser_from_source_str(&sess, filename, source) {\n                 Ok(p) => p,\n                 Err(errs) => {\n-                    for mut err in errs {\n-                        err.cancel();\n-                    }\n-\n+                    drop(errs);\n                     return (found_main, found_extern_crate, found_macro);\n                 }\n             };\n@@ -594,7 +591,7 @@ crate fn make_test(\n                         }\n                     }\n                     Ok(None) => break,\n-                    Err(mut e) => {\n+                    Err(e) => {\n                         e.cancel();\n                         break;\n                     }"}, {"sha": "a37d3a32571edf0b02cd2de922a7f12b2b01d1cf", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -42,7 +42,7 @@ fn parse_expr(ps: &ParseSess, src: &str) -> Option<P<Expr>> {\n \n     let mut p =\n         new_parser_from_source_str(ps, FileName::Custom(src_as_string.clone()), src_as_string);\n-    p.parse_expr().map_err(|mut e| e.cancel()).ok()\n+    p.parse_expr().map_err(|e| e.cancel()).ok()\n }\n \n // Helper functions for building exprs"}, {"sha": "16173580fd4617ae67a5223b96ce94a3a67be87d", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -628,9 +628,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let mut parser = match maybe_new_parser_from_source_str(&sess, filename, code) {\n                     Ok(p) => p,\n                     Err(errs) => {\n-                        for mut err in errs {\n-                            err.cancel();\n-                        }\n+                        drop(errs);\n                         return false;\n                     },\n                 };\n@@ -668,7 +666,7 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                             _ => {},\n                         },\n                         Ok(None) => break,\n-                        Err(mut e) => {\n+                        Err(e) => {\n                             e.cancel();\n                             return false;\n                         },"}, {"sha": "a328ddda5ae7b9fd6b980eddf188641e70057f6b", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -534,7 +534,7 @@ impl Write {\n             match parser\n                 .parse_expr()\n                 .map(rustc_ast::ptr::P::into_inner)\n-                .map_err(|mut e| e.cancel())\n+                .map_err(|e| e.cancel())\n             {\n                 // write!(e, ...)\n                 Ok(p) if parser.eat(&token::Comma) => Some(p),\n@@ -563,7 +563,7 @@ impl Write {\n             }\n \n             let comma_span = parser.prev_token.span;\n-            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|mut err| err.cancel()) {\n+            let token_expr = if let Ok(expr) = parser.parse_expr().map_err(|err| err.cancel()) {\n                 expr\n             } else {\n                 return (Some(fmtstr), None);"}, {"sha": "d4bddd957858ff30eb732c8999ada0f28b9faed0", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -439,7 +439,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n                 }\n             }\n             Err(mod_err) if !mods_outside_ast.is_empty() => {\n-                if let ModError::ParserError(mut e) = mod_err {\n+                if let ModError::ParserError(e) = mod_err {\n                     e.cancel();\n                 }\n                 Ok(Some(SubModKind::MultiExternal(mods_outside_ast)))"}, {"sha": "306b6bb745ee6d0221571f17ccc32fdad0986336", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -57,7 +57,7 @@ fn parse_cfg_if_inner<'a>(\n             let item = match parser.parse_item(ForceCollect::No) {\n                 Ok(Some(item_ptr)) => item_ptr.into_inner(),\n                 Ok(None) => continue,\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return Err("}, {"sha": "4c541de04be0894d4a53ef53890043105b345630", "filename": "src/tools/rustfmt/src/parse/macros/lazy_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Flazy_static.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn parse_lazy_static(\n                         val\n                     }\n                 }\n-                Err(mut err) => {\n+                Err(err) => {\n                     err.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                     return None;"}, {"sha": "fd738908170f86ef5264737ae24ab466228c146e", "filename": "src/tools/rustfmt/src/parse/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fmod.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -36,7 +36,7 @@ fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n                         return Some(MacroArg::$macro_arg($f(x)?));\n                     }\n                 }\n-                Err(mut e) => {\n+                Err(e) => {\n                     e.cancel();\n                     parser.sess.span_diagnostic.reset_err_count();\n                 }"}, {"sha": "f0944a88d2f2222be8cb519efd2c7c5f70b46aee", "filename": "src/tools/rustfmt/src/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fparser.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -115,7 +115,7 @@ impl<'a> Parser<'a> {\n             match parser.parse_mod(&TokenKind::Eof) {\n                 Ok(result) => Some(result),\n                 Err(mut e) => {\n-                    sess.emit_or_cancel_diagnostic(&mut e);\n+                    e.emit();\n                     if sess.can_reset_errors() {\n                         sess.reset_errors();\n                     }"}, {"sha": "40a6d708d8cccb25911c89b0cf85295481c698ad", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b9d70cf6d47df456280f83b58c04c96aa58e89e/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=0b9d70cf6d47df456280f83b58c04c96aa58e89e", "patch": "@@ -230,17 +230,6 @@ impl ParseSess {\n         }\n     }\n \n-    pub(crate) fn emit_or_cancel_diagnostic(&self, diagnostic: &mut Diagnostic) {\n-        self.parse_sess.span_diagnostic.emit_diagnostic(diagnostic);\n-        // The Handler will check whether the diagnostic should be emitted\n-        // based on the user's rustfmt configuration and the originating file\n-        // that caused the parser error. If the Handler determined it should skip\n-        // emission then we need to ensure the diagnostic is cancelled.\n-        if !diagnostic.cancelled() {\n-            diagnostic.cancel();\n-        }\n-    }\n-\n     pub(super) fn can_reset_errors(&self) -> bool {\n         self.can_reset_errors.load(Ordering::Acquire)\n     }"}]}