{"sha": "0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMmU2OTVmZmNkMWU5NmNkM2E2NjAzYTFkNWYzODdmNWJjZmJmMmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T07:28:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T07:28:27Z"}, "message": "Merge #5050\n\n5050: Simplify r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6653b04e51bd538773db8f4bcb63dd29f8ca0625", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6653b04e51bd538773db8f4bcb63dd29f8ca0625"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9FIbCRBK7hj4Ov3rIwAAdHIIAJ2dm9dxw9ylhXA+YAwETWkE\ndeoxgjkjd0ViSkqNXf0VogC/77BXpcoqVnxqQv5y/5mZ/jO63vLXGJwnA5CH+/oj\nF5etk8LqVCSbQatAV7fF8z8iYtRzO49iapuJKGwYHk4sTYmoMp6hcBX6KTUVEt74\nqh4LONedC3EozkpbKHT/vxN5mN6qxm067SLA0KKXAgnJLjguEmWq8fZeEPEuVvYm\nPRbBfwnwQrIuImngpyXQqn9neNVSvY+EhE+NxEZdGivShfSlUq/Kf08vnIePCvXn\nu9il61K3UPgJQJOuRcKjz2M13gj5xW4DZUDHsk8bcgSrkKlck+/AkPZ+jY/e+T4=\n=jlGY\n-----END PGP SIGNATURE-----\n", "payload": "tree 6653b04e51bd538773db8f4bcb63dd29f8ca0625\nparent edf8f419b532b93102222b9deb2c8bb5080911d9\nparent 941d4bfa53ebf4dd683889c2151544bcc3095073\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593070107 +0000\ncommitter GitHub <noreply@github.com> 1593070107 +0000\n\nMerge #5050\n\n5050: Simplify r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "html_url": "https://github.com/rust-lang/rust/commit/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf8f419b532b93102222b9deb2c8bb5080911d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf8f419b532b93102222b9deb2c8bb5080911d9", "html_url": "https://github.com/rust-lang/rust/commit/edf8f419b532b93102222b9deb2c8bb5080911d9"}, {"sha": "941d4bfa53ebf4dd683889c2151544bcc3095073", "url": "https://api.github.com/repos/rust-lang/rust/commits/941d4bfa53ebf4dd683889c2151544bcc3095073", "html_url": "https://github.com/rust-lang/rust/commit/941d4bfa53ebf4dd683889c2151544bcc3095073"}], "stats": {"total": 117, "additions": 54, "deletions": 63}, "files": [{"sha": "3e73cf6fff6d3ede3be5b9b3b51a6a36c708f6a1", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "patch": "@@ -10,7 +10,6 @@ use std::{\n     time::Instant,\n };\n \n-use cargo_metadata::Message;\n use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n \n pub use cargo_metadata::diagnostic::{\n@@ -50,17 +49,17 @@ impl fmt::Display for FlycheckConfig {\n #[derive(Debug)]\n pub struct FlycheckHandle {\n     // XXX: drop order is significant\n-    cmd_send: Sender<CheckCommand>,\n-    handle: jod_thread::JoinHandle<()>,\n+    cmd_send: Sender<Restart>,\n+    handle: jod_thread::JoinHandle,\n }\n \n impl FlycheckHandle {\n     pub fn spawn(\n-        sender: Box<dyn Fn(CheckTask) + Send>,\n+        sender: Box<dyn Fn(Message) + Send>,\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckHandle {\n-        let (cmd_send, cmd_recv) = unbounded::<CheckCommand>();\n+        let (cmd_send, cmd_recv) = unbounded::<Restart>();\n         let handle = jod_thread::spawn(move || {\n             FlycheckActor::new(sender, config, workspace_root).run(&cmd_recv);\n         });\n@@ -69,36 +68,33 @@ impl FlycheckHandle {\n \n     /// Schedule a re-start of the cargo check worker.\n     pub fn update(&self) {\n-        self.cmd_send.send(CheckCommand::Update).unwrap();\n+        self.cmd_send.send(Restart).unwrap();\n     }\n }\n \n #[derive(Debug)]\n-pub enum CheckTask {\n+pub enum Message {\n     /// Request a clearing of all cached diagnostics from the check watcher\n     ClearDiagnostics,\n \n     /// Request adding a diagnostic with fixes included to a file\n     AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n-    Status(Status),\n+    Progress(Progress),\n }\n \n #[derive(Debug)]\n-pub enum Status {\n+pub enum Progress {\n     Being,\n-    Progress(String),\n+    DidCheckCrate(String),\n     End,\n }\n \n-pub enum CheckCommand {\n-    /// Request re-start of check thread\n-    Update,\n-}\n+struct Restart;\n \n struct FlycheckActor {\n-    sender: Box<dyn Fn(CheckTask) + Send>,\n+    sender: Box<dyn Fn(Message) + Send>,\n     config: FlycheckConfig,\n     workspace_root: PathBuf,\n     last_update_req: Option<Instant>,\n@@ -109,12 +105,12 @@ struct FlycheckActor {\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    check_process: Option<jod_thread::JoinHandle<()>>,\n+    check_process: Option<jod_thread::JoinHandle>,\n }\n \n impl FlycheckActor {\n     fn new(\n-        sender: Box<dyn Fn(CheckTask) + Send>,\n+        sender: Box<dyn Fn(Message) + Send>,\n         config: FlycheckConfig,\n         workspace_root: PathBuf,\n     ) -> FlycheckActor {\n@@ -128,14 +124,14 @@ impl FlycheckActor {\n         }\n     }\n \n-    fn run(&mut self, cmd_recv: &Receiver<CheckCommand>) {\n+    fn run(&mut self, cmd_recv: &Receiver<Restart>) {\n         // If we rerun the thread, we need to discard the previous check results first\n         self.clean_previous_results();\n \n         loop {\n             select! {\n                 recv(&cmd_recv) -> cmd => match cmd {\n-                    Ok(cmd) => self.handle_command(cmd),\n+                    Ok(Restart) => self.last_update_req = Some(Instant::now()),\n                     Err(RecvError) => {\n                         // Command channel has closed, so shut down\n                         break;\n@@ -154,15 +150,15 @@ impl FlycheckActor {\n \n             if self.should_recheck() {\n                 self.last_update_req = None;\n-                self.send(CheckTask::ClearDiagnostics);\n+                self.send(Message::ClearDiagnostics);\n                 self.restart_check_process();\n             }\n         }\n     }\n \n     fn clean_previous_results(&self) {\n-        self.send(CheckTask::ClearDiagnostics);\n-        self.send(CheckTask::Status(Status::End));\n+        self.send(Message::ClearDiagnostics);\n+        self.send(Message::Progress(Progress::End));\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -175,37 +171,31 @@ impl FlycheckActor {\n         false\n     }\n \n-    fn handle_command(&mut self, cmd: CheckCommand) {\n-        match cmd {\n-            CheckCommand::Update => self.last_update_req = Some(Instant::now()),\n-        }\n-    }\n-\n     fn handle_message(&self, msg: CheckEvent) {\n         match msg {\n             CheckEvent::Begin => {\n-                self.send(CheckTask::Status(Status::Being));\n+                self.send(Message::Progress(Progress::Being));\n             }\n \n             CheckEvent::End => {\n-                self.send(CheckTask::Status(Status::End));\n+                self.send(Message::Progress(Progress::End));\n             }\n \n-            CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                self.send(CheckTask::Status(Status::Progress(msg.target.name)));\n+            CheckEvent::Msg(cargo_metadata::Message::CompilerArtifact(msg)) => {\n+                self.send(Message::Progress(Progress::DidCheckCrate(msg.target.name)));\n             }\n \n-            CheckEvent::Msg(Message::CompilerMessage(msg)) => {\n-                self.send(CheckTask::AddDiagnostic {\n+            CheckEvent::Msg(cargo_metadata::Message::CompilerMessage(msg)) => {\n+                self.send(Message::AddDiagnostic {\n                     workspace_root: self.workspace_root.clone(),\n                     diagnostic: msg.message,\n                 });\n             }\n \n-            CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n-            CheckEvent::Msg(Message::BuildFinished(_)) => {}\n-            CheckEvent::Msg(Message::TextLine(_)) => {}\n-            CheckEvent::Msg(Message::Unknown) => {}\n+            CheckEvent::Msg(cargo_metadata::Message::BuildScriptExecuted(_))\n+            | CheckEvent::Msg(cargo_metadata::Message::BuildFinished(_))\n+            | CheckEvent::Msg(cargo_metadata::Message::TextLine(_))\n+            | CheckEvent::Msg(cargo_metadata::Message::Unknown) => {}\n         }\n     }\n \n@@ -256,9 +246,11 @@ impl FlycheckActor {\n             let res = run_cargo(cmd, &mut |message| {\n                 // Skip certain kinds of messages to only spend time on what's useful\n                 match &message {\n-                    Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n-                    Message::BuildScriptExecuted(_) => return true,\n-                    Message::Unknown => return true,\n+                    cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => {\n+                        return true\n+                    }\n+                    cargo_metadata::Message::BuildScriptExecuted(_)\n+                    | cargo_metadata::Message::Unknown => return true,\n                     _ => {}\n                 }\n \n@@ -278,7 +270,7 @@ impl FlycheckActor {\n         }))\n     }\n \n-    fn send(&self, check_task: CheckTask) {\n+    fn send(&self, check_task: Message) {\n         (self.sender)(check_task)\n     }\n }"}, {"sha": "446207e9e54131acf6dc30196ef1f8e787581f59", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "patch": "@@ -6,7 +6,7 @@\n use std::{convert::TryFrom, sync::Arc};\n \n use crossbeam_channel::{unbounded, Receiver};\n-use flycheck::{CheckTask, FlycheckConfig, FlycheckHandle};\n+use flycheck::{FlycheckConfig, FlycheckHandle};\n use lsp_types::Url;\n use parking_lot::RwLock;\n use ra_db::{CrateId, SourceRoot, VfsPath};\n@@ -30,7 +30,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n fn create_flycheck(\n     workspaces: &[ProjectWorkspace],\n     config: &FlycheckConfig,\n-) -> Option<(FlycheckHandle, Receiver<CheckTask>)> {\n+) -> Option<(FlycheckHandle, Receiver<flycheck::Message>)> {\n     // FIXME: Figure out the multi-workspace situation\n     workspaces.iter().find_map(move |w| match w {\n         ProjectWorkspace::Cargo { cargo, .. } => {\n@@ -69,7 +69,7 @@ pub(crate) struct GlobalState {\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) loader: Box<dyn vfs::loader::Handle>,\n     pub(crate) task_receiver: Receiver<vfs::loader::Message>,\n-    pub(crate) flycheck: Option<(FlycheckHandle, Receiver<CheckTask>)>,\n+    pub(crate) flycheck: Option<(FlycheckHandle, Receiver<flycheck::Message>)>,\n     pub(crate) diagnostics: DiagnosticCollection,\n     pub(crate) mem_docs: FxHashSet<VfsPath>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,"}, {"sha": "200641cd57308ae8f6049a47bf17275e2f0d9256", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=0d2e695ffcd1e96cd3a6603a1d5f387f5bcfbf2e", "patch": "@@ -9,7 +9,6 @@ use std::{\n };\n \n use crossbeam_channel::{never, select, unbounded, RecvError, Sender};\n-use flycheck::CheckTask;\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{request::Request as _, NumberOrString, TextDocumentContentChangeEvent};\n use ra_db::VfsPath;\n@@ -176,7 +175,7 @@ enum Event {\n     Msg(Message),\n     Task(Task),\n     Vfs(vfs::loader::Message),\n-    CheckWatcher(CheckTask),\n+    CheckWatcher(flycheck::Message),\n }\n \n impl fmt::Debug for Event {\n@@ -250,14 +249,14 @@ fn loop_turn(\n             }\n             vfs::loader::Message::Progress { n_total, n_done } => {\n                 let state = if n_done == 0 {\n-                    ProgressState::Start\n+                    Progress::Begin\n                 } else if n_done < n_total {\n-                    ProgressState::Report\n+                    Progress::Report\n                 } else {\n                     assert_eq!(n_done, n_total);\n                     global_state.status = Status::Ready;\n                     became_ready = true;\n-                    ProgressState::End\n+                    Progress::End\n                 };\n                 report_progress(\n                     global_state,\n@@ -593,17 +592,17 @@ fn apply_document_changes(\n }\n \n fn on_check_task(\n-    task: CheckTask,\n+    task: flycheck::Message,\n     global_state: &mut GlobalState,\n     task_sender: &Sender<Task>,\n     msg_sender: &Sender<Message>,\n ) -> Result<()> {\n     match task {\n-        CheckTask::ClearDiagnostics => {\n+        flycheck::Message::ClearDiagnostics => {\n             task_sender.send(Task::Diagnostic(DiagnosticTask::ClearCheck))?;\n         }\n \n-        CheckTask::AddDiagnostic { workspace_root, diagnostic } => {\n+        flycheck::Message::AddDiagnostic { workspace_root, diagnostic } => {\n             let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n                 &global_state.config.diagnostics,\n                 &diagnostic,\n@@ -627,11 +626,11 @@ fn on_check_task(\n             }\n         }\n \n-        CheckTask::Status(status) => {\n+        flycheck::Message::Progress(status) => {\n             let (state, message) = match status {\n-                flycheck::Status::Being => (ProgressState::Start, None),\n-                flycheck::Status::Progress(target) => (ProgressState::Report, Some(target)),\n-                flycheck::Status::End => (ProgressState::End, None),\n+                flycheck::Progress::Being => (Progress::Begin, None),\n+                flycheck::Progress::DidCheckCrate(target) => (Progress::Report, Some(target)),\n+                flycheck::Progress::End => (Progress::End, None),\n             };\n \n             report_progress(global_state, msg_sender, \"cargo check\", state, message, None);\n@@ -654,8 +653,8 @@ fn on_diagnostic_task(task: DiagnosticTask, msg_sender: &Sender<Message>, state:\n }\n \n #[derive(Eq, PartialEq)]\n-enum ProgressState {\n-    Start,\n+enum Progress {\n+    Begin,\n     Report,\n     End,\n }\n@@ -668,7 +667,7 @@ fn report_progress(\n     global_state: &mut GlobalState,\n     sender: &Sender<Message>,\n     title: &str,\n-    state: ProgressState,\n+    state: Progress,\n     message: Option<String>,\n     percentage: Option<f64>,\n ) {\n@@ -677,7 +676,7 @@ fn report_progress(\n     }\n     let token = lsp_types::ProgressToken::String(format!(\"rustAnalyzer/{}\", title));\n     let work_done_progress = match state {\n-        ProgressState::Start => {\n+        Progress::Begin => {\n             let work_done_progress_create = global_state.req_queue.outgoing.register(\n                 lsp_types::request::WorkDoneProgressCreate::METHOD.to_string(),\n                 lsp_types::WorkDoneProgressCreateParams { token: token.clone() },\n@@ -692,14 +691,14 @@ fn report_progress(\n                 percentage,\n             })\n         }\n-        ProgressState::Report => {\n+        Progress::Report => {\n             lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n                 cancellable: None,\n                 message,\n                 percentage,\n             })\n         }\n-        ProgressState::End => {\n+        Progress::End => {\n             lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd { message })\n         }\n     };"}]}