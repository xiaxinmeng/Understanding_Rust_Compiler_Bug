{"sha": "dd0781ea254564cad86e3d594367b1988edf308d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMDc4MWVhMjU0NTY0Y2FkODZlM2Q1OTQzNjdiMTk4OGVkZjMwOGQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-28T05:56:06Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-10T09:21:29Z"}, "message": "Register and stability check `#[no_link]` crates.", "tree": {"sha": "5f3e7a3824ceed9dd6a74bf9a293c7e6779e03dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3e7a3824ceed9dd6a74bf9a293c7e6779e03dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd0781ea254564cad86e3d594367b1988edf308d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0781ea254564cad86e3d594367b1988edf308d", "html_url": "https://github.com/rust-lang/rust/commit/dd0781ea254564cad86e3d594367b1988edf308d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd0781ea254564cad86e3d594367b1988edf308d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1d45d94b0c4096ffaeccb0398987f5d6e73dfc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d45d94b0c4096ffaeccb0398987f5d6e73dfc6", "html_url": "https://github.com/rust-lang/rust/commit/a1d45d94b0c4096ffaeccb0398987f5d6e73dfc6"}], "stats": {"total": 91, "additions": 50, "deletions": 41}, "files": [{"sha": "bdef44bf5c18eae701227582b02c7cec911054a3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -65,6 +65,8 @@ pub struct CrateSource {\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n pub enum DepKind {\n+    /// A dependency that is only used for its macros.\n+    MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n     /// doesn't need to be linked to an rlib, e.g. the injected allocator.\n     Implicit,"}, {"sha": "92d1ab85c5a05afcf806eb14e7330c9d595b22a1", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -124,6 +124,7 @@ fn calculate_type(sess: &session::Session,\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n+                if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n                 let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n@@ -156,6 +157,7 @@ fn calculate_type(sess: &session::Session,\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     for cnum in sess.cstore.crates() {\n+        if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n         let name = sess.cstore.crate_name(cnum);\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {"}, {"sha": "07b87072c435e6ef14d9ebc0322285e6fe3446ca", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -29,6 +29,7 @@\n #![feature(staged_api)]\n #![feature(linked_from)]\n #![feature(concat_idents)]\n+#![cfg_attr(not(stage0), feature(rustc_private))]\n \n extern crate libc;\n #[macro_use]"}, {"sha": "9101f95c8821474cded401583a0a98053a0ea02c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -67,16 +67,12 @@ fn dump_crates(cstore: &CStore) {\n     })\n }\n \n-fn should_link(i: &ast::Item) -> bool {\n-    !attr::contains_name(&i.attrs, \"no_link\")\n-}\n-\n #[derive(Debug)]\n struct ExternCrateInfo {\n     ident: String,\n     name: String,\n     id: ast::NodeId,\n-    should_link: bool,\n+    dep_kind: DepKind,\n }\n \n fn register_native_lib(sess: &Session,\n@@ -168,7 +164,11 @@ impl<'a> CrateLoader<'a> {\n                     ident: i.ident.to_string(),\n                     name: name,\n                     id: i.id,\n-                    should_link: should_link(i),\n+                    dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n+                        DepKind::MacrosOnly\n+                    } else {\n+                        DepKind::Explicit\n+                    },\n                 })\n             }\n             _ => None\n@@ -283,7 +283,7 @@ impl<'a> CrateLoader<'a> {\n \n         let Library { dylib, rlib, metadata } = lib;\n \n-        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span);\n+        let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         if crate_root.macro_derive_registrar.is_some() {\n             self.sess.span_err(span, \"crates of the `proc-macro` crate type \\\n@@ -427,21 +427,23 @@ impl<'a> CrateLoader<'a> {\n                           crate_root: &CrateRoot,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n-                          span: Span)\n+                          span: Span,\n+                          dep_kind: DepKind)\n                           -> cstore::CrateNumMap {\n         debug!(\"resolving deps of external crate\");\n         // The map from crate numbers in the crate we're resolving to local crate\n         // numbers\n         let deps = crate_root.crate_deps.decode(metadata);\n         let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let (local_cnum, ..) = self.resolve_crate(root,\n-                                                        &dep.name.as_str(),\n-                                                        &dep.name.as_str(),\n-                                                        Some(&dep.hash),\n-                                                        span,\n-                                                        PathKind::Dependency,\n-                                                        dep.kind);\n+            let dep_name = &dep.name.as_str();\n+            let dep_kind = match dep_kind {\n+                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                _ => dep.kind,\n+            };\n+            let (local_cnum, ..) = self.resolve_crate(\n+                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+            );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n \n@@ -455,8 +457,8 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &ExternCrateInfo) -> ExtensionCrate {\n-        info!(\"read extension crate {} `extern crate {} as {}` linked={}\",\n-              info.id, info.name, info.ident, info.should_link);\n+        info!(\"read extension crate {} `extern crate {} as {}` dep_kind={:?}\",\n+              info.id, info.name, info.ident, info.dep_kind);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n@@ -641,7 +643,7 @@ impl<'a> CrateLoader<'a> {\n              name: name.to_string(),\n              ident: name.to_string(),\n              id: ast::DUMMY_NODE_ID,\n-             should_link: false,\n+             dep_kind: DepKind::MacrosOnly,\n         });\n \n         if ekrate.target_only {\n@@ -984,30 +986,26 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n             let ekrate = self.read_extension_crate(item.span, &info);\n             let loaded_macros = self.read_macros(item, &ekrate);\n \n-            // If this is a proc-macro crate or `#[no_link]` crate, it is only used at compile time,\n-            // so we return here to avoid registering the crate.\n-            if loaded_macros.is_proc_macros() || !info.should_link {\n+            // If this is a proc-macro crate, return here to avoid registering.\n+            if loaded_macros.is_proc_macros() {\n                 return Some(loaded_macros);\n             }\n \n             // Register crate now to avoid double-reading metadata\n             if let PMDSource::Owned(lib) = ekrate.metadata {\n                 if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n-                    let ExternCrateInfo { ref ident, ref name, .. } = info;\n-                    self.register_crate(&None, ident, name, item.span, lib, DepKind::Explicit);\n+                    let ExternCrateInfo { ref ident, ref name, dep_kind, .. } = info;\n+                    self.register_crate(&None, ident, name, item.span, lib, dep_kind);\n                 }\n             }\n \n             Some(loaded_macros)\n         } else {\n-            if !info.should_link {\n-                return None;\n-            }\n             None\n         };\n \n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, DepKind::Explicit,\n+            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();"}, {"sha": "10e86c427a832d7aecc6cf0b7dea664f7ac582a3", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -192,12 +192,13 @@ impl CStore {\n         let mut libs = self.metas\n             .borrow()\n             .iter()\n-            .map(|(&cnum, data)| {\n-                (cnum,\n-                 match prefer {\n-                     LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n-                     LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n-                 })\n+            .filter_map(|(&cnum, data)| {\n+                if data.dep_kind.get() == DepKind::MacrosOnly { return None; }\n+                let path = match prefer {\n+                    LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n+                    LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n+                };\n+                Some((cnum, path))\n             })\n             .collect::<Vec<_>>();\n         libs.sort_by(|&(a, _), &(b, _)| {"}, {"sha": "1da264189657301113429791064053d3ef561716", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -21,7 +21,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n-use rustc::middle::cstore::{InlinedItem, LinkagePreference};\n+use rustc::middle::cstore::{DepKind, InlinedItem, LinkagePreference};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc::middle::lang_items;\n@@ -690,6 +690,10 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn each_child_of_item<F>(&self, id: DefIndex, mut callback: F)\n         where F: FnMut(def::Export)\n     {\n+        if self.dep_kind.get() == DepKind::MacrosOnly {\n+            return\n+        }\n+\n         // Find the item.\n         let item = match self.maybe_entry(id) {\n             None => return,"}, {"sha": "ed87c61ef3b74c1a362ee8c518a12f70eabe13a1", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -22,7 +22,7 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacros;\n+use rustc::middle::cstore::{DepKind, LoadedMacros};\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty;\n@@ -499,8 +499,9 @@ impl<'b> Resolver<'b> {\n \n     fn get_extern_crate_root(&mut self, cnum: CrateNum) -> Module<'b> {\n         let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+        let macros_only = self.session.cstore.dep_kind(cnum) == DepKind::MacrosOnly;\n         let arenas = self.arenas;\n-        *self.extern_crate_roots.entry(cnum).or_insert_with(|| {\n+        *self.extern_crate_roots.entry((cnum, macros_only)).or_insert_with(|| {\n             arenas.alloc_module(ModuleS {\n                 populated: Cell::new(false),\n                 ..ModuleS::new(None, ModuleKind::Def(Def::Mod(def_id), keywords::Invalid.name()))"}, {"sha": "89a0826254c10b7c2caf01aec489e9ed1a8933a4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -1083,7 +1083,7 @@ pub struct Resolver<'a> {\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n     module_map: NodeMap<Module<'a>>,\n-    extern_crate_roots: FxHashMap<CrateNum, Module<'a>>,\n+    extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n     // Whether or not to print error messages. Can be set to true\n     // when getting additional info for error message suggestions,"}, {"sha": "5ea07403cf793b7e25038e36f1fff7894236f19d", "filename": "src/test/compile-fail/no-link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dd0781ea254564cad86e3d594367b1988edf308d/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0781ea254564cad86e3d594367b1988edf308d/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=dd0781ea254564cad86e3d594367b1988edf308d", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:empty-struct.rs\n+\n #[no_link]\n-extern crate libc;\n+extern crate empty_struct;\n \n fn main() {\n-    unsafe {\n-        libc::abs(0);  //~ ERROR unresolved name\n-    }\n+    empty_struct::XEmpty1; //~ ERROR unresolved name\n }"}]}