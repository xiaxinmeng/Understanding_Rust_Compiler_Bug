{"sha": "ff39457364659e485991fdb0f145858ff2fb016f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMzk0NTczNjQ2NTllNDg1OTkxZmRiMGYxNDU4NThmZjJmYjAxNmY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-29T10:34:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-10T09:47:20Z"}, "message": "avoid raising interpreter errors from interning", "tree": {"sha": "94248a988054f294d84f6b9591f8151f0b9a9d66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94248a988054f294d84f6b9591f8151f0b9a9d66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff39457364659e485991fdb0f145858ff2fb016f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff39457364659e485991fdb0f145858ff2fb016f", "html_url": "https://github.com/rust-lang/rust/commit/ff39457364659e485991fdb0f145858ff2fb016f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff39457364659e485991fdb0f145858ff2fb016f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e48a304dc1aa87bfed8f8e8c137477efc64cfd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e48a304dc1aa87bfed8f8e8c137477efc64cfd0", "html_url": "https://github.com/rust-lang/rust/commit/8e48a304dc1aa87bfed8f8e8c137477efc64cfd0"}], "stats": {"total": 80, "additions": 50, "deletions": 30}, "files": [{"sha": "0637ebf959e5a6b1ef0bd340a83481b913f51da9", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -66,7 +66,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n         intern_kind,\n         ret,\n         body.ignore_interior_mut_in_const_validation,\n-    )?;\n+    );\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)"}, {"sha": "7f557e340bbc8caa4ae4983f9a1ffcbf60c55928", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn const_caller_location(\n     let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false);\n     ConstValue::Scalar(loc_place.ptr)\n }\n "}, {"sha": "4caf2caa8cc3dbe8f1b78bb6e705068513a192c0", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -5,9 +5,8 @@\n \n use super::validity::RefTracking;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n-use rustc_middle::mir::interpret::{ErrorHandled, InterpResult};\n+use rustc_middle::mir::interpret::InterpResult;\n use rustc_middle::ty::{self, query::TyCtxtAt, Ty};\n \n use rustc_ast::ast::Mutability;\n@@ -64,6 +63,7 @@ enum InternMode {\n struct IsStaticOrFn;\n \n fn mutable_memory_in_const(tcx: TyCtxtAt<'_>, kind: &str) {\n+    // FIXME: show this in validation instead so we can point at where in the value the error is?\n     tcx.sess.span_err(tcx.span, &format!(\"mutable memory ({}) is not allowed in constant\", kind));\n }\n \n@@ -79,7 +79,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     alloc_id: AllocId,\n     mode: InternMode,\n     ty: Option<Ty<'tcx>>,\n-) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+) -> Option<IsStaticOrFn> {\n     trace!(\"intern_shallow {:?} with {:?}\", alloc_id, mode);\n     // remove allocation\n     let tcx = ecx.tcx;\n@@ -97,7 +97,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n             }\n             // treat dangling pointers like other statics\n             // just to stop trying to recurse into them\n-            return Ok(Some(IsStaticOrFn));\n+            return Some(IsStaticOrFn);\n         }\n     };\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n@@ -136,7 +136,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     let alloc = tcx.intern_const_alloc(alloc);\n     leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n     tcx.set_alloc_id_memory(alloc_id, alloc);\n-    Ok(None)\n+    None\n }\n \n impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir, 'tcx, M> {\n@@ -145,7 +145,7 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> InternVisitor<'rt, 'mir\n         alloc_id: AllocId,\n         mode: InternMode,\n         ty: Option<Ty<'tcx>>,\n-    ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+    ) -> Option<IsStaticOrFn> {\n         intern_shallow(\n             self.ecx,\n             self.leftover_allocations,\n@@ -213,7 +213,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n-                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None)?;\n+                    self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n                     // Let validation show the error message, but make sure it *does* error.\n                     tcx.sess.delay_span_bug(\n@@ -277,7 +277,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                         InternMode::ConstInner\n                     }\n                 };\n-                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty))? {\n+                match self.intern_shallow(ptr.alloc_id, ref_mode, Some(referenced_ty)) {\n                     // No need to recurse, these are interned already and statics may have\n                     // cycles, so we don't want to recurse there\n                     Some(IsStaticOrFn) => {}\n@@ -304,12 +304,18 @@ pub enum InternKind {\n     ConstProp,\n }\n \n+/// Intern `ret` and everything it references.\n+///\n+/// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n+/// trakcs where in the value we are and thus can show much better error messages.\n+/// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n+/// are hard errors.\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n     intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const: bool,\n-) -> InterpResult<'tcx>\n+)\n where\n     'tcx: 'mir,\n {\n@@ -338,7 +344,7 @@ where\n         ret.ptr.assert_ptr().alloc_id,\n         base_intern_mode,\n         Some(ret.layout.ty),\n-    )?;\n+    );\n \n     ref_tracking.track((ret, base_intern_mode), || ());\n \n@@ -422,13 +428,16 @@ where\n                 }\n             }\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n-            // dangling pointer\n-            throw_ub_format!(\"encountered dangling pointer in final constant\")\n+            // Codegen does not like dangling pointers, and generally `tcx` assumes that\n+            // all allocations referenced anywhere actually exist. So, make sure we error here.\n+            ecx.tcx.sess.span_err(\n+                ecx.tcx.span,\n+                \"encountered dangling pointer in final constant\",\n+            );\n         } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n-            // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n-            // as dangling by local memory.\n+                // We have hit an `AllocId` that is neither in local or global memory and isn't\n+                // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n-    Ok(())\n }"}, {"sha": "81de8dcece683a30a2c46c426f7790e529c08d87", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -702,8 +702,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false)\n-                    .expect(\"failed to intern alloc\");\n+                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false);\n                 true\n             }\n             _ => false,"}, {"sha": "3b7f1de5b9bea728a515009a026958a2659bb6da", "filename": "src/test/ui/consts/dangling-alloc-id-ice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -1,11 +1,13 @@\n // https://github.com/rust-lang/rust/issues/55223\n+#![allow(const_err)]\n \n union Foo<'a> {\n     y: &'a (),\n     long_live_the_unit: &'static (),\n }\n \n-const FOO: &() = { //~ ERROR any use of this value will cause an error\n+const FOO: &() = { //~ ERROR it is undefined behavior to use this value\n+//~^ ERROR encountered dangling pointer in final constant\n     let y = ();\n     unsafe { Foo { y: &y }.long_live_the_unit }\n };"}, {"sha": "14a49810b9de5fe07d99b50742abed192d0b7eac", "filename": "src/test/ui/consts/dangling-alloc-id-ice.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling-alloc-id-ice.stderr?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -1,13 +1,25 @@\n-error: any use of this value will cause an error\n-  --> $DIR/dangling-alloc-id-ice.rs:8:1\n+error: encountered dangling pointer in final constant\n+  --> $DIR/dangling-alloc-id-ice.rs:9:1\n    |\n LL | / const FOO: &() = {\n+LL | |\n LL | |     let y = ();\n LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n LL | | };\n-   | |__^ encountered dangling pointer in final constant\n+   | |__^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/dangling-alloc-id-ice.rs:9:1\n+   |\n+LL | / const FOO: &() = {\n+LL | |\n+LL | |     let y = ();\n+LL | |     unsafe { Foo { y: &y }.long_live_the_unit }\n+LL | | };\n+   | |__^ type validation failed: encountered a dangling reference (use-after-free)\n    |\n-   = note: `#[deny(const_err)]` on by default\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "ddd1fb1ba76e163124a485ff3643e78114aa6309", "filename": "src/test/ui/consts/dangling_raw_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.rs?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -1,4 +1,4 @@\n-const FOO: *const u32 = { //~ ERROR any use of this value will cause an error\n+const FOO: *const u32 = { //~ ERROR encountered dangling pointer in final constant\n     let x = 42;\n     &x\n };"}, {"sha": "a79ac62d5cdbdcce13ea7947f244036b8ab13317", "filename": "src/test/ui/consts/dangling_raw_ptr.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ff39457364659e485991fdb0f145858ff2fb016f/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fdangling_raw_ptr.stderr?ref=ff39457364659e485991fdb0f145858ff2fb016f", "patch": "@@ -1,13 +1,11 @@\n-error: any use of this value will cause an error\n+error: encountered dangling pointer in final constant\n   --> $DIR/dangling_raw_ptr.rs:1:1\n    |\n LL | / const FOO: *const u32 = {\n LL | |     let x = 42;\n LL | |     &x\n LL | | };\n-   | |__^ encountered dangling pointer in final constant\n-   |\n-   = note: `#[deny(const_err)]` on by default\n+   | |__^\n \n error: aborting due to previous error\n "}]}