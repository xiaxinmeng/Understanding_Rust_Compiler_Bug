{"sha": "3a863e534bcba819a4ff8d8362df442001a3dd8a", "node_id": "C_kwDOAAsO6NoAKDNhODYzZTUzNGJjYmE4MTlhNGZmOGQ4MzYyZGY0NDIwMDFhM2RkOGE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-22T04:51:35Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-05-09T20:37:50Z"}, "message": "Consolidate the 'match assumption' type methods in GoalKind", "tree": {"sha": "4a40d548eeaeb5204d4319b26d98c5634c09009b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a40d548eeaeb5204d4319b26d98c5634c09009b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a863e534bcba819a4ff8d8362df442001a3dd8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a863e534bcba819a4ff8d8362df442001a3dd8a", "html_url": "https://github.com/rust-lang/rust/commit/3a863e534bcba819a4ff8d8362df442001a3dd8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a863e534bcba819a4ff8d8362df442001a3dd8a/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbaae4165b8ba41397a9b0f714acb2cd3610d65", "html_url": "https://github.com/rust-lang/rust/commit/0dbaae4165b8ba41397a9b0f714acb2cd3610d65"}], "stats": {"total": 187, "additions": 47, "deletions": 140}, "files": [{"sha": "25cc82f01d5535822fc09611e7add79ab26c4a08", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=3a863e534bcba819a4ff8d8362df442001a3dd8a", "patch": "@@ -99,6 +99,17 @@ pub(super) trait GoalKind<'tcx>:\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n+    // Try equating an assumption predicate against a goal's predicate. If it\n+    // holds, then execute the `then` callback, which should do any additional\n+    // work, then produce a response (typically by executing\n+    // [`EvalCtxt::evaluate_added_goals_and_make_canonical_response`]).\n+    fn probe_and_match_goal_against_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n     // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n     // goal by equating it with the assumption.\n@@ -107,7 +118,12 @@ pub(super) trait GoalKind<'tcx>:\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.add_goals(requirements);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n \n     /// Consider a bound originating from the item bounds of an alias. For this we\n     /// require that the well-formed requirements of the self type of the goal\n@@ -117,7 +133,11 @@ pub(super) trait GoalKind<'tcx>:\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.validate_alias_bound_self_from_param_env(goal)\n+        })\n+    }\n \n     // Consider a clause specifically for a `dyn Trait` self type. This requires\n     // additionally checking all of the supertraits and object bounds to hold,\n@@ -126,7 +146,25 @@ pub(super) trait GoalKind<'tcx>:\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            let tcx = ecx.tcx();\n+            let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+            ecx.add_goals(\n+                structural_traits::predicates_for_object_candidate(\n+                    &ecx,\n+                    goal.param_env,\n+                    goal.predicate.trait_ref(tcx),\n+                    bounds,\n+                )\n+                .into_iter()\n+                .map(|pred| goal.with(tcx, pred)),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n \n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,"}, {"sha": "20ce2d9416e73eeeb3c30676a74dfc1735d05bcb", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 69, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=3a863e534bcba819a4ff8d8362df442001a3dd8a", "patch": "@@ -56,11 +56,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n@@ -75,73 +75,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n                     .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_alias_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.probe(|ecx| {\n-                let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)?;\n-                ecx.validate_alias_bound_self_from_param_env(goal)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.probe(|ecx| {\n-                let tcx = ecx.tcx();\n-\n-                let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.projection_ty.trait_ref(tcx),\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "dcfa33ae842e9b5f02d14dd9265055cb802bc02b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 68, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a863e534bcba819a4ff8d8362df442001a3dd8a/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=3a863e534bcba819a4ff8d8362df442001a3dd8a", "patch": "@@ -78,11 +78,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -97,72 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_alias_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-        {\n-            // FIXME: Constness and polarity\n-            ecx.probe(|ecx| {\n-                let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.trait_ref,\n-                    assumption_trait_pred.trait_ref,\n-                )?;\n-                ecx.validate_alias_bound_self_from_param_env(goal)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n-        {\n-            // FIXME: Constness and polarity\n-            ecx.probe(|ecx| {\n-                let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.trait_ref,\n-                    assumption_trait_pred.trait_ref,\n-                )?;\n-\n-                let tcx = ecx.tcx();\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.trait_ref,\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}]}