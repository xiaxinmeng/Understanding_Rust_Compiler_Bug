{"sha": "4f10f676d9e39940bf54ebfc7017f1505837532f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMTBmNjc2ZDllMzk5NDBiZjU0ZWJmYzcwMTdmMTUwNTgzNzUzMmY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-01T07:31:19Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:54:29Z"}, "message": "Handle relative paths", "tree": {"sha": "45c482fbc3abe2d2f20fa9f44e57223316eb58bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45c482fbc3abe2d2f20fa9f44e57223316eb58bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f10f676d9e39940bf54ebfc7017f1505837532f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f10f676d9e39940bf54ebfc7017f1505837532f", "html_url": "https://github.com/rust-lang/rust/commit/4f10f676d9e39940bf54ebfc7017f1505837532f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f10f676d9e39940bf54ebfc7017f1505837532f/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8166b59c74f423fbd9b5f1f21f63b9c1f972c9cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8166b59c74f423fbd9b5f1f21f63b9c1f972c9cc", "html_url": "https://github.com/rust-lang/rust/commit/8166b59c74f423fbd9b5f1f21f63b9c1f972c9cc"}], "stats": {"total": 104, "additions": 61, "deletions": 43}, "files": [{"sha": "07c940612b16cac6f302393c9df4b338b684db6b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4f10f676d9e39940bf54ebfc7017f1505837532f", "patch": "@@ -1413,25 +1413,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n \n     fn resolve_str_path(&mut self, span: Span, crate_root: Option<&str>,\n                 components: &[&str], is_value: bool) -> hir::Path {\n-        self.resolve_str_path_cb(span, crate_root, components, is_value,\n-                                 |resolver, span, error| resolve_error(resolver, span, error))\n-    }\n-\n-    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n-        self.def_map.get(&id).cloned()\n-    }\n-\n-    fn definitions(&mut self) -> &mut Definitions {\n-        &mut self.definitions\n-    }\n-}\n-\n-impl<'a> Resolver<'a> {\n-    /// resolve_str_path, but takes a callback in case there was an error\n-    fn resolve_str_path_cb<F>(&mut self, span: Span, crate_root: Option<&str>,\n-                components: &[&str], is_value: bool, error_callback: F) -> hir::Path \n-            where F: for<'b, 'c> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n-        {\n         use std::iter;\n         let mut path = hir::Path {\n             span,\n@@ -1441,19 +1422,45 @@ impl<'a> Resolver<'a> {\n             }).map(hir::PathSegment::from_name).collect(),\n         };\n \n-        self.resolve_hir_path_cb(&mut path, is_value, error_callback);\n+        self.resolve_hir_path(&mut path, is_value);\n         path\n     }\n \n+    fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution> {\n+        self.def_map.get(&id).cloned()\n+    }\n+\n+    fn definitions(&mut self) -> &mut Definitions {\n+        &mut self.definitions\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n     /// Rustdoc uses this to resolve things in a recoverable way. ResolutionError<'a>\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n     /// just that an error occured.\n-    pub fn resolve_str_path_error(&mut self, span: Span, crate_root: Option<&str>,\n-                components: &[&str], is_value: bool) -> Result<hir::Path, ()> {\n+    pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool) -> Result<hir::Path, ()> {\n+        use std::iter;\n         let mut errored = false;\n-        let path = self.resolve_str_path_cb(span, crate_root, components, is_value,\n-                                            |_, _, _| errored = true);\n+\n+        let mut path = if path_str.starts_with(\"::\") {\n+            hir::Path {\n+                span,\n+                def: Def::Err,\n+                segments: iter::once(keywords::CrateRoot.name()).chain({\n+                    path_str.split(\"::\").skip(1).map(Symbol::intern)\n+                }).map(hir::PathSegment::from_name).collect(),\n+            }\n+        } else {\n+            hir::Path {\n+                span,\n+                def: Def::Err,\n+                segments: path_str.split(\"::\").map(Symbol::intern)\n+                                  .map(hir::PathSegment::from_name).collect(),\n+            }\n+        };\n+        self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n         if errored || path.def == Def::Err {\n             Err(())\n         } else {\n@@ -1883,8 +1890,8 @@ impl<'a> Resolver<'a> {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope<F>(&mut self, id: NodeId, f: F)\n-        where F: FnOnce(&mut Resolver)\n+    pub fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut Resolver) -> T\n     {\n         let id = self.definitions.local_def_id(id);\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n@@ -1895,13 +1902,14 @@ impl<'a> Resolver<'a> {\n             self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n \n             self.finalize_current_module_macro_resolutions();\n-            f(self);\n+            let ret = f(self);\n \n             self.current_module = orig_module;\n             self.ribs[ValueNS].pop();\n             self.ribs[TypeNS].pop();\n+            ret\n         } else {\n-            f(self);\n+            f(self)\n         }\n     }\n "}, {"sha": "7daf8a7ae6d13e499a4cdeaee0d0581e050a6ad6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4f10f676d9e39940bf54ebfc7017f1505837532f", "patch": "@@ -472,6 +472,11 @@ impl Clean<Item> for doctree::Module {\n             \"\".to_string()\n         };\n \n+        // maintain a stack of mod ids\n+        // we could also pass this down through clean()\n+        // but that might complicate things.\n+        cx.mod_ids.borrow_mut().push(self.id);\n+\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n@@ -488,6 +493,8 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n+        cx.mod_ids.borrow_mut().pop();\n+\n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n         let whence = {\n@@ -847,21 +854,20 @@ impl Clean<Attributes> for [ast::Attribute] {\n                         link.trim()\n                     };\n \n-                    if !path_str.starts_with(\"::\") {\n-                        // FIXME (misdreavus): can only support absolute paths because of limitations\n-                        // in Resolver. this may, with a lot of effort, figure out how to resolve paths\n-                        // within scopes, but the one use of `resolve_hir_path` i found in the HIR\n-                        // lowering code itself used an absolute path. we're brushing up against some\n-                        // structural limitations in the compiler already, but this may be a design one\n-                        // as well >_>\n-                        continue;\n-                    }\n-\n-                    // This allocation could be avoided if resolve_str_path could take an iterator;\n-                    // but it can't because that would break object safety. This can still be\n-                    // fixed.\n-                    let components = path_str.split(\"::\").skip(1).collect::<Vec<_>>();\n-                    let resolve = |is_val| cx.resolver.borrow_mut().resolve_str_path_error(DUMMY_SP, None, &components, is_val);\n+                    let resolve = |is_val| {\n+                        // In case we're in a module, try to resolve the relative\n+                        // path\n+                        if let Some(id) = cx.mod_ids.borrow().last() {\n+                            cx.resolver.borrow_mut()\n+                                       .with_scope(*id, |resolver| {\n+                                            resolver.resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+                                        })\n+                        } else {\n+                            // FIXME(Manishearth) this branch doesn't seem to ever be hit, really\n+                            cx.resolver.borrow_mut()\n+                                       .resolve_str_path_error(DUMMY_SP, &path_str, is_val)\n+                        }\n+                    };\n \n                     if let Some(is_value) = is_value {\n                         if let Ok(path) = resolve(is_value) {"}, {"sha": "5fe4794389ff5a7cfe59a9d4f44cceb84fdf50d5", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f10f676d9e39940bf54ebfc7017f1505837532f/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=4f10f676d9e39940bf54ebfc7017f1505837532f", "patch": "@@ -23,6 +23,7 @@ use rustc_resolve as resolve;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n+use syntax::ast::NodeId;\n use syntax::codemap;\n use syntax::feature_gate::UnstableFeatures;\n use errors;\n@@ -47,6 +48,8 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub resolver: &'a RefCell<resolve::Resolver<'rcx>>,\n+    /// The stack of module NodeIds up till this point\n+    pub mod_ids: RefCell<Vec<NodeId>>,\n     pub populated_all_crate_impls: Cell<bool>,\n     // Note that external items for which `doc(hidden)` applies to are shown as\n     // non-reachable while local items aren't. This is because we're reusing\n@@ -243,6 +246,7 @@ pub fn run_core(search_paths: SearchPaths,\n             render_type,\n             ty_substs: Default::default(),\n             lt_substs: Default::default(),\n+            mod_ids: Default::default(),\n         };\n         debug!(\"crate: {:?}\", tcx.hir.krate());\n "}]}