{"sha": "47ad752e6cca5eb5499168ec7f859879e384a5ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YWQ3NTJlNmNjYTVlYjU0OTkxNjhlYzdmODU5ODc5ZTM4NGE1YWI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T20:03:31Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T20:03:31Z"}, "message": "Implement prev sibling determination for `CompletionContext`", "tree": {"sha": "1f54d1080184735cffd2c6ee3891e94510c2eefe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f54d1080184735cffd2c6ee3891e94510c2eefe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47ad752e6cca5eb5499168ec7f859879e384a5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47ad752e6cca5eb5499168ec7f859879e384a5ab", "html_url": "https://github.com/rust-lang/rust/commit/47ad752e6cca5eb5499168ec7f859879e384a5ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47ad752e6cca5eb5499168ec7f859879e384a5ab/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "html_url": "https://github.com/rust-lang/rust/commit/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749"}], "stats": {"total": 168, "additions": 114, "deletions": 54}, "files": [{"sha": "06789b704be7cc022beb5cfc7e5854bf1e751b0a", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=47ad752e6cca5eb5499168ec7f859879e384a5ab", "patch": "@@ -118,7 +118,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"let\", \"let \");\n     }\n \n-    if ctx.after_if {\n+    if ctx.after_if() {\n         add_keyword(\"else\", \"else {\\n    $0\\n}\");\n         add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n     }"}, {"sha": "8d6440cb23e69187f996b3d988fde88d8aa529c2", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=47ad752e6cca5eb5499168ec7f859879e384a5ab", "patch": "@@ -17,8 +17,8 @@ use text_edit::Indel;\n \n use crate::{\n     patterns::{\n-        determine_location, for_is_prev2, has_prev_sibling, inside_impl_trait_block,\n-        is_in_loop_body, is_match_arm, previous_token, ImmediateLocation,\n+        determine_location, determine_prev_sibling, for_is_prev2, inside_impl_trait_block,\n+        is_in_loop_body, is_match_arm, previous_token, ImmediateLocation, ImmediatePrevSibling,\n     },\n     CompletionConfig,\n };\n@@ -29,12 +29,6 @@ pub(crate) enum PatternRefutability {\n     Irrefutable,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum PrevSibling {\n-    Trait,\n-    Impl,\n-}\n-\n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n #[derive(Debug)]\n@@ -76,14 +70,14 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) is_param: bool,\n \n     pub(super) completion_location: Option<ImmediateLocation>,\n+    pub(super) prev_sibling: Option<ImmediatePrevSibling>,\n \n     /// FIXME: `ActiveParameter` is string-based, which is very very wrong\n     pub(super) active_parameter: Option<ActiveParameter>,\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n     pub(super) path_qual: Option<ast::Path>,\n-    pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n     pub(super) can_be_stmt: bool,\n     /// `true` if we expect an expression at the cursor position.\n@@ -107,7 +101,6 @@ pub(crate) struct CompletionContext<'a> {\n \n     // keyword patterns\n     pub(super) previous_token: Option<SyntaxToken>,\n-    pub(super) prev_sibling: Option<PrevSibling>,\n     pub(super) in_loop_body: bool,\n     pub(super) is_match_arm: bool,\n     pub(super) incomplete_let: bool,\n@@ -173,7 +166,6 @@ impl<'a> CompletionContext<'a> {\n             is_pat_or_const: None,\n             is_trivial_path: false,\n             path_qual: None,\n-            after_if: false,\n             can_be_stmt: false,\n             is_expr: false,\n             is_new_item: false,\n@@ -308,7 +300,14 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn has_impl_or_trait_prev_sibling(&self) -> bool {\n-        self.prev_sibling.is_some()\n+        matches!(\n+            self.prev_sibling,\n+            Some(ImmediatePrevSibling::ImplDefType) | Some(ImmediatePrevSibling::TraitDefName)\n+        )\n+    }\n+\n+    pub(crate) fn after_if(&self) -> bool {\n+        matches!(self.prev_sibling, Some(ImmediatePrevSibling::IfExpr))\n     }\n \n     pub(crate) fn is_path_disallowed(&self) -> bool {\n@@ -324,11 +323,6 @@ impl<'a> CompletionContext<'a> {\n         self.previous_token = previous_token(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n-        if has_prev_sibling(syntax_element.clone(), IMPL) {\n-            self.prev_sibling = Some(PrevSibling::Impl)\n-        } else if has_prev_sibling(syntax_element.clone(), TRAIT) {\n-            self.prev_sibling = Some(PrevSibling::Trait)\n-        }\n \n         self.mod_declaration_under_caret =\n             find_node_at_offset::<ast::Module>(&file_with_fake_ident, offset)\n@@ -468,6 +462,7 @@ impl<'a> CompletionContext<'a> {\n             None => return,\n         };\n         self.completion_location = determine_location(&name_like);\n+        self.prev_sibling = determine_prev_sibling(&name_like);\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.classify_lifetime(original_file, lifetime, offset);\n@@ -656,17 +651,6 @@ impl<'a> CompletionContext<'a> {\n                 })\n                 .unwrap_or(false);\n             self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n-\n-            if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n-                if let Some(if_expr) =\n-                    self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n-                {\n-                    if if_expr.syntax().text_range().end() < name_ref.syntax().text_range().start()\n-                    {\n-                        self.after_if = true;\n-                    }\n-                }\n-            }\n         }\n \n         if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {"}, {"sha": "8c4bdbed24df65227cac897371e6a6164d2a0d14", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 101, "deletions": 25, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47ad752e6cca5eb5499168ec7f859879e384a5ab/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=47ad752e6cca5eb5499168ec7f859879e384a5ab", "patch": "@@ -4,12 +4,19 @@ use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n-    SyntaxKind::{self, *},\n+    SyntaxKind::*,\n     SyntaxNode, SyntaxToken, T,\n };\n \n #[cfg(test)]\n use crate::test_utils::{check_pattern_is_applicable, check_pattern_is_not_applicable};\n+/// Direct parent container of the cursor position\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum ImmediatePrevSibling {\n+    IfExpr,\n+    TraitDefName,\n+    ImplDefType,\n+}\n \n /// Direct parent container of the cursor position\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -24,35 +31,61 @@ pub(crate) enum ImmediateLocation {\n     ItemList,\n }\n \n-pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateLocation> {\n-    // First walk the element we are completing up to its highest node that has the same text range\n-    // as the element so that we can check in what context it immediately lies. We only do this for\n-    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n-    // We only wanna do this if the NameRef is the last segment of the path.\n-    let node = match name_like {\n-        ast::NameLike::NameRef(name_ref) => {\n-            if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n-                let p = segment.parent_path();\n-                if p.parent_path().is_none() {\n-                    p.syntax()\n-                        .ancestors()\n-                        .take_while(|it| it.text_range() == p.syntax().text_range())\n-                        .last()?\n-                } else {\n-                    return None;\n+pub(crate) fn determine_prev_sibling(name_like: &ast::NameLike) -> Option<ImmediatePrevSibling> {\n+    let node = maximize_name_ref(name_like)?;\n+    let node = match node.parent().and_then(ast::MacroCall::cast) {\n+        // When a path is being typed after the name of a trait/type of an impl it is being\n+        // parsed as a macro, so when the trait/impl has a block following it an we are between the\n+        // name and block the macro will attach the block to itself so maximizing fails to take\n+        // that into account\n+        // FIXME path expr and statement have a similar problem with attrs\n+        Some(call)\n+            if call.excl_token().is_none()\n+                && call.token_tree().map_or(false, |t| t.l_curly_token().is_some())\n+                && call.semicolon_token().is_none() =>\n+        {\n+            call.syntax().clone()\n+        }\n+        _ => node,\n+    };\n+    let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+    let res = match_ast! {\n+        match prev_sibling {\n+            ast::ExprStmt(it) => {\n+                let node = it.expr()?.syntax().clone();\n+                match_ast! {\n+                    match node {\n+                        ast::IfExpr(_it) => ImmediatePrevSibling::IfExpr,\n+                        _ => return None,\n+                    }\n                 }\n-            } else {\n-                return None;\n-            }\n+            },\n+            ast::Trait(it) => if it.assoc_item_list().is_none() {\n+                    ImmediatePrevSibling::TraitDefName\n+                } else {\n+                    return None\n+            },\n+            ast::Impl(it) => if it.assoc_item_list().is_none()\n+                && (it.for_token().is_none() || it.self_ty().is_some()) {\n+                    ImmediatePrevSibling::ImplDefType\n+                } else {\n+                    return None\n+            },\n+            _ => return None,\n         }\n-        it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n     };\n+    Some(res)\n+}\n+\n+pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateLocation> {\n+    let node = maximize_name_ref(name_like)?;\n     let parent = match node.parent() {\n         Some(parent) => match ast::MacroCall::cast(parent.clone()) {\n             // When a path is being typed in an (Assoc)ItemList the parser will always emit a macro_call.\n             // This is usually fine as the node expansion code above already accounts for that with\n             // the ancestors call, but there is one exception to this which is that when an attribute\n             // precedes it the code above will not walk the Path to the parent MacroCall as their ranges differ.\n+            // FIXME path expr and statement have a similar problem\n             Some(call)\n                 if call.excl_token().is_none()\n                     && call.token_tree().is_none()\n@@ -90,6 +123,32 @@ pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateL\n     Some(res)\n }\n \n+fn maximize_name_ref(name_like: &ast::NameLike) -> Option<SyntaxNode> {\n+    // First walk the element we are completing up to its highest node that has the same text range\n+    // as the element so that we can check in what context it immediately lies. We only do this for\n+    // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n+    // We only wanna do this if the NameRef is the last segment of the path.\n+    let node = match name_like {\n+        ast::NameLike::NameRef(name_ref) => {\n+            if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n+                let p = segment.parent_path();\n+                if p.parent_path().is_none() {\n+                    p.syntax()\n+                        .ancestors()\n+                        .take_while(|it| it.text_range() == p.syntax().text_range())\n+                        .last()?\n+                } else {\n+                    return None;\n+                }\n+            } else {\n+                return None;\n+            }\n+        }\n+        it @ ast::NameLike::Name(_) | it @ ast::NameLike::Lifetime(_) => it.syntax().clone(),\n+    };\n+    Some(node)\n+}\n+\n #[cfg(test)]\n fn check_location(code: &str, loc: ImmediateLocation) {\n     check_pattern_is_applicable(code, |e| {\n@@ -192,17 +251,34 @@ fn test_for_is_prev2() {\n     check_pattern_is_applicable(r\"for i i$0\", for_is_prev2);\n }\n \n-pub(crate) fn has_prev_sibling(element: SyntaxElement, kind: SyntaxKind) -> bool {\n-    previous_sibling_or_ancestor_sibling(element).filter(|it| it.kind() == kind).is_some()\n+#[cfg(test)]\n+fn check_prev_sibling(code: &str, sibling: impl Into<Option<ImmediatePrevSibling>>) {\n+    check_pattern_is_applicable(code, |e| {\n+        let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+        assert_eq!(determine_prev_sibling(name), sibling.into());\n+        true\n+    });\n }\n+\n #[test]\n fn test_has_impl_as_prev_sibling() {\n-    check_pattern_is_applicable(r\"impl A w$0 {}\", |it| has_prev_sibling(it, IMPL));\n+    check_prev_sibling(r\"impl A w$0 \", ImmediatePrevSibling::ImplDefType);\n+    check_prev_sibling(r\"impl A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+    check_prev_sibling(r\"impl A for A w$0 \", ImmediatePrevSibling::ImplDefType);\n+    check_prev_sibling(r\"impl A for A w$0 {}\", ImmediatePrevSibling::ImplDefType);\n+    check_prev_sibling(r\"impl A for w$0 {}\", None);\n+    check_prev_sibling(r\"impl A for w$0\", None);\n }\n \n #[test]\n fn test_has_trait_as_prev_sibling() {\n-    check_pattern_is_applicable(r\"trait A w$0 {}\", |it| has_prev_sibling(it, TRAIT));\n+    check_prev_sibling(r\"trait A w$0 \", ImmediatePrevSibling::TraitDefName);\n+    check_prev_sibling(r\"trait A w$0 {}\", ImmediatePrevSibling::TraitDefName);\n+}\n+\n+#[test]\n+fn test_has_if_expr_as_prev_sibling() {\n+    check_prev_sibling(r\"fn foo() { if true {} w$0\", ImmediatePrevSibling::IfExpr);\n }\n \n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {"}]}