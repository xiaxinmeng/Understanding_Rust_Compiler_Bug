{"sha": "c7bd3f695b62a49d73b2f322681d0b1550e8a055", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YmQzZjY5NWI2MmE0OWQ3M2IyZjMyMjY4MWQwYjE1NTBlOGEwNTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-03T02:44:18Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-09-03T02:44:18Z"}, "message": "Merge remote-tracking branch 'graydon/master'", "tree": {"sha": "358daa3dbd66b22aec8080053cd08d688669613a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/358daa3dbd66b22aec8080053cd08d688669613a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7bd3f695b62a49d73b2f322681d0b1550e8a055", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bd3f695b62a49d73b2f322681d0b1550e8a055", "html_url": "https://github.com/rust-lang/rust/commit/c7bd3f695b62a49d73b2f322681d0b1550e8a055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7bd3f695b62a49d73b2f322681d0b1550e8a055/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07691e725a3528613625bbbc6462ff27321a8302", "url": "https://api.github.com/repos/rust-lang/rust/commits/07691e725a3528613625bbbc6462ff27321a8302", "html_url": "https://github.com/rust-lang/rust/commit/07691e725a3528613625bbbc6462ff27321a8302"}, {"sha": "b5f905342337a3dc12bdc5dc6d98d3ecdf60439d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f905342337a3dc12bdc5dc6d98d3ecdf60439d", "html_url": "https://github.com/rust-lang/rust/commit/b5f905342337a3dc12bdc5dc6d98d3ecdf60439d"}], "stats": {"total": 368, "additions": 248, "deletions": 120}, "files": [{"sha": "73627cfc67a442c090df0fab2831411728b927a1", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -126,6 +126,11 @@ fn largest_variants(ccx: &@crate_ctxt, tag_id: &ast::def_id) -> [uint] {\n                 // when in fact it has minimum size sizeof(int).\n                 bounded = false;\n             } else {\n+                // Could avoid this check: the constraint should\n+                // follow from how elem_t doesn't contain params.\n+                // (Could add a postcondition to type_contains_params,\n+                // once we implement Issue #586.)\n+                check trans_common::type_has_static_size(ccx, elem_t);\n                 let llty = trans::type_of(ccx, dummy_sp(), elem_t);\n                 min_size += trans::llsize_of_real(ccx, llty);\n                 min_align += trans::llalign_of_real(ccx, llty);\n@@ -201,6 +206,10 @@ fn compute_static_tag_size(ccx: &@crate_ctxt, largest_variants: &[uint],\n         // We increment a \"virtual data pointer\" to compute the size.\n         let lltys = [];\n         for typ: ty::t in variants[vid].args {\n+            // FIXME: there should really be a postcondition\n+            // on tag_variants that would obviate the need for\n+            // this check. (Issue #586)\n+            check trans_common::type_has_static_size(ccx, typ);\n             lltys += [trans::type_of(ccx, dummy_sp(), typ)];\n         }\n "}, {"sha": "315b11340babc2322e7fef4508d1e744afd151df", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 196, "deletions": 112, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -74,18 +74,8 @@ import trans_objects::trans_anon_obj;\n import trans_objects::trans_obj;\n import tvec = trans_vec;\n \n-// This function now fails if called on a type with dynamic size (as its\n-// return value was always meaningless in that case anyhow). Beware!\n-//\n-// TODO: Enforce via a predicate.\n-fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n-    if ty::type_has_dynamic_size(cx.tcx, t) {\n-        cx.sess.span_fatal(sp,\n-                           ~\"type_of() called on a type with dynamic size: \" +\n-                           ty_to_str(cx.tcx, t));\n-    }\n-    ret type_of_inner(cx, sp, t);\n-}\n+fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t)\n+    : type_has_static_size(cx, t) -> TypeRef { type_of_inner(cx, sp, t) }\n \n fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n    [TypeRef] {\n@@ -171,6 +161,8 @@ fn type_of_native_fn(cx: &@crate_ctxt, sp: &span, abi: ast::native_abi,\n     ret T_fn(atys, type_of_inner(cx, sp, output));\n }\n \n+/* FIXME: could add type_has_static_size as a constraint,\n+   allowing us to get rid of some impossible cases. */\n fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n     // Check the cache.\n \n@@ -263,23 +255,33 @@ fn type_of_tag(cx: &@crate_ctxt, sp: &span, did: &ast::def_id, t: ty::t) ->\n \n fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: &span,\n                                  tpt: &ty::ty_param_kinds_and_ty) -> TypeRef {\n-    alt ty::struct(lcx.ccx.tcx, tpt.ty) {\n+    let cx = lcx.ccx;\n+    let t = tpt.ty;\n+    alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_, _, _, _, _) {\n         let llfnty =\n-            type_of_fn_from_ty(lcx.ccx, sp, tpt.ty, std::vec::len(tpt.kinds));\n-        ret T_fn_pair(*lcx.ccx, llfnty);\n+            type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n+        ret T_fn_pair(*cx, llfnty);\n       }\n       _ {\n         // fall through\n       }\n     }\n-    ret type_of(lcx.ccx, sp, tpt.ty);\n+    // FIXME: could have a precondition on tpt, but that\n+    // doesn't work right now because one predicate can't imply\n+    // another\n+    check type_has_static_size(cx, t);\n+    type_of(cx, sp, t)\n }\n \n fn type_of_or_i8(bcx: &@block_ctxt, typ: ty::t) -> TypeRef {\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), typ) { ret T_i8(); }\n-    ret type_of(bcx_ccx(bcx), bcx.sp, typ);\n-}\n+    let ccx = bcx_ccx(bcx);\n+    if check type_has_static_size(ccx, typ) {\n+        let sp = bcx.sp;\n+        type_of(ccx, sp, typ)\n+    }\n+    else { T_i8() }\n+ }\n \n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n@@ -452,17 +454,25 @@ fn llalign_of(t: TypeRef) -> ValueRef {\n }\n \n fn size_of(cx: &@block_ctxt, t: ty::t) -> result {\n-    if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n-        ret rslt(cx, llsize_of(type_of(bcx_ccx(cx), cx.sp, t)));\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llsize_of(type_of(ccx, sp, t)))\n+    }\n+    else {\n+        dynamic_size_of(cx, t)\n     }\n-    ret dynamic_size_of(cx, t);\n }\n \n fn align_of(cx: &@block_ctxt, t: ty::t) -> result {\n-    if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n-        ret rslt(cx, llalign_of(type_of(bcx_ccx(cx), cx.sp, t)));\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llalign_of(type_of(ccx, sp, t)))\n+    }\n+    else {\n+        dynamic_align_of(cx, t)\n     }\n-    ret dynamic_align_of(cx, t);\n }\n \n fn alloca(cx: &@block_ctxt, t: TypeRef) -> ValueRef {\n@@ -551,6 +561,10 @@ fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n             tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n             // Here we possibly do a recursive call.\n \n+            // FIXME: Avoid this check. Since the parent has static\n+            // size, any field must as well. There should be a way to\n+            // express that with constrained types.\n+            check type_has_static_size(cx, tup_ty);\n             let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n@@ -682,9 +696,13 @@ fn bump_ptr(bcx: &@block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n     let bumped = GEP(bcx, raw, [sz]);\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), t) { ret bumped; }\n-    let typ = T_ptr(type_of(bcx_ccx(bcx), bcx.sp, t));\n-    ret PointerCast(bcx, bumped, typ);\n+    let ccx = bcx_ccx(bcx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = bcx.sp;\n+        let typ = T_ptr(type_of(ccx, sp, t));\n+        PointerCast(bcx, bumped, typ)\n+    }\n+    else { bumped }\n }\n \n // Replacement for the LLVM 'GEP' instruction when field-indexing into a\n@@ -800,20 +818,25 @@ fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: &ast::def_id,\n     // the blob pointer isn't dynamically sized).\n \n     let llunionptr: ValueRef;\n-    if !ty::type_has_dynamic_size(bcx_tcx(cx), tup_ty) {\n-        let llty = type_of(bcx_ccx(cx), cx.sp, tup_ty);\n+    let sp = cx.sp;\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, tup_ty) {\n+        let llty = type_of(ccx, sp, tup_ty);\n         llunionptr = TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n-    } else { llunionptr = llblobptr; }\n-    // Do the GEP_tup_like().\n+    }\n+    else { llunionptr = llblobptr; }\n \n+    // Do the GEP_tup_like().\n     let rs = GEP_tup_like(cx, tup_ty, llunionptr, [0, ix as int]);\n     // Cast the result to the appropriate type, if necessary.\n \n-    let val;\n-    if !ty::type_has_dynamic_size(bcx_tcx(cx), elem_ty) {\n-        let llelemty = type_of(bcx_ccx(rs.bcx), cx.sp, elem_ty);\n-        val = PointerCast(rs.bcx, rs.val, T_ptr(llelemty));\n-    } else { val = rs.val; }\n+    let rs_ccx = bcx_ccx(rs.bcx);\n+    let val = if check type_has_static_size(rs_ccx, elem_ty) {\n+        let llelemty = type_of(rs_ccx, sp, elem_ty);\n+        PointerCast(rs.bcx, rs.val, T_ptr(llelemty))\n+    }\n+    else { rs.val };\n+\n     ret rslt(rs.bcx, val);\n }\n \n@@ -863,7 +886,12 @@ fn trans_malloc_boxed_raw(cx: &@block_ctxt, t: ty::t) -> result {\n \n     // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n     // wants.\n-    let llty = type_of(bcx_ccx(cx), cx.sp, box_ptr);\n+    // FIXME: Could avoid this check with a postcondition on mk_imm_box?\n+    // (requires Issue #586)\n+    let ccx = bcx_ccx(cx);\n+    let sp = cx.sp;\n+    check type_has_static_size(ccx, box_ptr);\n+    let llty = type_of(ccx, sp, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n }\n \n@@ -1123,7 +1151,7 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n     let ccx = cx.ccx;\n     let llsize;\n     let llalign;\n-    if !ty::type_has_dynamic_size(ccx.tcx, t) {\n+    if check type_has_static_size(ccx, t) {\n         let llty = type_of(ccx, sp, t);\n         llsize = llsize_of(llty);\n         llalign = llalign_of(llty);\n@@ -1187,10 +1215,11 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: ty::t,\n     // the caller has no idea if it's dealing with something that can be\n     // passed by value.\n \n-    let llty;\n-    if ty::type_has_dynamic_size(cx.ccx.tcx, t) {\n-        llty = T_ptr(T_i8());\n-    } else { llty = T_ptr(type_of(cx.ccx, sp, t)); }\n+    let ccx = cx.ccx;\n+    let llty = if check type_has_static_size(ccx, t) {\n+        T_ptr(type_of(ccx, sp, t))\n+    } else { T_ptr(T_i8()) };\n+\n     let ty_param_count = std::vec::len::<uint>(ty_params);\n     let lltyparams = llvm::LLVMGetParam(llfn, 3u);\n     let copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n@@ -1784,11 +1813,15 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n                        elt_ty: &ty::t, f: &val_and_ty_fn) -> @block_ctxt {\n     fn adaptor_fn(f: val_and_ty_fn, elt_ty: ty::t, cx: &@block_ctxt,\n                   _dst: ValueRef, src: ValueRef) -> @block_ctxt {\n-        let llptrty;\n-        if !ty::type_has_dynamic_size(bcx_tcx(cx), elt_ty) {\n-            let llty = type_of(bcx_ccx(cx), cx.sp, elt_ty);\n-            llptrty = T_ptr(llty);\n-        } else { llptrty = T_ptr(T_ptr(T_i8())); }\n+        let ccx = bcx_ccx(cx);\n+        let sp = cx.sp;\n+        let llptrty =\n+          if check type_has_static_size(ccx, elt_ty) {\n+              let llty = type_of(ccx, sp, elt_ty);\n+              T_ptr(llty)\n+          }\n+          else { T_ptr(T_ptr(T_i8())) };\n+\n         let p = PointerCast(cx, src, llptrty);\n         ret f(cx, load_if_immediate(cx, p, elt_ty), elt_ty);\n     }\n@@ -2083,13 +2116,18 @@ fn call_bzero(cx: &@block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n \n fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n    result {\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        if ty::type_is_structural(bcx_tcx(cx), t) {\n+            let sp = cx.sp;\n+            let llsz = llsize_of(type_of(ccx, sp, t));\n+            ret call_memmove(cx, dst, src, llsz);\n+        } else { ret rslt(cx, Store(cx, Load(cx, src), dst)); }\n+    }\n+    else {\n         let llsz = size_of(cx, t);\n         ret call_memmove(llsz.bcx, dst, src, llsz.val);\n-    } else if ty::type_is_structural(bcx_tcx(cx), t) {\n-        let llsz = llsize_of(type_of(bcx_ccx(cx), cx.sp, t));\n-        ret call_memmove(cx, dst, src, llsz);\n-    } else { ret rslt(cx, Store(cx, Load(cx, src), dst)); }\n+    }\n }\n \n tag copy_action { INIT; DROP_EXISTING; }\n@@ -2259,7 +2297,12 @@ fn node_id_type(cx: &@crate_ctxt, id: ast::node_id) -> ty::t {\n }\n \n fn node_type(cx: &@crate_ctxt, sp: &span, id: ast::node_id) -> TypeRef {\n-    ret type_of(cx, sp, node_id_type(cx, id));\n+    let ty = node_id_type(cx, id);\n+    // How to make this a precondition?\n+    // FIXME (again, would require a predicate that implies\n+    // another predicate)\n+    check type_has_static_size(cx, ty);\n+    type_of(cx, sp, ty)\n }\n \n fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n@@ -2286,10 +2329,14 @@ fn trans_unary(cx: &@block_ctxt, op: ast::unop, e: &@ast::expr,\n         // Cast the body type to the type of the value. This is needed to\n         // make tags work, since tags have a different LLVM type depending\n         // on whether they're boxed or not.\n-        if !ty::type_has_dynamic_size(bcx_tcx(cx), e_ty) {\n-            let llety = T_ptr(type_of(bcx_ccx(sub.bcx), e.span, e_ty));\n+        let sub_ccx = bcx_ccx(sub.bcx);\n+        if check type_has_static_size(sub_ccx, e_ty) {\n+            let e_sp = e.span;\n+            let llety = T_ptr(type_of(sub_ccx, e_sp, e_ty));\n             body = PointerCast(sub.bcx, body, llety);\n         }\n+        else {} // FIXME: can remove the else{} once we have\n+                // a new snapshot\n         let bcx = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n         ret rslt(bcx, sub.box);\n       }\n@@ -2387,6 +2434,7 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n     let ccx = bcx_ccx(cx);\n+    let sp = cx.sp;\n     while true {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n@@ -2398,8 +2446,8 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             // to cast this pointer, since statically-sized tag types have\n             // different types depending on whether they're behind a box\n             // or not.\n-            if !ty::type_has_dynamic_size(ccx.tcx, mt.ty) {\n-                let llty = type_of(ccx, cx.sp, mt.ty);\n+            if check type_has_static_size(ccx, t1) {\n+                let llty = type_of(ccx, sp, t1);\n                 v1 = PointerCast(cx, body, T_ptr(llty));\n             } else { v1 = body; }\n           }\n@@ -2416,9 +2464,10 @@ fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             }\n             t1 =\n                 ty::substitute_type_params(ccx.tcx, tps, variants[0].args[0]);\n-            if !ty::type_has_dynamic_size(ccx.tcx, t1) {\n-                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, cx.sp, t1)));\n+            if check type_has_static_size(ccx, t1) {\n+                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, sp, t1)));\n             }\n+            else {} // FIXME: typestate hack\n           }\n           _ { break; }\n         }\n@@ -2756,7 +2805,13 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n-    let llty = type_of(bcx_ccx(bcx), bcx.sp, ty);\n+\n+    let ccx = bcx_ccx(bcx);\n+    let sp = bcx.sp;\n+    // FIXME: should have postcondition on mk_imm_box,\n+    // so this check won't be necessary\n+    check type_has_static_size(ccx, ty);\n+    let llty = type_of(ccx, sp, ty);\n     let llclosure = PointerCast(bcx, fcx.llenv, llty);\n \n     // Populate the type parameters from the environment. We need to\n@@ -3161,25 +3216,24 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     let bounds_check = ICmp(bcx, lib::llvm::LLVMIntULT, scaled_ix, lim);\n     let fail_cx = new_sub_block_ctxt(bcx, ~\"fail\");\n     let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n+    let ncx = bcx_ccx(next_cx);\n     CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n     trans_fail(fail_cx, some::<span>(sp), ~\"bounds check\");\n-    let elt;\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        body = PointerCast(next_cx, body, T_ptr(T_i8()));\n-        elt = GEP(next_cx, body, [scaled_ix]);\n-    } else {\n-        elt = GEP(next_cx, body, [ix_val]);\n-        // We're crossing a box boundary here, so we may need to pointer cast.\n+    let elt = if check type_has_static_size(ncx, unit_ty) {\n+          let elt_1 = GEP(next_cx, body, [ix_val]);\n+          let llunitty = type_of(ncx, sp, unit_ty);\n+          PointerCast(next_cx, elt_1, T_ptr(llunitty))\n+      }\n+      else {\n+          body = PointerCast(next_cx, body, T_ptr(T_i8()));\n+          GEP(next_cx, body, [scaled_ix])\n+      };\n \n-        let llunitty = type_of(bcx_ccx(next_cx), sp, unit_ty);\n-        elt = PointerCast(next_cx, elt, T_ptr(llunitty));\n-    }\n     ret lval_mem(next_cx, elt);\n }\n \n-\n // The additional bool returned indicates whether it's mem (that is\n // represented as an alloca or heap, hence needs a 'load' to be used as an\n // immediate).\n@@ -3211,10 +3265,11 @@ fn trans_lval_gen(cx: &@block_ctxt, e: &@ast::expr) -> lval_result {\n               }\n               ty::ty_tag(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n-                let ellty;\n-                if ty::type_has_dynamic_size(ccx.tcx, ety) {\n-                    ellty = T_typaram_ptr(ccx.tn);\n-                } else { ellty = T_ptr(type_of(ccx, e.span, ety)); }\n+                let sp = e.span;\n+                let ellty = if check type_has_static_size(ccx, ety) {\n+                    T_ptr(type_of(ccx, sp, ety))\n+                }\n+                else { T_typaram_ptr(ccx.tn) };\n                 PointerCast(sub.bcx, sub.val, ellty)\n               }\n               ty::ty_ptr(_) { sub.val }\n@@ -3291,6 +3346,9 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n     let ll_t_in = val_ty(e_res.val);\n     let t_in = ty::expr_ty(ccx.tcx, e);\n     let t_out = node_id_type(ccx, id);\n+    // Check should be avoidable because it's a cast.\n+    // FIXME: Constrain types so as to avoid this check.\n+    check type_has_static_size(ccx, t_out);\n     let ll_t_out = type_of(ccx, e.span, t_out);\n \n     tag kind { native_; integral; float; other; }\n@@ -3343,7 +3401,12 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n                     outgoing_fty: ty::t, args: &[option::t<@ast::expr>],\n                     env_ty: ty::t, ty_param_count: uint,\n                     target_fn: &option::t<ValueRef>) ->\n-   {val: ValueRef, ty: TypeRef} {\n+    {val: ValueRef, ty: TypeRef} {\n+    // FIXME\n+    // This should be a precondition on trans_bind_thunk, but we would need\n+    // to support record fields as constraint args\n+    let ccx = cx.ccx;\n+    check type_has_static_size(ccx, incoming_fty);\n \n     // Here we're not necessarily constructing a thunk in the sense of\n     // \"function with no arguments\".  The result of compiling 'bind f(foo,\n@@ -3368,14 +3431,11 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n \n     // Give the thunk a name, type, and value.\n     let s: istr =\n-        mangle_internal_name_by_path_and_seq(cx.ccx,\n-                                             cx.path,\n-                                             ~\"thunk\");\n+        mangle_internal_name_by_path_and_seq(ccx, cx.path, ~\"thunk\");\n     let llthunk_ty: TypeRef =\n-        get_pair_fn_ty(type_of(cx.ccx, sp, incoming_fty));\n+        get_pair_fn_ty(type_of(ccx, sp, incoming_fty));\n     let llthunk: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod,\n-                                  s, llthunk_ty);\n+        decl_internal_fastcall_fn(ccx.llmod, s, llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n@@ -3394,8 +3454,11 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n \n     // The llenv pointer needs to be the correct size.  That size is\n     // 'closure_ty', which was determined by trans_bind.\n-    let closure_ty = ty::mk_imm_box(cx.ccx.tcx, env_ty);\n-    let llclosure_ptr_ty = type_of(cx.ccx, sp, closure_ty);\n+    let closure_ty = ty::mk_imm_box(ccx.tcx, env_ty);\n+    // FIXME: would be nice to have a postcondition on mk_imm_box\n+    // (Issue #586)\n+    check type_has_static_size(ccx, closure_ty);\n+    let llclosure_ptr_ty = type_of(ccx, sp, closure_ty);\n     let llclosure =\n         PointerCast(copy_args_bcx, fcx.llenv, llclosure_ptr_ty);\n \n@@ -3554,6 +3617,9 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n     }\n     let bcx = f_res.res.bcx;\n \n+    // FIXME: should follow from a precondition on trans_bind_1\n+    let ccx = bcx_ccx(cx);\n+    check type_has_static_size(ccx, outgoing_fty);\n \n     // Arrange for the bound function to live in the first binding spot\n     // if the function is not statically known.\n@@ -3562,8 +3628,8 @@ fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n             // Cast the function we are binding to be the type that the\n             // closure will expect it to have. The type the closure knows\n             // about has the type parameters substituted with the real types.\n-            let llclosurety =\n-                T_ptr(type_of(bcx_ccx(cx), cx.sp, outgoing_fty));\n+            let sp = cx.sp;\n+            let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n             let src_loc = PointerCast(bcx, f_res.res.val, llclosurety);\n             let bound_f = {res: {bcx: bcx, val: src_loc} with f_res};\n             ([outgoing_fty], [bound_f], none)\n@@ -4545,14 +4611,17 @@ fn init_local(bcx: @block_ctxt, local: &@ast::local) -> result {\n \n fn zero_alloca(cx: &@block_ctxt, llptr: ValueRef, t: ty::t) -> result {\n     let bcx = cx;\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        let llty = type_of(ccx, sp, t);\n+        Store(bcx, C_null(llty), llptr);\n+    }\n+    else {\n         let llsz = size_of(bcx, t);\n         // FIXME passing in the align here is correct, but causes issue #843\n         // let llalign = align_of(llsz.bcx, t);\n         bcx = call_bzero(llsz.bcx, llptr, llsz.val, C_int(0)).bcx;\n-    } else {\n-        let llty = type_of(bcx_ccx(bcx), cx.sp, t);\n-        Store(bcx, C_null(llty), llptr);\n     }\n     ret rslt(bcx, llptr);\n }\n@@ -4713,19 +4782,22 @@ fn llderivedtydescs_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n \n fn alloc_ty(cx: &@block_ctxt, t: ty::t) -> result {\n     let bcx = cx;\n-    let val = C_int(0);\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), t) {\n+    let ccx = bcx_ccx(cx);\n+    let val = if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        alloca(bcx, type_of(ccx, sp, t))\n+    }\n+    else {\n         // NB: we have to run this particular 'size_of' in a\n         // block_ctxt built on the llderivedtydescs block for the fn,\n         // so that the size dominates the array_alloca that\n         // comes next.\n \n         let n = size_of(llderivedtydescs_block_ctxt(bcx.fcx), t);\n         bcx.fcx.llderivedtydescs = n.bcx.llbb;\n-        val = dynastack_alloca(bcx, T_i8(), n.val, t);\n-    } else {\n-        val = alloca(bcx, type_of(bcx_ccx(cx), cx.sp, t));\n-    }\n+        dynastack_alloca(bcx, T_i8(), n.val, t)\n+    };\n+\n     // NB: since we've pushed all size calculations in this\n     // function up to the alloca block, we actually return the\n     // block passed into us unmodified; it doesn't really\n@@ -5035,10 +5107,14 @@ fn populate_fn_ctxt_from_llself(fcx: @fn_ctxt, llself: val_self_pair) {\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n     // i8 *.\n \n-    if !ty::type_has_dynamic_size(fcx.lcx.ccx.tcx, fields_tup_ty) {\n-        let llfields_ty = type_of(fcx.lcx.ccx, fcx.sp, fields_tup_ty);\n+    let ccx = fcx.lcx.ccx;\n+    if check type_has_static_size(ccx, fields_tup_ty) {\n+        let sp = fcx.sp;\n+        let llfields_ty = type_of(ccx, sp, fields_tup_ty);\n         obj_fields = vi2p(bcx, obj_fields, T_ptr(llfields_ty));\n-    } else { obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8())); }\n+    }\n+    else { obj_fields = vi2p(bcx, obj_fields, T_ptr(T_i8())); }\n+\n     let i: int = 0;\n     for p: ast::ty_param in fcx.lcx.obj_typarams {\n         let lltyparam: ValueRef =\n@@ -5644,8 +5720,13 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n                           mode: ty::mode) -> ValueRef {\n         if mode == ty::mo_val {\n             if ty::type_is_integral(bcx_tcx(cx), t) {\n+                // FIXME: would be nice to have a postcondition that says\n+                // if a type is integral, then it has static size (#586)\n                 let lldsttype = T_int();\n-                let llsrctype = type_of(bcx_ccx(cx), cx.sp, t);\n+                let ccx = bcx_ccx(cx);\n+                let sp = cx.sp;\n+                check type_has_static_size(ccx, t);\n+                let llsrctype = type_of(ccx, sp, t);\n                 if llvm::LLVMGetIntTypeWidth(lldsttype) >\n                        llvm::LLVMGetIntTypeWidth(llsrctype) {\n                     ret ZExtOrBitCast(cx, v, T_int());\n@@ -5665,20 +5746,20 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[istr],\n        {val: ValueRef, rptr: ValueRef} {\n         let call_arg_tys: [TypeRef] = [];\n         for arg: ValueRef in call_args { call_arg_tys += [val_ty(arg)]; }\n+        let ccx = bcx_ccx(bcx);\n \n-        let llnativefnty;\n-        if uses_retptr {\n-            llnativefnty = T_fn(call_arg_tys, T_void());\n-        } else {\n-            llnativefnty =\n-                T_fn(call_arg_tys,\n-                     type_of(bcx_ccx(bcx), bcx.sp,\n-                             ty::ty_fn_ret(bcx_tcx(bcx), fn_type)));\n-        }\n+        let llnativefnty =\n+            if uses_retptr { T_fn(call_arg_tys, T_void()) }\n+            else {\n+                let fn_ret_ty = ty::ty_fn_ret(bcx_tcx(bcx), fn_type);\n+                // FIXME: Could follow from a constraint on fn_type...\n+                check type_has_static_size(ccx, fn_ret_ty);\n+                let sp = bcx.sp;\n+                T_fn(call_arg_tys, type_of(ccx, sp, fn_ret_ty))\n+            };\n \n         let llnativefn =\n-            get_extern_fn(bcx_ccx(bcx).externs, bcx_ccx(bcx).llmod, name, cc,\n-                          llnativefnty);\n+            get_extern_fn(ccx.externs, ccx.llmod, name, cc, llnativefnty);\n         let r =\n             if cc == lib::llvm::LLVMCCallConv {\n                 Call(bcx, llnativefn, call_args)\n@@ -5767,6 +5848,9 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[istr],\n             mangle_exported_name(ccx, pt + [i.ident],\n                                  node_id_type(ccx, i.id));\n         let g = str::as_buf(s, { |buf|\n+            // FIXME: Could follow from a constraint on types of const\n+            // items\n+            check type_has_static_size(ccx, typ);\n             llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n         });\n         ccx.item_symbols.insert(i.id, s);"}, {"sha": "e81f6b5b97fb6c3708a76429dab8b86148118a2d", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -563,6 +563,9 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n       ast::pat_bind(_) {\n         if make_copy {\n             let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n+            // FIXME: Could constrain pat_bind to make this\n+            // check unnecessary.\n+            check type_has_static_size(ccx, ty);\n             let llty = trans::type_of(ccx, pat.span, ty);\n             let alloc = trans::alloca(bcx, llty);\n             bcx = trans::copy_val(bcx, trans::INIT, alloc,"}, {"sha": "b18f81bb45c4c04dd96ac84202df9db34c62dd71", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -858,6 +858,10 @@ pure fn valid_variant_index(ix:uint, cx:@block_ctxt, tag_id: &ast::def_id,\n     }\n }\n \n+pure fn type_has_static_size(cx: &@crate_ctxt, t: ty::t) -> bool {\n+    !ty::type_has_dynamic_size(cx.tcx, t)\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "cb48ef95d6de7ce86e1ebec4362638a93a854efa", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -791,9 +791,14 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n         create_object_body_type(cx.ccx.tcx, additional_field_tys, [],\n                                 some(inner_obj_ty));\n     // And cast to that type.\n+    // create_object_body_type maybe should have a postcondition...\n+\n+    let cx_ccx = cx.ccx;\n+    check type_has_static_size(cx_ccx, body_ty);\n+\n     llself_obj_body =\n         PointerCast(bcx, llself_obj_body,\n-                              T_ptr(type_of(cx.ccx, sp, body_ty)));\n+                              T_ptr(type_of(cx_ccx, sp, body_ty)));\n \n     // Now, reach into the body and grab the inner_obj.\n     let llinner_obj ="}, {"sha": "a2d33039158110c0f716acc092cae2dfd930f350", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -264,12 +264,25 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n \n     alt maybe_alt {\n       none. {\n-        changed |=\n-            find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n-                                      conseq) |\n+        alt chk {\n+          if_check. {\n+            let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n+            let conseq_prestate = tritv_clone(expr_poststate(fcx.ccx, antec));\n+            tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n+            changed |=\n+                find_pre_post_state_block(fcx, conseq_prestate, conseq) |\n                 set_poststate_ann(fcx.ccx, id,\n                                   expr_poststate(fcx.ccx, antec));\n-      }\n+          }\n+          _ {\n+            changed |=\n+                find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n+                                          conseq) |\n+                set_poststate_ann(fcx.ccx, id,\n+                                  expr_poststate(fcx.ccx, antec));\n+          }\n+        }\n+     }\n       some(altern) {\n         changed |=\n             find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),"}, {"sha": "5b3197b1bd82b1b6e3bf3cd4673cf53e608065fd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7bd3f695b62a49d73b2f322681d0b1550e8a055/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c7bd3f695b62a49d73b2f322681d0b1550e8a055", "patch": "@@ -1132,13 +1132,23 @@ fn type_structurally_contains(cx: &ctxt, ty: t,\n     }\n }\n \n-fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n-    ret type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n+pure fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n+    /* type_structurally_contains can't be declared pure\n+    because it takes a function argument. But it should be\n+    referentially transparent, since a given type's size should\n+    never change once it's created.\n+    (It would be interesting to think about how to make such properties\n+    actually checkable. It seems to me like a lot of properties\n+    that the type context tracks about types should be immutable.)\n+    */\n+    unchecked {\n+    type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n         ret alt sty {\n           ty_param(_, _) { true }\n           _ { false }\n         };\n-    });\n+    })\n+    }\n }\n \n fn type_is_integral(cx: &ctxt, ty: t) -> bool {"}]}