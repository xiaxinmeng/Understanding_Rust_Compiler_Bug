{"sha": "aec63821d04872f9190c3d8606d0a58428005222", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYzYzODIxZDA0ODcyZjkxOTBjM2Q4NjA2ZDBhNTg0MjgwMDUyMjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T14:30:21Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:52Z"}, "message": "trans: Handle all function setup for all ABIs via FnType.", "tree": {"sha": "2189ef55ef047d7a669783aa11ab33c3a4a287d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2189ef55ef047d7a669783aa11ab33c3a4a287d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aec63821d04872f9190c3d8606d0a58428005222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aec63821d04872f9190c3d8606d0a58428005222", "html_url": "https://github.com/rust-lang/rust/commit/aec63821d04872f9190c3d8606d0a58428005222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aec63821d04872f9190c3d8606d0a58428005222/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd0a849f3b0fcc88743dc8d29cf69dd983ed5dbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0a849f3b0fcc88743dc8d29cf69dd983ed5dbc", "html_url": "https://github.com/rust-lang/rust/commit/bd0a849f3b0fcc88743dc8d29cf69dd983ed5dbc"}], "stats": {"total": 2036, "additions": 703, "deletions": 1333}, "files": [{"sha": "62b6c24d38747db68811283b316c5b1104ea7c5c", "filename": "src/librustc_trans/trans/abi.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fabi.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -29,6 +29,8 @@ use trans::type_of;\n use rustc_front::hir;\n use middle::ty::{self, Ty};\n \n+use libc::c_uint;\n+\n pub use syntax::abi::Abi;\n \n /// The first half of a fat pointer.\n@@ -129,6 +131,16 @@ impl ArgType {\n         self.kind == ArgKind::Ignore\n     }\n \n+    /// Get the LLVM type for an lvalue of the original Rust type of\n+    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    pub fn memory_ty(&self, ccx: &CrateContext) -> Type {\n+        if self.original_ty == Type::i1(ccx) {\n+            Type::i8(ccx)\n+        } else {\n+            self.original_ty\n+        }\n+    }\n+\n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n@@ -156,6 +168,18 @@ impl ArgType {\n             Store(bcx, val, dst);\n         }\n     }\n+\n+    pub fn store_fn_arg(&self, bcx: Block, idx: &mut usize, dst: ValueRef) {\n+        if self.pad.is_some() {\n+            *idx += 1;\n+        }\n+        if self.is_ignore() {\n+            return;\n+        }\n+        let val = llvm::get_param(bcx.fcx.llfn, *idx as c_uint);\n+        *idx += 1;\n+        self.store(bcx, val, dst);\n+    }\n }\n \n /// Metadata describing how the arguments to a native function"}, {"sha": "6d760069cc1fb3e97094d9a4e954bf72a7e5daf4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 382, "deletions": 546, "changes": 928, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -52,7 +52,7 @@ use rustc::mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n use trans::_match;\n-use trans::abi::{self, Abi};\n+use trans::abi::{self, Abi, FnType};\n use trans::adt;\n use trans::assert_dep_graph;\n use trans::attributes;\n@@ -66,7 +66,7 @@ use trans::collector::{self, TransItem, TransItemState, TransItemCollectionMode}\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n-use trans::common::{node_id_type, return_type_is_void, fulfill_obligation};\n+use trans::common::{node_id_type, fulfill_obligation};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n use trans::consts;\n@@ -80,7 +80,7 @@ use trans::foreign;\n use trans::glue;\n use trans::intrinsic;\n use trans::machine;\n-use trans::machine::{llsize_of, llsize_of_real};\n+use trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use trans::meth;\n use trans::mir;\n use trans::monomorphize::{self, Instance};\n@@ -915,23 +915,12 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) ->\n         return C_undef(type_of::type_of(cx.ccx(), t));\n     }\n \n-    let ptr = to_arg_ty_ptr(cx, ptr, t);\n-    let align = type_of::align_of(cx.ccx(), t);\n-\n-    if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        let load = Load(cx, ptr);\n-        unsafe {\n-            llvm::LLVMSetAlignment(load, align);\n-        }\n-        return load;\n-    }\n-\n     unsafe {\n         let global = llvm::LLVMIsAGlobalVariable(ptr);\n         if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n             let val = llvm::LLVMGetInitializer(global);\n             if !val.is_null() {\n-                return to_arg_ty(cx, val, t);\n+                return to_immediate(cx, val, t);\n             }\n         }\n     }\n@@ -948,11 +937,7 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) ->\n         Load(cx, ptr)\n     };\n \n-    unsafe {\n-        llvm::LLVMSetAlignment(val, align);\n-    }\n-\n-    to_arg_ty(cx, val, t)\n+    to_immediate(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n@@ -972,10 +957,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n               ExtractValue(cx, v, abi::FAT_PTR_EXTRA),\n               expr::get_meta(cx, dst));\n     } else {\n-        let store = Store(cx, from_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n-        unsafe {\n-            llvm::LLVMSetAlignment(store, type_of::align_of(cx.ccx(), t));\n-        }\n+        Store(cx, from_immediate(cx, v), dst);\n     }\n }\n \n@@ -998,33 +980,22 @@ pub fn load_fat_ptr<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n      Load(cx, expr::get_meta(cx, src)))\n }\n \n-pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n-    if ty.is_bool() {\n+pub fn from_immediate(bcx: Block, val: ValueRef) -> ValueRef {\n+    if val_ty(val) == Type::i1(bcx.ccx()) {\n         ZExt(bcx, val, Type::i8(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n-pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         Trunc(bcx, val, Type::i1(bcx.ccx()))\n     } else {\n         val\n     }\n }\n \n-pub fn to_arg_ty_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef, ty: Ty<'tcx>) -> ValueRef {\n-    if type_is_immediate(bcx.ccx(), ty) && type_of::type_of(bcx.ccx(), ty).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        // and we have to convert it\n-        BitCast(bcx, ptr, type_of::arg_type_of(bcx.ccx(), ty).ptr_to())\n-    } else {\n-        ptr\n-    }\n-}\n-\n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &hir::Local) -> Block<'blk, 'tcx> {\n     debug!(\"init_local(bcx={}, local.id={})\", bcx.to_str(), local.id);\n     let _indenter = indenter();\n@@ -1309,41 +1280,6 @@ pub fn set_value_name(val: ValueRef, name: &str) {\n     }\n }\n \n-// Creates the alloca slot which holds the pointer to the slot for the final return value\n-pub fn make_return_slot_pointer<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                                          output_type: Ty<'tcx>)\n-                                          -> ValueRef {\n-    let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-\n-    // We create an alloca to hold a pointer of type `output_type`\n-    // which will hold the pointer to the right alloca which has the\n-    // final ret value\n-    if fcx.needs_ret_allocas {\n-        // Let's create the stack slot\n-        let slot = AllocaFcx(fcx, lloutputtype.ptr_to(), \"llretslotptr\");\n-\n-        // and if we're using an out pointer, then store that in our newly made slot\n-        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-            let outptr = get_param(fcx.llfn, 0);\n-\n-            let b = fcx.ccx.builder();\n-            b.position_before(fcx.alloca_insert_pt.get().unwrap());\n-            b.store(outptr, slot);\n-        }\n-\n-        slot\n-\n-    // But if there are no nested returns, we skip the indirection and have a single\n-    // retslot\n-    } else {\n-        if type_of::return_uses_outptr(fcx.ccx, output_type) {\n-            get_param(fcx.llfn, 0)\n-        } else {\n-            AllocaFcx(fcx, lloutputtype, \"sret_slot\")\n-        }\n-    }\n-}\n-\n struct FindNestedReturn {\n     found: bool,\n }\n@@ -1450,419 +1386,389 @@ fn has_nested_returns(tcx: &TyCtxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bool\n     return false;\n }\n \n-// NB: must keep 4 fns in sync:\n-//\n-//  - type_of_fn\n-//  - create_datums_for_fn_args.\n-//  - new_fn_ctxt\n-//  - trans_args\n-//\n-// Be warned! You must call `init_function` before doing anything with the\n-// returned function context.\n-pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                             llfndecl: ValueRef,\n-                             id: ast::NodeId,\n-                             has_env: bool,\n-                             output_type: ty::FnOutput<'tcx>,\n-                             param_substs: &'tcx Substs<'tcx>,\n-                             sp: Option<Span>,\n-                             block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n-                             -> FunctionContext<'a, 'tcx> {\n-    common::validate_substs(param_substs);\n-\n-    debug!(\"new_fn_ctxt(path={}, id={}, param_substs={:?})\",\n-           if id == !0 {\n-               \"\".to_string()\n-           } else {\n-               ccx.tcx().map.path_to_string(id).to_string()\n-           },\n-           id,\n-           param_substs);\n-\n-    let uses_outptr = match output_type {\n-        ty::FnConverging(output_type) => {\n-            let substd_output_type = monomorphize::apply_param_substs(ccx.tcx(),\n-                                                                      param_substs,\n-                                                                      &output_type);\n-            type_of::return_uses_outptr(ccx, substd_output_type)\n-        }\n-        ty::FnDiverging => false,\n-    };\n-    let debug_context = debuginfo::create_function_debug_context(ccx, id,\n-                                                                 param_substs,\n-                                                                 llfndecl);\n-    let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n-    let nested_returns = if let Some(ref cfg) = cfg {\n-        has_nested_returns(ccx.tcx(), cfg, blk_id)\n-    } else {\n-        false\n-    };\n-\n-    let mir = ccx.mir_map().map.get(&id);\n-\n-    let mut fcx = FunctionContext {\n-        mir: mir,\n-        llfn: llfndecl,\n-        llenv: None,\n-        llretslotptr: Cell::new(None),\n-        param_env: ccx.tcx().empty_parameter_environment(),\n-        alloca_insert_pt: Cell::new(None),\n-        llreturn: Cell::new(None),\n-        needs_ret_allocas: nested_returns,\n-        landingpad_alloca: Cell::new(None),\n-        caller_expects_out_pointer: uses_outptr,\n-        lllocals: RefCell::new(NodeMap()),\n-        llupvars: RefCell::new(NodeMap()),\n-        lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n-        id: id,\n-        param_substs: param_substs,\n-        span: sp,\n-        block_arena: block_arena,\n-        lpad_arena: TypedArena::new(),\n-        ccx: ccx,\n-        debug_context: debug_context,\n-        scopes: RefCell::new(Vec::new()),\n-        cfg: cfg,\n-    };\n+impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n+    /// Create a function context for the given function.\n+    /// Beware that you must call `fcx.init` or `fcx.bind_args`\n+    /// before doing anything with the returned function context.\n+    pub fn new(ccx: &'blk CrateContext<'blk, 'tcx>,\n+               llfndecl: ValueRef,\n+               fn_ty: FnType,\n+               id: ast::NodeId,\n+               param_substs: &'tcx Substs<'tcx>,\n+               sp: Option<Span>,\n+               block_arena: &'blk TypedArena<common::BlockS<'blk, 'tcx>>)\n+               -> FunctionContext<'blk, 'tcx> {\n+        common::validate_substs(param_substs);\n+\n+        debug!(\"FunctionContext::new(path={}, id={}, param_substs={:?})\",\n+            if id == !0 {\n+                \"\".to_string()\n+            } else {\n+                ccx.tcx().map.path_to_string(id).to_string()\n+            },\n+            id,\n+            param_substs);\n+\n+        let debug_context = debuginfo::create_function_debug_context(ccx, id,\n+                                                                     param_substs,\n+                                                                     llfndecl);\n+        let (blk_id, cfg) = build_cfg(ccx.tcx(), id);\n+        let nested_returns = if let Some(ref cfg) = cfg {\n+            has_nested_returns(ccx.tcx(), cfg, blk_id)\n+        } else {\n+            false\n+        };\n \n-    if has_env {\n-        fcx.llenv = Some(get_param(fcx.llfn, fcx.env_arg_pos() as c_uint))\n-    }\n-\n-    fcx\n-}\n-\n-/// Performs setup on a newly created function, creating the entry scope block\n-/// and allocating space for the return pointer.\n-pub fn init_function<'a, 'tcx>(fcx: &'a FunctionContext<'a, 'tcx>,\n-                               skip_retptr: bool,\n-                               output: ty::FnOutput<'tcx>)\n-                               -> Block<'a, 'tcx> {\n-    let entry_bcx = fcx.new_temp_block(\"entry-block\");\n-\n-    // Use a dummy instruction as the insertion point for all allocas.\n-    // This is later removed in FunctionContext::cleanup.\n-    fcx.alloca_insert_pt.set(Some(unsafe {\n-        Load(entry_bcx, C_null(Type::i8p(fcx.ccx)));\n-        llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n-    }));\n-\n-    if let ty::FnConverging(output_type) = output {\n-        // This shouldn't need to recompute the return type,\n-        // as new_fn_ctxt did it already.\n-        let substd_output_type = fcx.monomorphize(&output_type);\n-        if !return_type_is_void(fcx.ccx, substd_output_type) {\n-            // If the function returns nil/bot, there is no real return\n-            // value, so do not set `llretslotptr`.\n-            if !skip_retptr || fcx.caller_expects_out_pointer {\n-                // Otherwise, we normally allocate the llretslotptr, unless we\n-                // have been instructed to skip it for immediate return\n-                // values.\n-                fcx.llretslotptr.set(Some(make_return_slot_pointer(fcx, substd_output_type)));\n-            }\n+        FunctionContext {\n+            mir: ccx.mir_map().map.get(&id),\n+            llfn: llfndecl,\n+            llretslotptr: Cell::new(None),\n+            param_env: ccx.tcx().empty_parameter_environment(),\n+            alloca_insert_pt: Cell::new(None),\n+            llreturn: Cell::new(None),\n+            needs_ret_allocas: nested_returns,\n+            landingpad_alloca: Cell::new(None),\n+            lllocals: RefCell::new(NodeMap()),\n+            llupvars: RefCell::new(NodeMap()),\n+            lldropflag_hints: RefCell::new(DropFlagHintsMap::new()),\n+            fn_ty: fn_ty,\n+            id: id,\n+            param_substs: param_substs,\n+            span: sp,\n+            block_arena: block_arena,\n+            lpad_arena: TypedArena::new(),\n+            ccx: ccx,\n+            debug_context: debug_context,\n+            scopes: RefCell::new(Vec::new()),\n+            cfg: cfg,\n         }\n     }\n \n-    // Create the drop-flag hints for every unfragmented path in the function.\n-    let tcx = fcx.ccx.tcx();\n-    let fn_did = tcx.map.local_def_id(fcx.id);\n-    let tables = tcx.tables.borrow();\n-    let mut hints = fcx.lldropflag_hints.borrow_mut();\n-    let fragment_infos = tcx.fragment_infos.borrow();\n+    /// Performs setup on a newly created function, creating the entry\n+    /// scope block and allocating space for the return pointer.\n+    pub fn init(&'blk self, skip_retptr: bool) -> Block<'blk, 'tcx> {\n+        let entry_bcx = self.new_temp_block(\"entry-block\");\n \n-    // Intern table for drop-flag hint datums.\n-    let mut seen = HashMap::new();\n+        // Use a dummy instruction as the insertion point for all allocas.\n+        // This is later removed in FunctionContext::cleanup.\n+        self.alloca_insert_pt.set(Some(unsafe {\n+            Load(entry_bcx, C_null(Type::i8p(self.ccx)));\n+            llvm::LLVMGetFirstInstruction(entry_bcx.llbb)\n+        }));\n \n-    if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n-        for &info in fragment_infos {\n+        if !self.fn_ty.ret.is_ignore() && !skip_retptr {\n+            // We normally allocate the llretslotptr, unless we\n+            // have been instructed to skip it for immediate return\n+            // values, or there is nothing to return at all.\n+\n+            // We create an alloca to hold a pointer of type `ret.original_ty`\n+            // which will hold the pointer to the right alloca which has the\n+            // final ret value\n+            let llty = self.fn_ty.ret.memory_ty(self.ccx);\n+            let slot = if self.needs_ret_allocas {\n+                // Let's create the stack slot\n+                let slot = AllocaFcx(self, llty.ptr_to(), \"llretslotptr\");\n+\n+                // and if we're using an out pointer, then store that in our newly made slot\n+                if self.fn_ty.ret.is_indirect() {\n+                    let outptr = get_param(self.llfn, 0);\n+\n+                    let b = self.ccx.builder();\n+                    b.position_before(self.alloca_insert_pt.get().unwrap());\n+                    b.store(outptr, slot);\n+                }\n \n-            let make_datum = |id| {\n-                let init_val = C_u8(fcx.ccx, adt::DTOR_NEEDED_HINT);\n-                let llname = &format!(\"dropflag_hint_{}\", id);\n-                debug!(\"adding hint {}\", llname);\n-                let ty = tcx.types.u8;\n-                let ptr = alloc_ty(entry_bcx, ty, llname);\n-                Store(entry_bcx, init_val, ptr);\n-                let flag = datum::Lvalue::new_dropflag_hint(\"base::init_function\");\n-                datum::Datum::new(ptr, ty, flag)\n+                slot\n+            } else {\n+                // But if there are no nested returns, we skip the indirection\n+                // and have a single retslot\n+                if self.fn_ty.ret.is_indirect() {\n+                    get_param(self.llfn, 0)\n+                } else {\n+                    AllocaFcx(self, llty, \"sret_slot\")\n+                }\n             };\n \n-            let (var, datum) = match info {\n-                ty::FragmentInfo::Moved { var, .. } |\n-                ty::FragmentInfo::Assigned { var, .. } => {\n-                    let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n-                        let ty = tables.node_types[&var];\n-                        if fcx.type_needs_drop(ty) {\n-                            let datum = make_datum(var);\n-                            seen.insert(var, Some(datum.clone()));\n-                            Some(datum)\n+            self.llretslotptr.set(Some(slot));\n+        }\n+\n+        // Create the drop-flag hints for every unfragmented path in the function.\n+        let tcx = self.ccx.tcx();\n+        let fn_did = tcx.map.local_def_id(self.id);\n+        let tables = tcx.tables.borrow();\n+        let mut hints = self.lldropflag_hints.borrow_mut();\n+        let fragment_infos = tcx.fragment_infos.borrow();\n+\n+        // Intern table for drop-flag hint datums.\n+        let mut seen = HashMap::new();\n+\n+        if let Some(fragment_infos) = fragment_infos.get(&fn_did) {\n+            for &info in fragment_infos {\n+\n+                let make_datum = |id| {\n+                    let init_val = C_u8(self.ccx, adt::DTOR_NEEDED_HINT);\n+                    let llname = &format!(\"dropflag_hint_{}\", id);\n+                    debug!(\"adding hint {}\", llname);\n+                    let ty = tcx.types.u8;\n+                    let ptr = alloc_ty(entry_bcx, ty, llname);\n+                    Store(entry_bcx, init_val, ptr);\n+                    let flag = datum::Lvalue::new_dropflag_hint(\"FunctionContext::init\");\n+                    datum::Datum::new(ptr, ty, flag)\n+                };\n+\n+                let (var, datum) = match info {\n+                    ty::FragmentInfo::Moved { var, .. } |\n+                    ty::FragmentInfo::Assigned { var, .. } => {\n+                        let opt_datum = seen.get(&var).cloned().unwrap_or_else(|| {\n+                            let ty = tables.node_types[&var];\n+                            if self.type_needs_drop(ty) {\n+                                let datum = make_datum(var);\n+                                seen.insert(var, Some(datum.clone()));\n+                                Some(datum)\n+                            } else {\n+                                // No drop call needed, so we don't need a dropflag hint\n+                                None\n+                            }\n+                        });\n+                        if let Some(datum) = opt_datum {\n+                            (var, datum)\n                         } else {\n-                            // No drop call needed, so we don't need a dropflag hint\n-                            None\n+                            continue\n                         }\n-                    });\n-                    if let Some(datum) = opt_datum {\n-                        (var, datum)\n-                    } else {\n-                        continue\n                     }\n-                }\n-            };\n-            match info {\n-                ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n-                    debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n-                    hints.insert(expr_id, DropHint::new(var, datum));\n-                }\n-                ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n-                    debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n-                    hints.insert(expr_id, DropHint::new(var, datum));\n+                };\n+                match info {\n+                    ty::FragmentInfo::Moved { move_expr: expr_id, .. } => {\n+                        debug!(\"FragmentInfo::Moved insert drop hint for {}\", expr_id);\n+                        hints.insert(expr_id, DropHint::new(var, datum));\n+                    }\n+                    ty::FragmentInfo::Assigned { assignee_id: expr_id, .. } => {\n+                        debug!(\"FragmentInfo::Assigned insert drop hint for {}\", expr_id);\n+                        hints.insert(expr_id, DropHint::new(var, datum));\n+                    }\n                 }\n             }\n         }\n-    }\n-\n-    entry_bcx\n-}\n \n-// NB: must keep 4 fns in sync:\n-//\n-//  - type_of_fn\n-//  - create_datums_for_fn_args.\n-//  - new_fn_ctxt\n-//  - trans_args\n-\n-pub fn arg_kind<'a, 'tcx>(cx: &FunctionContext<'a, 'tcx>, t: Ty<'tcx>) -> datum::Rvalue {\n-    use trans::datum::{ByRef, ByValue};\n-\n-    datum::Rvalue {\n-        mode: if arg_is_indirect(cx.ccx, t) { ByRef } else { ByValue }\n+        entry_bcx\n     }\n-}\n \n-// create_datums_for_fn_args: creates lvalue datums for each of the\n-// incoming function arguments.\n-pub fn create_datums_for_fn_args<'a, 'tcx>(mut bcx: Block<'a, 'tcx>,\n-                                           args: &[hir::Arg],\n-                                           arg_tys: &[Ty<'tcx>],\n-                                           has_tupled_arg: bool,\n-                                           arg_scope: cleanup::CustomScopeIndex)\n-                                           -> Block<'a, 'tcx> {\n-    let _icx = push_ctxt(\"create_datums_for_fn_args\");\n-    let fcx = bcx.fcx;\n-    let arg_scope_id = cleanup::CustomScope(arg_scope);\n+    /// Creates lvalue datums for each of the incoming function arguments,\n+    /// matches all argument patterns against them to produce bindings,\n+    /// and returns the entry block (see FunctionContext::init).\n+    fn bind_args(&'blk self,\n+                 args: &[hir::Arg],\n+                 abi: Abi,\n+                 closure_env: closure::ClosureEnv,\n+                 arg_scope: cleanup::CustomScopeIndex)\n+                 -> Block<'blk, 'tcx> {\n+        let _icx = push_ctxt(\"FunctionContext::bind_args\");\n+        let mut bcx = self.init(false);\n+        let arg_scope_id = cleanup::CustomScope(arg_scope);\n \n-    debug!(\"create_datums_for_fn_args\");\n+        let mut idx = 0;\n+        let mut llarg_idx = self.fn_ty.ret.is_indirect() as usize;\n \n-    // Return an array wrapping the ValueRefs that we get from `get_param` for\n-    // each argument into datums.\n-    //\n-    // For certain mode/type combinations, the raw llarg values are passed\n-    // by value.  However, within the fn body itself, we want to always\n-    // have all locals and arguments be by-ref so that we can cancel the\n-    // cleanup and for better interaction with LLVM's debug info.  So, if\n-    // the argument would be passed by value, we store it into an alloca.\n-    // This alloca should be optimized away by LLVM's mem-to-reg pass in\n-    // the event it's not truly needed.\n-    let mut idx = fcx.arg_offset() as c_uint;\n-    let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n-    for (i, &arg_ty) in arg_tys.iter().enumerate() {\n-        let arg_datum = if !has_tupled_arg || i < arg_tys.len() - 1 {\n-            if type_of::arg_is_indirect(bcx.ccx(), arg_ty) &&\n-               bcx.sess().opts.debuginfo != FullDebugInfo {\n-                // Don't copy an indirect argument to an alloca, the caller\n-                // already put it in a temporary alloca and gave it up, unless\n-                // we emit extra-debug-info, which requires local allocas :(.\n-                let llarg = get_param(fcx.llfn, idx);\n+        let has_tupled_arg = match closure_env {\n+            closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n+            closure::ClosureEnv::Closure(..) => {\n+                closure_env.load(bcx, arg_scope_id);\n+                let env_arg = &self.fn_ty.args[idx];\n                 idx += 1;\n-                bcx.fcx.schedule_lifetime_end(arg_scope_id, llarg);\n-                bcx.fcx.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n-\n-                datum::Datum::new(llarg,\n-                                  arg_ty,\n-                                  datum::Lvalue::new(\"create_datum_for_fn_args\"))\n-            } else if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                let data = get_param(fcx.llfn, idx);\n-                let extra = get_param(fcx.llfn, idx + 1);\n-                idx += 2;\n-                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\", uninit_reason,\n-                                                        arg_scope_id, (data, extra),\n-                                                        |(data, extra), bcx, dst| {\n-                    debug!(\"populate call for create_datum_for_fn_args \\\n-                            early fat arg, on arg[{}] ty={:?}\", i, arg_ty);\n-\n-                    Store(bcx, data, expr::get_dataptr(bcx, dst));\n-                    Store(bcx, extra, expr::get_meta(bcx, dst));\n-                    bcx\n-                }))\n-            } else {\n-                let llarg = get_param(fcx.llfn, idx);\n-                idx += 1;\n-                let tmp = datum::Datum::new(llarg, arg_ty, arg_kind(fcx, arg_ty));\n-                unpack_datum!(bcx,\n-                              datum::lvalue_scratch_datum(bcx,\n-                                                          arg_ty,\n-                                                          \"\",\n-                                                          uninit_reason,\n-                                                          arg_scope_id,\n-                                                          tmp,\n-                                                          |tmp, bcx, dst| {\n-\n-                        debug!(\"populate call for create_datum_for_fn_args \\\n-                                early thin arg, on arg[{}] ty={:?}\", i, arg_ty);\n-\n-                                                              tmp.store_to(bcx, dst)\n-                                                          }))\n-            }\n-        } else {\n-            // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n-            match arg_ty.sty {\n-                ty::TyTuple(ref tupled_arg_tys) => {\n-                    unpack_datum!(bcx,\n-                                  datum::lvalue_scratch_datum(bcx,\n-                                                              arg_ty,\n-                                                              \"tupled_args\",\n-                                                              uninit_reason,\n-                                                              arg_scope_id,\n-                                                              (),\n-                                                              |(),\n-                                                               mut bcx,\n-                                                              llval| {\n-                        debug!(\"populate call for create_datum_for_fn_args \\\n-                                tupled_args, on arg[{}] ty={:?}\", i, arg_ty);\n-                        for (j, &tupled_arg_ty) in\n-                                    tupled_arg_tys.iter().enumerate() {\n-                            let lldest = StructGEP(bcx, llval, j);\n-                            if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n-                                let data = get_param(bcx.fcx.llfn, idx);\n-                                let extra = get_param(bcx.fcx.llfn, idx + 1);\n-                                Store(bcx, data, expr::get_dataptr(bcx, lldest));\n-                                Store(bcx, extra, expr::get_meta(bcx, lldest));\n-                                idx += 2;\n-                            } else {\n-                                let datum = datum::Datum::new(\n-                                    get_param(bcx.fcx.llfn, idx),\n-                                    tupled_arg_ty,\n-                                    arg_kind(bcx.fcx, tupled_arg_ty));\n-                                idx += 1;\n-                                bcx = datum.store_to(bcx, lldest);\n-                            };\n-                        }\n-                        bcx\n-                    }))\n+                if env_arg.pad.is_some() {\n+                    llarg_idx += 1;\n                 }\n-                _ => {\n-                    bcx.tcx()\n-                       .sess\n-                       .bug(\"last argument of a function with `rust-call` ABI isn't a tuple?!\")\n+                if !env_arg.is_ignore() {\n+                    llarg_idx += 1;\n                 }\n+                false\n             }\n         };\n-\n-        let pat = &*args[i].pat;\n-        bcx = if let Some(name) = simple_name(pat) {\n-            // Generate nicer LLVM for the common case of fn a pattern\n-            // like `x: T`\n-            set_value_name(arg_datum.val, &bcx.name(name));\n-            bcx.fcx.lllocals.borrow_mut().insert(pat.id, arg_datum);\n-            bcx\n+        let tupled_arg_id = if has_tupled_arg {\n+            args[args.len() - 1].id\n         } else {\n-            // General path. Copy out the values that are used in the\n-            // pattern.\n-            _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n+            ast::DUMMY_NODE_ID\n         };\n-        debuginfo::create_argument_metadata(bcx, &args[i]);\n-    }\n \n-    bcx\n-}\n+        // Return an array wrapping the ValueRefs that we get from `get_param` for\n+        // each argument into datums.\n+        //\n+        // For certain mode/type combinations, the raw llarg values are passed\n+        // by value.  However, within the fn body itself, we want to always\n+        // have all locals and arguments be by-ref so that we can cancel the\n+        // cleanup and for better interaction with LLVM's debug info.  So, if\n+        // the argument would be passed by value, we store it into an alloca.\n+        // This alloca should be optimized away by LLVM's mem-to-reg pass in\n+        // the event it's not truly needed.\n+        let uninit_reason = InitAlloca::Uninit(\"fn_arg populate dominates dtor\");\n+        for hir_arg in args {\n+            let arg_ty = node_id_type(bcx, hir_arg.id);\n+            let arg_datum = if hir_arg.id != tupled_arg_id {\n+                let arg = &self.fn_ty.args[idx];\n+                idx += 1;\n+                if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n+                    // Don't copy an indirect argument to an alloca, the caller\n+                    // already put it in a temporary alloca and gave it up, unless\n+                    // we emit extra-debug-info, which requires local allocas :(.\n+                    let llarg = get_param(self.llfn, llarg_idx as c_uint);\n+                    llarg_idx += 1;\n+                    self.schedule_lifetime_end(arg_scope_id, llarg);\n+                    self.schedule_drop_mem(arg_scope_id, llarg, arg_ty, None);\n+\n+                    datum::Datum::new(llarg,\n+                                    arg_ty,\n+                                    datum::Lvalue::new(\"FunctionContext::bind_args\"))\n+                } else {\n+                    unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx, arg_ty, \"\",\n+                                                                   uninit_reason,\n+                                                                   arg_scope_id, |bcx, dst| {\n+                        debug!(\"FunctionContext::bind_args: {:?}: {:?}\", hir_arg, arg_ty);\n+                        if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n+                            let meta = &self.fn_ty.args[idx];\n+                            idx += 1;\n+                            arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                        } else {\n+                            arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                        }\n+                        bcx\n+                    }))\n+                }\n+            } else {\n+                // FIXME(pcwalton): Reduce the amount of code bloat this is responsible for.\n+                let tupled_arg_tys = match arg_ty.sty {\n+                    ty::TyTuple(ref tys) => tys,\n+                    _ => unreachable!(\"last argument of `rust-call` fn isn't a tuple?!\")\n+                };\n \n-// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n-// and builds the return block.\n-pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n-                             last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput<'tcx>,\n-                             ret_debug_loc: DebugLoc) {\n-    let _icx = push_ctxt(\"finish_fn\");\n+                unpack_datum!(bcx, datum::lvalue_scratch_datum(bcx,\n+                                                            arg_ty,\n+                                                            \"tupled_args\",\n+                                                            uninit_reason,\n+                                                            arg_scope_id,\n+                                                            |bcx, llval| {\n+                    debug!(\"FunctionContext::bind_args: tupled {:?}: {:?}\", hir_arg, arg_ty);\n+                    for (j, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                        let dst = StructGEP(bcx, llval, j);\n+                        let arg = &self.fn_ty.args[idx];\n+                        if common::type_is_fat_ptr(bcx.tcx(), tupled_arg_ty) {\n+                            let meta = &self.fn_ty.args[idx];\n+                            idx += 1;\n+                            arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, dst));\n+                            meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, dst));\n+                        } else {\n+                            arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                        }\n+                    }\n+                    bcx\n+                }))\n+            };\n \n-    let ret_cx = match fcx.llreturn.get() {\n-        Some(llreturn) => {\n-            if !last_bcx.terminated.get() {\n-                Br(last_bcx, llreturn, DebugLoc::None);\n-            }\n-            raw_block(fcx, llreturn)\n+            let pat = &hir_arg.pat;\n+            bcx = if let Some(name) = simple_name(pat) {\n+                // Generate nicer LLVM for the common case of fn a pattern\n+                // like `x: T`\n+                set_value_name(arg_datum.val, &bcx.name(name));\n+                self.lllocals.borrow_mut().insert(pat.id, arg_datum);\n+                bcx\n+            } else {\n+                // General path. Copy out the values that are used in the\n+                // pattern.\n+                _match::bind_irrefutable_pat(bcx, pat, arg_datum.match_input(), arg_scope_id)\n+            };\n+            debuginfo::create_argument_metadata(bcx, hir_arg);\n         }\n-        None => last_bcx,\n-    };\n \n-    // This shouldn't need to recompute the return type,\n-    // as new_fn_ctxt did it already.\n-    let substd_retty = fcx.monomorphize(&retty);\n-    build_return_block(fcx, ret_cx, substd_retty, ret_debug_loc);\n+        bcx\n+    }\n \n-    debuginfo::clear_source_location(fcx);\n-    fcx.cleanup();\n-}\n+    /// Ties up the llstaticallocas -> llloadenv -> lltop edges,\n+    /// and builds the return block.\n+    pub fn finish(&'blk self, last_bcx: Block<'blk, 'tcx>,\n+                  ret_debug_loc: DebugLoc) {\n+        let _icx = push_ctxt(\"FunctionContext::finish\");\n \n-// Builds the return block for a function.\n-pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n-                                      ret_cx: Block<'blk, 'tcx>,\n-                                      retty: ty::FnOutput<'tcx>,\n-                                      ret_debug_location: DebugLoc) {\n-    if fcx.llretslotptr.get().is_none() ||\n-       (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n-        return RetVoid(ret_cx, ret_debug_location);\n+        let ret_cx = match self.llreturn.get() {\n+            Some(llreturn) => {\n+                if !last_bcx.terminated.get() {\n+                    Br(last_bcx, llreturn, DebugLoc::None);\n+                }\n+                raw_block(self, llreturn)\n+            }\n+            None => last_bcx,\n+        };\n+\n+        self.build_return_block(ret_cx, ret_debug_loc);\n+\n+        debuginfo::clear_source_location(self);\n+        self.cleanup();\n     }\n \n-    let retslot = if fcx.needs_ret_allocas {\n-        Load(ret_cx, fcx.llretslotptr.get().unwrap())\n-    } else {\n-        fcx.llretslotptr.get().unwrap()\n-    };\n-    let retptr = Value(retslot);\n-    match retptr.get_dominating_store(ret_cx) {\n-        // If there's only a single store to the ret slot, we can directly return\n-        // the value that was stored and omit the store and the alloca\n-        Some(s) => {\n-            let retval = s.get_operand(0).unwrap().get();\n-            s.erase_from_parent();\n-\n-            if retptr.has_no_uses() {\n-                retptr.erase_from_parent();\n-            }\n+    // Builds the return block for a function.\n+    pub fn build_return_block(&self, ret_cx: Block<'blk, 'tcx>,\n+                              ret_debug_location: DebugLoc) {\n+        if self.llretslotptr.get().is_none() ||\n+           ret_cx.unreachable.get() ||\n+           (!self.needs_ret_allocas && self.fn_ty.ret.is_indirect()) {\n+            return RetVoid(ret_cx, ret_debug_location);\n+        }\n \n-            let retval = if retty == ty::FnConverging(fcx.ccx.tcx().types.bool) {\n-                Trunc(ret_cx, retval, Type::i1(fcx.ccx))\n-            } else {\n-                retval\n-            };\n+        let retslot = if self.needs_ret_allocas {\n+            Load(ret_cx, self.llretslotptr.get().unwrap())\n+        } else {\n+            self.llretslotptr.get().unwrap()\n+        };\n+        let retptr = Value(retslot);\n+        let llty = self.fn_ty.ret.original_ty;\n+        match (retptr.get_dominating_store(ret_cx), self.fn_ty.ret.cast) {\n+            // If there's only a single store to the ret slot, we can directly return\n+            // the value that was stored and omit the store and the alloca.\n+            // However, we only want to do this when there is no cast needed.\n+            (Some(s), None) => {\n+                let mut retval = s.get_operand(0).unwrap().get();\n+                s.erase_from_parent();\n+\n+                if retptr.has_no_uses() {\n+                    retptr.erase_from_parent();\n+                }\n \n-            if fcx.caller_expects_out_pointer {\n-                if let ty::FnConverging(retty) = retty {\n-                    store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n+                if self.fn_ty.ret.is_indirect() {\n+                    Store(ret_cx, retval, get_param(self.llfn, 0));\n+                    RetVoid(ret_cx, ret_debug_location)\n+                } else {\n+                    if llty == Type::i1(self.ccx) {\n+                        retval = Trunc(ret_cx, retval, llty);\n+                    }\n+                    Ret(ret_cx, retval, ret_debug_location)\n                 }\n+            }\n+            (_, cast_ty) if self.fn_ty.ret.is_indirect() => {\n+                // Otherwise, copy the return value to the ret slot.\n+                assert_eq!(cast_ty, None);\n+                let llsz = llsize_of(self.ccx, self.fn_ty.ret.ty);\n+                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n+                call_memcpy(ret_cx, get_param(self.llfn, 0),\n+                            retslot, llsz, llalign as u32);\n                 RetVoid(ret_cx, ret_debug_location)\n-            } else {\n-                Ret(ret_cx, retval, ret_debug_location)\n             }\n-        }\n-        // Otherwise, copy the return value to the ret slot\n-        None => match retty {\n-            ty::FnConverging(retty) => {\n-                if fcx.caller_expects_out_pointer {\n-                    memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                    RetVoid(ret_cx, ret_debug_location)\n-                } else {\n-                    Ret(ret_cx, load_ty(ret_cx, retslot, retty), ret_debug_location)\n+            (_, Some(cast_ty)) => {\n+                let load = Load(ret_cx, PointerCast(ret_cx, retslot, cast_ty.ptr_to()));\n+                let llalign = llalign_of_min(self.ccx, self.fn_ty.ret.ty);\n+                unsafe {\n+                    llvm::LLVMSetAlignment(load, llalign);\n                 }\n+                Ret(ret_cx, load, ret_debug_location)\n             }\n-            ty::FnDiverging => {\n-                if fcx.caller_expects_out_pointer {\n-                    RetVoid(ret_cx, ret_debug_location)\n+            (_, None) => {\n+                let retval = if llty == Type::i1(self.ccx) {\n+                    let val = LoadRangeAssert(ret_cx, retslot, 0, 2, llvm::False);\n+                    Trunc(ret_cx, val, llty)\n                 } else {\n-                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n-                }\n+                    Load(ret_cx, retslot)\n+                };\n+                Ret(ret_cx, retval, ret_debug_location)\n             }\n-        },\n+        }\n     }\n }\n \n@@ -1876,7 +1782,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n                                    attributes: &[ast::Attribute],\n-                                   output_type: ty::FnOutput<'tcx>,\n+                                   fn_ty: FnType,\n                                    abi: Abi,\n                                    closure_env: closure::ClosureEnv<'b>) {\n     ccx.stats().n_closures.set(ccx.stats().n_closures.get() + 1);\n@@ -1888,27 +1794,13 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"trans_closure(..., param_substs={:?})\", param_substs);\n \n-    let has_env = match closure_env {\n-        closure::ClosureEnv::Closure(..) => true,\n-        closure::ClosureEnv::NotClosure => false,\n-    };\n-\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfndecl,\n-                      fn_ast_id,\n-                      has_env,\n-                      output_type,\n-                      param_substs,\n-                      Some(body.span),\n-                      &arena);\n-    let mut bcx = init_function(&fcx, false, output_type);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, fn_ast_id,\n+                               param_substs, Some(body.span), &arena);\n \n     if attributes.iter().any(|item| item.check_name(\"rustc_mir\")) {\n-        mir::trans_mir(bcx.build());\n-        fcx.cleanup();\n-        return;\n+        return mir::trans_mir(&fcx);\n     }\n \n     // cleanup scope for the incoming arguments\n@@ -1918,50 +1810,26 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                                              true);\n     let arg_scope = fcx.push_custom_cleanup_scope_with_debug_loc(fn_cleanup_debug_loc);\n \n-    let block_ty = node_id_type(bcx, body.id);\n-\n     // Set up arguments to the function.\n-    let monomorphized_arg_types = decl.inputs\n-                                      .iter()\n-                                      .map(|arg| node_id_type(bcx, arg.id))\n-                                      .collect::<Vec<_>>();\n-    for monomorphized_arg_type in &monomorphized_arg_types {\n-        debug!(\"trans_closure: monomorphized_arg_type: {:?}\",\n-               monomorphized_arg_type);\n-    }\n-    debug!(\"trans_closure: function lltype: {:?}\", Value(bcx.fcx.llfn));\n-\n-    let has_tupled_arg = match closure_env {\n-        closure::ClosureEnv::NotClosure => abi == Abi::RustCall,\n-        _ => false,\n-    };\n-\n-    bcx = create_datums_for_fn_args(bcx,\n-                                    &decl.inputs,\n-                                    &monomorphized_arg_types,\n-                                    has_tupled_arg,\n-                                    arg_scope);\n-\n-    bcx = closure_env.load(bcx, cleanup::CustomScope(arg_scope));\n+    debug!(\"trans_closure: function: {:?}\", Value(fcx.llfn));\n+    let bcx = fcx.bind_args(&decl.inputs, abi, closure_env, arg_scope);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(&fcx);\n \n-    let dest = match fcx.llretslotptr.get() {\n-        Some(_) => expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(block_ty), \"iret_slot\")),\n-        None => {\n-            assert!(type_is_zero_size(bcx.ccx(), block_ty));\n-            expr::Ignore\n-        }\n+    let dest = if fcx.fn_ty.ret.is_ignore() {\n+        expr::Ignore\n+    } else {\n+        expr::SaveIn(fcx.get_ret_slot(bcx, \"iret_slot\"))\n     };\n \n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-    bcx = controlflow::trans_block(bcx, body, dest);\n+    let mut bcx = controlflow::trans_block(bcx, body, dest);\n \n     match dest {\n         expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -1994,7 +1862,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id, fn_cleanup_debug_loc.span);\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n+    fcx.finish(bcx, ret_debug_loc);\n \n     fn record_translation_item_as_generated<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       node_id: ast::NodeId,\n@@ -2032,19 +1900,18 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let _icx = push_ctxt(\"trans_fn\");\n     let fn_ty = ccx.tcx().node_id_to_type(id);\n     let fn_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fn_ty);\n-    let sig = fn_ty.fn_sig();\n-    let sig = ccx.tcx().erase_late_bound_regions(&sig);\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_ty.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let output_type = sig.output;\n     let abi = fn_ty.fn_abi();\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfndecl,\n                   param_substs,\n                   id,\n                   attrs,\n-                  output_type,\n+                  fn_ty,\n                   abi,\n                   closure::ClosureEnv::NotClosure);\n }\n@@ -2131,53 +1998,39 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let sig = ccx.tcx().erase_late_bound_regions(&ctor_ty.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n-    let arg_tys = sig.inputs;\n-    let result_ty = sig.output;\n+    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfndecl,\n-                      ctor_id,\n-                      false,\n-                      result_ty,\n-                      param_substs,\n-                      None,\n-                      &arena);\n-    let bcx = init_function(&fcx, false, result_ty);\n+    fcx = FunctionContext::new(ccx, llfndecl, fn_ty, ctor_id,\n+                               param_substs, None, &arena);\n+    let bcx = fcx.init(false);\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n-        let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n+    if !fcx.fn_ty.ret.is_ignore() {\n+        let dest = fcx.get_ret_slot(bcx, \"eret_slot\");\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n-        let repr = adt::represent_type(ccx, result_ty.unwrap());\n-        let mut llarg_idx = fcx.arg_offset() as c_uint;\n-        for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n+        let repr = adt::represent_type(ccx, sig.output.unwrap());\n+        let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+        let mut arg_idx = 0;\n+        for (i, arg_ty) in sig.inputs.into_iter().enumerate() {\n             let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n+            let arg = &fcx.fn_ty.args[arg_idx];\n+            arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n-                Store(bcx,\n-                      get_param(fcx.llfn, llarg_idx),\n-                      expr::get_dataptr(bcx, lldestptr));\n-                Store(bcx,\n-                      get_param(fcx.llfn, llarg_idx + 1),\n-                      expr::get_meta(bcx, lldestptr));\n-                llarg_idx += 2;\n+                let meta = &fcx.fn_ty.args[arg_idx];\n+                arg_idx += 1;\n+                arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, lldestptr));\n+                meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, lldestptr));\n             } else {\n-                let arg = get_param(fcx.llfn, llarg_idx);\n-                llarg_idx += 1;\n-\n-                if arg_is_indirect(ccx, arg_ty) {\n-                    memcpy_ty(bcx, lldestptr, arg, arg_ty);\n-                } else {\n-                    store_ty(bcx, arg, lldestptr, arg_ty);\n-                }\n+                arg.store_fn_arg(bcx, &mut llarg_idx, lldestptr);\n             }\n         }\n         adt::trans_set_discr(bcx, &repr, dest, disr);\n     }\n \n-    finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n }\n \n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span, id: ast::NodeId) {\n@@ -2376,7 +2229,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n \n     match item.node {\n-        hir::ItemFn(ref decl, _, _, abi, ref generics, ref body) => {\n+        hir::ItemFn(ref decl, _, _, _, ref generics, ref body) => {\n             if !generics.is_type_parameterized() {\n                 let trans_everywhere = attr::requests_inline(&item.attrs);\n                 // Ignore `trans_everywhere` for cross-crate inlined items\n@@ -2387,24 +2240,7 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                     let def_id = tcx.map.local_def_id(item.id);\n                     let llfn = Callee::def(ccx, def_id, empty_substs).reify(ccx).val;\n-                    if abi != Abi::Rust {\n-                        foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                                &decl,\n-                                                                &body,\n-                                                                &item.attrs,\n-                                                                llfn,\n-                                                                empty_substs,\n-                                                                item.id,\n-                                                                None);\n-                    } else {\n-                        trans_fn(ccx,\n-                                 &decl,\n-                                 &body,\n-                                 llfn,\n-                                 empty_substs,\n-                                 item.id,\n-                                 &item.attrs);\n-                    }\n+                    trans_fn(ccx, &decl, &body, llfn, empty_substs, item.id, &item.attrs);\n                     set_global_section(ccx, llfn, item);\n                     update_linkage(ccx,\n                                    llfn,"}, {"sha": "042f81542d644833db4415af37640691960c6e0f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -255,15 +255,18 @@ impl<'tcx> Callee<'tcx> {\n     /// Turn the callee into a function pointer.\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>)\n                      -> Datum<'tcx, Rvalue> {\n+        let fn_ptr_ty = match self.ty.sty {\n+            ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n+            _ => self.ty\n+        };\n         match self.data {\n             Fn(llfn) => {\n-                let fn_ptr_ty = match self.ty.sty {\n-                    ty::TyFnDef(_, _, f) => ccx.tcx().mk_ty(ty::TyFnPtr(f)),\n-                    _ => self.ty\n-                };\n                 immediate_rvalue(llfn, fn_ptr_ty)\n             }\n-            Virtual(idx) => meth::trans_object_shim(ccx, self.ty, idx),\n+            Virtual(idx) => {\n+                let llfn = meth::trans_object_shim(ccx, self.ty, idx);\n+                immediate_rvalue(llfn, fn_ptr_ty)\n+            }\n             NamedTupleConstructor(_) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n                     return get_fn(ccx, def_id, substs);\n@@ -313,6 +316,21 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         ty::ClosureKind::Fn | ty::ClosureKind::FnMut => true,\n         ty::ClosureKind::FnOnce => false,\n     };\n+\n+    let llfnpointer = match bare_fn_ty.sty {\n+        ty::TyFnDef(def_id, substs, _) => {\n+            // Function definitions have to be turned into a pointer.\n+            let llfn = Callee::def(ccx, def_id, substs).reify(ccx).val;\n+            if !is_by_ref {\n+                // A by-value fn item is ignored, so the shim has\n+                // the same signature as the original function.\n+                return llfn;\n+            }\n+            Some(llfn)\n+        }\n+        _ => None\n+    };\n+\n     let bare_fn_ty_maybe_ref = if is_by_ref {\n         tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), bare_fn_ty)\n     } else {\n@@ -347,15 +365,17 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let sig = tcx.erase_late_bound_regions(sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     let tuple_input_ty = tcx.mk_tup(sig.inputs.to_vec());\n+    let sig = ty::FnSig {\n+        inputs: vec![bare_fn_ty_maybe_ref,\n+                     tuple_input_ty],\n+        output: sig.output,\n+        variadic: false\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n     let tuple_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: hir::Unsafety::Normal,\n         abi: Abi::RustCall,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: vec![bare_fn_ty_maybe_ref,\n-                         tuple_input_ty],\n-            output: sig.output,\n-            variadic: false\n-        })\n+        sig: ty::Binder(sig)\n     });\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n@@ -368,37 +388,26 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      sig.output,\n-                      empty_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, sig.output);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n+                               empty_substs, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n \n     let llargs = get_params(fcx.llfn);\n \n-    let self_idx = fcx.arg_offset();\n-    let llfnpointer = match bare_fn_ty.sty {\n-        ty::TyFnDef(def_id, substs, _) => {\n-            // Function definitions have to be turned into a pointer.\n-            Callee::def(ccx, def_id, substs).reify(ccx).val\n-        }\n-\n+    let self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let llfnpointer = llfnpointer.unwrap_or_else(|| {\n         // the first argument (`self`) will be ptr to the fn pointer\n-        _ => if is_by_ref {\n+        if is_by_ref {\n             Load(bcx, llargs[self_idx])\n         } else {\n             llargs[self_idx]\n         }\n-    };\n+    });\n \n     assert!(!fcx.needs_ret_allocas);\n \n     let dest = fcx.llretslotptr.get().map(|_|\n-        expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\"))\n+        expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n     );\n \n     let callee = Callee {\n@@ -407,7 +416,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     };\n     bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[(self_idx + 1)..]), dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n "}, {"sha": "10ed646cd01fd2c3c6a0ee5047327d9a17e71534", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 82, "deletions": 67, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -10,24 +10,24 @@\n \n use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n-use llvm::{ValueRef, get_params};\n+use llvm::{ValueRef, get_param, get_params};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::traits::ProjectionMode;\n-use trans::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{self, ArgVals, Callee};\n use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n-use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue};\n+use trans::datum::{ByRef, Datum, lvalue_scratch_datum};\n+use trans::datum::{rvalue_scratch_datum, Rvalue};\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::expr;\n use trans::monomorphize::{Instance};\n-use trans::type_of::*;\n use trans::value::Value;\n use trans::Disr;\n use middle::ty::{self, Ty, TyCtxt};\n@@ -38,28 +38,26 @@ use syntax::attr::{ThinAttributes, ThinAttributesExt};\n \n use rustc_front::hir;\n \n+use libc::c_uint;\n \n fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         closure_def_id: DefId,\n                                         arg_scope_id: ScopeId,\n-                                        freevars: &[ty::Freevar])\n-                                        -> Block<'blk, 'tcx>\n-{\n+                                        freevars: &[ty::Freevar]) {\n     let _icx = push_ctxt(\"closure::load_closure_environment\");\n+    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n+\n+    let env_arg = &bcx.fcx.fn_ty.args[0];\n+    let mut env_idx = bcx.fcx.fn_ty.ret.is_indirect() as usize;\n \n     // Special case for small by-value selfs.\n-    let closure_ty = node_id_type(bcx, bcx.fcx.id);\n-    let self_type = get_self_type(bcx.tcx(), closure_def_id, closure_ty);\n-    let kind = kind_for_closure(bcx.ccx(), closure_def_id);\n-    let llenv = if kind == ty::ClosureKind::FnOnce &&\n-            !arg_is_indirect(bcx.ccx(), self_type) {\n-        let datum = rvalue_scratch_datum(bcx,\n-                                         self_type,\n-                                         \"closure_env\");\n-        store_ty(bcx, bcx.fcx.llenv.unwrap(), datum.val, self_type);\n-        datum.val\n+    let llenv = if kind == ty::ClosureKind::FnOnce && !env_arg.is_indirect() {\n+        let closure_ty = node_id_type(bcx, bcx.fcx.id);\n+        let llenv = rvalue_scratch_datum(bcx, closure_ty, \"closure_env\").val;\n+        env_arg.store_fn_arg(bcx, &mut env_idx, llenv);\n+        llenv\n     } else {\n-        bcx.fcx.llenv.unwrap()\n+        get_param(bcx.fcx.llfn, env_idx as c_uint)\n     };\n \n     // Store the pointer to closure data in an alloca for debug info because that's what the\n@@ -105,8 +103,6 @@ fn load_closure_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 freevar.span);\n         }\n     }\n-\n-    bcx\n }\n \n pub enum ClosureEnv<'a> {\n@@ -115,26 +111,19 @@ pub enum ClosureEnv<'a> {\n }\n \n impl<'a> ClosureEnv<'a> {\n-    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId)\n-                           -> Block<'blk, 'tcx>\n-    {\n-        match self {\n-            ClosureEnv::NotClosure => bcx,\n-            ClosureEnv::Closure(def_id, freevars) => {\n-                if freevars.is_empty() {\n-                    bcx\n-                } else {\n-                    load_closure_environment(bcx, def_id, arg_scope, freevars)\n-                }\n+    pub fn load<'blk,'tcx>(self, bcx: Block<'blk, 'tcx>, arg_scope: ScopeId) {\n+        if let ClosureEnv::Closure(def_id, freevars) = self {\n+            if !freevars.is_empty() {\n+                load_closure_environment(bcx, def_id, arg_scope, freevars);\n             }\n         }\n     }\n }\n \n-pub fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n-                           closure_id: DefId,\n-                           fn_ty: Ty<'tcx>)\n-                           -> Ty<'tcx> {\n+fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n+                       closure_id: DefId,\n+                       fn_ty: Ty<'tcx>)\n+                       -> Ty<'tcx> {\n     match tcx.closure_kind(closure_id) {\n         ty::ClosureKind::Fn => {\n             tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), fn_ty)\n@@ -148,10 +137,10 @@ pub fn get_self_type<'tcx>(tcx: &TyCtxt<'tcx>,\n \n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                   closure_id: DefId,\n-                                                   substs: &ty::ClosureSubsts<'tcx>)\n-                                                   -> ValueRef {\n+fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                               closure_id: DefId,\n+                                               substs: &ty::ClosureSubsts<'tcx>)\n+                                               -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n     let tcx = ccx.tcx();\n@@ -246,15 +235,25 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     let sig = tcx.erase_late_bound_regions(&function_type.sig);\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n \n+    let closure_type = tcx.mk_closure_from_closure_substs(closure_def_id,\n+        Box::new(closure_substs.clone()));\n+    let sig = ty::FnSig {\n+        inputs: Some(get_self_type(tcx, closure_def_id, closure_type))\n+                    .into_iter().chain(sig.inputs).collect(),\n+        output: sig.output,\n+        variadic: false\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::RustCall, &sig, &[]);\n+\n     trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn,\n                   param_substs,\n                   id,\n                   closure_expr_attrs.as_attr_slice(),\n-                  sig.output,\n-                  function_type.abi,\n+                  fn_ty,\n+                  Abi::RustCall,\n                   ClosureEnv::Closure(closure_def_id, &freevars));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n@@ -373,17 +372,20 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n            llref_fn_ty);\n \n-    let ret_ty = tcx.erase_late_bound_regions(&sig.output());\n-    let ret_ty = infer::normalize_associated_type(ccx.tcx(), &ret_ty);\n \n     // Make a version of the closure type with the same arguments, but\n     // with argument #0 being by value.\n     assert_eq!(abi, Abi::RustCall);\n     sig.0.inputs[0] = closure_ty;\n+\n+    let sig = tcx.erase_late_bound_regions(&sig);\n+    let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n+\n     let llonce_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n-        sig: sig\n+        sig: ty::Binder(sig)\n     });\n \n     // Create the by-value helper.\n@@ -392,36 +394,49 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      lloncefn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      ret_ty,\n-                      substs.func_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, ret_ty);\n+    fcx = FunctionContext::new(ccx, lloncefn, fn_ty, ast::DUMMY_NODE_ID,\n+                               substs.func_substs, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n \n-    let mut llargs = get_params(fcx.llfn);\n \n     // the first argument (`self`) will be the (by value) closure env.\n     let self_scope = fcx.push_custom_cleanup_scope();\n     let self_scope_id = CustomScope(self_scope);\n-    let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n-    let self_idx = fcx.arg_offset();\n-    let llself = llargs[self_idx];\n-    let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n-    let env_datum = unpack_datum!(bcx,\n-                                  env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n-                                                                     self_scope_id));\n-\n-    debug!(\"trans_fn_once_adapter_shim: env_datum={:?}\",\n-           Value(env_datum.val));\n-    llargs[self_idx] = env_datum.val;\n+\n+    let mut llargs = get_params(fcx.llfn);\n+    let mut self_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    let env_arg = &fcx.fn_ty.args[0];\n+    let llenv = if env_arg.is_indirect() {\n+        Datum::new(llargs[self_idx], closure_ty, Rvalue::new(ByRef))\n+            .add_clean(&fcx, self_scope_id)\n+    } else {\n+        unpack_datum!(bcx, lvalue_scratch_datum(bcx, closure_ty, \"self\",\n+                                                InitAlloca::Dropped,\n+                                                self_scope_id, |bcx, llval| {\n+            let mut llarg_idx = self_idx;\n+            env_arg.store_fn_arg(bcx, &mut llarg_idx, llval);\n+            bcx.fcx.schedule_lifetime_end(self_scope_id, llval);\n+            bcx\n+        })).val\n+    };\n+\n+    debug!(\"trans_fn_once_adapter_shim: env={:?}\", Value(llenv));\n+    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n+    // For zero-sized closures that means sneaking in a new argument.\n+    if env_arg.is_ignore() {\n+        if self_idx > 0 {\n+            self_idx -= 1;\n+            llargs[self_idx] = llenv;\n+        } else {\n+            llargs.insert(0, llenv);\n+        }\n+    } else {\n+        llargs[self_idx] = llenv;\n+    }\n \n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n \n     let callee = Callee {\n         data: callee::Fn(llreffn),\n@@ -431,7 +446,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, self_scope);\n \n-    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     lloncefn\n }"}, {"sha": "e0a93c4916fc4a65d38718981ba333fc14d8cb19", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -22,7 +22,7 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::LangItem;\n use middle::subst::Substs;\n-use trans::abi::Abi;\n+use trans::abi::{Abi, FnType};\n use trans::base;\n use trans::build;\n use trans::builder::Builder;\n@@ -35,7 +35,6 @@ use trans::declare;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n-use trans::type_of;\n use trans::value::Value;\n use middle::ty::{self, Ty, TyCtxt};\n use middle::traits::{self, SelectionContext, ProjectionMode};\n@@ -107,12 +106,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-/// Identifies types which we declare to be equivalent to `void` in C for the purpose of function\n-/// return types. These are `()`, bot, uninhabited enums and all other zero-sized types.\n-pub fn return_type_is_void<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_nil() || ty.is_empty(ccx.tcx()) || type_is_zero_size(ccx, ty)\n-}\n-\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> ast::Name {\n@@ -291,9 +284,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // always an empty parameter-environment NOTE: @jroesch another use of ParamEnv\n     pub param_env: ty::ParameterEnvironment<'a, 'tcx>,\n \n-    // The environment argument in a closure.\n-    pub llenv: Option<ValueRef>,\n-\n     // A pointer to where to store the return value. If the return type is\n     // immediate, this points to an alloca in the function. Otherwise, it's a\n     // pointer to the hidden first parameter of the function. After function\n@@ -321,11 +311,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // Note that for cleanuppad-based exceptions this is not used.\n     pub landingpad_alloca: Cell<Option<ValueRef>>,\n \n-    // True if the caller expects this fn to use the out pointer to\n-    // return. Either way, your code should write into the slot llretslotptr\n-    // points to, but if this value is false, that slot will be a local alloca.\n-    pub caller_expects_out_pointer: bool,\n-\n     // Maps the DefId's for local variables to the allocas created for\n     // them in llallocas.\n     pub lllocals: RefCell<NodeMap<LvalueDatum<'tcx>>>,\n@@ -337,6 +322,9 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // paths) for the code being compiled.\n     pub lldropflag_hints: RefCell<DropFlagHintsMap<'tcx>>,\n \n+    // Describes the return/argument LLVM types and their ABI handling.\n+    pub fn_ty: FnType,\n+\n     // The NodeId of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n     pub id: ast::NodeId,\n@@ -372,18 +360,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.mir.unwrap()\n     }\n \n-    pub fn arg_offset(&self) -> usize {\n-        self.env_arg_pos() + if self.llenv.is_some() { 1 } else { 0 }\n-    }\n-\n-    pub fn env_arg_pos(&self) -> usize {\n-        if self.caller_expects_out_pointer {\n-            1\n-        } else {\n-            0\n-        }\n-    }\n-\n     pub fn cleanup(&self) {\n         unsafe {\n             llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt\n@@ -404,14 +380,9 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         self.llreturn.get().unwrap()\n     }\n \n-    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>,\n-                        output: ty::FnOutput<'tcx>,\n-                        name: &str) -> ValueRef {\n+    pub fn get_ret_slot(&self, bcx: Block<'a, 'tcx>, name: &str) -> ValueRef {\n         if self.needs_ret_allocas {\n-            base::alloca(bcx, match output {\n-                ty::FnConverging(output_type) => type_of::type_of(bcx.ccx(), output_type),\n-                ty::FnDiverging => Type::void(bcx.ccx())\n-            }, name)\n+            base::alloca(bcx, self.fn_ty.ret.memory_ty(self.ccx), name)\n         } else {\n             self.llretslotptr.get().unwrap()\n         }"}, {"sha": "91454df156655b4b149d5f3792d2acd41dda8b88", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -25,7 +25,6 @@ use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::machine;\n use trans;\n-use middle::ty;\n \n use rustc_front::hir;\n use rustc_front::util as ast_util;\n@@ -363,14 +362,12 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match (fcx.llretslotptr.get(), retval_expr) {\n-        (Some(_), Some(retval_expr)) => {\n-            let ret_ty = expr_ty_adjusted(bcx, &retval_expr);\n-            expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n-        }\n-        _ => expr::Ignore,\n-    };\n     if let Some(x) = retval_expr {\n+        let dest = if fcx.llretslotptr.get().is_some() {\n+            expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\"))\n+        } else {\n+            expr::Ignore\n+        };\n         bcx = expr::trans_into(bcx, &x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {"}, {"sha": "40eb29ed250506d7ef4351603ba3e5acb164ad08", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -35,7 +35,7 @@ use rustc_front::hir;\n use trans::abi::Abi;\n use trans::common::{NodeIdAndSpan, CrateContext, FunctionContext, Block};\n use trans;\n-use trans::{monomorphize, type_of};\n+use trans::monomorphize;\n use middle::infer;\n use middle::ty::{self, Ty};\n use session::config::{self, FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -456,17 +456,25 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ty::FnDiverging => diverging_type_metadata(cx)\n         });\n \n-        let inputs = &if abi == Abi::RustCall {\n-            type_of::untuple_arguments(cx, &sig.inputs)\n+        let inputs = if abi == Abi::RustCall {\n+            &sig.inputs[..sig.inputs.len()-1]\n         } else {\n-            sig.inputs\n+            &sig.inputs[..]\n         };\n \n         // Arguments types\n         for &argument_type in inputs {\n             signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n         }\n \n+        if abi == Abi::RustCall && !sig.inputs.is_empty() {\n+            if let ty::TyTuple(ref args) = sig.inputs[sig.inputs.len() - 1].sty {\n+                for &argument_type in args {\n+                    signature.push(type_metadata(cx, argument_type, codemap::DUMMY_SP));\n+                }\n+            }\n+        }\n+\n         return create_DIArray(DIB(cx), &signature[..]);\n     }\n "}, {"sha": "e63f17770bcecc3c2f1c94a0797faca457b263f9", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -92,24 +92,19 @@ pub fn declare_cfn(ccx: &CrateContext, name: &str, fn_type: Type) -> ValueRef {\n pub fn declare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n                             fn_type: ty::Ty<'tcx>) -> ValueRef {\n     debug!(\"declare_rust_fn(name={:?}, fn_type={:?})\", name, fn_type);\n-\n-    let f = match fn_type.sty {\n-        ty::TyFnDef(_, _, f) | ty::TyFnPtr(f) => f,\n-        _ => unreachable!(\"expected fn type for {:?}, found {:?}\", name, fn_type)\n-    };\n-\n-    let sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n+    let abi = fn_type.fn_abi();\n+    let sig = ccx.tcx().erase_late_bound_regions(fn_type.fn_sig());\n     let sig = infer::normalize_associated_type(ccx.tcx(), &sig);\n     debug!(\"declare_rust_fn (after region erasure) sig={:?}\", sig);\n \n-    let fty = FnType::new(ccx, f.abi, &sig, &[]);\n+    let fty = FnType::new(ccx, abi, &sig, &[]);\n     let llfn = declare_raw_fn(ccx, name, fty.cconv, fty.llvm_type(ccx));\n \n     if sig.output == ty::FnDiverging {\n         llvm::SetFunctionAttribute(llfn, llvm::Attribute::NoReturn);\n     }\n \n-    if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n+    if abi != Abi::Rust && abi != Abi::RustCall {\n         attributes::unwind(llfn, false);\n     }\n "}, {"sha": "c10bb76fb17d0778a722fcffb5cf90cae9b55936", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -1898,8 +1898,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let t_out = node_id_type(bcx, id);\n \n     debug!(\"trans_cast({:?} as {:?})\", t_in, t_out);\n-    let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n-    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n+    let mut ll_t_in = type_of::immediate_type_of(ccx, t_in);\n+    let ll_t_out = type_of::immediate_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n     let mut datum = unpack_datum!(bcx, trans(bcx, expr));"}, {"sha": "92a50ac3181fd0487585fb0380c3619539a5b8af", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 4, "deletions": 382, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -9,32 +9,17 @@\n // except according to those terms.\n \n \n-use back::link;\n-use llvm::{ValueRef, get_param};\n+use llvm::{ValueRef};\n use llvm;\n use middle::weak_lang_items;\n-use trans::abi::{Abi, FnType};\n-use trans::attributes;\n-use trans::base::{llvm_linkage_by_name, push_ctxt};\n-use trans::base;\n-use trans::build::*;\n+use trans::base::{llvm_linkage_by_name};\n use trans::common::*;\n-use trans::debuginfo::DebugLoc;\n use trans::declare;\n-use trans::machine;\n-use trans::monomorphize;\n-use trans::type_::Type;\n use trans::type_of;\n-use trans::value::Value;\n-use middle::infer;\n-use middle::ty::{self, Ty, TyCtxt};\n-use middle::subst::Substs;\n+use middle::ty;\n \n-use std::cmp;\n-use std::iter::once;\n-use libc::c_uint;\n use syntax::attr;\n-use syntax::parse::token::{InternedString, special_idents};\n+use syntax::parse::token::{InternedString};\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n@@ -95,369 +80,6 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => // Generate an external declaration.\n             declare::declare_global(ccx, &ident[..], llty),\n-    };\n-\n-    // Handle thread-local external statics.\n-    for attr in foreign_item.attrs.iter() {\n-        if attr.check_name(\"thread_local\") {\n-            llvm::set_thread_local(c, true);\n-        }\n-    }\n-\n-    return c;\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Rust functions with foreign ABIs\n-//\n-// These are normal Rust functions defined with foreign ABIs.  For\n-// now, and perhaps forever, we translate these using a \"layer of\n-// indirection\". That is, given a Rust declaration like:\n-//\n-//     extern \"C\" fn foo(i: u32) -> u32 { ... }\n-//\n-// we will generate a function like:\n-//\n-//     S foo(T i) {\n-//         S r;\n-//         foo0(&r, NULL, i);\n-//         return r;\n-//     }\n-//\n-//     #[inline_always]\n-//     void foo0(uint32_t *r, void *env, uint32_t i) { ... }\n-//\n-// Here the (internal) `foo0` function follows the Rust ABI as normal,\n-// where the `foo` function follows the C ABI. We rely on LLVM to\n-// inline the one into the other. Of course we could just generate the\n-// correct code in the first place, but this is much simpler.\n-\n-pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                decl: &hir::FnDecl,\n-                                                body: &hir::Block,\n-                                                attrs: &[ast::Attribute],\n-                                                llwrapfn: ValueRef,\n-                                                param_substs: &'tcx Substs<'tcx>,\n-                                                id: ast::NodeId,\n-                                                hash: Option<&str>) {\n-    let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n-\n-    let fnty = ccx.tcx().node_id_to_type(id);\n-    let mty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &fnty);\n-    let f = match mty.sty {\n-        ty::TyFnDef(_, _, f) => f,\n-        _ => ccx.sess().bug(\"trans_rust_fn_with_foreign_abi called on non-function type\")\n-    };\n-    assert!(f.abi != Abi::Rust);\n-    assert!(f.abi != Abi::RustIntrinsic);\n-    assert!(f.abi != Abi::PlatformIntrinsic);\n-\n-    let fn_sig = ccx.tcx().erase_late_bound_regions(&f.sig);\n-    let fn_sig = infer::normalize_associated_type(ccx.tcx(), &fn_sig);\n-    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::BareFnTy {\n-        unsafety: f.unsafety,\n-        abi: Abi::Rust,\n-        sig: ty::Binder(fn_sig.clone())\n-    });\n-    let fty = FnType::new(ccx, f.abi, &fn_sig, &[]);\n-    let rust_fty = FnType::new(ccx, Abi::Rust, &fn_sig, &[]);\n-\n-    unsafe { // unsafe because we call LLVM operations\n-        // Build up the Rust function (`foo0` above).\n-        let llrustfn = build_rust_fn(ccx, decl, body, param_substs,\n-                                     attrs, id, rust_fn_ty, hash);\n-\n-        // Build up the foreign wrapper (`foo` above).\n-        return build_wrap_fn(ccx, llrustfn, llwrapfn, &fn_sig, &fty, &rust_fty);\n-    }\n-\n-    fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               decl: &hir::FnDecl,\n-                               body: &hir::Block,\n-                               param_substs: &'tcx Substs<'tcx>,\n-                               attrs: &[ast::Attribute],\n-                               id: ast::NodeId,\n-                               rust_fn_ty: Ty<'tcx>,\n-                               hash: Option<&str>)\n-                               -> ValueRef\n-    {\n-        let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n-        let tcx = ccx.tcx();\n-\n-        let path =\n-            tcx.map.def_path(tcx.map.local_def_id(id))\n-                   .into_iter()\n-                   .map(|e| e.data.as_interned_str())\n-                   .chain(once(special_idents::clownshoe_abi.name.as_str()));\n-        let ps = link::mangle(path, hash);\n-\n-\n-        debug!(\"build_rust_fn: path={} id={} ty={:?}\",\n-               ccx.tcx().map.path_to_string(id),\n-               id, rust_fn_ty);\n-\n-        let llfn = declare::define_internal_fn(ccx, &ps, rust_fn_ty);\n-        attributes::from_fn_attrs(ccx, attrs, llfn);\n-        base::trans_fn(ccx, decl, body, llfn, param_substs, id, attrs);\n-        llfn\n-    }\n-\n-    unsafe fn build_wrap_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                      llrustfn: ValueRef,\n-                                      llwrapfn: ValueRef,\n-                                      fn_sig: &ty::FnSig<'tcx>,\n-                                      fn_ty: &FnType,\n-                                      rust_fty: &FnType) {\n-        let _icx = push_ctxt(\n-            \"foreign::trans_rust_fn_with_foreign_abi::build_wrap_fn\");\n-\n-        debug!(\"build_wrap_fn(llrustfn={:?}, llwrapfn={:?})\",\n-               Value(llrustfn),\n-               Value(llwrapfn));\n-\n-        // Avoid all the Rust generation stuff and just generate raw\n-        // LLVM here.\n-        //\n-        // We want to generate code like this:\n-        //\n-        //     S foo(T i) {\n-        //         S r;\n-        //         foo0(&r, NULL, i);\n-        //         return r;\n-        //     }\n-\n-        if llvm::LLVMCountBasicBlocks(llwrapfn) != 0 {\n-            ccx.sess().bug(\"wrapping a function inside non-empty wrapper, most likely cause is \\\n-                           multiple functions being wrapped\");\n-        }\n-\n-        let ptr = \"the block\\0\".as_ptr();\n-        let the_block = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llwrapfn,\n-                                                            ptr as *const _);\n-\n-        let builder = ccx.builder();\n-        builder.position_at_end(the_block);\n-\n-        // Array for the arguments we will pass to the rust function.\n-        let mut llrust_args = Vec::new();\n-        let mut next_foreign_arg_counter: c_uint = 0;\n-        let mut next_foreign_arg = |pad: bool| -> c_uint {\n-            next_foreign_arg_counter += if pad {\n-                2\n-            } else {\n-                1\n-            };\n-            next_foreign_arg_counter - 1\n-        };\n-\n-        // If there is an out pointer on the foreign function\n-        let foreign_outptr = {\n-            if fn_ty.ret.is_indirect() {\n-                Some(get_param(llwrapfn, next_foreign_arg(false)))\n-            } else {\n-                None\n-            }\n-        };\n-\n-        let rustfn_ty = Type::from_ref(llvm::LLVMTypeOf(llrustfn)).element_type();\n-        let mut rust_param_tys = rustfn_ty.func_params().into_iter();\n-        // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match fn_sig.output {\n-            ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n-            ty::FnDiverging => false\n-        };\n-        let return_alloca: Option<ValueRef>;\n-        let llrust_ret_ty = if rust_uses_outptr {\n-            rust_param_tys.next().expect(\"Missing return type!\").element_type()\n-        } else {\n-            rustfn_ty.return_type()\n-        };\n-        if rust_uses_outptr {\n-            // Rust expects to use an outpointer. If the foreign fn\n-            // also uses an outpointer, we can reuse it, but the types\n-            // may vary, so cast first to the Rust type. If the\n-            // foreign fn does NOT use an outpointer, we will have to\n-            // alloca some scratch space on the stack.\n-            match foreign_outptr {\n-                Some(llforeign_outptr) => {\n-                    debug!(\"out pointer, foreign={:?}\",\n-                           Value(llforeign_outptr));\n-                    let llrust_retptr =\n-                        builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n-                    debug!(\"out pointer, foreign={:?} (casted)\",\n-                           Value(llrust_retptr));\n-                    llrust_args.push(llrust_retptr);\n-                    return_alloca = None;\n-                }\n-\n-                None => {\n-                    let slot = builder.alloca(llrust_ret_ty, \"return_alloca\");\n-                    debug!(\"out pointer, \\\n-                            allocad={:?}, \\\n-                            llrust_ret_ty={:?}, \\\n-                            return_ty={:?}\",\n-                           Value(slot),\n-                           llrust_ret_ty,\n-                           fn_sig.output);\n-                    llrust_args.push(slot);\n-                    return_alloca = Some(slot);\n-                }\n-            }\n-        } else {\n-            // Rust does not expect an outpointer. If the foreign fn\n-            // does use an outpointer, then we will do a store of the\n-            // value that the Rust fn returns.\n-            return_alloca = None;\n-        };\n-\n-        // Build up the arguments to the call to the rust function.\n-        // Careful to adapt for cases where the native convention uses\n-        // a pointer and Rust does not or vice versa.\n-        let mut tys = fn_ty.args.iter().zip(rust_param_tys);\n-        for i in 0..fn_sig.inputs.len() {\n-            let rust_ty = fn_sig.inputs[i];\n-            let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let (llforeign_arg_ty, llty) = tys.next().expect(\"Not enough parameter types!\");\n-            let llrust_ty = if rust_indirect {\n-                llty.element_type()\n-            } else {\n-                llty\n-            };\n-            let foreign_indirect = llforeign_arg_ty.is_indirect();\n-\n-            if llforeign_arg_ty.is_ignore() {\n-                debug!(\"skipping ignored arg #{}\", i);\n-                llrust_args.push(C_undef(llrust_ty));\n-                continue;\n-            }\n-\n-            // skip padding\n-            let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n-            let mut llforeign_arg = get_param(llwrapfn, foreign_index);\n-\n-            if type_is_fat_ptr(ccx.tcx(), rust_ty) {\n-                // Fat pointers are one pointer and one integer or pointer.\n-                let a = llforeign_arg_ty;\n-                let (b, _) = tys.next().expect(\"Not enough parameter types!\");\n-                assert_eq!((a.cast, b.cast), (None, None));\n-                assert!(!a.is_indirect() && !b.is_indirect());\n-\n-                llrust_args.push(llforeign_arg);\n-                let foreign_index = next_foreign_arg(llforeign_arg_ty.pad.is_some());\n-                llrust_args.push(get_param(llwrapfn, foreign_index));\n-                continue;\n-            }\n-\n-            debug!(\"llforeign_arg {}{}: {:?}\", \"#\",\n-                   i, Value(llforeign_arg));\n-            debug!(\"rust_indirect = {}, foreign_indirect = {}\",\n-                   rust_indirect, foreign_indirect);\n-\n-            // Ensure that the foreign argument is indirect (by\n-            // pointer).  It makes adapting types easier, since we can\n-            // always just bitcast pointers.\n-            if !foreign_indirect {\n-                llforeign_arg = if rust_ty.is_bool() {\n-                    let lltemp = builder.alloca(Type::bool(ccx), \"\");\n-                    builder.store(builder.zext(llforeign_arg, Type::bool(ccx)), lltemp);\n-                    lltemp\n-                } else {\n-                    let lltemp = builder.alloca(val_ty(llforeign_arg), \"\");\n-                    builder.store(llforeign_arg, lltemp);\n-                    lltemp\n-                }\n-            }\n-\n-            // If the types in the ABI and the Rust types don't match,\n-            // bitcast the llforeign_arg pointer so it matches the types\n-            // Rust expects.\n-            if llforeign_arg_ty.cast.is_some() && !type_is_fat_ptr(ccx.tcx(), rust_ty){\n-                assert!(!foreign_indirect);\n-                llforeign_arg = builder.bitcast(llforeign_arg, llrust_ty.ptr_to());\n-            }\n-\n-            let llrust_arg = if rust_indirect || type_is_fat_ptr(ccx.tcx(), rust_ty) {\n-                llforeign_arg\n-            } else {\n-                if rust_ty.is_bool() {\n-                    let tmp = builder.load_range_assert(llforeign_arg, 0, 2, llvm::False);\n-                    builder.trunc(tmp, Type::i1(ccx))\n-                } else if type_of::type_of(ccx, rust_ty).is_aggregate() {\n-                    // We want to pass small aggregates as immediate values, but using an aggregate\n-                    // LLVM type for this leads to bad optimizations, so its arg type is an\n-                    // appropriately sized integer and we have to convert it\n-                    let tmp = builder.bitcast(llforeign_arg,\n-                                              type_of::arg_type_of(ccx, rust_ty).ptr_to());\n-                    let load = builder.load(tmp);\n-                    llvm::LLVMSetAlignment(load, type_of::align_of(ccx, rust_ty));\n-                    load\n-                } else {\n-                    builder.load(llforeign_arg)\n-                }\n-            };\n-\n-            debug!(\"llrust_arg {}{}: {:?}\", \"#\",\n-                   i, Value(llrust_arg));\n-            llrust_args.push(llrust_arg);\n-        }\n-\n-        // Perform the call itself\n-        debug!(\"calling llrustfn = {:?}\", Value(llrustfn));\n-        let llrust_ret_val = builder.call(llrustfn, &llrust_args, None);\n-        rust_fty.apply_attrs_callsite(llrust_ret_val);\n-\n-        // Get the return value where the foreign fn expects it.\n-        let llforeign_ret_ty = fn_ty.ret.cast.unwrap_or(fn_ty.ret.original_ty);\n-        match foreign_outptr {\n-            None if llforeign_ret_ty == Type::void(ccx) => {\n-                // Function returns `()` or `bot`, which in Rust is the LLVM\n-                // type \"{}\" but in foreign ABIs is \"Void\".\n-                builder.ret_void();\n-            }\n-\n-            None if rust_uses_outptr => {\n-                // Rust uses an outpointer, but the foreign ABI does not. Load.\n-                let llrust_outptr = return_alloca.unwrap();\n-                let llforeign_outptr_casted =\n-                    builder.bitcast(llrust_outptr, llforeign_ret_ty.ptr_to());\n-                let llforeign_retval = builder.load(llforeign_outptr_casted);\n-                builder.ret(llforeign_retval);\n-            }\n-\n-            None if llforeign_ret_ty != llrust_ret_ty => {\n-                // Neither ABI uses an outpointer, but the types don't\n-                // quite match. Must cast. Probably we should try and\n-                // examine the types and use a concrete llvm cast, but\n-                // right now we just use a temp memory location and\n-                // bitcast the pointer, which is the same thing the\n-                // old wrappers used to do.\n-                let lltemp = builder.alloca(llforeign_ret_ty, \"\");\n-                let lltemp_casted = builder.bitcast(lltemp, llrust_ret_ty.ptr_to());\n-                builder.store(llrust_ret_val, lltemp_casted);\n-                let llforeign_retval = builder.load(lltemp);\n-                builder.ret(llforeign_retval);\n-            }\n-\n-            None => {\n-                // Neither ABI uses an outpointer, and the types\n-                // match. Easy peasy.\n-                builder.ret(llrust_ret_val);\n-            }\n-\n-            Some(llforeign_outptr) if !rust_uses_outptr => {\n-                // Foreign ABI requires an out pointer, but Rust doesn't.\n-                // Store Rust return value.\n-                let llforeign_outptr_casted =\n-                    builder.bitcast(llforeign_outptr, llrust_ret_ty.ptr_to());\n-                builder.store(llrust_ret_val, llforeign_outptr_casted);\n-                builder.ret_void();\n-            }\n-\n-            Some(_) => {\n-                // Both ABIs use outpointers. Easy peasy.\n-                builder.ret_void();\n-            }\n-        }\n     }\n }\n "}, {"sha": "3e9cc19bf757d19fe86ad18377bf221d93a41ad1", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -21,6 +21,7 @@ use middle::lang_items::ExchangeFreeFnLangItem;\n use middle::subst::{Substs};\n use middle::traits;\n use middle::ty::{self, Ty, TyCtxt};\n+use trans::abi::{Abi, FnType};\n use trans::adt;\n use trans::adt::GetDtorType; // for tcx.dtor_type()\n use trans::base::*;\n@@ -40,7 +41,6 @@ use trans::type_::Type;\n use trans::value::Value;\n \n use arena::TypedArena;\n-use libc::c_uint;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n \n@@ -240,13 +240,17 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n     let t = g.ty();\n \n-    let llty = if type_is_sized(ccx.tcx(), t) {\n-        type_of(ccx, t).ptr_to()\n-    } else {\n-        type_of(ccx, ccx.tcx().mk_box(t)).ptr_to()\n+    let tcx = ccx.tcx();\n+    let sig = ty::FnSig {\n+        inputs: vec![tcx.mk_mut_ptr(tcx.types.i8)],\n+        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+        variadic: false,\n     };\n-\n-    let llfnty = Type::glue_fn(ccx, llty);\n+    // Create a FnType for fn(*mut i8) and substitute the real type in\n+    // later - that prevents FnType from splitting fat pointers up.\n+    let mut fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+    fn_ty.args[0].original_ty = type_of(ccx, t).ptr_to();\n+    let llfnty = fn_ty.llvm_type(ccx);\n \n     // To avoid infinite recursion, don't `make_drop_glue` until after we've\n     // added the entry to the `drop_glues` cache.\n@@ -260,17 +264,17 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     assert!(declare::get_defined_value(ccx, &fn_nm).is_none());\n     let llfn = declare::declare_cfn(ccx, &fn_nm, llfnty);\n     ccx.available_drop_glues().borrow_mut().insert(g, fn_nm);\n+    ccx.drop_glues().borrow_mut().insert(g, llfn);\n \n     let _s = StatRecorder::new(ccx, format!(\"drop {:?}\", t));\n \n-    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      ty::FnConverging(ccx.tcx().mk_nil()),\n-                      empty_substs, None, &arena);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n+                               empty_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ccx.tcx().mk_nil()));\n+    let bcx = fcx.init(false);\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -283,9 +287,8 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let llrawptr0 = get_param(llfn, fcx.arg_offset() as c_uint);\n-    let bcx = make_drop_glue(bcx, llrawptr0, g);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ccx.tcx().mk_nil()), DebugLoc::None);\n+    let bcx = make_drop_glue(bcx, get_param(llfn, 0), g);\n+    fcx.finish(bcx, DebugLoc::None);\n \n     llfn\n }"}, {"sha": "df8bdb05fcd81ecc1e2dcd7695eb4dfe4a686921", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 48, "deletions": 62, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -270,7 +270,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let val = if datum.kind.is_by_ref() {\n                         load_ty(bcx, datum.val, datum.ty)\n                     } else {\n-                        from_arg_ty(bcx, datum.val, datum.ty)\n+                        from_immediate(bcx, datum.val)\n                     };\n \n                     let cast_val = BitCast(bcx, val, llret_ty);\n@@ -509,14 +509,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"init_dropped\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            if !return_type_is_void(ccx, tp_ty) {\n+            if !type_is_zero_size(ccx, tp_ty) {\n                 drop_done_fill_mem(bcx, llresult, tp_ty);\n             }\n             C_nil(ccx)\n         }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            if !return_type_is_void(ccx, tp_ty) {\n+            if !type_is_zero_size(ccx, tp_ty) {\n                 // Just zero out the stack slot. (See comment on base::memzero for explanation)\n                 init_zero_mem(bcx, llresult, tp_ty);\n             }\n@@ -603,21 +603,24 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"volatile_load\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            let mut ptr = llargs[0];\n+            if let Some(ty) = fn_ty.ret.cast {\n+                ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+            }\n             let load = VolatileLoad(bcx, ptr);\n             unsafe {\n                 llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n             }\n-            to_arg_ty(bcx, load, tp_ty)\n+            to_immediate(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n-            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n             let val = if type_is_immediate(bcx.ccx(), tp_ty) {\n-                from_arg_ty(bcx, llargs[1], tp_ty)\n+                from_immediate(bcx, llargs[1])\n             } else {\n                 Load(bcx, llargs[1])\n             };\n+            let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n             let store = VolatileStore(bcx, val, ptr);\n             unsafe {\n                 llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n@@ -684,7 +687,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n \n         (_, \"return_address\") => {\n-            if !fcx.caller_expects_out_pointer {\n+            if !fcx.fn_ty.ret.is_indirect() {\n                 span_err!(tcx.sess, call_info.span, E0510,\n                           \"invalid use of `return_address` intrinsic: function \\\n                            does not use out pointer\");\n@@ -746,19 +749,17 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n             match split[1] {\n                 \"cxchg\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n-                    let src = from_arg_ty(bcx, llargs[2], tp_ty);\n+                    let cmp = from_immediate(bcx, llargs[1]);\n+                    let src = from_immediate(bcx, llargs[2]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n                     let res = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::False);\n                     ExtractValue(bcx, res, 0)\n                 }\n \n                 \"cxchgweak\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let cmp = from_arg_ty(bcx, llargs[1], tp_ty);\n-                    let src = from_arg_ty(bcx, llargs[2], tp_ty);\n+                    let cmp = from_immediate(bcx, llargs[1]);\n+                    let src = from_immediate(bcx, llargs[2]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(src).ptr_to());\n                     let val = AtomicCmpXchg(bcx, ptr, cmp, src, order, failorder, llvm::True);\n                     let result = ExtractValue(bcx, val, 0);\n                     let success = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n@@ -769,13 +770,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n                 \"load\" => {\n                     let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    to_arg_ty(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n+                    let mut ptr = llargs[0];\n+                    if let Some(ty) = fn_ty.ret.cast {\n+                        ptr = PointerCast(bcx, ptr, ty.ptr_to());\n+                    }\n+                    to_immediate(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n                 \"store\" => {\n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let val = from_arg_ty(bcx, llargs[1], tp_ty);\n+                    let val = from_immediate(bcx, llargs[1]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n                     AtomicStore(bcx, val, ptr, order);\n                     C_nil(ccx)\n                 }\n@@ -807,9 +810,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    let tp_ty = *substs.types.get(FnSpace, 0);\n-                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-                    let val = from_arg_ty(bcx, llargs[1], tp_ty);\n+                    let val = from_immediate(bcx, llargs[1]);\n+                    let ptr = PointerCast(bcx, llargs[0], val_ty(val).ptr_to());\n                     AtomicRMW(bcx, atom_op, ptr, val, order)\n                 }\n             }\n@@ -1279,21 +1281,33 @@ fn trans_gnu_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // This is currently primarily used for the `try` intrinsic functions above.\n fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     name: &str,\n-                    ty: Ty<'tcx>,\n+                    inputs: Vec<Ty<'tcx>>,\n                     output: ty::FnOutput<'tcx>,\n                     trans: &mut for<'b> FnMut(Block<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n-    let llfn = declare::define_internal_fn(ccx, name, ty);\n+    let sig = ty::FnSig {\n+        inputs: inputs,\n+        output: output,\n+        variadic: false,\n+    };\n+    let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n+\n+    let rust_fn_ty = ccx.tcx().mk_fn_ptr(ty::BareFnTy {\n+        unsafety: hir::Unsafety::Unsafe,\n+        abi: Abi::Rust,\n+        sig: ty::Binder(sig)\n+    });\n+    let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n     let (fcx, block_arena);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                      output, ccx.tcx().mk_substs(Substs::trans_empty()),\n-                      None, &block_arena);\n-    let bcx = init_function(&fcx, true, output);\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n+                               ccx.tcx().mk_substs(Substs::trans_empty()),\n+                               None, &block_arena);\n+    let bcx = fcx.init(true);\n     trans(bcx);\n     fcx.cleanup();\n-    return llfn\n+    llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n@@ -1321,17 +1335,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         }),\n     });\n     let output = ty::FnOutput::FnConverging(tcx.types.i32);\n-    let try_fn_ty  = ty::BareFnTy {\n-        unsafety: hir::Unsafety::Unsafe,\n-        abi: Abi::Rust,\n-        sig: ty::Binder(ty::FnSig {\n-            inputs: vec![fn_ty, i8p, i8p],\n-            output: output,\n-            variadic: false,\n-        }),\n-    };\n-    let rust_try = gen_fn(fcx, \"__rust_try\", tcx.mk_fn_ptr(try_fn_ty), output,\n-                          trans);\n+    let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try\n }\n@@ -1399,16 +1403,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // going on here, all I can say is that there's a few tests cases in\n         // LLVM's test suite which follow this pattern of instructions, so we\n         // just do the same.\n-        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![],\n-                output: output,\n-                variadic: false,\n-            }),\n-        });\n-        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n+        gen_fn(fcx, \"__rustc_try_filter\", vec![], output, &mut |bcx| {\n             let ebp = Call(bcx, frameaddress, &[C_i32(ccx, 1)], dloc);\n             let exn = InBoundsGEP(bcx, ebp, &[C_i32(ccx, -20)]);\n             let exn = Load(bcx, BitCast(bcx, exn, Type::i8p(ccx).ptr_to()));\n@@ -1418,16 +1413,7 @@ fn generate_filter_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         // Conveniently on x86_64 the EXCEPTION_POINTERS handle and base pointer\n         // are passed in as arguments to the filter function, so we just pass\n         // those along.\n-        let filter_fn_ty = tcx.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: vec![i8p, i8p],\n-                output: output,\n-                variadic: false,\n-            }),\n-        });\n-        gen_fn(fcx, \"__rustc_try_filter\", filter_fn_ty, output, &mut |bcx| {\n+        gen_fn(fcx, \"__rustc_try_filter\", vec![i8p, i8p], output, &mut |bcx| {\n             let exn = llvm::get_param(bcx.fcx.llfn, 0);\n             let rbp = llvm::get_param(bcx.fcx.llfn, 1);\n             do_trans(bcx, exn, rbp);"}, {"sha": "551bae8f4148dda5bbb8b39962bb686228d54aa1", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 18, "deletions": 35, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -18,13 +18,13 @@ use middle::infer;\n use middle::subst::{Subst, Substs};\n use middle::subst;\n use middle::traits::{self, ProjectionMode};\n+use trans::abi::FnType;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::{Callee, Virtual, ArgVals, trans_fn_pointer_shim};\n use trans::closure;\n use trans::common::*;\n use trans::consts;\n-use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::declare;\n use trans::expr;\n@@ -77,66 +77,49 @@ pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                    method_ty: Ty<'tcx>,\n                                    vtable_index: usize)\n-                                   -> Datum<'tcx, Rvalue> {\n+                                   -> ValueRef {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n     debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n            vtable_index,\n            method_ty);\n \n-    let ret_ty = tcx.erase_late_bound_regions(&method_ty.fn_ret());\n-    let ret_ty = infer::normalize_associated_type(tcx, &ret_ty);\n+    let sig = tcx.erase_late_bound_regions(&method_ty.fn_sig());\n+    let sig = infer::normalize_associated_type(tcx, &sig);\n+    let fn_ty = FnType::new(ccx, method_ty.fn_abi(), &sig, &[]);\n \n-    let shim_fn_ty = match method_ty.sty {\n-        ty::TyFnDef(_, _, fty) => tcx.mk_ty(ty::TyFnPtr(fty)),\n-        _ => unreachable!(\"expected fn item type, found {}\", method_ty)\n-    };\n-\n-    //\n-    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, shim_fn_ty, \"object_shim\");\n-    let llfn = declare::define_internal_fn(ccx, &function_name, shim_fn_ty);\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, method_ty, \"object_shim\");\n+    let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n \n     let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n-    fcx = new_fn_ctxt(ccx,\n-                      llfn,\n-                      ast::DUMMY_NODE_ID,\n-                      false,\n-                      ret_ty,\n-                      empty_substs,\n-                      None,\n-                      &block_arena);\n-    let mut bcx = init_function(&fcx, false, ret_ty);\n-\n-    let llargs = get_params(fcx.llfn);\n-\n-    let self_idx = fcx.arg_offset();\n-    let llself = llargs[self_idx];\n-    let llvtable = llargs[self_idx + 1];\n-\n-    debug!(\"trans_object_shim: llself={:?}, llvtable={:?}\",\n-           Value(llself), Value(llvtable));\n-\n+    fcx = FunctionContext::new(ccx, llfn, fn_ty, ast::DUMMY_NODE_ID,\n+                               empty_substs, None, &block_arena);\n+    let mut bcx = fcx.init(false);\n     assert!(!fcx.needs_ret_allocas);\n \n+\n     let dest =\n         fcx.llretslotptr.get().map(\n-            |_| expr::SaveIn(fcx.get_ret_slot(bcx, ret_ty, \"ret_slot\")));\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, \"ret_slot\")));\n \n     debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n            vtable_index);\n \n+    let llargs = get_params(fcx.llfn);\n+    let args = ArgVals(&llargs[fcx.fn_ty.ret.is_indirect() as usize..]);\n+\n     let callee = Callee {\n         data: Virtual(vtable_index),\n         ty: method_ty\n     };\n-    bcx = callee.call(bcx, DebugLoc::None, ArgVals(&llargs[self_idx..]), dest).bcx;\n+    bcx = callee.call(bcx, DebugLoc::None, args, dest).bcx;\n \n-    finish_fn(&fcx, bcx, ret_ty, DebugLoc::None);\n+    fcx.finish(bcx, DebugLoc::None);\n \n-    immediate_rvalue(llfn, shim_fn_ty)\n+    llfn\n }\n \n /// Creates a returns a dynamic vtable for the given type and vtable origin."}, {"sha": "0eea8fea8268a8371eb06e755bab9dbb15edd2c2", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -113,9 +113,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::Terminator::Return => {\n-                let return_ty = bcx.monomorphize(&self.mir.return_ty);\n                 bcx.with_block(|bcx| {\n-                    base::build_return_block(self.fcx, bcx, return_ty, DebugLoc::None);\n+                    self.fcx.build_return_block(bcx, DebugLoc::None);\n                 })\n             }\n "}, {"sha": "796a7c551f3999baefa62cb7a9a4128f184e0b97", "filename": "src/librustc_trans/trans/mir/lvalue.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Flvalue.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -17,7 +17,6 @@ use trans::base;\n use trans::common::{self, BlockAndBuilder};\n use trans::consts;\n use trans::machine;\n-use trans::type_of;\n use trans::mir::drop;\n use llvm;\n use trans::Disr;\n@@ -93,23 +92,23 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 LvalueRef::new_sized(consts::get_static(ccx, def_id).val, const_ty)\n             },\n             mir::Lvalue::ReturnPointer => {\n-                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n-                let return_ty = fn_return_ty.unwrap();\n-                let llval = if !common::return_type_is_void(bcx.ccx(), return_ty) {\n+                let llval = if !fcx.fn_ty.ret.is_ignore() {\n                     bcx.with_block(|bcx| {\n-                        fcx.get_ret_slot(bcx, fn_return_ty, \"\")\n+                        fcx.get_ret_slot(bcx, \"\")\n                     })\n                 } else {\n                     // This is a void return; that is, there\u2019s no place to store the value and\n                     // there cannot really be one (or storing into it doesn\u2019t make sense, anyway).\n                     // Ergo, we return an undef ValueRef, so we do not have to special-case every\n                     // place using lvalues, and could use it the same way you use a regular\n                     // ReturnPointer LValue (i.e. store into it, load from it etc).\n-                    let llty = type_of::type_of(bcx.ccx(), return_ty).ptr_to();\n+                    let llty = fcx.fn_ty.ret.original_ty.ptr_to();\n                     unsafe {\n                         llvm::LLVMGetUndef(llty.to_ref())\n                     }\n                 };\n+                let fn_return_ty = bcx.monomorphize(&self.mir.return_ty);\n+                let return_ty = fn_return_ty.unwrap();\n                 LvalueRef::new_sized(llval, LvalueTy::from_ty(return_ty))\n             },\n             mir::Lvalue::Projection(ref projection) => {"}, {"sha": "dac9310c8b9e1eefd0b623cc725ad46de7c87af4", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -13,9 +13,8 @@ use llvm::{self, ValueRef};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n-use trans::common::{self, Block, BlockAndBuilder};\n+use trans::common::{self, Block, BlockAndBuilder, FunctionContext};\n use trans::expr;\n-use trans::type_of;\n \n use self::lvalue::LvalueRef;\n use self::operand::OperandRef;\n@@ -77,11 +76,11 @@ enum TempRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n-    let fcx = bcx.fcx();\n+pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n+    let bcx = fcx.init(false).build();\n     let mir = bcx.mir();\n \n-    let mir_blocks = bcx.mir().all_basic_blocks();\n+    let mir_blocks = mir.all_basic_blocks();\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n@@ -111,7 +110,7 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n     let args = arg_value_refs(&bcx, mir);\n \n     // Allocate a `Block` for every basic block\n-    let block_bcxs: Vec<Block<'bcx,'tcx>> =\n+    let block_bcxs: Vec<Block<'blk,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n                       // FIXME(#30941) this doesn't handle msvc-style exceptions\n@@ -138,6 +137,8 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n     for &bb in &mir_blocks {\n         mircx.trans_block(bb);\n     }\n+\n+    fcx.cleanup();\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the\n@@ -149,48 +150,41 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n     // FIXME tupled_args? I think I'd rather that mapping is done in MIR land though\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n-    let mut idx = fcx.arg_offset() as c_uint;\n-    mir.arg_decls\n-       .iter()\n-       .enumerate()\n-       .map(|(arg_index, arg_decl)| {\n-           let arg_ty = bcx.monomorphize(&arg_decl.ty);\n-           let llval = if type_of::arg_is_indirect(bcx.ccx(), arg_ty) {\n-               // Don't copy an indirect argument to an alloca, the caller\n-               // already put it in a temporary alloca and gave it up, unless\n-               // we emit extra-debug-info, which requires local allocas :(.\n-               // FIXME: lifetimes, debug info\n-               let llarg = llvm::get_param(fcx.llfn, idx);\n-               idx += 1;\n-               llarg\n-           } else if common::type_is_fat_ptr(tcx, arg_ty) {\n-               // we pass fat pointers as two words, but we want to\n-               // represent them internally as a pointer to two words,\n-               // so make an alloca to store them in.\n-               let lldata = llvm::get_param(fcx.llfn, idx);\n-               let llextra = llvm::get_param(fcx.llfn, idx + 1);\n-               idx += 2;\n-               let (lltemp, dataptr, meta) = bcx.with_block(|bcx| {\n-                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                   (lltemp, expr::get_dataptr(bcx, lltemp), expr::get_meta(bcx, lltemp))\n-               });\n-               bcx.store(lldata, dataptr);\n-               bcx.store(llextra, meta);\n-               lltemp\n-           } else {\n-               // otherwise, arg is passed by value, so make a\n-               // temporary and store it there\n-               let llarg = llvm::get_param(fcx.llfn, idx);\n-               idx += 1;\n-               bcx.with_block(|bcx| {\n-                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n-                   base::store_ty(bcx, llarg, lltemp, arg_ty);\n-                   lltemp\n-               })\n-           };\n-           LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n-       })\n-       .collect()\n+    let mut idx = 0;\n+    let mut llarg_idx = fcx.fn_ty.ret.is_indirect() as usize;\n+    mir.arg_decls.iter().enumerate().map(|(arg_index, arg_decl)| {\n+        let arg = &fcx.fn_ty.args[idx];\n+        idx += 1;\n+        let arg_ty = bcx.monomorphize(&arg_decl.ty);\n+        let llval = if arg.is_indirect() {\n+            // Don't copy an indirect argument to an alloca, the caller\n+            // already put it in a temporary alloca and gave it up, unless\n+            // we emit extra-debug-info, which requires local allocas :(.\n+            // FIXME: lifetimes, debug info\n+            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            llarg_idx += 1;\n+            llarg\n+        } else {\n+            bcx.with_block(|bcx| {\n+                let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                if common::type_is_fat_ptr(tcx, arg_ty) {\n+                    // we pass fat pointers as two words, but we want to\n+                    // represent them internally as a pointer to two words,\n+                    // so make an alloca to store them in.\n+                    let meta = &fcx.fn_ty.args[idx];\n+                    idx += 1;\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, expr::get_dataptr(bcx, lltemp));\n+                    meta.store_fn_arg(bcx, &mut llarg_idx, expr::get_meta(bcx, lltemp));\n+                } else  {\n+                    // otherwise, arg is passed by value, so make a\n+                    // temporary and store it there\n+                    arg.store_fn_arg(bcx, &mut llarg_idx, lltemp);\n+                }\n+                lltemp\n+            })\n+        };\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n+    }).collect()\n }\n \n mod analyze;"}, {"sha": "6c4fa9cd3bdd3c375365e62b4ad4ed3f3a2a05de", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -246,8 +246,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         debug_assert!(common::type_is_immediate(bcx.ccx(), cast_ty));\n                         let r_t_in = CastTy::from_ty(operand.ty).expect(\"bad input type for cast\");\n                         let r_t_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                        let ll_t_in = type_of::arg_type_of(bcx.ccx(), operand.ty);\n-                        let ll_t_out = type_of::arg_type_of(bcx.ccx(), cast_ty);\n+                        let ll_t_in = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n+                        let ll_t_out = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n                         let (llval, ll_t_in, signed) = if let CastTy::Int(IntTy::CEnum) = r_t_in {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n                             let llval = operand.immediate();\n@@ -308,8 +308,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         OperandValue::Immediate(newval)\n                     }\n                     mir::CastKind::Misc => { // Casts from a fat-ptr.\n-                        let ll_cast_ty = type_of::arg_type_of(bcx.ccx(), cast_ty);\n-                        let ll_from_ty = type_of::arg_type_of(bcx.ccx(), operand.ty);\n+                        let ll_cast_ty = type_of::immediate_type_of(bcx.ccx(), cast_ty);\n+                        let ll_from_ty = type_of::immediate_type_of(bcx.ccx(), operand.ty);\n                         if let OperandValue::FatPtr(data_ptr, meta_ptr) = operand.val {\n                             if common::type_is_fat_ptr(bcx.tcx(), cast_ty) {\n                                 let ll_cft = ll_cast_ty.field_types();"}, {"sha": "f4ae60b356bbd8e2bba07305c598f06d6287ebf9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -16,14 +16,12 @@ use middle::infer::normalize_associated_type;\n use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n-use trans::abi::Abi;\n use trans::attributes;\n use trans::base::{push_ctxt};\n use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n use trans::declare;\n-use trans::foreign;\n use middle::ty::{self, Ty, TyCtxt};\n use trans::Disr;\n use rustc::front::map as hir_map;\n@@ -129,15 +127,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         });\n     match map_node {\n         hir_map::NodeItem(&hir::Item {\n-            ref attrs, node: hir::ItemFn(ref decl, _, _, abi, _, ref body), ..\n+            ref attrs, node: hir::ItemFn(ref decl, _, _, _, _, ref body), ..\n         }) |\n         hir_map::NodeTraitItem(&hir::TraitItem {\n             ref attrs, node: hir::MethodTraitItem(\n-                hir::MethodSig { abi, ref decl, .. }, Some(ref body)), ..\n+                hir::MethodSig { ref decl, .. }, Some(ref body)), ..\n         }) |\n         hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, node: hir::ImplItemKind::Method(\n-                hir::MethodSig { abi, ref decl, .. }, ref body), ..\n+                hir::MethodSig { ref decl, .. }, ref body), ..\n         }) => {\n             base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n             attributes::from_fn_attrs(ccx, attrs, lldecl);\n@@ -153,13 +151,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n \n             if trans_everywhere || is_first {\n-                if abi != Abi::Rust && abi != Abi::RustCall {\n-                    foreign::trans_rust_fn_with_foreign_abi(\n-                        ccx, decl, body, attrs, lldecl, psubsts, fn_node_id,\n-                        Some(&hash));\n-                } else {\n-                    trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id, attrs);\n-                }\n+                trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id, attrs);\n             }\n         }\n "}, {"sha": "57bd0ba81581642b1d2d0961bac97354548b9dc4", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -183,10 +183,6 @@ impl Type {\n         Type::struct_(ccx, &[], false)\n     }\n \n-    pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n-        Type::func(&[t], &Type::void(ccx))\n-    }\n-\n     pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMRustArrayType(ty.to_ref(), len))\n     }\n@@ -206,7 +202,7 @@ impl Type {\n     }\n \n     pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n-        Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n+        Type::func(&[Type::i8p(ccx)], &Type::void(ccx)).ptr_to().ptr_to()\n     }\n \n     pub fn kind(&self) -> TypeKind {"}, {"sha": "7d5218d84dafe780f7ce92a0091de2e2f7b681e0", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aec63821d04872f9190c3d8606d0a58428005222/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=aec63821d04872f9190c3d8606d0a58428005222", "patch": "@@ -35,58 +35,6 @@ fn ensure_array_fits_in_address_space<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn arg_is_indirect<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                 arg_ty: Ty<'tcx>) -> bool {\n-    !type_is_immediate(ccx, arg_ty) && !type_is_fat_ptr(ccx.tcx(), arg_ty)\n-}\n-\n-pub fn return_uses_outptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ty: Ty<'tcx>) -> bool {\n-    arg_is_indirect(ccx, ty)\n-}\n-\n-pub fn type_of_explicit_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                      arg_ty: Ty<'tcx>) -> Type {\n-    let llty = arg_type_of(ccx, arg_ty);\n-    if arg_is_indirect(ccx, arg_ty) {\n-        llty.ptr_to()\n-    } else {\n-        llty\n-    }\n-}\n-\n-/// Yields the types of the \"real\" arguments for a function using the `RustCall`\n-/// ABI by untupling the arguments of the function.\n-pub fn untuple_arguments<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                   inputs: &[Ty<'tcx>])\n-                                   -> Vec<Ty<'tcx>> {\n-    if inputs.is_empty() {\n-        return Vec::new()\n-    }\n-\n-    let mut result = Vec::new();\n-    for (i, &arg_prior_to_tuple) in inputs.iter().enumerate() {\n-        if i < inputs.len() - 1 {\n-            result.push(arg_prior_to_tuple);\n-        }\n-    }\n-\n-    match inputs[inputs.len() - 1].sty {\n-        ty::TyTuple(ref tupled_arguments) => {\n-            debug!(\"untuple_arguments(): untupling arguments\");\n-            for &tupled_argument in tupled_arguments {\n-                result.push(tupled_argument);\n-            }\n-        }\n-        _ => {\n-            ccx.tcx().sess.bug(\"argument to function with \\\"rust-call\\\" ABI \\\n-                                is neither a tuple nor unit\")\n-        }\n-    }\n-\n-    result\n-}\n-\n // A \"sizing type\" is an LLVM type, the size and alignment of which are\n // guaranteed to be equivalent to what you would get out of `type_of()`. It's\n // useful because:\n@@ -189,16 +137,9 @@ fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type\n     }\n }\n \n-pub fn arg_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n+pub fn immediate_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     if t.is_bool() {\n         Type::i1(cx)\n-    } else if type_is_immediate(cx, t) && type_of(cx, t).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        match machine::llsize_of_alloc(cx, sizing_type_of(cx, t)) {\n-            0 => type_of(cx, t),\n-            n => Type::ix(cx, n * 8),\n-        }\n     } else {\n         type_of(cx, t)\n     }"}]}