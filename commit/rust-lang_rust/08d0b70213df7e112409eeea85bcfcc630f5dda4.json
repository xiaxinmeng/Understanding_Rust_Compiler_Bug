{"sha": "08d0b70213df7e112409eeea85bcfcc630f5dda4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDBiNzAyMTNkZjdlMTEyNDA5ZWVlYTg1YmNmY2M2MzBmNWRkYTQ=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-04T02:49:44Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-06T02:05:08Z"}, "message": "extra: Simplify the bitv iterators using Repeat", "tree": {"sha": "606b4c6264d3ed8fad803f3f593188d755b6eb2f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/606b4c6264d3ed8fad803f3f593188d755b6eb2f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d0b70213df7e112409eeea85bcfcc630f5dda4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d0b70213df7e112409eeea85bcfcc630f5dda4", "html_url": "https://github.com/rust-lang/rust/commit/08d0b70213df7e112409eeea85bcfcc630f5dda4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d0b70213df7e112409eeea85bcfcc630f5dda4/comments", "author": null, "committer": null, "parents": [{"sha": "b5cd81d0e54fb2310ce0de6f746957501130ce5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5cd81d0e54fb2310ce0de6f746957501130ce5f", "html_url": "https://github.com/rust-lang/rust/commit/b5cd81d0e54fb2310ce0de6f746957501130ce5f"}], "stats": {"total": 63, "additions": 19, "deletions": 44}, "files": [{"sha": "f32170a3a6de6aa02b6235bda50d13b53a5a08f2", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/08d0b70213df7e112409eeea85bcfcc630f5dda4/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d0b70213df7e112409eeea85bcfcc630f5dda4/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=08d0b70213df7e112409eeea85bcfcc630f5dda4", "patch": "@@ -13,7 +13,7 @@\n \n use std::cmp;\n use std::iterator::RandomAccessIterator;\n-use std::iterator::{Invert, Enumerate};\n+use std::iterator::{Invert, Enumerate, Repeat, Map, Zip};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -864,13 +864,12 @@ impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn common_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint,&uint),(uint,uint,uint), &'a ~[uint],Enumerate<vec::VecIterator<'a,uint>>> {\n-        let min = num::min(self.bitv.storage.len(),\n-                            other.bitv.storage.len());\n-        MapE{iter: self.bitv.storage.slice(0, min).iter().enumerate(),\n-             env: &other.bitv.storage,\n-             f: |(i, &w): (uint, &uint), o_store| (i * uint::bits, w, o_store[i])\n-        }\n+        -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+        let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n+        self.bitv.storage.slice(0, min).iter().enumerate()\n+            .zip(Repeat::new(&other.bitv.storage))\n+            .transform(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -881,45 +880,21 @@ impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint, &uint),(bool, uint, uint), uint, Enumerate<vec::VecIterator<'a, uint>>> {\n-        let len1 = self.bitv.storage.len();\n-        let len2 = other.bitv.storage.len();\n-        let min = num::min(len1, len2);\n-\n-        if min < len1 {\n-            MapE{iter: self.bitv.storage.slice(min, len1).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (true, (i + min) * uint::bits, w)\n-            }\n+        -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {\n+        let slen = self.bitv.storage.len();\n+        let olen = other.bitv.storage.len();\n+\n+        if olen < slen {\n+            self.bitv.storage.slice_from(olen).iter().enumerate()\n+                .zip(Repeat::new(olen))\n+                .transform(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n         } else {\n-            MapE{iter: other.bitv.storage.slice(min, len2).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (false, (i + min) * uint::bits, w)\n-            }\n-        }\n-    }\n-}\n-\n-/// Like iterator::Map with explicit env capture\n-struct MapE<A, B, Env, I> {\n-    priv env: Env,\n-    priv f: &'static fn(A, Env) -> B,\n-    priv iter: I,\n-}\n-\n-impl<'self, A, B, Env: Clone, I: Iterator<A>> Iterator<B> for MapE<A, B, Env, I> {\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n-            Some(elt) => Some((self.f)(elt, self.env.clone())),\n-            None => None\n+            other.bitv.storage.slice_from(slen).iter().enumerate()\n+                .zip(Repeat::new(slen))\n+                .transform(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n         }\n     }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n }\n \n pub struct BitvSetIterator<'self> {"}]}