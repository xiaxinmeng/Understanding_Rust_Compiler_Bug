{"sha": "1df6ddd08c3155e64806cd54b878337814401b7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZjZkZGQwOGMzMTU1ZTY0ODA2Y2Q1NGI4NzgzMzc4MTQ0MDFiN2U=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-21T00:09:30Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-06-21T00:56:40Z"}, "message": "doc: add information about suffix inference to tutorial and manual.", "tree": {"sha": "92eeef636afd56b8ab20dd2ed10d39b0ce1aa129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92eeef636afd56b8ab20dd2ed10d39b0ce1aa129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1df6ddd08c3155e64806cd54b878337814401b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1df6ddd08c3155e64806cd54b878337814401b7e", "html_url": "https://github.com/rust-lang/rust/commit/1df6ddd08c3155e64806cd54b878337814401b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1df6ddd08c3155e64806cd54b878337814401b7e/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dcf84e4f4a9a54254fd426609ad9f1ccffae3b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dcf84e4f4a9a54254fd426609ad9f1ccffae3b9", "html_url": "https://github.com/rust-lang/rust/commit/4dcf84e4f4a9a54254fd426609ad9f1ccffae3b9"}], "stats": {"total": 101, "additions": 88, "deletions": 13}, "files": [{"sha": "3f4e39d95c8653e31d57156300cdf0c27da9c57d", "filename": "doc/rust.md", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1df6ddd08c3155e64806cd54b878337814401b7e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/1df6ddd08c3155e64806cd54b878337814401b7e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=1df6ddd08c3155e64806cd54b878337814401b7e", "patch": "@@ -330,24 +330,32 @@ An _integer literal_ has one of three forms:\n   * A _binary literal_ starts with the character sequence `U+0030` `U+0062`\n     (`0b`) and continues as any mixture binary digits and underscores.\n \n-By default, an integer literal is of type `int`. An integer literal may be\n-followed (immediately, without any spaces) by an _integer suffix_, which\n-changes the type of the literal. There are two kinds of integer literal\n-suffix:\n+An integer literal may be followed (immediately, without any spaces) by an\n+_integer suffix_, which changes the type of the literal. There are two kinds\n+of integer literal suffix:\n \n-  * The `u` suffix gives the literal type `uint`.\n+  * The `i` and `u` suffixes give the literal type `int` or `uint`,\n+    respectively.\n   * Each of the signed and unsigned machine types `u8`, `i8`,\n     `u16`, `i16`, `u32`, `i32`, `u64` and `i64`\n     give the literal the corresponding machine type.\n \n+The type of an _unsuffixed_ integer literal is determined by type inference.\n+If a integer type can be _uniquely_ determined from the surrounding program\n+context, the unsuffixed integer literal has that type.  If the program context\n+underconstrains the type, the unsuffixed integer literal's type is `int`; if\n+the program context overconstrains the type, it is considered a static type\n+error.\n \n Examples of integer literals of various forms:\n \n ~~~~\n-123;                               // type int\n+123; 0xff00;                       // type determined by program context; \n+                                   // defaults to int in absence of type\n+\t\t\t\t   // information\n+\n 123u;                              // type uint\n 123_u;                             // type uint\n-0xff00;                            // type int\n 0xff_u8;                           // type u8\n 0b1111_1111_1001_0000_i32;         // type i32\n ~~~~"}, {"sha": "f6c2aef30ea3528019162ad626415296f67f8c2f", "filename": "doc/tutorial.md", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1df6ddd08c3155e64806cd54b878337814401b7e/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/1df6ddd08c3155e64806cd54b878337814401b7e/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=1df6ddd08c3155e64806cd54b878337814401b7e", "patch": "@@ -396,22 +396,67 @@ synonym.\n \n ## Literals\n \n+### Numeric literals\n+\n Integers can be written in decimal (`144`), hexadecimal (`0x90`), and\n-binary (`0b10010000`) base. Without a suffix, an integer literal is\n-considered to be of type `int`. Add a `u` (`144u`) to make it a `uint`\n-instead. Literals of the fixed-size integer types can be created by\n-the literal with the type name (`255u8`, `50i64`, etc).\n+binary (`0b10010000`) base.\n+\n+If you write an integer literal without a suffix (`3`, `-500`, etc.),\n+the Rust compiler will try to infer its type based on type annotations\n+and function signatures in the surrounding program.  For example, here\n+the type of `x` is inferred to be `u16` because it is passed to a\n+function that takes a `u16` argument:\n+\n+~~~~~\n+let x = 3;\n+\n+fn identity_u16(n: u16) -> u16 { n }\n+\n+identity_u16(x);\n+~~~~\n+\n+On the other hand, if the program gives conflicting information about\n+what the type of the unsuffixed literal should be, you'll get an error\n+message.\n+\n+~~~~~{.xfail-test}\n+let x = 3;\n+let y: i32 = 3;\n+\n+fn identity_u8(n: u8) -> u8 { n }\n+fn identity_u16(n: u16) -> u16 { n }\n+\n+identity_u8(x);  // after this, `x` is assumed to have type `u8`\n+identity_u16(x); // raises a type error (expected `u16` but found `u8`)\n+identity_u16(y); // raises a type error (expected `u16` but found `i32`)\n+~~~~\n+\n+In the absence of any type annotations at all, Rust will assume that\n+an unsuffixed integer literal has type `int`.\n+\n+~~~~\n+let n = 50;\n+log(error, n); // n is an int\n+~~~~\n+\n+It's also possible to avoid any type ambiguity by writing integer\n+literals with a suffix.  The suffixes `i` and `u` are for the types\n+`int` and `uint`, respectively: the literal `-3i` has type `int`,\n+while `127u` has type `uint`.  For the fixed-size integer types, just\n+suffix the literal with the type name: `255u8`, `50i64`, etc.\n \n Note that, in Rust, no implicit conversion between integer types\n-happens. If you are adding one to a variable of type `uint`, you must\n-type `v += 1u`\u2014saying `+= 1` will give you a type error.\n+happens. If you are adding one to a variable of type `uint`, saying\n+`+= 1u8` will give you a type error.\n \n Floating point numbers are written `0.0`, `1e6`, or `2.1e-4`. Without\n a suffix, the literal is assumed to be of type `float`. Suffixes `f32`\n and `f64` can be used to create literals of a specific type. The\n suffix `f` can be used to write `float` literals without a dot or\n exponent: `3f`.\n \n+### Other literals\n+\n The nil literal is written just like the type: `()`. The keywords\n `true` and `false` produce the boolean literals.\n "}, {"sha": "fa07be952c119b5ebd84d64028cac407ff202776", "filename": "src/test/compile-fail/tutorial-suffix-inference-test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1df6ddd08c3155e64806cd54b878337814401b7e/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1df6ddd08c3155e64806cd54b878337814401b7e/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftutorial-suffix-inference-test.rs?ref=1df6ddd08c3155e64806cd54b878337814401b7e", "patch": "@@ -0,0 +1,22 @@\n+fn main() {\n+    let x = 3;\n+    let y: i32 = 3;\n+\n+    fn identity_u8(n: u8) -> u8 { n }\n+    fn identity_u16(n: u16) -> u16 { n }\n+\n+    identity_u8(x);  // after this, `x` is assumed to have type `u8`\n+    identity_u16(x);\n+    //!^ ERROR mismatched types: expected `u16` but found `u8`\n+    identity_u16(y);\n+    //!^ ERROR mismatched types: expected `u16` but found `i32`\n+\n+    let a = 3i;\n+    \n+    fn identity_i(n: int) -> int { n }\n+\n+    identity_i(a); // ok\n+    identity_u16(a); \n+    //!^ ERROR mismatched types: expected `u16` but found `int`\n+\n+}\n\\ No newline at end of file"}]}