{"sha": "fdf935a5249edd0be0f14385a099963e43c7a29b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZjkzNWE1MjQ5ZWRkMGJlMGYxNDM4NWEwOTk5NjNlNDNjN2EyOWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-21T01:54:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-21T23:36:57Z"}, "message": "std,green: Mark some queue types as NoShare", "tree": {"sha": "29511557c2c812534477934db9e1be4da6d219e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29511557c2c812534477934db9e1be4da6d219e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdf935a5249edd0be0f14385a099963e43c7a29b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf935a5249edd0be0f14385a099963e43c7a29b", "html_url": "https://github.com/rust-lang/rust/commit/fdf935a5249edd0be0f14385a099963e43c7a29b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdf935a5249edd0be0f14385a099963e43c7a29b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54f6eacf34c1ec368750051832aba2735fbf0880", "url": "https://api.github.com/repos/rust-lang/rust/commits/54f6eacf34c1ec368750051832aba2735fbf0880", "html_url": "https://github.com/rust-lang/rust/commit/54f6eacf34c1ec368750051832aba2735fbf0880"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "137c493364520e3f3440df88c905c26c105a0895", "filename": "src/libgreen/message_queue.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibgreen%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibgreen%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmessage_queue.rs?ref=fdf935a5249edd0be0f14385a099963e43c7a29b", "patch": "@@ -10,6 +10,7 @@\n \n use alloc::arc::Arc;\n use mpsc = std::sync::mpsc_queue;\n+use std::kinds::marker;\n \n pub enum PopResult<T> {\n     Inconsistent,\n@@ -19,15 +20,18 @@ pub enum PopResult<T> {\n \n pub fn queue<T: Send>() -> (Consumer<T>, Producer<T>) {\n     let a = Arc::new(mpsc::Queue::new());\n-    (Consumer { inner: a.clone() }, Producer { inner: a })\n+    (Consumer { inner: a.clone(), noshare: marker::NoShare },\n+     Producer { inner: a, noshare: marker::NoShare })\n }\n \n pub struct Producer<T> {\n     inner: Arc<mpsc::Queue<T>>,\n+    noshare: marker::NoShare,\n }\n \n pub struct Consumer<T> {\n     inner: Arc<mpsc::Queue<T>>,\n+    noshare: marker::NoShare,\n }\n \n impl<T: Send> Consumer<T> {\n@@ -56,6 +60,6 @@ impl<T: Send> Producer<T> {\n \n impl<T: Send> Clone for Producer<T> {\n     fn clone(&self) -> Producer<T> {\n-        Producer { inner: self.inner.clone() }\n+        Producer { inner: self.inner.clone(), noshare: marker::NoShare }\n     }\n }"}, {"sha": "8bd8bc71a49f1759c6d615aee9dfa6c230f8aafe", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=fdf935a5249edd0be0f14385a099963e43c7a29b", "patch": "@@ -326,7 +326,7 @@ impl TcpStream {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { (*self.inner.get()).lock.lock() },\n+            guard: unsafe { self.inner.lock.lock() },\n         };\n         assert!(util::set_nonblocking(self.fd(), true).is_ok());\n         ret\n@@ -597,7 +597,7 @@ impl UdpSocket {\n     fn lock_nonblocking<'a>(&'a self) -> Guard<'a> {\n         let ret = Guard {\n             fd: self.fd(),\n-            guard: unsafe { (*self.inner.get()).lock.lock() },\n+            guard: unsafe { self.inner.lock.lock() },\n         };\n         assert!(util::set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "a53a58b6cec434ddc2ad2ad11c930675062d849a", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=fdf935a5249edd0be0f14385a099963e43c7a29b", "patch": "@@ -138,7 +138,7 @@ impl UnixStream {\n     fn lock_nonblocking<'a>(&'a self) -> net::Guard<'a> {\n         let ret = net::Guard {\n             fd: self.fd(),\n-            guard: self.inner.lock.lock(),\n+            guard: unsafe { self.inner.lock.lock() },\n         };\n         assert!(util::set_nonblocking(self.fd(), true).is_ok());\n         ret"}, {"sha": "c9dbdc8331bbe265a95e043c3efd02371849e279", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=fdf935a5249edd0be0f14385a099963e43c7a29b", "patch": "@@ -320,11 +320,11 @@ impl UnixStream {\n     fn handle(&self) -> libc::HANDLE { self.inner.handle }\n \n     fn read_closed(&self) -> bool {\n-        unsafe { (*self.inner.get()).read_closed.load(atomics::SeqCst) }\n+        self.inner.read_closed.load(atomics::SeqCst)\n     }\n \n     fn write_closed(&self) -> bool {\n-        unsafe { (*self.inner.get()).write_closed.load(atomics::SeqCst) }\n+        self.inner.write_closed.load(atomics::SeqCst)\n     }\n \n     fn cancel_io(&self) -> IoResult<()> {\n@@ -353,7 +353,7 @@ impl rtio::RtioPipe for UnixStream {\n         // acquire the lock.\n         //\n         // See comments in close_read() about why this lock is necessary.\n-        let guard = unsafe { (*self.inner.get()).lock.lock() };\n+        let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n             return Err(io::standard_error(io::EndOfFile))\n         }\n@@ -429,7 +429,7 @@ impl rtio::RtioPipe for UnixStream {\n             // going after we woke up.\n             //\n             // See comments in close_read() about why this lock is necessary.\n-            let guard = unsafe { (*self.inner.get()).lock.lock() };\n+            let guard = unsafe { self.inner.lock.lock() };\n             if self.write_closed() {\n                 return Err(io::standard_error(io::BrokenPipe))\n             }\n@@ -514,15 +514,15 @@ impl rtio::RtioPipe for UnixStream {\n         // close_read() between steps 1 and 2. By atomically executing steps 1\n         // and 2 with a lock with respect to close_read(), we're guaranteed that\n         // no thread will erroneously sit in a read forever.\n-        let _guard = unsafe { (*self.inner.get()).lock.lock() };\n-        unsafe { (*self.inner.get()).read_closed.store(true, atomics::SeqCst) }\n+        let _guard = unsafe { self.inner.lock.lock() };\n+        self.inner.read_closed.store(true, atomics::SeqCst);\n         self.cancel_io()\n     }\n \n     fn close_write(&mut self) -> IoResult<()> {\n         // see comments in close_read() for why this lock is necessary\n-        let _guard = unsafe { (*self.inner.get()).lock.lock() };\n-        unsafe { (*self.inner.get()).write_closed.store(true, atomics::SeqCst) }\n+        let _guard = unsafe { self.inner.lock.lock() };\n+        self.inner.write_closed.store(true, atomics::SeqCst);\n         self.cancel_io()\n     }\n "}, {"sha": "a3fdc4d3eaff7e3d4b891794574b65d8a10ff912", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdf935a5249edd0be0f14385a099963e43c7a29b/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=fdf935a5249edd0be0f14385a099963e43c7a29b", "patch": "@@ -53,16 +53,17 @@ use alloc::arc::Arc;\n use clone::Clone;\n use iter::{range, Iterator};\n use kinds::Send;\n+use kinds::marker;\n use mem::{forget, min_align_of, size_of, transmute};\n use ops::Drop;\n use option::{Option, Some, None};\n use owned::Box;\n use ptr::RawPtr;\n use ptr;\n+use rt::heap::{allocate, deallocate};\n use slice::ImmutableVector;\n use sync::atomics::{AtomicInt, AtomicPtr, SeqCst};\n use unstable::sync::Exclusive;\n-use rt::heap::{allocate, deallocate};\n use vec::Vec;\n \n // Once the queue is less than 1/K full, then it will be downsized. Note that\n@@ -89,13 +90,15 @@ struct Deque<T> {\n /// There may only be one worker per deque.\n pub struct Worker<T> {\n     deque: Arc<Deque<T>>,\n+    noshare: marker::NoShare,\n }\n \n /// The stealing half of the work-stealing deque. Stealers have access to the\n /// opposite end of the deque from the worker, and they only have access to the\n /// `steal` method.\n pub struct Stealer<T> {\n     deque: Arc<Deque<T>>,\n+    noshare: marker::NoShare,\n }\n \n /// When stealing some data, this is an enumeration of the possible outcomes.\n@@ -153,7 +156,8 @@ impl<T: Send> BufferPool<T> {\n     pub fn deque(&self) -> (Worker<T>, Stealer<T>) {\n         let a = Arc::new(Deque::new(self.clone()));\n         let b = a.clone();\n-        (Worker { deque: a }, Stealer { deque: b })\n+        (Worker { deque: a, noshare: marker::NoShare },\n+         Stealer { deque: b, noshare: marker::NoShare })\n     }\n \n     fn alloc(&self, bits: int) -> Box<Buffer<T>> {\n@@ -219,7 +223,9 @@ impl<T: Send> Stealer<T> {\n }\n \n impl<T: Send> Clone for Stealer<T> {\n-    fn clone(&self) -> Stealer<T> { Stealer { deque: self.deque.clone() } }\n+    fn clone(&self) -> Stealer<T> {\n+        Stealer { deque: self.deque.clone(), noshare: marker::NoShare }\n+    }\n }\n \n // Almost all of this code can be found directly in the paper so I'm not"}]}