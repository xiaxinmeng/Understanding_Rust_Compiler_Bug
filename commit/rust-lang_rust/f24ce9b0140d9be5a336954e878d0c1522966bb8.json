{"sha": "f24ce9b0140d9be5a336954e878d0c1522966bb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNGNlOWIwMTQwZDliZTVhMzM2OTU0ZTg3OGQwYzE1MjI5NjZiYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T10:05:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-16T10:05:46Z"}, "message": "Auto merge of #82838 - Amanieu:rustdoc_asm, r=nagisa\n\nAllow rustdoc to handle asm! of foreign architectures\n\nThis allows rustdoc to process code containing `asm!` for architectures other than the current one. Since this never reaches codegen, we just replace target-specific registers and register classes with a dummy one.\n\nFixes #82869", "tree": {"sha": "652b4ddb515deb444280ee580bfe64dfeca2ee75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652b4ddb515deb444280ee580bfe64dfeca2ee75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24ce9b0140d9be5a336954e878d0c1522966bb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24ce9b0140d9be5a336954e878d0c1522966bb8", "html_url": "https://github.com/rust-lang/rust/commit/f24ce9b0140d9be5a336954e878d0c1522966bb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24ce9b0140d9be5a336954e878d0c1522966bb8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "195ad4830e11a544391abe296b146450dea8411b", "url": "https://api.github.com/repos/rust-lang/rust/commits/195ad4830e11a544391abe296b146450dea8411b", "html_url": "https://github.com/rust-lang/rust/commit/195ad4830e11a544391abe296b146450dea8411b"}, {"sha": "ba00ddc39a99ed70ba107902767db8d4837af921", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba00ddc39a99ed70ba107902767db8d4837af921", "html_url": "https://github.com/rust-lang/rust/commit/ba00ddc39a99ed70ba107902767db8d4837af921"}], "stats": {"total": 184, "additions": 139, "deletions": 45}, "files": [{"sha": "584257936027e973297f7c3b1491a94e38839f81", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -1331,84 +1331,83 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_expr_asm(&mut self, sp: Span, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n-        if self.sess.asm_arch.is_none() {\n+        // Rustdoc needs to support asm! from foriegn architectures: don't try\n+        // lowering the register contraints in this case.\n+        let asm_arch = if self.sess.opts.actually_rustdoc { None } else { self.sess.asm_arch };\n+        if asm_arch.is_none() && !self.sess.opts.actually_rustdoc {\n             struct_span_err!(self.sess, sp, E0472, \"asm! is unsupported on this target\").emit();\n         }\n         if asm.options.contains(InlineAsmOptions::ATT_SYNTAX)\n-            && !matches!(\n-                self.sess.asm_arch,\n-                Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64)\n-            )\n+            && !matches!(asm_arch, Some(asm::InlineAsmArch::X86 | asm::InlineAsmArch::X86_64))\n+            && !self.sess.opts.actually_rustdoc\n         {\n             self.sess\n                 .struct_span_err(sp, \"the `att_syntax` option is only supported on x86\")\n                 .emit();\n         }\n \n-        // Lower operands to HIR, filter_map skips any operands with invalid\n-        // register classes.\n+        // Lower operands to HIR. We use dummy register classes if an error\n+        // occurs during lowering because we still need to be able to produce a\n+        // valid HIR.\n         let sess = self.sess;\n         let operands: Vec<_> = asm\n             .operands\n             .iter()\n-            .filter_map(|(op, op_sp)| {\n-                let lower_reg = |reg| {\n-                    Some(match reg {\n-                        InlineAsmRegOrRegClass::Reg(s) => asm::InlineAsmRegOrRegClass::Reg(\n+            .map(|(op, op_sp)| {\n+                let lower_reg = |reg| match reg {\n+                    InlineAsmRegOrRegClass::Reg(s) => {\n+                        asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(\n-                                sess.asm_arch?,\n+                                asm_arch,\n                                 |feature| sess.target_features.contains(&Symbol::intern(feature)),\n                                 &sess.target,\n                                 s,\n                             )\n-                            .map_err(|e| {\n+                            .unwrap_or_else(|e| {\n                                 let msg = format!(\"invalid register `{}`: {}\", s.as_str(), e);\n                                 sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmReg::Err\n                             })\n-                            .ok()?,\n-                        ),\n-                        InlineAsmRegOrRegClass::RegClass(s) => {\n-                            asm::InlineAsmRegOrRegClass::RegClass(\n-                                asm::InlineAsmRegClass::parse(sess.asm_arch?, s)\n-                                    .map_err(|e| {\n-                                        let msg = format!(\n-                                            \"invalid register class `{}`: {}\",\n-                                            s.as_str(),\n-                                            e\n-                                        );\n-                                        sess.struct_span_err(*op_sp, &msg).emit();\n-                                    })\n-                                    .ok()?,\n-                            )\n-                        }\n-                    })\n+                        } else {\n+                            asm::InlineAsmReg::Err\n+                        })\n+                    }\n+                    InlineAsmRegOrRegClass::RegClass(s) => {\n+                        asm::InlineAsmRegOrRegClass::RegClass(if let Some(asm_arch) = asm_arch {\n+                            asm::InlineAsmRegClass::parse(asm_arch, s).unwrap_or_else(|e| {\n+                                let msg = format!(\"invalid register class `{}`: {}\", s.as_str(), e);\n+                                sess.struct_span_err(*op_sp, &msg).emit();\n+                                asm::InlineAsmRegClass::Err\n+                            })\n+                        } else {\n+                            asm::InlineAsmRegClass::Err\n+                        })\n+                    }\n                 };\n \n-                // lower_reg is executed last because we need to lower all\n-                // sub-expressions even if we throw them away later.\n                 let op = match *op {\n                     InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                        reg: lower_reg(reg),\n                         expr: self.lower_expr_mut(expr),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                        reg: lower_reg(reg),\n                         late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                        reg: lower_reg(reg)?,\n                     },\n                     InlineAsmOperand::InOut { reg, late, ref expr } => {\n                         hir::InlineAsmOperand::InOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             expr: self.lower_expr_mut(expr),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n                     InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n+                            reg: lower_reg(reg),\n                             late,\n                             in_expr: self.lower_expr_mut(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr_mut(expr)),\n-                            reg: lower_reg(reg)?,\n                         }\n                     }\n                     InlineAsmOperand::Const { ref expr } => {\n@@ -1418,17 +1417,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::InlineAsmOperand::Sym { expr: self.lower_expr_mut(expr) }\n                     }\n                 };\n-                Some((op, *op_sp))\n+                (op, *op_sp)\n             })\n             .collect();\n \n-        // Stop if there were any errors when lowering the register classes\n-        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n-            return hir::ExprKind::Err;\n-        }\n-\n         // Validate template modifiers against the register classes for the operands\n-        let asm_arch = sess.asm_arch.unwrap();\n         for p in &asm.template {\n             if let InlineAsmTemplatePiece::Placeholder {\n                 operand_idx,\n@@ -1443,7 +1436,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     | hir::InlineAsmOperand::InOut { reg, .. }\n                     | hir::InlineAsmOperand::SplitInOut { reg, .. } => {\n                         let class = reg.reg_class();\n-                        let valid_modifiers = class.valid_modifiers(asm_arch);\n+                        if class == asm::InlineAsmRegClass::Err {\n+                            continue;\n+                        }\n+                        let valid_modifiers = class.valid_modifiers(asm_arch.unwrap());\n                         if !valid_modifiers.contains(&modifier) {\n                             let mut err = sess.struct_span_err(\n                                 placeholder_span,\n@@ -1506,7 +1502,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // features. We check that at least one type is available for\n                 // the current target.\n                 let reg_class = reg.reg_class();\n-                for &(_, feature) in reg_class.supported_types(asm_arch) {\n+                if reg_class == asm::InlineAsmRegClass::Err {\n+                    continue;\n+                }\n+                for &(_, feature) in reg_class.supported_types(asm_arch.unwrap()) {\n                     if let Some(feature) = feature {\n                         if self.sess.target_features.contains(&Symbol::intern(feature)) {\n                             required_features.clear();"}, {"sha": "e7d359c4f149c1db4a6d94387ea58b702637e6b6", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -528,6 +528,7 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"LLVM backend does not support SPIR-V\")\n             }\n+            InlineAsmRegClass::Err => unreachable!(),\n         }\n         .to_string(),\n     }\n@@ -594,6 +595,7 @@ fn modifier_to_llvm(\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n \n@@ -637,6 +639,7 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n         }\n+        InlineAsmRegClass::Err => unreachable!(),\n     }\n }\n "}, {"sha": "a09c87b3ec2b23c865ceaed3c60a094f8c8a1333", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -229,6 +229,8 @@ pub enum InlineAsmReg {\n     Mips(MipsInlineAsmReg),\n     SpirV(SpirVInlineAsmReg),\n     Wasm(WasmInlineAsmReg),\n+    // Placeholder for invalid register constraints for the current target\n+    Err,\n }\n \n impl InlineAsmReg {\n@@ -240,6 +242,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::Err => \"<reg>\",\n         }\n     }\n \n@@ -251,6 +254,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => InlineAsmRegClass::RiscV(r.reg_class()),\n             Self::Hexagon(r) => InlineAsmRegClass::Hexagon(r.reg_class()),\n             Self::Mips(r) => InlineAsmRegClass::Mips(r.reg_class()),\n+            Self::Err => InlineAsmRegClass::Err,\n         }\n     }\n \n@@ -309,6 +313,7 @@ impl InlineAsmReg {\n             Self::RiscV(r) => r.emit(out, arch, modifier),\n             Self::Hexagon(r) => r.emit(out, arch, modifier),\n             Self::Mips(r) => r.emit(out, arch, modifier),\n+            Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n \n@@ -320,6 +325,7 @@ impl InlineAsmReg {\n             Self::RiscV(_) => cb(self),\n             Self::Hexagon(r) => r.overlapping_regs(|r| cb(Self::Hexagon(r))),\n             Self::Mips(_) => cb(self),\n+            Self::Err => unreachable!(\"Use of InlineAsmReg::Err\"),\n         }\n     }\n }\n@@ -346,6 +352,8 @@ pub enum InlineAsmRegClass {\n     Mips(MipsInlineAsmRegClass),\n     SpirV(SpirVInlineAsmRegClass),\n     Wasm(WasmInlineAsmRegClass),\n+    // Placeholder for invalid register constraints for the current target\n+    Err,\n }\n \n impl InlineAsmRegClass {\n@@ -360,6 +368,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.name(),\n             Self::SpirV(r) => r.name(),\n             Self::Wasm(r) => r.name(),\n+            Self::Err => rustc_span::symbol::sym::reg,\n         }\n     }\n \n@@ -377,6 +386,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n             Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n             Self::Wasm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Wasm),\n+            Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n \n@@ -401,6 +411,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n             Self::SpirV(r) => r.suggest_modifier(arch, ty),\n             Self::Wasm(r) => r.suggest_modifier(arch, ty),\n+            Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n \n@@ -421,6 +432,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.default_modifier(arch),\n             Self::SpirV(r) => r.default_modifier(arch),\n             Self::Wasm(r) => r.default_modifier(arch),\n+            Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n \n@@ -440,6 +452,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.supported_types(arch),\n             Self::SpirV(r) => r.supported_types(arch),\n             Self::Wasm(r) => r.supported_types(arch),\n+            Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n \n@@ -476,6 +489,7 @@ impl InlineAsmRegClass {\n             Self::Mips(r) => r.valid_modifiers(arch),\n             Self::SpirV(r) => r.valid_modifiers(arch),\n             Self::Wasm(r) => r.valid_modifiers(arch),\n+            Self::Err => unreachable!(\"Use of InlineAsmRegClass::Err\"),\n         }\n     }\n }"}, {"sha": "570ed043dd9e874bd6362965cac8c07bbf032368", "filename": "src/test/rustdoc/asm-foreign.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Frustdoc%2Fasm-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Frustdoc%2Fasm-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasm-foreign.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -0,0 +1,20 @@\n+// Make sure rustdoc accepts asm! for a foreign architecture.\n+\n+#![feature(asm)]\n+\n+// @has asm_foreign/fn.aarch64.html\n+pub unsafe fn aarch64(a: f64, b: f64) -> f64 {\n+    let c;\n+    asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+        || {};\n+        b\n+    });\n+    c\n+}\n+\n+// @has asm_foreign/fn.x86.html\n+pub unsafe fn x86(a: f64, b: f64) -> f64 {\n+    let c;\n+    asm!(\"addsd {}, {}, xmm0\", out(xmm_reg) c, in(xmm_reg) a, in(\"xmm0\") b);\n+    c\n+}"}, {"sha": "34e313e7eacebec23df46c5fa58837ec9910e695", "filename": "src/test/rustdoc/asm-foreign2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Frustdoc%2Fasm-foreign2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Frustdoc%2Fasm-foreign2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasm-foreign2.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -0,0 +1,11 @@\n+// only-aarch64\n+// Make sure rustdoc accepts options(att_syntax) asm! on non-x86 targets.\n+\n+#![feature(asm)]\n+\n+// @has asm_foreign2/fn.x86.html\n+pub unsafe fn x86(x: i64) -> i64 {\n+    let y;\n+    asm!(\"movq {}, {}\", in(reg) x, out(reg) y, options(att_syntax));\n+    y\n+}"}, {"sha": "a8e688cbe1ff3e6bbcf76ac7d112fa985b1681b2", "filename": "src/test/ui/issues/issue-82869.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Fui%2Fissues%2Fissue-82869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Fui%2Fissues%2Fissue-82869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-82869.rs?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -0,0 +1,23 @@\n+// only-x86_64\n+// Make sure rustc doesn't ICE on asm! for a foreign architecture.\n+\n+#![feature(asm)]\n+#![crate_type = \"rlib\"]\n+\n+pub unsafe fn aarch64(a: f64, b: f64) -> f64 {\n+    let c;\n+    asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+        || {};\n+        b\n+    });\n+    //~^^^^ invalid register class\n+    //~^^^^^ invalid register class\n+    //~^^^^^^ invalid register\n+    c\n+}\n+\n+pub unsafe fn x86(a: f64, b: f64) -> f64 {\n+    let c;\n+    asm!(\"addsd {}, {}, xmm0\", out(xmm_reg) c, in(xmm_reg) a, in(\"xmm0\") b);\n+    c\n+}"}, {"sha": "d05714ea6f2153428524e6b76f12d2ed0f1e1ae2", "filename": "src/test/ui/issues/issue-82869.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Fui%2Fissues%2Fissue-82869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f24ce9b0140d9be5a336954e878d0c1522966bb8/src%2Ftest%2Fui%2Fissues%2Fissue-82869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-82869.stderr?ref=f24ce9b0140d9be5a336954e878d0c1522966bb8", "patch": "@@ -0,0 +1,24 @@\n+error: invalid register class `vreg`: unknown register class\n+  --> $DIR/issue-82869.rs:9:32\n+   |\n+LL |     asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+   |                                ^^^^^^^^^^^\n+\n+error: invalid register class `vreg`: unknown register class\n+  --> $DIR/issue-82869.rs:9:45\n+   |\n+LL |     asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+   |                                             ^^^^^^^^^^\n+\n+error: invalid register `d0`: unknown register\n+  --> $DIR/issue-82869.rs:9:57\n+   |\n+LL |       asm!(\"add {:d}, {:d}, d0\", out(vreg) c, in(vreg) a, in(\"d0\") {\n+   |  _________________________________________________________^\n+LL | |         || {};\n+LL | |         b\n+LL | |     });\n+   | |_____^\n+\n+error: aborting due to 3 previous errors\n+"}]}