{"sha": "4abb3283f38886bef53545e2065c21268362b2df", "node_id": "C_kwDOAAsO6NoAKDRhYmIzMjgzZjM4ODg2YmVmNTM1NDVlMjA2NWMyMTI2ODM2MmIyZGY", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-11-05T21:27:53Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-31T03:33:52Z"}, "message": "Use SparseIntervalMatrix instead of SparseBitMatrix\n\nRegion inference contains several bitsets which are filled with large intervals\nrepresenting liveness. These can cause excessive memory usage, and are\nrelatively slow when growing to large sizes compared to the IntervalSet.", "tree": {"sha": "9e28d56dde60899e1ab7b434d72a355da7218747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e28d56dde60899e1ab7b434d72a355da7218747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4abb3283f38886bef53545e2065c21268362b2df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4abb3283f38886bef53545e2065c21268362b2df", "html_url": "https://github.com/rust-lang/rust/commit/4abb3283f38886bef53545e2065c21268362b2df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4abb3283f38886bef53545e2065c21268362b2df/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00c55a1bb83a9dccad806d8b9994a4e343aec24c", "url": "https://api.github.com/repos/rust-lang/rust/commits/00c55a1bb83a9dccad806d8b9994a4e343aec24c", "html_url": "https://github.com/rust-lang/rust/commit/00c55a1bb83a9dccad806d8b9994a4e343aec24c"}], "stats": {"total": 37, "additions": 20, "deletions": 17}, "files": [{"sha": "4a70535c63bea2fdddd690cc088e900f0a1f3919", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4abb3283f38886bef53545e2065c21268362b2df/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abb3283f38886bef53545e2065c21268362b2df/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=4abb3283f38886bef53545e2065c21268362b2df", "patch": "@@ -1,5 +1,7 @@\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n+use rustc_index::bit_set::SparseBitMatrix;\n+use rustc_index::interval::IntervalSet;\n+use rustc_index::interval::SparseIntervalMatrix;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{BasicBlock, Body, Location};\n@@ -110,19 +112,19 @@ crate enum RegionElement {\n     PlaceholderRegion(ty::PlaceholderRegion),\n }\n \n-/// When we initially compute liveness, we use a bit matrix storing\n-/// points for each region-vid.\n+/// When we initially compute liveness, we use an interval matrix storing\n+/// liveness ranges for each region-vid.\n crate struct LivenessValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n-    points: SparseBitMatrix<N, PointIndex>,\n+    points: SparseIntervalMatrix<N, PointIndex>,\n }\n \n impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n     crate fn new(elements: Rc<RegionValueElements>) -> Self {\n-        Self { points: SparseBitMatrix::new(elements.num_points), elements }\n+        Self { points: SparseIntervalMatrix::new(elements.num_points), elements }\n     }\n \n     /// Iterate through each region that has a value in this set.\n@@ -140,7 +142,7 @@ impl<N: Idx> LivenessValues<N> {\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns whether any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n+    crate fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_row(row, locations)\n     }\n@@ -153,7 +155,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// Returns `true` if the region `r` contains the given element.\n     crate fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n-        self.points.contains(row, index)\n+        self.points.row(row).map_or(false, |r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`\n@@ -221,7 +223,7 @@ impl PlaceholderIndices {\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     placeholder_indices: Rc<PlaceholderIndices>,\n-    points: SparseBitMatrix<N, PointIndex>,\n+    points: SparseIntervalMatrix<N, PointIndex>,\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n     /// Placeholders represent bound regions -- so something like `'a`\n@@ -241,7 +243,7 @@ impl<N: Idx> RegionValues<N> {\n         let num_placeholders = placeholder_indices.len();\n         Self {\n             elements: elements.clone(),\n-            points: SparseBitMatrix::new(elements.num_points),\n+            points: SparseIntervalMatrix::new(elements.num_points),\n             placeholder_indices: placeholder_indices.clone(),\n             free_regions: SparseBitMatrix::new(num_universal_regions),\n             placeholders: SparseBitMatrix::new(num_placeholders),"}, {"sha": "094af20f52efc9ad5573973169e7901284baac78", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4abb3283f38886bef53545e2065c21268362b2df/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4abb3283f38886bef53545e2065c21268362b2df/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=4abb3283f38886bef53545e2065c21268362b2df", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n+use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc_middle::ty::{Ty, TypeFoldable};\n@@ -105,12 +106,12 @@ struct LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n \n     /// Points where the current variable is \"use live\" -- meaning\n     /// that there is a future \"full use\" that may use its value.\n-    use_live_at: HybridBitSet<PointIndex>,\n+    use_live_at: IntervalSet<PointIndex>,\n \n     /// Points where the current variable is \"drop live\" -- meaning\n     /// that there is no future \"full use\" that may use its value, but\n     /// there is a future drop.\n-    drop_live_at: HybridBitSet<PointIndex>,\n+    drop_live_at: IntervalSet<PointIndex>,\n \n     /// Locations where drops may occur.\n     drop_locations: Vec<Location>,\n@@ -125,8 +126,8 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         LivenessResults {\n             cx,\n             defs: HybridBitSet::new_empty(num_points),\n-            use_live_at: HybridBitSet::new_empty(num_points),\n-            drop_live_at: HybridBitSet::new_empty(num_points),\n+            use_live_at: IntervalSet::new(num_points),\n+            drop_live_at: IntervalSet::new(num_points),\n             drop_locations: vec![],\n             stack: vec![],\n         }\n@@ -165,7 +166,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         drop_used: Vec<(Local, Location)>,\n         live_locals: FxHashSet<Local>,\n     ) {\n-        let locations = HybridBitSet::new_empty(self.cx.elements.num_points());\n+        let locations = IntervalSet::new(self.cx.elements.num_points());\n \n         for (local, location) in drop_used {\n             if !live_locals.contains(&local) {\n@@ -456,7 +457,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n     fn add_use_live_facts_for(\n         &mut self,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n@@ -473,7 +474,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n         dropped_local: Local,\n         dropped_ty: Ty<'tcx>,\n         drop_locations: &[Location],\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\n             \"add_drop_live_constraint(\\\n@@ -521,7 +522,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!("}]}