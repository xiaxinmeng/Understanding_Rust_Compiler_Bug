{"sha": "3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMzM4ZWVkOTkyNjVmZTVlOWExNjdhYmIyZTFmNGE3ZmYyZWExMDE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-25T00:29:26Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-29T19:24:26Z"}, "message": "rustc: remove type information from TraitDef.", "tree": {"sha": "56316a7d7a49ffcc54e0df26f3c320a65822f0a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56316a7d7a49ffcc54e0df26f3c320a65822f0a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "html_url": "https://github.com/rust-lang/rust/commit/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f50dbd580f3d5d88a300da540db3c85164bfd0de", "url": "https://api.github.com/repos/rust-lang/rust/commits/f50dbd580f3d5d88a300da540db3c85164bfd0de", "html_url": "https://github.com/rust-lang/rust/commit/f50dbd580f3d5d88a300da540db3c85164bfd0de"}], "stats": {"total": 283, "additions": 123, "deletions": 160}, "files": [{"sha": "12557fe4301a577885b8be3345c397f41232dd6b", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -277,7 +277,7 @@ pub trait CrateStore<'tcx> {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n@@ -423,7 +423,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }\n     fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }"}, {"sha": "f560308abe0d11751cb8a40c1ca778e8e0f1f9b4", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -244,11 +244,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(\"rustc_on_unimplemented\") {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n-                let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-                let trait_str = def.trait_ref.to_string();\n+                let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n                 if let Some(istring) = item.value_str() {\n                     let istring = &*istring.as_str();\n-                    let generic_map = def.generics.types.iter().map(|param| {\n+                    let generics = self.tcx.item_generics(trait_ref.def_id);\n+                    let generic_map = generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();"}, {"sha": "ceee6c236e4e3dba250c6364d3a5ef6e5fc796ab", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -21,7 +21,8 @@ use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n use traits;\n-use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::subst::Substs;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -126,9 +127,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n-        let trait_def = self.lookup_trait_def(trait_def_id);\n-        let trait_ref = trait_def.trait_ref.clone();\n-        let trait_ref = trait_ref.to_poly_trait_ref();\n+        let trait_ref = ty::Binder(ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: Substs::identity_for_item(self, trait_def_id)\n+        });\n         let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n@@ -317,8 +319,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                     // Compute supertraits of current trait lazily.\n                     if supertraits.is_none() {\n-                        let trait_def = self.lookup_trait_def(trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        let trait_ref = ty::Binder(ty::TraitRef {\n+                            def_id: trait_def_id,\n+                            substs: Substs::identity_for_item(self, trait_def_id)\n+                        });\n                         supertraits = Some(traits::supertraits(self, trait_ref).collect());\n                     }\n "}, {"sha": "a41523f2def76385d1cc323bf6ff103781ac4c6a", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -297,18 +297,18 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a, 'tcx: 'a> {\n-    trait_def: &'a TraitDef<'tcx>,\n+pub struct Ancestors<'a> {\n+    trait_def: &'a TraitDef,\n     current_source: Option<Node>,\n }\n \n-impl<'a, 'tcx> Iterator for Ancestors<'a, 'tcx> {\n+impl<'a> Iterator for Ancestors<'a> {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n             let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id() {\n+            if parent == self.trait_def.def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -332,7 +332,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -347,9 +347,7 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a, 'tcx>(trait_def: &'a TraitDef<'tcx>,\n-                           start_from_impl: DefId)\n-                           -> Ancestors<'a, 'tcx> {\n+pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n     Ancestors {\n         trait_def: trait_def,\n         current_source: Some(Node::Impl(start_from_impl)),"}, {"sha": "025b35100a73889099f5f6eac95b42701c639b05", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -66,7 +66,7 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n-    trait_def: TypedArena<ty::TraitDef<'tcx>>,\n+    trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n@@ -683,19 +683,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n     }\n \n-    pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n-                            -> &'gcx ty::TraitDef<'gcx> {\n-        let did = def.trait_ref.def_id;\n-        let interned = self.alloc_trait_def(def);\n-        if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n-        }\n-        self.generics.borrow_mut().insert(did, interned.generics);\n-        interned\n-    }\n-\n-    pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n-                           -> &'gcx ty::TraitDef<'gcx> {\n+    pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_interners.arenas.trait_def.alloc(def)\n     }\n "}, {"sha": "1fc1c32c2d5c86b52b088ede490c2be093b2f3bd", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -39,7 +39,7 @@ dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n-dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n+dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }"}, {"sha": "288ca751bd498a523b52509ad81822fd5c265b3c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -629,10 +629,6 @@ pub struct RegionParameterDef<'tcx> {\n }\n \n impl<'tcx> RegionParameterDef<'tcx> {\n-    pub fn to_early_bound_region(&self) -> ty::Region {\n-        ty::ReEarlyBound(self.to_early_bound_region_data())\n-    }\n-\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n             index: self.index,\n@@ -2400,7 +2396,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n             || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))"}, {"sha": "d6f61a12a3c6eb2ca8ad84ab7f6ec6d0303e33aa", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -165,6 +165,14 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n+    /// Creates a Substs that maps each generic parameter to itself.\n+    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n+                             -> &'tcx Substs<'tcx> {\n+        Substs::for_item(tcx, def_id, |def, _| {\n+            tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+        }, |def, _| tcx.mk_param_from_def(def))\n+    }\n+\n     /// Creates a Substs for generic parameter definitions,\n     /// by calling closures to obtain each region and type.\n     /// The closures get to observe the Substs as they're"}, {"sha": "c6d862b23bd5e393fc2bc67da607d37c730e7e7d", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -19,7 +19,9 @@ use hir;\n use util::nodemap::FxHashMap;\n \n /// A trait's definition with type information.\n-pub struct TraitDef<'tcx> {\n+pub struct TraitDef {\n+    pub def_id: DefId,\n+\n     pub unsafety: hir::Unsafety,\n \n     /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n@@ -28,15 +30,6 @@ pub struct TraitDef<'tcx> {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    /// Generic type definitions. Note that `Self` is listed in here\n-    /// as having a single bound, the trait itself (e.g., in the trait\n-    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n-    /// default methods get to assume that the `Self` parameters\n-    /// implements the trait.\n-    pub generics: &'tcx ty::Generics<'tcx>,\n-\n-    pub trait_ref: ty::TraitRef<'tcx>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -72,18 +65,16 @@ pub struct TraitDef<'tcx> {\n     pub def_path_hash: u64,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n-    pub fn new(unsafety: hir::Unsafety,\n+impl<'a, 'gcx, 'tcx> TraitDef {\n+    pub fn new(def_id: DefId,\n+               unsafety: hir::Unsafety,\n                paren_sugar: bool,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               trait_ref: ty::TraitRef<'tcx>,\n                def_path_hash: u64)\n-               -> TraitDef<'tcx> {\n+               -> TraitDef {\n         TraitDef {\n+            def_id: def_id,\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n-            generics: generics,\n-            trait_ref: trait_ref,\n             nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n@@ -92,10 +83,6 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n         }\n     }\n \n-    pub fn def_id(&self) -> DefId {\n-        self.trait_ref.def_id\n-    }\n-\n     // returns None if not yet calculated\n     pub fn object_safety(&self) -> Option<bool> {\n         if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n@@ -117,11 +104,11 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     }\n \n     fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n     }\n \n     fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n@@ -203,13 +190,13 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             .insert(tcx, impl_def_id)\n     }\n \n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n@@ -231,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     {\n         self.read_trait_impls(tcx);\n \n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);"}, {"sha": "641b1b548806d93fccd2f158cae03e1bce7d6006", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -432,10 +432,11 @@ impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n+impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitDef(generics={:?}, trait_ref={:?})\",\n-               self.generics, self.trait_ref)\n+        ty::tls::with(|tcx| {\n+            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n+        })\n     }\n }\n "}, {"sha": "624350d84db783ff1585c9479442af8fd9d14582", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_trait_def(def.index, tcx)"}, {"sha": "d75bab9dc5a2bbb40b476b0a2c2c6a0e26f0b991", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -531,16 +531,15 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                         -> ty::TraitDef<'tcx> {\n+                         -> ty::TraitDef {\n         let data = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        ty::TraitDef::new(data.unsafety,\n+        ty::TraitDef::new(self.local_def_id(item_id),\n+                          data.unsafety,\n                           data.paren_sugar,\n-                          tcx.item_generics(self.local_def_id(item_id)),\n-                          data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n "}, {"sha": "4a1e60812c9a44c7b1d8e3aed39fdd16beac9dbc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -730,7 +730,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n-                    trait_ref: self.lazy(&trait_def.trait_ref),\n                     super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n                 };\n "}, {"sha": "c74c8c58ab8b6119f0eed28dc865c3640112c479", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -278,7 +278,6 @@ pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_default_impl: bool,\n-    pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n "}, {"sha": "786106e805f3949845a4186ce530b7488c68b169", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -91,7 +91,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>;\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of"}, {"sha": "2e66f6290a022deb523097ab40adfbc17bdadd20", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -192,13 +192,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                m_name,\n                trait_def_id);\n \n-        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-\n-        if let Some(ref input_types) = opt_input_types {\n-            assert_eq!(trait_def.generics.types.len() - 1, input_types.len());\n-        }\n-        assert!(trait_def.generics.regions.is_empty());\n-\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = Substs::for_item(self.tcx,\n                                       trait_def_id,"}, {"sha": "2a17867fbd54b6ac0b9490847ee67c74e8164233", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -1040,7 +1040,7 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           trait_def: &ty::TraitDef<'tcx>,\n+                                           trait_def: &ty::TraitDef,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n@@ -1400,7 +1400,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn get_trait_def(&self, _: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n     {\n         Ok(self.tcx().lookup_trait_def(id))\n     }"}, {"sha": "fd5d922f935e499fc4ff224028a668eaac25ffb6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -290,12 +290,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             });\n \n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-\n-        let has_ty_params =\n-            trait_def.generics\n-                      .types\n-                      .len() > 1;\n+        let has_ty_params = self.tcx().item_generics(trait_def_id).types.len() > 1;\n \n         // We use an if-else here, since the generics will also trigger\n         // an extraneous error message when we find predicates like"}, {"sha": "c749e1cf8429119a5a25715b83d15bd7b14a600a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 55, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -329,20 +329,21 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n-    fn get_trait_def(&self, trait_id: DefId)\n-                     -> &'tcx ty::TraitDef<'tcx>\n+    fn get_trait_def(&self, def_id: DefId)\n+                     -> &'tcx ty::TraitDef\n     {\n         let tcx = self.tcx;\n \n-        if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n+        if let Some(trait_id) = tcx.map.as_local_node_id(def_id) {\n             let item = match tcx.map.get(trait_id) {\n                 hir_map::NodeItem(item) => item,\n                 _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n             };\n \n+            generics_of_def_id(self, def_id);\n             trait_def_of_item(self, &item)\n         } else {\n-            tcx.lookup_trait_def(trait_id)\n+            tcx.lookup_trait_def(def_id)\n         }\n     }\n \n@@ -392,7 +393,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n             Ok(self.ccx.get_trait_def(id))\n@@ -716,6 +717,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n@@ -726,7 +728,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty = type_of_def_id(ccx, def_id);\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n@@ -756,7 +757,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       _) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             generics_of_def_id(ccx, def_id);\n             let mut ty_predicates =\n                 ty_generic_predicates(ccx, generics, None, vec![], false);\n@@ -786,8 +786,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n         },\n         hir::ItemTrait(.., ref trait_items) => {\n-            let trait_def = trait_def_of_item(ccx, it);\n-            let def_id = trait_def.trait_ref.def_id;\n+            generics_of_def_id(ccx, def_id);\n+            trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n@@ -838,7 +838,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty = type_of_def_id(ccx, def_id);\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n@@ -855,13 +854,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n         _ => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n@@ -1155,10 +1152,15 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // In-scope when converting the superbounds for `Trait` are\n         // that `Self:Trait` as well as any bounds that appear on the\n         // generic types:\n-        let trait_def = trait_def_of_item(ccx, item);\n+        generics_of_def_id(ccx, trait_def_id);\n+        trait_def_of_item(ccx, item);\n+        let trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: Substs::identity_for_item(tcx, trait_def_id)\n+        };\n         let self_predicate = ty::GenericPredicates {\n             parent: None,\n-            predicates: vec![trait_def.trait_ref.to_predicate()]\n+            predicates: vec![trait_ref.to_predicate()]\n         };\n         let scope = &(generics, &self_predicate);\n \n@@ -1203,54 +1205,41 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n     def_ids\n }\n \n-fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               it: &hir::Item)\n-                               -> &'tcx ty::TraitDef<'tcx>\n-{\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n     let tcx = ccx.tcx;\n \n-    if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n-        return def.clone();\n-    }\n+    tcx.trait_defs.memoize(def_id, || {\n+        let unsafety = match it.node {\n+            hir::ItemTrait(unsafety, ..) => unsafety,\n+            _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n+        };\n \n-    let (unsafety, generics) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, _) => {\n-            (unsafety, generics)\n+        let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+        if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n+            let mut err = ccx.tcx.sess.struct_span_err(\n+                it.span,\n+                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n+                which traits can use parenthetical notation\");\n+            help!(&mut err,\n+                \"add `#![feature(unboxed_closures)]` to \\\n+                the crate attributes to use it\");\n+            err.emit();\n         }\n-        _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n-    };\n-\n-    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-    if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n-        let mut err = ccx.tcx.sess.struct_span_err(\n-            it.span,\n-            \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-             which traits can use parenthetical notation\");\n-        help!(&mut err,\n-            \"add `#![feature(unboxed_closures)]` to \\\n-             the crate attributes to use it\");\n-        err.emit();\n-    }\n-\n-    let ty_generics = generics_of_def_id(ccx, def_id);\n-    let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n-\n-    let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n-\n-    let trait_ref = ty::TraitRef::new(def_id, substs);\n-    let trait_def = ty::TraitDef::new(unsafety, paren_sugar, ty_generics, trait_ref,\n-                                      def_path_hash);\n \n-    tcx.intern_trait_def(trait_def)\n+        let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n+        tcx.alloc_trait_def(ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash))\n+    })\n }\n \n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n     let tcx = ccx.tcx;\n-    let trait_def = trait_def_of_item(ccx, it);\n \n     let def_id = ccx.tcx.map.local_def_id(it.id);\n \n+    generics_of_def_id(ccx, def_id);\n+    trait_def_of_item(ccx, it);\n+\n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n         ref s => {\n@@ -1272,7 +1261,11 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n-    let self_predicate = trait_def.trait_ref.to_poly_trait_ref().to_predicate();\n+    let trait_ref = ty::TraitRef {\n+        def_id: def_id,\n+        substs: Substs::identity_for_item(tcx, def_id)\n+    };\n+    let self_predicate = trait_ref.to_poly_trait_ref().to_predicate();\n     base_predicates.push(self_predicate);\n \n     // add in the explicit where-clauses\n@@ -1282,7 +1275,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n                                                            &trait_predicates,\n-                                                           trait_def.trait_ref,\n+                                                           trait_ref,\n                                                            items);\n     trait_predicates.predicates.extend(assoc_predicates);\n \n@@ -1581,7 +1574,10 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n                 ccx.tcx.mk_closure(def_id, Substs::for_item(\n                     ccx.tcx, def_id,\n-                    |def, _| ccx.tcx.mk_region(def.to_early_bound_region()),\n+                    |def, _| {\n+                        let region = def.to_early_bound_region_data();\n+                        ccx.tcx.mk_region(ty::ReEarlyBound(region))\n+                    },\n                     |def, _| ccx.tcx.mk_param_from_def(def)\n                 ))\n             }\n@@ -2095,7 +2091,5 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         bug!(\"ErrorReported returned, but no errors reports?\")\n     }\n \n-    Substs::for_item(tcx, def_id,\n-                     |def, _| tcx.mk_region(def.to_early_bound_region()),\n-                     |def, _| tcx.mk_param_from_def(def))\n+    Substs::identity_for_item(tcx, def_id)\n }"}, {"sha": "823c6e2744fe872f70eb758e422e0056ff5312d5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -97,9 +97,13 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                let trait_def = tcx.lookup_trait_def(did);\n-                self.add_constraints_from_trait_ref(&trait_def.generics,\n-                                                    trait_def.trait_ref,\n+                let generics = tcx.item_generics(did);\n+                let trait_ref = ty::TraitRef {\n+                    def_id: did,\n+                    substs: Substs::identity_for_item(tcx, did)\n+                };\n+                self.add_constraints_from_trait_ref(generics,\n+                                                    trait_ref,\n                                                     self.invariant);\n             }\n \n@@ -279,7 +283,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                trait_ref,\n                variance);\n \n-        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+        let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n \n         // This edge is actually implied by the call to\n         // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -288,8 +292,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         self.add_constraints_from_substs(generics,\n                                          trait_ref.def_id,\n-                                         &trait_def.generics.types,\n-                                         &trait_def.generics.regions,\n+                                         &trait_generics.types,\n+                                         &trait_generics.regions,\n                                          trait_ref.substs,\n                                          variance);\n     }\n@@ -356,7 +360,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n-                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+                let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n \n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -365,8 +369,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(generics,\n                                                  trait_ref.def_id,\n-                                                 &trait_def.generics.types,\n-                                                 &trait_def.generics.regions,\n+                                                 &trait_generics.types,\n+                                                 &trait_generics.regions,\n                                                  trait_ref.substs,\n                                                  variance);\n             }"}, {"sha": "d12e0ae6ddbebdce8e630d0e6f0b27d4eefe0cca", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -151,14 +151,13 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n }\n \n pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n-    let def = cx.tcx.lookup_trait_def(did);\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.item_predicates(did);\n-    let generics = (def.generics, &predicates).clean(cx);\n+    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n-        unsafety: def.unsafety,\n+        unsafety: cx.tcx.lookup_trait_def(did).unsafety,\n         generics: generics,\n         items: trait_items,\n         bounds: supertrait_bounds,"}, {"sha": "5538b78c00548375347c7b78767485d0ae5875d9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f338eed99265fe5e9a167abb2e1f4a7ff2ea101/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3f338eed99265fe5e9a167abb2e1f4a7ff2ea101", "patch": "@@ -1407,9 +1407,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let def = cx.tcx.lookup_trait_def(did);\n                     let predicates = cx.tcx.item_predicates(did);\n-                    let generics = (def.generics, &predicates).clean(cx);\n+                    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n                             WherePredicate::BoundPredicate {"}]}