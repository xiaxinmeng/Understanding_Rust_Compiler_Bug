{"sha": "f6f160391db945a0dcc2f73b38926d6919f7c566", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZjE2MDM5MWRiOTQ1YTBkY2MyZjczYjM4OTI2ZDY5MTlmN2M1NjY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-24T10:15:43Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-24T10:15:43Z"}, "message": "Merge #885\n\n885: Parse token trees directy r=matklad a=matklad\n\nThis takes advantage of the recent macro refactoring to directly parse token stream into a syntax tree.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "060450b70c09357615f261d8acd032a647615dd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/060450b70c09357615f261d8acd032a647615dd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6f160391db945a0dcc2f73b38926d6919f7c566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f160391db945a0dcc2f73b38926d6919f7c566", "html_url": "https://github.com/rust-lang/rust/commit/f6f160391db945a0dcc2f73b38926d6919f7c566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6f160391db945a0dcc2f73b38926d6919f7c566/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "c5e74cebdcbade069c0e1e81e298ab7d729e4cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e74cebdcbade069c0e1e81e298ab7d729e4cd5", "html_url": "https://github.com/rust-lang/rust/commit/c5e74cebdcbade069c0e1e81e298ab7d729e4cd5"}, {"sha": "81bca78349afb9e15994f46401da0cfabfba04a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/81bca78349afb9e15994f46401da0cfabfba04a1", "html_url": "https://github.com/rust-lang/rust/commit/81bca78349afb9e15994f46401da0cfabfba04a1"}], "stats": {"total": 335, "additions": 288, "deletions": 47}, "files": [{"sha": "e697de588d05f5237dd61f97551a8c78218553a8", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -1066,6 +1066,7 @@ dependencies = [\n name = \"ra_mbe\"\n version = \"0.1.0\"\n dependencies = [\n+ \"ra_parser 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "6e785f570c34433dd4bb8ba170b9dcc8f7b4725d", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -6,6 +6,7 @@ authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n ra_syntax = { path = \"../ra_syntax\" }\n+ra_parser = { path = \"../ra_parser\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n \n rustc-hash = \"1.0.0\""}, {"sha": "907402f5f8402b7d24a1c5217f8ea0e25ed55812", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -24,7 +24,7 @@ use ra_syntax::SmolStr;\n \n pub use tt::{Delimiter, Punct};\n \n-pub use crate::syntax_bridge::ast_to_token_tree;\n+pub use crate::syntax_bridge::{ast_to_token_tree, token_tree_to_ast_item_list};\n \n /// This struct contains AST for a single `macro_rules` definition. What might\n /// be very confusing is that AST has almost exactly the same shape as\n@@ -164,14 +164,18 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         crate::MacroRules::parse(&definition_tt).unwrap()\n     }\n \n-    fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n+    fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n         let source_file = ast::SourceFile::parse(invocation);\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n         let (invocation_tt, _) = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n \n-        let expanded = rules.expand(&invocation_tt).unwrap();\n+        rules.expand(&invocation_tt).unwrap()\n+    }\n+\n+    fn assert_expansion(rules: &MacroRules, invocation: &str, expansion: &str) {\n+        let expanded = expand(rules, invocation);\n         assert_eq!(expanded.to_string(), expansion);\n     }\n \n@@ -268,4 +272,57 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! { Foo,# Bar }\", \"struct Foo ; struct Bar ;\");\n     }\n \n+    #[test]\n+    fn expand_to_item_list() {\n+        let rules = create_rules(\n+            \"\n+            macro_rules! structs {\n+                ($($i:ident),*) => {\n+                    $(struct $i { field: u32 } )*\n+                }\n+            }\n+            \",\n+        );\n+        let expansion = expand(&rules, \"structs!(Foo, Bar)\");\n+        let tree = token_tree_to_ast_item_list(&expansion);\n+        assert_eq!(\n+            tree.syntax().debug_dump().trim(),\n+            r#\"\n+SOURCE_FILE@[0; 40)\n+  STRUCT_DEF@[0; 20)\n+    STRUCT_KW@[0; 6)\n+    NAME@[6; 9)\n+      IDENT@[6; 9) \"Foo\"\n+    NAMED_FIELD_DEF_LIST@[9; 20)\n+      L_CURLY@[9; 10)\n+      NAMED_FIELD_DEF@[10; 19)\n+        NAME@[10; 15)\n+          IDENT@[10; 15) \"field\"\n+        COLON@[15; 16)\n+        PATH_TYPE@[16; 19)\n+          PATH@[16; 19)\n+            PATH_SEGMENT@[16; 19)\n+              NAME_REF@[16; 19)\n+                IDENT@[16; 19) \"u32\"\n+      R_CURLY@[19; 20)\n+  STRUCT_DEF@[20; 40)\n+    STRUCT_KW@[20; 26)\n+    NAME@[26; 29)\n+      IDENT@[26; 29) \"Bar\"\n+    NAMED_FIELD_DEF_LIST@[29; 40)\n+      L_CURLY@[29; 30)\n+      NAMED_FIELD_DEF@[30; 39)\n+        NAME@[30; 35)\n+          IDENT@[30; 35) \"field\"\n+        COLON@[35; 36)\n+        PATH_TYPE@[36; 39)\n+          PATH@[36; 39)\n+            PATH_SEGMENT@[36; 39)\n+              NAME_REF@[36; 39)\n+                IDENT@[36; 39) \"u32\"\n+      R_CURLY@[39; 40)\"#\n+                .trim()\n+        );\n+    }\n+\n }"}, {"sha": "c1472bbe57398829e97d944bbeea95f8496784f3", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 146, "deletions": 1, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -1,5 +1,6 @@\n+use ra_parser::{TokenSource, TreeSink, ParseError};\n use ra_syntax::{\n-    AstNode, SyntaxNode, TextRange,\n+    AstNode, SyntaxNode, TextRange, SyntaxKind, SmolStr, SyntaxTreeBuilder, TreeArc,\n     ast, SyntaxKind::*, TextUnit\n };\n \n@@ -19,6 +20,15 @@ pub fn ast_to_token_tree(ast: &ast::TokenTree) -> Option<(tt::Subtree, TokenMap)\n     Some((tt, token_map))\n }\n \n+/// Parses the token tree (result of macro expansion) as a sequence of items\n+pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> TreeArc<ast::SourceFile> {\n+    let token_source = TtTokenSource::new(tt);\n+    let mut tree_sink = TtTreeSink::new(&token_source.tokens);\n+    ra_parser::parse(&token_source, &mut tree_sink);\n+    let syntax = tree_sink.inner.finish();\n+    ast::SourceFile::cast(&syntax).unwrap().to_owned()\n+}\n+\n impl TokenMap {\n     pub fn relative_range_of(&self, tt: tt::TokenId) -> Option<TextRange> {\n         let idx = tt.0 as usize;\n@@ -84,3 +94,138 @@ fn convert_tt(\n     let res = tt::Subtree { delimiter, token_trees };\n     Some(res)\n }\n+\n+struct TtTokenSource {\n+    tokens: Vec<TtToken>,\n+}\n+\n+struct TtToken {\n+    kind: SyntaxKind,\n+    is_joint_to_next: bool,\n+    text: SmolStr,\n+}\n+\n+impl TtTokenSource {\n+    fn new(tt: &tt::Subtree) -> TtTokenSource {\n+        let mut res = TtTokenSource { tokens: Vec::new() };\n+        res.convert_subtree(tt);\n+        res\n+    }\n+    fn convert_subtree(&mut self, sub: &tt::Subtree) {\n+        self.push_delim(sub.delimiter, false);\n+        sub.token_trees.iter().for_each(|tt| self.convert_tt(tt));\n+        self.push_delim(sub.delimiter, true)\n+    }\n+    fn convert_tt(&mut self, tt: &tt::TokenTree) {\n+        match tt {\n+            tt::TokenTree::Leaf(leaf) => self.convert_leaf(leaf),\n+            tt::TokenTree::Subtree(sub) => self.convert_subtree(sub),\n+        }\n+    }\n+    fn convert_leaf(&mut self, leaf: &tt::Leaf) {\n+        let tok = match leaf {\n+            tt::Leaf::Literal(l) => TtToken {\n+                kind: SyntaxKind::INT_NUMBER, // FIXME\n+                is_joint_to_next: false,\n+                text: l.text.clone(),\n+            },\n+            tt::Leaf::Punct(p) => {\n+                let kind = match p.char {\n+                    // lexer may produce combpund tokens for these ones\n+                    '.' => DOT,\n+                    ':' => COLON,\n+                    '=' => EQ,\n+                    '!' => EXCL,\n+                    '-' => MINUS,\n+                    c => SyntaxKind::from_char(c).unwrap(),\n+                };\n+                let text = {\n+                    let mut buf = [0u8; 4];\n+                    let s: &str = p.char.encode_utf8(&mut buf);\n+                    SmolStr::new(s)\n+                };\n+                TtToken { kind, is_joint_to_next: p.spacing == tt::Spacing::Joint, text }\n+            }\n+            tt::Leaf::Ident(ident) => {\n+                let kind = SyntaxKind::from_keyword(ident.text.as_str()).unwrap_or(IDENT);\n+                TtToken { kind, is_joint_to_next: false, text: ident.text.clone() }\n+            }\n+        };\n+        self.tokens.push(tok)\n+    }\n+    fn push_delim(&mut self, d: tt::Delimiter, closing: bool) {\n+        let (kinds, texts) = match d {\n+            tt::Delimiter::Parenthesis => ([L_PAREN, R_PAREN], \"()\"),\n+            tt::Delimiter::Brace => ([L_CURLY, R_CURLY], \"{}\"),\n+            tt::Delimiter::Bracket => ([L_BRACK, R_BRACK], \"[]\"),\n+            tt::Delimiter::None => return,\n+        };\n+        let idx = closing as usize;\n+        let kind = kinds[idx];\n+        let text = &texts[idx..texts.len() - (1 - idx)];\n+        let tok = TtToken { kind, is_joint_to_next: false, text: SmolStr::new(text) };\n+        self.tokens.push(tok)\n+    }\n+}\n+\n+impl TokenSource for TtTokenSource {\n+    fn token_kind(&self, pos: usize) -> SyntaxKind {\n+        if let Some(tok) = self.tokens.get(pos) {\n+            tok.kind\n+        } else {\n+            SyntaxKind::EOF\n+        }\n+    }\n+    fn is_token_joint_to_next(&self, pos: usize) -> bool {\n+        self.tokens[pos].is_joint_to_next\n+    }\n+    fn is_keyword(&self, pos: usize, kw: &str) -> bool {\n+        self.tokens[pos].text == *kw\n+    }\n+}\n+\n+#[derive(Default)]\n+struct TtTreeSink<'a> {\n+    buf: String,\n+    tokens: &'a [TtToken],\n+    text_pos: TextUnit,\n+    token_pos: usize,\n+    inner: SyntaxTreeBuilder,\n+}\n+\n+impl<'a> TtTreeSink<'a> {\n+    fn new(tokens: &'a [TtToken]) -> TtTreeSink {\n+        TtTreeSink {\n+            buf: String::new(),\n+            tokens,\n+            text_pos: 0.into(),\n+            token_pos: 0,\n+            inner: SyntaxTreeBuilder::default(),\n+        }\n+    }\n+}\n+\n+impl<'a> TreeSink for TtTreeSink<'a> {\n+    fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8) {\n+        for _ in 0..n_tokens {\n+            self.buf += self.tokens[self.token_pos].text.as_str();\n+            self.token_pos += 1;\n+        }\n+        self.text_pos += TextUnit::of_str(&self.buf);\n+        let text = SmolStr::new(self.buf.as_str());\n+        self.buf.clear();\n+        self.inner.leaf(kind, text)\n+    }\n+\n+    fn start_branch(&mut self, kind: SyntaxKind) {\n+        self.inner.start_branch(kind);\n+    }\n+\n+    fn finish_branch(&mut self) {\n+        self.inner.finish_branch();\n+    }\n+\n+    fn error(&mut self, error: ParseError) {\n+        self.inner.error(error, self.text_pos)\n+    }\n+}"}, {"sha": "7334d53ef51722b63ce7d4aad0fea5459d2225bd", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -36,7 +36,7 @@ pub use crate::{\n     ast::AstNode,\n     syntax_error::{SyntaxError, SyntaxErrorKind, Location},\n     syntax_text::SyntaxText,\n-    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc},\n+    syntax_node::{Direction,  SyntaxNode, WalkEvent, TreeArc, SyntaxTreeBuilder},\n     ptr::{SyntaxNodePtr, AstPtr},\n     parsing::{tokenize, Token},\n };"}, {"sha": "ad5668a65c23fde277204391bd84e1c47d82123d", "filename": "crates/ra_syntax/src/parsing.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -2,17 +2,13 @@\n //! incremental reparsing.\n \n mod lexer;\n-mod input;\n-mod builder;\n+mod text_token_source;\n+mod text_tree_sink;\n mod reparsing;\n \n use crate::{\n     SyntaxError,\n     syntax_node::GreenNode,\n-    parsing::{\n-        builder::TreeBuilder,\n-        input::ParserInput,\n-    },\n };\n \n pub use self::lexer::{tokenize, Token};\n@@ -21,8 +17,8 @@ pub(crate) use self::reparsing::incremental_reparse;\n \n pub(crate) fn parse_text(text: &str) -> (GreenNode, Vec<SyntaxError>) {\n     let tokens = tokenize(&text);\n-    let token_source = ParserInput::new(text, &tokens);\n-    let mut tree_sink = TreeBuilder::new(text, &tokens);\n+    let token_source = text_token_source::TextTokenSource::new(text, &tokens);\n+    let mut tree_sink = text_tree_sink::TextTreeSink::new(text, &tokens);\n     ra_parser::parse(&token_source, &mut tree_sink);\n     tree_sink.finish()\n }"}, {"sha": "ba77a3b6c8fe4926b33faf35fb608837b4633ee7", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     algo,\n     syntax_node::{GreenNode, SyntaxNode},\n     parsing::{\n-        input::ParserInput,\n-        builder::TreeBuilder,\n+        text_token_source::TextTokenSource,\n+        text_tree_sink::TextTreeSink,\n         lexer::{tokenize, Token},\n     }\n };\n@@ -68,8 +68,8 @@ fn reparse_block<'node>(\n     if !is_balanced(&tokens) {\n         return None;\n     }\n-    let token_source = ParserInput::new(&text, &tokens);\n-    let mut tree_sink = TreeBuilder::new(&text, &tokens);\n+    let token_source = TextTokenSource::new(&text, &tokens);\n+    let mut tree_sink = TextTreeSink::new(&text, &tokens);\n     reparser.parse(&token_source, &mut tree_sink);\n     let (green, new_errors) = tree_sink.finish();\n     Some((node, green, new_errors))"}, {"sha": "a6277f66fc88ba2936c8463d6d4920b2c985e226", "filename": "crates/ra_syntax/src/parsing/text_token_source.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_token_source.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -5,7 +5,7 @@ use crate::{\n     parsing::lexer::Token,\n };\n \n-pub(crate) struct ParserInput<'t> {\n+pub(crate) struct TextTokenSource<'t> {\n     text: &'t str,\n     /// start position of each token(expect whitespace and comment)\n     /// ```non-rust\n@@ -25,7 +25,7 @@ pub(crate) struct ParserInput<'t> {\n     tokens: Vec<Token>,\n }\n \n-impl<'t> TokenSource for ParserInput<'t> {\n+impl<'t> TokenSource for TextTokenSource<'t> {\n     fn token_kind(&self, pos: usize) -> SyntaxKind {\n         if !(pos < self.tokens.len()) {\n             return EOF;\n@@ -48,9 +48,9 @@ impl<'t> TokenSource for ParserInput<'t> {\n     }\n }\n \n-impl<'t> ParserInput<'t> {\n+impl<'t> TextTokenSource<'t> {\n     /// Generate input from tokens(expect comment and whitespace).\n-    pub fn new(text: &'t str, raw_tokens: &'t [Token]) -> ParserInput<'t> {\n+    pub fn new(text: &'t str, raw_tokens: &'t [Token]) -> TextTokenSource<'t> {\n         let mut tokens = Vec::new();\n         let mut start_offsets = Vec::new();\n         let mut len = 0.into();\n@@ -62,6 +62,6 @@ impl<'t> ParserInput<'t> {\n             len += token.len;\n         }\n \n-        ParserInput { text, start_offsets, tokens }\n+        TextTokenSource { text, start_offsets, tokens }\n     }\n }", "previous_filename": "crates/ra_syntax/src/parsing/input.rs"}, {"sha": "961a91d41d99dc9953c188f5ca313198e2183376", "filename": "crates/ra_syntax/src/parsing/text_tree_sink.rs", "status": "renamed", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -1,26 +1,24 @@\n use std::mem;\n \n use ra_parser::{TreeSink, ParseError};\n-use rowan::GreenNodeBuilder;\n \n use crate::{\n-    SmolStr, SyntaxError, SyntaxErrorKind, TextUnit, TextRange,\n+    SmolStr, SyntaxError, TextUnit, TextRange, SyntaxTreeBuilder,\n     SyntaxKind::{self, *},\n     parsing::Token,\n-    syntax_node::{GreenNode, RaTypes},\n+    syntax_node::GreenNode,\n };\n \n /// Bridges the parser with our specific syntax tree representation.\n ///\n-/// `TreeBuilder` also handles attachment of trivia (whitespace) to nodes.\n-pub(crate) struct TreeBuilder<'a> {\n+/// `TextTreeSink` also handles attachment of trivia (whitespace) to nodes.\n+pub(crate) struct TextTreeSink<'a> {\n     text: &'a str,\n     tokens: &'a [Token],\n     text_pos: TextUnit,\n     token_pos: usize,\n     state: State,\n-    errors: Vec<SyntaxError>,\n-    inner: GreenNodeBuilder<RaTypes>,\n+    inner: SyntaxTreeBuilder,\n }\n \n enum State {\n@@ -29,11 +27,11 @@ enum State {\n     PendingFinish,\n }\n \n-impl<'a> TreeSink for TreeBuilder<'a> {\n+impl<'a> TreeSink for TextTreeSink<'a> {\n     fn leaf(&mut self, kind: SyntaxKind, n_tokens: u8) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => unreachable!(),\n-            State::PendingFinish => self.inner.finish_internal(),\n+            State::PendingFinish => self.inner.finish_branch(),\n             State::Normal => (),\n         }\n         self.eat_trivias();\n@@ -48,12 +46,12 @@ impl<'a> TreeSink for TreeBuilder<'a> {\n     fn start_branch(&mut self, kind: SyntaxKind) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => {\n-                self.inner.start_internal(kind);\n+                self.inner.start_branch(kind);\n                 // No need to attach trivias to previous node: there is no\n                 // previous node.\n                 return;\n             }\n-            State::PendingFinish => self.inner.finish_internal(),\n+            State::PendingFinish => self.inner.finish_branch(),\n             State::Normal => (),\n         }\n \n@@ -73,47 +71,45 @@ impl<'a> TreeSink for TreeBuilder<'a> {\n             n_attached_trivias(kind, leading_trivias)\n         };\n         self.eat_n_trivias(n_trivias - n_attached_trivias);\n-        self.inner.start_internal(kind);\n+        self.inner.start_branch(kind);\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n     fn finish_branch(&mut self) {\n         match mem::replace(&mut self.state, State::PendingFinish) {\n             State::PendingStart => unreachable!(),\n-            State::PendingFinish => self.inner.finish_internal(),\n+            State::PendingFinish => self.inner.finish_branch(),\n             State::Normal => (),\n         }\n     }\n \n     fn error(&mut self, error: ParseError) {\n-        let error = SyntaxError::new(SyntaxErrorKind::ParseError(error), self.text_pos);\n-        self.errors.push(error)\n+        self.inner.error(error, self.text_pos)\n     }\n }\n \n-impl<'a> TreeBuilder<'a> {\n-    pub(super) fn new(text: &'a str, tokens: &'a [Token]) -> TreeBuilder<'a> {\n-        TreeBuilder {\n+impl<'a> TextTreeSink<'a> {\n+    pub(super) fn new(text: &'a str, tokens: &'a [Token]) -> TextTreeSink<'a> {\n+        TextTreeSink {\n             text,\n             tokens,\n             text_pos: 0.into(),\n             token_pos: 0,\n             state: State::PendingStart,\n-            errors: Vec::new(),\n-            inner: GreenNodeBuilder::new(),\n+            inner: SyntaxTreeBuilder::default(),\n         }\n     }\n \n     pub(super) fn finish(mut self) -> (GreenNode, Vec<SyntaxError>) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingFinish => {\n                 self.eat_trivias();\n-                self.inner.finish_internal()\n+                self.inner.finish_branch()\n             }\n             State::PendingStart | State::Normal => unreachable!(),\n         }\n \n-        (self.inner.finish(), self.errors)\n+        self.inner.finish_raw()\n     }\n \n     fn eat_trivias(&mut self) {", "previous_filename": "crates/ra_syntax/src/parsing/builder.rs"}, {"sha": "e5b4cdb116b289b414e3e387d1eda43fe9d6a242", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 48, "deletions": 3, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6f160391db945a0dcc2f73b38926d6919f7c566/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=f6f160391db945a0dcc2f73b38926d6919f7c566", "patch": "@@ -11,11 +11,12 @@ use std::{\n     borrow::Borrow,\n };\n \n-use rowan::{Types, TransparentNewType};\n+use ra_parser::ParseError;\n+use rowan::{Types, TransparentNewType, GreenNodeBuilder};\n \n use crate::{\n-    SmolStr, SyntaxKind, TextRange, SyntaxText, SourceFile, AstNode,\n-    syntax_error::SyntaxError,\n+    SmolStr, SyntaxKind, TextUnit, TextRange, SyntaxText, SourceFile, AstNode,\n+    syntax_error::{SyntaxError, SyntaxErrorKind},\n };\n \n pub use rowan::WalkEvent;\n@@ -276,3 +277,47 @@ fn has_short_text(kind: SyntaxKind) -> bool {\n         _ => false,\n     }\n }\n+\n+pub struct SyntaxTreeBuilder {\n+    errors: Vec<SyntaxError>,\n+    inner: GreenNodeBuilder<RaTypes>,\n+}\n+\n+impl Default for SyntaxTreeBuilder {\n+    fn default() -> SyntaxTreeBuilder {\n+        SyntaxTreeBuilder { errors: Vec::new(), inner: GreenNodeBuilder::new() }\n+    }\n+}\n+\n+impl SyntaxTreeBuilder {\n+    pub(crate) fn finish_raw(self) -> (GreenNode, Vec<SyntaxError>) {\n+        let green = self.inner.finish();\n+        (green, self.errors)\n+    }\n+\n+    pub fn finish(self) -> TreeArc<SyntaxNode> {\n+        let (green, errors) = self.finish_raw();\n+        let node = SyntaxNode::new(green, errors);\n+        if cfg!(debug_assertions) {\n+            crate::validation::validate_block_structure(&node);\n+        }\n+        node\n+    }\n+\n+    pub fn leaf(&mut self, kind: SyntaxKind, text: SmolStr) {\n+        self.inner.leaf(kind, text)\n+    }\n+\n+    pub fn start_branch(&mut self, kind: SyntaxKind) {\n+        self.inner.start_internal(kind)\n+    }\n+\n+    pub fn finish_branch(&mut self) {\n+        self.inner.finish_internal()\n+    }\n+\n+    pub fn error(&mut self, error: ParseError, text_pos: TextUnit) {\n+        let error = SyntaxError::new(SyntaxErrorKind::ParseError(error), text_pos);\n+        self.errors.push(error)\n+    }\n+}"}]}