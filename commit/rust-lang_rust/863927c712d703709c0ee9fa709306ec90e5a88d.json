{"sha": "863927c712d703709c0ee9fa709306ec90e5a88d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MzkyN2M3MTJkNzAzNzA5YzBlZTlmYTcwOTMwNmVjOTBlNWE4OGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-13T17:14:37Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-13T22:33:09Z"}, "message": "rewrite post-processing routines not to require a `CrateContext`\n\nThese do some low-level munging on the LLVM data structures. Unclear\nthat they need to operate as a \"second pass\" but leave it for now.", "tree": {"sha": "5e036efa98ed54a6f73e3e63d5594ee0c6c27dbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e036efa98ed54a6f73e3e63d5594ee0c6c27dbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/863927c712d703709c0ee9fa709306ec90e5a88d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/863927c712d703709c0ee9fa709306ec90e5a88d", "html_url": "https://github.com/rust-lang/rust/commit/863927c712d703709c0ee9fa709306ec90e5a88d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/863927c712d703709c0ee9fa709306ec90e5a88d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc79f01a581c9340cd869ba36579ee80d9606298", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc79f01a581c9340cd869ba36579ee80d9606298", "html_url": "https://github.com/rust-lang/rust/commit/bc79f01a581c9340cd869ba36579ee80d9606298"}], "stats": {"total": 66, "additions": 36, "deletions": 30}, "files": [{"sha": "a034974cb13edd1f4bff79a1cdf5d18dbe58f499", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=863927c712d703709c0ee9fa709306ec90e5a88d", "patch": "@@ -799,7 +799,8 @@ fn write_metadata(cx: &SharedCrateContext,\n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n fn internalize_symbols<'a, 'tcx>(sess: &Session,\n-                                 ccxs: &CrateContextList<'a, 'tcx>,\n+                                 scx: &SharedCrateContext<'a, 'tcx>,\n+                                 llvm_modules: &[ModuleLlvm],\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n@@ -814,7 +815,6 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         .map(|&(ref name, _)| &name[..])\n         .collect::<FxHashSet<&str>>();\n \n-    let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n     let incr_comp = sess.opts.debugging_opts.incremental.is_some();\n@@ -829,8 +829,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // incremental compilation, we don't need to collect. See below for more\n         // information.\n         if !incr_comp {\n-            for ccx in ccxs.iter_need_trans() {\n-                for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+            for ll in llvm_modules {\n+                for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                     let linkage = llvm::LLVMRustGetLinkage(val);\n                     // We only care about external declarations (not definitions)\n                     // and available_externally definitions.\n@@ -866,8 +866,8 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in ccxs.iter_need_trans() {\n-            for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n+        for ll in llvm_modules {\n+            for val in iter_globals(ll.llmod).chain(iter_functions(ll.llmod)) {\n                 let linkage = llvm::LLVMRustGetLinkage(val);\n \n                 let is_externally_visible = (linkage == llvm::Linkage::ExternalLinkage) ||\n@@ -926,33 +926,34 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n // when using MSVC linker.  We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n-fn create_imps(cx: &CrateContextList) {\n+fn create_imps(sess: &Session,\n+               llvm_modules: &[ModuleLlvm]) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n     // underscores added in front).\n-    let prefix = if cx.shared().sess().target.target.target_pointer_width == \"32\" {\n+    let prefix = if sess.target.target.target_pointer_width == \"32\" {\n         \"\\x01__imp__\"\n     } else {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter_need_trans() {\n-            let exported: Vec<_> = iter_globals(ccx.llmod())\n+        for ll in llvm_modules {\n+            let exported: Vec<_> = iter_globals(ll.llmod)\n                                        .filter(|&val| {\n                                            llvm::LLVMRustGetLinkage(val) ==\n                                            llvm::Linkage::ExternalLinkage &&\n                                            llvm::LLVMIsDeclaration(val) == 0\n                                        })\n                                        .collect();\n \n-            let i8p_ty = Type::i8p(&ccx);\n+            let i8p_ty = Type::i8p_llcx(ll.llcx);\n             for val in exported {\n                 let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n                 let mut imp_name = prefix.as_bytes().to_vec();\n                 imp_name.extend(name.to_bytes());\n                 let imp_name = CString::new(imp_name).unwrap();\n-                let imp = llvm::LLVMAddGlobal(ccx.llmod(),\n+                let imp = llvm::LLVMAddGlobal(ll.llmod,\n                                               i8p_ty.to_ref(),\n                                               imp_name.as_ptr() as *const _);\n                 let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n@@ -1244,11 +1245,23 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n                                                          &symbol_map);\n \n+    // Get the list of llvm modules we created. We'll do a few wacky\n+    // transforms on them now.\n+\n+    let llvm_modules: Vec<_> =\n+        modules.iter()\n+               .filter_map(|module| match module.source {\n+                   ModuleSource::Translated(llvm) => Some(llvm),\n+                   _ => None,\n+               })\n+               .collect();\n+\n     // Now that we have all symbols that are exported from the CGUs of this\n     // crate, we can run the `internalize_symbols` pass.\n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n         internalize_symbols(sess,\n-                            &crate_context_list,\n+                            &shared_ccx,\n+                            &llvm_modules,\n                             &symbol_map,\n                             &exported_symbols);\n     });\n@@ -1259,7 +1272,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(&crate_context_list);\n+        create_imps(sess, &llvm_modules);\n     }\n \n     let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);"}, {"sha": "e3b1e04c5303f40ef064fb403090fe1a2b81a6af", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=863927c712d703709c0ee9fa709306ec90e5a88d", "patch": "@@ -244,21 +244,6 @@ impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n             filter_to_previous_work_product_unavail: false,\n         }\n     }\n-\n-    /// Iterator over all CCX that need translation (cannot reuse results from\n-    /// previous incr. comp.).\n-    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n-        CrateContextIterator {\n-            shared: self.shared,\n-            index: 0,\n-            local_ccxs: &self.local_ccxs[..],\n-            filter_to_previous_work_product_unavail: true,\n-        }\n-    }\n-\n-    pub fn shared(&self) -> &'a SharedCrateContext<'a, 'tcx> {\n-        self.shared\n-    }\n }\n \n /// A CrateContext value binds together one LocalCrateContext with the"}, {"sha": "d70afc0cce5a3cbebfa7ff9bc997b53b0b5137c2", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/863927c712d703709c0ee9fa709306ec90e5a88d/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=863927c712d703709c0ee9fa709306ec90e5a88d", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n \n use llvm;\n-use llvm::{TypeRef, Bool, False, True, TypeKind};\n+use llvm::{ContextRef, TypeRef, Bool, False, True, TypeKind};\n use llvm::{Float, Double, X86_FP80, PPC_FP128, FP128};\n \n use context::CrateContext;\n@@ -82,6 +82,10 @@ impl Type {\n         ty!(llvm::LLVMInt8TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i8_llcx(llcx: ContextRef) -> Type {\n+        ty!(llvm::LLVMInt8TypeInContext(llcx))\n+    }\n+\n     pub fn i16(ccx: &CrateContext) -> Type {\n         ty!(llvm::LLVMInt16TypeInContext(ccx.llcx()))\n     }\n@@ -123,6 +127,10 @@ impl Type {\n         Type::i8(ccx).ptr_to()\n     }\n \n+    pub fn i8p_llcx(llcx: ContextRef) -> Type {\n+        Type::i8_llcx(llcx).ptr_to()\n+    }\n+\n     pub fn int(ccx: &CrateContext) -> Type {\n         match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"16\" => Type::i16(ccx),"}]}