{"sha": "f3fc547194d22dc673274ac20e9a7b1e607cb862", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZmM1NDcxOTRkMjJkYzY3MzI3NGFjMjBlOWE3YjFlNjA3Y2I4NjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-09T11:55:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-09T11:55:37Z"}, "message": "Auto merge of #41709 - michaelwoerister:close-metadata-ich-holes, r=nikomatsakis\n\nincr.comp.: Hash more pieces of crate metadata to detect changes there.\n\nThis PR adds incr. comp. hashes for non-`Entry` pieces of data in crate metadata.\n\nThe first part of it I like: `EntryBuilder` is refactored into the more generally applicable `IsolatedEncoder` which provides means of encoding something into metadata while also feeding the encoded data into an incr. comp. hash. We already did this for `Entry`, now we are doing it for various other pieces of data too, like the set of exported symbols and so on. The hashes generated there are persisted together with the per-`Entry` hashes and are also used for dep-graph dirtying the same way.\n\nThe second part of the PR I'm not entirely happy with: In order to make sure that we don't forget registering a read to the new `DepNodes` introduced here, I added the `Tracked<T>` struct. This struct wraps a value and requires a `DepNode` when accessing the wrapped value. This makes it harder to overlook adding read edges in the right places and works just fine.\nHowever, crate metadata is already used in places where there is no `tcx` yet or even in places where no `cnum` has been assigned -- this makes it harder to apply this feature consistently or implement it ergonomically. The result is not too bad but there's a bit more code churn and a bit more opportunity to get something wrong than I would have liked. On the other hand, wrapping things in `Tracked<T>` already has revealed some bugs, so there's definitely some value in it.\n\nThis is still a work in progress:\n- [x] I need to write some test cases.\n- [x] Accessing the CodeMap should really be dependency tracked too, especially with the new path-remapping feature.\n\ncc @nikomatsakis", "tree": {"sha": "c51e4d0b978a96b241093d39a0d9868ceef27e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c51e4d0b978a96b241093d39a0d9868ceef27e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3fc547194d22dc673274ac20e9a7b1e607cb862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fc547194d22dc673274ac20e9a7b1e607cb862", "html_url": "https://github.com/rust-lang/rust/commit/f3fc547194d22dc673274ac20e9a7b1e607cb862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3fc547194d22dc673274ac20e9a7b1e607cb862/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d53dce7eaef554a6c48eb5f179884becee4d82", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d53dce7eaef554a6c48eb5f179884becee4d82", "html_url": "https://github.com/rust-lang/rust/commit/c2d53dce7eaef554a6c48eb5f179884becee4d82"}, {"sha": "115602b1beed92998998ec45460f917b6281980a", "url": "https://api.github.com/repos/rust-lang/rust/commits/115602b1beed92998998ec45460f917b6281980a", "html_url": "https://github.com/rust-lang/rust/commit/115602b1beed92998998ec45460f917b6281980a"}], "stats": {"total": 2358, "additions": 1506, "deletions": 852}, "files": [{"sha": "af425a95fb19ccc55da7e84a3bedd435e7f0367a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -51,6 +51,9 @@ pub enum DepNode<D: Clone + Debug> {\n     // in an extern crate.\n     MetaData(D),\n \n+    // Represents some piece of metadata global to its crate.\n+    GlobalMetaData(D, GlobalMetaDataKind),\n+\n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n     WorkProduct(Arc<WorkProductId>),\n@@ -79,7 +82,6 @@ pub enum DepNode<D: Clone + Debug> {\n     MirKeys,\n     LateLintCheck,\n     TransCrateItem(D),\n-    TransInlinedItem(D),\n     TransWriteMetadata,\n     CrateVariances,\n \n@@ -157,6 +159,7 @@ pub enum DepNode<D: Clone + Debug> {\n     DefSpan(D),\n     Stability(D),\n     Deprecation(D),\n+    FileMap(D, Arc<String>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -234,7 +237,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             RegionMaps(ref d) => op(d).map(RegionMaps),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n-            TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n             ItemVariances(ref d) => op(d).map(ItemVariances),\n@@ -271,6 +273,8 @@ impl<D: Clone + Debug> DepNode<D> {\n             DefSpan(ref d) => op(d).map(DefSpan),\n             Stability(ref d) => op(d).map(Stability),\n             Deprecation(ref d) => op(d).map(Deprecation),\n+            GlobalMetaData(ref d, kind) => op(d).map(|d| GlobalMetaData(d, kind)),\n+            FileMap(ref d, ref file_name) => op(d).map(|d| FileMap(d, file_name.clone())),\n         }\n     }\n }\n@@ -282,3 +286,16 @@ impl<D: Clone + Debug> DepNode<D> {\n /// them even in the absence of a tcx.)\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct WorkProductId(pub String);\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum GlobalMetaDataKind {\n+    Krate,\n+    CrateDeps,\n+    DylibDependencyFormats,\n+    LangItems,\n+    LangItemsMissing,\n+    NativeLibraries,\n+    CodeMap,\n+    Impls,\n+    ExportedSymbols,\n+}"}, {"sha": "822b61df7a489ae7b2c11677b341343a46585fb6", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -22,6 +22,7 @@ mod thread;\n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n pub use self::dep_node::WorkProductId;\n+pub use self::dep_node::GlobalMetaDataKind;\n pub use self::graph::DepGraph;\n pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;"}, {"sha": "47604b961ae4ac04f505fe9b013d504575cfaee6", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -36,7 +36,10 @@ pub const LOCAL_CRATE: CrateNum = CrateNum(0);\n \n /// Virtual crate for builtin macros\n // FIXME(jseyfried): this is also used for custom derives until proc-macro crates get `CrateNum`s.\n-pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(!0);\n+pub const BUILTIN_MACROS_CRATE: CrateNum = CrateNum(u32::MAX);\n+\n+/// A CrateNum value that indicates that something is wrong.\n+pub const INVALID_CRATE: CrateNum = CrateNum(u32::MAX - 1);\n \n impl CrateNum {\n     pub fn new(x: usize) -> CrateNum {"}, {"sha": "a6cfcb710edad6919ec68c2c32008f38c95681d7", "filename": "src/librustc/hir/svh.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fhir%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fhir%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fsvh.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -66,3 +66,7 @@ impl Decodable for Svh {\n          .map(Svh::new)\n     }\n }\n+\n+impl_stable_hash_for!(struct Svh {\n+    hash\n+});"}, {"sha": "b21c3a2b216000e4072b3e2b11dbcccc637c6345", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -8,10 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ty::TyCtxt;\n+use dep_graph::{DepGraph, DepNode};\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n+use rustc_data_structures::bitvec::BitVector;\n use std::rc::Rc;\n+use std::sync::Arc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n+use ty::TyCtxt;\n \n #[derive(Clone)]\n struct CacheEntry {\n@@ -20,30 +24,37 @@ struct CacheEntry {\n     line_start: BytePos,\n     line_end: BytePos,\n     file: Rc<FileMap>,\n+    file_index: usize,\n }\n \n pub struct CachingCodemapView<'tcx> {\n     codemap: &'tcx CodeMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n+    dep_graph: DepGraph,\n+    dep_tracking_reads: BitVector,\n }\n \n impl<'tcx> CachingCodemapView<'tcx> {\n     pub fn new<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> CachingCodemapView<'tcx> {\n         let codemap = tcx.sess.codemap();\n-        let first_file = codemap.files.borrow()[0].clone();\n+        let files = codemap.files_untracked();\n+        let first_file = files[0].clone();\n         let entry = CacheEntry {\n             time_stamp: 0,\n             line_number: 0,\n             line_start: BytePos(0),\n             line_end: BytePos(0),\n             file: first_file,\n+            file_index: 0,\n         };\n \n         CachingCodemapView {\n+            dep_graph: tcx.dep_graph.clone(),\n             codemap: codemap,\n             line_cache: [entry.clone(), entry.clone(), entry.clone()],\n             time_stamp: 0,\n+            dep_tracking_reads: BitVector::new(files.len()),\n         }\n     }\n \n@@ -56,6 +67,10 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         for cache_entry in self.line_cache.iter_mut() {\n             if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n                 cache_entry.time_stamp = self.time_stamp;\n+                if self.dep_tracking_reads.insert(cache_entry.file_index) {\n+                    self.dep_graph.read(dep_node(cache_entry));\n+                }\n+\n                 return Some((cache_entry.file.clone(),\n                              cache_entry.line_number,\n                              pos - cache_entry.line_start));\n@@ -75,14 +90,15 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         // If the entry doesn't point to the correct file, fix it up\n         if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n             let file_valid;\n-            let files = self.codemap.files.borrow();\n+            let files = self.codemap.files_untracked();\n \n             if files.len() > 0 {\n                 let file_index = self.codemap.lookup_filemap_idx(pos);\n                 let file = files[file_index].clone();\n \n                 if pos >= file.start_pos && pos < file.end_pos {\n                     cache_entry.file = file;\n+                    cache_entry.file_index = file_index;\n                     file_valid = true;\n                 } else {\n                     file_valid = false;\n@@ -104,8 +120,21 @@ impl<'tcx> CachingCodemapView<'tcx> {\n         cache_entry.line_end = line_bounds.1;\n         cache_entry.time_stamp = self.time_stamp;\n \n+        if self.dep_tracking_reads.insert(cache_entry.file_index) {\n+            self.dep_graph.read(dep_node(cache_entry));\n+        }\n+\n         return Some((cache_entry.file.clone(),\n                      cache_entry.line_number,\n                      pos - cache_entry.line_start));\n     }\n }\n+\n+fn dep_node(cache_entry: &CacheEntry) -> DepNode<DefId> {\n+    let def_id = DefId {\n+        krate: CrateNum::from_u32(cache_entry.file.crate_of_origin),\n+        index: CRATE_DEF_INDEX,\n+    };\n+    let name = Arc::new(cache_entry.file.name.clone());\n+    DepNode::FileMap(def_id, name)\n+}"}, {"sha": "e95dbdd15c5f0e1a285cc025d58d5ac628c22bd6", "filename": "src/librustc/ich/impls_cstore.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! from rustc::middle::cstore in no particular order.\n+\n+use middle;\n+\n+impl_stable_hash_for!(enum middle::cstore::DepKind {\n+    UnexportedMacrosOnly,\n+    MacrosOnly,\n+    Implicit,\n+    Explicit\n+});\n+\n+impl_stable_hash_for!(enum middle::cstore::NativeLibraryKind {\n+    NativeStatic,\n+    NativeStaticNobundle,\n+    NativeFramework,\n+    NativeUnknown\n+});\n+\n+impl_stable_hash_for!(struct middle::cstore::NativeLibrary {\n+    kind,\n+    name,\n+    cfg,\n+    foreign_items\n+});\n+\n+impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n+    RequireDynamic,\n+    RequireStatic\n+});"}, {"sha": "abc51601b6ecef814c2ea2e95da8e37739367521", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -1120,3 +1120,11 @@ impl_stable_hash_for!(struct hir::def::Export {\n     def,\n     span\n });\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::lang_items::LangItem {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        ::std::hash::Hash::hash(self, hasher);\n+    }\n+}"}, {"sha": "7138db01339f6a89489a6204526c24fb26c96b87", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -19,7 +19,9 @@ use std::mem;\n use syntax::ast;\n use syntax::parse::token;\n use syntax::tokenstream;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, FileMap};\n+\n+use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n@@ -299,3 +301,79 @@ fn hash_token<'a, 'tcx, W: StableHasherResult>(token: &token::Token,\n         token::Token::Shebang(val) => val.hash_stable(hcx, hasher),\n     }\n }\n+\n+impl_stable_hash_for_spanned!(::syntax::ast::NestedMetaItemKind);\n+\n+impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n+    MetaItem(meta_item),\n+    Literal(lit)\n+});\n+\n+impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n+    name,\n+    node,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n+    Word,\n+    List(nested_items),\n+    NameValue(lit)\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for FileMap {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let FileMap {\n+            ref name,\n+            name_was_remapped,\n+            crate_of_origin,\n+            // Do not hash the source as it is not encoded\n+            src: _,\n+            start_pos,\n+            end_pos: _,\n+            ref lines,\n+            ref multibyte_chars,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+        name_was_remapped.hash_stable(hcx, hasher);\n+\n+        DefId {\n+            krate: CrateNum::from_u32(crate_of_origin),\n+            index: CRATE_DEF_INDEX,\n+        }.hash_stable(hcx, hasher);\n+\n+        // We only hash the relative position within this filemap\n+        let lines = lines.borrow();\n+        lines.len().hash_stable(hcx, hasher);\n+        for &line in lines.iter() {\n+            stable_byte_pos(line, start_pos).hash_stable(hcx, hasher);\n+        }\n+\n+        // We only hash the relative position within this filemap\n+        let multibyte_chars = multibyte_chars.borrow();\n+        multibyte_chars.len().hash_stable(hcx, hasher);\n+        for &char_pos in multibyte_chars.iter() {\n+            stable_multibyte_char(char_pos, start_pos).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n+\n+fn stable_byte_pos(pos: ::syntax_pos::BytePos,\n+                   filemap_start: ::syntax_pos::BytePos)\n+                   -> u32 {\n+    pos.0 - filemap_start.0\n+}\n+\n+fn stable_multibyte_char(mbc: ::syntax_pos::MultiByteChar,\n+                         filemap_start: ::syntax_pos::BytePos)\n+                         -> (u32, u32) {\n+    let ::syntax_pos::MultiByteChar {\n+        pos,\n+        bytes,\n+    } = mbc;\n+\n+    (pos.0 - filemap_start.0, bytes as u32)\n+}"}, {"sha": "d881a1cc45a79a56da6c1a420b278068e6264bfb", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -19,6 +19,7 @@ mod caching_codemap_view;\n mod hcx;\n \n mod impls_const_math;\n+mod impls_cstore;\n mod impls_hir;\n mod impls_mir;\n mod impls_ty;"}, {"sha": "16b3fcd2f8c32702ee89e327edfccf79c2a3da6e", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -23,6 +23,7 @@\n // probably get a better home if someone can find one.\n \n use hir::def;\n+use dep_graph::DepNode;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n@@ -161,7 +162,16 @@ pub struct ExternCrate {\n \n pub struct EncodedMetadata {\n     pub raw_data: Vec<u8>,\n-    pub hashes: Vec<EncodedMetadataHash>,\n+    pub hashes: EncodedMetadataHashes,\n+}\n+\n+impl EncodedMetadata {\n+    pub fn new() -> EncodedMetadata {\n+        EncodedMetadata {\n+            raw_data: Vec::new(),\n+            hashes: EncodedMetadataHashes::new(),\n+        }\n+    }\n }\n \n /// The hash for some metadata that (when saving) will be exported\n@@ -173,6 +183,24 @@ pub struct EncodedMetadataHash {\n     pub hash: ich::Fingerprint,\n }\n \n+/// The hash for some metadata that (when saving) will be exported\n+/// from this crate, or which (when importing) was exported by an\n+/// upstream crate.\n+#[derive(Debug, RustcEncodable, RustcDecodable, Clone)]\n+pub struct EncodedMetadataHashes {\n+    pub entry_hashes: Vec<EncodedMetadataHash>,\n+    pub global_hashes: Vec<(DepNode<()>, ich::Fingerprint)>,\n+}\n+\n+impl EncodedMetadataHashes {\n+    pub fn new() -> EncodedMetadataHashes {\n+        EncodedMetadataHashes {\n+            entry_hashes: Vec::new(),\n+            global_hashes: Vec::new(),\n+        }\n+    }\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {"}, {"sha": "2e2d5a6bd4d387e8f2cf32208270cd2f63b24876", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -11,8 +11,8 @@\n pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n \n-use dep_graph::DepGraph;\n-use hir::def_id::{CrateNum, DefIndex};\n+use dep_graph::{DepGraph, DepNode};\n+use hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n use lint;\n use middle::cstore::CrateStore;\n use middle::dependency_format;\n@@ -32,7 +32,7 @@ use syntax::parse::ParseSess;\n use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n-use syntax_pos::{Span, MultiSpan};\n+use syntax_pos::{Span, MultiSpan, FileMap};\n \n use rustc_back::{LinkerFlavor, PanicStrategy};\n use rustc_back::target::Target;\n@@ -48,6 +48,7 @@ use std::io::Write;\n use std::rc::Rc;\n use std::fmt;\n use std::time::Duration;\n+use std::sync::Arc;\n use libc::c_int;\n \n mod code_stats;\n@@ -627,6 +628,22 @@ pub fn build_session_(sopts: config::Options,\n         }\n     };\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n+\n+    // Hook up the codemap with a callback that allows it to register FileMap\n+    // accesses with the dependency graph.\n+    let cm_depgraph = dep_graph.clone();\n+    let codemap_dep_tracking_callback = Box::new(move |filemap: &FileMap| {\n+        let def_id = DefId {\n+            krate: CrateNum::from_u32(filemap.crate_of_origin),\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let name = Arc::new(filemap.name.clone());\n+        let dep_node = DepNode::FileMap(def_id, name);\n+\n+        cm_depgraph.read(dep_node);\n+    });\n+    codemap.set_dep_tracking_callback(codemap_dep_tracking_callback);\n+\n     let p_s = parse::ParseSess::with_span_handler(span_diagnostic, codemap);\n     let default_sysroot = match sopts.maybe_sysroot {\n         Some(_) => None,"}, {"sha": "635b95d861dafec9e88a401952c96f31222ce5f2", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -283,6 +283,16 @@ impl<CTX> HashStable<CTX> for str {\n     }\n }\n \n+\n+impl<CTX> HashStable<CTX> for String {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        (&self[..]).hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "5f14890665caba8aa963bada709f3a78601d039e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -1155,8 +1155,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n             // Build a list of files used to compile the output and\n             // write Makefile-compatible dependency rules\n             let files: Vec<String> = sess.codemap()\n-                                         .files\n-                                         .borrow()\n+                                         .files()\n                                          .iter()\n                                          .filter(|fmap| fmap.is_real_file())\n                                          .filter(|fmap| !fmap.is_imported())"}, {"sha": "6f5cc1f3f45c87d0384dd439325e4a8453fb4fb0", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -29,9 +29,10 @@\n \n use std::cell::RefCell;\n use std::hash::Hash;\n+use std::sync::Arc;\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{LOCAL_CRATE, CRATE_DEF_INDEX, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n@@ -60,6 +61,10 @@ impl IncrementalHashesMap {\n         }\n     }\n \n+    pub fn get(&self, k: &DepNode<DefId>) -> Option<&Fingerprint> {\n+        self.hashes.get(k)\n+    }\n+\n     pub fn insert(&mut self, k: DepNode<DefId>, v: Fingerprint) -> Option<Fingerprint> {\n         self.hashes.insert(k, v)\n     }\n@@ -140,14 +145,34 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             let hcx = &mut self.hcx;\n             let mut item_hashes: Vec<_> =\n                 self.hashes.iter()\n-                           .map(|(item_dep_node, &item_hash)| {\n-                               // convert from a DepNode<DefId> tp a\n-                               // DepNode<u64> where the u64 is the\n-                               // hash of the def-id's def-path:\n-                               let item_dep_node =\n-                                   item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n-                                                .unwrap();\n-                               (item_dep_node, item_hash)\n+                           .filter_map(|(item_dep_node, &item_hash)| {\n+                                // This `match` determines what kinds of nodes\n+                                // go into the SVH:\n+                                match *item_dep_node {\n+                                    DepNode::Hir(_) |\n+                                    DepNode::HirBody(_) => {\n+                                        // We want to incoporate these into the\n+                                        // SVH.\n+                                    }\n+                                    DepNode::FileMap(..) => {\n+                                        // These don't make a semantic\n+                                        // difference, filter them out.\n+                                        return None\n+                                    }\n+                                    ref other => {\n+                                        bug!(\"Found unexpected DepNode during \\\n+                                              SVH computation: {:?}\",\n+                                             other)\n+                                    }\n+                                }\n+\n+                                // Convert from a DepNode<DefId> to a\n+                                // DepNode<u64> where the u64 is the hash of\n+                                // the def-id's def-path:\n+                                let item_dep_node =\n+                                    item_dep_node.map_def(|&did| Some(hcx.def_path_hash(did)))\n+                                                 .unwrap();\n+                                Some((item_dep_node, item_hash))\n                            })\n                            .collect();\n             item_hashes.sort_unstable(); // avoid artificial dependencies on item ordering\n@@ -229,6 +254,24 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n             visitor.compute_and_store_ich_for_item_like(DepNode::Hir(def_id), false, macro_def);\n             visitor.compute_and_store_ich_for_item_like(DepNode::HirBody(def_id), true, macro_def);\n         }\n+\n+        for filemap in tcx.sess\n+                          .codemap()\n+                          .files_untracked()\n+                          .iter()\n+                          .filter(|fm| !fm.is_imported()) {\n+            assert_eq!(LOCAL_CRATE.as_u32(), filemap.crate_of_origin);\n+            let def_id = DefId {\n+                krate: LOCAL_CRATE,\n+                index: CRATE_DEF_INDEX,\n+            };\n+            let name = Arc::new(filemap.name.clone());\n+            let dep_node = DepNode::FileMap(def_id, name);\n+            let mut hasher = IchHasher::new();\n+            filemap.hash_stable(&mut visitor.hcx, &mut hasher);\n+            let fingerprint = hasher.finish();\n+            visitor.hashes.insert(dep_node, fingerprint);\n+        }\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);"}, {"sha": "b016ff34bc5c604be24c0b0d4c1557d34bf2a573", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -99,7 +99,11 @@ pub struct SerializedMetadataHashes {\n     /// where `X` refers to some item in this crate. That `X` will be\n     /// a `DefPathIndex` that gets retracted to the current `DefId`\n     /// (matching the one found in this structure).\n-    pub hashes: Vec<EncodedMetadataHash>,\n+    pub entry_hashes: Vec<EncodedMetadataHash>,\n+\n+    /// This map contains fingerprints that are not specific to some DefId but\n+    /// describe something global to the whole crate.\n+    pub global_hashes: Vec<(DepNode<()>, Fingerprint)>,\n \n     /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n     /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so"}, {"sha": "5bc442deafa2bd726524e98d6cd7f09f9d214d3d", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 65, "deletions": 17, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::def_id::{CrateNum, DefId};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::ty::TyCtxt;\n@@ -23,11 +23,15 @@ use super::data::*;\n use super::fs::*;\n use super::file_format;\n \n+use std::hash::Hash;\n+use std::fmt::Debug;\n+\n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     incremental_hashes_map: &'a IncrementalHashesMap,\n     item_metadata_hashes: FxHashMap<DefId, Fingerprint>,\n     crate_hashes: FxHashMap<CrateNum, Svh>,\n+    global_metadata_hashes: FxHashMap<DepNode<DefId>, Fingerprint>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n@@ -39,16 +43,19 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             incremental_hashes_map: incremental_hashes_map,\n             item_metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n+            global_metadata_hashes: FxHashMap(),\n         }\n     }\n \n     pub fn is_hashable(dep_node: &DepNode<DefId>) -> bool {\n         match *dep_node {\n             DepNode::Krate |\n             DepNode::Hir(_) |\n-            DepNode::HirBody(_) =>\n+            DepNode::HirBody(_) |\n+            DepNode::FileMap(..) =>\n                 true,\n-            DepNode::MetaData(def_id) => !def_id.is_local(),\n+            DepNode::MetaData(def_id) |\n+            DepNode::GlobalMetaData(def_id, _) => !def_id.is_local(),\n             _ => false,\n         }\n     }\n@@ -60,7 +67,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n-            DepNode::Hir(def_id) | DepNode::HirBody(def_id) => {\n+            DepNode::Hir(def_id) |\n+            DepNode::HirBody(def_id) => {\n                 assert!(def_id.is_local(),\n                         \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n                         def_id,\n@@ -69,12 +77,30 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                 Some(self.incremental_hashes_map[dep_node])\n             }\n \n+            DepNode::FileMap(def_id, ref name) => {\n+                if def_id.is_local() {\n+                    Some(self.incremental_hashes_map[dep_node])\n+                } else {\n+                    Some(self.metadata_hash(DepNode::FileMap(def_id, name.clone()),\n+                                            def_id.krate,\n+                                            |this| &mut this.global_metadata_hashes))\n+                }\n+            }\n+\n             // MetaData from other crates is an *input* to us.\n             // MetaData nodes from *our* crates are an *output*; we\n             // don't hash them, but we do compute a hash for them and\n             // save it for others to use.\n             DepNode::MetaData(def_id) if !def_id.is_local() => {\n-                Some(self.metadata_hash(def_id))\n+                Some(self.metadata_hash(def_id,\n+                                        def_id.krate,\n+                                        |this| &mut this.item_metadata_hashes))\n+            }\n+\n+            DepNode::GlobalMetaData(def_id, kind) => {\n+                Some(self.metadata_hash(DepNode::GlobalMetaData(def_id, kind),\n+                                        def_id.krate,\n+                                        |this| &mut this.global_metadata_hashes))\n             }\n \n             _ => {\n@@ -87,33 +113,37 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    fn metadata_hash(&mut self, def_id: DefId) -> Fingerprint {\n-        debug!(\"metadata_hash(def_id={:?})\", def_id);\n+    fn metadata_hash<K, C>(&mut self,\n+                           key: K,\n+                           cnum: CrateNum,\n+                           cache: C)\n+                           -> Fingerprint\n+        where K: Hash + Eq + Debug,\n+              C: Fn(&mut Self) -> &mut FxHashMap<K, Fingerprint>,\n+    {\n+        debug!(\"metadata_hash(key={:?})\", key);\n \n-        assert!(!def_id.is_local());\n+        debug_assert!(cnum != LOCAL_CRATE);\n         loop {\n             // check whether we have a result cached for this def-id\n-            if let Some(&hash) = self.item_metadata_hashes.get(&def_id) {\n-                debug!(\"metadata_hash: def_id={:?} hash={:?}\", def_id, hash);\n+            if let Some(&hash) = cache(self).get(&key) {\n                 return hash;\n             }\n \n             // check whether we did not find detailed metadata for this\n             // krate; in that case, we just use the krate's overall hash\n-            if let Some(&svh) = self.crate_hashes.get(&def_id.krate) {\n-                debug!(\"metadata_hash: def_id={:?} crate_hash={:?}\", def_id, svh);\n-\n+            if let Some(&svh) = self.crate_hashes.get(&cnum) {\n                 // micro-\"optimization\": avoid a cache miss if we ask\n                 // for metadata from this particular def-id again.\n                 let fingerprint = svh_to_fingerprint(svh);\n-                self.item_metadata_hashes.insert(def_id, fingerprint);\n+                cache(self).insert(key, fingerprint);\n \n                 return fingerprint;\n             }\n \n             // otherwise, load the data and repeat.\n-            self.load_data(def_id.krate);\n-            assert!(self.crate_hashes.contains_key(&def_id.krate));\n+            self.load_data(cnum);\n+            assert!(self.crate_hashes.contains_key(&cnum));\n         }\n     }\n \n@@ -191,7 +221,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n \n         let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder)?;\n-        for serialized_hash in serialized_hashes.hashes {\n+        for serialized_hash in serialized_hashes.entry_hashes {\n             // the hashes are stored with just a def-index, which is\n             // always relative to the old crate; convert that to use\n             // our internal crate number\n@@ -202,6 +232,24 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             debug!(\"load_from_data: def_id={:?} hash={}\", def_id, serialized_hash.hash);\n             assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n         }\n+\n+        for (dep_node, fingerprint) in serialized_hashes.global_hashes {\n+            // Here we need to remap the CrateNum in the DepNode.\n+            let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+            let dep_node = match dep_node {\n+                DepNode::GlobalMetaData(_, kind) => DepNode::GlobalMetaData(def_id, kind),\n+                DepNode::FileMap(_, name) => DepNode::FileMap(def_id, name),\n+                other => {\n+                    bug!(\"unexpected DepNode variant: {:?}\", other)\n+                }\n+            };\n+\n+            // record the hash for this dep-node\n+            debug!(\"load_from_data: def_node={:?} hash={}\", dep_node, fingerprint);\n+            let old = self.global_metadata_hashes.insert(dep_node.clone(), fingerprint);\n+            assert!(old.is_none(), \"already have hash for {:?}\", dep_node);\n+        }\n+\n         Ok(())\n     }\n }"}, {"sha": "7fad600d1054294ff769cec9341d5172fa28bf6f", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -240,35 +240,40 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let mut dirty_nodes = FxHashMap();\n \n+    let print_removed_message = |dep_node: &DepNode<_>| {\n+        if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+            println!(\"node {:?} is dirty as it was removed\", dep_node);\n+        }\n+\n+        debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\", dep_node);\n+    };\n+\n     for hash in serialized_hashes {\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n-            let current_hash = hcx.hash(&dep_node).unwrap();\n-            if current_hash == hash.hash {\n-                debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n-                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                   current_hash);\n-                continue;\n-            }\n+            if let Some(current_hash) = hcx.hash(&dep_node) {\n+                if current_hash == hash.hash {\n+                    debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n+                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                       current_hash);\n+                    continue;\n+                }\n \n-            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-                println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n-                         dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                         current_hash,\n-                         hash.hash);\n-            }\n+                if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n+                    println!(\"node {:?} is dirty as hash is {:?} was {:?}\",\n+                             dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                             current_hash,\n+                             hash.hash);\n+                }\n \n-            debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n-                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n-                   current_hash,\n-                   hash.hash);\n-        } else {\n-            if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-                println!(\"node {:?} is dirty as it was removed\",\n-                         hash.dep_node);\n+                debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                       dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                       current_hash,\n+                       hash.hash);\n+            } else {\n+                print_removed_message(&hash.dep_node);\n             }\n-\n-            debug!(\"initial_dirty_nodes: {:?} is dirty as it was removed\",\n-                   hash.dep_node);\n+        } else {\n+            print_removed_message(&hash.dep_node);\n         }\n \n         dirty_nodes.insert(hash.dep_node.clone(), hash.dep_node.clone());\n@@ -382,8 +387,8 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - Mapping DefIds\");\n \n-    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.hashes.len());\n-    for serialized_hash in serialized_hashes.hashes {\n+    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.entry_hashes.len());\n+    for serialized_hash in serialized_hashes.entry_hashes {\n         let def_path_index = serialized_hashes.index_map[&serialized_hash.def_index];\n         if let Some(def_id) = retraced.def_id(def_path_index) {\n             let old = output.insert(def_id, serialized_hash.hash);"}, {"sha": "06e49e9d37c8464c82061bd4fb46198b5b8551ba", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -12,7 +12,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n-use rustc::middle::cstore::EncodedMetadataHash;\n+use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n@@ -34,7 +34,7 @@ use super::work_product;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n-                                metadata_hashes: &[EncodedMetadataHash],\n+                                metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -240,18 +240,19 @@ pub fn encode_dep_graph(preds: &Predecessors,\n \n pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n-                              metadata_hashes: &[EncodedMetadataHash],\n+                              metadata_hashes: &EncodedMetadataHashes,\n                               builder: &mut DefIdDirectoryBuilder,\n                               current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n     let mut serialized_hashes = SerializedMetadataHashes {\n-        hashes: metadata_hashes.to_vec(),\n+        entry_hashes: metadata_hashes.entry_hashes.to_vec(),\n+        global_hashes: metadata_hashes.global_hashes.to_vec(),\n         index_map: FxHashMap()\n     };\n \n     if tcx.sess.opts.debugging_opts.query_dep_graph {\n-        for serialized_hash in &serialized_hashes.hashes {\n+        for serialized_hash in &serialized_hashes.entry_hashes {\n             let def_id = DefId::local(serialized_hash.def_index);\n \n             // Store entry in the index_map"}, {"sha": "6c02ac7eafec32e0dba689f5cba942281a897bf1", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use index_builder::EntryBuilder;\n+use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::hir;\n@@ -31,7 +31,7 @@ impl_stable_hash_for!(struct Ast<'tcx> {\n     rvalue_promotable_to_static\n });\n \n-impl<'a, 'b, 'tcx> EntryBuilder<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n         let body = self.tcx.hir.body(body_id);\n         let lazy_body = self.lazy(body);"}, {"sha": "d2874f16289015afb8095c96111d203aac3745fa", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -12,9 +12,10 @@\n \n use cstore::{self, CStore, CrateSource, MetadataBlob};\n use locator::{self, CratePaths};\n-use schema::CrateRoot;\n+use schema::{CrateRoot, Tracked};\n \n-use rustc::hir::def_id::{CrateNum, DefIndex};\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::hir::def_id::{DefId, CrateNum, DefIndex, CRATE_DEF_INDEX};\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::DepKind;\n use rustc::session::Session;\n@@ -311,7 +312,8 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n-        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n+        let exported_symbols = crate_root.exported_symbols\n+                                         .map(|x| x.decode(&metadata).collect());\n \n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n@@ -333,16 +335,27 @@ impl<'a> CrateLoader<'a> {\n                 rlib: rlib,\n                 rmeta: rmeta,\n             },\n-            dllimport_foreign_items: FxHashSet(),\n+            // Initialize this with an empty set. The field is populated below\n+            // after we were able to deserialize its contents.\n+            dllimport_foreign_items: Tracked::new(FxHashSet()),\n         };\n \n-        let dllimports: Vec<_> = cmeta.get_native_libraries().iter()\n-                            .filter(|lib| relevant_lib(self.sess, lib) &&\n-                                          lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-                            .flat_map(|lib| &lib.foreign_items)\n-                            .map(|id| *id)\n-                            .collect();\n-        cmeta.dllimport_foreign_items.extend(dllimports);\n+        let dllimports: Tracked<FxHashSet<_>> = cmeta\n+            .root\n+            .native_libraries\n+            .map(|native_libraries| {\n+                let native_libraries: Vec<_> = native_libraries.decode(&cmeta)\n+                                                               .collect();\n+                native_libraries\n+                    .iter()\n+                    .filter(|lib| relevant_lib(self.sess, lib) &&\n+                                  lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n+                    .flat_map(|lib| lib.foreign_items.iter())\n+                    .map(|id| *id)\n+                    .collect()\n+            });\n+\n+        cmeta.dllimport_foreign_items = dllimports;\n \n         let cmeta = Rc::new(cmeta);\n         self.cstore.set_crate_data(cnum, cmeta.clone());\n@@ -493,10 +506,16 @@ impl<'a> CrateLoader<'a> {\n             return cstore::CrateNumMap::new();\n         }\n \n+        let dep_node = DepNode::GlobalMetaData(DefId { krate, index: CRATE_DEF_INDEX },\n+                                               GlobalMetaDataKind::CrateDeps);\n+\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        ::std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n+        ::std::iter::once(krate).chain(crate_root.crate_deps\n+                                                 .get(&self.sess.dep_graph, dep_node)\n+                                                 .decode(metadata)\n+                                                 .map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n                 return krate;\n@@ -654,7 +673,9 @@ impl<'a> CrateLoader<'a> {\n \n     /// Look for a plugin registrar. Returns library path, crate\n     /// SVH and DefIndex of the registrar function.\n-    pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n+    pub fn find_plugin_registrar(&mut self,\n+                                 span: Span,\n+                                 name: &str)\n                                  -> Option<(PathBuf, Symbol, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n              name: Symbol::intern(name),\n@@ -740,13 +761,17 @@ impl<'a> CrateLoader<'a> {\n         let mut runtime_found = false;\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n+\n+        let dep_graph = &self.sess.dep_graph;\n+\n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n-            if data.is_panic_runtime() {\n+            needs_panic_runtime = needs_panic_runtime ||\n+                                  data.needs_panic_runtime(dep_graph);\n+            if data.is_panic_runtime(dep_graph) {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime());\n+                                          &|data| data.needs_panic_runtime(dep_graph));\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -782,19 +807,19 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime() {\n+        if !data.is_panic_runtime(dep_graph) {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n-        if data.panic_strategy() != desired_strategy {\n+        if data.panic_strategy(dep_graph) != desired_strategy {\n             self.sess.err(&format!(\"the crate `{}` does not have the panic \\\n                                     strategy `{}`\",\n                                    name, desired_strategy.desc()));\n         }\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime());\n+                                  &|data| data.needs_panic_runtime(dep_graph));\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -862,7 +887,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime() {\n+                if !data.is_sanitizer_runtime(&self.sess.dep_graph) {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -878,12 +903,13 @@ impl<'a> CrateLoader<'a> {\n         // also bail out as we don't need to implicitly inject one.\n         let mut needs_allocator = false;\n         let mut found_required_allocator = false;\n+        let dep_graph = &self.sess.dep_graph;\n         self.cstore.iter_crate_data(|cnum, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator();\n-            if data.is_allocator() {\n+            needs_allocator = needs_allocator || data.needs_allocator(dep_graph);\n+            if data.is_allocator(dep_graph) {\n                 info!(\"{} required by rlib and is an allocator\", data.name());\n                 self.inject_dependency_if(cnum, \"an allocator\",\n-                                          &|data| data.needs_allocator());\n+                                          &|data| data.needs_allocator(dep_graph));\n                 found_required_allocator = found_required_allocator ||\n                     data.dep_kind.get() == DepKind::Explicit;\n             }\n@@ -937,14 +963,14 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the crate we loaded to ensure that it is indeed an\n         // allocator.\n-        if !data.is_allocator() {\n+        if !data.is_allocator(dep_graph) {\n             self.sess.err(&format!(\"the allocator crate `{}` is not tagged \\\n                                     with #![allocator]\", data.name()));\n         }\n \n         self.sess.injected_allocator.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"an allocator\",\n-                                  &|data| data.needs_allocator());\n+                                  &|data| data.needs_allocator(dep_graph));\n     }\n \n     fn inject_dependency_if(&self,"}, {"sha": "8d53e7d49ee81b3d7027a37b7f77b0451a38af8d", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -12,9 +12,9 @@\n // crates and libraries\n \n use locator;\n-use schema;\n+use schema::{self, Tracked};\n \n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n@@ -83,14 +83,14 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: DefPathTable,\n \n-    pub exported_symbols: FxHashSet<DefIndex>,\n+    pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n \n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n \n     pub proc_macros: Option<Vec<(ast::Name, Rc<SyntaxExtension>)>>,\n     // Foreign items imported from a dylib (Windows only)\n-    pub dllimport_foreign_items: FxHashSet<DefIndex>,\n+    pub dllimport_foreign_items: Tracked<FxHashSet<DefIndex>>,\n }\n \n pub struct CStore {\n@@ -269,51 +269,60 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn is_staged_api(&self) -> bool {\n-        for attr in self.get_item_attrs(CRATE_DEF_INDEX).iter() {\n+    pub fn is_staged_api(&self, dep_graph: &DepGraph) -> bool {\n+        for attr in self.get_item_attrs(CRATE_DEF_INDEX, dep_graph).iter() {\n             if attr.path == \"stable\" || attr.path == \"unstable\" {\n                 return true;\n             }\n         }\n         false\n     }\n \n-    pub fn is_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"allocator\")\n     }\n \n-    pub fn needs_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_allocator(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n-    pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_panic_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_compiler_builtins(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_sanitizer_runtime(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_no_builtins(&self, dep_graph: &DepGraph) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, dep_graph);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-    pub fn panic_strategy(&self) -> PanicStrategy {\n-        self.root.panic_strategy.clone()\n+    pub fn panic_strategy(&self, dep_graph: &DepGraph) -> PanicStrategy {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let dep_node = DepNode::GlobalMetaData(def_id, GlobalMetaDataKind::Krate);\n+\n+        self.root\n+            .panic_strategy\n+            .get(dep_graph, dep_node)\n+            .clone()\n     }\n }"}, {"sha": "6fa6a868605dcedc2c42a9275247b15cb9fa1ea0", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n use rustc::hir::map::{DefKey, DefPath, DisambiguatedDefPathData};\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n@@ -147,8 +147,8 @@ impl CrateStore for cstore::CStore {\n \n     fn item_attrs(&self, def_id: DefId) -> Rc<[ast::Attribute]>\n     {\n-        self.dep_graph.read(DepNode::MetaData(def_id));\n-        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n+        self.get_crate_data(def_id.krate)\n+            .get_item_attrs(def_id.index, &self.dep_graph)\n     }\n \n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>\n@@ -168,7 +168,7 @@ impl CrateStore for cstore::CStore {\n         }\n         let mut result = vec![];\n         self.iter_crate_data(|_, cdata| {\n-            cdata.get_implementations_for_trait(filter, &mut result)\n+            cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n         });\n         result\n     }\n@@ -216,70 +216,82 @@ impl CrateStore for cstore::CStore {\n     }\n \n     fn is_exported_symbol(&self, def_id: DefId) -> bool {\n-        self.get_crate_data(def_id.krate).exported_symbols.contains(&def_id.index)\n+        let data = self.get_crate_data(def_id.krate);\n+        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+        data.exported_symbols\n+            .get(&self.dep_graph, dep_node)\n+            .contains(&def_id.index)\n     }\n \n     fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n         if def_id.krate == LOCAL_CRATE {\n             self.dllimport_foreign_items.borrow().contains(&def_id.index)\n         } else {\n-            self.get_crate_data(def_id.krate).is_dllimport_foreign_item(def_id.index)\n+            self.get_crate_data(def_id.krate)\n+                .is_dllimport_foreign_item(def_id.index, &self.dep_graph)\n         }\n     }\n \n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                 -> Vec<(CrateNum, LinkagePreference)>\n     {\n-        self.get_crate_data(cnum).get_dylib_dependency_formats()\n+        self.get_crate_data(cnum).get_dylib_dependency_formats(&self.dep_graph)\n     }\n \n     fn dep_kind(&self, cnum: CrateNum) -> DepKind\n     {\n-        self.get_crate_data(cnum).dep_kind.get()\n+        let data = self.get_crate_data(cnum);\n+        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n+        self.dep_graph.read(dep_node);\n+        data.dep_kind.get()\n     }\n \n     fn export_macros(&self, cnum: CrateNum) {\n-        if self.get_crate_data(cnum).dep_kind.get() == DepKind::UnexportedMacrosOnly {\n-            self.get_crate_data(cnum).dep_kind.set(DepKind::MacrosOnly)\n+        let data = self.get_crate_data(cnum);\n+        let dep_node = data.metadata_dep_node(GlobalMetaDataKind::CrateDeps);\n+\n+        self.dep_graph.read(dep_node);\n+        if data.dep_kind.get() == DepKind::UnexportedMacrosOnly {\n+            data.dep_kind.set(DepKind::MacrosOnly)\n         }\n     }\n \n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>\n     {\n-        self.get_crate_data(cnum).get_lang_items()\n+        self.get_crate_data(cnum).get_lang_items(&self.dep_graph)\n     }\n \n     fn missing_lang_items(&self, cnum: CrateNum)\n                           -> Vec<lang_items::LangItem>\n     {\n-        self.get_crate_data(cnum).get_missing_lang_items()\n+        self.get_crate_data(cnum).get_missing_lang_items(&self.dep_graph)\n     }\n \n     fn is_staged_api(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_staged_api()\n+        self.get_crate_data(cnum).is_staged_api(&self.dep_graph)\n     }\n \n     fn is_allocator(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_allocator()\n+        self.get_crate_data(cnum).is_allocator(&self.dep_graph)\n     }\n \n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool\n     {\n-        self.get_crate_data(cnum).is_panic_runtime()\n+        self.get_crate_data(cnum).is_panic_runtime(&self.dep_graph)\n     }\n \n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_compiler_builtins()\n+        self.get_crate_data(cnum).is_compiler_builtins(&self.dep_graph)\n     }\n \n     fn is_sanitizer_runtime(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_sanitizer_runtime()\n+        self.get_crate_data(cnum).is_sanitizer_runtime(&self.dep_graph)\n     }\n \n     fn panic_strategy(&self, cnum: CrateNum) -> PanicStrategy {\n-        self.get_crate_data(cnum).panic_strategy()\n+        self.get_crate_data(cnum).panic_strategy(&self.dep_graph)\n     }\n \n     fn crate_name(&self, cnum: CrateNum) -> Symbol\n@@ -325,16 +337,16 @@ impl CrateStore for cstore::CStore {\n \n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n     {\n-        self.get_crate_data(cnum).get_native_libraries()\n+        self.get_crate_data(cnum).get_native_libraries(&self.dep_graph)\n     }\n \n     fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>\n     {\n-        self.get_crate_data(cnum).get_exported_symbols()\n+        self.get_crate_data(cnum).get_exported_symbols(&self.dep_graph)\n     }\n \n     fn is_no_builtins(&self, cnum: CrateNum) -> bool {\n-        self.get_crate_data(cnum).is_no_builtins()\n+        self.get_crate_data(cnum).is_no_builtins(&self.dep_graph)\n     }\n \n     fn retrace_path(&self,\n@@ -401,7 +413,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index);\n+        let attrs = data.get_item_attrs(id.index, &self.dep_graph);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }\n@@ -483,7 +495,7 @@ impl CrateStore for cstore::CStore {\n                                  reachable: &NodeSet)\n                                  -> EncodedMetadata\n     {\n-        encoder::encode_metadata(tcx, self, link_meta, reachable)\n+        encoder::encode_metadata(tcx, link_meta, reachable)\n     }\n \n     fn metadata_encoding_version(&self) -> &[u8]"}, {"sha": "820b5a68bcc9b51bb0781e49ecc95ae75d9c7927", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 112, "deletions": 124, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -13,6 +13,7 @@\n use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary};\n use schema::*;\n \n+use rustc::dep_graph::{DepGraph, DepNode, GlobalMetaDataKind};\n use rustc::hir::map::{DefKey, DefPath, DefPathData};\n use rustc::hir;\n \n@@ -404,10 +405,14 @@ impl<'a, 'tcx> MetadataBlob {\n         Lazy::with_position(pos).decode(self)\n     }\n \n-    pub fn list_crate_metadata(&self, out: &mut io::Write) -> io::Result<()> {\n+    pub fn list_crate_metadata(&self,\n+                               out: &mut io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n-        for (i, dep) in root.crate_deps.decode(self).enumerate() {\n+        for (i, dep) in root.crate_deps\n+                            .get_untracked()\n+                            .decode(self)\n+                            .enumerate() {\n             write!(out, \"{} {}-{}\\n\", i + 1, dep.name, dep.hash)?;\n         }\n         write!(out, \"\\n\")?;\n@@ -653,8 +658,13 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n-        self.root.lang_items.decode(self).collect()\n+    pub fn get_lang_items(&self, dep_graph: &DepGraph) -> Vec<(DefIndex, usize)> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItems);\n+        self.root\n+            .lang_items\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n     /// Iterates over each child of the given item.\n@@ -853,13 +863,17 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self,\n+                          node_id: DefIndex,\n+                          dep_graph: &DepGraph) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n             return Rc::new([]);\n         }\n \n+        dep_graph.read(DepNode::MetaData(self.local_def_id(node_id)));\n+\n         if let Some(&Some(ref val)) =\n             self.attribute_cache.borrow()[node_as].get(node_index) {\n             return val.clone();\n@@ -924,7 +938,10 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_implementations_for_trait(&self, filter: Option<DefId>, result: &mut Vec<DefId>) {\n+    pub fn get_implementations_for_trait(&self,\n+                                         filter: Option<DefId>,\n+                                         dep_graph: &DepGraph,\n+                                         result: &mut Vec<DefId>) {\n         // Do a reverse lookup beforehand to avoid touching the crate_num\n         // hash map in the loop below.\n         let filter = match filter.map(|def_id| self.reverse_translate_def_id(def_id)) {\n@@ -935,7 +952,8 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         // FIXME(eddyb) Make this O(1) instead of O(n).\n-        for trait_impls in self.root.impls.decode(self) {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n+        for trait_impls in self.root.impls.get(dep_graph, dep_node).decode(self) {\n             if filter.is_some() && filter != Some(trait_impls.trait_id) {\n                 continue;\n             }\n@@ -958,13 +976,29 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n \n-    pub fn get_native_libraries(&self) -> Vec<NativeLibrary> {\n-        self.root.native_libraries.decode(self).collect()\n+    pub fn get_native_libraries(&self,\n+                                dep_graph: &DepGraph)\n+                                -> Vec<NativeLibrary> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n+        self.root\n+            .native_libraries\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n-    pub fn get_dylib_dependency_formats(&self) -> Vec<(CrateNum, LinkagePreference)> {\n+    pub fn get_dylib_dependency_formats(&self,\n+                                        dep_graph: &DepGraph)\n+                                        -> Vec<(CrateNum, LinkagePreference)> {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n+        let dep_node = DepNode::GlobalMetaData(def_id,\n+                                               GlobalMetaDataKind::DylibDependencyFormats);\n         self.root\n             .dylib_dependency_formats\n+            .get(dep_graph, dep_node)\n             .decode(self)\n             .enumerate()\n             .flat_map(|(i, link)| {\n@@ -974,8 +1008,13 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    pub fn get_missing_lang_items(&self) -> Vec<lang_items::LangItem> {\n-        self.root.lang_items_missing.decode(self).collect()\n+    pub fn get_missing_lang_items(&self, dep_graph: &DepGraph) -> Vec<lang_items::LangItem> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::LangItemsMissing);\n+        self.root\n+            .lang_items_missing\n+            .get(dep_graph, dep_node)\n+            .decode(self)\n+            .collect()\n     }\n \n     pub fn get_fn_arg_names(&self, id: DefIndex) -> Vec<ast::Name> {\n@@ -988,8 +1027,13 @@ impl<'a, 'tcx> CrateMetadata {\n         arg_names.decode(self).collect()\n     }\n \n-    pub fn get_exported_symbols(&self) -> Vec<DefId> {\n-        self.exported_symbols.iter().map(|&index| self.local_def_id(index)).collect()\n+    pub fn get_exported_symbols(&self, dep_graph: &DepGraph) -> Vec<DefId> {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+        self.exported_symbols\n+            .get(dep_graph, dep_node)\n+            .iter()\n+            .map(|&index| self.local_def_id(index))\n+            .collect()\n     }\n \n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n@@ -1018,8 +1062,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn is_dllimport_foreign_item(&self, id: DefIndex) -> bool {\n-        self.dllimport_foreign_items.contains(&id)\n+    pub fn is_dllimport_foreign_item(&self, id: DefIndex, dep_graph: &DepGraph) -> bool {\n+        let dep_node = self.metadata_dep_node(GlobalMetaDataKind::NativeLibraries);\n+        self.dllimport_foreign_items\n+            .get(dep_graph, dep_node)\n+            .contains(&id)\n     }\n \n     pub fn is_default_impl(&self, impl_id: DefIndex) -> bool {\n@@ -1097,121 +1144,62 @@ impl<'a, 'tcx> CrateMetadata {\n         let external_codemap = self.root.codemap.decode(self);\n \n         let imported_filemaps = external_codemap.map(|filemap_to_import| {\n-                // Try to find an existing FileMap that can be reused for the filemap to\n-                // be imported. A FileMap is reusable if it is exactly the same, just\n-                // positioned at a different offset within the codemap.\n-                let reusable_filemap = {\n-                    local_codemap.files\n-                        .borrow()\n-                        .iter()\n-                        .find(|fm| are_equal_modulo_startpos(&fm, &filemap_to_import))\n-                        .map(|rc| rc.clone())\n-                };\n-\n-                match reusable_filemap {\n-                    Some(fm) => {\n-\n-                        debug!(\"CrateMetaData::imported_filemaps reuse \\\n-                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n-                                translated (start_pos {:?} end_pos {:?})\",\n-                               filemap_to_import.name,\n-                               filemap_to_import.start_pos, filemap_to_import.end_pos,\n-                               fm.start_pos, fm.end_pos);\n-\n-                        cstore::ImportedFileMap {\n-                            original_start_pos: filemap_to_import.start_pos,\n-                            original_end_pos: filemap_to_import.end_pos,\n-                            translated_filemap: fm,\n-                        }\n-                    }\n-                    None => {\n-                        // We can't reuse an existing FileMap, so allocate a new one\n-                        // containing the information we need.\n-                        let syntax_pos::FileMap { name,\n-                                                  name_was_remapped,\n-                                                  start_pos,\n-                                                  end_pos,\n-                                                  lines,\n-                                                  multibyte_chars,\n-                                                  .. } = filemap_to_import;\n-\n-                        let source_length = (end_pos - start_pos).to_usize();\n-\n-                        // Translate line-start positions and multibyte character\n-                        // position into frame of reference local to file.\n-                        // `CodeMap::new_imported_filemap()` will then translate those\n-                        // coordinates to their new global frame of reference when the\n-                        // offset of the FileMap is known.\n-                        let mut lines = lines.into_inner();\n-                        for pos in &mut lines {\n-                            *pos = *pos - start_pos;\n-                        }\n-                        let mut multibyte_chars = multibyte_chars.into_inner();\n-                        for mbc in &mut multibyte_chars {\n-                            mbc.pos = mbc.pos - start_pos;\n-                        }\n+            // We can't reuse an existing FileMap, so allocate a new one\n+            // containing the information we need.\n+            let syntax_pos::FileMap { name,\n+                                      name_was_remapped,\n+                                      start_pos,\n+                                      end_pos,\n+                                      lines,\n+                                      multibyte_chars,\n+                                      .. } = filemap_to_import;\n+\n+            let source_length = (end_pos - start_pos).to_usize();\n+\n+            // Translate line-start positions and multibyte character\n+            // position into frame of reference local to file.\n+            // `CodeMap::new_imported_filemap()` will then translate those\n+            // coordinates to their new global frame of reference when the\n+            // offset of the FileMap is known.\n+            let mut lines = lines.into_inner();\n+            for pos in &mut lines {\n+                *pos = *pos - start_pos;\n+            }\n+            let mut multibyte_chars = multibyte_chars.into_inner();\n+            for mbc in &mut multibyte_chars {\n+                mbc.pos = mbc.pos - start_pos;\n+            }\n \n-                        let local_version = local_codemap.new_imported_filemap(name,\n-                                                                               name_was_remapped,\n-                                                                               source_length,\n-                                                                               lines,\n-                                                                               multibyte_chars);\n-                        debug!(\"CrateMetaData::imported_filemaps alloc \\\n-                                filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n-                                translated (start_pos {:?} end_pos {:?})\",\n-                               local_version.name, start_pos, end_pos,\n-                               local_version.start_pos, local_version.end_pos);\n-\n-                        cstore::ImportedFileMap {\n-                            original_start_pos: start_pos,\n-                            original_end_pos: end_pos,\n-                            translated_filemap: local_version,\n-                        }\n-                    }\n-                }\n-            })\n-            .collect();\n+            let local_version = local_codemap.new_imported_filemap(name,\n+                                                                   name_was_remapped,\n+                                                                   self.cnum.as_u32(),\n+                                                                   source_length,\n+                                                                   lines,\n+                                                                   multibyte_chars);\n+            debug!(\"CrateMetaData::imported_filemaps alloc \\\n+                    filemap {:?} original (start_pos {:?} end_pos {:?}) \\\n+                    translated (start_pos {:?} end_pos {:?})\",\n+                   local_version.name, start_pos, end_pos,\n+                   local_version.start_pos, local_version.end_pos);\n+\n+            cstore::ImportedFileMap {\n+                original_start_pos: start_pos,\n+                original_end_pos: end_pos,\n+                translated_filemap: local_version,\n+            }\n+        }).collect();\n \n         // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n         *self.codemap_import_info.borrow_mut() = imported_filemaps;\n         self.codemap_import_info.borrow()\n     }\n-}\n-\n-fn are_equal_modulo_startpos(fm1: &syntax_pos::FileMap, fm2: &syntax_pos::FileMap) -> bool {\n-    if fm1.byte_length() != fm2.byte_length() {\n-        return false;\n-    }\n-\n-    if fm1.name != fm2.name {\n-        return false;\n-    }\n-\n-    let lines1 = fm1.lines.borrow();\n-    let lines2 = fm2.lines.borrow();\n-\n-    if lines1.len() != lines2.len() {\n-        return false;\n-    }\n-\n-    for (&line1, &line2) in lines1.iter().zip(lines2.iter()) {\n-        if (line1 - fm1.start_pos) != (line2 - fm2.start_pos) {\n-            return false;\n-        }\n-    }\n-\n-    let multibytes1 = fm1.multibyte_chars.borrow();\n-    let multibytes2 = fm2.multibyte_chars.borrow();\n \n-    if multibytes1.len() != multibytes2.len() {\n-        return false;\n-    }\n+    pub fn metadata_dep_node(&self, kind: GlobalMetaDataKind) -> DepNode<DefId> {\n+        let def_id = DefId {\n+            krate: self.cnum,\n+            index: CRATE_DEF_INDEX,\n+        };\n \n-    for (mb1, mb2) in multibytes1.iter().zip(multibytes2.iter()) {\n-        if (mb1.bytes != mb2.bytes) || ((mb1.pos - fm1.start_pos) != (mb2.pos - fm2.start_pos)) {\n-            return false;\n-        }\n+        DepNode::GlobalMetaData(def_id, kind)\n     }\n-\n-    true\n }"}, {"sha": "fa4ebed16189c7ab2cb81defdb02eeef3a4068be", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 517, "deletions": 456, "changes": 973, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use cstore;\n use index::Index;\n+use index_builder::{FromId, IndexBuilder, Untracked};\n+use isolated_encoder::IsolatedEncoder;\n use schema::*;\n \n use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n-                            EncodedMetadata, EncodedMetadataHash};\n+                            EncodedMetadata, EncodedMetadataHashes};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId, LOCAL_CRATE};\n use rustc::hir::map::definitions::DefPathTable;\n+use rustc::dep_graph::{DepNode, GlobalMetaDataKind};\n+use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n@@ -26,12 +29,15 @@ use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n \n use rustc_serialize::{Encodable, Encoder, SpecializedEncoder, opaque};\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+\n use std::hash::Hash;\n use std::intrinsics;\n use std::io::prelude::*;\n use std::io::Cursor;\n use std::path::Path;\n use std::rc::Rc;\n+use std::sync::Arc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n@@ -44,20 +50,18 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-use super::index_builder::{FromId, IndexBuilder, Untracked, EntryBuilder};\n-\n pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     link_meta: &'a LinkMeta,\n-    cstore: &'a cstore::CStore,\n     exported_symbols: &'a NodeSet,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n-    pub metadata_hashes: Vec<EncodedMetadataHash>,\n+    pub metadata_hashes: EncodedMetadataHashes,\n+    pub compute_ich: bool,\n }\n \n macro_rules! encoder_methods {\n@@ -134,6 +138,7 @@ impl<'a, 'tcx> SpecializedEncoder<ty::GenericPredicates<'tcx>> for EncodeContext\n }\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+\n     pub fn position(&self) -> usize {\n         self.opaque.position()\n     }\n@@ -237,19 +242,248 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Ok(())\n     }\n+\n+    // Encodes something that corresponds to a single DepNode::GlobalMetaData\n+    // and registers the Fingerprint in the `metadata_hashes` map.\n+    pub fn tracked<'x, DATA, R>(&'x mut self,\n+                                dep_node: DepNode<()>,\n+                                op: fn(&mut IsolatedEncoder<'x, 'a, 'tcx>, DATA) -> R,\n+                                data: DATA)\n+                                -> Tracked<R> {\n+        let mut entry_builder = IsolatedEncoder::new(self);\n+        let ret = op(&mut entry_builder, data);\n+        let (fingerprint, this) = entry_builder.finish();\n+\n+        if let Some(fingerprint) = fingerprint {\n+            this.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n+        }\n+\n+        Tracked::new(ret)\n+    }\n+\n+    fn encode_info_for_items(&mut self) -> Index {\n+        let krate = self.tcx.hir.krate();\n+        let mut index = IndexBuilder::new(self);\n+        index.record(DefId::local(CRATE_DEF_INDEX),\n+                     IsolatedEncoder::encode_info_for_mod,\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+        let mut visitor = EncodeVisitor { index: index };\n+        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        for macro_def in &krate.exported_macros {\n+            visitor.visit_macro_def(macro_def);\n+        }\n+        visitor.index.into_items()\n+    }\n+\n+    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n+        let definitions = self.tcx.hir.definitions();\n+        self.lazy(definitions.def_path_table())\n+    }\n+\n+    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n+        let codemap = self.tcx.sess.codemap();\n+        let all_filemaps = codemap.files();\n+\n+        let hcx = &mut StableHashingContext::new(self.tcx);\n+        let (working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir.clone();\n+\n+        let adapted = all_filemaps.iter()\n+            .filter(|filemap| {\n+                // No need to re-export imported filemaps, as any downstream\n+                // crate will import them from their original source.\n+                !filemap.is_imported()\n+            })\n+            .map(|filemap| {\n+                // When exporting FileMaps, we expand all paths to absolute\n+                // paths because any relative paths are potentially relative to\n+                // a wrong directory.\n+                // However, if a path has been modified via\n+                // `-Zremap-path-prefix` we assume the user has already set\n+                // things up the way they want and don't touch the path values\n+                // anymore.\n+                let name = Path::new(&filemap.name);\n+                if filemap.name_was_remapped ||\n+                   (name.is_relative() && working_dir_was_remapped) {\n+                    // This path of this FileMap has been modified by\n+                    // path-remapping, so we use it verbatim (and avoid cloning\n+                    // the whole map in the process).\n+                    filemap.clone()\n+                } else {\n+                    let mut adapted = (**filemap).clone();\n+                    let abs_path = Path::new(&working_dir).join(name)\n+                                                         .to_string_lossy()\n+                                                         .into_owned();\n+                    adapted.name = abs_path;\n+                    Rc::new(adapted)\n+                }\n+            });\n+\n+        let filemaps: Vec<_> = if self.compute_ich {\n+            adapted.inspect(|filemap| {\n+                let mut hasher = StableHasher::new();\n+                filemap.hash_stable(hcx, &mut hasher);\n+                let fingerprint = hasher.finish();\n+                let dep_node = DepNode::FileMap((), Arc::new(filemap.name.clone()));\n+                self.metadata_hashes.global_hashes.push((dep_node, fingerprint));\n+            }).collect()\n+        } else {\n+            adapted.collect()\n+        };\n+\n+        self.lazy_seq_ref(filemaps.iter().map(|fm| &**fm))\n+    }\n+\n+    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n+        let mut i = self.position();\n+\n+        let crate_deps = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::CrateDeps),\n+            IsolatedEncoder::encode_crate_deps,\n+            ());\n+        let dylib_dependency_formats = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::DylibDependencyFormats),\n+            IsolatedEncoder::encode_dylib_dependency_formats,\n+            ());\n+        let dep_bytes = self.position() - i;\n+\n+        // Encode the language items.\n+        i = self.position();\n+        let lang_items = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItems),\n+            IsolatedEncoder::encode_lang_items,\n+            ());\n+\n+        let lang_items_missing = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::LangItemsMissing),\n+            IsolatedEncoder::encode_lang_items_missing,\n+            ());\n+        let lang_item_bytes = self.position() - i;\n+\n+        // Encode the native libraries used\n+        i = self.position();\n+        let native_libraries = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::NativeLibraries),\n+            IsolatedEncoder::encode_native_libraries,\n+            ());\n+        let native_lib_bytes = self.position() - i;\n+\n+        // Encode codemap\n+        i = self.position();\n+        let codemap = self.encode_codemap();\n+        let codemap_bytes = self.position() - i;\n+\n+        // Encode DefPathTable\n+        i = self.position();\n+        let def_path_table = self.encode_def_path_table();\n+        let def_path_table_bytes = self.position() - i;\n+\n+        // Encode the def IDs of impls, for coherence checking.\n+        i = self.position();\n+        let impls = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::Impls),\n+            IsolatedEncoder::encode_impls,\n+            ());\n+        let impl_bytes = self.position() - i;\n+\n+        // Encode exported symbols info.\n+        i = self.position();\n+        let exported_symbols = self.tracked(\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::ExportedSymbols),\n+            IsolatedEncoder::encode_exported_symbols,\n+            self.exported_symbols);\n+        let exported_symbols_bytes = self.position() - i;\n+\n+        // Encode and index the items.\n+        i = self.position();\n+        let items = self.encode_info_for_items();\n+        let item_bytes = self.position() - i;\n+\n+        i = self.position();\n+        let index = items.write_index(&mut self.opaque.cursor);\n+        let index_bytes = self.position() - i;\n+\n+        let tcx = self.tcx;\n+        let link_meta = self.link_meta;\n+        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n+        let root = self.lazy(&CrateRoot {\n+            name: tcx.crate_name(LOCAL_CRATE),\n+            triple: tcx.sess.opts.target_triple.clone(),\n+            hash: link_meta.crate_hash,\n+            disambiguator: tcx.sess.local_crate_disambiguator(),\n+            panic_strategy: Tracked::new(tcx.sess.panic_strategy()),\n+            plugin_registrar_fn: tcx.sess\n+                .plugin_registrar_fn\n+                .get()\n+                .map(|id| tcx.hir.local_def_id(id).index),\n+            macro_derive_registrar: if is_proc_macro {\n+                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n+                Some(tcx.hir.local_def_id(id).index)\n+            } else {\n+                None\n+            },\n+\n+            crate_deps: crate_deps,\n+            dylib_dependency_formats: dylib_dependency_formats,\n+            lang_items: lang_items,\n+            lang_items_missing: lang_items_missing,\n+            native_libraries: native_libraries,\n+            codemap: codemap,\n+            def_path_table: def_path_table,\n+            impls: impls,\n+            exported_symbols: exported_symbols,\n+            index: index,\n+        });\n+\n+        let total_bytes = self.position();\n+\n+        self.metadata_hashes.global_hashes.push((\n+            DepNode::GlobalMetaData((), GlobalMetaDataKind::Krate),\n+            Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n+        ));\n+\n+        if self.tcx.sess.meta_stats() {\n+            let mut zero_bytes = 0;\n+            for e in self.opaque.cursor.get_ref() {\n+                if *e == 0 {\n+                    zero_bytes += 1;\n+                }\n+            }\n+\n+            println!(\"metadata stats:\");\n+            println!(\"             dep bytes: {}\", dep_bytes);\n+            println!(\"       lang item bytes: {}\", lang_item_bytes);\n+            println!(\"          native bytes: {}\", native_lib_bytes);\n+            println!(\"         codemap bytes: {}\", codemap_bytes);\n+            println!(\"            impl bytes: {}\", impl_bytes);\n+            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n+            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            println!(\"            item bytes: {}\", item_bytes);\n+            println!(\"           index bytes: {}\", index_bytes);\n+            println!(\"            zero bytes: {}\", zero_bytes);\n+            println!(\"           total bytes: {}\", total_bytes);\n+        }\n+\n+        root\n+    }\n }\n \n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n+// These are methods for encoding various things. They are meant to be used with\n+// IndexBuilder::record() and EncodeContext::tracked(). They actually\n+// would not have to be methods of IsolatedEncoder (free standing functions\n+// taking IsolatedEncoder as first argument would be just fine) but by making\n+// them methods we don't have to repeat the lengthy `<'a, 'b: 'a, 'tcx: 'b>`\n+// clause again and again.\n+impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     fn encode_variances_of(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n-        debug!(\"EntryBuilder::encode_variances_of({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_variances_of({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy_seq_from_slice(&tcx.variances_of(def_id))\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n         let ty = tcx.type_of(def_id);\n-        debug!(\"EntryBuilder::encode_item_type({:?}) => {:?}\", def_id, ty);\n+        debug!(\"IsolatedEncoder::encode_item_type({:?}) => {:?}\", def_id, ty);\n         self.lazy(&ty)\n     }\n \n@@ -265,7 +499,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.did;\n-        debug!(\"EntryBuilder::encode_enum_variant_info({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -306,7 +540,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(id);\n-        debug!(\"EntryBuilder::encode_info_for_mod({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.export_map.get(&id) {\n@@ -338,22 +572,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             mir: None\n         }\n     }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_fields(&mut self, adt_def_id: DefId) {\n-        let def = self.tcx.adt_def(adt_def_id);\n-        for (variant_index, variant) in def.variants.iter().enumerate() {\n-            for (field_index, field) in variant.fields.iter().enumerate() {\n-                self.record(field.did,\n-                            EntryBuilder::encode_field,\n-                            (adt_def_id, Untracked((variant_index, field_index))));\n-            }\n-        }\n-    }\n-}\n \n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -370,7 +589,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n-        debug!(\"EntryBuilder::encode_field({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n         let variant_id = tcx.hir.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.hir.expect_variant_data(variant_id);\n@@ -396,7 +615,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_struct_ctor({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let variant = tcx.adt_def(adt_def_id).struct_variant();\n \n@@ -438,19 +657,19 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n-        debug!(\"EntryBuilder::encode_generics({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(tcx.generics_of(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n-        debug!(\"EntryBuilder::encode_predicates({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.predicates_of(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_trait_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -533,7 +752,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_impl_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_impl_item({:?})\", def_id);\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -631,7 +850,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n-        debug!(\"EntryBuilder::encode_inherent_implementations({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_inherent_implementations({:?})\", def_id);\n         let implementations = self.tcx.inherent_impls(def_id);\n         if implementations.is_empty() {\n             LazySeq::empty()\n@@ -644,19 +863,19 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n-        debug!(\"EntryBuilder::encode_stability({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_stability({:?})\", def_id);\n         self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n-        debug!(\"EntryBuilder::encode_deprecation({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_deprecation({:?})\", def_id);\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"EntryBuilder::encode_info_for_item({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n@@ -902,224 +1121,38 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n             mir: None,\n         }\n     }\n-}\n \n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    /// In some cases, along with the item itself, we also\n-    /// encode some sub-items. Usually we want some info from the item\n-    /// so it's easier to do that here then to wait until we would encounter\n-    /// normally in the visitor walk.\n-    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n-        let def_id = self.tcx.hir.local_def_id(item.id);\n-        match item.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemTy(..) => {\n-                // no sub-item recording needed in these cases\n-            }\n-            hir::ItemEnum(..) => {\n-                self.encode_fields(def_id);\n+    fn encode_info_for_ty_param(&mut self,\n+                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n+                                -> Entry<'tcx> {\n+        debug!(\"IsolatedEncoder::encode_info_for_ty_param({:?})\", def_id);\n+        let tcx = self.tcx;\n+        Entry {\n+            kind: EntryKind::Type,\n+            visibility: self.lazy(&ty::Visibility::Public),\n+            span: self.lazy(&tcx.def_span(def_id)),\n+            attributes: LazySeq::empty(),\n+            children: LazySeq::empty(),\n+            stability: None,\n+            deprecation: None,\n \n-                let def = self.tcx.adt_def(def_id);\n-                for (i, variant) in def.variants.iter().enumerate() {\n-                    self.record(variant.did,\n-                                EntryBuilder::encode_enum_variant_info,\n-                                (def_id, Untracked(i)));\n-                }\n-            }\n-            hir::ItemStruct(ref struct_def, _) => {\n-                self.encode_fields(def_id);\n+            ty: if has_default {\n+                Some(self.encode_item_type(def_id))\n+            } else {\n+                None\n+            },\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: None,\n+            predicates: None,\n \n-                // If the struct has a constructor, encode it.\n-                if !struct_def.is_struct() {\n-                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n-                    self.record(ctor_def_id,\n-                                EntryBuilder::encode_struct_ctor,\n-                                (def_id, ctor_def_id));\n-                }\n-            }\n-            hir::ItemUnion(..) => {\n-                self.encode_fields(def_id);\n-            }\n-            hir::ItemImpl(..) => {\n-                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(trait_item_def_id,\n-                                EntryBuilder::encode_info_for_impl_item,\n-                                trait_item_def_id);\n-                }\n-            }\n-            hir::ItemTrait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n-                    self.record(item_def_id,\n-                                EntryBuilder::encode_info_for_trait_item,\n-                                item_def_id);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_foreign_item(&mut self,\n-                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n-                                    -> Entry<'tcx> {\n-        let tcx = self.tcx;\n-\n-        debug!(\"EntryBuilder::encode_info_for_foreign_item({:?})\", def_id);\n-\n-        let kind = match nitem.node {\n-            hir::ForeignItemFn(_, ref names, _) => {\n-                let data = FnData {\n-                    constness: hir::Constness::NotConst,\n-                    arg_names: self.encode_fn_arg_names(names),\n-                };\n-                EntryKind::ForeignFn(self.lazy(&data))\n-            }\n-            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n-        };\n-\n-        Entry {\n-            kind: kind,\n-            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n-            span: self.lazy(&nitem.span),\n-            attributes: self.encode_attributes(&nitem.attrs),\n-            children: LazySeq::empty(),\n-            stability: self.encode_stability(def_id),\n-            deprecation: self.encode_deprecation(def_id),\n-\n-            ty: Some(self.encode_item_type(def_id)),\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: Some(self.encode_generics(def_id)),\n-            predicates: Some(self.encode_predicates(def_id)),\n-\n-            ast: None,\n-            mir: None,\n-        }\n-    }\n-}\n-\n-struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    index: IndexBuilder<'a, 'b, 'tcx>,\n-}\n-\n-impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n-    }\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        intravisit::walk_expr(self, ex);\n-        self.index.encode_info_for_expr(ex);\n-    }\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        intravisit::walk_item(self, item);\n-        let def_id = self.index.tcx.hir.local_def_id(item.id);\n-        match item.node {\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) => (), // ignore these\n-            _ => self.index.record(def_id, EntryBuilder::encode_info_for_item, (def_id, item)),\n-        }\n-        self.index.encode_addl_info_for_item(item);\n-    }\n-    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n-        intravisit::walk_foreign_item(self, ni);\n-        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n-        self.index.record(def_id,\n-                          EntryBuilder::encode_info_for_foreign_item,\n-                          (def_id, ni));\n-    }\n-    fn visit_variant(&mut self,\n-                     v: &'tcx hir::Variant,\n-                     g: &'tcx hir::Generics,\n-                     id: ast::NodeId) {\n-        intravisit::walk_variant(self, v, g, id);\n-\n-        if let Some(discr) = v.node.disr_expr {\n-            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n-            self.index.record(def_id, EntryBuilder::encode_info_for_embedded_const, def_id);\n-        }\n-    }\n-    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n-        intravisit::walk_generics(self, generics);\n-        self.index.encode_info_for_generics(generics);\n-    }\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        intravisit::walk_ty(self, ty);\n-        self.index.encode_info_for_ty(ty);\n-    }\n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n-        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n-        self.index.record(def_id, EntryBuilder::encode_info_for_macro_def, macro_def);\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in &generics.ty_params {\n-            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n-            let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, EntryBuilder::encode_info_for_ty_param, (def_id, has_default));\n-        }\n-    }\n-\n-    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyImplTrait(_) = ty.node {\n-            let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, EntryBuilder::encode_info_for_anon_ty, def_id);\n-        }\n-    }\n-\n-    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n-            hir::ExprClosure(..) => {\n-                let def_id = self.tcx.hir.local_def_id(expr.id);\n-                self.record(def_id, EntryBuilder::encode_info_for_closure, def_id);\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-    fn encode_info_for_ty_param(&mut self,\n-                                (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n-                                -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_ty_param({:?})\", def_id);\n-        let tcx = self.tcx;\n-        Entry {\n-            kind: EntryKind::Type,\n-            visibility: self.lazy(&ty::Visibility::Public),\n-            span: self.lazy(&tcx.def_span(def_id)),\n-            attributes: LazySeq::empty(),\n-            children: LazySeq::empty(),\n-            stability: None,\n-            deprecation: None,\n-\n-            ty: if has_default {\n-                Some(self.encode_item_type(def_id))\n-            } else {\n-                None\n-            },\n-            inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n-            generics: None,\n-            predicates: None,\n-\n-            ast: None,\n-            mir: None,\n+            ast: None,\n+            mir: None,\n         }\n     }\n \n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_anon_ty({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_anon_ty({:?})\", def_id);\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n@@ -1142,7 +1175,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_closure({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let data = ClosureData {\n@@ -1171,7 +1204,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn encode_info_for_embedded_const(&mut self, def_id: DefId) -> Entry<'tcx> {\n-        debug!(\"EntryBuilder::encode_info_for_embedded_const({:?})\", def_id);\n+        debug!(\"IsolatedEncoder::encode_info_for_embedded_const({:?})\", def_id);\n         let tcx = self.tcx;\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         let body = tcx.hir.body_owned_by(id);\n@@ -1198,154 +1231,70 @@ impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n \n     fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n         // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n-        //       we really on the HashStable specialization for [Attribute]\n+        //       we rely on the HashStable specialization for [Attribute]\n         //       to properly filter things out.\n         self.lazy_seq_from_slice(attrs)\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_info_for_items(&mut self) -> Index {\n-        let krate = self.tcx.hir.krate();\n-        let mut index = IndexBuilder::new(self);\n-        index.record(DefId::local(CRATE_DEF_INDEX),\n-                     EntryBuilder::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n-        let mut visitor = EncodeVisitor { index: index };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n-        for macro_def in &krate.exported_macros {\n-            visitor.visit_macro_def(macro_def);\n-        }\n-        visitor.index.into_items()\n+    fn encode_native_libraries(&mut self, _: ()) -> LazySeq<NativeLibrary> {\n+        let used_libraries = self.tcx.sess.cstore.used_libraries();\n+        self.lazy_seq(used_libraries)\n     }\n \n-    fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n-        fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n-            // Pull the cnums and name,vers,hash out of cstore\n-            let mut deps = Vec::new();\n-            cstore.iter_crate_data(|cnum, val| {\n-                deps.push((cnum, val.clone()));\n-            });\n+    fn encode_crate_deps(&mut self, _: ()) -> LazySeq<CrateDep> {\n+        let cstore = &*self.tcx.sess.cstore;\n+        let crates = cstore.crates();\n+\n+        let mut deps = crates\n+            .iter()\n+            .map(|&cnum| {\n+                let dep = CrateDep {\n+                    name: cstore.original_crate_name(cnum),\n+                    hash: cstore.crate_hash(cnum),\n+                    kind: cstore.dep_kind(cnum),\n+                };\n+                (cnum, dep)\n+            })\n+            .collect::<Vec<_>>();\n \n-            // Sort by cnum\n-            deps.sort_by(|kv1, kv2| kv1.0.cmp(&kv2.0));\n+        deps.sort_by_key(|&(cnum, _)| cnum);\n \n+        {\n             // Sanity-check the crate numbers\n             let mut expected_cnum = 1;\n             for &(n, _) in &deps {\n                 assert_eq!(n, CrateNum::new(expected_cnum));\n                 expected_cnum += 1;\n             }\n-\n-            deps\n         }\n \n         // We're just going to write a list of crate 'name-hash-version's, with\n         // the assumption that they are numbered 1 to n.\n         // FIXME (#2166): This is not nearly enough to support correct versioning\n         // but is enough to get transitive crate dependencies working.\n-        let deps = get_ordered_deps(self.cstore);\n-        self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n-            CrateDep {\n-                name: dep.name(),\n-                hash: dep.hash(),\n-                kind: dep.dep_kind.get(),\n-            }\n-        }))\n+        self.lazy_seq_ref(deps.iter().map(|&(_, ref dep)| dep))\n     }\n \n-    fn encode_lang_items(&mut self) -> (LazySeq<(DefIndex, usize)>, LazySeq<lang_items::LangItem>) {\n+    fn encode_lang_items(&mut self, _: ()) -> LazySeq<(DefIndex, usize)> {\n         let tcx = self.tcx;\n         let lang_items = tcx.lang_items.items().iter();\n-        (self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n+        self.lazy_seq(lang_items.enumerate().filter_map(|(i, &opt_def_id)| {\n             if let Some(def_id) = opt_def_id {\n                 if def_id.is_local() {\n                     return Some((def_id.index, i));\n                 }\n             }\n             None\n-        })),\n-         self.lazy_seq_ref(&tcx.lang_items.missing))\n-    }\n-\n-    fn encode_native_libraries(&mut self) -> LazySeq<NativeLibrary> {\n-        let used_libraries = self.tcx.sess.cstore.used_libraries();\n-        self.lazy_seq(used_libraries)\n-    }\n-\n-    fn encode_codemap(&mut self) -> LazySeq<syntax_pos::FileMap> {\n-        let codemap = self.tcx.sess.codemap();\n-        let all_filemaps = codemap.files.borrow();\n-        let adapted = all_filemaps.iter()\n-            .filter(|filemap| {\n-                // No need to re-export imported filemaps, as any downstream\n-                // crate will import them from their original source.\n-                !filemap.is_imported()\n-            })\n-            .map(|filemap| {\n-                // When exporting FileMaps, we expand all paths to absolute\n-                // paths because any relative paths are potentially relative to\n-                // a wrong directory.\n-                // However, if a path has been modified via\n-                // `-Zremap-path-prefix` we assume the user has already set\n-                // things up the way they want and don't touch the path values\n-                // anymore.\n-                let name = Path::new(&filemap.name);\n-                let (ref working_dir, working_dir_was_remapped) = self.tcx.sess.working_dir;\n-                if filemap.name_was_remapped ||\n-                   (name.is_relative() && working_dir_was_remapped) {\n-                    // This path of this FileMap has been modified by\n-                    // path-remapping, so we use it verbatim (and avoid cloning\n-                    // the whole map in the process).\n-                    filemap.clone()\n-                } else {\n-                    let mut adapted = (**filemap).clone();\n-                    let abs_path = Path::new(working_dir).join(name)\n-                                                         .to_string_lossy()\n-                                                         .into_owned();\n-                    adapted.name = abs_path;\n-                    Rc::new(adapted)\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-\n-        self.lazy_seq_ref(adapted.iter().map(|fm| &**fm))\n-    }\n-\n-    fn encode_def_path_table(&mut self) -> Lazy<DefPathTable> {\n-        let definitions = self.tcx.hir.definitions();\n-        self.lazy(definitions.def_path_table())\n-    }\n-}\n-\n-struct ImplVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    impls: FxHashMap<DefId, Vec<DefIndex>>,\n-}\n-\n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(..) = item.node {\n-            let impl_id = self.tcx.hir.local_def_id(item.id);\n-            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n-                self.impls\n-                    .entry(trait_ref.def_id)\n-                    .or_insert(vec![])\n-                    .push(impl_id.index);\n-            }\n-        }\n+        }))\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n-        // handled in `visit_item` above\n+    fn encode_lang_items_missing(&mut self, _: ()) -> LazySeq<lang_items::LangItem> {\n+        let tcx = self.tcx;\n+        self.lazy_seq_ref(&tcx.lang_items.missing)\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     /// Encodes an index, mapping each trait to its (local) implementations.\n-    fn encode_impls(&mut self) -> LazySeq<TraitImpls> {\n+    fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n         let mut visitor = ImplVisitor {\n             tcx: self.tcx,\n             impls: FxHashMap(),\n@@ -1371,13 +1320,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     // middle::reachable module but filters out items that either don't have a\n     // symbol associated with them (they weren't translated) or if they're an FFI\n     // definition (as that's not defined in this crate).\n-    fn encode_exported_symbols(&mut self) -> LazySeq<DefIndex> {\n-        let exported_symbols = self.exported_symbols;\n+    fn encode_exported_symbols(&mut self, exported_symbols: &NodeSet) -> LazySeq<DefIndex> {\n         let tcx = self.tcx;\n         self.lazy_seq(exported_symbols.iter().map(|&id| tcx.hir.local_def_id(id).index))\n     }\n \n-    fn encode_dylib_dependency_formats(&mut self) -> LazySeq<Option<LinkagePreference>> {\n+    fn encode_dylib_dependency_formats(&mut self, _: ()) -> LazySeq<Option<LinkagePreference>> {\n         match self.tcx.sess.dependency_formats.borrow().get(&config::CrateTypeDylib) {\n             Some(arr) => {\n                 self.lazy_seq(arr.iter().map(|slot| {\n@@ -1393,111 +1341,221 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             None => LazySeq::empty(),\n         }\n     }\n-}\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n-    fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n-        let mut i = self.position();\n-        let crate_deps = self.encode_crate_deps();\n-        let dylib_dependency_formats = self.encode_dylib_dependency_formats();\n-        let dep_bytes = self.position() - i;\n+    fn encode_info_for_foreign_item(&mut self,\n+                                    (def_id, nitem): (DefId, &hir::ForeignItem))\n+                                    -> Entry<'tcx> {\n+        let tcx = self.tcx;\n \n-        // Encode the language items.\n-        i = self.position();\n-        let (lang_items, lang_items_missing) = self.encode_lang_items();\n-        let lang_item_bytes = self.position() - i;\n+        debug!(\"IsolatedEncoder::encode_info_for_foreign_item({:?})\", def_id);\n \n-        // Encode the native libraries used\n-        i = self.position();\n-        let native_libraries = self.encode_native_libraries();\n-        let native_lib_bytes = self.position() - i;\n+        let kind = match nitem.node {\n+            hir::ForeignItemFn(_, ref names, _) => {\n+                let data = FnData {\n+                    constness: hir::Constness::NotConst,\n+                    arg_names: self.encode_fn_arg_names(names),\n+                };\n+                EntryKind::ForeignFn(self.lazy(&data))\n+            }\n+            hir::ForeignItemStatic(_, true) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemStatic(_, false) => EntryKind::ForeignImmStatic,\n+        };\n \n-        // Encode codemap\n-        i = self.position();\n-        let codemap = self.encode_codemap();\n-        let codemap_bytes = self.position() - i;\n+        Entry {\n+            kind: kind,\n+            visibility: self.lazy(&ty::Visibility::from_hir(&nitem.vis, nitem.id, tcx)),\n+            span: self.lazy(&nitem.span),\n+            attributes: self.encode_attributes(&nitem.attrs),\n+            children: LazySeq::empty(),\n+            stability: self.encode_stability(def_id),\n+            deprecation: self.encode_deprecation(def_id),\n \n-        // Encode DefPathTable\n-        i = self.position();\n-        let def_path_table = self.encode_def_path_table();\n-        let def_path_table_bytes = self.position() - i;\n+            ty: Some(self.encode_item_type(def_id)),\n+            inherent_impls: LazySeq::empty(),\n+            variances: LazySeq::empty(),\n+            generics: Some(self.encode_generics(def_id)),\n+            predicates: Some(self.encode_predicates(def_id)),\n \n-        // Encode the def IDs of impls, for coherence checking.\n-        i = self.position();\n-        let impls = self.encode_impls();\n-        let impl_bytes = self.position() - i;\n+            ast: None,\n+            mir: None,\n+        }\n+    }\n+}\n \n-        // Encode exported symbols info.\n-        i = self.position();\n-        let exported_symbols = self.encode_exported_symbols();\n-        let exported_symbols_bytes = self.position() - i;\n+struct EncodeVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    index: IndexBuilder<'a, 'b, 'tcx>,\n+}\n \n-        // Encode and index the items.\n-        i = self.position();\n-        let items = self.encode_info_for_items();\n-        let item_bytes = self.position() - i;\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.index.tcx.hir)\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n+        intravisit::walk_expr(self, ex);\n+        self.index.encode_info_for_expr(ex);\n+    }\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        intravisit::walk_item(self, item);\n+        let def_id = self.index.tcx.hir.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(..) => (), // ignore these\n+            _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n+        }\n+        self.index.encode_addl_info_for_item(item);\n+    }\n+    fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n+        intravisit::walk_foreign_item(self, ni);\n+        let def_id = self.index.tcx.hir.local_def_id(ni.id);\n+        self.index.record(def_id,\n+                          IsolatedEncoder::encode_info_for_foreign_item,\n+                          (def_id, ni));\n+    }\n+    fn visit_variant(&mut self,\n+                     v: &'tcx hir::Variant,\n+                     g: &'tcx hir::Generics,\n+                     id: ast::NodeId) {\n+        intravisit::walk_variant(self, v, g, id);\n \n-        i = self.position();\n-        let index = items.write_index(&mut self.opaque.cursor);\n-        let index_bytes = self.position() - i;\n+        if let Some(discr) = v.node.disr_expr {\n+            let def_id = self.index.tcx.hir.body_owner_def_id(discr);\n+            self.index.record(def_id, IsolatedEncoder::encode_info_for_embedded_const, def_id);\n+        }\n+    }\n+    fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n+        intravisit::walk_generics(self, generics);\n+        self.index.encode_info_for_generics(generics);\n+    }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        intravisit::walk_ty(self, ty);\n+        self.index.encode_info_for_ty(ty);\n+    }\n+    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n+        let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n+        self.index.record(def_id, IsolatedEncoder::encode_info_for_macro_def, macro_def);\n+    }\n+}\n \n-        let tcx = self.tcx;\n-        let link_meta = self.link_meta;\n-        let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n-        let root = self.lazy(&CrateRoot {\n-            name: tcx.crate_name(LOCAL_CRATE),\n-            triple: tcx.sess.opts.target_triple.clone(),\n-            hash: link_meta.crate_hash,\n-            disambiguator: tcx.sess.local_crate_disambiguator(),\n-            panic_strategy: tcx.sess.panic_strategy(),\n-            plugin_registrar_fn: tcx.sess\n-                .plugin_registrar_fn\n-                .get()\n-                .map(|id| tcx.hir.local_def_id(id).index),\n-            macro_derive_registrar: if is_proc_macro {\n-                let id = tcx.sess.derive_registrar_fn.get().unwrap();\n-                Some(tcx.hir.local_def_id(id).index)\n-            } else {\n-                None\n-            },\n+impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n+    fn encode_fields(&mut self, adt_def_id: DefId) {\n+        let def = self.tcx.adt_def(adt_def_id);\n+        for (variant_index, variant) in def.variants.iter().enumerate() {\n+            for (field_index, field) in variant.fields.iter().enumerate() {\n+                self.record(field.did,\n+                            IsolatedEncoder::encode_field,\n+                            (adt_def_id, Untracked((variant_index, field_index))));\n+            }\n+        }\n+    }\n \n-            crate_deps: crate_deps,\n-            dylib_dependency_formats: dylib_dependency_formats,\n-            lang_items: lang_items,\n-            lang_items_missing: lang_items_missing,\n-            native_libraries: native_libraries,\n-            codemap: codemap,\n-            def_path_table: def_path_table,\n-            impls: impls,\n-            exported_symbols: exported_symbols,\n-            index: index,\n-        });\n+    fn encode_info_for_generics(&mut self, generics: &hir::Generics) {\n+        for ty_param in &generics.ty_params {\n+            let def_id = self.tcx.hir.local_def_id(ty_param.id);\n+            let has_default = Untracked(ty_param.default.is_some());\n+            self.record(def_id, IsolatedEncoder::encode_info_for_ty_param, (def_id, has_default));\n+        }\n+    }\n \n-        let total_bytes = self.position();\n+    fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n+        if let hir::TyImplTrait(_) = ty.node {\n+            let def_id = self.tcx.hir.local_def_id(ty.id);\n+            self.record(def_id, IsolatedEncoder::encode_info_for_anon_ty, def_id);\n+        }\n+    }\n \n-        if self.tcx.sess.meta_stats() {\n-            let mut zero_bytes = 0;\n-            for e in self.opaque.cursor.get_ref() {\n-                if *e == 0 {\n-                    zero_bytes += 1;\n+    fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n+        match expr.node {\n+            hir::ExprClosure(..) => {\n+                let def_id = self.tcx.hir.local_def_id(expr.id);\n+                self.record(def_id, IsolatedEncoder::encode_info_for_closure, def_id);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    /// In some cases, along with the item itself, we also\n+    /// encode some sub-items. Usually we want some info from the item\n+    /// so it's easier to do that here then to wait until we would encounter\n+    /// normally in the visitor walk.\n+    fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n+        let def_id = self.tcx.hir.local_def_id(item.id);\n+        match item.node {\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) |\n+            hir::ItemFn(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemGlobalAsm(..) |\n+            hir::ItemExternCrate(..) |\n+            hir::ItemUse(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemTy(..) => {\n+                // no sub-item recording needed in these cases\n+            }\n+            hir::ItemEnum(..) => {\n+                self.encode_fields(def_id);\n+\n+                let def = self.tcx.adt_def(def_id);\n+                for (i, variant) in def.variants.iter().enumerate() {\n+                    self.record(variant.did,\n+                                IsolatedEncoder::encode_enum_variant_info,\n+                                (def_id, Untracked(i)));\n                 }\n             }\n+            hir::ItemStruct(ref struct_def, _) => {\n+                self.encode_fields(def_id);\n \n-            println!(\"metadata stats:\");\n-            println!(\"             dep bytes: {}\", dep_bytes);\n-            println!(\"       lang item bytes: {}\", lang_item_bytes);\n-            println!(\"          native bytes: {}\", native_lib_bytes);\n-            println!(\"         codemap bytes: {}\", codemap_bytes);\n-            println!(\"            impl bytes: {}\", impl_bytes);\n-            println!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n-            println!(\"  def-path table bytes: {}\", def_path_table_bytes);\n-            println!(\"            item bytes: {}\", item_bytes);\n-            println!(\"           index bytes: {}\", index_bytes);\n-            println!(\"            zero bytes: {}\", zero_bytes);\n-            println!(\"           total bytes: {}\", total_bytes);\n+                // If the struct has a constructor, encode it.\n+                if !struct_def.is_struct() {\n+                    let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n+                    self.record(ctor_def_id,\n+                                IsolatedEncoder::encode_struct_ctor,\n+                                (def_id, ctor_def_id));\n+                }\n+            }\n+            hir::ItemUnion(..) => {\n+                self.encode_fields(def_id);\n+            }\n+            hir::ItemImpl(..) => {\n+                for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                    self.record(trait_item_def_id,\n+                                IsolatedEncoder::encode_info_for_impl_item,\n+                                trait_item_def_id);\n+                }\n+            }\n+            hir::ItemTrait(..) => {\n+                for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n+                    self.record(item_def_id,\n+                                IsolatedEncoder::encode_info_for_trait_item,\n+                                item_def_id);\n+                }\n+            }\n         }\n+    }\n+}\n \n-        root\n+struct ImplVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impls: FxHashMap<DefId, Vec<DefIndex>>,\n+}\n+\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        if let hir::ItemImpl(..) = item.node {\n+            let impl_id = self.tcx.hir.local_def_id(item.id);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n+                self.impls\n+                    .entry(trait_ref.def_id)\n+                    .or_insert(vec![])\n+                    .push(impl_id.index);\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &'v hir::TraitItem) {}\n+\n+    fn visit_impl_item(&mut self, _impl_item: &'v hir::ImplItem) {\n+        // handled in `visit_item` above\n     }\n }\n \n@@ -1525,28 +1583,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n // generated regardless of trailing bytes that end up in it.\n \n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 cstore: &cstore::CStore,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n                                  -> EncodedMetadata\n {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n-    // Will be filed with the root position after encoding everything.\n+    // Will be filled with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n+     let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n+                        tcx.sess.opts.debugging_opts.incremental_cc) &&\n+                        tcx.sess.opts.build_dep_graph();\n+\n     let (root, metadata_hashes) = {\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx: tcx,\n             link_meta: link_meta,\n-            cstore: cstore,\n             exported_symbols: exported_symbols,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n-            metadata_hashes: Vec::new(),\n+            metadata_hashes: EncodedMetadataHashes::new(),\n+            compute_ich: compute_ich,\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "478202aeba4449db284369d45fa876f3c9d835f8", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 10, "deletions": 112, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -58,20 +58,16 @@\n use encoder::EncodeContext;\n use index::Index;\n use schema::*;\n+use isolated_encoder::IsolatedEncoder;\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ich::{StableHashingContext, Fingerprint};\n use rustc::middle::cstore::EncodedMetadataHash;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n \n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_serialize::Encodable;\n-\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n@@ -119,7 +115,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// content system.\n     pub fn record<'x, DATA>(&'x mut self,\n                             id: DefId,\n-                            op: fn(&mut EntryBuilder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n+                            op: fn(&mut IsolatedEncoder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n                             data: DATA)\n         where DATA: DepGraphRead\n     {\n@@ -132,29 +128,19 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         // unclear whether that would be a win since hashing is cheap enough.\n         let _task = tcx.dep_graph.in_ignore();\n \n-        let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n-                           tcx.sess.opts.debugging_opts.incremental_cc) &&\n-                           tcx.sess.opts.build_dep_graph();\n-\n         let ecx: &'x mut EncodeContext<'b, 'tcx> = &mut *self.ecx;\n-        let mut entry_builder = EntryBuilder {\n-            tcx: tcx,\n-            ecx: ecx,\n-            hcx: if compute_ich {\n-                Some((StableHashingContext::new(tcx), StableHasher::new()))\n-            } else {\n-                None\n-            }\n-        };\n-\n+        let mut entry_builder = IsolatedEncoder::new(ecx);\n         let entry = op(&mut entry_builder, data);\n+        let entry = entry_builder.lazy(&entry);\n \n-        if let Some((ref mut hcx, ref mut hasher)) = entry_builder.hcx {\n-            entry.hash_stable(hcx, hasher);\n+        let (fingerprint, ecx) = entry_builder.finish();\n+        if let Some(hash) = fingerprint {\n+            ecx.metadata_hashes.entry_hashes.push(EncodedMetadataHash {\n+                def_index: id.index,\n+                hash: hash,\n+            });\n         }\n \n-        let entry = entry_builder.ecx.lazy(&entry);\n-        entry_builder.finish(id);\n         self.items.record(id, entry);\n     }\n \n@@ -257,91 +243,3 @@ impl<T> DepGraphRead for FromId<T> {\n         tcx.hir.read(self.0);\n     }\n }\n-\n-pub struct EntryBuilder<'a, 'b: 'a, 'tcx: 'b> {\n-    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n-}\n-\n-impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n-\n-    pub fn finish(self, def_id: DefId) {\n-        if let Some((_, hasher)) = self.hcx {\n-            let hash = hasher.finish();\n-            self.ecx.metadata_hashes.push(EncodedMetadataHash {\n-                def_index: def_id.index,\n-                hash: hash,\n-            });\n-        }\n-    }\n-\n-    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            value.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy(value)\n-    }\n-\n-    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n-        where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            let iter = iter.into_iter();\n-            let (lower_bound, upper_bound) = iter.size_hint();\n-\n-            if upper_bound == Some(lower_bound) {\n-                lower_bound.hash_stable(hcx, hasher);\n-                let mut num_items_hashed = 0;\n-                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n-                    item.hash_stable(hcx, hasher);\n-                    num_items_hashed += 1;\n-                }));\n-\n-                // Sometimes items in a sequence are filtered out without being\n-                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n-                // handle that correctly, so we want to make sure we didn't hit\n-                // it by accident.\n-                if lower_bound != num_items_hashed {\n-                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n-                         num_items_hashed,\n-                         lower_bound);\n-                }\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                ret\n-            } else {\n-                // Collect into a vec so we know the length of the sequence\n-                let items: AccumulateVec<[T; 32]> = iter.collect();\n-                items.hash_stable(hcx, hasher);\n-                debug!(\"metadata-hash: {:?}\", hasher);\n-                self.ecx.lazy_seq(items)\n-            }\n-        } else {\n-            self.ecx.lazy_seq(iter)\n-        }\n-    }\n-\n-    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy_seq_ref(slice.iter())\n-    }\n-\n-    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n-    {\n-        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n-            slice.hash_stable(hcx, hasher);\n-            debug!(\"metadata-hash: {:?}\", hasher);\n-        }\n-        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n-    }\n-}"}, {"sha": "7722a7b10c99658ec817e075ef35e1e922de4d35", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -0,0 +1,160 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use encoder::EncodeContext;\n+use schema::{Lazy, LazySeq};\n+\n+use rustc::ich::{StableHashingContext, Fingerprint};\n+use rustc::ty::TyCtxt;\n+\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use rustc_serialize::Encodable;\n+\n+/// The IsolatedEncoder provides facilities to write to crate metadata while\n+/// making sure that anything going through it is also feed into an ICH hasher.\n+pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n+    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n+}\n+\n+impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n+\n+    pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n+        let tcx = ecx.tcx;\n+        let compute_ich = ecx.compute_ich;\n+        IsolatedEncoder {\n+            tcx: tcx,\n+            ecx: ecx,\n+            hcx: if compute_ich {\n+                Some((StableHashingContext::new(tcx), StableHasher::new()))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn finish(self) -> (Option<Fingerprint>, &'a mut EncodeContext<'b, 'tcx>) {\n+        if let Some((_, hasher)) = self.hcx {\n+            (Some(hasher.finish()), self.ecx)\n+        } else {\n+            (None, self.ecx)\n+        }\n+    }\n+\n+    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            value.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy(value)\n+    }\n+\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            let iter = iter.into_iter();\n+            let (lower_bound, upper_bound) = iter.size_hint();\n+\n+            if upper_bound == Some(lower_bound) {\n+                lower_bound.hash_stable(hcx, hasher);\n+                let mut num_items_hashed = 0;\n+                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n+                    item.hash_stable(hcx, hasher);\n+                    num_items_hashed += 1;\n+                }));\n+\n+                // Sometimes items in a sequence are filtered out without being\n+                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n+                // handle that correctly, so we want to make sure we didn't hit\n+                // it by accident.\n+                if lower_bound != num_items_hashed {\n+                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n+                         num_items_hashed,\n+                         lower_bound);\n+                }\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                ret\n+            } else {\n+                // Collect into a vec so we know the length of the sequence\n+                let items: AccumulateVec<[T; 32]> = iter.collect();\n+                items.hash_stable(hcx, hasher);\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                self.ecx.lazy_seq(items)\n+            }\n+        } else {\n+            self.ecx.lazy_seq(iter)\n+        }\n+    }\n+\n+    pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = &'x T>,\n+              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            let iter = iter.into_iter();\n+            let (lower_bound, upper_bound) = iter.size_hint();\n+\n+            if upper_bound == Some(lower_bound) {\n+                lower_bound.hash_stable(hcx, hasher);\n+                let mut num_items_hashed = 0;\n+                let ret = self.ecx.lazy_seq_ref(iter.inspect(|item| {\n+                    item.hash_stable(hcx, hasher);\n+                    num_items_hashed += 1;\n+                }));\n+\n+                // Sometimes items in a sequence are filtered out without being\n+                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n+                // handle that correctly, so we want to make sure we didn't hit\n+                // it by accident.\n+                if lower_bound != num_items_hashed {\n+                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n+                         num_items_hashed,\n+                         lower_bound);\n+                }\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                ret\n+            } else {\n+                // Collect into a vec so we know the length of the sequence\n+                let items: AccumulateVec<[&'x T; 32]> = iter.collect();\n+                items.hash_stable(hcx, hasher);\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                self.ecx.lazy_seq_ref(items.iter().map(|x| *x))\n+            }\n+        } else {\n+            self.ecx.lazy_seq_ref(iter)\n+        }\n+    }\n+\n+    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter())\n+    }\n+\n+    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n+    }\n+}"}, {"sha": "90eb2bc0f6a7dae31ed100e036ce467b3b6219b0", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -57,6 +57,7 @@ mod index;\n mod encoder;\n mod decoder;\n mod cstore_impl;\n+mod isolated_encoder;\n mod schema;\n \n pub mod creader;"}, {"sha": "5abe1adfb6f359ff9478af0ec7cc5d670cff4757", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -13,7 +13,7 @@ use index;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n-use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::hir::def_id::{DefIndex, DefId, CrateNum};\n use rustc::ich::StableHashingContext;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n@@ -32,6 +32,8 @@ use std::mem;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n                                            StableHasherResult};\n \n+use rustc::dep_graph::{DepGraph, DepNode};\n+\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -186,25 +188,59 @@ pub enum LazyState {\n     Previous(usize),\n }\n \n+/// A `Tracked<T>` wraps a value so that one can only access it when specifying\n+/// the `DepNode` for that value. This makes it harder to forget registering\n+/// reads.\n+#[derive(RustcEncodable, RustcDecodable)]\n+pub struct Tracked<T> {\n+    state: T,\n+}\n+\n+impl<T> Tracked<T> {\n+    pub fn new(state: T) -> Tracked<T> {\n+        Tracked {\n+            state: state,\n+        }\n+    }\n+\n+    pub fn get(&self, dep_graph: &DepGraph, dep_node: DepNode<DefId>) -> &T {\n+        dep_graph.read(dep_node);\n+        &self.state\n+    }\n+\n+    pub fn get_untracked(&self) -> &T {\n+        &self.state\n+    }\n+\n+    pub fn map<F, R>(&self, f: F) -> Tracked<R>\n+        where F: FnOnce(&T) -> R\n+    {\n+        Tracked {\n+            state: f(&self.state),\n+        }\n+    }\n+}\n+\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n     pub disambiguator: Symbol,\n-    pub panic_strategy: PanicStrategy,\n+    pub panic_strategy: Tracked<PanicStrategy>,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n \n-    pub crate_deps: LazySeq<CrateDep>,\n-    pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub lang_items: LazySeq<(DefIndex, usize)>,\n-    pub lang_items_missing: LazySeq<lang_items::LangItem>,\n-    pub native_libraries: LazySeq<NativeLibrary>,\n+    pub crate_deps: Tracked<LazySeq<CrateDep>>,\n+    pub dylib_dependency_formats: Tracked<LazySeq<Option<LinkagePreference>>>,\n+    pub lang_items: Tracked<LazySeq<(DefIndex, usize)>>,\n+    pub lang_items_missing: Tracked<LazySeq<lang_items::LangItem>>,\n+    pub native_libraries: Tracked<LazySeq<NativeLibrary>>,\n     pub codemap: LazySeq<syntax_pos::FileMap>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n-    pub impls: LazySeq<TraitImpls>,\n-    pub exported_symbols: LazySeq<DefIndex>,\n+    pub impls: Tracked<LazySeq<TraitImpls>>,\n+    pub exported_symbols: Tracked<LazySeq<DefIndex>>,\n     pub index: LazySeq<index::Index>,\n }\n \n@@ -215,12 +251,35 @@ pub struct CrateDep {\n     pub kind: DepKind,\n }\n \n+impl_stable_hash_for!(struct CrateDep {\n+    name,\n+    hash,\n+    kind\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitImpls {\n     pub trait_id: (u32, DefIndex),\n     pub impls: LazySeq<DefIndex>,\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for TraitImpls {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let TraitImpls {\n+            trait_id: (krate, def_index),\n+            ref impls,\n+        } = *self;\n+\n+        DefId {\n+            krate: CrateNum::from_u32(krate),\n+            index: def_index\n+        }.hash_stable(hcx, hasher);\n+        impls.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Entry<'tcx> {\n     pub kind: EntryKind<'tcx>,"}, {"sha": "8689e176f7a7b92d8d5d70f1443ea10361acf804", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -754,10 +754,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return (metadata_llcx, metadata_llmod, EncodedMetadata {\n-            raw_data: vec![],\n-            hashes: vec![],\n-        });\n+        return (metadata_llcx, metadata_llmod, EncodedMetadata::new());\n     }\n \n     let cstore = &tcx.sess.cstore;"}, {"sha": "0c8be1d4f24591822ab0686d3851a912b5c8b457", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -21,8 +21,8 @@ pub use syntax_pos::*;\n pub use syntax_pos::hygiene::{ExpnFormat, ExpnInfo, NameAndSpan};\n pub use self::ExpnFormat::*;\n \n-use std::cell::RefCell;\n-use std::path::{Path,PathBuf};\n+use std::cell::{RefCell, Ref};\n+use std::path::{Path, PathBuf};\n use std::rc::Rc;\n \n use std::env;\n@@ -103,11 +103,18 @@ impl FileLoader for RealFileLoader {\n //\n \n pub struct CodeMap {\n-    pub files: RefCell<Vec<Rc<FileMap>>>,\n+    // The `files` field should not be visible outside of libsyntax so that we\n+    // can do proper dependency tracking.\n+    pub(super) files: RefCell<Vec<Rc<FileMap>>>,\n     file_loader: Box<FileLoader>,\n     // This is used to apply the file path remapping as specified via\n     // -Zremap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n+    // The CodeMap will invoke this callback whenever a specific FileMap is\n+    // accessed. The callback starts out as a no-op but when the dependency\n+    // graph becomes available later during the compilation process, it is\n+    // be replaced with something that notifies the dep-tracking system.\n+    dep_tracking_callback: RefCell<Box<Fn(&FileMap)>>,\n }\n \n impl CodeMap {\n@@ -116,6 +123,7 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: Box::new(RealFileLoader),\n             path_mapping: path_mapping,\n+            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n@@ -126,13 +134,18 @@ impl CodeMap {\n             files: RefCell::new(Vec::new()),\n             file_loader: file_loader,\n             path_mapping: path_mapping,\n+            dep_tracking_callback: RefCell::new(Box::new(|_| {})),\n         }\n     }\n \n     pub fn path_mapping(&self) -> &FilePathMapping {\n         &self.path_mapping\n     }\n \n+    pub fn set_dep_tracking_callback(&self, cb: Box<Fn(&FileMap)>) {\n+        *self.dep_tracking_callback.borrow_mut() = cb;\n+    }\n+\n     pub fn file_exists(&self, path: &Path) -> bool {\n         self.file_loader.file_exists(path)\n     }\n@@ -142,6 +155,19 @@ impl CodeMap {\n         Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n     }\n \n+    pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> {\n+        let files = self.files.borrow();\n+        for file in files.iter() {\n+            (self.dep_tracking_callback.borrow())(file);\n+        }\n+        files\n+    }\n+\n+    /// Only use this if you do your own dependency tracking!\n+    pub fn files_untracked(&self) -> Ref<Vec<Rc<FileMap>>> {\n+        self.files.borrow()\n+    }\n+\n     fn next_start_pos(&self) -> usize {\n         let files = self.files.borrow();\n         match files.last() {\n@@ -170,6 +196,7 @@ impl CodeMap {\n         let filemap = Rc::new(FileMap {\n             name: filename,\n             name_was_remapped: was_remapped,\n+            crate_of_origin: 0,\n             src: Some(Rc::new(src)),\n             start_pos: Pos::from_usize(start_pos),\n             end_pos: Pos::from_usize(end_pos),\n@@ -204,6 +231,7 @@ impl CodeMap {\n     pub fn new_imported_filemap(&self,\n                                 filename: FileName,\n                                 name_was_remapped: bool,\n+                                crate_of_origin: u32,\n                                 source_len: usize,\n                                 mut file_local_lines: Vec<BytePos>,\n                                 mut file_local_multibyte_chars: Vec<MultiByteChar>)\n@@ -225,6 +253,7 @@ impl CodeMap {\n         let filemap = Rc::new(FileMap {\n             name: filename,\n             name_was_remapped: name_was_remapped,\n+            crate_of_origin: crate_of_origin,\n             src: None,\n             start_pos: start_pos,\n             end_pos: end_pos,\n@@ -282,6 +311,8 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n \n+        (self.dep_tracking_callback.borrow())(&f);\n+\n         match f.lookup_line(pos) {\n             Some(line) => Ok(FileMapAndLine { fm: f, line: line }),\n             None => Err(f)\n@@ -471,6 +502,7 @@ impl CodeMap {\n     pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n             if filename == fm.name {\n+               (self.dep_tracking_callback.borrow())(&fm);\n                 return Some(fm.clone());\n             }\n         }\n@@ -481,6 +513,7 @@ impl CodeMap {\n     pub fn lookup_byte_offset(&self, bpos: BytePos) -> FileMapAndBytePos {\n         let idx = self.lookup_filemap_idx(bpos);\n         let fm = (*self.files.borrow())[idx].clone();\n+        (self.dep_tracking_callback.borrow())(&fm);\n         let offset = bpos - fm.start_pos;\n         FileMapAndBytePos {fm: fm, pos: offset}\n     }\n@@ -491,6 +524,8 @@ impl CodeMap {\n         let files = self.files.borrow();\n         let map = &(*files)[idx];\n \n+        (self.dep_tracking_callback.borrow())(map);\n+\n         // The number of extra bytes due to multibyte chars in the FileMap\n         let mut total_extra_bytes = 0;\n \n@@ -536,7 +571,7 @@ impl CodeMap {\n     }\n \n     pub fn count_lines(&self) -> usize {\n-        self.files.borrow().iter().fold(0, |a, f| a + f.count_lines())\n+        self.files().iter().fold(0, |a, f| a + f.count_lines())\n     }\n }\n "}, {"sha": "eb86a8e13797b1107a79716342f4c4cecf94b524", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -377,6 +377,8 @@ pub struct FileMap {\n     pub name: FileName,\n     /// True if the `name` field above has been modified by -Zremap-path-prefix\n     pub name_was_remapped: bool,\n+    /// Indicates which crate this FileMap was imported from.\n+    pub crate_of_origin: u32,\n     /// The complete source code\n     pub src: Option<Rc<String>>,\n     /// The start position of this source in the CodeMap\n@@ -491,6 +493,10 @@ impl Decodable for FileMap {\n             Ok(FileMap {\n                 name: name,\n                 name_was_remapped: name_was_remapped,\n+                // `crate_of_origin` has to be set by the importer.\n+                // This value matches up with rustc::hir::def_id::INVALID_CRATE.\n+                // That constant is not available here unfortunately :(\n+                crate_of_origin: ::std::u32::MAX - 1,\n                 start_pos: start_pos,\n                 end_pos: end_pos,\n                 src: None,"}, {"sha": "09db90d618b69ce9af6a0361c241047cc506a7f9", "filename": "src/test/incremental/remapped_paths_cc/auxiliary/extern_crate.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// aux-build:extern_crate.rs\n+//[rpass1] compile-flags: -g\n+//[rpass2] compile-flags: -g\n+//[rpass3] compile-flags: -g -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+#[inline(always)]\n+pub fn inline_fn() {\n+    println!(\"test\");\n+}"}, {"sha": "8a8c658acccbf2d936fe1648d65273b1682ba2ba", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fc547194d22dc673274ac20e9a7b1e607cb862/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=f3fc547194d22dc673274ac20e9a7b1e607cb862", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions:rpass1 rpass2 rpass3\n+// compile-flags: -Z query-dep-graph -g\n+// aux-build:extern_crate.rs\n+\n+\n+// This test case makes sure that we detect if paths emitted into debuginfo\n+// are changed, even when the change happens in an external crate.\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"main-some_mod\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"main\", cfg=\"rpass3\")]\n+#![rustc_partition_translated(module=\"main-some_mod\", cfg=\"rpass3\")]\n+\n+extern crate extern_crate;\n+\n+#[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass3\")]\n+fn main() {\n+    some_mod::some_fn();\n+}\n+\n+mod some_mod {\n+    use extern_crate;\n+\n+    #[rustc_clean(label=\"TransCrateItem\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TransCrateItem\", cfg=\"rpass3\")]\n+    pub fn some_fn() {\n+        extern_crate::inline_fn();\n+    }\n+}"}]}