{"sha": "ed72950fdee7fe53cb52584c249d21fd03b0672e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNzI5NTBmZGVlN2ZlNTNjYjUyNTg0YzI0OWQyMWZkMDNiMDY3MmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-08T03:25:05Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-10T02:21:24Z"}, "message": "rework causal tracking to explore outlives relationships\n\nInstead of tracking the \"cause\" of each bit that gets added, try to\nrecover that by walking outlives relationships. This is currently\nimprecise, since it ignores the \"point\" where the outlives relationship\nis incurred -- but that's ok, since we're about to stop considering that\noverall in a later commit. This does seem to affect one error message\nnegatively, I didn't dig *too* hard to find out why.", "tree": {"sha": "52b41fe841fc8838a6826223e2a4c54b6cd96a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52b41fe841fc8838a6826223e2a4c54b6cd96a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed72950fdee7fe53cb52584c249d21fd03b0672e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed72950fdee7fe53cb52584c249d21fd03b0672e", "html_url": "https://github.com/rust-lang/rust/commit/ed72950fdee7fe53cb52584c249d21fd03b0672e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed72950fdee7fe53cb52584c249d21fd03b0672e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fb17aba6921e80bd5ad20b85b5df5334a6e32b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb17aba6921e80bd5ad20b85b5df5334a6e32b7", "html_url": "https://github.com/rust-lang/rust/commit/1fb17aba6921e80bd5ad20b85b5df5334a6e32b7"}], "stats": {"total": 142, "additions": 42, "deletions": 100}, "files": [{"sha": "265cadb495160bfbf7e614624d20c5a8c99c876f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ed72950fdee7fe53cb52584c249d21fd03b0672e", "patch": "@@ -10,7 +10,7 @@\n \n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use borrow_check::nll::region_infer::{RegionCausalInfo, RegionInferenceContext};\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n@@ -248,7 +248,6 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         nonlexical_regioncx: regioncx,\n         used_mut: FxHashSet(),\n         used_mut_upvars: SmallVec::new(),\n-        nonlexical_cause_info: None,\n         borrow_set,\n         dominators,\n     };\n@@ -367,7 +366,6 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-    nonlexical_cause_info: Option<RegionCausalInfo>,\n \n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,"}, {"sha": "2807a4e8857e0b91421dbf09506b2598f16fb48a", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=ed72950fdee7fe53cb52584c249d21fd03b0672e", "patch": "@@ -32,13 +32,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let regioncx = &&self.nonlexical_regioncx;\n         let mir = self.mir;\n \n-        if self.nonlexical_cause_info.is_none() {\n-            self.nonlexical_cause_info = Some(regioncx.compute_causal_info(mir));\n-        }\n-\n-        let cause_info = self.nonlexical_cause_info.as_ref().unwrap();\n-        if let Some(cause) = cause_info.why_region_contains_point(borrow.region, context.loc) {\n-            match *cause.root_cause() {\n+        let borrow_region_vid = regioncx.to_region_vid(borrow.region);\n+        if let Some(cause) = regioncx.why_region_contains_point(borrow_region_vid, context.loc) {\n+            match cause {\n                 Cause::LiveVar(local, location) => {\n                     match find_regular_use(mir, regioncx, borrow, location, local) {\n                         Some(p) => {"}, {"sha": "d3d3750a98ad64a39d8f84931a5086eebc9d7e9f", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 68, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=ed72950fdee7fe53cb52584c249d21fd03b0672e", "patch": "@@ -101,7 +101,7 @@ struct RegionDefinition<'tcx> {\n /// NB: The variants in `Cause` are intentionally ordered. Lower\n /// values are preferred when it comes to error messages. Do not\n /// reorder willy nilly.\n-#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub(crate) enum Cause {\n     /// point inserted because Local was live at the given Location\n     LiveVar(Local, Location),\n@@ -115,23 +115,6 @@ pub(crate) enum Cause {\n \n     /// part of the initial set of values for a universally quantified region\n     UniversalRegion(RegionVid),\n-\n-    /// Element E was added to R because there was some\n-    /// outlives obligation `R: R1 @ P` and `R1` contained `E`.\n-    Outlives {\n-        /// the reason that R1 had E\n-        original_cause: Rc<Cause>,\n-\n-        /// the point P from the relation\n-        constraint_location: Location,\n-\n-        /// The span indicating why we added the outlives constraint.\n-        constraint_span: Span,\n-    },\n-}\n-\n-pub(crate) struct RegionCausalInfo {\n-    inferred_values: RegionValues,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -477,21 +460,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Re-execute the region inference, this time tracking causal information.\n-    /// This is significantly slower, so it is done only when an error is being reported.\n-    pub(super) fn compute_causal_info(&self, mir: &Mir<'tcx>) -> RegionCausalInfo {\n-        let dfs_storage = &mut self.new_dfs_storage();\n-        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(true));\n-        RegionCausalInfo { inferred_values }\n-    }\n-\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>, dfs_storage: &mut dfs::DfsStorage) {\n         self.dependency_map = Some(self.build_dependency_map());\n-        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(false));\n+        let inferred_values = self.compute_region_values(mir, dfs_storage);\n         self.inferred_values = Some(inferred_values);\n     }\n \n@@ -500,7 +475,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         mir: &Mir<'tcx>,\n         dfs_storage: &mut dfs::DfsStorage,\n-        track_causes: TrackCauses,\n     ) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n@@ -511,7 +485,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The initial values for each region are derived from the liveness\n         // constraints we have accumulated.\n-        let mut inferred_values = self.liveness_constraints.duplicate(track_causes);\n+        let mut inferred_values = self.liveness_constraints.duplicate(TrackCauses(false));\n \n         let dependency_map = self.dependency_map.as_ref().unwrap();\n \n@@ -1095,6 +1069,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         diag.emit();\n     }\n \n+    crate fn why_region_contains_point(&self, fr1: RegionVid, elem: Location) -> Option<Cause> {\n+        // Find some constraint `X: Y` where:\n+        // - `fr1: X` transitively\n+        // - and `Y` is live at `elem`\n+        let index = self.blame_constraint(fr1, elem);\n+        let region_sub = self.constraints[index].sub;\n+\n+        // then return why `Y` was live at `elem`\n+        self.liveness_constraints.cause(region_sub, elem)\n+    }\n+\n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n     fn blame_constraint(&self, fr1: RegionVid, elem: impl ToElementIndex) -> ConstraintIndex {\n@@ -1112,7 +1097,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let relevant_constraint = self.constraints\n             .iter_enumerated()\n             .filter_map(|(i, constraint)| {\n-                if self.liveness_constraints.contains(constraint.sub, elem) {\n+                if !self.liveness_constraints.contains(constraint.sub, elem) {\n                     None\n                 } else {\n                     influenced_fr1[constraint.sup]\n@@ -1163,16 +1148,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n }\n \n-impl RegionCausalInfo {\n-    /// Returns the *reason* that the region `r` contains the given point.\n-    pub(super) fn why_region_contains_point<R>(&self, r: R, p: Location) -> Option<Rc<Cause>>\n-    where\n-        R: ToRegionVid,\n-    {\n-        self.inferred_values.cause(r.to_region_vid(), p)\n-    }\n-}\n-\n impl<'tcx> RegionDefinition<'tcx> {\n     fn new(origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free\n@@ -1316,31 +1291,3 @@ impl<'gcx, 'tcx> ClosureRegionRequirementsExt<'gcx, 'tcx> for ClosureRegionRequi\n         })\n     }\n }\n-\n-trait CauseExt {\n-    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause;\n-}\n-\n-impl CauseExt for Rc<Cause> {\n-    /// Creates a derived cause due to an outlives constraint.\n-    fn outlives(&self, constraint_location: Location, constraint_span: Span) -> Cause {\n-        Cause::Outlives {\n-            original_cause: self.clone(),\n-            constraint_location,\n-            constraint_span,\n-        }\n-    }\n-}\n-\n-impl Cause {\n-    pub(crate) fn root_cause(&self) -> &Cause {\n-        match self {\n-            Cause::LiveVar(..)\n-            | Cause::DropVar(..)\n-            | Cause::LiveOther(..)\n-            | Cause::UniversalRegion(..) => self,\n-\n-            Cause::Outlives { original_cause, .. } => original_cause.root_cause(),\n-        }\n-    }\n-}"}, {"sha": "a25b6ef90188adf8a260a86a2150a0d4569f8986", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=ed72950fdee7fe53cb52584c249d21fd03b0672e", "patch": "@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::region_infer::TrackCauses;\n use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::ty::{self, RegionVid};\n+use rustc::ty::RegionVid;\n use std::fmt::Debug;\n use std::rc::Rc;\n use syntax::codemap::Span;\n \n-use super::{Cause, CauseExt, TrackCauses};\n+use super::Cause;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n@@ -196,7 +197,7 @@ pub(super) struct RegionValues {\n     causes: Option<CauseMap>,\n }\n \n-type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Rc<Cause>>;\n+type CauseMap = FxHashMap<(RegionVid, RegionElementIndex), Cause>;\n \n impl RegionValues {\n     /// Creates a new set of \"region values\" that tracks causal information.\n@@ -255,7 +256,7 @@ impl RegionValues {\n             debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n \n             if let Some(causes) = &mut self.causes {\n-                let cause = Rc::new(make_cause(causes));\n+                let cause = make_cause(causes);\n                 causes.insert((r, i), cause);\n             }\n \n@@ -267,15 +268,8 @@ impl RegionValues {\n                 // #49998: compare using root cause alone to avoid\n                 // useless traffic from similar outlives chains.\n \n-                let overwrite = if ty::tls::with(|tcx| {\n-                    tcx.sess.opts.debugging_opts.nll_subminimal_causes\n-                }) {\n-                    cause.root_cause() < old_cause.root_cause()\n-                } else {\n-                    cause < **old_cause\n-                };\n-                if overwrite {\n-                    *old_cause = Rc::new(cause);\n+                if cause < *old_cause {\n+                    *old_cause = cause;\n                     return true;\n                 }\n             }\n@@ -294,13 +288,11 @@ impl RegionValues {\n         from_region: RegionVid,\n         to_region: RegionVid,\n         elem: T,\n-        constraint_location: Location,\n-        constraint_span: Span,\n+        _constraint_location: Location,\n+        _constraint_span: Span,\n     ) -> bool {\n         let elem = self.elements.index(elem);\n-        self.add_internal(to_region, elem, |causes| {\n-            causes[&(from_region, elem)].outlives(constraint_location, constraint_span)\n-        })\n+        self.add_internal(to_region, elem, |causes| causes[&(from_region, elem)])\n     }\n \n     /// Adds all the universal regions outlived by `from_region` to\n@@ -445,7 +437,7 @@ impl RegionValues {\n     ///\n     /// Returns None if cause tracking is disabled or `elem` is not\n     /// actually found in `r`.\n-    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Rc<Cause>> {\n+    pub(super) fn cause<T: ToElementIndex>(&self, r: RegionVid, elem: T) -> Option<Cause> {\n         let index = self.elements.index(elem);\n         if let Some(causes) = &self.causes {\n             causes.get(&(r, index)).cloned()"}, {"sha": "2284f0784c545d4bbe5223f5837907619a374364", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.nll.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed72950fdee7fe53cb52584c249d21fd03b0672e/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr?ref=ed72950fdee7fe53cb52584c249d21fd03b0672e", "patch": "@@ -2,19 +2,28 @@ error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:20:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:26:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:33:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |             ------------^^^-\n+   |             |           |\n+   |             |           mutable borrow starts here in previous iteration of loop\n+   |             borrow later used here\n \n error: aborting due to 3 previous errors\n "}]}