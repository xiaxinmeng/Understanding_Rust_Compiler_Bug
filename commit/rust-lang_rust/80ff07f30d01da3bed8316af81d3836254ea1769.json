{"sha": "80ff07f30d01da3bed8316af81d3836254ea1769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZmYwN2YzMGQwMWRhM2JlZDgzMTZhZjgxZDM4MzYyNTRlYTE3Njk=", "commit": {"author": {"name": "Jad Ghalayini", "email": "jad.ghalayini@hotmail.com", "date": "2019-06-03T22:26:48Z"}, "committer": {"name": "Jad Ghalayini", "email": "jad.ghalayini@hotmail.com", "date": "2019-06-09T20:05:05Z"}, "message": "Changed usages of `mir` in librustc::mir and librustc_mir to `body`", "tree": {"sha": "27e52a8732cb7b0aeca3ed80c2a658d751c6dbb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27e52a8732cb7b0aeca3ed80c2a658d751c6dbb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ff07f30d01da3bed8316af81d3836254ea1769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ff07f30d01da3bed8316af81d3836254ea1769", "html_url": "https://github.com/rust-lang/rust/commit/80ff07f30d01da3bed8316af81d3836254ea1769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ff07f30d01da3bed8316af81d3836254ea1769/comments", "author": {"login": "imbrem", "id": 44735514, "node_id": "MDQ6VXNlcjQ0NzM1NTE0", "avatar_url": "https://avatars.githubusercontent.com/u/44735514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/imbrem", "html_url": "https://github.com/imbrem", "followers_url": "https://api.github.com/users/imbrem/followers", "following_url": "https://api.github.com/users/imbrem/following{/other_user}", "gists_url": "https://api.github.com/users/imbrem/gists{/gist_id}", "starred_url": "https://api.github.com/users/imbrem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/imbrem/subscriptions", "organizations_url": "https://api.github.com/users/imbrem/orgs", "repos_url": "https://api.github.com/users/imbrem/repos", "events_url": "https://api.github.com/users/imbrem/events{/privacy}", "received_events_url": "https://api.github.com/users/imbrem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "imbrem", "id": 44735514, "node_id": "MDQ6VXNlcjQ0NzM1NTE0", "avatar_url": "https://avatars.githubusercontent.com/u/44735514?v=4", "gravatar_id": "", "url": "https://api.github.com/users/imbrem", "html_url": "https://github.com/imbrem", "followers_url": "https://api.github.com/users/imbrem/followers", "following_url": "https://api.github.com/users/imbrem/following{/other_user}", "gists_url": "https://api.github.com/users/imbrem/gists{/gist_id}", "starred_url": "https://api.github.com/users/imbrem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/imbrem/subscriptions", "organizations_url": "https://api.github.com/users/imbrem/orgs", "repos_url": "https://api.github.com/users/imbrem/repos", "events_url": "https://api.github.com/users/imbrem/events{/privacy}", "received_events_url": "https://api.github.com/users/imbrem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c3967de9027735bfbf9c739f6a8ca14312c22d", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c3967de9027735bfbf9c739f6a8ca14312c22d", "html_url": "https://github.com/rust-lang/rust/commit/07c3967de9027735bfbf9c739f6a8ca14312c22d"}], "stats": {"total": 2642, "additions": 1323, "deletions": 1319}, "files": [{"sha": "d2cabb7e10bbff251713eb96a713874f2d222d67", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -47,19 +47,19 @@ impl Cache {\n \n     pub fn predecessors(\n         &self,\n-        mir: &Body<'_>\n+        body: &Body<'_>\n     ) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         if self.predecessors.borrow().is_none() {\n-            *self.predecessors.borrow_mut() = Some(calculate_predecessors(mir));\n+            *self.predecessors.borrow_mut() = Some(calculate_predecessors(body));\n         }\n \n         ReadGuard::map(self.predecessors.borrow(), |p| p.as_ref().unwrap())\n     }\n }\n \n-fn calculate_predecessors(mir: &Body<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n-    let mut result = IndexVec::from_elem(vec![], mir.basic_blocks());\n-    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+fn calculate_predecessors(body: &Body<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n+    let mut result = IndexVec::from_elem(vec![], body.basic_blocks());\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n         if let Some(ref term) = data.terminator {\n             for &tgt in term.successors() {\n                 result[tgt].push(bb);"}, {"sha": "74beb1b1bc7de38435bd3648a2596bde2ab53d8f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -2916,21 +2916,21 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, mir: &Body<'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, body: &Body<'tcx>) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n             return true;\n         }\n \n         // If we're in another block, then we want to check that block is a predecessor of `other`.\n-        let mut queue: Vec<BasicBlock> = mir.predecessors_for(other.block).clone();\n+        let mut queue: Vec<BasicBlock> = body.predecessors_for(other.block).clone();\n         let mut visited = FxHashSet::default();\n \n         while let Some(block) = queue.pop() {\n             // If we haven't visited this block before, then make sure we visit it's predecessors.\n             if visited.insert(block) {\n-                queue.append(&mut mir.predecessors_for(block).clone());\n+                queue.append(&mut body.predecessors_for(block).clone());\n             } else {\n                 continue;\n             }"}, {"sha": "77af0e6661b732ea0f50032d90a96d939290ebff", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -21,27 +21,27 @@ use super::*;\n /// A preorder traversal of this graph is either `A B D C` or `A C D B`\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Preorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n+    pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n         let worklist = vec![root];\n \n         Preorder {\n-            mir,\n-            visited: BitSet::new_empty(mir.basic_blocks().len()),\n+            body,\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n             worklist,\n             root_is_start_block: root == START_BLOCK,\n         }\n     }\n }\n \n-pub fn preorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> Preorder<'a, 'tcx> {\n-    Preorder::new(mir, START_BLOCK)\n+pub fn preorder<'a, 'tcx>(body: &'a Body<'tcx>) -> Preorder<'a, 'tcx> {\n+    Preorder::new(body, START_BLOCK)\n }\n \n impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n@@ -53,7 +53,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n                 continue;\n             }\n \n-            let data = &self.mir[idx];\n+            let data = &self.body[idx];\n \n             if let Some(ref term) = data.terminator {\n                 self.worklist.extend(term.successors());\n@@ -67,7 +67,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         // All the blocks, minus the number of blocks we've visited.\n-        let upper = self.mir.basic_blocks().len() - self.visited.count();\n+        let upper = self.body.basic_blocks().len() - self.visited.count();\n \n         let lower = if self.root_is_start_block {\n             // We will visit all remaining blocks exactly once.\n@@ -99,23 +99,23 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+    pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n-            mir,\n-            visited: BitSet::new_empty(mir.basic_blocks().len()),\n+            body,\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n             visit_stack: Vec::new(),\n             root_is_start_block: root == START_BLOCK,\n         };\n \n \n-        let data = &po.mir[root];\n+        let data = &po.body[root];\n \n         if let Some(ref term) = data.terminator {\n             po.visited.insert(root);\n@@ -186,16 +186,16 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n             };\n \n             if self.visited.insert(bb) {\n-                if let Some(term) = &self.mir[bb].terminator {\n+                if let Some(term) = &self.body[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));\n                 }\n             }\n         }\n     }\n }\n \n-pub fn postorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> Postorder<'a, 'tcx> {\n-    Postorder::new(mir, START_BLOCK)\n+pub fn postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> Postorder<'a, 'tcx> {\n+    Postorder::new(body, START_BLOCK)\n }\n \n impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n@@ -207,12 +207,12 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n             self.traverse_successor();\n         }\n \n-        next.map(|(bb, _)| (bb, &self.mir[bb]))\n+        next.map(|(bb, _)| (bb, &self.body[bb]))\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         // All the blocks, minus the number of blocks we've visited.\n-        let upper = self.mir.basic_blocks().len() - self.visited.count();\n+        let upper = self.body.basic_blocks().len() - self.visited.count();\n \n         let lower = if self.root_is_start_block {\n             // We will visit all remaining blocks exactly once.\n@@ -252,19 +252,19 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n /// to re-use the traversal\n #[derive(Clone)]\n pub struct ReversePostorder<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     blocks: Vec<BasicBlock>,\n     idx: usize\n }\n \n impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n-        let blocks : Vec<_> = Postorder::new(mir, root).map(|(bb, _)| bb).collect();\n+    pub fn new(body: &'a Body<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n+        let blocks : Vec<_> = Postorder::new(body, root).map(|(bb, _)| bb).collect();\n \n         let len = blocks.len();\n \n         ReversePostorder {\n-            mir,\n+            body,\n             blocks,\n             idx: len\n         }\n@@ -276,8 +276,8 @@ impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n }\n \n \n-pub fn reverse_postorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> ReversePostorder<'a, 'tcx> {\n-    ReversePostorder::new(mir, START_BLOCK)\n+pub fn reverse_postorder<'a, 'tcx>(body: &'a Body<'tcx>) -> ReversePostorder<'a, 'tcx> {\n+    ReversePostorder::new(body, START_BLOCK)\n }\n \n impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> Iterator for ReversePostorder<'a, 'tcx> {\n         if self.idx == 0 { return None; }\n         self.idx -= 1;\n \n-        self.blocks.get(self.idx).map(|&bb| (bb, &self.mir[bb]))\n+        self.blocks.get(self.idx).map(|&bb| (bb, &self.body[bb]))\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {"}, {"sha": "b4acc076f3e4e038949c5d6bafa18653de1faf50", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -71,8 +71,8 @@ macro_rules! make_mir_visitor {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_body(&mut self, mir: & $($mutability)? Body<'tcx>) {\n-                self.super_body(mir);\n+            fn visit_body(&mut self, body: & $($mutability)? Body<'tcx>) {\n+                self.super_body(body);\n             }\n \n             fn visit_basic_block_data(&mut self,\n@@ -253,41 +253,41 @@ macro_rules! make_mir_visitor {\n             // not meant to be overridden.\n \n             fn super_body(&mut self,\n-                         mir: & $($mutability)? Body<'tcx>) {\n-                if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n+                         body: & $($mutability)? Body<'tcx>) {\n+                if let Some(yield_ty) = &$($mutability)? body.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n-                        span: mir.span,\n+                        span: body.span,\n                         scope: OUTERMOST_SOURCE_SCOPE,\n                     }));\n                 }\n \n                 // for best performance, we want to use an iterator rather\n-                // than a for-loop, to avoid calling `mir::Body::invalidate` for\n+                // than a for-loop, to avoid calling `body::Body::invalidate` for\n                 // each basic block.\n                 macro_rules! basic_blocks {\n-                    (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n-                    () => (mir.basic_blocks().iter_enumerated());\n+                    (mut) => (body.basic_blocks_mut().iter_enumerated_mut());\n+                    () => (body.basic_blocks().iter_enumerated());\n                 };\n                 for (bb, data) in basic_blocks!($($mutability)?) {\n                     self.visit_basic_block_data(bb, data);\n                 }\n \n-                for scope in &$($mutability)? mir.source_scopes {\n+                for scope in &$($mutability)? body.source_scopes {\n                     self.visit_source_scope_data(scope);\n                 }\n \n-                self.visit_ty(&$($mutability)? mir.return_ty(), TyContext::ReturnTy(SourceInfo {\n-                    span: mir.span,\n+                self.visit_ty(&$($mutability)? body.return_ty(), TyContext::ReturnTy(SourceInfo {\n+                    span: body.span,\n                     scope: OUTERMOST_SOURCE_SCOPE,\n                 }));\n \n-                for local in mir.local_decls.indices() {\n-                    self.visit_local_decl(local, & $($mutability)? mir.local_decls[local]);\n+                for local in body.local_decls.indices() {\n+                    self.visit_local_decl(local, & $($mutability)? body.local_decls[local]);\n                 }\n \n                 macro_rules! type_annotations {\n-                    (mut) => (mir.user_type_annotations.iter_enumerated_mut());\n-                    () => (mir.user_type_annotations.iter_enumerated());\n+                    (mut) => (body.user_type_annotations.iter_enumerated_mut());\n+                    () => (body.user_type_annotations.iter_enumerated());\n                 };\n \n                 for (index, annotation) in type_annotations!($($mutability)?) {\n@@ -296,7 +296,7 @@ macro_rules! make_mir_visitor {\n                     );\n                 }\n \n-                self.visit_span(&$($mutability)? mir.span);\n+                self.visit_span(&$($mutability)? body.span);\n             }\n \n             fn super_basic_block_data(&mut self,\n@@ -834,8 +834,8 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)? Body<'tcx>, location: Location) {\n-                let basic_block = & $($mutability)? mir[location.block];\n+            fn visit_location(&mut self, body: & $($mutability)? Body<'tcx>, location: Location) {\n+                let basic_block = & $($mutability)? body[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {\n                         self.visit_terminator(terminator, location)"}, {"sha": "0fc72b83a1668cf05c31f989b0ac8c09ecc8bb32", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -106,8 +106,8 @@ impl LocalsStateAtExit {\n         if locals_are_invalidated_at_exit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n-            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(mir.local_decls.len()));\n-            has_storage_dead.visit_body(mir);\n+            let mut has_storage_dead = HasStorageDead(BitSet::new_empty(body.local_decls.len()));\n+            has_storage_dead.visit_body(body);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {\n                 if let Some(index) = move_data.base_local(move_out.path) {\n@@ -123,24 +123,24 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n \n         let mut visitor = GatherBorrows {\n             tcx,\n-            mir,\n+            body,\n             idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n             local_map: Default::default(),\n             pending_activations: Default::default(),\n             locals_state_at_exit:\n-                LocalsStateAtExit::build(locals_are_invalidated_at_exit, mir, move_data),\n+                LocalsStateAtExit::build(locals_are_invalidated_at_exit, body, move_data),\n         };\n \n-        for (block, block_data) in traversal::preorder(mir) {\n+        for (block, block_data) in traversal::preorder(body) {\n             visitor.visit_basic_block_data(block, block_data);\n         }\n \n@@ -163,7 +163,7 @@ impl<'tcx> BorrowSet<'tcx> {\n \n struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -191,7 +191,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n     ) {\n         if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n             if borrowed_place.ignore_borrow(\n-                self.tcx, self.mir, &self.locals_state_at_exit) {\n+                self.tcx, self.body, &self.locals_state_at_exit) {\n                 return;\n             }\n \n@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n             if let TwoPhaseActivation::ActivatedAt(other_location) =\n                     borrow_data.activation_location {\n                 span_bug!(\n-                    self.mir.source_info(location).span,\n+                    self.body.source_info(location).span,\n                     \"found two uses for 2-phase borrow temporary {:?}: \\\n                      {:?} and {:?}\",\n                     temp,\n@@ -320,7 +320,7 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n             temp\n         } else {\n             span_bug!(\n-                self.mir.source_info(start_location).span,\n+                self.body.source_info(start_location).span,\n                 \"expected 2-phase borrow to assign to a local, not `{:?}`\",\n                 assigned_place,\n             );\n@@ -339,7 +339,7 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n         // assignment.\n         let old_value = self.pending_activations.insert(temp, borrow_index);\n         if let Some(old_index) = old_value {\n-            span_bug!(self.mir.source_info(start_location).span,\n+            span_bug!(self.body.source_info(start_location).span,\n                       \"found already pending activation for temp: {:?} \\\n                        at borrow_index: {:?} with associated data {:?}\",\n                       temp, old_index, self.idx_vec[old_index]);"}, {"sha": "359e3be860df0adf9b38484cb08abde0d2f4eae3", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -202,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let ty = used_place.ty(self.mir, self.infcx.tcx).ty;\n+            let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.sty {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -217,7 +217,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mpi = self.move_data.moves[move_out_indices[0]].path;\n                 let place = &self.move_data.move_paths[mpi].place;\n \n-                let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+                let ty = place.ty(self.body, self.infcx.tcx).ty;\n                 let opt_name = self.describe_place_with_options(place, IncludingDowncast(true));\n                 let note_msg = match opt_name {\n                     Some(ref name) => format!(\"`{}`\", name),\n@@ -235,7 +235,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n                 let span = if let Place::Base(PlaceBase::Local(local)) = place {\n-                    let decl = &self.mir.local_decls[*local];\n+                    let decl = &self.body.local_decls[*local];\n                     Some(decl.source_info.span)\n                 } else {\n                     None\n@@ -305,7 +305,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             location,\n             borrow,\n             None,\n-        ).add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", Some(borrow_span));\n+        ).add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", Some(borrow_span));\n         err.buffer(&mut self.errors_buffer);\n     }\n \n@@ -342,7 +342,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         });\n \n         self.explain_why_borrow_contains_point(location, borrow, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+            .add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n         err\n     }\n \n@@ -552,7 +552,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         explanation.add_explanation_to_diagnostic(\n             self.infcx.tcx,\n-            self.mir,\n+            self.body,\n             &mut err,\n             first_borrow_desc,\n             None,\n@@ -592,7 +592,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n         let union_ty = |place: &Place<'tcx>| -> Option<Ty<'tcx>> {\n-            let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+            let ty = place.ty(self.body, self.infcx.tcx).ty;\n             ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n         let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n@@ -687,7 +687,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         let proper_span = match *root_place {\n-            Place::Base(PlaceBase::Local(local)) => self.mir.local_decls[local].source_info.span,\n+            Place::Base(PlaceBase::Local(local)) => self.body.local_decls[local].source_info.span,\n             _ => drop_span,\n         };\n \n@@ -876,7 +876,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             } else {\n                 explanation.add_explanation_to_diagnostic(\n                     self.infcx.tcx,\n-                    self.mir,\n+                    self.body,\n                     &mut err,\n                     \"\",\n                     None,\n@@ -900,7 +900,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 format!(\"value captured here{}\", within),\n             );\n \n-            explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+            explanation.add_explanation_to_diagnostic(\n+                self.infcx.tcx, self.body, &mut err, \"\", None);\n         }\n \n         err\n@@ -960,7 +961,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1043,7 +1044,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             _ => {}\n         }\n-        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+        explanation.add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n \n         let within = if borrow_spans.for_generator() {\n             \" by generator\"\n@@ -1076,7 +1077,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         };\n \n         // FIXME use a better heuristic than Spans\n-        let reference_desc = if return_span == self.mir.source_info(borrow.reserve_location).span {\n+        let reference_desc = if return_span == self.body.source_info(borrow.reserve_location).span {\n             \"reference to\"\n         } else {\n             \"value referencing\"\n@@ -1085,7 +1086,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = match borrow.borrowed_place {\n                 Place::Base(PlaceBase::Local(local)) => {\n-                    match self.mir.local_kind(local) {\n+                    match self.body.local_kind(local) {\n                         LocalKind::ReturnPointer\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n                         LocalKind::Var => \"local variable \",\n@@ -1114,7 +1115,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             } else {\n                 bug!(\"try_report_cannot_return_reference_to_local: not a local\")\n             };\n-            match self.mir.local_kind(local) {\n+            match self.body.local_kind(local) {\n                 LocalKind::ReturnPointer | LocalKind::Temp => {\n                     (\n                         \"temporary value\".to_string(),\n@@ -1251,10 +1252,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     }\n \n     fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n-        let mir = self.mir;\n+        let body = self.body;\n \n         let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+        stack.extend(body.predecessor_locations(location).map(|predecessor| {\n             let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n@@ -1273,7 +1274,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n \n             // check for moves\n-            let stmt_kind = mir[location.block]\n+            let stmt_kind = body[location.block]\n                 .statements\n                 .get(location.statement_index)\n                 .map(|s| &s.kind);\n@@ -1328,7 +1329,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let mut any_match = false;\n             drop_flag_effects::for_location_inits(\n                 self.infcx.tcx,\n-                self.mir,\n+                self.body,\n                 self.move_data,\n                 location,\n                 |m| {\n@@ -1341,7 +1342,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 continue 'dfs;\n             }\n \n-            stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+            stack.extend(body.predecessor_locations(location).map(|predecessor| {\n                 let back_edge = location.dominates(predecessor, &self.dominators);\n                 (predecessor, is_back_edge || back_edge)\n             }));\n@@ -1391,7 +1392,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(location, loan, None)\n-            .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n+            .add_explanation_to_diagnostic(self.infcx.tcx, self.body, &mut err, \"\", None);\n \n         err.buffer(&mut self.errors_buffer);\n     }\n@@ -1410,10 +1411,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err_place: &Place<'tcx>,\n     ) {\n         let (from_arg, local_decl) = if let Place::Base(PlaceBase::Local(local)) = *err_place {\n-            if let LocalKind::Arg = self.mir.local_kind(local) {\n-                (true, Some(&self.mir.local_decls[local]))\n+            if let LocalKind::Arg = self.body.local_kind(local) {\n+                (true, Some(&self.body.local_decls[local]))\n             } else {\n-                (false, Some(&self.mir.local_decls[local]))\n+                (false, Some(&self.body.local_decls[local]))\n             }\n         } else {\n             (false, None)\n@@ -1493,15 +1494,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                base.ty(self.mir, tcx).ty.is_box(),\n+                                base.ty(self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = base.ty(self.mir, tcx).ty;\n+                        let base_ty = base.ty(self.body, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1560,7 +1561,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             location\n         );\n         if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n-             = &self.mir[location.block].statements.get(location.statement_index)\n+             = &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: reservation={:?}\",\n@@ -1569,14 +1570,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // Check that the initial assignment of the reserve location is into a temporary.\n             let mut target = *match reservation {\n                 Place::Base(PlaceBase::Local(local))\n-                    if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                    if self.body.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n             // Next, look through the rest of the block, checking if we are assigning the\n             // `target` (that is, the place that contains our borrow) to anything.\n             let mut annotated_closure = None;\n-            for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n                 debug!(\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n@@ -1701,7 +1702,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n \n             // Check the terminator if we didn't find anything in the statements.\n-            let terminator = &self.mir[location.block].terminator();\n+            let terminator = &self.body[location.block].terminator();\n             debug!(\n                 \"annotate_argument_and_return_for_borrow: target={:?} terminator={:?}\",\n                 target, terminator"}, {"sha": "a124c78ab67961ff96c30323b36705c64f7308d7", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -38,7 +38,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"add_moved_or_invoked_closure_note: location={:?} place={:?}\", location, place);\n         let mut target = place.local_or_deref_local();\n-        for stmt in &self.mir[location.block].statements[location.statement_index..] {\n+        for stmt in &self.body[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n             if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n@@ -52,7 +52,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // Check if we are attempting to call a closure after it has been invoked.\n-        let terminator = self.mir[location.block].terminator();\n+        let terminator = self.body[location.block].terminator();\n         debug!(\"add_moved_or_invoked_closure_note: terminator={:?}\", terminator);\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n@@ -75,7 +75,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::Closure(did, _) = self.mir.local_decls[closure].ty.sty {\n+                if let ty::Closure(did, _) = self.body.local_decls[closure].ty.sty {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -98,7 +98,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::Closure(did, _) = self.mir.local_decls[target].ty.sty {\n+            if let ty::Closure(did, _) = self.body.local_decls[target].ty.sty {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -180,7 +180,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     &including_downcast,\n                                 )?;\n                             } else if let Place::Base(PlaceBase::Local(local)) = proj.base {\n-                                if self.mir.local_decls[local].is_ref_for_guard() {\n+                                if self.body.local_decls[local].is_ref_for_guard() {\n                                     self.append_place_to_string(\n                                         &proj.base,\n                                         buf,\n@@ -276,7 +276,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Appends end-user visible description of the `local` place to `buf`. If `local` doesn't have\n     /// a name, or its name was generated by the compiler, then `Err` is returned\n     fn append_local_to_string(&self, local_index: Local, buf: &mut String) -> Result<(), ()> {\n-        let local = &self.mir.local_decls[local_index];\n+        let local = &self.body.local_decls[local_index];\n         match local.name {\n             Some(name) if !local.from_compiler_desugaring() => {\n                 buf.push_str(name.as_str().get());\n@@ -290,15 +290,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn describe_field(&self, base: &Place<'tcx>, field: Field) -> String {\n         match *base {\n             Place::Base(PlaceBase::Local(local)) => {\n-                let local = &self.mir.local_decls[local];\n+                let local = &self.body.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             Place::Base(PlaceBase::Static(ref static_)) =>\n                 self.describe_field_from_ty(&static_.ty, field, None),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n                 ProjectionElem::Downcast(_, variant_index) => {\n-                    let base_ty = base.ty(self.mir, self.infcx.tcx).ty;\n+                    let base_ty = base.ty(self.body, self.infcx.tcx).ty;\n                     self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n@@ -556,9 +556,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> UseSpans {\n         use self::UseSpans::*;\n \n-        let stmt = match self.mir[location.block].statements.get(location.statement_index) {\n+        let stmt = match self.body[location.block].statements.get(location.statement_index) {\n             Some(stmt) => stmt,\n-            None => return OtherUse(self.mir.source_info(location).span),\n+            None => return OtherUse(self.body.source_info(location).span),\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n@@ -596,7 +596,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         use self::UseSpans::*;\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n-        let target = match self.mir[location.block]\n+        let target = match self.body[location.block]\n             .statements\n             .get(location.statement_index)\n         {\n@@ -607,12 +607,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             _ => return OtherUse(use_span),\n         };\n \n-        if self.mir.local_kind(target) != LocalKind::Temp {\n+        if self.body.local_kind(target) != LocalKind::Temp {\n             // operands are always temporaries.\n             return OtherUse(use_span);\n         }\n \n-        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+        for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n             if let StatementKind::Assign(\n                 _, box Rvalue::Aggregate(ref kind, ref places)\n             ) = stmt.kind {\n@@ -682,7 +682,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Helper to retrieve span(s) of given borrow from the current MIR\n     /// representation\n     pub(super) fn retrieve_borrow_spans(&self, borrow: &BorrowData<'_>) -> UseSpans {\n-        let span = self.mir.source_info(borrow.reserve_location).span;\n+        let span = self.body.source_info(borrow.reserve_location).span;\n         self.borrow_spans(span, borrow.reserve_location)\n     }\n }"}, {"sha": "cc44dc3f5d46bd34be686d7bcea9a36281710d7e", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -30,9 +30,9 @@ crate enum RichLocation {\n }\n \n impl LocationTable {\n-    crate fn new(mir: &Body<'_>) -> Self {\n+    crate fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block = mir.basic_blocks()\n+        let statements_before_block = body.basic_blocks()\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;"}, {"sha": "502d601f7ce612580531855a5d4da5890e94b6b2", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -88,12 +88,12 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowCheckResult<'tcx> {\n-    let input_mir = tcx.mir_validated(def_id);\n+    let input_body = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n-        let input_mir: &Body<'_> = &input_mir.borrow();\n-        do_mir_borrowck(&infcx, input_mir, def_id)\n+        let input_body: &Body<'_> = &input_body.borrow();\n+        do_mir_borrowck(&infcx, input_body, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -102,7 +102,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n \n fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    input_mir: &Body<'gcx>,\n+    input_body: &Body<'gcx>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'gcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -149,14 +149,14 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let mut mir: Body<'tcx> = input_mir.clone();\n-    let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n-    let mir = &mir; // no further changes\n-    let location_table = &LocationTable::new(mir);\n+    let mut body: Body<'tcx> = input_body.clone();\n+    let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body);\n+    let body = &body; // no further changes\n+    let location_table = &LocationTable::new(body);\n \n     let mut errors_buffer = Vec::new();\n     let (move_data, move_errors): (MoveData<'tcx>, Option<Vec<(Place<'tcx>, MoveError<'tcx>)>>) =\n-        match MoveData::gather_moves(mir, tcx) {\n+        match MoveData::gather_moves(body, tcx) {\n             Ok(move_data) => (move_data, None),\n             Err((move_data, move_errors)) => (move_data, Some(move_errors)),\n         };\n@@ -166,27 +166,27 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         param_env: param_env,\n     };\n \n-    let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        mir,\n+        body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n     let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n-            tcx, mir, locals_are_invalidated_at_exit, &mdpe.move_data));\n+            tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n     let (regioncx, polonius_output, opt_closure_req) = nll::compute_regions(\n         infcx,\n         def_id,\n         free_regions,\n-        mir,\n+        body,\n         &upvars,\n         location_table,\n         param_env,\n@@ -205,29 +205,29 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     let flow_borrows = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        mir,\n+        body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        Borrows::new(tcx, mir, regioncx.clone(), &borrow_set),\n+        Borrows::new(tcx, body, regioncx.clone(), &borrow_set),\n         |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        mir,\n+        body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_ever_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n-        mir,\n+        body,\n         def_id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedPlaces::new(tcx, mir, &mdpe),\n+        EverInitializedPlaces::new(tcx, body, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -239,11 +239,11 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         _ => true,\n     };\n \n-    let dominators = mir.dominators();\n+    let dominators = body.dominators();\n \n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n-        mir,\n+        body,\n         mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         location_table,\n@@ -281,8 +281,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         let mut initial_diag =\n             mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n \n-        let lint_root = if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n-            let scope = mbcx.mir.source_info(location).scope;\n+        let lint_root = if let ClearCrossCrate::Set(ref vsi) = mbcx.body.source_scope_local_data {\n+            let scope = mbcx.body.source_info(location).scope;\n             vsi[scope].lint_root\n         } else {\n             id\n@@ -305,22 +305,22 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n     let temporary_used_locals: FxHashSet<Local> = mbcx.used_mut.iter()\n-        .filter(|&local| mbcx.mir.local_decls[*local].is_user_variable.is_none())\n+        .filter(|&local| mbcx.body.local_decls[*local].is_user_variable.is_none())\n         .cloned()\n         .collect();\n     // For the remaining unused locals that are marked as mutable, we avoid linting any that\n     // were never initialized. These locals may have been removed as unreachable code; or will be\n     // linted as unused variables.\n-    let unused_mut_locals = mbcx.mir.mut_vars_iter()\n+    let unused_mut_locals = mbcx.body.mut_vars_iter()\n         .filter(|local| !mbcx.used_mut.contains(local))\n         .collect();\n     mbcx.gather_used_muts(temporary_used_locals, unused_mut_locals);\n \n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n     let used_mut = mbcx.used_mut;\n-    for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n-        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n-            let local_decl = &mbcx.mir.local_decls[local];\n+    for local in mbcx.body.mut_vars_and_args_iter().filter(|local| !used_mut.contains(local)) {\n+        if let ClearCrossCrate::Set(ref vsi) = mbcx.body.source_scope_local_data {\n+            let local_decl = &mbcx.body.local_decls[local];\n \n             // Skip implicit `self` argument for closures\n             if local.index() == 1 && tcx.is_closure(mbcx.mir_def_id) {\n@@ -425,7 +425,7 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n \n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    mir: &'cx Body<'tcx>,\n+    body: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n \n@@ -511,8 +511,8 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     type FlowState = Flows<'cx, 'gcx, 'tcx>;\n \n-    fn mir(&self) -> &'cx Body<'tcx> {\n-        self.mir\n+    fn body(&self) -> &'cx Body<'tcx> {\n+        self.body\n     }\n \n     fn visit_block_entry(&mut self, bb: BasicBlock, flow_state: &Self::FlowState) {\n@@ -662,7 +662,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let gcx = self.infcx.tcx.global_tcx();\n \n                 // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.mir, self.infcx.tcx);\n+                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n \n                 // Erase the regions.\n                 let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n@@ -1005,13 +1005,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n-        let mir = self.mir;\n+        let body = self.body;\n         let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,\n             tcx,\n-            mir,\n+            body,\n             location,\n             (sd, place_span.0),\n             &borrow_set,\n@@ -1169,7 +1169,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n         if let &Place::Base(PlaceBase::Local(local)) = place_span.0 {\n-            if let Mutability::Not = self.mir.local_decls[local].mutability {\n+            if let Mutability::Not = self.body.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n@@ -1326,9 +1326,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *operand {\n             Operand::Move(Place::Base(PlaceBase::Local(local)))\n             | Operand::Copy(Place::Base(PlaceBase::Local(local)))\n-                if self.mir.local_decls[local].is_user_variable.is_none() =>\n+                if self.body.local_decls[local].is_user_variable.is_none() =>\n             {\n-                if self.mir.local_decls[local].ty.is_mutable_pointer() {\n+                if self.body.local_decls[local].ty.is_mutable_pointer() {\n                     // The variable will be marked as mutable by the borrow.\n                     return;\n                 }\n@@ -1359,7 +1359,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     _ => bug!(\"temporary initialized in arguments\"),\n                 };\n \n-                let bbd = &self.mir[loc.block];\n+                let bbd = &self.body[loc.block];\n                 let stmt = &bbd.statements[loc.statement_index];\n                 debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n@@ -1474,7 +1474,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         if places_conflict::borrow_conflicts_with_place(\n             self.infcx.tcx,\n-            self.mir,\n+            self.body,\n             place,\n             borrow.kind,\n             root_place,\n@@ -1561,7 +1561,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {\n             // And, if so, report an error.\n             let init = &self.move_data.inits[init_index];\n-            let span = init.span(&self.mir);\n+            let span = init.span(&self.body);\n             self.report_illegal_reassignment(\n                 location, place_span, span, place_span.0\n             );\n@@ -1771,7 +1771,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // assigning to `P.f` requires `P` itself\n                             // be already initialized\n                             let tcx = self.infcx.tcx;\n-                            match base.ty(self.mir, tcx).ty.sty {\n+                            match base.ty(self.body, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n                                         location, InitializationRequiringAction::Assignment,\n@@ -1875,11 +1875,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n+                if let ty::Adt(def, _) = base.ty(this.body, tcx).ty.sty {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                location, this.mir,\n+                                location, this.body,\n                             )\n                         }) {\n                             return;\n@@ -2097,7 +2097,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => {\n-                let local = &self.mir.local_decls[local];\n+                let local = &self.body.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => Ok(RootPlace {\n@@ -2136,7 +2136,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n                     ProjectionElem::Deref => {\n-                        let base_ty = proj.base.ty(self.mir, self.infcx.tcx).ty;\n+                        let base_ty = proj.base.ty(self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2264,7 +2264,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _ty) => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = proj.base.ty(self.mir, tcx).ty;\n+                    let base_ty = proj.base.ty(self.body, tcx).ty;\n \n                     if (base_ty.is_closure() || base_ty.is_generator()) &&\n                         (!by_ref || self.upvars[field.index()].by_ref)"}, {"sha": "f4bc1bc54527aaed6ba74b905d905162ce302c12", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -158,12 +158,12 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(StatementKind::Assign(\n                     Place::Base(PlaceBase::Local(local)),\n                     box Rvalue::Use(Operand::Move(move_from)),\n-                )) = self.mir.basic_blocks()[location.block]\n+                )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n-                    let local_decl = &self.mir.local_decls[*local];\n+                    let local_decl = &self.body.local_decls[*local];\n                     // opt_match_place is the\n                     // match_span is the span of the expression being matched on\n                     // match *x.y { ... }        match_place is Some(*x.y)\n@@ -178,7 +178,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         pat_span: _,\n                     }))) = local_decl.is_user_variable\n                     {\n-                        let stmt_source_info = self.mir.source_info(location);\n+                        let stmt_source_info = self.body.source_info(location);\n                         self.append_binding_error(\n                             grouped_errors,\n                             kind,\n@@ -371,7 +371,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n         // was a move rather than a copy.\n-        let ty = deref_target_place.ty(self.mir, self.infcx.tcx).ty;\n+        let ty = deref_target_place.ty(self.body, self.infcx.tcx).ty;\n         let upvar_field = self.prefixes(&move_place, PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n@@ -381,7 +381,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if let Place::Base(PlaceBase::Local(local)) = *deref_base {\n-            let decl = &self.mir.local_decls[local];\n+            let decl = &self.body.local_decls[local];\n             if decl.is_ref_for_guard() {\n                 let mut err = self.infcx.tcx.cannot_move_out_of(\n                     span,\n@@ -470,7 +470,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         };\n         let move_ty = format!(\n             \"{:?}\",\n-            move_place.ty(self.mir, self.infcx.tcx).ty,\n+            move_place.ty(self.body, self.infcx.tcx).ty,\n         );\n         let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n         let is_option = move_ty.starts_with(\"std::option::Option\");\n@@ -511,7 +511,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 );\n \n                 if binds_to.is_empty() {\n-                    let place_ty = move_from.ty(self.mir, self.infcx.tcx).ty;\n+                    let place_ty = move_from.ty(self.body, self.infcx.tcx).ty;\n                     let place_desc = match self.describe_place(&move_from) {\n                         Some(desc) => format!(\"`{}`\", desc),\n                         None => format!(\"value\"),\n@@ -539,7 +539,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // No binding. Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { ref original_path, use_spans, .. } => {\n                 let span = use_spans.var_or_use();\n-                let place_ty = original_path.ty(self.mir, self.infcx.tcx).ty;\n+                let place_ty = original_path.ty(self.body, self.infcx.tcx).ty;\n                 let place_desc = match self.describe_place(original_path) {\n                     Some(desc) => format!(\"`{}`\", desc),\n                     None => format!(\"value\"),\n@@ -567,7 +567,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         let mut suggestions: Vec<(Span, &str, String)> = Vec::new();\n         for local in binds_to {\n-            let bind_to = &self.mir.local_decls[*local];\n+            let bind_to = &self.body.local_decls[*local];\n             if let Some(\n                 ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n                     pat_span,\n@@ -617,7 +617,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         let mut noncopy_var_spans = Vec::new();\n         for (j, local) in binds_to.into_iter().enumerate() {\n-            let bind_to = &self.mir.local_decls[*local];\n+            let bind_to = &self.body.local_decls[*local];\n             let binding_span = bind_to.source_info.span;\n \n             if j == 0 {\n@@ -667,7 +667,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         _ => continue,\n                     };\n \n-                    let bbd = &self.mir[loc.block];\n+                    let bbd = &self.body[loc.block];\n                     let is_terminator = bbd.statements.len() == loc.statement_index;\n                     debug!(\n                         \"borrowed_content_source: loc={:?} is_terminator={:?}\",\n@@ -685,7 +685,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     }) = bbd.terminator {\n                         if let Some(source)\n-                            = BorrowedContentSource::from_call(func.ty(self.mir, tcx), tcx)\n+                            = BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n                         {\n                             return source;\n                         }\n@@ -698,7 +698,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n         // If we didn't find an overloaded deref or index, then assume it's a\n         // built in deref and check the type of the base.\n-        let base_ty = deref_base.ty(self.mir, tcx).ty;\n+        let base_ty = deref_base.ty(self.body, tcx).ty;\n         if base_ty.is_unsafe_ptr() {\n             BorrowedContentSource::DerefRawPointer\n         } else if base_ty.is_mutable_pointer() {"}, {"sha": "46116e3e876bc0326a195a89eeaaaee881eb1d59", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 if let Place::Base(PlaceBase::Local(_)) = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n-                    let name = self.mir.local_decls[*local]\n+                    let name = self.body.local_decls[*local]\n                         .name\n                         .expect(\"immutable unnamed local\");\n                     reason = format!(\", as `{}` is not declared as mutable\", name);\n@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).ty\n+                    base.ty(self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -83,9 +83,9 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                    debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n+                    debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n-                        the_place_err.ty(self.mir, self.infcx.tcx).ty\n+                        the_place_err.ty(self.body, self.infcx.tcx).ty\n                     ));\n \n                     reason = if self.is_upvar_field_projection(access_place).is_some() {\n@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 } else if {\n                     if let Place::Base(PlaceBase::Local(local)) = *base {\n-                        self.mir.local_decls[local].is_ref_for_guard()\n+                        self.body.local_decls[local].is_ref_for_guard()\n                     } else {\n                         false\n                     }\n@@ -104,7 +104,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     reason = \", as it is immutable for the pattern guard\".to_string();\n                 } else {\n                     let pointer_type =\n-                        if base.ty(self.mir, self.infcx.tcx).ty.is_region_ptr() {\n+                        if base.ty(self.body, self.infcx.tcx).ty.is_region_ptr() {\n                             \"`&` reference\"\n                         } else {\n                             \"`*const` pointer\"\n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    base.ty(self.mir, self.infcx.tcx).ty,\n+                    base.ty(self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // Suggest removing a `&mut` from the use of a mutable reference.\n             Place::Base(PlaceBase::Local(local))\n                 if {\n-                    self.mir.local_decls.get(*local).map(|local_decl| {\n+                    self.body.local_decls.get(*local).map(|local_decl| {\n                         if let ClearCrossCrate::Set(\n                             mir::BindingForm::ImplicitSelf(kind)\n                         ) = local_decl.is_user_variable.as_ref().unwrap() {\n@@ -275,12 +275,12 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n             Place::Base(PlaceBase::Local(local))\n-                if self.mir.local_decls[*local].can_be_made_mutable() => {\n+                if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n                 // mutable).\n-                let local_decl = &self.mir.local_decls[*local];\n+                let local_decl = &self.body.local_decls[*local];\n                 assert_eq!(local_decl.mutability, Mutability::Not);\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -298,7 +298,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Field(upvar_index, _),\n             }) => {\n                 debug_assert!(is_closure_or_generator(\n-                    base.ty(self.mir, self.infcx.tcx).ty\n+                    base.ty(self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -344,7 +344,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 elem: ProjectionElem::Deref,\n             }) if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n-                    self.mir.local_decls[*local].is_user_variable\n+                    self.body.local_decls[*local].is_user_variable\n                 {\n                     true\n                 } else {\n@@ -366,9 +366,9 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n-            }) if self.mir.local_decls[*local].is_user_variable.is_some() =>\n+            }) if self.body.local_decls[*local].is_user_variable.is_some() =>\n             {\n-                let local_decl = &self.mir.local_decls[*local];\n+                let local_decl = &self.body.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n                     ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(_)) => {\n                         Some(suggest_ampmut_self(self.infcx.tcx, local_decl))\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     })) => Some(suggest_ampmut(\n                         self.infcx.tcx,\n-                        self.mir,\n+                        self.body,\n                         *local,\n                         local_decl,\n                         *opt_ty_info,\n@@ -451,7 +451,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n-                    self.mir.span,\n+                    self.body.span,\n                     \"consider changing this to accept closures that implement `FnMut`\"\n                 );\n             }\n@@ -482,7 +482,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                 },\n                                 ..\n                             }\n-                        ) = &self.mir.basic_blocks()[location.block].terminator {\n+                        ) = &self.body.basic_blocks()[location.block].terminator {\n                             let index_trait = self.infcx.tcx.lang_items().index_trait();\n                             if self.infcx.tcx.parent(id) == index_trait {\n                                 let mut found = false;\n@@ -557,14 +557,14 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n-    let locations = mir.find_assignments(local);\n+    let locations = body.find_assignments(local);\n     if !locations.is_empty() {\n-        let assignment_rhs_span = mir.source_info(locations[0]).span;\n+        let assignment_rhs_span = body.source_info(locations[0]).span;\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) = (\n                 src.starts_with(\"&'\"),"}, {"sha": "4a9aad2e80abcf3438684e719cec4b9cd12d3804", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -18,7 +18,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n@@ -29,7 +29,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         all_facts,\n     };\n \n-    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n         cg.visit_basic_block_data(bb, data);\n     }\n }"}, {"sha": "31181e72ed7ef8f4b7271c8ad62949925b42799c", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -10,14 +10,14 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n crate fn find<'tcx>(\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'_, '_, 'tcx>,\n     region_vid: RegionVid,\n     start_point: Location,\n ) -> Option<Cause> {\n     let mut uf = UseFinder {\n-        mir,\n+        body,\n         regioncx,\n         tcx,\n         region_vid,\n@@ -28,7 +28,7 @@ crate fn find<'tcx>(\n }\n \n struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Body<'tcx>,\n+    body: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n@@ -50,7 +50,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            let block_data = &self.mir[p.block];\n+            let block_data = &self.body[p.block];\n \n             match self.def_use(p, block_data.visitable(p.statement_index)) {\n                 Some(DefUseResult::Def) => {}\n@@ -87,7 +87,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n \n     fn def_use(&self, location: Location, thing: &dyn MirVisitable<'tcx>) -> Option<DefUseResult> {\n         let mut visitor = DefUseVisitor {\n-            mir: self.mir,\n+            body: self.body,\n             tcx: self.tcx,\n             region_vid: self.region_vid,\n             def_use_result: None,\n@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n }\n \n struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Body<'tcx>,\n+    body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n     def_use_result: Option<DefUseResult>,\n@@ -114,7 +114,7 @@ enum DefUseResult {\n \n impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for DefUseVisitor<'cx, 'gcx, 'tcx> {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext, _: Location) {\n-        let local_ty = self.mir.local_decls[local].ty;\n+        let local_ty = self.body.local_decls[local].ty;\n \n         let mut found_it = false;\n         self.tcx.for_each_free_region(&local_ty, |r| {"}, {"sha": "f0e6d5636ccd05740360c4df55488074b47e6ccf", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -54,7 +54,7 @@ impl BorrowExplanation {\n     pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'cx, 'gcx, 'tcx>(\n         &self,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,\n         borrow_span: Option<Span>,\n@@ -94,7 +94,7 @@ impl BorrowExplanation {\n                 dropped_local,\n                 should_note_order,\n             } => {\n-                let local_decl = &mir.local_decls[dropped_local];\n+                let local_decl = &body.local_decls[dropped_local];\n                 let (dtor_desc, type_desc) = match local_decl.ty.sty {\n                     // If type is an ADT that implements Drop, then\n                     // simplify output by reporting just the ADT name.\n@@ -121,7 +121,7 @@ impl BorrowExplanation {\n                             TYPE = type_desc,\n                             DTOR = dtor_desc\n                         );\n-                        err.span_label(mir.source_info(drop_loc).span, message);\n+                        err.span_label(body.source_info(drop_loc).span, message);\n \n                         if should_note_order {\n                             err.note(\n@@ -147,7 +147,7 @@ impl BorrowExplanation {\n                             TYPE = type_desc,\n                             DTOR = dtor_desc\n                         );\n-                        err.span_label(mir.source_info(drop_loc).span, message);\n+                        err.span_label(body.source_info(drop_loc).span, message);\n \n                         if let Some(info) = &local_decl.is_block_tail {\n                             // FIXME: use span_suggestion instead, highlighting the\n@@ -233,7 +233,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n-        let mir = self.mir;\n+        let body = self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n@@ -248,9 +248,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             region_sub\n         );\n \n-        match find_use::find(mir, regioncx, tcx, region_sub, location) {\n+        match find_use::find(body, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n-                let span = mir.source_info(location).span;\n+                let span = body.source_info(location).span;\n                 let spans = self\n                     .move_spans(&Place::Base(PlaceBase::Local(local)), location)\n                     .or_else(|| self.borrow_spans(span, location));\n@@ -270,10 +270,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Some(Cause::DropVar(local, location)) => {\n                 let mut should_note_order = false;\n-                if mir.local_decls[local].name.is_some() {\n+                if body.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place::Base(PlaceBase::Local(borrowed_local)) = place {\n-                             if mir.local_decls[*borrowed_local].name.is_some()\n+                             if body.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n                             {\n                                 should_note_order = true;\n@@ -293,7 +293,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n                     let (category, from_closure, span, region_name) =\n                         self.nonlexical_regioncx.free_region_constraint_info(\n-                            self.mir,\n+                            self.body,\n                         &self.upvars,\n                             self.mir_def_id,\n                             self.infcx,\n@@ -359,7 +359,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 return outmost_back_edge;\n             }\n \n-            let block = &self.mir.basic_blocks()[location.block];\n+            let block = &self.body.basic_blocks()[location.block];\n \n             if location.statement_index < block.statements.len() {\n                 let successor = location.successor_within_block();\n@@ -421,7 +421,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.mir.basic_blocks()[from.block];\n+            let block = &self.body.basic_blocks()[from.block];\n \n             if from.statement_index < block.statements.len() {\n                 let successor = from.successor_within_block();\n@@ -453,7 +453,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// True if an edge `source -> target` is a backedge -- in other words, if the target\n     /// dominates the source.\n     fn is_back_edge(&self, source: Location, target: Location) -> bool {\n-        target.dominates(source, &self.mir.dominators())\n+        target.dominates(source, &self.body.dominators())\n     }\n \n     /// Determine how the borrow was later used.\n@@ -469,7 +469,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 (LaterUseKind::ClosureCapture, var_span)\n             }\n             UseSpans::OtherUse(span) => {\n-                let block = &self.mir.basic_blocks()[location.block];\n+                let block = &self.body.basic_blocks()[location.block];\n \n                 let kind = if let Some(&Statement {\n                     kind: StatementKind::FakeRead(FakeReadCause::ForLet, _),\n@@ -491,7 +491,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             Operand::Constant(c) => c.span,\n                             Operand::Copy(Place::Base(PlaceBase::Local(l))) |\n                             Operand::Move(Place::Base(PlaceBase::Local(l))) => {\n-                                let local_decl = &self.mir.local_decls[*l];\n+                                let local_decl = &self.body.local_decls[*l];\n                                 if local_decl.name.is_none() {\n                                     local_decl.source_info.span\n                                 } else {\n@@ -519,7 +519,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn was_captured_by_trait_object(&self, borrow: &BorrowData<'tcx>) -> bool {\n         // Start at the reserve location, find the place that we want to see cast to a trait object.\n         let location = borrow.reserve_location;\n-        let block = &self.mir[location.block];\n+        let block = &self.body[location.block];\n         let stmt = block.statements.get(location.statement_index);\n         debug!(\n             \"was_captured_by_trait_object: location={:?} stmt={:?}\",\n@@ -546,7 +546,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         while let Some(current_location) = queue.pop() {\n             debug!(\"was_captured_by_trait: target={:?}\", target);\n-            let block = &self.mir[current_location.block];\n+            let block = &self.body[current_location.block];\n             // We need to check the current location to find out if it is a terminator.\n             let is_terminator = current_location.statement_index == block.statements.len();\n             if !is_terminator {"}, {"sha": "8fa3bb1847212a82da7ec0a4b0e5cc8f384ff8fb", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -21,7 +21,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -30,24 +30,24 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     }\n \n     if let Some(all_facts) = all_facts {\n-        let dominators = mir.dominators();\n+        let dominators = body.dominators();\n         let mut ig = InvalidationGenerator {\n             all_facts,\n             borrow_set,\n             tcx,\n             location_table,\n-            mir,\n+            body,\n             dominators,\n         };\n-        ig.visit_body(mir);\n+        ig.visit_body(body);\n     }\n }\n \n struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n-    mir: &'cx Body<'tcx>,\n+    body: &'cx Body<'tcx>,\n     dominators: Dominators<BasicBlock>,\n     borrow_set: &'cx BorrowSet<'tcx>,\n }\n@@ -400,13 +400,13 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             rw,\n         );\n         let tcx = self.tcx;\n-        let mir = self.mir;\n+        let body = self.body;\n         let borrow_set = self.borrow_set.clone();\n         let indices = self.borrow_set.borrows.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,\n-            mir,\n+            body,\n             location,\n             (sd, place),\n             &borrow_set.clone(),"}, {"sha": "a260f5460e504da22ab232614b46d993e3b99153", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -50,18 +50,18 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    mir: &mut Body<'tcx>,\n+    body: &mut Body<'tcx>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n     let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, mir);\n+    renumber::renumber_mir(infcx, body);\n \n     let source = MirSource::item(def_id);\n-    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, mir, |_, _| Ok(()));\n+    mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions\n }\n@@ -73,7 +73,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -94,7 +94,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n     let universal_regions = Rc::new(universal_regions);\n \n-    let elements = &Rc::new(RegionValueElements::new(mir));\n+    let elements = &Rc::new(RegionValueElements::new(body));\n \n     // Run the MIR type-checker.\n     let MirTypeckResults {\n@@ -103,7 +103,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     } = type_check::type_check(\n         infcx,\n         param_env,\n-        mir,\n+        body,\n         def_id,\n         &universal_regions,\n         location_table,\n@@ -139,7 +139,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,\n-        &mir,\n+        &body,\n         borrow_set,\n     );\n \n@@ -148,7 +148,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         universal_regions,\n         placeholder_indices,\n         universal_region_relations,\n-        mir,\n+        body,\n         outlives_constraints,\n         closure_bounds_mapping,\n         type_tests,\n@@ -161,7 +161,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         infcx.tcx,\n         &mut all_facts,\n         location_table,\n-        &mir,\n+        &body,\n         borrow_set,\n     );\n \n@@ -191,29 +191,29 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n     // Solve the region constraints.\n     let closure_region_requirements =\n-        regioncx.solve(infcx, &mir, upvars, def_id, errors_buffer);\n+        regioncx.solve(infcx, &body, upvars, def_id, errors_buffer);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n         MirSource::item(def_id),\n-        &mir,\n+        &body,\n         &regioncx,\n         &closure_region_requirements,\n     );\n \n     // We also have a `#[rustc_nll]` annotation that causes us to dump\n     // information\n-    dump_annotation(infcx, &mir, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n+    dump_annotation(infcx, &body, def_id, &regioncx, &closure_region_requirements, errors_buffer);\n \n     (regioncx, polonius_output, closure_region_requirements)\n }\n \n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'_>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n@@ -227,7 +227,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         \"nll\",\n         &0,\n         source,\n-        mir,\n+        body,\n         |pass_where, out| {\n             match pass_where {\n                 // Before the CFG, dump out the values for each region variable.\n@@ -273,7 +273,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n \n fn dump_annotation<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -296,7 +296,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n         let mut err = tcx\n             .sess\n             .diagnostic()\n-            .span_note_diag(mir.span, \"External requirements\");\n+            .span_note_diag(body.span, \"External requirements\");\n \n         regioncx.annotate(tcx, &mut err);\n \n@@ -317,7 +317,7 @@ fn dump_annotation<'a, 'gcx, 'tcx>(\n         let mut err = tcx\n             .sess\n             .diagnostic()\n-            .span_note_diag(mir.span, \"No external requirements\");\n+            .span_note_diag(body.span, \"No external requirements\");\n         regioncx.annotate(tcx, &mut err);\n \n         err.buffer(errors_buffer);"}, {"sha": "85937848eca96fe33912d978d0101d175d793d1e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// path to blame.\n     fn best_blame_constraint(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, bool, Span) {\n@@ -88,9 +88,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path.iter()\n             .map(|constraint| {\n                 if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(mir, &constraint)\n+                    self.retrieve_closure_constraint_info(body, &constraint)\n                 } else {\n-                    (constraint.category, false, constraint.locations.span(mir))\n+                    (constraint.category, false, constraint.locations.span(body))\n                 }\n             })\n             .collect();\n@@ -237,7 +237,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     pub(super) fn report_error(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -247,7 +247,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(mir, fr, |r| {\n+        let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n             self.provides_universal_region(r, fr, outlived_fr)\n         });\n \n@@ -274,7 +274,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match (category, fr_is_local, outlived_fr_is_local) {\n             (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(infcx, fr) => {\n                 self.report_fnmut_error(\n-                    mir,\n+                    body,\n                     upvars,\n                     infcx,\n                     mir_def_id,\n@@ -286,7 +286,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => self.report_escaping_data_error(\n-                mir,\n+                body,\n                 upvars,\n                 infcx,\n                 mir_def_id,\n@@ -297,7 +297,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 errors_buffer,\n             ),\n             _ => self.report_general_error(\n-                mir,\n+                body,\n                 upvars,\n                 infcx,\n                 mir_def_id,\n@@ -357,7 +357,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -383,7 +383,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(span, message);\n \n-        match self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, &mut 1)\n+        match self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, &mut 1)\n             .unwrap().source\n         {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n@@ -422,7 +422,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -433,9 +433,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, fr);\n         let outlived_fr_name_and_span =\n-            self.get_var_name_and_span_for_region(infcx.tcx, mir, upvars, outlived_fr);\n+            self.get_var_name_and_span_for_region(infcx.tcx, body, upvars, outlived_fr);\n \n         let escapes_from = match self.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n@@ -451,7 +451,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                mir,\n+                body,\n                 upvars,\n                 infcx,\n                 mir_def_id,\n@@ -514,7 +514,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -532,10 +532,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(infcx, mir, upvars, mir_def_id, fr, counter).unwrap();\n+        let fr_name = self.give_region_a_name(\n+            infcx, body, upvars, mir_def_id, fr, counter).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_fr, counter).unwrap();\n+            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_fr, counter).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         let mir_def_name = if infcx.tcx.is_closure(mir_def_id) {\n@@ -667,20 +668,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     crate fn free_region_constraint_info(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n     ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n         let (category, from_closure, span) = self.best_blame_constraint(\n-            mir,\n+            body,\n             borrow_region,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n         let outlived_fr_name =\n-            self.give_region_a_name(infcx, mir, upvars, mir_def_id, outlived_region, &mut 1);\n+            self.give_region_a_name(infcx, body, upvars, mir_def_id, outlived_region, &mut 1);\n         (category, from_closure, span, outlived_fr_name)\n     }\n \n@@ -724,18 +725,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n     crate fn find_outlives_blame_span(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n         let (category, _, span) =\n-            self.best_blame_constraint(mir, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n+            self.best_blame_constraint(body, fr1, |r| self.provides_universal_region(r, fr1, fr2));\n         (category, span)\n     }\n \n     fn retrieve_closure_constraint_info(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         constraint: &OutlivesConstraint,\n     ) -> (ConstraintCategory, bool, Span) {\n         let loc = match constraint.locations {\n@@ -747,7 +748,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n         opt_span_category\n             .map(|&(category, span)| (category, true, span))\n-            .unwrap_or((constraint.category, false, mir.source_info(loc).span))\n+            .unwrap_or((constraint.category, false, body.source_info(loc).span))\n     }\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure."}, {"sha": "82720d0091394b231cfb15205dbc0cdcc5cad988", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -152,7 +152,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn give_region_a_name(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -165,7 +165,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let value = self.give_name_from_error_region(infcx.tcx, mir_def_id, fr, counter)\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_arguments(\n-                    infcx, mir, mir_def_id, fr, counter,\n+                    infcx, body, mir_def_id, fr, counter,\n                 )\n             })\n             .or_else(|| {\n@@ -175,12 +175,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_output(\n-                    infcx, mir, mir_def_id, fr, counter,\n+                    infcx, body, mir_def_id, fr, counter,\n                 )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_yield_ty(\n-                    infcx, mir, mir_def_id, fr, counter,\n+                    infcx, body, mir_def_id, fr, counter,\n                 )\n             });\n \n@@ -332,7 +332,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -344,7 +344,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n         if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n             infcx,\n-            mir,\n+            body,\n             mir_def_id,\n             fr,\n             arg_ty,\n@@ -354,13 +354,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(infcx, mir, fr, arg_ty, counter)\n+        self.give_name_if_we_cannot_match_hir_ty(infcx, body, fr, arg_ty, counter)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n@@ -376,7 +376,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // must highlight the variable.\n             hir::TyKind::Infer => self.give_name_if_we_cannot_match_hir_ty(\n                 infcx,\n-                mir,\n+                body,\n                 needle_fr,\n                 argument_ty,\n                 counter,\n@@ -406,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n@@ -422,7 +422,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n             let argument_index = self.get_argument_index_for_region(infcx.tcx, needle_fr)?;\n-            let (_, span) = self.get_argument_name_and_span_for_region(mir, argument_index);\n+            let (_, span) = self.get_argument_name_and_span_for_region(body, argument_index);\n \n             Some(RegionName {\n                 // This counter value will already have been used, so this function will increment\n@@ -676,7 +676,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_output(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -717,7 +717,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 node: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (mir.span, \"\"),\n+            _ => (body.span, \"\"),\n         };\n \n         Some(RegionName {\n@@ -736,7 +736,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -768,7 +768,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }) => (\n                 tcx.sess.source_map().end_point(*span)\n             ),\n-            _ => mir.span,\n+            _ => body.span,\n         };\n \n         debug!("}, {"sha": "f2dbcc5db3ab1b56600eaa18dee46582f4669781", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -11,7 +11,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_var_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n@@ -28,7 +28,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .or_else(|| {\n                 debug!(\"get_var_name_and_span_for_region: attempting argument\");\n                 self.get_argument_index_for_region(tcx, fr)\n-                    .map(|index| self.get_argument_name_and_span_for_region(mir, index))\n+                    .map(|index| self.get_argument_name_and_span_for_region(body, index))\n             })\n     }\n \n@@ -120,15 +120,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// declared.\n     crate fn get_argument_name_and_span_for_region(\n         &self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n \n-        let argument_name = mir.local_decls[argument_local].name;\n-        let argument_span = mir.local_decls[argument_local].source_info.span;\n+        let argument_name = body.local_decls[argument_local].name;\n+        let argument_span = body.local_decls[argument_local].source_info.span;\n         debug!(\"get_argument_name_and_span_for_region: argument_name={:?} argument_span={:?}\",\n                argument_name, argument_span);\n "}, {"sha": "170f61a63a5b459c05519f1011abf4be25363e0a", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -185,7 +185,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n-        _mir: &Body<'tcx>,\n+        _body: &Body<'tcx>,\n         outlives_constraints: ConstraintSet,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n@@ -400,7 +400,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn solve<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -409,19 +409,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             infcx.tcx.sess.time_extended(),\n             Some(infcx.tcx.sess),\n             &format!(\"solve_nll_region_constraints({:?})\", mir_def_id),\n-            || self.solve_inner(infcx, mir, upvars, mir_def_id, errors_buffer),\n+            || self.solve_inner(infcx, body, upvars, mir_def_id, errors_buffer),\n         )\n     }\n \n     fn solve_inner<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n-        self.propagate_constraints(mir);\n+        self.propagate_constraints(body);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -436,15 +436,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.check_type_tests(\n             infcx,\n-            mir,\n+            body,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n             errors_buffer,\n         );\n \n         self.check_universal_regions(\n             infcx,\n-            mir,\n+            body,\n             upvars,\n             mir_def_id,\n             outlives_requirements.as_mut(),\n@@ -468,7 +468,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, _mir: &Body<'tcx>) {\n+    fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -581,7 +581,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_type_tests<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -599,7 +599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let generic_ty = type_test.generic_kind.to_ty(tcx);\n             if self.eval_verify_bound(\n                 tcx,\n-                mir,\n+                body,\n                 generic_ty,\n                 type_test.lower_bound,\n                 &type_test.verify_bound,\n@@ -610,7 +610,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n                 if self.try_promote_type_test(\n                     infcx,\n-                    mir,\n+                    body,\n                     type_test,\n                     propagated_outlives_requirements,\n                 ) {\n@@ -624,7 +624,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let lower_bound_region = self.to_error_region(type_test.lower_bound);\n \n             // Skip duplicate-ish errors.\n-            let type_test_span = type_test.locations.span(mir);\n+            let type_test_span = type_test.locations.span(body);\n             let erased_generic_kind = tcx.erase_regions(&type_test.generic_kind);\n             if !deduplicate_errors.insert((\n                 erased_generic_kind,\n@@ -725,7 +725,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) -> bool {\n@@ -762,7 +762,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // where `ur` is a local bound -- we are sometimes in a\n             // position to prove things that our caller cannot.  See\n             // #53570 for an example.\n-            if self.eval_verify_bound(tcx, mir, generic_ty, ur, &type_test.verify_bound) {\n+            if self.eval_verify_bound(tcx, body, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n             }\n \n@@ -782,7 +782,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 let requirement = ClosureOutlivesRequirement {\n                     subject,\n                     outlived_free_region: upper_bound,\n-                    blame_span: locations.span(mir),\n+                    blame_span: locations.span(body),\n                     category: ConstraintCategory::Boring,\n                 };\n                 debug!(\"try_promote_type_test: pushing {:#?}\", requirement);\n@@ -944,7 +944,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_verify_bound(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n@@ -956,28 +956,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n-                self.eval_if_eq(tcx, mir, generic_ty, lower_bound, test_ty, verify_bound1)\n+                self.eval_if_eq(tcx, body, generic_ty, lower_bound, test_ty, verify_bound1)\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n-                self.eval_outlives(mir, r_vid, lower_bound)\n+                self.eval_outlives(body, r_vid, lower_bound)\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n-                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n             }),\n \n             VerifyBound::AllBounds(verify_bounds) => verify_bounds.iter().all(|verify_bound| {\n-                self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+                self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n             }),\n         }\n     }\n \n     fn eval_if_eq(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         test_ty: Ty<'tcx>,\n@@ -986,7 +986,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let generic_ty_normalized = self.normalize_to_scc_representatives(tcx, generic_ty);\n         let test_ty_normalized = self.normalize_to_scc_representatives(tcx, test_ty);\n         if generic_ty_normalized == test_ty_normalized {\n-            self.eval_verify_bound(tcx, mir, generic_ty, lower_bound, verify_bound)\n+            self.eval_verify_bound(tcx, body, generic_ty, lower_bound, verify_bound)\n         } else {\n             false\n         }\n@@ -1037,7 +1037,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,\n-        _mir: &Body<'tcx>,\n+        _body: &Body<'tcx>,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n     ) -> bool {\n@@ -1105,7 +1105,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1119,7 +1119,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     // for our caller into the `outlives_requirements` vector.\n                     self.check_universal_region(\n                         infcx,\n-                        mir,\n+                        body,\n                         upvars,\n                         mir_def_id,\n                         fr,\n@@ -1129,7 +1129,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, placeholder);\n+                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -1150,7 +1150,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n@@ -1183,7 +1183,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr,\n                 representative,\n                 infcx,\n-                mir,\n+                body,\n                 upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n@@ -1199,7 +1199,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr,\n                 shorter_fr,\n                 infcx,\n-                mir,\n+                body,\n                 upvars,\n                 mir_def_id,\n                 propagated_outlives_requirements,\n@@ -1216,7 +1216,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1245,7 +1245,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n-                let blame_span_category = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n+                let blame_span_category =\n+                    self.find_outlives_blame_span(body, longer_fr, shorter_fr);\n \n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n@@ -1275,14 +1276,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //\n         // Note: in this case, we use the unapproximated regions to report the\n         // error. This gives better error messages in some cases.\n-        self.report_error(mir, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n+        self.report_error(body, upvars, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         Some(ErrorReported)\n     }\n \n     fn check_bound_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         _mir_def_id: DefId,\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,\n@@ -1330,7 +1331,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let (_, span) = self.find_outlives_blame_span(mir, longer_fr, error_region);\n+        let (_, span) = self.find_outlives_blame_span(body, longer_fr, error_region);\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --"}, {"sha": "cfd80cecca510865849ec3829d0a7e208dce6d36", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -20,9 +20,9 @@ crate struct RegionValueElements {\n }\n \n impl RegionValueElements {\n-    crate fn new(mir: &Body<'_>) -> Self {\n+    crate fn new(body: &Body<'_>) -> Self {\n         let mut num_points = 0;\n-        let statements_before_block: IndexVec<BasicBlock, usize> = mir.basic_blocks()\n+        let statements_before_block: IndexVec<BasicBlock, usize> = body.basic_blocks()\n             .iter()\n             .map(|block_data| {\n                 let v = num_points;\n@@ -37,7 +37,7 @@ impl RegionValueElements {\n         debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n \n         let mut basic_blocks = IndexVec::with_capacity(num_points);\n-        for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n             basic_blocks.extend((0..=bb_data.statements.len()).map(|_| bb));\n         }\n \n@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        mir: &Body<'_>,\n+        body: &Body<'_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {\n@@ -104,9 +104,9 @@ impl RegionValueElements {\n             // If this is a basic block head, then the predecessors are\n             // the terminators of other basic blocks\n             stack.extend(\n-                mir.predecessors_for(block)\n+                body.predecessors_for(block)\n                     .iter()\n-                    .map(|&pred_bb| mir.terminator_loc(pred_bb))\n+                    .map(|&pred_bb| body.terminator_loc(pred_bb))\n                     .map(|pred_loc| self.point_from_location(pred_loc)),\n             );\n         } else {"}, {"sha": "b5fe3d7c8b32934ea127db869d0500b1b0835049", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -6,12 +6,12 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Body<'tcx>) {\n+pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, body: &mut Body<'tcx>) {\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n+    debug!(\"renumber_mir: body.arg_count={:?}\", body.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n-    visitor.visit_body(mir);\n+    visitor.visit_body(body);\n }\n \n /// Replaces all regions appearing in `value` with fresh inference\n@@ -47,12 +47,12 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_body(&mut self, mir: &mut Body<'tcx>) {\n-        for promoted in mir.promoted.iter_mut() {\n+    fn visit_body(&mut self, body: &mut Body<'tcx>) {\n+        for promoted in body.promoted.iter_mut() {\n             self.visit_body(promoted);\n         }\n \n-        self.super_body(mir);\n+        self.super_body(body);\n     }\n \n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {"}, {"sha": "353c5a39b61b90a9aa797438cd877330cdd0e73b", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -20,7 +20,7 @@ use super::{Locations, TypeChecker};\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         universal_regions: &UniversalRegions<'tcx>,\n         normalized_inputs_and_output: &[Ty<'tcx>],\n     ) {\n@@ -43,7 +43,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     // user-provided signature (e.g., the `_` in the code\n                     // above) with fresh variables.\n                     let (poly_sig, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n-                        mir.span,\n+                        body.span,\n                         &user_provided_poly_sig,\n                     );\n \n@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     Some(\n                         self.infcx\n                             .replace_bound_vars_with_fresh_vars(\n-                                mir.span,\n+                                body.span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 &poly_sig,\n                             )\n@@ -73,8 +73,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 normalized_input_ty\n             );\n \n-            let mir_input_ty = mir.local_decls[local].ty;\n-            let mir_input_span = mir.local_decls[local].source_info.span;\n+            let mir_input_ty = body.local_decls[local].ty;\n+            let mir_input_span = body.local_decls[local].source_info.span;\n             self.equate_normalized_input_or_output(\n                 normalized_input_ty,\n                 mir_input_ty,\n@@ -89,8 +89,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // In MIR, closures begin an implicit `self`, so\n                 // argument N is stored in local N+2.\n                 let local = Local::new(argument_index + 2);\n-                let mir_input_ty = mir.local_decls[local].ty;\n-                let mir_input_span = mir.local_decls[local].source_info.span;\n+                let mir_input_ty = body.local_decls[local].ty;\n+                let mir_input_span = body.local_decls[local].source_info.span;\n \n                 // If the user explicitly annotated the input types, enforce those.\n                 let user_provided_input_ty =\n@@ -104,19 +104,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n \n         assert!(\n-            mir.yield_ty.is_some() && universal_regions.yield_ty.is_some()\n-                || mir.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n+            body.yield_ty.is_some() && universal_regions.yield_ty.is_some()\n+                || body.yield_ty.is_none() && universal_regions.yield_ty.is_none()\n         );\n-        if let Some(mir_yield_ty) = mir.yield_ty {\n+        if let Some(mir_yield_ty) = body.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            let yield_span = mir.local_decls[RETURN_PLACE].source_info.span;\n+            let yield_span = body.local_decls[RETURN_PLACE].source_info.span;\n             self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty, yield_span);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n-        let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        let output_span = mir.local_decls[RETURN_PLACE].source_info.span;\n+        let mir_output_ty = body.local_decls[RETURN_PLACE].ty;\n+        let output_span = body.local_decls[RETURN_PLACE].source_info.span;\n         if let Err(terr) = self.eq_opaque_type_and_type(\n             mir_output_ty,\n             normalized_output_ty,"}, {"sha": "2a066538cc234427c27118fcaf0f0f3abdf539a6", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -60,9 +60,9 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        mir: &Body<'_>,\n+        body: &Body<'_>,\n     ) -> Self {\n-        let nones = IndexVec::from_elem_n(None, mir.local_decls.len());\n+        let nones = IndexVec::from_elem_n(None, body.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n             first_def_at: nones.clone(),\n             first_use_at: nones.clone(),\n@@ -71,7 +71,7 @@ impl LocalUseMap {\n         };\n \n         let mut locals_with_use_data: IndexVec<Local, bool> =\n-            IndexVec::from_elem_n(false, mir.local_decls.len());\n+            IndexVec::from_elem_n(false, body.local_decls.len());\n         live_locals\n             .iter()\n             .for_each(|&local| locals_with_use_data[local] = true);\n@@ -81,7 +81,7 @@ impl LocalUseMap {\n             elements,\n             locals_with_use_data,\n         }\n-        .visit_body(mir);\n+        .visit_body(body);\n \n         local_use_map\n     }"}, {"sha": "fb99382e1314ad33cd74c5008c5d33aed27b6026", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -27,7 +27,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'gcx, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -44,7 +44,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n         // of the `live_locals`.\n         // FIXME: Review \"live\" terminology past this point, we should\n         // not be naming the `Local`s as live.\n-        mir.local_decls.indices().collect()\n+        body.local_decls.indices().collect()\n     } else {\n         let free_regions = {\n             regions_that_outlive_free_regions(\n@@ -53,13 +53,13 @@ pub(super) fn generate<'gcx, 'tcx>(\n                 &typeck.borrowck_context.constraints.outlives_constraints,\n             )\n         };\n-        compute_live_locals(typeck.tcx(), &free_regions, mir)\n+        compute_live_locals(typeck.tcx(), &free_regions, body)\n     };\n \n     if !live_locals.is_empty() {\n         trace::trace(\n             typeck,\n-            mir,\n+            body,\n             elements,\n             flow_inits,\n             move_data,\n@@ -77,9 +77,9 @@ pub(super) fn generate<'gcx, 'tcx>(\n fn compute_live_locals(\n     tcx: TyCtxt<'_, '_, 'tcx>,\n     free_regions: &FxHashSet<RegionVid>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n ) -> Vec<Local> {\n-    let live_locals: Vec<Local> = mir\n+    let live_locals: Vec<Local> = body\n         .local_decls\n         .iter_enumerated()\n         .filter_map(|(local, local_decl)| {\n@@ -93,7 +93,7 @@ fn compute_live_locals(\n         })\n         .collect();\n \n-    debug!(\"{} total variables\", mir.local_decls.len());\n+    debug!(\"{} total variables\", body.local_decls.len());\n     debug!(\"{} variables need liveness\", live_locals.len());\n     debug!(\"{} regions outlive free regions\", free_regions.len());\n "}, {"sha": "828cb4cdcd04fab9417897cd0c5effa9aef80ffd", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -32,7 +32,7 @@ use std::rc::Rc;\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -41,11 +41,11 @@ pub(super) fn trace(\n ) {\n     debug!(\"trace()\");\n \n-    let local_use_map = &LocalUseMap::build(&live_locals, elements, mir);\n+    let local_use_map = &LocalUseMap::build(&live_locals, elements, body);\n \n     let cx = LivenessContext {\n         typeck,\n-        mir,\n+        body,\n         flow_inits,\n         elements,\n         local_use_map,\n@@ -72,7 +72,7 @@ where\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    mir: &'me Body<'tcx>,\n+    body: &'me Body<'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,\n@@ -145,7 +145,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n             self.compute_use_live_points_for(local);\n             self.compute_drop_live_points_for(local);\n \n-            let local_ty = self.cx.mir.local_decls[local].ty;\n+            let local_ty = self.cx.body.local_decls[local].ty;\n \n             if !self.use_live_at.is_empty() {\n                 self.cx.add_use_live_facts_for(local_ty, &self.use_live_at);\n@@ -197,7 +197,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n             if self.use_live_at.insert(p) {\n                 self.cx\n                     .elements\n-                    .push_predecessors(self.cx.mir, p, &mut self.stack)\n+                    .push_predecessors(self.cx.body, p, &mut self.stack)\n             }\n         }\n     }\n@@ -220,7 +220,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         // Find the drops where `local` is initialized.\n         for drop_point in self.cx.local_use_map.drops(local) {\n             let location = self.cx.elements.to_location(drop_point);\n-            debug_assert_eq!(self.cx.mir.terminator_loc(location.block), location,);\n+            debug_assert_eq!(self.cx.body.terminator_loc(location.block), location,);\n \n             if self.cx.initialized_at_terminator(location.block, mpi) {\n                 if self.drop_live_at.insert(drop_point) {\n@@ -270,7 +270,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n         debug_assert_eq!(\n-            self.cx.mir.terminator_loc(term_location.block),\n+            self.cx.body.terminator_loc(term_location.block),\n             term_location,\n         );\n         let block = term_location.block;\n@@ -297,7 +297,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n             }\n         }\n \n-        for &pred_block in self.cx.mir.predecessors_for(block).iter() {\n+        for &pred_block in self.cx.body.predecessors_for(block).iter() {\n             debug!(\n                 \"compute_drop_live_points_for_block: pred_block = {:?}\",\n                 pred_block,\n@@ -326,7 +326,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            let pred_term_loc = self.cx.mir.terminator_loc(pred_block);\n+            let pred_term_loc = self.cx.body.terminator_loc(pred_block);\n             let pred_term_point = self.cx.elements.point_from_location(pred_term_loc);\n \n             // If the terminator of this predecessor either *assigns*\n@@ -403,7 +403,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         // the effects of all statements. This is the only way to get\n         // \"just ahead\" of a terminator.\n         self.flow_inits.reset_to_entry_of(block);\n-        for statement_index in 0..self.mir[block].statements.len() {\n+        for statement_index in 0..self.body[block].statements.len() {\n             let location = Location {\n                 block,\n                 statement_index,\n@@ -485,7 +485,7 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n \n         drop_data.dropck_result.report_overflows(\n             self.typeck.infcx.tcx,\n-            self.mir.source_info(*drop_locations.first().unwrap()).span,\n+            self.body.source_info(*drop_locations.first().unwrap()).span,\n             dropped_ty,\n         );\n "}, {"sha": "d6da42c24cee433eac984c6d2dc9f475b0a7f43a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -112,7 +112,7 @@ mod relate_tys;\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -156,14 +156,14 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         infcx,\n         mir_def_id,\n         param_env,\n-        mir,\n+        body,\n         &region_bound_pairs,\n         implicit_region_bound,\n         &mut borrowck_context,\n         &universal_region_relations,\n         |mut cx| {\n-            cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(&mut cx, mir, elements, flow_inits, move_data, location_table);\n+            cx.equate_inputs_and_outputs(body, universal_regions, &normalized_inputs_and_output);\n+            liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(cx.borrowck_context);\n         },\n@@ -179,7 +179,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -188,7 +188,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n ) -> R where {\n     let mut checker = TypeChecker::new(\n         infcx,\n-        mir,\n+        body,\n         mir_def_id,\n         param_env,\n         region_bound_pairs,\n@@ -197,14 +197,14 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n         universal_region_relations,\n     );\n     let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, mir);\n-        verifier.visit_body(mir);\n+        let mut verifier = TypeVerifier::new(&mut checker, body);\n+        verifier.visit_body(body);\n         verifier.errors_reported\n     };\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(mir);\n+        checker.typeck_mir(body);\n     }\n \n     extra(&mut checker)\n@@ -253,7 +253,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n-    mir: &'b Body<'tcx>,\n+    body: &'b Body<'tcx>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -327,7 +327,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.mir, self.tcx());\n+        let rval_ty = rvalue.ty(self.body, self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -368,25 +368,25 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_body(&mut self, mir: &Body<'tcx>) {\n-        self.sanitize_type(&\"return type\", mir.return_ty());\n-        for local_decl in &mir.local_decls {\n+    fn visit_body(&mut self, body: &Body<'tcx>) {\n+        self.sanitize_type(&\"return type\", body.return_ty());\n+        for local_decl in &body.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n         if self.errors_reported {\n             return;\n         }\n-        self.super_body(mir);\n+        self.super_body(body);\n     }\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'b Body<'tcx>) -> Self {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, body: &'b Body<'tcx>) -> Self {\n         TypeVerifier {\n-            mir,\n+            body,\n             mir_def_id: cx.mir_def_id,\n             cx,\n-            last_span: mir.span,\n+            last_span: body.span,\n             errors_reported: false,\n         }\n     }\n@@ -451,7 +451,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         place.iterate(|place_base, place_projection| {\n             let mut place_ty = match place_base {\n                 PlaceBase::Local(index) =>\n-                    PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n+                    PlaceTy::from_ty(self.body.local_decls[*index].ty),\n                 PlaceBase::Static(box Static { kind, ty: sty }) => {\n                     let sty = self.sanitize_type(place, sty);\n                     let check_err =\n@@ -478,10 +478,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                     match kind {\n                         StaticKind::Promoted(promoted) => {\n                             if !self.errors_reported {\n-                                let promoted_mir = &self.mir.promoted[*promoted];\n-                                self.sanitize_promoted(promoted_mir, location);\n+                                let promoted_body = &self.body.promoted[*promoted];\n+                                self.sanitize_promoted(promoted_body, location);\n \n-                                let promoted_ty = promoted_mir.return_ty();\n+                                let promoted_ty = promoted_body.return_ty();\n                                 check_err(self, place, promoted_ty, sty);\n                             }\n                         }\n@@ -538,12 +538,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn sanitize_promoted(&mut self, promoted_mir: &'b Body<'tcx>, location: Location) {\n+    fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n \n-        let parent_mir = mem::replace(&mut self.mir, promoted_mir);\n+        let parent_body = mem::replace(&mut self.body, promoted_body);\n \n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n@@ -562,14 +562,14 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             &mut closure_bounds\n         );\n \n-        self.visit_body(promoted_mir);\n+        self.visit_body(promoted_body);\n \n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n-            self.cx.typeck_mir(promoted_mir);\n+            self.cx.typeck_mir(promoted_body);\n         }\n \n-        self.mir = parent_mir;\n+        self.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n         mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n         mem::swap(\n@@ -632,7 +632,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 )\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).ty;\n+                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.body, tcx).ty;\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::from_ty(\n                         span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n@@ -969,18 +969,18 @@ impl Locations {\n     }\n \n     /// Gets a span representing the location.\n-    pub fn span(&self, mir: &Body<'_>) -> Span {\n+    pub fn span(&self, body: &Body<'_>) -> Span {\n         match self {\n             Locations::All(span) => *span,\n-            Locations::Single(l) => mir.source_info(*l).span,\n+            Locations::Single(l) => body.source_info(*l).span,\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Body<'tcx>,\n+        body: &'a Body<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -992,7 +992,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             infcx,\n             last_span: DUMMY_SP,\n             mir_def_id,\n-            user_type_annotations: &mir.user_type_annotations,\n+            user_type_annotations: &body.user_type_annotations,\n             param_env,\n             region_bound_pairs,\n             implicit_region_bound,\n@@ -1317,7 +1317,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, mir: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n+    fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n@@ -1345,14 +1345,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         ConstraintCategory::Return\n                     },\n                     Place::Base(PlaceBase::Local(l))\n-                        if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n                 };\n \n-                let place_ty = place.ty(mir, tcx).ty;\n-                let rv_ty = rv.ty(mir, tcx);\n+                let place_ty = place.ty(body, tcx).ty;\n+                let rv_ty = rv.ty(body, tcx);\n                 if let Err(terr) =\n                     self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n                 {\n@@ -1386,7 +1386,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                self.check_rvalue(mir, rv, location);\n+                self.check_rvalue(body, rv, location);\n                 if !self.tcx().features().unsized_locals {\n                     let trait_ref = ty::TraitRef {\n                         def_id: tcx.lang_items().sized_trait().unwrap(),\n@@ -1403,7 +1403,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref place,\n                 variant_index,\n             } => {\n-                let place_type = place.ty(mir, tcx).ty;\n+                let place_type = place.ty(body, tcx).ty;\n                 let adt = match place_type.sty {\n                     ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -1425,7 +1425,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 };\n             }\n             StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n-                let place_ty = place.ty(mir, tcx).ty;\n+                let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n@@ -1456,7 +1456,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_terminator(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         term_location: Location,\n     ) {\n@@ -1481,8 +1481,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 target: _,\n                 unwind: _,\n             } => {\n-                let place_ty = location.ty(mir, tcx).ty;\n-                let rv_ty = value.ty(mir, tcx);\n+                let place_ty = location.ty(body, tcx).ty;\n+                let rv_ty = value.ty(body, tcx);\n \n                 let locations = term_location.to_locations();\n                 if let Err(terr) =\n@@ -1503,7 +1503,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 switch_ty,\n                 ..\n             } => {\n-                let discr_ty = discr.ty(mir, tcx);\n+                let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n                     switch_ty,\n@@ -1531,7 +1531,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 from_hir_call,\n                 ..\n             } => {\n-                let func_ty = func.ty(mir, tcx);\n+                let func_ty = func.ty(body, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n                     ty::FnDef(..) | ty::FnPtr(_) => func_ty.fn_sig(tcx),\n@@ -1546,7 +1546,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     &sig,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(mir, term, &sig, destination, term_location);\n+                self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n                     sig.inputs_and_output.iter().map(|ty| ty::Predicate::WellFormed(ty)),\n@@ -1571,28 +1571,28 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         .add_element(region_vid, term_location);\n                 }\n \n-                self.check_call_inputs(mir, term, &sig, args, term_location, from_hir_call);\n+                self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n             }\n             TerminatorKind::Assert {\n                 ref cond, ref msg, ..\n             } => {\n-                let cond_ty = cond.ty(mir, tcx);\n+                let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    if len.ty(mir, tcx) != tcx.types.usize {\n+                    if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n-                    if index.ty(mir, tcx) != tcx.types.usize {\n+                    if index.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n                     }\n                 }\n             }\n             TerminatorKind::Yield { ref value, .. } => {\n-                let value_ty = value.ty(mir, tcx);\n-                match mir.yield_ty {\n+                let value_ty = value.ty(body, tcx);\n+                match body.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n                         if let Err(terr) = self.sub_types(\n@@ -1618,7 +1618,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_call_dest(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         destination: &Option<(Place<'tcx>, BasicBlock)>,\n@@ -1627,7 +1627,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, _target_block)) => {\n-                let dest_ty = dest.ty(mir, tcx).ty;\n+                let dest_ty = dest.ty(body, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                         if let BorrowCheckContext {\n@@ -1649,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     Place::Base(PlaceBase::Local(l))\n-                        if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1687,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_call_inputs(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         args: &[Operand<'tcx>],\n@@ -1706,7 +1706,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in inputs.iter().zip(args).enumerate() {\n-            let op_arg_ty = op_arg.ty(mir, self.tcx());\n+            let op_arg_ty = op_arg.ty(body, self.tcx());\n             let category = if from_hir_call {\n                 ConstraintCategory::CallArgument\n             } else {\n@@ -1728,15 +1728,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_iscleanup(&mut self, mir: &Body<'tcx>, block_data: &BasicBlockData<'tcx>) {\n+    fn check_iscleanup(&mut self, body: &Body<'tcx>, block_data: &BasicBlockData<'tcx>) {\n         let is_cleanup = block_data.is_cleanup;\n         self.last_span = block_data.terminator().source_info.span;\n         match block_data.terminator().kind {\n             TerminatorKind::Goto { target } => {\n-                self.assert_iscleanup(mir, block_data, target, is_cleanup)\n+                self.assert_iscleanup(body, block_data, target, is_cleanup)\n             }\n             TerminatorKind::SwitchInt { ref targets, .. } => for target in targets {\n-                self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n+                self.assert_iscleanup(body, block_data, *target, is_cleanup);\n             },\n             TerminatorKind::Resume => if !is_cleanup {\n                 span_mirbug!(self, block_data, \"resume on non-cleanup block!\")\n@@ -1754,9 +1754,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if is_cleanup {\n                     span_mirbug!(self, block_data, \"yield in cleanup block\")\n                 }\n-                self.assert_iscleanup(mir, block_data, resume, is_cleanup);\n+                self.assert_iscleanup(body, block_data, resume, is_cleanup);\n                 if let Some(drop) = drop {\n-                    self.assert_iscleanup(mir, block_data, drop, is_cleanup);\n+                    self.assert_iscleanup(body, block_data, drop, is_cleanup);\n                 }\n             }\n             TerminatorKind::Unreachable => {}\n@@ -1767,12 +1767,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 cleanup: unwind,\n                 ..\n             } => {\n-                self.assert_iscleanup(mir, block_data, target, is_cleanup);\n+                self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n                         span_mirbug!(self, block_data, \"unwind on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block_data, unwind, true);\n+                    self.assert_iscleanup(body, block_data, unwind, true);\n                 }\n             }\n             TerminatorKind::Call {\n@@ -1781,29 +1781,29 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 if let &Some((_, target)) = destination {\n-                    self.assert_iscleanup(mir, block_data, target, is_cleanup);\n+                    self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 }\n                 if let Some(cleanup) = cleanup {\n                     if is_cleanup {\n                         span_mirbug!(self, block_data, \"cleanup on cleanup block\")\n                     }\n-                    self.assert_iscleanup(mir, block_data, cleanup, true);\n+                    self.assert_iscleanup(body, block_data, cleanup, true);\n                 }\n             }\n             TerminatorKind::FalseEdges {\n                 real_target,\n                 ref imaginary_targets,\n             } => {\n-                self.assert_iscleanup(mir, block_data, real_target, is_cleanup);\n+                self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 for target in imaginary_targets {\n-                    self.assert_iscleanup(mir, block_data, *target, is_cleanup);\n+                    self.assert_iscleanup(body, block_data, *target, is_cleanup);\n                 }\n             }\n             TerminatorKind::FalseUnwind {\n                 real_target,\n                 unwind,\n             } => {\n-                self.assert_iscleanup(mir, block_data, real_target, is_cleanup);\n+                self.assert_iscleanup(body, block_data, real_target, is_cleanup);\n                 if let Some(unwind) = unwind {\n                     if is_cleanup {\n                         span_mirbug!(\n@@ -1812,20 +1812,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             \"cleanup in cleanup block via false unwind\"\n                         );\n                     }\n-                    self.assert_iscleanup(mir, block_data, unwind, true);\n+                    self.assert_iscleanup(body, block_data, unwind, true);\n                 }\n             }\n         }\n     }\n \n     fn assert_iscleanup(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         ctxt: &dyn fmt::Debug,\n         bb: BasicBlock,\n         iscleanuppad: bool,\n     ) {\n-        if mir[bb].is_cleanup != iscleanuppad {\n+        if body[bb].is_cleanup != iscleanuppad {\n             span_mirbug!(\n                 self,\n                 ctxt,\n@@ -1836,8 +1836,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Body<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n-        match mir.local_kind(local) {\n+    fn check_local(&mut self, body: &Body<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n+        match body.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n                 // sized by typeck, but return values of ADT constructors are\n@@ -1938,16 +1938,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_rvalue(&mut self, mir: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+    fn check_rvalue(&mut self, body: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n \n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n-                self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n+                self.check_aggregate_rvalue(body, rvalue, ak, ops, location)\n             }\n \n             Rvalue::Repeat(operand, len) => if *len > 1 {\n-                let operand_ty = operand.ty(mir, tcx);\n+                let operand_ty = operand.ty(body, tcx);\n \n                 let trait_ref = ty::TraitRef {\n                     def_id: tcx.lang_items().copy_trait().unwrap(),\n@@ -1964,7 +1964,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Rvalue::NullaryOp(_, ty) => {\n                 // Even with unsized locals cannot box an unsized value.\n                 if self.tcx().features().unsized_locals {\n-                    let span = mir.source_info(location).span;\n+                    let span = body.source_info(location).span;\n                     self.ensure_place_sized(ty, span);\n                 }\n \n@@ -1983,7 +1983,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Rvalue::Cast(cast_kind, op, ty) => {\n                 match cast_kind {\n                     CastKind::Pointer(PointerCast::ReifyFnPointer) => {\n-                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2012,7 +2012,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::ClosureFnPointer(unsafety)) => {\n-                        let sig = match op.ty(mir, tcx).sty {\n+                        let sig = match op.ty(body, tcx).sty {\n                             ty::Closure(def_id, substs) => {\n                                 substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n                             }\n@@ -2038,7 +2038,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::UnsafeFnPointer) => {\n-                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+                        let fn_sig = op.ty(body, tcx).fn_sig(tcx);\n \n                         // The type that we see in the fcx is like\n                         // `foo::<'a, 'b>`, where `foo` is the path to a\n@@ -2070,7 +2070,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         let &ty = ty;\n                         let trait_ref = ty::TraitRef {\n                             def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n+                            substs: tcx.mk_substs_trait(op.ty(body, tcx), &[ty.into()]),\n                         };\n \n                         self.prove_trait_ref(\n@@ -2081,7 +2081,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     CastKind::Pointer(PointerCast::MutToConstPointer) => {\n-                        let ty_from = match op.ty(mir, tcx).sty {\n+                        let ty_from = match op.ty(body, tcx).sty {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n                                 mutbl: hir::MutMutable,\n@@ -2129,7 +2129,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     CastKind::Misc => {\n-                        if let ty::Ref(_, mut ty_from, _) = op.ty(mir, tcx).sty {\n+                        if let ty::Ref(_, mut ty_from, _) = op.ty(body, tcx).sty {\n                             let (mut ty_to, mutability) = if let ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n                                 mutbl,\n@@ -2140,7 +2140,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                     self,\n                                     rvalue,\n                                     \"invalid cast types {:?} -> {:?}\",\n-                                    op.ty(mir, tcx),\n+                                    op.ty(body, tcx),\n                                     ty,\n                                 );\n                                 return;\n@@ -2196,7 +2196,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n-                self.add_reborrow_constraint(mir, location, region, borrowed_place);\n+                self.add_reborrow_constraint(body, location, region, borrowed_place);\n             }\n \n             Rvalue::BinaryOp(BinOp::Eq, left, right)\n@@ -2205,13 +2205,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             | Rvalue::BinaryOp(BinOp::Le, left, right)\n             | Rvalue::BinaryOp(BinOp::Gt, left, right)\n             | Rvalue::BinaryOp(BinOp::Ge, left, right) => {\n-                let ty_left = left.ty(mir, tcx);\n+                let ty_left = left.ty(body, tcx);\n                 if let ty::RawPtr(_) | ty::FnPtr(_) = ty_left.sty {\n-                    let ty_right = right.ty(mir, tcx);\n+                    let ty_right = right.ty(body, tcx);\n                     let common_ty = self.infcx.next_ty_var(\n                         TypeVariableOrigin {\n                             kind: TypeVariableOriginKind::MiscVariable,\n-                            span: mir.source_info(location).span,\n+                            span: body.source_info(location).span,\n                         }\n                     );\n                     self.sub_types(\n@@ -2277,7 +2277,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_aggregate_rvalue(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         rvalue: &Rvalue<'tcx>,\n         aggregate_kind: &AggregateKind<'tcx>,\n         operands: &[Operand<'tcx>],\n@@ -2306,7 +2306,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     continue;\n                 }\n             };\n-            let operand_ty = operand.ty(mir, tcx);\n+            let operand_ty = operand.ty(body, tcx);\n \n             if let Err(terr) = self.sub_types(\n                 operand_ty,\n@@ -2335,7 +2335,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// - `borrowed_place`: the place `P` being borrowed\n     fn add_reborrow_constraint(\n         &mut self,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n@@ -2382,7 +2382,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             match *elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = base.ty(mir, tcx).ty;\n+                    let base_ty = base.ty(body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2624,15 +2624,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, mir: &Body<'tcx>) {\n-        self.last_span = mir.span;\n-        debug!(\"run_on_mir: {:?}\", mir.span);\n+    fn typeck_mir(&mut self, body: &Body<'tcx>) {\n+        self.last_span = body.span;\n+        debug!(\"run_on_mir: {:?}\", body.span);\n \n-        for (local, local_decl) in mir.local_decls.iter_enumerated() {\n-            self.check_local(mir, local, local_decl);\n+        for (local, local_decl) in body.local_decls.iter_enumerated() {\n+            self.check_local(body, local, local_decl);\n         }\n \n-        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+        for (block, block_data) in body.basic_blocks().iter_enumerated() {\n             let mut location = Location {\n                 block,\n                 statement_index: 0,\n@@ -2641,12 +2641,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 if !stmt.source_info.span.is_dummy() {\n                     self.last_span = stmt.source_info.span;\n                 }\n-                self.check_stmt(mir, stmt, location);\n+                self.check_stmt(body, stmt, location);\n                 location.statement_index += 1;\n             }\n \n-            self.check_terminator(mir, block_data.terminator(), location);\n-            self.check_iscleanup(mir, block_data);\n+            self.check_terminator(body, block_data.terminator(), location);\n+            self.check_iscleanup(body, block_data);\n         }\n     }\n "}, {"sha": "dc4235ea6d09316fe52fbc06438682857e3f8aaf", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -25,7 +25,7 @@ pub(super) enum Control {\n pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     s: &mut S,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n@@ -47,7 +47,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n \n         if places_conflict::borrow_conflicts_with_place(\n             tcx,\n-            mir,\n+            body,\n             &borrowed.borrowed_place,\n             borrowed.kind,\n             place,"}, {"sha": "509bd16d4a080a8c6455498bf7a45c958363773b", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -13,7 +13,7 @@ crate trait PlaceExt<'tcx> {\n     fn ignore_borrow(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n         ) -> bool;\n }\n@@ -22,7 +22,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn ignore_borrow(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         self.iterate(|place_base, place_projection| {\n@@ -40,7 +40,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                         LocalsStateAtExit::AllAreInvalidated => false,\n                         LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n                             let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                                mir.local_decls[*index].mutability == Mutability::Not;\n+                                body.local_decls[*index].mutability == Mutability::Not;\n                             debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n                             ignore\n                         }\n@@ -55,7 +55,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             for proj in place_projection {\n                 if proj.elem == ProjectionElem::Deref {\n-                    let ty = proj.base.ty(mir, tcx).ty;\n+                    let ty = proj.base.ty(body, tcx).ty;\n                     match ty.sty {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and"}, {"sha": "a9ee0a65e3af6a93363fe91a31a1be79254dd16f", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -26,14 +26,14 @@ crate enum PlaceConflictBias {\n /// dataflow).\n crate fn places_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n     bias: PlaceConflictBias,\n ) -> bool {\n     borrow_conflicts_with_place(\n         tcx,\n-        mir,\n+        body,\n         borrow_place,\n         BorrowKind::Mut { allow_two_phase_borrow: true },\n         access_place,\n@@ -48,7 +48,7 @@ crate fn places_conflict<'gcx, 'tcx>(\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: &Place<'tcx>,\n@@ -72,7 +72,7 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n         access_place.iterate(|access_base, access_projections| {\n             place_components_conflict(\n                 tcx,\n-                mir,\n+                body,\n                 (borrow_base, borrow_projections),\n                 borrow_kind,\n                 (access_base, access_projections),\n@@ -85,7 +85,7 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n \n fn place_components_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n     access_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n@@ -175,7 +175,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 // check whether the components being borrowed vs\n                 // accessed are disjoint (as in the second example,\n                 // but not the first).\n-                match place_projection_conflict(tcx, mir, borrow_c, access_c, bias) {\n+                match place_projection_conflict(tcx, body, borrow_c, access_c, bias) {\n                     Overlap::Arbitrary => {\n                         // We have encountered different fields of potentially\n                         // the same union - the borrow now partially overlaps.\n@@ -214,7 +214,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n \n                 let base = &borrow_c.base;\n                 let elem = &borrow_c.elem;\n-                let base_ty = base.ty(mir, tcx).ty;\n+                let base_ty = base.ty(body, tcx).ty;\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n@@ -367,7 +367,7 @@ fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n // between `elem1` and `elem2`.\n fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,\n     bias: PlaceConflictBias,\n@@ -384,7 +384,7 @@ fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = pi1.base.ty(mir, tcx).ty;\n+                let ty = pi1.base.ty(body, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck."}, {"sha": "416de1c67e727c311866d92f22088b416fa8677c", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n \n \n pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Body<'tcx>,\n+    body: &'cx Body<'tcx>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     kind: PrefixSet,\n     next: Option<&'cx Place<'tcx>>,\n@@ -68,7 +68,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         Prefixes {\n             next: Some(place),\n             kind,\n-            mir: self.mir,\n+            body: self.body,\n             tcx: self.infcx.tcx,\n         }\n     }\n@@ -139,7 +139,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n             // derefs, except we stop at the deref of a shared\n             // reference.\n \n-            let ty = proj.base.ty(self.mir, self.tcx).ty;\n+            let ty = proj.base.ty(self.body, self.tcx).ty;\n             match ty.sty {\n                 ty::RawPtr(_) |\n                 ty::Ref("}, {"sha": "7b2f662c7033d1ef4e584933a31617089bb4e20c", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 never_initialized_mut_locals: &mut never_initialized_mut_locals,\n                 mbcx: self,\n             };\n-            visitor.visit_body(visitor.mbcx.mir);\n+            visitor.visit_body(visitor.mbcx.body);\n         }\n \n         // Take the union of the existed `used_mut` set with those variables we've found were"}, {"sha": "65ece3fa82ff829e620c3ba505e9eb2bb157610a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -66,7 +66,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n \n     tcx.infer_ctxt().enter(|infcx| {\n         let cx = Cx::new(&infcx, id);\n-        let mut mir = if cx.tables().tainted_by_errors {\n+        let mut body = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n@@ -165,19 +165,19 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'\n         // Convert the `mir::Body` to global types.\n         let mut globalizer = GlobalizeMir {\n             tcx,\n-            span: mir.span\n+            span: body.span\n         };\n-        globalizer.visit_body(&mut mir);\n-        let mir = unsafe {\n-            mem::transmute::<Body<'_>, Body<'tcx>>(mir)\n+        globalizer.visit_body(&mut body);\n+        let body = unsafe {\n+            mem::transmute::<Body<'_>, Body<'tcx>>(body)\n         };\n \n         mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n-                           MirSource::item(def_id), &mir, |_, _| Ok(()) );\n+                           MirSource::item(def_id), &body, |_, _| Ok(()) );\n \n-        lints::check(tcx, &mir, def_id);\n+        lints::check(tcx, &body, def_id);\n \n-        mir\n+        body\n     })\n }\n \n@@ -700,9 +700,9 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     info!(\"fn_id {:?} has attrs {:?}\", fn_def_id,\n           tcx.get_attrs(fn_def_id));\n \n-    let mut mir = builder.finish(yield_ty);\n-    mir.spread_arg = spread_arg;\n-    mir\n+    let mut body = builder.finish(yield_ty);\n+    body.spread_arg = spread_arg;\n+    body\n }\n \n fn construct_const<'a, 'gcx, 'tcx>("}, {"sha": "b938e86ffad16c5458c04a812914a33b0a36e75c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -55,12 +55,12 @@ pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n-    mir: &'mir mir::Body<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = mk_eval_cx(tcx, span, param_env);\n-    eval_body_using_ecx(&mut ecx, cid, mir, param_env)\n+    eval_body_using_ecx(&mut ecx, cid, body, param_env)\n }\n \n fn mplace_to_const<'tcx>(\n@@ -139,23 +139,23 @@ fn op_to_const<'tcx>(\n fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n-    mir: &'mir mir::Body<'tcx>,\n+    body: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> InterpResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n-    let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n+    let layout = ecx.layout_of(body.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack);\n \n     let name = ty::tls::with(|tcx| tcx.def_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n     trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n-    assert!(mir.arg_count == 0);\n+    assert!(body.arg_count == 0);\n     ecx.push_stack_frame(\n         cid.instance,\n-        mir.span,\n-        mir,\n+        body.span,\n+        body,\n         Some(ret.into()),\n         StackPopCleanup::None { cleanup: false },\n     )?;\n@@ -165,7 +165,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n     // Intern the result\n     let mutability = if tcx.is_mutable_static(cid.instance.def_id()) ||\n-                     !layout.ty.is_freeze(tcx, param_env, mir.span) {\n+                     !layout.ty.is_freeze(tcx, param_env, body.span) {\n         Mutability::Mutable\n     } else {\n         Mutability::Immutable\n@@ -354,7 +354,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def) {\n-            Ok(mir) => mir,\n+            Ok(body) => body,\n             Err(err) => {\n                 if let InterpError::NoMirFor(ref path) = err.kind {\n                     return Err(\n@@ -628,14 +628,14 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n     let mut ecx = InterpretCx::new(tcx.at(span), key.param_env, CompileTimeInterpreter::new());\n \n     let res = ecx.load_mir(cid.instance.def);\n-    res.map(|mir| {\n+    res.map(|body| {\n         if let Some(index) = cid.promoted {\n-            &mir.promoted[index]\n+            &body.promoted[index]\n         } else {\n-            mir\n+            body\n         }\n     }).and_then(\n-        |mir| eval_body_using_ecx(&mut ecx, cid, mir, key.param_env)\n+        |body| eval_body_using_ecx(&mut ecx, cid, body, key.param_env)\n     ).and_then(|place| {\n         Ok(RawConst {\n             alloc_id: place.to_ptr().expect(\"we allocated this ptr!\").alloc_id,"}, {"sha": "b77fdcdd7b6de6896d2827b0f2a2cb6a69cd8420", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -47,9 +47,9 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n //\n // FIXME: we have to do something for moving slice patterns.\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                            mir: &Body<'tcx>,\n+                                                            body: &Body<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n-    let ty = place.ty(mir, tcx).ty;\n+    let ty = place.ty(body, tcx).ty;\n     match ty.sty {\n         ty::Array(..) => {\n             debug!(\"place_contents_drop_state_cannot_differ place: {:?} ty: {:?} => false\",\n@@ -74,7 +74,7 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n \n pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n     each_child: F)\n@@ -85,63 +85,63 @@ pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n             // access to untracked value - do not touch children\n         }\n         LookupResult::Exact(e) => {\n-            on_all_children_bits(tcx, mir, move_data, e, each_child)\n+            on_all_children_bits(tcx, body, move_data, e, each_child)\n         }\n     }\n }\n \n pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n     fn is_terminal_path<'a, 'gcx, 'tcx>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n     {\n         place_contents_drop_state_cannot_differ(\n-            tcx, mir, &move_data.move_paths[path].place)\n+            tcx, body, &move_data.move_paths[path].place)\n     }\n \n     fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &Body<'tcx>,\n+        body: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n         each_child: &mut F)\n         where F: FnMut(MovePathIndex)\n     {\n         each_child(move_path_index);\n \n-        if is_terminal_path(tcx, mir, move_data, move_path_index) {\n+        if is_terminal_path(tcx, body, move_data, move_path_index) {\n             return\n         }\n \n         let mut next_child_index = move_data.move_paths[move_path_index].first_child;\n         while let Some(child_index) = next_child_index {\n-            on_all_children_bits(tcx, mir, move_data, child_index, each_child);\n+            on_all_children_bits(tcx, body, move_data, child_index, each_child);\n             next_child_index = move_data.move_paths[child_index].next_sibling;\n         }\n     }\n-    on_all_children_bits(tcx, mir, move_data, move_path_index, &mut each_child);\n+    on_all_children_bits(tcx, body, move_data, move_path_index, &mut each_child);\n }\n \n pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n-    on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n+    on_all_children_bits(tcx, body, &ctxt.move_data, path, |child| {\n         let place = &ctxt.move_data.move_paths[path].place;\n-        let ty = place.ty(mir, tcx).ty;\n+        let ty = place.ty(body, tcx).ty;\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();\n@@ -156,24 +156,24 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)\n {\n     let move_data = &ctxt.move_data;\n-    for arg in mir.args_iter() {\n+    for arg in body.args_iter() {\n         let place = mir::Place::Base(mir::PlaceBase::Local(arg));\n         let lookup_result = move_data.rev_lookup.find(&place);\n-        on_lookup_result_bits(tcx, mir, move_data,\n+        on_lookup_result_bits(tcx, body, move_data,\n                               lookup_result,\n                               |mpi| callback(mpi, DropFlagState::Present));\n     }\n }\n \n pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n     mut callback: F)\n@@ -187,7 +187,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n         let path = mi.move_path_index(move_data);\n         debug!(\"moving out of path {:?}\", move_data.move_paths[path]);\n \n-        on_all_children_bits(tcx, mir, move_data,\n+        on_all_children_bits(tcx, body, move_data,\n                              path,\n                              |mpi| callback(mpi, DropFlagState::Absent))\n     }\n@@ -196,7 +196,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n \n     for_location_inits(\n         tcx,\n-        mir,\n+        body,\n         move_data,\n         loc,\n         |mpi| callback(mpi, DropFlagState::Present)\n@@ -205,7 +205,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,\n     mut callback: F)\n@@ -217,7 +217,7 @@ pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n             InitKind::Deep => {\n                 let path = init.path;\n \n-                on_all_children_bits(tcx, mir, move_data,\n+                on_all_children_bits(tcx, body, move_data,\n                                     path,\n                                     &mut callback)\n             },"}, {"sha": "f62ad2fbef71f06bcd8d3d8e7cac5f55440f761f", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -17,7 +17,7 @@ use super::DebugFormatted;\n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation<'tcx>;\n     fn def_id(&self) -> DefId;\n-    fn mir(&self) -> &Body<'tcx>;\n+    fn body(&self) -> &Body<'tcx>;\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n }\n \n@@ -26,7 +26,7 @@ impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n {\n     type BD = BD;\n     fn def_id(&self) -> DefId { self.def_id }\n-    fn mir(&self) -> &Body<'tcx> { self.flow_state.mir() }\n+    fn body(&self) -> &Body<'tcx> { self.flow_state.body() }\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> { &self.flow_state.flow_state }\n }\n \n@@ -59,8 +59,8 @@ pub type Node = BasicBlock;\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct Edge { source: BasicBlock, index: usize }\n \n-fn outgoing(mir: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n-    (0..mir[bb].terminator().successors().count())\n+fn outgoing(body: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n+    (0..body[bb].terminator().successors().count())\n         .map(|index| Edge { source: bb, index: index}).collect()\n }\n \n@@ -99,7 +99,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n         // | [00-00] | _7 = const Foo::twiddle(move _8) | [0c-00]          | [f3-0f]          |\n         // +---------+----------------------------------+------------------+------------------+\n         let mut v = Vec::new();\n-        self.node_label_internal(n, &mut v, *n, self.mbcx.mir()).unwrap();\n+        self.node_label_internal(n, &mut v, *n, self.mbcx.body()).unwrap();\n         dot::LabelText::html(String::from_utf8(v).unwrap())\n     }\n \n@@ -109,7 +109,7 @@ impl<'a, 'tcx, MWF, P> dot::Labeller<'a> for Graph<'a, 'tcx, MWF, P>\n     }\n \n     fn edge_label(&'a self, e: &Edge) -> dot::LabelText<'a> {\n-        let term = self.mbcx.mir()[e.source].terminator();\n+        let term = self.mbcx.body()[e.source].terminator();\n         let label = &term.kind.fmt_successor_labels()[e.index];\n         dot::LabelText::label(label.clone())\n     }\n@@ -124,7 +124,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                          n: &Node,\n                                          w: &mut W,\n                                          block: BasicBlock,\n-                                         mir: &Body<'_>) -> io::Result<()> {\n+                                         body: &Body<'_>) -> io::Result<()> {\n         // Header rows\n         const HDRS: [&str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n         const HDR_FMT: &str = \"bgcolor=\\\"grey\\\"\";\n@@ -137,8 +137,8 @@ where MWF: MirWithFlowState<'tcx>,\n         write!(w, \"</tr>\")?;\n \n         // Data row\n-        self.node_label_verbose_row(n, w, block, mir)?;\n-        self.node_label_final_row(n, w, block, mir)?;\n+        self.node_label_verbose_row(n, w, block, body)?;\n+        self.node_label_final_row(n, w, block, body)?;\n         write!(w, \"</table>\")?;\n \n         Ok(())\n@@ -149,7 +149,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                             n: &Node,\n                                             w: &mut W,\n                                             block: BasicBlock,\n-                                            mir: &Body<'_>)\n+                                            body: &Body<'_>)\n                                             -> io::Result<()> {\n         let i = n.index();\n \n@@ -175,7 +175,7 @@ where MWF: MirWithFlowState<'tcx>,\n         // MIR statements\n         write!(w, \"<td>\")?;\n         {\n-            let data = &mir[block];\n+            let data = &body[block];\n             for (i, statement) in data.statements.iter().enumerate() {\n                 write!(w, \"{}<br align=\\\"left\\\"/>\",\n                        dot::escape_html(&format!(\"{:3}: {:?}\", i, statement)))?;\n@@ -199,7 +199,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                           n: &Node,\n                                           w: &mut W,\n                                           block: BasicBlock,\n-                                          mir: &Body<'_>)\n+                                          body: &Body<'_>)\n                                           -> io::Result<()> {\n         let i = n.index();\n \n@@ -214,7 +214,7 @@ where MWF: MirWithFlowState<'tcx>,\n         // Terminator\n         write!(w, \"<td>\")?;\n         {\n-            let data = &mir[block];\n+            let data = &body[block];\n             let mut terminator_head = String::new();\n             data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             write!(w, \"{}\", dot::escape_html(&terminator_head))?;\n@@ -241,19 +241,19 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<'_, Node> {\n-        self.mbcx.mir()\n+        self.mbcx.body()\n             .basic_blocks()\n             .indices()\n             .collect::<Vec<_>>()\n             .into()\n     }\n \n     fn edges(&self) -> dot::Edges<'_, Edge> {\n-        let mir = self.mbcx.mir();\n+        let body = self.mbcx.body();\n \n-        mir.basic_blocks()\n+        body.basic_blocks()\n            .indices()\n-           .flat_map(|bb| outgoing(mir, bb))\n+           .flat_map(|bb| outgoing(body, bb))\n            .collect::<Vec<_>>()\n            .into()\n     }\n@@ -263,7 +263,7 @@ impl<'a, 'tcx, MWF, P> dot::GraphWalk<'a> for Graph<'a, 'tcx, MWF, P>\n     }\n \n     fn target(&self, edge: &Edge) -> Node {\n-        let mir = self.mbcx.mir();\n-        *mir[edge.source].terminator().successors().nth(edge.index).unwrap()\n+        let body = self.mbcx.body();\n+        *body[edge.source].terminator().successors().nth(edge.index).unwrap()\n     }\n }"}, {"sha": "a5e1b4ebaafee58d810a1e85c75820d9f16feed2", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -12,25 +12,25 @@ use crate::dataflow::BitDenotation;\n /// immovable generators.\n #[derive(Copy, Clone)]\n pub struct HaveBeenBorrowedLocals<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> HaveBeenBorrowedLocals<'a, 'tcx> {\n-    pub fn new(mir: &'a Body<'tcx>)\n+    pub fn new(body: &'a Body<'tcx>)\n                -> Self {\n-        HaveBeenBorrowedLocals { mir }\n+        HaveBeenBorrowedLocals { body }\n     }\n \n-    pub fn mir(&self) -> &Body<'tcx> {\n-        self.mir\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n     }\n }\n \n impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     type Idx = Local;\n     fn name() -> &'static str { \"has_been_borrowed_locals\" }\n     fn bits_per_block(&self) -> usize {\n-        self.mir.local_decls.len()\n+        self.body.local_decls.len()\n     }\n \n     fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<'_, Local>,\n                         loc: Location) {\n-        let stmt = &self.mir[loc.block].statements[loc.statement_index];\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n \n         BorrowedLocalsVisitor {\n             sets,\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n     fn terminator_effect(&self,\n                          sets: &mut BlockSets<'_, Local>,\n                          loc: Location) {\n-        let terminator = self.mir[loc.block].terminator();\n+        let terminator = self.body[loc.block].terminator();\n         BorrowedLocalsVisitor {\n             sets,\n         }.visit_terminator(terminator, loc);"}, {"sha": "eedb936aed93789450e878b8a38cd2a0aa5f5df8", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -31,7 +31,7 @@ newtype_index! {\n /// borrows in compact bitvectors.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -48,7 +48,7 @@ struct StackEntry {\n }\n \n fn precompute_borrows_out_of_scope<'tcx>(\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n     borrow_index: BorrowIndex,\n@@ -72,7 +72,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n     stack.push(StackEntry {\n         bb: location.block,\n         lo: location.statement_index,\n-        hi: mir[location.block].statements.len(),\n+        hi: body[location.block].statements.len(),\n         first_part_only: false,\n     });\n \n@@ -95,7 +95,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n \n         if !finished_early {\n             // Add successor BBs to the work list, if necessary.\n-            let bb_data = &mir[bb];\n+            let bb_data = &body[bb];\n             assert!(hi == bb_data.statements.len());\n             for &succ_bb in bb_data.terminator.as_ref().unwrap().successors() {\n                 visited.entry(succ_bb)\n@@ -121,7 +121,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n                         stack.push(StackEntry {\n                             bb: succ_bb,\n                             lo: 0,\n-                            hi: mir[succ_bb].statements.len(),\n+                            hi: body[succ_bb].statements.len(),\n                             first_part_only: false,\n                         });\n                         // Insert 0 for this BB, to represent the whole BB\n@@ -136,7 +136,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Body<'tcx>,\n+        body: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n@@ -145,14 +145,14 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             let borrow_region = borrow_data.region.to_region_vid();\n             let location = borrow_set.borrows[borrow_index].reserve_location;\n \n-            precompute_borrows_out_of_scope(mir, &nonlexical_regioncx,\n+            precompute_borrows_out_of_scope(body, &nonlexical_regioncx,\n                                             &mut borrows_out_of_scope_at_location,\n                                             borrow_index, borrow_region, location);\n         }\n \n         Borrows {\n             tcx: tcx,\n-            mir: mir,\n+            body: body,\n             borrow_set: borrow_set.clone(),\n             borrows_out_of_scope_at_location,\n             _nonlexical_regioncx: nonlexical_regioncx,\n@@ -219,7 +219,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             // locations.\n             if places_conflict::places_conflict(\n                 self.tcx,\n-                self.mir,\n+                self.body,\n                 &borrow_data.borrowed_place,\n                 place,\n                 places_conflict::PlaceConflictBias::NoOverlap,\n@@ -257,7 +257,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n     fn statement_effect(&self, sets: &mut BlockSets<'_, BorrowIndex>, location: Location) {\n         debug!(\"Borrows::statement_effect: sets={:?} location={:?}\", sets, location);\n \n-        let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n+        let block = &self.body.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n         let stmt = block.statements.get(location.statement_index).unwrap_or_else(|| {\n@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n-                        self.mir,\n+                        self.body,\n                         &self.borrow_set.locals_state_at_exit,\n                     ) {\n                         return;"}, {"sha": "55ef861d7926efbd46d4c6a87bac9478c54e45f6", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -65,17 +65,17 @@ pub(super) mod borrows;\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Body<'tcx>,\n+               body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n@@ -120,17 +120,17 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Body<'tcx>,\n+               body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeUninitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeUninitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n@@ -174,17 +174,17 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// that would require a dynamic drop-flag at that statement.\n pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Body<'tcx>,\n+               body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        DefinitelyInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n+        DefinitelyInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n@@ -223,17 +223,17 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n /// ```\n pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Body<'tcx>,\n+               body: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        EverInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n+        EverInitializedPlaces { tcx: tcx, body: body, mdpe: mdpe }\n     }\n }\n \n@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 't\n \n     fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 entry_set.insert(path);\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 't\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -307,7 +307,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 't\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -322,7 +322,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 't\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+        on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.insert(mpi); });\n     }\n@@ -342,7 +342,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx,\n         entry_set.insert_all();\n \n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 entry_set.remove(path);\n@@ -354,7 +354,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx,\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -365,7 +365,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx,\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for MaybeUninitializedPlaces<'a, 'gcx,\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 0 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+        on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.remove(mpi); });\n     }\n@@ -398,7 +398,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gc\n         entry_set.clear();\n \n         drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             |path, s| {\n                 assert!(s == DropFlagState::Present);\n                 entry_set.insert(path);\n@@ -410,7 +410,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gc\n                         location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -421,7 +421,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gc\n                          location: Location)\n     {\n         drop_flag_effects_for_location(\n-            self.tcx, self.mir, self.mdpe,\n+            self.tcx, self.body, self.mdpe,\n             location,\n             |path, s| Self::update_bits(sets, path, s)\n         )\n@@ -436,7 +436,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for DefinitelyInitializedPlaces<'a, 'gc\n     ) {\n         // when a call returns successfully, that means we need to set\n         // the bits for that dest_place to 1 (initialized).\n-        on_lookup_result_bits(self.tcx, self.mir, self.move_data(),\n+        on_lookup_result_bits(self.tcx, self.body, self.move_data(),\n                               self.move_data().rev_lookup.find(dest_place),\n                               |mpi| { in_out.insert(mpi); });\n     }\n@@ -450,16 +450,16 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n     }\n \n     fn start_block_effect(&self, entry_set: &mut BitSet<InitIndex>) {\n-        for arg_init in 0..self.mir.arg_count {\n+        for arg_init in 0..self.body.arg_count {\n             entry_set.insert(InitIndex::new(arg_init));\n         }\n     }\n \n     fn statement_effect(&self,\n                         sets: &mut BlockSets<'_, InitIndex>,\n                         location: Location) {\n-        let (_, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[location.block].statements[location.statement_index];\n+        let (_, body, move_data) = (self.tcx, self.body, self.move_data());\n+        let stmt = &body[location.block].statements[location.statement_index];\n         let init_path_map = &move_data.init_path_map;\n         let init_loc_map = &move_data.init_loc_map;\n         let rev_lookup = &move_data.rev_lookup;\n@@ -485,8 +485,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n                          sets: &mut BlockSets<'_, InitIndex>,\n                          location: Location)\n     {\n-        let (mir, move_data) = (self.mir, self.move_data());\n-        let term = mir[location.block].terminator();\n+        let (body, move_data) = (self.body, self.move_data());\n+        let term = body[location.block].terminator();\n         let init_loc_map = &move_data.init_loc_map;\n         debug!(\"terminator {:?} at loc {:?} initializes move_indexes {:?}\",\n                term, location, &init_loc_map[location]);\n@@ -510,7 +510,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n \n         let call_loc = Location {\n             block: call_bb,\n-            statement_index: self.mir[call_bb].statements.len(),\n+            statement_index: self.body[call_bb].statements.len(),\n         };\n         for init_index in &init_loc_map[call_loc] {\n             assert!(init_index.index() < bits_per_block);"}, {"sha": "fed56e987ef4982f0af24d5a469c5b289e1b5e91", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -5,25 +5,25 @@ use crate::dataflow::BitDenotation;\n \n #[derive(Copy, Clone)]\n pub struct MaybeStorageLive<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> MaybeStorageLive<'a, 'tcx> {\n-    pub fn new(mir: &'a Body<'tcx>)\n+    pub fn new(body: &'a Body<'tcx>)\n                -> Self {\n-        MaybeStorageLive { mir }\n+        MaybeStorageLive { body }\n     }\n \n-    pub fn mir(&self) -> &Body<'tcx> {\n-        self.mir\n+    pub fn body(&self) -> &Body<'tcx> {\n+        self.body\n     }\n }\n \n impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     type Idx = Local;\n     fn name() -> &'static str { \"maybe_storage_live\" }\n     fn bits_per_block(&self) -> usize {\n-        self.mir.local_decls.len()\n+        self.body.local_decls.len()\n     }\n \n     fn start_block_effect(&self, _sets: &mut BitSet<Local>) {\n@@ -33,7 +33,7 @@ impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<'_, Local>,\n                         loc: Location) {\n-        let stmt = &self.mir[loc.block].statements[loc.statement_index];\n+        let stmt = &self.body[loc.block].statements[loc.statement_index];\n \n         match stmt.kind {\n             StatementKind::StorageLive(l) => sets.gen(l),"}, {"sha": "8e2068269ceaa883bd72a16ca710f746b406220f", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -122,7 +122,7 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n }\n \n pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 mir: &'a Body<'tcx>,\n+                                                 body: &'a Body<'tcx>,\n                                                  def_id: DefId,\n                                                  attributes: &[ast::Attribute],\n                                                  dead_unwinds: &BitSet<BasicBlock>,\n@@ -132,7 +132,7 @@ pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     where BD: BitDenotation<'tcx> + InitialFlow,\n           P: Fn(&BD, BD::Idx) -> DebugFormatted\n {\n-    let flow_state = DataflowAnalysis::new(mir, dead_unwinds, bd);\n+    let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n     flow_state.run(tcx, def_id, attributes, p)\n }\n \n@@ -195,7 +195,7 @@ impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation<'t\n             self.flow_state.operator.start_block_effect(&mut sets.on_entry);\n         }\n \n-        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n \n             let mut interim_state;\n@@ -231,10 +231,10 @@ impl<'b, 'a: 'b, 'tcx: 'a, BD> PropagationContext<'b, 'a, 'tcx, BD> where BD: Bi\n {\n     fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n         let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n-            WorkQueue::with_all(self.builder.mir.basic_blocks().len());\n-        let mir = self.builder.mir;\n+            WorkQueue::with_all(self.builder.body.basic_blocks().len());\n+        let body = self.builder.body;\n         while let Some(bb) = dirty_queue.pop() {\n-            let bb_data = &mir[bb];\n+            let bb_data = &body[bb];\n             {\n                 let sets = self.builder.flow_state.sets.for_block(bb.index());\n                 debug_assert!(in_out.words().len() == sets.on_entry.words().len());\n@@ -312,15 +312,15 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n         let flow = flow_uninit;\n-        for (bb, _) in traversal::reverse_postorder(self.mir()) {\n+        for (bb, _) in traversal::reverse_postorder(self.body()) {\n             flow.reset_to_entry_of(bb);\n             self.process_basic_block(bb, flow);\n         }\n     }\n \n     fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n-            self.mir()[bb];\n+            self.body()[bb];\n         let mut location = Location { block: bb, statement_index: 0 };\n         for stmt in statements.iter() {\n             flow_state.reconstruct_statement_effect(location);\n@@ -343,13 +343,13 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     // Delegated Hooks: Provide access to the MIR and process the flow state.\n \n-    fn mir(&self) -> &'a Body<'tcx>;\n+    fn body(&self) -> &'a Body<'tcx>;\n }\n \n pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         analysis: &T,\n                                                         result: &DataflowResults<'tcx, T>,\n-                                                        mir: &Body<'tcx>)\n+                                                        body: &Body<'tcx>)\n     -> BitSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n@@ -370,7 +370,7 @@ pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n         }\n \n         // Apply the pre-statement effect of the statement we're evaluating.\n-        if loc.statement_index == mir[loc.block].statements.len() {\n+        if loc.statement_index == body[loc.block].statements.len() {\n             analysis.before_terminator_effect(&mut sets, loc);\n         } else {\n             analysis.before_statement_effect(&mut sets, loc);\n@@ -384,7 +384,7 @@ pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n {\n     flow_state: DataflowState<'tcx, O>,\n     dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n@@ -393,7 +393,7 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n         DataflowResults(self.flow_state)\n     }\n \n-    pub fn mir(&self) -> &'a Body<'tcx> { self.mir }\n+    pub fn body(&self) -> &'a Body<'tcx> { self.body }\n }\n \n pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>) where O: BitDenotation<'tcx>;\n@@ -697,11 +697,11 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n \n impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n {\n-    pub fn new(mir: &'a Body<'tcx>,\n+    pub fn new(body: &'a Body<'tcx>,\n                dead_unwinds: &'a BitSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();\n-        let num_blocks = mir.basic_blocks().len();\n+        let num_blocks = body.basic_blocks().len();\n \n         let on_entry_sets = if D::bottom_value() {\n             vec![BitSet::new_filled(bits_per_block); num_blocks]\n@@ -712,7 +712,7 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n         let kill_sets = gen_sets.clone();\n \n         DataflowAnalysis {\n-            mir,\n+            body,\n             dead_unwinds,\n             flow_state: DataflowState {\n                 sets: AllSets {"}, {"sha": "90e6c46f2817e221af2437bee395857a03d22469", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -13,27 +13,27 @@ use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n \n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(mir: &'a Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(body: &'a Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n \n         MoveDataBuilder {\n-            mir,\n+            body,\n             tcx,\n             errors: Vec::new(),\n             data: MoveData {\n                 moves: IndexVec::new(),\n-                loc_map: LocationMap::new(mir),\n+                loc_map: LocationMap::new(body),\n                 rev_lookup: MovePathLookup {\n-                    locals: mir.local_decls.indices().map(PlaceBase::Local).map(|v| {\n+                    locals: body.local_decls.indices().map(PlaceBase::Local).map(|v| {\n                         Self::new_move_path(\n                             &mut move_paths,\n                             &mut path_map,\n@@ -47,7 +47,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                 move_paths,\n                 path_map,\n                 inits: IndexVec::new(),\n-                init_loc_map: LocationMap::new(mir),\n+                init_loc_map: LocationMap::new(body),\n                 init_path_map,\n             }\n         }\n@@ -104,9 +104,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             };\n \n             for proj in place_projection {\n-                let mir = self.builder.mir;\n+                let body = self.builder.body;\n                 let tcx = self.builder.tcx;\n-                let place_ty = proj.base.ty(mir, tcx).ty;\n+                let place_ty = proj.base.ty(body, tcx).ty;\n                 match place_ty.sty {\n                     ty::Ref(..) | ty::RawPtr(..) =>\n                         return Err(MoveError::cannot_move_out_of(\n@@ -183,11 +183,11 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n         self\n     ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         debug!(\"{}\", {\n-            debug!(\"moves for {:?}:\", self.mir.span);\n+            debug!(\"moves for {:?}:\", self.body.span);\n             for (j, mo) in self.data.moves.iter_enumerated() {\n                 debug!(\"    {:?} = {:?}\", j, mo);\n             }\n-            debug!(\"move paths for {:?}:\", self.mir.span);\n+            debug!(\"move paths for {:?}:\", self.body.span);\n             for (j, path) in self.data.move_paths.iter_enumerated() {\n                 debug!(\"    {:?} = {:?}\", j, path);\n             }\n@@ -203,14 +203,14 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n }\n \n pub(super) fn gather_moves<'a, 'gcx, 'tcx>(\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-    let mut builder = MoveDataBuilder::new(mir, tcx);\n+    let mut builder = MoveDataBuilder::new(body, tcx);\n \n     builder.gather_args();\n \n-    for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+    for (bb, block) in body.basic_blocks().iter_enumerated() {\n         for (i, stmt) in block.statements.iter().enumerate() {\n             let source = Location { block: bb, statement_index: i };\n             builder.gather_statement(source, stmt);\n@@ -228,7 +228,7 @@ pub(super) fn gather_moves<'a, 'gcx, 'tcx>(\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n     fn gather_args(&mut self) {\n-        for arg in self.mir.args_iter() {\n+        for arg in self.body.args_iter() {\n             let path = self.data.rev_lookup.locals[arg];\n \n             let init = self.data.inits.push(Init {\n@@ -429,7 +429,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base,\n                 elem: ProjectionElem::Field(_, _),\n-            }) if match base.ty(self.builder.mir, self.builder.tcx).ty.sty {\n+            }) if match base.ty(self.builder.body, self.builder.tcx).ty.sty {\n                     ty::Adt(def, _) if def.is_union() => true,\n                     _ => false,\n             } => base,"}, {"sha": "7d75d352f94c9b081944aff9d7ea1bb94e8001b1", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -138,9 +138,9 @@ impl<T> IndexMut<Location> for LocationMap<T> {\n }\n \n impl<T> LocationMap<T> where T: Default + Clone {\n-    fn new(mir: &Body<'_>) -> Self {\n+    fn new(body: &Body<'_>) -> Self {\n         LocationMap {\n-            map: mir.basic_blocks().iter().map(|block| {\n+            map: body.basic_blocks().iter().map(|block| {\n                 vec![T::default(); block.statements.len()+1]\n             }).collect()\n         }\n@@ -205,10 +205,10 @@ impl fmt::Debug for Init {\n }\n \n impl Init {\n-    crate fn span<'gcx>(&self, mir: &Body<'gcx>) -> Span {\n+    crate fn span<'gcx>(&self, body: &Body<'gcx>) -> Span {\n         match self.location {\n-            InitLocation::Argument(local) => mir.local_decls[local].source_info.span,\n-            InitLocation::Statement(location) => mir.source_info(location).span,\n+            InitLocation::Argument(local) => body.local_decls[local].source_info.span,\n+            InitLocation::Statement(location) => body.source_info(location).span,\n         }\n     }\n }\n@@ -306,9 +306,9 @@ impl<'tcx> MoveError<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+    pub fn gather_moves(body: &Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                         -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n-        builder::gather_moves(mir, tcx)\n+        builder::gather_moves(body, tcx)\n     }\n \n     /// For the move path `mpi`, returns the root local variable (if any) that starts the path."}, {"sha": "a34889e6f33bc0a62d66777548251d052cf1b553", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -56,7 +56,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The MIR for the function called on this frame.\n-    pub mir: &'mir mir::Body<'tcx>,\n+    pub body: &'mir mir::Body<'tcx>,\n \n     /// The def_id and substs of the current function.\n     pub instance: ty::Instance<'tcx>,\n@@ -252,8 +252,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub(super) fn mir(&self) -> &'mir mir::Body<'tcx> {\n-        self.frame().mir\n+    pub(super) fn body(&self) -> &'mir mir::Body<'tcx> {\n+        self.frame().body\n     }\n \n     pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n@@ -356,7 +356,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         match frame.locals[local].layout.get() {\n             None => {\n                 let layout = crate::interpret::operand::from_known_layout(layout, || {\n-                    let local_ty = frame.mir.local_decls[local].ty;\n+                    let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty = self.monomorphize_with_substs(local_ty, frame.instance.substs);\n                     self.layout_of(local_ty)\n                 })?;\n@@ -475,7 +475,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         span: source_map::Span,\n-        mir: &'mir mir::Body<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n@@ -487,7 +487,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         // first push a stack frame so we have access to the local substs\n         let extra = M::stack_push(self)?;\n         self.stack.push(Frame {\n-            mir,\n+            body,\n             block: mir::START_BLOCK,\n             return_to_block,\n             return_place,\n@@ -501,13 +501,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         });\n \n         // don't allocate at all for trivial constants\n-        if mir.local_decls.len() > 1 {\n+        if body.local_decls.len() > 1 {\n             // Locals are initially uninitialized.\n             let dummy = LocalState {\n                 value: LocalValue::Uninitialized,\n                 layout: Cell::new(None),\n             };\n-            let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n+            let mut locals = IndexVec::from_elem(dummy, &body.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n             locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n@@ -518,8 +518,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                 | Some(DefKind::Const)\n                 | Some(DefKind::AssocConst) => {},\n                 _ => {\n-                    trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n-                    for block in mir.basic_blocks() {\n+                    trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, body.basic_blocks().len());\n+                    for block in body.basic_blocks() {\n                         for stmt in block.statements.iter() {\n                             use rustc::mir::StatementKind::{StorageDead, StorageLive};\n                             match stmt.kind {\n@@ -734,7 +734,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn generate_stacktrace(&self, explicit_span: Option<Span>) -> Vec<FrameInfo<'tcx>> {\n         let mut last_span = None;\n         let mut frames = Vec::new();\n-        for &Frame { instance, span, mir, block, stmt, .. } in self.stack().iter().rev() {\n+        for &Frame { instance, span, body, block, stmt, .. } in self.stack().iter().rev() {\n             // make sure we don't emit frames that are duplicates of the previous\n             if explicit_span == Some(span) {\n                 last_span = Some(span);\n@@ -747,13 +747,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n             } else {\n                 last_span = Some(span);\n             }\n-            let block = &mir.basic_blocks()[block];\n+            let block = &body.basic_blocks()[block];\n             let source_info = if stmt < block.statements.len() {\n                 block.statements[stmt].source_info\n             } else {\n                 block.terminator().source_info\n             };\n-            let lint_root = match mir.source_scope_local_data {\n+            let lint_root = match body.source_scope_local_data {\n                 mir::ClearCrossCrate::Set(ref ivs) => Some(ivs[source_info.scope].lint_root),\n                 mir::ClearCrossCrate::Clear => None,\n             };"}, {"sha": "758230e2b7dcb8c271ed90531de5fc9908ba5784", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -612,7 +612,7 @@ where\n                         PlaceTy {\n                             place: *return_place,\n                             layout: self\n-                                .layout_of(self.monomorphize(self.frame().mir.return_ty())?)?,\n+                                .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n                     None => return err!(InvalidNullPointerUsage),"}, {"sha": "d806caf44151364ba3eede443af5ff62e5dae7ca", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -316,7 +316,7 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n }\n \n impl_stable_hash_for!(impl<'mir, 'tcx: 'mir> for struct Frame<'mir, 'tcx> {\n-    mir,\n+    body,\n     instance,\n     span,\n     return_to_block,\n@@ -334,7 +334,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         let Frame {\n-            mir: _,\n+            body: _,\n             instance,\n             span,\n             return_to_block,"}, {"sha": "9312d71188c97355f86d867e7320face59f613f1", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -51,8 +51,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n \n         let block = self.frame().block;\n         let stmt_id = self.frame().stmt;\n-        let mir = self.mir();\n-        let basic_block = &mir.basic_blocks()[block];\n+        let body = self.body();\n+        let basic_block = &body.basic_blocks()[block];\n \n         let old_frames = self.cur_frame();\n "}, {"sha": "ff8d6804febbd057e5377d25c321dbd8b0e1e34e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -281,15 +281,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 }\n \n                 // We need MIR for this fn\n-                let mir = match M::find_fn(self, instance, args, dest, ret)? {\n-                    Some(mir) => mir,\n+                let body = match M::find_fn(self, instance, args, dest, ret)? {\n+                    Some(body) => body,\n                     None => return Ok(()),\n                 };\n \n                 self.push_stack_frame(\n                     instance,\n                     span,\n-                    mir,\n+                    body,\n                     dest,\n                     StackPopCleanup::Goto(ret),\n                 )?;\n@@ -307,8 +307,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     );\n                     trace!(\n                         \"spread_arg: {:?}, locals: {:#?}\",\n-                        mir.spread_arg,\n-                        mir.args_iter()\n+                        body.spread_arg,\n+                        body.args_iter()\n                             .map(|local|\n                                 (local, self.layout_of_local(self.frame(), local, None).unwrap().ty)\n                             )\n@@ -352,12 +352,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                     // this is a single iterator (that handles `spread_arg`), then\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n-                    let mut locals_iter = mir.args_iter();\n+                    let mut locals_iter = body.args_iter();\n                     while let Some(local) = locals_iter.next() {\n                         let dest = self.eval_place(\n                             &mir::Place::Base(mir::PlaceBase::Local(local))\n                         )?;\n-                        if Some(local) == mir.spread_arg {\n+                        if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n                                 let dest = self.place_field(dest, i as u64)?;"}, {"sha": "e15c8a4b416643c1b807705fe60902e4cf4ee4df", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -8,18 +8,18 @@ use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-             mir: &Body<'tcx>,\n+             body: &Body<'tcx>,\n              def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)) {\n-        check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), mir, def_id);\n+        check_fn_for_unconditional_recursion(tcx, fn_like_node.kind(), body, def_id);\n     }\n }\n \n fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         fn_kind: FnKind<'_>,\n-                                        mir: &Body<'tcx>,\n+                                        body: &Body<'tcx>,\n                                         def_id: DefId) {\n     if let FnKind::Closure(_) = fn_kind {\n         // closures can't recur, so they don't matter.\n@@ -54,7 +54,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // to have behaviour like the above, rather than\n     // e.g., accidentally recursing after an assert.\n \n-    let basic_blocks = mir.basic_blocks();\n+    let basic_blocks = body.basic_blocks();\n     let mut reachable_without_self_call_queue = vec![mir::START_BLOCK];\n     let mut reached_exit_without_self_call = false;\n     let mut self_call_locations = vec![];\n@@ -84,7 +84,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let Some(ref terminator) = block.terminator {\n             match terminator.kind {\n                 TerminatorKind::Call { ref func, .. } => {\n-                    let func_ty = func.ty(mir, tcx);\n+                    let func_ty = func.ty(body, tcx);\n \n                     if let ty::FnDef(fn_def_id, substs) = func_ty.sty {\n                         let (call_fn_id, call_substs) ="}, {"sha": "f084919ac057c0c50d355680afb384c39a5f8c3c", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -516,7 +516,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a mir::Body<'tcx>,\n+    body: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: SubstsRef<'tcx>,\n }\n@@ -538,7 +538,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     ty::ParamEnv::reveal_all(),\n                     &target_ty,\n                 );\n-                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = operand.ty(self.body, self.tcx);\n                 let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::Rvalue::Cast(\n                 mir::CastKind::Pointer(PointerCast::ReifyFnPointer), ref operand, _\n             ) => {\n-                let fn_ty = operand.ty(self.mir, self.tcx);\n+                let fn_ty = operand.ty(self.body, self.tcx);\n                 let fn_ty = self.tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::Rvalue::Cast(\n                 mir::CastKind::Pointer(PointerCast::ClosureFnPointer(_)), ref operand, _\n             ) => {\n-                let source_ty = operand.ty(self.mir, self.tcx);\n+                let source_ty = operand.ty(self.body, self.tcx);\n                 let source_ty = self.tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),\n@@ -621,7 +621,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let tcx = self.tcx;\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n-                let callee_ty = func.ty(self.mir, tcx);\n+                let callee_ty = func.ty(self.body, tcx);\n                 let callee_ty = tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),\n@@ -631,7 +631,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.tcx).ty;\n+                let ty = location.ty(self.body, self.tcx).ty;\n                 let ty = tcx.subst_and_normalize_erasing_regions(\n                     self.param_substs,\n                     ty::ParamEnv::reveal_all(),\n@@ -1211,16 +1211,16 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 instance: Instance<'tcx>,\n                                 output: &mut Vec<MonoItem<'tcx>>)\n {\n-    let mir = tcx.instance_mir(instance.def);\n+    let body = tcx.instance_mir(instance.def);\n \n     MirNeighborCollector {\n         tcx,\n-        mir: &mir,\n+        body: &body,\n         output,\n         param_substs: instance.substs,\n-    }.visit_body(&mir);\n+    }.visit_body(&body);\n     let param_env = ty::ParamEnv::reveal_all();\n-    for i in 0..mir.promoted.len() {\n+    for i in 0..body.promoted.len() {\n         use rustc_data_structures::indexed_vec::Idx;\n         let i = Promoted::new(i);\n         let cid = GlobalId {\n@@ -1231,7 +1231,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Ok(val) => collect_const(tcx, val, instance.substs, output),\n             Err(ErrorHandled::Reported) => {},\n             Err(ErrorHandled::TooGeneric) => span_bug!(\n-                mir.promoted[i].span, \"collection encountered polymorphic constant\",\n+                body.promoted[i].span, \"collection encountered polymorphic constant\",\n             ),\n         }\n     }"}, {"sha": "0f2196b5da6beb532eccfb35832c2ab0cd23e1b4", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -175,8 +175,8 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Check if this is a generator, if so, return the drop glue for it\n     if let Some(&ty::TyS { sty: ty::Generator(gen_def_id, substs, _), .. }) = ty {\n-        let mir = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n-        return mir.subst(tcx, substs.substs);\n+        let body = &**tcx.optimized_mir(gen_def_id).generator_drop.as_ref().unwrap();\n+        return body.subst(tcx, substs.substs);\n     }\n \n     let substs = if let Some(ty) = ty {\n@@ -202,7 +202,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let mut mir = Body::new(\n+    let mut body = Body::new(\n         blocks,\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -223,16 +223,16 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let dropee_ptr = Place::Base(PlaceBase::Local(Local::new(1+0)));\n         if tcx.sess.opts.debugging_opts.mir_emit_retag {\n             // Function arguments should be retagged, and we make this one raw.\n-            mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+            body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n                 source_info,\n                 kind: StatementKind::Retag(RetagKind::Raw, dropee_ptr.clone()),\n             });\n         }\n         let patch = {\n             let param_env = tcx.param_env(def_id).with_reveal_all();\n             let mut elaborator = DropShimElaborator {\n-                mir: &mir,\n-                patch: MirPatch::new(&mir),\n+                body: &body,\n+                patch: MirPatch::new(&body),\n                 tcx,\n                 param_env\n             };\n@@ -249,14 +249,14 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             );\n             elaborator.patch\n         };\n-        patch.apply(&mut mir);\n+        patch.apply(&mut body);\n     }\n \n-    mir\n+    body\n }\n \n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n-    pub mir: &'a Body<'tcx>,\n+    pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     type Path = ();\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n-    fn mir(&self) -> &'a Body<'tcx> { self.mir }\n+    fn body(&self) -> &'a Body<'tcx> { self.body }\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n@@ -821,7 +821,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut mir = Body::new(\n+    let mut body = Body::new(\n         blocks,\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -837,9 +837,9 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         vec![],\n     );\n     if let Abi::RustCall = sig.abi {\n-        mir.spread_arg = Some(Local::new(sig.inputs().len()));\n+        body.spread_arg = Some(Local::new(sig.inputs().len()));\n     }\n-    mir\n+    body\n }\n \n pub fn build_adt_ctor<'gcx>(tcx: TyCtxt<'_, 'gcx, 'gcx>, ctor_id: DefId) -> &'gcx Body<'gcx> {"}, {"sha": "40af3579766363923d002425c503bbec375616d3", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -34,22 +34,22 @@ impl MirPass for AddCallGuards {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        self.add_call_guards(mir);\n+                          body: &mut Body<'tcx>) {\n+        self.add_call_guards(body);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, mir: &mut Body<'_>) {\n+    pub fn add_call_guards(&self, body: &mut Body<'_>) {\n         let pred_count: IndexVec<_, _> =\n-            mir.predecessors().iter().map(|ps| ps.len()).collect();\n+            body.predecessors().iter().map(|ps| ps.len()).collect();\n \n         // We need a place to store the new blocks generated\n         let mut new_blocks = Vec::new();\n \n-        let cur_len = mir.basic_blocks().len();\n+        let cur_len = body.basic_blocks().len();\n \n-        for block in mir.basic_blocks_mut() {\n+        for block in body.basic_blocks_mut() {\n             match block.terminator {\n                 Some(Terminator {\n                     kind: TerminatorKind::Call {\n@@ -81,6 +81,6 @@ impl AddCallGuards {\n \n         debug!(\"Broke {} N edges\", new_blocks.len());\n \n-        mir.basic_blocks_mut().extend(new_blocks);\n+        body.basic_blocks_mut().extend(new_blocks);\n     }\n }"}, {"sha": "23f5e636b7f8a56351e1e5807ba8b013e0f63615", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -43,40 +43,40 @@ impl MirPass for AddMovesForPackedDrops {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>)\n+                          body: &mut Body<'tcx>)\n     {\n-        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, mir.span);\n-        add_moves_for_packed_drops(tcx, mir, src.def_id());\n+        debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, body.span);\n+        add_moves_for_packed_drops(tcx, body, src.def_id());\n     }\n }\n \n pub fn add_moves_for_packed_drops<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Body<'tcx>,\n+    body: &mut Body<'tcx>,\n     def_id: DefId)\n {\n-    let patch = add_moves_for_packed_drops_patch(tcx, mir, def_id);\n-    patch.apply(mir);\n+    let patch = add_moves_for_packed_drops_patch(tcx, body, def_id);\n+    patch.apply(body);\n }\n \n fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     def_id: DefId)\n     -> MirPatch<'tcx>\n {\n-    let mut patch = MirPatch::new(mir);\n+    let mut patch = MirPatch::new(body);\n     let param_env = tcx.param_env(def_id);\n \n-    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n         let loc = Location { block: bb, statement_index: data.statements.len() };\n         let terminator = data.terminator();\n \n         match terminator.kind {\n             TerminatorKind::Drop { ref location, .. }\n-                if util::is_disaligned(tcx, mir, param_env, location) =>\n+                if util::is_disaligned(tcx, body, param_env, location) =>\n             {\n-                add_move_for_packed_drop(tcx, mir, &mut patch, terminator,\n+                add_move_for_packed_drop(tcx, body, &mut patch, terminator,\n                                          loc, data.is_cleanup);\n             }\n             TerminatorKind::DropAndReplace { .. } => {\n@@ -92,7 +92,7 @@ fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n \n fn add_move_for_packed_drop<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,\n     loc: Location,\n@@ -106,7 +106,7 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n     };\n \n     let source_info = terminator.source_info;\n-    let ty = location.ty(mir, tcx).ty;\n+    let ty = location.ty(body, tcx).ty;\n     let temp = patch.new_temp(ty, terminator.source_info.span);\n \n     let storage_dead_block = patch.new_block(BasicBlockData {"}, {"sha": "bea95bcd567adcc46103110e519016518002b9de", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -77,13 +77,13 @@ impl MirPass for AddRetag {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>)\n+                          body: &mut Body<'tcx>)\n     {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;\n         }\n-        let (span, arg_count) = (mir.span, mir.arg_count);\n-        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let (span, arg_count) = (body.span, body.arg_count);\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let needs_retag = |place: &Place<'tcx>| {\n             // FIXME: Instead of giving up for unstable places, we should introduce\n             // a temporary and retag on that."}, {"sha": "87581c530b9d735d8b78e961f0fbe946ebfacf8c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -19,7 +19,7 @@ use std::ops::Bound;\n use crate::util;\n \n pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     const_context: bool,\n     min_const_fn: bool,\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn new(\n         const_context: bool,\n         min_const_fn: bool,\n-        mir: &'a Body<'tcx>,\n+        body: &'a Body<'tcx>,\n         source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -46,13 +46,13 @@ impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             assert!(const_context);\n         }\n         Self {\n-            mir,\n+            body,\n             const_context,\n             min_const_fn,\n             source_scope_local_data,\n             violations: vec![],\n             source_info: SourceInfo {\n-                span: mir.span,\n+                span: body.span,\n                 scope: OUTERMOST_SOURCE_SCOPE\n             },\n             tcx,\n@@ -87,7 +87,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             TerminatorKind::Call { ref func, .. } => {\n-                let func_ty = func.ty(self.mir, self.tcx);\n+                let func_ty = func.ty(self.body, self.tcx);\n                 let sig = func_ty.fn_sig(self.tcx);\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n                     self.require_unsafe(\"call to unsafe function\",\n@@ -159,7 +159,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             // pointers during const evaluation have no integral address, only an abstract one\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty)\n             if self.const_context && self.tcx.features().const_raw_ptr_to_usize_cast => {\n-                let operand_ty = operand.ty(self.mir, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -182,7 +182,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             // result of a comparison of addresses would differ between runtime and compile-time.\n             Rvalue::BinaryOp(_, ref lhs, _)\n             if self.const_context && self.tcx.features().const_compare_raw_pointers => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.mir, self.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).sty {\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info: self.source_info,\n                         description: InternedString::intern(\"pointer operation\"),\n@@ -233,7 +233,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n \n             for proj in place_projections {\n                 if context.is_borrow() {\n-                    if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n+                    if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n                         let source_info = self.source_info;\n                         let lint_root =\n                             self.source_scope_local_data[source_info.scope].lint_root;\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }\n                 }\n                 let is_borrow_of_interior_mut = context.is_borrow() && !proj.base\n-                    .ty(self.mir, self.tcx)\n+                    .ty(self.body, self.tcx)\n                     .ty\n                     .is_freeze(self.tcx, self.param_env, self.source_info.span);\n                 // prevent\n@@ -265,14 +265,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 let old_source_info = self.source_info;\n                 if let Place::Base(PlaceBase::Local(local)) = proj.base {\n-                    if self.mir.local_decls[local].internal {\n+                    if self.body.local_decls[local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.mir.local_decls[local].source_info;\n+                        self.source_info = self.body.local_decls[local].source_info;\n                     }\n                 }\n-                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                 match base_ty.sty {\n                     ty::RawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\",\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         }) = place {\n             match *elem {\n                 ProjectionElem::Field(..) => {\n-                    let ty = base.ty(&self.mir.local_decls, self.tcx).ty;\n+                    let ty = base.ty(&self.body.local_decls, self.tcx).ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n                             (Bound::Unbounded, Bound::Unbounded) => {},\n@@ -512,9 +512,9 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     // N.B., this borrow is valid because all the consumers of\n     // `mir_built` force this.\n-    let mir = &tcx.mir_built(def_id).borrow();\n+    let body = &tcx.mir_built(def_id).borrow();\n \n-    let source_scope_local_data = match mir.source_scope_local_data {\n+    let source_scope_local_data = match body.source_scope_local_data {\n         ClearCrossCrate::Set(ref data) => data,\n         ClearCrossCrate::Clear => {\n             debug!(\"unsafety_violations: {:?} - remote, skipping\", def_id);\n@@ -536,8 +536,8 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     };\n     let mut checker = UnsafetyChecker::new(\n         const_context, min_const_fn,\n-        mir, source_scope_local_data, tcx, param_env);\n-    checker.visit_body(mir);\n+        body, source_scope_local_data, tcx, param_env);\n+    checker.visit_body(body);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n     UnsafetyCheckResult {"}, {"sha": "2bbd6ff21047b5632272907061ef1f618d4e4192", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -30,9 +30,9 @@ impl MirPass for CleanupNonCodegenStatements {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;\n-        delete.visit_body(mir);\n+        delete.visit_body(body);\n     }\n }\n "}, {"sha": "b112643e2cd4ab77eee88147ed43ed50c72e7e3c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -34,7 +34,7 @@ impl MirPass for ConstProp {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -63,16 +63,16 @@ impl MirPass for ConstProp {\n         // constants, instead of just checking for const-folding succeeding.\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n-        let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n-        optimization_finder.visit_body(mir);\n+        let mut optimization_finder = ConstPropagator::new(body, tcx, source);\n+        optimization_finder.visit_body(body);\n \n         // put back the data we stole from `mir`\n         std::mem::replace(\n-            &mut mir.source_scope_local_data,\n+            &mut body.source_scope_local_data,\n             optimization_finder.source_scope_local_data\n         );\n         std::mem::replace(\n-            &mut mir.promoted,\n+            &mut body.promoted,\n             optimization_finder.promoted\n         );\n \n@@ -120,19 +120,19 @@ impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n \n impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n-        mir: &mut Body<'tcx>,\n+        body: &mut Body<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n         let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n-        let can_const_prop = CanConstProp::check(mir);\n+        let can_const_prop = CanConstProp::check(body);\n         let source_scope_local_data = std::mem::replace(\n-            &mut mir.source_scope_local_data,\n+            &mut body.source_scope_local_data,\n             ClearCrossCrate::Clear\n         );\n         let promoted = std::mem::replace(\n-            &mut mir.promoted,\n+            &mut body.promoted,\n             IndexVec::new()\n         );\n \n@@ -142,10 +142,10 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             source,\n             param_env,\n             can_const_prop,\n-            places: IndexVec::from_elem(None, &mir.local_decls),\n+            places: IndexVec::from_elem(None, &body.local_decls),\n             source_scope_local_data,\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n-            local_decls: mir.local_decls.clone(),\n+            local_decls: body.local_decls.clone(),\n             promoted,\n         }\n     }\n@@ -315,8 +315,8 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     // cannot use `const_eval` here, because that would require having the MIR\n                     // for the current function available, but we're producing said MIR right now\n                     let res = self.use_ecx(source_info, |this| {\n-                        let mir = &this.promoted[*promoted];\n-                        eval_promoted(this.tcx, cid, mir, this.param_env)\n+                        let body = &this.promoted[*promoted];\n+                        eval_promoted(this.tcx, cid, body, this.param_env)\n                     })?;\n                     trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n                     res.into()\n@@ -613,24 +613,24 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(mir: &Body<'_>) -> IndexVec<Local, bool> {\n+    fn check(body: &Body<'_>) -> IndexVec<Local, bool> {\n         let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(true, &mir.local_decls),\n-            found_assignment: IndexVec::from_elem(false, &mir.local_decls),\n+            can_const_prop: IndexVec::from_elem(true, &body.local_decls),\n+            found_assignment: IndexVec::from_elem(false, &body.local_decls),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             // cannot use args at all\n             // cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            *val = mir.local_kind(local) == LocalKind::Temp;\n+            *val = body.local_kind(local) == LocalKind::Temp;\n \n             if !*val {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n             }\n         }\n-        cpv.visit_body(mir);\n+        cpv.visit_body(body);\n         cpv.can_const_prop\n     }\n }"}, {"sha": "45b3fb79dd9fa70dc0d048cb1eae8e810f1e7662", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -33,23 +33,23 @@ impl MirPass for CopyPropagation {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n             return;\n         }\n \n-        let mut def_use_analysis = DefUseAnalysis::new(mir);\n+        let mut def_use_analysis = DefUseAnalysis::new(body);\n         loop {\n-            def_use_analysis.analyze(mir);\n+            def_use_analysis.analyze(body);\n \n-            if eliminate_self_assignments(mir, &def_use_analysis) {\n-                def_use_analysis.analyze(mir);\n+            if eliminate_self_assignments(body, &def_use_analysis) {\n+                def_use_analysis.analyze(body);\n             }\n \n             let mut changed = false;\n-            for dest_local in mir.local_decls.indices() {\n+            for dest_local in body.local_decls.indices() {\n                 debug!(\"Considering destination local: {:?}\", dest_local);\n \n                 let action;\n@@ -76,15 +76,15 @@ impl MirPass for CopyPropagation {\n                     }\n                     // Conservatively gives up if the dest is an argument,\n                     // because there may be uses of the original argument value.\n-                    if mir.local_kind(dest_local) == LocalKind::Arg {\n+                    if body.local_kind(dest_local) == LocalKind::Arg {\n                         debug!(\"  Can't copy-propagate local: dest {:?} (argument)\",\n                             dest_local);\n                         continue;\n                     }\n                     let dest_place_def = dest_use_info.defs_not_including_drop().next().unwrap();\n                     location = dest_place_def.location;\n \n-                    let basic_block = &mir[location.block];\n+                    let basic_block = &body[location.block];\n                     let statement_index = location.statement_index;\n                     let statement = match basic_block.statements.get(statement_index) {\n                         Some(statement) => statement,\n@@ -103,7 +103,7 @@ impl MirPass for CopyPropagation {\n                             let maybe_action = match *operand {\n                                 Operand::Copy(ref src_place) |\n                                 Operand::Move(ref src_place) => {\n-                                    Action::local_copy(&mir, &def_use_analysis, src_place)\n+                                    Action::local_copy(&body, &def_use_analysis, src_place)\n                                 }\n                                 Operand::Constant(ref src_constant) => {\n                                     Action::constant(src_constant)\n@@ -122,7 +122,7 @@ impl MirPass for CopyPropagation {\n                     }\n                 }\n \n-                changed = action.perform(mir, &def_use_analysis, dest_local, location) || changed;\n+                changed = action.perform(body, &def_use_analysis, dest_local, location) || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n                 break\n@@ -135,17 +135,17 @@ impl MirPass for CopyPropagation {\n }\n \n fn eliminate_self_assignments(\n-    mir: &mut Body<'_>,\n+    body: &mut Body<'_>,\n     def_use_analysis: &DefUseAnalysis,\n ) -> bool {\n     let mut changed = false;\n \n-    for dest_local in mir.local_decls.indices() {\n+    for dest_local in body.local_decls.indices() {\n         let dest_use_info = def_use_analysis.local_info(dest_local);\n \n         for def in dest_use_info.defs_not_including_drop() {\n             let location = def.location;\n-            if let Some(stmt) = mir[location.block].statements.get(location.statement_index) {\n+            if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n                 match stmt.kind {\n                     StatementKind::Assign(\n                         Place::Base(PlaceBase::Local(local)),\n@@ -163,7 +163,7 @@ fn eliminate_self_assignments(\n                 continue;\n             }\n             debug!(\"Deleting a self-assignment for {:?}\", dest_local);\n-            mir.make_statement_nop(location);\n+            body.make_statement_nop(location);\n             changed = true;\n         }\n     }\n@@ -177,7 +177,7 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(mir: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n+    fn local_copy(body: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Place::Base(PlaceBase::Local(local)) = *src_place {\n@@ -214,7 +214,7 @@ impl<'tcx> Action<'tcx> {\n         //     USE(SRC);\n         let src_def_count = src_use_info.def_count_not_including_drop();\n         // allow function arguments to be propagated\n-        let is_arg = mir.local_kind(src_local) == LocalKind::Arg;\n+        let is_arg = body.local_kind(src_local) == LocalKind::Arg;\n         if (is_arg && src_def_count != 0) || (!is_arg && src_def_count != 1) {\n             debug!(\n                 \"  Can't copy-propagate local: {} defs of src{}\",\n@@ -232,7 +232,7 @@ impl<'tcx> Action<'tcx> {\n     }\n \n     fn perform(self,\n-               mir: &mut Body<'tcx>,\n+               body: &mut Body<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n                location: Location)\n@@ -249,21 +249,21 @@ impl<'tcx> Action<'tcx> {\n                        src_local);\n                 for place_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n                 for place_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, mir, src_local);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");\n-                mir.make_statement_nop(location);\n+                body.make_statement_nop(location);\n \n                 true\n             }\n@@ -277,15 +277,15 @@ impl<'tcx> Action<'tcx> {\n                 let dest_local_info = def_use_analysis.local_info(dest_local);\n                 for place_use in &dest_local_info.defs_and_uses {\n                     if place_use.context.is_storage_marker() {\n-                        mir.make_statement_nop(place_use.location)\n+                        body.make_statement_nop(place_use.location)\n                     }\n                 }\n \n                 // Replace all uses of the destination local with the constant.\n                 let mut visitor = ConstantPropagationVisitor::new(dest_local,\n                                                                   src_constant);\n                 for dest_place_use in &dest_local_info.defs_and_uses {\n-                    visitor.visit_location(mir, dest_place_use.location)\n+                    visitor.visit_location(body, dest_place_use.location)\n                 }\n \n                 // Zap the assignment instruction if we eliminated all the uses. We won't have been\n@@ -296,7 +296,7 @@ impl<'tcx> Action<'tcx> {\n                     debug!(\"  {} of {} use(s) replaced; deleting assignment\",\n                            visitor.uses_replaced,\n                            use_count);\n-                    mir.make_statement_nop(location);\n+                    body.make_statement_nop(location);\n                     true\n                 } else if visitor.uses_replaced == 0 {\n                     debug!(\"  No uses replaced; not deleting assignment\");"}, {"sha": "78725f7523aab4afae9c5b62a163aa1acace545f", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -9,8 +9,8 @@ impl MirPass for Deaggregator {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+                          body: &mut Body<'tcx>) {\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {"}, {"sha": "9d88a2c8027e383acf35291c3515b03def905217", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -21,7 +21,7 @@ impl MirPass for Marker {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          _mir: &mut Body<'tcx>)\n+                          _body: &mut Body<'tcx>)\n     {\n     }\n }\n@@ -42,15 +42,15 @@ pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              pass_num: &dyn fmt::Display,\n                              pass_name: &str,\n                              source: MirSource<'tcx>,\n-                             mir: &Body<'tcx>,\n+                             body: &Body<'tcx>,\n                              is_after: bool) {\n     if mir_util::dump_enabled(tcx, pass_name, source) {\n         mir_util::dump_mir(tcx,\n                            Some(pass_num),\n                            pass_name,\n                            &Disambiguator { is_after },\n                            source,\n-                           mir,\n+                           body,\n                            |_, _| Ok(()) );\n     }\n }"}, {"sha": "c48b94bded65179a80b09cc60748b622813a6e5c", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -24,13 +24,13 @@ impl MirPass for ElaborateDrops {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>)\n+                          body: &mut Body<'tcx>)\n     {\n-        debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n+        debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n         let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n-        let move_data = match MoveData::gather_moves(mir, tcx) {\n+        let move_data = match MoveData::gather_moves(body, tcx) {\n             Ok(move_data) => move_data,\n             Err((move_data, _move_errors)) => {\n                 // The only way we should be allowing any move_errors\n@@ -45,32 +45,32 @@ impl MirPass for ElaborateDrops {\n             }\n         };\n         let elaborate_patch = {\n-            let mir = &*mir;\n+            let body = &*body;\n             let env = MoveDataParamEnv {\n                 move_data,\n                 param_env,\n             };\n-            let dead_unwinds = find_dead_unwinds(tcx, mir, def_id, &env);\n+            let dead_unwinds = find_dead_unwinds(tcx, body, def_id, &env);\n             let flow_inits =\n-                do_dataflow(tcx, mir, def_id, &[], &dead_unwinds,\n-                            MaybeInitializedPlaces::new(tcx, mir, &env),\n+                do_dataflow(tcx, body, def_id, &[], &dead_unwinds,\n+                            MaybeInitializedPlaces::new(tcx, body, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n             let flow_uninits =\n-                do_dataflow(tcx, mir, def_id, &[], &dead_unwinds,\n-                            MaybeUninitializedPlaces::new(tcx, mir, &env),\n+                do_dataflow(tcx, body, def_id, &[], &dead_unwinds,\n+                            MaybeUninitializedPlaces::new(tcx, body, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n \n             ElaborateDropsCtxt {\n                 tcx,\n-                mir,\n+                body,\n                 env: &env,\n                 flow_inits,\n                 flow_uninits,\n                 drop_flags: Default::default(),\n-                patch: MirPatch::new(mir),\n+                patch: MirPatch::new(body),\n             }.elaborate()\n         };\n-        elaborate_patch.apply(mir);\n+        elaborate_patch.apply(body);\n     }\n }\n \n@@ -79,20 +79,20 @@ impl MirPass for ElaborateDrops {\n /// that can't drop anything.\n fn find_dead_unwinds<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n     -> BitSet<BasicBlock>\n {\n-    debug!(\"find_dead_unwinds({:?})\", mir.span);\n+    debug!(\"find_dead_unwinds({:?})\", body.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+    let mut dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let flow_inits =\n-        do_dataflow(tcx, mir, def_id, &[], &dead_unwinds,\n-                    MaybeInitializedPlaces::new(tcx, mir, &env),\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds,\n+                    MaybeInitializedPlaces::new(tcx, body, &env),\n                     |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n-    for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n+    for (bb, bb_data) in body.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n             TerminatorKind::Drop { ref location, unwind: Some(_), .. } |\n             TerminatorKind::DropAndReplace { ref location, unwind: Some(_), .. } => location,\n@@ -107,7 +107,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n                bb, bb_data, init_data.live);\n         for stmt in 0..bb_data.statements.len() {\n             let loc = Location { block: bb, statement_index: stmt };\n-            init_data.apply_location(tcx, mir, env, loc);\n+            init_data.apply_location(tcx, body, env, loc);\n         }\n \n         let path = match env.move_data.rev_lookup.find(location) {\n@@ -121,7 +121,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n         debug!(\"find_dead_unwinds @ {:?}: path({:?})={:?}\", bb, location, path);\n \n         let mut maybe_live = false;\n-        on_all_drop_children_bits(tcx, mir, &env, path, |child| {\n+        on_all_drop_children_bits(tcx, body, &env, path, |child| {\n             let (child_maybe_live, _) = init_data.state(child);\n             maybe_live |= child_maybe_live;\n         });\n@@ -143,11 +143,11 @@ struct InitializationData {\n impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               mir: &Body<'tcx>,\n+                               body: &Body<'tcx>,\n                                env: &MoveDataParamEnv<'tcx, 'tcx>,\n                                loc: Location)\n     {\n-        drop_flag_effects_for_location(tcx, mir, env, loc, |path, df| {\n+        drop_flag_effects_for_location(tcx, body, env, loc, |path, df| {\n             debug!(\"at location {:?}: setting {:?} to {:?}\",\n                    loc, path, df);\n             match df {\n@@ -186,8 +186,8 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         &mut self.ctxt.patch\n     }\n \n-    fn mir(&self) -> &'a Body<'tcx> {\n-        self.ctxt.mir\n+    fn body(&self) -> &'a Body<'tcx> {\n+        self.ctxt.body\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -206,7 +206,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n                 let mut some_dead = false;\n                 let mut children_count = 0;\n                 on_all_drop_children_bits(\n-                    self.tcx(), self.mir(), self.ctxt.env, path, |child| {\n+                    self.tcx(), self.body(), self.ctxt.env, path, |child| {\n                         let (live, dead) = self.init_data.state(child);\n                         debug!(\"elaborate_drop: state({:?}) = {:?}\",\n                                child, (live, dead));\n@@ -232,7 +232,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n             }\n             DropFlagMode::Deep => {\n                 on_all_children_bits(\n-                    self.tcx(), self.mir(), self.ctxt.move_data(), path,\n+                    self.tcx(), self.body(), self.ctxt.move_data(), path,\n                     |child| self.ctxt.set_drop_flag(loc, child, DropFlagState::Absent)\n                  );\n             }\n@@ -291,7 +291,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n     flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n     flow_uninits:  DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n@@ -314,7 +314,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 .to_owned(),\n         };\n         for stmt in 0..loc.statement_index {\n-            data.apply_location(self.tcx, self.mir, self.env,\n+            data.apply_location(self.tcx, self.body, self.env,\n                                 Location { block: loc.block, statement_index: stmt });\n         }\n         data\n@@ -323,7 +323,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn create_drop_flag(&mut self, index: MovePathIndex, span: Span) {\n         let tcx = self.tcx;\n         let patch = &mut self.patch;\n-        debug!(\"create_drop_flag({:?})\", self.mir.span);\n+        debug!(\"create_drop_flag({:?})\", self.body.span);\n         self.drop_flags.entry(index).or_insert_with(|| {\n             patch.new_internal(tcx.types.bool, span)\n         });\n@@ -351,7 +351,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn collect_drop_flags(&mut self)\n     {\n-        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let terminator = data.terminator();\n             let location = match terminator.kind {\n                 TerminatorKind::Drop { ref location, .. } |\n@@ -382,7 +382,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 }\n             };\n \n-            on_all_drop_children_bits(self.tcx, self.mir, self.env, path, |child| {\n+            on_all_drop_children_bits(self.tcx, self.body, self.env, path, |child| {\n                 let (maybe_live, maybe_dead) = init_data.state(child);\n                 debug!(\"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n                        child, location, path, (maybe_live, maybe_dead));\n@@ -395,7 +395,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn elaborate_drops(&mut self)\n     {\n-        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n@@ -464,7 +464,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         unwind: Option<BasicBlock>)\n     {\n         let bb = loc.block;\n-        let data = &self.mir[bb];\n+        let data = &self.body[bb];\n         let terminator = data.terminator();\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n@@ -508,7 +508,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     target,\n                     Unwind::To(unwind),\n                     bb);\n-                on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n+                on_all_children_bits(self.tcx, self.body, self.move_data(), path, |child| {\n                     self.set_drop_flag(Location { block: target, statement_index: 0 },\n                                        child, DropFlagState::Present);\n                     self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n@@ -539,23 +539,23 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n     fn set_drop_flag(&mut self, loc: Location, path: MovePathIndex, val: DropFlagState) {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n-            let span = self.patch.source_info_for_location(self.mir, loc).span;\n+            let span = self.patch.source_info_for_location(self.body, loc).span;\n             let val = self.constant_bool(span, val.value());\n             self.patch.add_assign(loc, Place::Base(PlaceBase::Local(flag)), val);\n         }\n     }\n \n     fn drop_flags_on_init(&mut self) {\n         let loc = Location::START;\n-        let span = self.patch.source_info_for_location(self.mir, loc).span;\n+        let span = self.patch.source_info_for_location(self.body, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n             self.patch.add_assign(loc, Place::Base(PlaceBase::Local(*flag)), false_.clone());\n         }\n     }\n \n     fn drop_flags_for_fn_rets(&mut self) {\n-        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             if let TerminatorKind::Call {\n                 destination: Some((ref place, tgt)), cleanup: Some(_), ..\n             } = data.terminator().kind {\n@@ -564,7 +564,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let loc = Location { block: tgt, statement_index: 0 };\n                 let path = self.move_data().rev_lookup.find(place);\n                 on_lookup_result_bits(\n-                    self.tcx, self.mir, self.move_data(), path,\n+                    self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n             }\n@@ -574,7 +574,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn drop_flags_for_args(&mut self) {\n         let loc = Location::START;\n         dataflow::drop_flag_effects_for_function_entry(\n-            self.tcx, self.mir, self.env, |path, ds| {\n+            self.tcx, self.body, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);\n             }\n         )\n@@ -587,7 +587,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         // drop flags by themselves, to avoid the drop flags being\n         // clobbered before they are read.\n \n-        for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n+        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n             debug!(\"drop_flags_for_locs({:?})\", data);\n             for i in 0..(data.statements.len()+1) {\n                 debug!(\"drop_flag_for_locs: stmt {}\", i);\n@@ -619,7 +619,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 }\n                 let loc = Location { block: bb, statement_index: i };\n                 dataflow::drop_flag_effects_for_location(\n-                    self.tcx, self.mir, self.env, loc, |path, ds| {\n+                    self.tcx, self.body, self.env, loc, |path, ds| {\n                         if ds == DropFlagState::Absent || allow_initializations {\n                             self.set_drop_flag(loc, path, ds)\n                         }\n@@ -638,7 +638,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 let loc = Location { block: bb, statement_index: data.statements.len() };\n                 let path = self.move_data().rev_lookup.find(place);\n                 on_lookup_result_bits(\n-                    self.tcx, self.mir, self.move_data(), path,\n+                    self.tcx, self.body, self.move_data(), path,\n                     |child| self.set_drop_flag(loc, child, DropFlagState::Present)\n                 );\n             }"}, {"sha": "5ed7abc88b8f172c0781b719b639e32826e11caf", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -53,7 +53,7 @@ impl MirPass for EraseRegions {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_body(mir);\n+                          body: &mut Body<'tcx>) {\n+        EraseRegionsVisitor::new(tcx).visit_body(body);\n     }\n }"}, {"sha": "d2c75ebe8d6aa3f58097966e7d518d81a0d395ba", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 117, "deletions": 117, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -218,14 +218,14 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n \n     // Create a statement which reads the discriminant into a temporary\n-    fn get_discr(&self, mir: &mut Body<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n-        let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, mir.span);\n-        let local_decls_len = mir.local_decls.push(temp_decl);\n+    fn get_discr(&self, body: &mut Body<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n+        let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, body.span);\n+        let local_decls_len = body.local_decls.push(temp_decl);\n         let temp = Place::Base(PlaceBase::Local(local_decls_len));\n \n         let self_place = Place::Base(PlaceBase::Local(self_arg()));\n         let assign = Statement {\n-            source_info: source_info(mir),\n+            source_info: source_info(body),\n             kind: StatementKind::Assign(temp.clone(), box Rvalue::Discriminant(self_place)),\n         };\n         (assign, temp)\n@@ -312,8 +312,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n fn make_generator_state_argument_indirect<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 def_id: DefId,\n-                mir: &mut Body<'tcx>) {\n-    let gen_ty = mir.local_decls.raw[1].ty;\n+                body: &mut Body<'tcx>) {\n+    let gen_ty = body.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n         scope: def_id,\n@@ -328,34 +328,34 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n     });\n \n     // Replace the by value generator argument\n-    mir.local_decls.raw[1].ty = ref_gen_ty;\n+    body.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor.visit_body(mir);\n+    DerefArgVisitor.visit_body(body);\n }\n \n fn make_generator_state_argument_pinned<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                mir: &mut Body<'tcx>) {\n-    let ref_gen_ty = mir.local_decls.raw[1].ty;\n+                body: &mut Body<'tcx>) {\n+    let ref_gen_ty = body.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n     let pin_adt_ref = tcx.adt_def(pin_did);\n     let substs = tcx.intern_substs(&[ref_gen_ty.into()]);\n     let pin_ref_gen_ty = tcx.mk_adt(pin_adt_ref, substs);\n \n     // Replace the by ref generator argument\n-    mir.local_decls.raw[1].ty = pin_ref_gen_ty;\n+    body.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty }.visit_body(mir);\n+    PinArgVisitor { ref_gen_ty }.visit_body(body);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n-    mir: &mut Body<'tcx>,\n+    body: &mut Body<'tcx>,\n ) -> Local {\n-    let source_info = source_info(mir);\n+    let source_info = source_info(body);\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n@@ -367,14 +367,14 @@ fn replace_result_variable<'tcx>(\n         is_block_tail: None,\n         is_user_variable: None,\n     };\n-    let new_ret_local = Local::new(mir.local_decls.len());\n-    mir.local_decls.push(new_ret);\n-    mir.local_decls.swap(RETURN_PLACE, new_ret_local);\n+    let new_ret_local = Local::new(body.local_decls.len());\n+    body.local_decls.push(new_ret);\n+    body.local_decls.swap(RETURN_PLACE, new_ret_local);\n \n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n-    }.visit_body(mir);\n+    }.visit_body(body);\n \n     new_ret_local\n }\n@@ -395,60 +395,60 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> (\n     liveness::LiveVarSet,\n     FxHashMap<BasicBlock, liveness::LiveVarSet>,\n     BitSet<BasicBlock>,\n ) {\n-    let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n     // lifetimes.\n-    let storage_live_analysis = MaybeStorageLive::new(mir);\n+    let storage_live_analysis = MaybeStorageLive::new(body);\n     let storage_live =\n-        do_dataflow(tcx, mir, def_id, &[], &dead_unwinds, storage_live_analysis,\n-                    |bd, p| DebugFormatted::new(&bd.mir().local_decls[p]));\n+        do_dataflow(tcx, body, def_id, &[], &dead_unwinds, storage_live_analysis,\n+                    |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(BitSet::new_filled(mir.local_decls.len()));\n-    ignored.visit_body(mir);\n+    let mut ignored = StorageIgnored(BitSet::new_filled(body.local_decls.len()));\n+    ignored.visit_body(body);\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n     // This is only used for immovable generators.\n     let borrowed_locals = if !movable {\n-        let analysis = HaveBeenBorrowedLocals::new(mir);\n+        let analysis = HaveBeenBorrowedLocals::new(body);\n         let result =\n-            do_dataflow(tcx, mir, def_id, &[], &dead_unwinds, analysis,\n-                        |bd, p| DebugFormatted::new(&bd.mir().local_decls[p]));\n+            do_dataflow(tcx, body, def_id, &[], &dead_unwinds, analysis,\n+                        |bd, p| DebugFormatted::new(&bd.body().local_decls[p]));\n         Some((analysis, result))\n     } else {\n         None\n     };\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n+    let mut set = liveness::LiveVarSet::new_empty(body.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n-        mir,\n+        body,\n     );\n     liveness::dump_mir(\n         tcx,\n         \"generator_liveness\",\n         source,\n-        mir,\n+        body,\n         &liveness,\n     );\n \n     let mut storage_liveness_map = FxHashMap::default();\n \n-    let mut suspending_blocks = BitSet::new_empty(mir.basic_blocks().len());\n+    let mut suspending_blocks = BitSet::new_empty(body.basic_blocks().len());\n \n-    for (block, data) in mir.basic_blocks().iter_enumerated() {\n+    for (block, data) in body.basic_blocks().iter_enumerated() {\n         if let TerminatorKind::Yield { .. } = data.terminator().kind {\n             suspending_blocks.insert(block);\n \n@@ -461,7 +461,7 @@ fn locals_live_across_suspend_points(\n                 let borrowed_locals = state_for_location(loc,\n                                                          analysis,\n                                                          result,\n-                                                         mir);\n+                                                         body);\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows.\n                 // This is correct for movable generators since borrows cannot live across\n                 // suspension points. However for immovable generators we need to account for\n@@ -478,7 +478,7 @@ fn locals_live_across_suspend_points(\n             let mut storage_liveness = state_for_location(loc,\n                                                           &storage_live_analysis,\n                                                           &storage_live,\n-                                                          mir);\n+                                                          body);\n \n             // Store the storage liveness for later use so we can restore the state\n             // after a suspension point\n@@ -511,14 +511,14 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             upvars: &Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n-                            mir: &mut Body<'tcx>)\n+                            body: &mut Body<'tcx>)\n     -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n         GeneratorLayout<'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness, suspending_blocks) =\n-        locals_live_across_suspend_points(tcx, mir, source, movable);\n+        locals_live_across_suspend_points(tcx, body, source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -528,7 +528,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => bug!(),\n     };\n \n-    for (local, decl) in mir.local_decls.iter_enumerated() {\n+    for (local, decl) in body.local_decls.iter_enumerated() {\n         // Ignore locals which are internal or not live\n         if !live_locals.contains(local) || decl.internal {\n             continue;\n@@ -537,20 +537,20 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Sanity check that typeck knows about the type of locals which are\n         // live across a suspension point\n         if !allowed.contains(&decl.ty) && !allowed_upvars.contains(&decl.ty) {\n-            span_bug!(mir.span,\n+            span_bug!(body.span,\n                       \"Broken MIR: generator contains type {} in MIR, \\\n                        but typeck only knows about {}\",\n                       decl.ty,\n                       interior);\n         }\n     }\n \n-    let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), mir.span);\n+    let dummy_local = LocalDecl::new_internal(tcx.mk_unit(), body.span);\n \n     // Gather live locals and their indices replacing values in mir.local_decls with a dummy\n     // to avoid changing local indices\n     let live_decls = live_locals.iter().map(|local| {\n-        let var = mem::replace(&mut mir.local_decls[local], dummy_local.clone());\n+        let var = mem::replace(&mut body.local_decls[local], dummy_local.clone());\n         (local, var)\n     });\n \n@@ -584,21 +584,21 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(mir: &mut Body<'tcx>,\n+fn insert_switch<'a, 'tcx>(body: &mut Body<'tcx>,\n                            cases: Vec<(usize, BasicBlock)>,\n                            transform: &TransformVisitor<'a, 'tcx>,\n                            default: TerminatorKind<'tcx>) {\n-    let default_block = insert_term_block(mir, default);\n-    let (assign, discr) = transform.get_discr(mir);\n+    let default_block = insert_term_block(body, default);\n+    let (assign, discr) = transform.get_discr(body);\n     let switch = TerminatorKind::SwitchInt {\n         discr: Operand::Move(discr),\n         switch_ty: transform.discr_ty,\n         values: Cow::from(cases.iter().map(|&(i, _)| i as u128).collect::<Vec<_>>()),\n         targets: cases.iter().map(|&(_, d)| d).chain(iter::once(default_block)).collect(),\n     };\n \n-    let source_info = source_info(mir);\n-    mir.basic_blocks_mut().raw.insert(0, BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().raw.insert(0, BasicBlockData {\n         statements: vec![assign],\n         terminator: Some(Terminator {\n             source_info,\n@@ -607,7 +607,7 @@ fn insert_switch<'a, 'tcx>(mir: &mut Body<'tcx>,\n         is_cleanup: false,\n     });\n \n-    let blocks = mir.basic_blocks_mut().iter_mut();\n+    let blocks = body.basic_blocks_mut().iter_mut();\n \n     for target in blocks.flat_map(|b| b.terminator_mut().successors_mut()) {\n         *target = BasicBlock::new(target.index() + 1);\n@@ -616,7 +616,7 @@ fn insert_switch<'a, 'tcx>(mir: &mut Body<'tcx>,\n \n fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        def_id: DefId,\n-                                       mir: &mut Body<'tcx>) {\n+                                       body: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -629,13 +629,13 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let gen = self_arg();\n \n     let mut elaborator = DropShimElaborator {\n-        mir: mir,\n-        patch: MirPatch::new(mir),\n+        body: body,\n+        patch: MirPatch::new(body),\n         tcx,\n         param_env\n     };\n \n-    for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+    for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n             &Terminator {\n                 source_info,\n@@ -662,7 +662,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             block,\n         );\n     }\n-    elaborator.patch.apply(mir);\n+    elaborator.patch.apply(body);\n }\n \n fn create_generator_drop_shim<'a, 'tcx>(\n@@ -671,30 +671,30 @@ fn create_generator_drop_shim<'a, 'tcx>(\n                 def_id: DefId,\n                 source: MirSource<'tcx>,\n                 gen_ty: Ty<'tcx>,\n-                mir: &Body<'tcx>,\n+                body: &Body<'tcx>,\n                 drop_clean: BasicBlock) -> Body<'tcx> {\n-    let mut mir = mir.clone();\n+    let mut body = body.clone();\n \n-    let source_info = source_info(&mir);\n+    let source_info = source_info(&body);\n \n-    let mut cases = create_cases(&mut mir, transform, |point| point.drop);\n+    let mut cases = create_cases(&mut body, transform, |point| point.drop);\n \n     cases.insert(0, (UNRESUMED, drop_clean));\n \n     // The returned state and the poisoned state fall through to the default\n     // case which is just to return\n \n-    insert_switch(&mut mir, cases, &transform, TerminatorKind::Return);\n+    insert_switch(&mut body, cases, &transform, TerminatorKind::Return);\n \n-    for block in mir.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         let kind = &mut block.terminator_mut().kind;\n         if let TerminatorKind::GeneratorDrop = *kind {\n             *kind = TerminatorKind::Return;\n         }\n     }\n \n     // Replace the return variable\n-    mir.local_decls[RETURN_PLACE] = LocalDecl {\n+    body.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_unit(),\n         user_ty: UserTypeProjections::none(),\n@@ -706,10 +706,10 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         is_user_variable: None,\n     };\n \n-    make_generator_state_argument_indirect(tcx, def_id, &mut mir);\n+    make_generator_state_argument_indirect(tcx, def_id, &mut body);\n \n     // Change the generator argument from &mut to *mut\n-    mir.local_decls[self_arg()] = LocalDecl {\n+    body.local_decls[self_arg()] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n@@ -725,27 +725,27 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     };\n     if tcx.sess.opts.debugging_opts.mir_emit_retag {\n         // Alias tracking must know we changed the type\n-        mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n+        body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n             kind: StatementKind::Retag(RetagKind::Raw, Place::Base(PlaceBase::Local(self_arg()))),\n         })\n     }\n \n-    no_landing_pads(tcx, &mut mir);\n+    no_landing_pads(tcx, &mut body);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the resume part of the function\n-    simplify::remove_dead_blocks(&mut mir);\n+    simplify::remove_dead_blocks(&mut body);\n \n-    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut mir, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_drop\", &0, source, &mut body, |_, _| Ok(()) );\n \n-    mir\n+    body\n }\n \n-fn insert_term_block<'tcx>(mir: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-    let term_block = BasicBlock::new(mir.basic_blocks().len());\n-    let source_info = source_info(mir);\n-    mir.basic_blocks_mut().push(BasicBlockData {\n+fn insert_term_block<'tcx>(body: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+    let term_block = BasicBlock::new(body.basic_blocks().len());\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -757,12 +757,12 @@ fn insert_term_block<'tcx>(mir: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) ->\n }\n \n fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                mir: &mut Body<'tcx>,\n+                                body: &mut Body<'tcx>,\n                                 message: AssertMessage<'tcx>) -> BasicBlock {\n-    let assert_block = BasicBlock::new(mir.basic_blocks().len());\n+    let assert_block = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n         cond: Operand::Constant(box Constant {\n-            span: mir.span,\n+            span: body.span,\n             ty: tcx.types.bool,\n             user_ty: None,\n             literal: ty::Const::from_bool(tcx, false),\n@@ -773,8 +773,8 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cleanup: None,\n     };\n \n-    let source_info = source_info(mir);\n-    mir.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -791,17 +791,17 @@ fn create_generator_resume_function<'a, 'tcx>(\n         transform: TransformVisitor<'a, 'tcx>,\n         def_id: DefId,\n         source: MirSource<'tcx>,\n-        mir: &mut Body<'tcx>) {\n+        body: &mut Body<'tcx>) {\n     // Poison the generator when it unwinds\n-    for block in mir.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n         if let &TerminatorKind::Resume = &block.terminator().kind {\n             block.statements.push(\n                 transform.set_discr(VariantIdx::new(POISONED), source_info));\n         }\n     }\n \n-    let mut cases = create_cases(mir, &transform, |point| Some(point.resume));\n+    let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n \n     use rustc::mir::interpret::InterpError::{\n         GeneratorResumedAfterPanic,\n@@ -811,43 +811,43 @@ fn create_generator_resume_function<'a, 'tcx>(\n     // Jump to the entry point on the unresumed\n     cases.insert(0, (UNRESUMED, BasicBlock::new(0)));\n     // Panic when resumed on the returned state\n-    cases.insert(1, (RETURNED, insert_panic_block(tcx, mir, GeneratorResumedAfterReturn)));\n+    cases.insert(1, (RETURNED, insert_panic_block(tcx, body, GeneratorResumedAfterReturn)));\n     // Panic when resumed on the poisoned state\n-    cases.insert(2, (POISONED, insert_panic_block(tcx, mir, GeneratorResumedAfterPanic)));\n+    cases.insert(2, (POISONED, insert_panic_block(tcx, body, GeneratorResumedAfterPanic)));\n \n-    insert_switch(mir, cases, &transform, TerminatorKind::Unreachable);\n+    insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n \n-    make_generator_state_argument_indirect(tcx, def_id, mir);\n-    make_generator_state_argument_pinned(tcx, mir);\n+    make_generator_state_argument_indirect(tcx, def_id, body);\n+    make_generator_state_argument_pinned(tcx, body);\n \n-    no_landing_pads(tcx, mir);\n+    no_landing_pads(tcx, body);\n \n     // Make sure we remove dead blocks to remove\n     // unrelated code from the drop part of the function\n-    simplify::remove_dead_blocks(mir);\n+    simplify::remove_dead_blocks(body);\n \n-    dump_mir(tcx, None, \"generator_resume\", &0, source, mir, |_, _| Ok(()) );\n+    dump_mir(tcx, None, \"generator_resume\", &0, source, body, |_, _| Ok(()) );\n }\n \n-fn source_info<'a, 'tcx>(mir: &Body<'tcx>) -> SourceInfo {\n+fn source_info<'a, 'tcx>(body: &Body<'tcx>) -> SourceInfo {\n     SourceInfo {\n-        span: mir.span,\n+        span: body.span,\n         scope: OUTERMOST_SOURCE_SCOPE,\n     }\n }\n \n-fn insert_clean_drop<'a, 'tcx>(mir: &mut Body<'tcx>) -> BasicBlock {\n-    let return_block = insert_term_block(mir, TerminatorKind::Return);\n+fn insert_clean_drop<'a, 'tcx>(body: &mut Body<'tcx>) -> BasicBlock {\n+    let return_block = insert_term_block(body, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n-    let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n+    let drop_clean = BasicBlock::new(body.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n         location: Place::Base(PlaceBase::Local(self_arg())),\n         target: return_block,\n         unwind: None,\n     };\n-    let source_info = source_info(mir);\n-    mir.basic_blocks_mut().push(BasicBlockData {\n+    let source_info = source_info(body);\n+    body.basic_blocks_mut().push(BasicBlockData {\n         statements: Vec::new(),\n         terminator: Some(Terminator {\n             source_info,\n@@ -859,20 +859,20 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Body<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'a, 'tcx, F>(mir: &mut Body<'tcx>,\n+fn create_cases<'a, 'tcx, F>(body: &mut Body<'tcx>,\n                           transform: &TransformVisitor<'a, 'tcx>,\n                           target: F) -> Vec<(usize, BasicBlock)>\n     where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n-    let source_info = source_info(mir);\n+    let source_info = source_info(body);\n \n     transform.suspension_points.iter().filter_map(|point| {\n         // Find the target for this suspension point, if applicable\n         target(point).map(|target| {\n-            let block = BasicBlock::new(mir.basic_blocks().len());\n+            let block = BasicBlock::new(body.basic_blocks().len());\n             let mut statements = Vec::new();\n \n             // Create StorageLive instructions for locals with live storage\n-            for i in 0..(mir.local_decls.len()) {\n+            for i in 0..(body.local_decls.len()) {\n                 let l = Local::new(i);\n                 if point.storage_liveness.contains(l) && !transform.remap.contains_key(&l) {\n                     statements.push(Statement {\n@@ -883,7 +883,7 @@ fn create_cases<'a, 'tcx, F>(mir: &mut Body<'tcx>,\n             }\n \n             // Then jump to the real target\n-            mir.basic_blocks_mut().push(BasicBlockData {\n+            body.basic_blocks_mut().push(BasicBlockData {\n                 statements,\n                 terminator: Some(Terminator {\n                     source_info,\n@@ -903,20 +903,20 @@ impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     source: MirSource<'tcx>,\n-                    mir: &mut Body<'tcx>) {\n-        let yield_ty = if let Some(yield_ty) = mir.yield_ty {\n+                    body: &mut Body<'tcx>) {\n+        let yield_ty = if let Some(yield_ty) = body.yield_ty {\n             yield_ty\n         } else {\n             // This only applies to generators\n             return\n         };\n \n-        assert!(mir.generator_drop.is_none());\n+        assert!(body.generator_drop.is_none());\n \n         let def_id = source.def_id();\n \n         // The first argument is the generator type passed by value\n-        let gen_ty = mir.local_decls.raw[1].ty;\n+        let gen_ty = body.local_decls.raw[1].ty;\n \n         // Get the interior types and substs which typeck computed\n         let (upvars, interior, discr_ty, movable) = match gen_ty.sty {\n@@ -934,13 +934,13 @@ impl MirPass for StateTransform {\n         let state_adt_ref = tcx.adt_def(state_did);\n         let state_substs = tcx.intern_substs(&[\n             yield_ty.into(),\n-            mir.return_ty().into(),\n+            body.return_ty().into(),\n         ]);\n         let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, mir);\n+        let new_ret_local = replace_result_variable(ret_ty, body);\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices\n@@ -951,7 +951,7 @@ impl MirPass for StateTransform {\n             &upvars,\n             interior,\n             movable,\n-            mir);\n+            body);\n \n         // Run the transformation which converts Places from Local to generator struct\n         // accesses for locals in `remap`.\n@@ -967,40 +967,40 @@ impl MirPass for StateTransform {\n             new_ret_local,\n             discr_ty,\n         };\n-        transform.visit_body(mir);\n+        transform.visit_body(body);\n \n         // Update our MIR struct to reflect the changed we've made\n-        mir.yield_ty = None;\n-        mir.arg_count = 1;\n-        mir.spread_arg = None;\n-        mir.generator_layout = Some(layout);\n+        body.yield_ty = None;\n+        body.arg_count = 1;\n+        body.spread_arg = None;\n+        body.generator_layout = Some(layout);\n \n         // Insert `drop(generator_struct)` which is used to drop upvars for generators in\n         // the unresumed state.\n         // This is expanded to a drop ladder in `elaborate_generator_drops`.\n-        let drop_clean = insert_clean_drop(mir);\n+        let drop_clean = insert_clean_drop(body);\n \n-        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, mir, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_pre-elab\", &0, source, body, |_, _| Ok(()) );\n \n         // Expand `drop(generator_struct)` to a drop ladder which destroys upvars.\n         // If any upvars are moved out of, drop elaboration will handle upvar destruction.\n         // However we need to also elaborate the code generated by `insert_clean_drop`.\n-        elaborate_generator_drops(tcx, def_id, mir);\n+        elaborate_generator_drops(tcx, def_id, body);\n \n-        dump_mir(tcx, None, \"generator_post-transform\", &0, source, mir, |_, _| Ok(()) );\n+        dump_mir(tcx, None, \"generator_post-transform\", &0, source, body, |_, _| Ok(()) );\n \n         // Create a copy of our MIR and use it to create the drop shim for the generator\n         let drop_shim = create_generator_drop_shim(tcx,\n             &transform,\n             def_id,\n             source,\n             gen_ty,\n-            &mir,\n+            &body,\n             drop_clean);\n \n-        mir.generator_drop = Some(box drop_shim);\n+        body.generator_drop = Some(box drop_shim);\n \n         // Create the Generator::resume function\n-        create_generator_resume_function(tcx, transform, def_id, source, mir);\n+        create_generator_resume_function(tcx, transform, def_id, source, body);\n     }\n }"}, {"sha": "651910c64924dd801144d2cbd1174c539ad2a1e2", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -41,9 +41,9 @@ impl MirPass for Inline {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            Inliner { tcx, source }.run_pass(mir);\n+            Inliner { tcx, source }.run_pass(body);\n         }\n     }\n }\n@@ -54,7 +54,7 @@ struct Inliner<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Inliner<'a, 'tcx> {\n-    fn run_pass(&self, caller_mir: &mut Body<'tcx>) {\n+    fn run_pass(&self, caller_body: &mut Body<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -76,10 +76,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         if self.tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure()\n             && self.source.promoted.is_none()\n         {\n-            for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated() {\n+            for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) = self.get_valid_function_call(bb,\n                                                                     bb_data,\n-                                                                    caller_mir,\n+                                                                    caller_body,\n                                                                     param_env) {\n                     callsites.push_back(callsite);\n                 }\n@@ -103,7 +103,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let self_node_id = self.tcx.hir().as_local_node_id(self.source.def_id()).unwrap();\n                 let callee_node_id = self.tcx.hir().as_local_node_id(callsite.callee);\n \n-                let callee_mir = if let Some(callee_node_id) = callee_node_id {\n+                let callee_body = if let Some(callee_node_id) = callee_node_id {\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower node id than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation.\n@@ -120,29 +120,29 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     self.tcx.optimized_mir(callsite.callee)\n                 };\n \n-                let callee_mir = if self.consider_optimizing(callsite, callee_mir) {\n+                let callee_body = if self.consider_optimizing(callsite, callee_body) {\n                     self.tcx.subst_and_normalize_erasing_regions(\n                         &callsite.substs,\n                         param_env,\n-                        callee_mir,\n+                        callee_body,\n                     )\n                 } else {\n                     continue;\n                 };\n \n-                let start = caller_mir.basic_blocks().len();\n-                debug!(\"attempting to inline callsite {:?} - mir={:?}\", callsite, callee_mir);\n-                if !self.inline_call(callsite, caller_mir, callee_mir) {\n+                let start = caller_body.basic_blocks().len();\n+                debug!(\"attempting to inline callsite {:?} - body={:?}\", callsite, callee_body);\n+                if !self.inline_call(callsite, caller_body, callee_body) {\n                     debug!(\"attempting to inline callsite {:?} - failure\", callsite);\n                     continue;\n                 }\n                 debug!(\"attempting to inline callsite {:?} - success\", callsite);\n \n                 // Add callsites from inlined function\n-                for (bb, bb_data) in caller_mir.basic_blocks().iter_enumerated().skip(start) {\n+                for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated().skip(start) {\n                     if let Some(new_callsite) = self.get_valid_function_call(bb,\n                                                                              bb_data,\n-                                                                             caller_mir,\n+                                                                             caller_body,\n                                                                              param_env) {\n                         // Don't inline the same function multiple times.\n                         if callsite.callee != new_callsite.callee {\n@@ -163,15 +163,15 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Simplify if we inlined anything.\n         if changed {\n             debug!(\"Running simplify cfg on {:?}\", self.source);\n-            CfgSimplifier::new(caller_mir).simplify();\n-            remove_dead_blocks(caller_mir);\n+            CfgSimplifier::new(caller_body).simplify();\n+            remove_dead_blocks(caller_body);\n         }\n     }\n \n     fn get_valid_function_call(&self,\n                                bb: BasicBlock,\n                                bb_data: &BasicBlockData<'tcx>,\n-                               caller_mir: &Body<'tcx>,\n+                               caller_body: &Body<'tcx>,\n                                param_env: ParamEnv<'tcx>,\n     ) -> Option<CallSite<'tcx>> {\n         // Don't inline calls that are in cleanup blocks.\n@@ -180,7 +180,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n-            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_mir, self.tcx).sty {\n+            if let ty::FnDef(callee_def_id, substs) = op.ty(caller_body, self.tcx).sty {\n                 let instance = Instance::resolve(self.tcx,\n                                                  param_env,\n                                                  callee_def_id,\n@@ -204,33 +204,33 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n-                           callee_mir: &Body<'tcx>)\n+                           callee_body: &Body<'tcx>)\n                            -> bool\n     {\n         debug!(\"consider_optimizing({:?})\", callsite);\n-        self.should_inline(callsite, callee_mir)\n+        self.should_inline(callsite, callee_body)\n             && self.tcx.consider_optimizing(|| format!(\"Inline {:?} into {:?}\",\n-                                                       callee_mir.span,\n+                                                       callee_body.span,\n                                                        callsite))\n     }\n \n     fn should_inline(&self,\n                      callsite: CallSite<'tcx>,\n-                     callee_mir: &Body<'tcx>)\n+                     callee_body: &Body<'tcx>)\n                      -> bool\n     {\n         debug!(\"should_inline({:?})\", callsite);\n         let tcx = self.tcx;\n \n         // Don't inline closures that have capture debuginfo\n         // FIXME: Handle closures better\n-        if callee_mir.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n+        if callee_body.__upvar_debuginfo_codegen_only_do_not_use.len() > 0 {\n             debug!(\"    upvar debuginfo present - not inlining\");\n             return false;\n         }\n \n         // Cannot inline generators which haven't been transformed yet\n-        if callee_mir.yield_ty.is_some() {\n+        if callee_body.yield_ty.is_some() {\n             debug!(\"    yield ty present - not inlining\");\n             return false;\n         }\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Give a bonus functions with a small number of blocks,\n         // We normally have two or three blocks for even\n         // very small functions.\n-        if callee_mir.basic_blocks().len() <= 3 {\n+        if callee_body.basic_blocks().len() <= 3 {\n             threshold += threshold / 4;\n         }\n         debug!(\"    final inline threshold = {}\", threshold);\n@@ -296,10 +296,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Traverse the MIR manually so we can account for the effects of\n         // inlining on the CFG.\n         let mut work_list = vec![START_BLOCK];\n-        let mut visited = BitSet::new_empty(callee_mir.basic_blocks().len());\n+        let mut visited = BitSet::new_empty(callee_body.basic_blocks().len());\n         while let Some(bb) = work_list.pop() {\n             if !visited.insert(bb.index()) { continue; }\n-            let blk = &callee_mir.basic_blocks()[bb];\n+            let blk = &callee_body.basic_blocks()[bb];\n \n             for stmt in &blk.statements {\n                 // Don't count StorageLive/StorageDead in the inlining cost.\n@@ -319,7 +319,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     work_list.push(target);\n                     // If the location doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(callee_mir, tcx).subst(tcx, callsite.substs).ty;\n+                    let ty = location.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -366,8 +366,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let ptr_size = tcx.data_layout.pointer_size.bytes();\n \n-        for v in callee_mir.vars_and_temps_iter() {\n-            let v = &callee_mir.local_decls[v];\n+        for v in callee_body.vars_and_temps_iter() {\n+            let v = &callee_body.local_decls[v];\n             let ty = v.ty.subst(tcx, callsite.substs);\n             // Cost of the var is the size in machine-words, if we know\n             // it.\n@@ -394,44 +394,44 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n     fn inline_call(&self,\n                    callsite: CallSite<'tcx>,\n-                   caller_mir: &mut Body<'tcx>,\n-                   mut callee_mir: Body<'tcx>) -> bool {\n-        let terminator = caller_mir[callsite.bb].terminator.take().unwrap();\n+                   caller_body: &mut Body<'tcx>,\n+                   mut callee_body: Body<'tcx>) -> bool {\n+        let terminator = caller_body[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n             TerminatorKind::Call { args, destination: Some(destination), cleanup, .. } => {\n                 debug!(\"Inlined {:?} into {:?}\", callsite.callee, self.source);\n \n-                let mut local_map = IndexVec::with_capacity(callee_mir.local_decls.len());\n-                let mut scope_map = IndexVec::with_capacity(callee_mir.source_scopes.len());\n-                let mut promoted_map = IndexVec::with_capacity(callee_mir.promoted.len());\n+                let mut local_map = IndexVec::with_capacity(callee_body.local_decls.len());\n+                let mut scope_map = IndexVec::with_capacity(callee_body.source_scopes.len());\n+                let mut promoted_map = IndexVec::with_capacity(callee_body.promoted.len());\n \n-                for mut scope in callee_mir.source_scopes.iter().cloned() {\n+                for mut scope in callee_body.source_scopes.iter().cloned() {\n                     if scope.parent_scope.is_none() {\n                         scope.parent_scope = Some(callsite.location.scope);\n-                        scope.span = callee_mir.span;\n+                        scope.span = callee_body.span;\n                     }\n \n                     scope.span = callsite.location.span;\n \n-                    let idx = caller_mir.source_scopes.push(scope);\n+                    let idx = caller_body.source_scopes.push(scope);\n                     scope_map.push(idx);\n                 }\n \n-                for loc in callee_mir.vars_and_temps_iter() {\n-                    let mut local = callee_mir.local_decls[loc].clone();\n+                for loc in callee_body.vars_and_temps_iter() {\n+                    let mut local = callee_body.local_decls[loc].clone();\n \n                     local.source_info.scope =\n                         scope_map[local.source_info.scope];\n                     local.source_info.span = callsite.location.span;\n                     local.visibility_scope = scope_map[local.visibility_scope];\n \n-                    let idx = caller_mir.local_decls.push(local);\n+                    let idx = caller_body.local_decls.push(local);\n                     local_map.push(idx);\n                 }\n \n                 promoted_map.extend(\n-                    callee_mir.promoted.iter().cloned().map(|p| caller_mir.promoted.push(p))\n+                    callee_body.promoted.iter().cloned().map(|p| caller_body.promoted.push(p))\n                 );\n \n                 // If the call is something like `a[*i] = f(i)`, where\n@@ -465,18 +465,18 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         BorrowKind::Mut { allow_two_phase_borrow: false },\n                         destination.0);\n \n-                    let ty = dest.ty(caller_mir, self.tcx);\n+                    let ty = dest.ty(caller_body, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n-                    let tmp = caller_mir.local_decls.push(temp);\n+                    let tmp = caller_body.local_decls.push(temp);\n                     let tmp = Place::Base(PlaceBase::Local(tmp));\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n                         kind: StatementKind::Assign(tmp.clone(), box dest)\n                     };\n-                    caller_mir[callsite.bb]\n+                    caller_body[callsite.bb]\n                         .statements.push(stmt);\n                     tmp.deref()\n                 } else {\n@@ -486,9 +486,9 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let return_block = destination.1;\n \n                 // Copy the arguments if needed.\n-                let args: Vec<_> = self.make_call_args(args, &callsite, caller_mir);\n+                let args: Vec<_> = self.make_call_args(args, &callsite, caller_body);\n \n-                let bb_len = caller_mir.basic_blocks().len();\n+                let bb_len = caller_body.basic_blocks().len();\n                 let mut integrator = Integrator {\n                     block_idx: bb_len,\n                     args: &args,\n@@ -503,22 +503,22 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 };\n \n \n-                for (bb, mut block) in callee_mir.basic_blocks_mut().drain_enumerated(..) {\n+                for (bb, mut block) in callee_body.basic_blocks_mut().drain_enumerated(..) {\n                     integrator.visit_basic_block_data(bb, &mut block);\n-                    caller_mir.basic_blocks_mut().push(block);\n+                    caller_body.basic_blocks_mut().push(block);\n                 }\n \n                 let terminator = Terminator {\n                     source_info: callsite.location,\n                     kind: TerminatorKind::Goto { target: BasicBlock::new(bb_len) }\n                 };\n \n-                caller_mir[callsite.bb].terminator = Some(terminator);\n+                caller_body[callsite.bb].terminator = Some(terminator);\n \n                 true\n             }\n             kind => {\n-                caller_mir[callsite.bb].terminator = Some(Terminator {\n+                caller_body[callsite.bb].terminator = Some(Terminator {\n                     source_info: terminator.source_info,\n                     kind,\n                 });\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         &self,\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n-        caller_mir: &mut Body<'tcx>,\n+        caller_body: &mut Body<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -560,12 +560,12 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n         if tcx.is_closure(callsite.callee) {\n             let mut args = args.into_iter();\n-            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n-            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n+            let self_ = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n+            let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_body);\n             assert!(args.next().is_none());\n \n             let tuple = Place::Base(PlaceBase::Local(tuple));\n-            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).ty.sty {\n+            let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_body, tcx).ty.sty {\n                 s\n             } else {\n                 bug!(\"Closure arguments are not passed as a tuple\");\n@@ -584,13 +584,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     ));\n \n                     // Spill to a local to make e.g., `tmp0`.\n-                    self.create_temp_if_necessary(tuple_field, callsite, caller_mir)\n+                    self.create_temp_if_necessary(tuple_field, callsite, caller_body)\n                 });\n \n             closure_ref_arg.chain(tuple_tmp_args).collect()\n         } else {\n             args.into_iter()\n-                .map(|a| self.create_temp_if_necessary(a, callsite, caller_mir))\n+                .map(|a| self.create_temp_if_necessary(a, callsite, caller_body))\n                 .collect()\n         }\n     }\n@@ -601,13 +601,13 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         &self,\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n-        caller_mir: &mut Body<'tcx>,\n+        caller_body: &mut Body<'tcx>,\n     ) -> Local {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n         if let Operand::Move(Place::Base(PlaceBase::Local(local))) = arg {\n-            if caller_mir.local_kind(local) == LocalKind::Temp {\n+            if caller_body.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n                 return local;\n             }\n@@ -617,16 +617,16 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // Otherwise, create a temporary for the arg\n         let arg = Rvalue::Use(arg);\n \n-        let ty = arg.ty(caller_mir, self.tcx);\n+        let ty = arg.ty(caller_body, self.tcx);\n \n         let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n-        let arg_tmp = caller_mir.local_decls.push(arg_tmp);\n+        let arg_tmp = caller_body.local_decls.push(arg_tmp);\n \n         let stmt = Statement {\n             source_info: callsite.location,\n             kind: StatementKind::Assign(Place::Base(PlaceBase::Local(arg_tmp)), box arg),\n         };\n-        caller_mir[callsite.bb].statements.push(stmt);\n+        caller_body[callsite.bb].statements.push(stmt);\n         arg_tmp\n     }\n }"}, {"sha": "2899112b7b542943d2446d847f1f8d67bac4b606", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -15,7 +15,7 @@ impl MirPass for InstCombine {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -25,13 +25,13 @@ impl MirPass for InstCombine {\n         // read-only so that we can do global analyses on the MIR in the process (e.g.\n         // `Place::ty()`).\n         let optimizations = {\n-            let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n-            optimization_finder.visit_body(mir);\n+            let mut optimization_finder = OptimizationFinder::new(body, tcx);\n+            optimization_finder.visit_body(body);\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations }, mir);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations }, body);\n     }\n }\n \n@@ -64,15 +64,15 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n \n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n-    mir: &'b Body<'tcx>,\n+    body: &'b Body<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     optimizations: OptimizationList<'tcx>,\n }\n \n impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n-    fn new(mir: &'b Body<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n+    fn new(body: &'b Body<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n         OptimizationFinder {\n-            mir,\n+            body,\n             tcx,\n             optimizations: OptimizationList::default(),\n         }\n@@ -83,16 +83,16 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.mir, self.tcx).ty.is_region_ptr() {\n+                if projection.base.ty(self.body, self.tcx).ty.is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }\n         }\n \n         if let Rvalue::Len(ref place) = *rvalue {\n-            let place_ty = place.ty(&self.mir.local_decls, self.tcx).ty;\n+            let place_ty = place.ty(&self.body.local_decls, self.tcx).ty;\n             if let ty::Array(_, len) = place_ty.sty {\n-                let span = self.mir.source_info(location).span;\n+                let span = self.body.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n                 let constant = Constant { span, ty, literal: len, user_ty: None };\n                 self.optimizations.arrays_lengths.insert(location, constant);"}, {"sha": "189258c2e92c471b264b5c54a4bf09ad2eea7f4f", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -13,23 +13,23 @@ impl MirPass for Lower128Bit {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {\n             return\n         }\n \n-        self.lower_128bit_ops(tcx, mir);\n+        self.lower_128bit_ops(tcx, body);\n     }\n }\n \n impl Lower128Bit {\n-    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Body<'tcx>) {\n+    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n         let mut new_blocks = Vec::new();\n-        let cur_len = mir.basic_blocks().len();\n+        let cur_len = body.basic_blocks().len();\n \n-        let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n+        let (basic_blocks, local_decls) = body.basic_blocks_and_local_decls_mut();\n         for block in basic_blocks.iter_mut() {\n             for i in (0..block.statements.len()).rev() {\n                 let (lang_item, rhs_kind) ="}, {"sha": "b6220ac1d21fff2e575130f19e81501f59d635f7", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -145,20 +145,20 @@ pub trait MirPass {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>);\n+                          body: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Body<'tcx>,\n+    body: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n     passes: &[&dyn MirPass],\n ) {\n     let phase_index = mir_phase.phase_index();\n \n-    let run_passes = |mir: &mut Body<'tcx>, promoted| {\n-        if mir.phase >= mir_phase {\n+    let run_passes = |body: &mut Body<'tcx>, promoted| {\n+        if body.phase >= mir_phase {\n             return;\n         }\n \n@@ -168,13 +168,13 @@ pub fn run_passes(\n         };\n         let mut index = 0;\n         let mut run_pass = |pass: &dyn MirPass| {\n-            let run_hooks = |mir: &_, index, is_after| {\n+            let run_hooks = |body: &_, index, is_after| {\n                 dump_mir::on_mir_pass(tcx, &format_args!(\"{:03}-{:03}\", phase_index, index),\n-                                      &pass.name(), source, mir, is_after);\n+                                      &pass.name(), source, body, is_after);\n             };\n-            run_hooks(mir, index, false);\n-            pass.run_pass(tcx, source, mir);\n-            run_hooks(mir, index, true);\n+            run_hooks(body, index, false);\n+            pass.run_pass(tcx, source, body);\n+            run_hooks(body, index, true);\n \n             index += 1;\n         };\n@@ -183,31 +183,31 @@ pub fn run_passes(\n             run_pass(*pass);\n         }\n \n-        mir.phase = mir_phase;\n+        body.phase = mir_phase;\n     };\n \n-    run_passes(mir, None);\n+    run_passes(body, None);\n \n-    for (index, promoted_mir) in mir.promoted.iter_enumerated_mut() {\n-        run_passes(promoted_mir, Some(index));\n+    for (index, promoted_body) in body.promoted.iter_enumerated_mut() {\n+        run_passes(promoted_body, Some(index));\n \n         //Let's make sure we don't miss any nested instances\n-        assert!(promoted_mir.promoted.is_empty())\n+        assert!(promoted_body.promoted.is_empty())\n     }\n }\n \n fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n-    let mut mir = tcx.mir_built(def_id).steal();\n-    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Const, &[\n+    let mut body = tcx.mir_built(def_id).steal();\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);\n-    tcx.alloc_steal_mir(mir)\n+    tcx.alloc_steal_mir(body)\n }\n \n fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n@@ -218,13 +218,13 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         let _ = tcx.mir_const_qualif(def_id);\n     }\n \n-    let mut mir = tcx.mir_const(def_id).steal();\n-    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Validated, &[\n+    let mut body = tcx.mir_const(def_id).steal();\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Validated, &[\n         // What we need to run borrowck etc.\n         &qualify_consts::QualifyAndPromoteConstants,\n         &simplify::SimplifyCfg::new(\"qualify-consts\"),\n     ]);\n-    tcx.alloc_steal_mir(mir)\n+    tcx.alloc_steal_mir(body)\n }\n \n fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n@@ -244,8 +244,8 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         tcx.ensure().borrowck(def_id);\n     }\n \n-    let mut mir = tcx.mir_validated(def_id).steal();\n-    run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Optimized, &[\n+    let mut body = tcx.mir_validated(def_id).steal();\n+    run_passes(tcx, &mut body, InstanceDef::Item(def_id), MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n         &no_landing_pads::NoLandingPads,\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n@@ -298,5 +298,5 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         &add_call_guards::CriticalCallEdges,\n         &dump_mir::Marker(\"PreCodegen\"),\n     ]);\n-    tcx.arena.alloc(mir)\n+    tcx.arena.alloc(body)\n }"}, {"sha": "a987c19c2aba088ac171eace93aeb8914e36e5e0", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -12,14 +12,14 @@ impl MirPass for NoLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        no_landing_pads(tcx, mir)\n+                          body: &mut Body<'tcx>) {\n+        no_landing_pads(tcx, body)\n     }\n }\n \n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Body<'tcx>) {\n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_body(mir);\n+        NoLandingPads.visit_body(body);\n     }\n }\n "}, {"sha": "4fbb95ec4ad351babfd72361d94d1cfa257beafa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -71,7 +71,7 @@ pub enum Candidate {\n struct TempCollector<'tcx> {\n     temps: IndexVec<Local, TempState>,\n     span: Span,\n-    mir: &'tcx Body<'tcx>,\n+    body: &'tcx Body<'tcx>,\n }\n \n impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n@@ -81,7 +81,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n                    location: Location) {\n         debug!(\"visit_local: index={:?} context={:?} location={:?}\", index, context, location);\n         // We're only interested in temporaries and the return place\n-        match self.mir.local_kind(index) {\n+        match self.body.local_kind(index) {\n             | LocalKind::Temp\n             | LocalKind::ReturnPointer\n             => {},\n@@ -134,12 +134,12 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n     }\n }\n \n-pub fn collect_temps(mir: &Body<'_>,\n+pub fn collect_temps(body: &Body<'_>,\n                      rpo: &mut ReversePostorder<'_, '_>) -> IndexVec<Local, TempState> {\n     let mut collector = TempCollector {\n-        temps: IndexVec::from_elem(TempState::Undefined, &mir.local_decls),\n-        span: mir.span,\n-        mir,\n+        temps: IndexVec::from_elem(TempState::Undefined, &body.local_decls),\n+        span: body.span,\n+        body,\n     };\n     for (bb, data) in rpo {\n         collector.visit_basic_block_data(bb, data);\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'a, 'tcx>(mir: &mut Body<'tcx>,\n+pub fn promote_candidates<'a, 'tcx>(body: &mut Body<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n@@ -379,7 +379,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Body<'tcx>,\n     for candidate in candidates.into_iter().rev() {\n         match candidate {\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match mir[block].statements[statement_index].kind {\n+                match body[block].statements[statement_index].kind {\n                     StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _) => {\n                         if temps[local] == TempState::PromotedOut {\n                             // Already promoted.\n@@ -395,27 +395,27 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Body<'tcx>,\n \n         // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(\n-            LocalDecl::new_return_place(tcx.types.never, mir.span)\n+            LocalDecl::new_return_place(tcx.types.never, body.span)\n         ).collect();\n \n         let promoter = Promoter {\n             promoted: Body::new(\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?\n-                mir.source_scopes.clone(),\n-                mir.source_scope_local_data.clone(),\n+                body.source_scopes.clone(),\n+                body.source_scope_local_data.clone(),\n                 IndexVec::new(),\n                 None,\n                 initial_locals,\n                 IndexVec::new(),\n                 0,\n                 vec![],\n-                mir.span,\n+                body.span,\n                 vec![],\n             ),\n             tcx,\n-            source: mir,\n+            source: body,\n             temps: &mut temps,\n             keep_original: false\n         };\n@@ -424,7 +424,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Body<'tcx>,\n \n     // Eliminate assignments to, and drops of promoted temps.\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n-    for block in mir.basic_blocks_mut() {\n+    for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n                 StatementKind::Assign(Place::Base(PlaceBase::Local(index)), _) |"}, {"sha": "69cfdbc28eb11bf5224d519e6bfedb538d81723b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -113,7 +113,7 @@ struct ConstCx<'a, 'tcx> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n \n     per_local: PerQualif<BitSet<Local>>,\n }\n@@ -166,7 +166,7 @@ trait Qualif {\n         let base_qualif = Self::in_place(cx, &proj.base);\n         let qualif = base_qualif && Self::mask_for_ty(\n             cx,\n-            proj.base.ty(cx.mir, cx.tcx)\n+            proj.base.ty(cx.body, cx.tcx)\n                 .projection_ty(cx.tcx, &proj.elem)\n                 .ty,\n         );\n@@ -245,7 +245,7 @@ trait Qualif {\n                 // Special-case reborrows to be more like a copy of the reference.\n                 if let Place::Projection(ref proj) = *place {\n                     if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n+                        let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, &proj.base);\n                         }\n@@ -301,7 +301,7 @@ impl Qualif for HasMutInterior {\n             // allowed in constants (and the `Checker` will error), and/or it\n             // won't be promoted, due to `&mut ...` or interior mutability.\n             Rvalue::Ref(_, kind, ref place) => {\n-                let ty = place.ty(cx.mir, cx.tcx).ty;\n+                let ty = place.ty(cx.body, cx.tcx).ty;\n \n                 if let BorrowKind::Mut { .. } = kind {\n                     // In theory, any zero-sized value could be borrowed\n@@ -329,7 +329,7 @@ impl Qualif for HasMutInterior {\n             Rvalue::Aggregate(ref kind, _) => {\n                 if let AggregateKind::Adt(def, ..) = **kind {\n                     if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(cx.mir, cx.tcx);\n+                        let ty = rvalue.ty(cx.body, cx.tcx);\n                         assert_eq!(Self::in_any_value_of_ty(cx, ty), Some(true));\n                         return true;\n                     }\n@@ -399,7 +399,7 @@ impl Qualif for IsNotPromotable {\n \n             ProjectionElem::Field(..) => {\n                 if cx.mode == Mode::Fn {\n-                    let base_ty = proj.base.ty(cx.mir, cx.tcx).ty;\n+                    let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n                         if def.is_union() {\n                             return true;\n@@ -415,7 +415,7 @@ impl Qualif for IsNotPromotable {\n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n         match *rvalue {\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::Fn => {\n-                let operand_ty = operand.ty(cx.mir, cx.tcx);\n+                let operand_ty = operand.ty(cx.body, cx.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -429,7 +429,7 @@ impl Qualif for IsNotPromotable {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::Fn => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.mir, cx.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -454,7 +454,7 @@ impl Qualif for IsNotPromotable {\n         args: &[Operand<'tcx>],\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n-        let fn_ty = callee.ty(cx.mir, cx.tcx);\n+        let fn_ty = callee.ty(cx.body, cx.tcx);\n         match fn_ty.sty {\n             ty::FnDef(def_id, _) => {\n                 match cx.tcx.fn_sig(def_id).abi() {\n@@ -529,7 +529,7 @@ impl Qualif for IsNotImplicitlyPromotable {\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n         if cx.mode == Mode::Fn {\n-            if let ty::FnDef(def_id, _) = callee.ty(cx.mir, cx.tcx).sty {\n+            if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).sty {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n                 if !cx.tcx.is_promotable_const_fn(def_id) {\n@@ -620,12 +620,12 @@ impl Deref for Checker<'a, 'tcx> {\n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            def_id: DefId,\n-           mir: &'a Body<'tcx>,\n+           body: &'a Body<'tcx>,\n            mode: Mode)\n            -> Self {\n         assert!(def_id.is_local());\n-        let mut rpo = traversal::reverse_postorder(mir);\n-        let temps = promote_consts::collect_temps(mir, &mut rpo);\n+        let mut rpo = traversal::reverse_postorder(body);\n+        let temps = promote_consts::collect_temps(body, &mut rpo);\n         rpo.reset();\n \n         let param_env = tcx.param_env(def_id);\n@@ -634,12 +634,12 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             tcx,\n             param_env,\n             mode,\n-            mir,\n-            per_local: PerQualif::new(BitSet::new_empty(mir.local_decls.len())),\n+            body,\n+            per_local: PerQualif::new(BitSet::new_empty(body.local_decls.len())),\n         };\n \n-        for (local, decl) in mir.local_decls.iter_enumerated() {\n-            if let LocalKind::Arg = mir.local_kind(local) {\n+        for (local, decl) in body.local_decls.iter_enumerated() {\n+            if let LocalKind::Arg = body.local_kind(local) {\n                 let qualifs = cx.qualifs_in_any_value_of_ty(decl.ty);\n                 for (per_local, qualif) in &mut cx.per_local.as_mut().zip(qualifs).0 {\n                     if *qualif {\n@@ -650,7 +650,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             if !temps[local].is_promotable() {\n                 cx.per_local[IsNotPromotable].insert(local);\n             }\n-            if let LocalKind::Var = mir.local_kind(local) {\n+            if let LocalKind::Var = body.local_kind(local) {\n                 // Sanity check to prevent implicit and explicit promotion of\n                 // named locals\n                 assert!(cx.per_local[IsNotPromotable].contains(local));\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n         Checker {\n             cx,\n-            span: mir.span,\n+            span: body.span,\n             def_id,\n             rpo,\n             temp_promotion_state: temps,\n@@ -747,7 +747,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 }\n                 debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n                 if let Place::Base(PlaceBase::Local(local)) = *place {\n-                    if self.mir.local_kind(local) == LocalKind::Temp {\n+                    if self.body.local_kind(local) == LocalKind::Temp {\n                         debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n                         // The borrowed place doesn't have `HasMutInterior`\n                         // (from `in_rvalue`), so we can safely ignore\n@@ -799,7 +799,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             }\n         };\n \n-        let kind = self.mir.local_kind(index);\n+        let kind = self.body.local_kind(index);\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n         // Only handle promotable temps in non-const functions.\n@@ -837,16 +837,16 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n-        let mir = self.mir;\n+        let body = self.body;\n \n-        let mut seen_blocks = BitSet::new_empty(mir.basic_blocks().len());\n+        let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n         let mut bb = START_BLOCK;\n         loop {\n             seen_blocks.insert(bb.index());\n \n-            self.visit_basic_block_data(bb, &mir[bb]);\n+            self.visit_basic_block_data(bb, &body[bb]);\n \n-            let target = match mir[bb].terminator().kind {\n+            let target = match body[bb].terminator().kind {\n                 TerminatorKind::Goto { target } |\n                 TerminatorKind::Drop { target, .. } |\n                 TerminatorKind::Assert { target, .. } |\n@@ -894,7 +894,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         for candidate in &self.promotion_candidates {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n-                    match self.mir[bb].statements[stmt_idx].kind {\n+                    match self.body[bb].statements[stmt_idx].kind {\n                         StatementKind::Assign(\n                             _,\n                             box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n@@ -913,7 +913,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         // Account for errors in consts by using the\n         // conservative type qualification instead.\n         if qualifs[IsNotPromotable] {\n-            qualifs = self.qualifs_in_any_value_of_ty(mir.return_ty());\n+            qualifs = self.qualifs_in_any_value_of_ty(body.return_ty());\n         }\n \n         (qualifs.encode_to_bits(), self.tcx.arena.alloc(promoted_temps))\n@@ -1003,7 +1003,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     // `not_const` errors out in const contexts\n                     self.not_const()\n                 }\n-                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                 match self.mode {\n                     Mode::Fn => {},\n                     _ => {\n@@ -1027,7 +1027,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             ProjectionElem::Subslice {..} |\n             ProjectionElem::Field(..) |\n             ProjectionElem::Index(_) => {\n-                let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                 if let Some(def) = base_ty.ty_adt_def() {\n                     if def.is_union() {\n                         match self.mode {\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             let mut reborrow_place = None;\n             if let Place::Projection(ref proj) = *place {\n                 if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                    let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n                         reborrow_place = Some(&proj.base);\n                     }\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             Rvalue::Aggregate(..) => {}\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.mir, self.tcx);\n+                let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.mir, self.tcx).sty {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -1201,11 +1201,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.assign(dest, ValueSource::Call {\n                     callee: func,\n                     args,\n-                    return_ty: dest.ty(self.mir, self.tcx).ty,\n+                    return_ty: dest.ty(self.body, self.tcx).ty,\n                 }, location);\n             }\n \n-            let fn_ty = func.ty(self.mir, self.tcx);\n+            let fn_ty = func.ty(self.body, self.tcx);\n             let mut callee_def_id = None;\n             let mut is_shuffle = false;\n             match fn_ty.sty {\n@@ -1367,7 +1367,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Base(PlaceBase::Local(local)) = *place {\n                     if NeedsDrop::in_local(self, local) {\n-                        Some(self.mir.local_decls[local].source_info.span)\n+                        Some(self.body.local_decls[local].source_info.span)\n                     } else {\n                         None\n                     }\n@@ -1377,7 +1377,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 if let Some(span) = needs_drop {\n                     // Double-check the type being dropped, to minimize false positives.\n-                    let ty = place.ty(self.mir, self.tcx).ty;\n+                    let ty = place.ty(self.body, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")\n@@ -1441,14 +1441,14 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal.\n-    let mir = &tcx.mir_const(def_id).borrow();\n+    let body = &tcx.mir_const(def_id).borrow();\n \n-    if mir.return_ty().references_error() {\n-        tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: MIR had errors\");\n+    if body.return_ty().references_error() {\n+        tcx.sess.delay_span_bug(body.span, \"mir_const_qualif: MIR had errors\");\n         return (1 << IsNotPromotable::IDX, tcx.arena.alloc(BitSet::new_empty(0)));\n     }\n \n-    Checker::new(tcx, def_id, mir, Mode::Const).check_const()\n+    Checker::new(tcx, def_id, body, Mode::Const).check_const()\n }\n \n pub struct QualifyAndPromoteConstants;\n@@ -1457,10 +1457,10 @@ impl MirPass for QualifyAndPromoteConstants {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n+                          body: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n-        if mir.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(mir.span, \"QualifyAndPromoteConstants: MIR had errors\");\n+        if body.return_ty().references_error() {\n+            tcx.sess.delay_span_bug(body.span, \"QualifyAndPromoteConstants: MIR had errors\");\n             return;\n         }\n \n@@ -1493,14 +1493,14 @@ impl MirPass for QualifyAndPromoteConstants {\n             // This is ugly because Checker holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n-                let mut checker = Checker::new(tcx, def_id, mir, mode);\n+                let mut checker = Checker::new(tcx, def_id, body, mode);\n                 if mode == Mode::ConstFn {\n                     if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n                         checker.check_const();\n                     } else if tcx.is_min_const_fn(def_id) {\n                         // enforce `min_const_fn` for stable const fns\n                         use super::qualify_min_const_fn::is_min_const_fn;\n-                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, mir) {\n+                        if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n                             let mut diag = struct_span_err!(\n                                 tcx.sess,\n                                 span,\n@@ -1533,12 +1533,12 @@ impl MirPass for QualifyAndPromoteConstants {\n             };\n \n             // Do the actual promotion, now that we know what's viable.\n-            promote_consts::promote_candidates(mir, tcx, temps, candidates);\n+            promote_consts::promote_candidates(body, tcx, temps, candidates);\n         } else {\n-            if !mir.control_flow_destroyed.is_empty() {\n-                let mut locals = mir.vars_iter();\n+            if !body.control_flow_destroyed.is_empty() {\n+                let mut locals = body.vars_iter();\n                 if let Some(local) = locals.next() {\n-                    let span = mir.local_decls[local].source_info.span;\n+                    let span = body.local_decls[local].source_info.span;\n                     let mut error = tcx.sess.struct_span_err(\n                         span,\n                         &format!(\n@@ -1547,7 +1547,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                             mode,\n                         ),\n                     );\n-                    for (span, kind) in mir.control_flow_destroyed.iter() {\n+                    for (span, kind) in body.control_flow_destroyed.iter() {\n                         error.span_note(\n                             *span,\n                             &format!(\"use of {} here does not actually short circuit due to \\\n@@ -1557,7 +1557,7 @@ impl MirPass for QualifyAndPromoteConstants {\n                         );\n                     }\n                     for local in locals {\n-                        let span = mir.local_decls[local].source_info.span;\n+                        let span = body.local_decls[local].source_info.span;\n                         error.span_note(\n                             span,\n                             \"more locals defined here\",\n@@ -1570,14 +1570,14 @@ impl MirPass for QualifyAndPromoteConstants {\n                 // Already computed by `mir_const_qualif`.\n                 const_promoted_temps.unwrap()\n             } else {\n-                Checker::new(tcx, def_id, mir, mode).check_const().1\n+                Checker::new(tcx, def_id, body, mode).check_const().1\n             };\n \n             // In `const` and `static` everything without `StorageDead`\n             // is `'static`, we don't have to create promoted MIR fragments,\n             // just remove `Drop` and `StorageDead` on \"promoted\" locals.\n             debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-            for block in mir.basic_blocks_mut() {\n+            for block in body.basic_blocks_mut() {\n                 block.statements.retain(|statement| {\n                     match statement.kind {\n                         StatementKind::StorageDead(index) => {\n@@ -1612,10 +1612,10 @@ impl MirPass for QualifyAndPromoteConstants {\n                     return;\n                 }\n             }\n-            let ty = mir.return_ty();\n+            let ty = body.return_ty();\n             tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty();\n-                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                let cause = traits::ObligationCause::new(body.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();\n                 fulfillment_cx.register_bound(&infcx,\n                                               param_env,"}, {"sha": "f96675864562f3b410773183e4dadf0ba255e4eb", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -11,7 +11,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n ) -> McfResult {\n     let mut current = def_id;\n     loop {\n@@ -59,21 +59,21 @@ pub fn is_min_const_fn(\n         }\n     }\n \n-    for local in &mir.local_decls {\n+    for local in &body.local_decls {\n         check_ty(tcx, local.ty, local.source_info.span, def_id)?;\n     }\n     // impl trait is gone in MIR, so check the return type manually\n     check_ty(\n         tcx,\n         tcx.fn_sig(def_id).output().skip_binder(),\n-        mir.local_decls.iter().next().unwrap().source_info.span,\n+        body.local_decls.iter().next().unwrap().source_info.span,\n         def_id,\n     )?;\n \n-    for bb in mir.basic_blocks() {\n-        check_terminator(tcx, mir, bb.terminator())?;\n+    for bb in body.basic_blocks() {\n+        check_terminator(tcx, body, bb.terminator())?;\n         for stmt in &bb.statements {\n-            check_statement(tcx, mir, stmt)?;\n+            check_statement(tcx, body, stmt)?;\n         }\n     }\n     Ok(())\n@@ -130,7 +130,7 @@ fn check_ty(\n \n fn check_rvalue(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n ) -> McfResult {\n@@ -143,7 +143,7 @@ fn check_rvalue(\n         }\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc::ty::cast::CastTy;\n-            let cast_in = CastTy::from_ty(operand.ty(mir, tcx)).expect(\"bad input type for cast\");\n+            let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n             let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n             match (cast_in, cast_out) {\n                 (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => Err((\n@@ -173,7 +173,7 @@ fn check_rvalue(\n         Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n             check_operand(lhs, span)?;\n             check_operand(rhs, span)?;\n-            let ty = lhs.ty(mir, tcx);\n+            let ty = lhs.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() || ty.is_char() {\n                 Ok(())\n             } else {\n@@ -189,7 +189,7 @@ fn check_rvalue(\n             \"heap allocations are not allowed in const fn\".into(),\n         )),\n         Rvalue::UnaryOp(_, operand) => {\n-            let ty = operand.ty(mir, tcx);\n+            let ty = operand.ty(body, tcx);\n             if ty.is_integral() || ty.is_bool() {\n                 check_operand(operand, span)\n             } else {\n@@ -210,14 +210,14 @@ fn check_rvalue(\n \n fn check_statement(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     statement: &Statement<'tcx>,\n ) -> McfResult {\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(place, rval) => {\n             check_place(place, span)?;\n-            check_rvalue(tcx, mir, rval, span)\n+            check_rvalue(tcx, body, rval, span)\n         }\n \n         StatementKind::FakeRead(_, place) => check_place(place, span),\n@@ -280,7 +280,7 @@ fn check_place(\n \n fn check_terminator(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n     let span = terminator.source_info.span;\n@@ -315,7 +315,7 @@ fn check_terminator(\n             destination: _,\n             cleanup: _,\n         } => {\n-            let fn_ty = func.ty(mir, tcx);\n+            let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.sty {\n \n                 // some intrinsics are waved through if called inside the"}, {"sha": "30edf7f14a3d3c4ec44a9a06c60ca6943d912903", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -11,33 +11,33 @@ pub struct RemoveNoopLandingPads;\n \n pub fn remove_noop_landing_pads<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Body<'tcx>)\n+    body: &mut Body<'tcx>)\n {\n     if tcx.sess.no_landing_pads() {\n         return\n     }\n-    debug!(\"remove_noop_landing_pads({:?})\", mir);\n+    debug!(\"remove_noop_landing_pads({:?})\", body);\n \n-    RemoveNoopLandingPads.remove_nop_landing_pads(mir)\n+    RemoveNoopLandingPads.remove_nop_landing_pads(body)\n }\n \n impl MirPass for RemoveNoopLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        remove_noop_landing_pads(tcx, mir);\n+                          body: &mut Body<'tcx>) {\n+        remove_noop_landing_pads(tcx, body);\n     }\n }\n \n impl RemoveNoopLandingPads {\n     fn is_nop_landing_pad(\n         &self,\n         bb: BasicBlock,\n-        mir: &Body<'_>,\n+        body: &Body<'_>,\n         nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n-        for stmt in &mir[bb].statements {\n+        for stmt in &body[bb].statements {\n             match stmt.kind {\n                 StatementKind::FakeRead(..) |\n                 StatementKind::StorageLive(_) |\n@@ -61,7 +61,7 @@ impl RemoveNoopLandingPads {\n             }\n         }\n \n-        let terminator = mir[bb].terminator();\n+        let terminator = body[bb].terminator();\n         match terminator.kind {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n@@ -86,34 +86,34 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, mir: &mut Body<'_>) {\n+    fn remove_nop_landing_pads(&self, body: &mut Body<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n-            let patch = MirPatch::new(mir);\n+            let patch = MirPatch::new(body);\n             let resume_block = patch.resume_block();\n-            patch.apply(mir);\n+            patch.apply(body);\n             resume_block\n         };\n         debug!(\"remove_noop_landing_pads: resume block is {:?}\", resume_block);\n \n         let mut jumps_folded = 0;\n         let mut landing_pads_removed = 0;\n-        let mut nop_landing_pads = BitSet::new_empty(mir.basic_blocks().len());\n+        let mut nop_landing_pads = BitSet::new_empty(body.basic_blocks().len());\n \n         // This is a post-order traversal, so that if A post-dominates B\n         // then A will be visited before B.\n-        let postorder: Vec<_> = traversal::postorder(mir).map(|(bb, _)| bb).collect();\n+        let postorder: Vec<_> = traversal::postorder(body).map(|(bb, _)| bb).collect();\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n-            for target in mir[bb].terminator_mut().successors_mut() {\n+            for target in body[bb].terminator_mut().successors_mut() {\n                 if *target != resume_block && nop_landing_pads.contains(*target) {\n                     debug!(\"    folding noop jump to {:?} to resume block\", target);\n                     *target = resume_block;\n                     jumps_folded += 1;\n                 }\n             }\n \n-            match mir[bb].terminator_mut().unwind_mut() {\n+            match body[bb].terminator_mut().unwind_mut() {\n                 Some(unwind) => {\n                     if *unwind == Some(resume_block) {\n                         debug!(\"    removing noop landing pad\");\n@@ -125,7 +125,7 @@ impl RemoveNoopLandingPads {\n                 _ => {}\n             }\n \n-            let is_nop_landing_pad = self.is_nop_landing_pad(bb, mir, &nop_landing_pads);\n+            let is_nop_landing_pad = self.is_nop_landing_pad(bb, body, &nop_landing_pads);\n             if is_nop_landing_pad {\n                 nop_landing_pads.insert(bb);\n             }"}, {"sha": "a6ae03e834b5e8fcf713e39de1380cd57358b2c0", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -26,7 +26,7 @@ pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>, mir: &mut Body<'tcx>) {\n+                          src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -37,30 +37,30 @@ impl MirPass for SanityCheck {\n \n         let attributes = tcx.get_attrs(def_id);\n         let param_env = tcx.param_env(def_id);\n-        let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n+        let move_data = MoveData::gather_moves(body, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n+        let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n         let flow_inits =\n-            do_dataflow(tcx, mir, def_id, &attributes, &dead_unwinds,\n-                        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        MaybeInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n-            do_dataflow(tcx, mir, def_id, &attributes, &dead_unwinds,\n-                        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        MaybeUninitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n-            do_dataflow(tcx, mir, def_id, &attributes, &dead_unwinds,\n-                        DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n+            do_dataflow(tcx, body, def_id, &attributes, &dead_unwinds,\n+                        DefinitelyInitializedPlaces::new(tcx, body, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_inits);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n-            sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_uninits);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n         if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n-            sanity_check_via_rustc_peek(tcx, mir, def_id, &attributes, &flow_def_inits);\n+            sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n         if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n@@ -85,7 +85,7 @@ impl MirPass for SanityCheck {\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                mir: &Body<'tcx>,\n+                                                body: &Body<'tcx>,\n                                                 def_id: DefId,\n                                                 _attributes: &[ast::Attribute],\n                                                 results: &DataflowResults<'tcx, O>)\n@@ -96,19 +96,19 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // `dataflow::build_sets`. (But note it is doing non-standard\n     // stuff, so such generalization may not be realistic.)\n \n-    for bb in mir.basic_blocks().indices() {\n-        each_block(tcx, mir, results, bb);\n+    for bb in body.basic_blocks().indices() {\n+        each_block(tcx, body, results, bb);\n     }\n }\n \n fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mir: &Body<'tcx>,\n+                           body: &Body<'tcx>,\n                            results: &DataflowResults<'tcx, O>,\n                            bb: mir::BasicBlock) where\n     O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>\n {\n     let move_data = results.0.operator.move_data();\n-    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = mir[bb];\n+    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n \n     let (args, span) = match is_rustc_peek(tcx, terminator) {\n         Some(args_and_span) => args_and_span,"}, {"sha": "f1ca93ec13ffa0d4d145f8994dca5c38e08e36e5", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -44,12 +44,12 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(mir: &mut Body<'_>) {\n-    CfgSimplifier::new(mir).simplify();\n-    remove_dead_blocks(mir);\n+pub fn simplify_cfg(body: &mut Body<'_>) {\n+    CfgSimplifier::new(body).simplify();\n+    remove_dead_blocks(body);\n \n     // FIXME: Should probably be moved into some kind of pass manager\n-    mir.basic_blocks_mut().raw.shrink_to_fit();\n+    body.basic_blocks_mut().raw.shrink_to_fit();\n }\n \n impl MirPass for SimplifyCfg {\n@@ -60,9 +60,9 @@ impl MirPass for SimplifyCfg {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n-        simplify_cfg(mir);\n+                          body: &mut Body<'tcx>) {\n+        debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, body);\n+        simplify_cfg(body);\n     }\n }\n \n@@ -72,22 +72,22 @@ pub struct CfgSimplifier<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(mir: &'a mut Body<'tcx>) -> Self {\n-        let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n+    pub fn new(body: &'a mut Body<'tcx>) -> Self {\n+        let mut pred_count = IndexVec::from_elem(0u32, body.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n         // dead blocks, which we don't want to.\n         pred_count[START_BLOCK] = 1;\n \n-        for (_, data) in traversal::preorder(mir) {\n+        for (_, data) in traversal::preorder(body) {\n             if let Some(ref term) = data.terminator {\n                 for &tgt in term.successors() {\n                     pred_count[tgt] += 1;\n                 }\n             }\n         }\n \n-        let basic_blocks = mir.basic_blocks_mut();\n+        let basic_blocks = body.basic_blocks_mut();\n \n         CfgSimplifier {\n             basic_blocks,\n@@ -263,13 +263,13 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(mir: &mut Body<'_>) {\n-    let mut seen = BitSet::new_empty(mir.basic_blocks().len());\n-    for (bb, _) in traversal::preorder(mir) {\n+pub fn remove_dead_blocks(body: &mut Body<'_>) {\n+    let mut seen = BitSet::new_empty(body.basic_blocks().len());\n+    for (bb, _) in traversal::preorder(body) {\n         seen.insert(bb.index());\n     }\n \n-    let basic_blocks = mir.basic_blocks_mut();\n+    let basic_blocks = body.basic_blocks_mut();\n \n     let num_blocks = basic_blocks.len();\n     let mut replacements : Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n@@ -299,26 +299,26 @@ impl MirPass for SimplifyLocals {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        let mut marker = DeclMarker { locals: BitSet::new_empty(mir.local_decls.len()) };\n-        marker.visit_body(mir);\n+                          body: &mut Body<'tcx>) {\n+        let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()) };\n+        marker.visit_body(body);\n         // Return pointer and arguments are always live\n         marker.locals.insert(RETURN_PLACE);\n-        for arg in mir.args_iter() {\n+        for arg in body.args_iter() {\n             marker.locals.insert(arg);\n         }\n \n         // We may need to keep dead user variables live for debuginfo.\n         if tcx.sess.opts.debuginfo == DebugInfo::Full {\n-            for local in mir.vars_iter() {\n+            for local in body.vars_iter() {\n                 marker.locals.insert(local);\n             }\n         }\n \n-        let map = make_local_map(&mut mir.local_decls, marker.locals);\n+        let map = make_local_map(&mut body.local_decls, marker.locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map }.visit_body(mir);\n-        mir.local_decls.shrink_to_fit();\n+        LocalUpdater { map }.visit_body(body);\n+        body.local_decls.shrink_to_fit();\n     }\n }\n "}, {"sha": "938fa772e90807e1f0482ccf01360622d4eceac2", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -22,8 +22,8 @@ impl MirPass for SimplifyBranches {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        for block in mir.basic_blocks_mut() {\n+                          body: &mut Body<'tcx>) {\n+        for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n                 TerminatorKind::SwitchInt {"}, {"sha": "fbfc296cc31fae4ef56150bc0da5ba9169924b38", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -40,18 +40,18 @@ impl MirPass for UniformArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        let mut patch = MirPatch::new(mir);\n+                          body: &mut Body<'tcx>) {\n+        let mut patch = MirPatch::new(body);\n         {\n-            let mut visitor = UniformArrayMoveOutVisitor{mir, patch: &mut patch, tcx};\n-            visitor.visit_body(mir);\n+            let mut visitor = UniformArrayMoveOutVisitor{body, patch: &mut patch, tcx};\n+            visitor.visit_body(body);\n         }\n-        patch.apply(mir);\n+        patch.apply(body);\n     }\n }\n \n struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n-    mir: &'a Body<'tcx>,\n+    body: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                                      from_end: false} = proj.elem {\n                     // no need to transformation\n                 } else {\n-                    let place_ty = proj.base.ty(self.mir, self.tcx).ty;\n+                    let place_ty = proj.base.ty(self.body, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.assert_usize(self.tcx) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n             ProjectionElem::Subslice{from, to} => {\n                 self.patch.make_nop(location);\n                 let temps : Vec<_> = (from..(size-to)).map(|i| {\n-                    let temp = self.patch.new_temp(item_ty, self.mir.source_info(location).span);\n+                    let temp = self.patch.new_temp(item_ty, self.body.source_info(location).span);\n                     self.patch.add_statement(location, StatementKind::StorageLive(temp));\n                     self.patch.add_assign(location,\n                                           Place::Base(PlaceBase::Local(temp)),\n@@ -165,23 +165,24 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Body<'tcx>) {\n-        let mut patch = MirPatch::new(mir);\n+                          body: &mut Body<'tcx>) {\n+        let mut patch = MirPatch::new(body);\n         {\n             let mut visitor = RestoreDataCollector {\n-                locals_use: IndexVec::from_elem(LocalUse::new(), &mir.local_decls),\n+                locals_use: IndexVec::from_elem(LocalUse::new(), &body.local_decls),\n                 candidates: vec![],\n             };\n-            visitor.visit_body(mir);\n+            visitor.visit_body(body);\n \n             for candidate in &visitor.candidates {\n-                let statement = &mir[candidate.block].statements[candidate.statement_index];\n+                let statement = &body[candidate.block].statements[candidate.statement_index];\n                 if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = **rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(Place::Base(PlaceBase::Local(local))) = item {\n                                 let local_use = &visitor.locals_use[*local];\n-                                let opt_index_and_place = Self::try_get_item_source(local_use, mir);\n+                                let opt_index_and_place =\n+                                    Self::try_get_item_source(local_use, body);\n                                 // each local should be used twice:\n                                 //  in assign and in aggregate statements\n                                 if local_use.use_count == 2 && opt_index_and_place.is_some() {\n@@ -194,7 +195,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n \n                         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n                         let opt_size = opt_src_place.and_then(|src_place| {\n-                            let src_ty = src_place.ty(mir, tcx).ty;\n+                            let src_ty = src_place.ty(body, tcx).ty;\n                             if let ty::Array(_, ref size_o) = src_ty.sty {\n                                 size_o.assert_usize(tcx)\n                             } else {\n@@ -206,7 +207,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                 }\n             }\n         }\n-        patch.apply(mir);\n+        patch.apply(body);\n     }\n }\n \n@@ -254,9 +255,9 @@ impl RestoreSubsliceArrayMoveOut {\n     }\n \n     fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n-                                     mir: &'a Body<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n+                                     body: &'a Body<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n         if let Some(location) = local_use.first_use {\n-            let block = &mir[location.block];\n+            let block = &body[location.block];\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign("}, {"sha": "fac752dbf023e9675fd7231f39b35bc7a90b2c65", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -21,19 +21,19 @@ pub struct Use {\n }\n \n impl DefUseAnalysis {\n-    pub fn new(mir: &Body<'_>) -> DefUseAnalysis {\n+    pub fn new(body: &Body<'_>) -> DefUseAnalysis {\n         DefUseAnalysis {\n-            info: IndexVec::from_elem_n(Info::new(), mir.local_decls.len()),\n+            info: IndexVec::from_elem_n(Info::new(), body.local_decls.len()),\n         }\n     }\n \n-    pub fn analyze(&mut self, mir: &Body<'_>) {\n+    pub fn analyze(&mut self, body: &Body<'_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n             info: mem::replace(&mut self.info, IndexVec::new()),\n         };\n-        finder.visit_body(mir);\n+        finder.visit_body(body);\n         self.info = finder.info\n     }\n \n@@ -47,23 +47,23 @@ impl DefUseAnalysis {\n         &self.info[local]\n     }\n \n-    fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Body<'_>, mut callback: F)\n+    fn mutate_defs_and_uses<F>(&self, local: Local, body: &mut Body<'_>, mut callback: F)\n                                where F: for<'a> FnMut(&'a mut Local,\n                                                       PlaceContext,\n                                                       Location) {\n         for place_use in &self.info[local].defs_and_uses {\n             MutateUseVisitor::new(local,\n                                   &mut callback,\n-                                  mir).visit_location(mir, place_use.location)\n+                                  body).visit_location(body, place_use.location)\n         }\n     }\n \n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          mir: &mut Body<'_>,\n+                                          body: &mut Body<'_>,\n                                           new_local: Local) {\n-        self.mutate_defs_and_uses(local, mir, |local, _, _| *local = new_local)\n+        self.mutate_defs_and_uses(local, body, |local, _, _| *local = new_local)\n     }\n }\n "}, {"sha": "6d761525639bd0c10dea3d90b0f0e7ebf986646a", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -74,7 +74,7 @@ pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n-    fn mir(&self) -> &'a Body<'tcx>;\n+    fn body(&self) -> &'a Body<'tcx>;\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n@@ -122,7 +122,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n     fn place_ty(&self, place: &Place<'tcx>) -> Ty<'tcx> {\n-        place.ty(self.elaborator.mir(), self.tcx()).ty\n+        place.ty(self.elaborator.body(), self.tcx()).ty\n     }\n \n     fn tcx(&self) -> TyCtxt<'b, 'tcx, 'tcx> {\n@@ -799,7 +799,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             // within that own generator's resume function.\n             // This should only happen for the self argument on the resume function.\n             // It effetively only contains upvars until the generator transformation runs.\n-            // See librustc_mir/transform/generator.rs for more details.\n+            // See librustc_body/transform/generator.rs for more details.\n             ty::Generator(def_id, substs, _) => {\n                 let tys : Vec<_> = substs.upvar_tys(def_id, self.tcx()).collect();\n                 self.open_drop_for_tuple(&tys)\n@@ -966,8 +966,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     fn terminator_loc(&mut self, bb: BasicBlock) -> Location {\n-        let mir = self.elaborator.mir();\n-        self.elaborator.patch().terminator_loc(mir, bb)\n+        let body = self.elaborator.body();\n+        self.elaborator.patch().terminator_loc(body, bb)\n     }\n \n     fn constant_usize(&self, val: u16) -> Operand<'tcx> {"}, {"sha": "fe0a1198701401028942fa0f00c65e7020dd3519", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -15,8 +15,8 @@ pub fn write_mir_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n     where W: Write\n {\n     for def_id in dump_mir_def_ids(tcx, single) {\n-        let mir = &tcx.optimized_mir(def_id);\n-        write_mir_fn_graphviz(tcx, def_id, mir, w)?;\n+        let body = &tcx.optimized_mir(def_id);\n+        write_mir_fn_graphviz(tcx, def_id, body, w)?;\n     }\n     Ok(())\n }\n@@ -34,7 +34,7 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n /// Write a graphviz DOT graph of the MIR.\n pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n                                       def_id: DefId,\n-                                      mir: &Body<'_>,\n+                                      body: &Body<'_>,\n                                       w: &mut W) -> io::Result<()>\n     where W: Write\n {\n@@ -46,16 +46,16 @@ pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n     writeln!(w, r#\"    edge [fontname=\"monospace\"];\"#)?;\n \n     // Graph label\n-    write_graph_label(tcx, def_id, mir, w)?;\n+    write_graph_label(tcx, def_id, body, w)?;\n \n     // Nodes\n-    for (block, _) in mir.basic_blocks().iter_enumerated() {\n-        write_node(block, mir, w)?;\n+    for (block, _) in body.basic_blocks().iter_enumerated() {\n+        write_node(block, body, w)?;\n     }\n \n     // Edges\n-    for (source, _) in mir.basic_blocks().iter_enumerated() {\n-        write_edges(source, mir, w)?;\n+    for (source, _) in body.basic_blocks().iter_enumerated() {\n+        write_edges(source, body, w)?;\n     }\n     writeln!(w, \"}}\")\n }\n@@ -68,15 +68,15 @@ pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n /// `init` and `fini` are callbacks for emitting additional rows of\n /// data (using HTML enclosed with `<tr>` in the emitted text).\n pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n-                                              mir: &Body<'_>,\n+                                              body: &Body<'_>,\n                                               w: &mut W,\n                                               num_cols: u32,\n                                               init: INIT,\n                                               fini: FINI) -> io::Result<()>\n     where INIT: Fn(&mut W) -> io::Result<()>,\n           FINI: Fn(&mut W) -> io::Result<()>\n {\n-    let data = &mir[block];\n+    let data = &body[block];\n \n     write!(w, r#\"<table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\"#)?;\n \n@@ -110,17 +110,17 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n }\n \n /// Write a graphviz DOT node for the given basic block.\n-fn write_node<W: Write>(block: BasicBlock, mir: &Body<'_>, w: &mut W) -> io::Result<()> {\n+fn write_node<W: Write>(block: BasicBlock, body: &Body<'_>, w: &mut W) -> io::Result<()> {\n     // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n     write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block))?;\n-    write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(()))?;\n+    write_node_label(block, body, w, 1, |_| Ok(()), |_| Ok(()))?;\n     // Close the node label and the node itself.\n     writeln!(w, \">];\")\n }\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n-fn write_edges<W: Write>(source: BasicBlock, mir: &Body<'_>, w: &mut W) -> io::Result<()> {\n-    let terminator = mir[source].terminator();\n+fn write_edges<W: Write>(source: BasicBlock, body: &Body<'_>, w: &mut W) -> io::Result<()> {\n+    let terminator = body[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n     for (&target, label) in terminator.successors().zip(labels) {\n@@ -135,28 +135,28 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Body<'_>, w: &mut W) -> io::R\n /// all the variables and temporaries.\n fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                def_id: DefId,\n-                                               mir: &Body<'_>,\n+                                               body: &Body<'_>,\n                                                w: &mut W)\n                                                -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;\n \n     // fn argument types.\n-    for (i, arg) in mir.args_iter().enumerate() {\n+    for (i, arg) in body.args_iter().enumerate() {\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n         write!(w,\n                \"{:?}: {}\",\n                Place::Base(PlaceBase::Local(arg)),\n-               escape(&mir.local_decls[arg].ty)\n+               escape(&body.local_decls[arg].ty)\n         )?;\n     }\n \n-    write!(w, \") -&gt; {}\", escape(&mir.return_ty()))?;\n+    write!(w, \") -&gt; {}\", escape(&body.return_ty()))?;\n     write!(w, r#\"<br align=\"left\"/>\"#)?;\n \n-    for local in mir.vars_and_temps_iter() {\n-        let decl = &mir.local_decls[local];\n+    for local in body.vars_and_temps_iter() {\n+        let decl = &body.local_decls[local];\n \n         write!(w, \"let \")?;\n         if decl.mutability == Mutability::Mut {"}, {"sha": "8bc43b6107461a5195f3fcedc489b68527011a9d", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -57,17 +57,17 @@ pub struct LivenessResult {\n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n pub fn liveness_of_locals<'tcx>(\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n ) -> LivenessResult {\n-    let num_live_vars = mir.local_decls.len();\n+    let num_live_vars = body.local_decls.len();\n \n-    let def_use: IndexVec<_, DefsUses> = mir\n+    let def_use: IndexVec<_, DefsUses> = body\n         .basic_blocks()\n         .iter()\n         .map(|b| block(b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, LiveVarSet> = mir\n+    let mut outs: IndexVec<_, LiveVarSet> = body\n         .basic_blocks()\n         .indices()\n         .map(|_| LiveVarSet::new_empty(num_live_vars))\n@@ -77,9 +77,9 @@ pub fn liveness_of_locals<'tcx>(\n \n     // queue of things that need to be re-processed, and a set containing\n     // the things currently in the queue\n-    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_all(mir.basic_blocks().len());\n+    let mut dirty_queue: WorkQueue<BasicBlock> = WorkQueue::with_all(body.basic_blocks().len());\n \n-    let predecessors = mir.predecessors();\n+    let predecessors = body.predecessors();\n \n     while let Some(bb) = dirty_queue.pop() {\n         // bits = use \u222a (bits - def)\n@@ -258,7 +258,7 @@ pub fn dump_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     result: &LivenessResult,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n@@ -268,15 +268,15 @@ pub fn dump_mir<'a, 'tcx>(\n         // see notes on #41697 below\n         tcx.def_path_str(source.def_id())\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, body, result);\n }\n \n fn dump_matched_mir_node<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     result: &LivenessResult,\n ) {\n     let mut file_path = PathBuf::new();\n@@ -289,30 +289,30 @@ fn dump_matched_mir_node<'a, 'tcx>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, &mut file, result)?;\n+        write_mir_fn(tcx, source, body, &mut file, result)?;\n         Ok(())\n     });\n }\n \n pub fn write_mir_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     w: &mut dyn Write,\n     result: &LivenessResult,\n ) -> io::Result<()> {\n-    write_mir_intro(tcx, src, mir, w)?;\n-    for block in mir.basic_blocks().indices() {\n+    write_mir_intro(tcx, src, body, w)?;\n+    for block in body.basic_blocks().indices() {\n         let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet>| {\n             let live: Vec<String> = result[block]\n                 .iter()\n                 .map(|local| format!(\"{:?}\", local))\n                 .collect();\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))\n         };\n-        write_basic_block(tcx, block, mir, &mut |_, _| Ok(()), w)?;\n+        write_basic_block(tcx, block, body, &mut |_, _| Ok(()), w)?;\n         print(w, \"   \", &result.outs)?;\n-        if block.index() + 1 != mir.basic_blocks().len() {\n+        if block.index() + 1 != body.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n     }"}, {"sha": "eb457dacf8467982a39222e1330580d982ac024f", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -17,13 +17,13 @@ pub struct MirPatch<'tcx> {\n }\n \n impl<'tcx> MirPatch<'tcx> {\n-    pub fn new(mir: &Body<'tcx>) -> Self {\n+    pub fn new(body: &Body<'tcx>) -> Self {\n         let mut result = MirPatch {\n-            patch_map: IndexVec::from_elem(None, mir.basic_blocks()),\n+            patch_map: IndexVec::from_elem(None, body.basic_blocks()),\n             new_blocks: vec![],\n             new_statements: vec![],\n             new_locals: vec![],\n-            next_local: mir.local_decls.len(),\n+            next_local: body.local_decls.len(),\n             resume_block: START_BLOCK,\n             make_nop: vec![]\n         };\n@@ -35,7 +35,7 @@ impl<'tcx> MirPatch<'tcx> {\n \n         let mut resume_block = None;\n         let mut resume_stmt_block = None;\n-        for (bb, block) in mir.basic_blocks().iter_enumerated() {\n+        for (bb, block) in body.basic_blocks().iter_enumerated() {\n             if let TerminatorKind::Resume = block.terminator().kind {\n                 if block.statements.len() > 0 {\n                     assert!(resume_stmt_block.is_none());\n@@ -51,7 +51,7 @@ impl<'tcx> MirPatch<'tcx> {\n                 statements: vec![],\n                 terminator: Some(Terminator {\n                     source_info: SourceInfo {\n-                        span: mir.span,\n+                        span: body.span,\n                         scope: OUTERMOST_SOURCE_SCOPE\n                     },\n                     kind: TerminatorKind::Resume\n@@ -75,10 +75,10 @@ impl<'tcx> MirPatch<'tcx> {\n         self.patch_map[bb].is_some()\n     }\n \n-    pub fn terminator_loc(&self, mir: &Body<'tcx>, bb: BasicBlock) -> Location {\n-        let offset = match bb.index().checked_sub(mir.basic_blocks().len()) {\n+    pub fn terminator_loc(&self, body: &Body<'tcx>, bb: BasicBlock) -> Location {\n+        let offset = match bb.index().checked_sub(body.basic_blocks().len()) {\n             Some(index) => self.new_blocks[index].statements.len(),\n-            None => mir[bb].statements.len()\n+            None => body[bb].statements.len()\n         };\n         Location {\n             block: bb,\n@@ -127,21 +127,21 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, mir: &mut Body<'tcx>) {\n+    pub fn apply(self, body: &mut Body<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n-            mir.make_statement_nop(loc);\n+            body.make_statement_nop(loc);\n         }\n         debug!(\"MirPatch: {:?} new temps, starting from index {}: {:?}\",\n-               self.new_locals.len(), mir.local_decls.len(), self.new_locals);\n+               self.new_locals.len(), body.local_decls.len(), self.new_locals);\n         debug!(\"MirPatch: {} new blocks, starting from index {}\",\n-               self.new_blocks.len(), mir.basic_blocks().len());\n-        mir.basic_blocks_mut().extend(self.new_blocks);\n-        mir.local_decls.extend(self.new_locals);\n+               self.new_blocks.len(), body.basic_blocks().len());\n+        body.basic_blocks_mut().extend(self.new_blocks);\n+        body.local_decls.extend(self.new_locals);\n         for (src, patch) in self.patch_map.into_iter_enumerated() {\n             if let Some(patch) = patch {\n                 debug!(\"MirPatch: patching block {:?}\", src);\n-                mir[src].terminator_mut().kind = patch;\n+                body[src].terminator_mut().kind = patch;\n             }\n         }\n \n@@ -159,9 +159,9 @@ impl<'tcx> MirPatch<'tcx> {\n                    stmt, loc, delta);\n             loc.statement_index += delta;\n             let source_info = Self::source_info_for_index(\n-                &mir[loc.block], loc\n+                &body[loc.block], loc\n             );\n-            mir[loc.block].statements.insert(\n+            body[loc.block].statements.insert(\n                 loc.statement_index, Statement {\n                     source_info,\n                     kind: stmt\n@@ -177,10 +177,10 @@ impl<'tcx> MirPatch<'tcx> {\n         }\n     }\n \n-    pub fn source_info_for_location(&self, mir: &Body<'_>, loc: Location) -> SourceInfo {\n-        let data = match loc.block.index().checked_sub(mir.basic_blocks().len()) {\n+    pub fn source_info_for_location(&self, body: &Body<'_>, loc: Location) -> SourceInfo {\n+        let data = match loc.block.index().checked_sub(body.basic_blocks().len()) {\n             Some(new) => &self.new_blocks[new],\n-            None => &mir[loc.block]\n+            None => &body[loc.block]\n         };\n         Self::source_info_for_index(data, loc)\n     }"}, {"sha": "2de58d2f3d60b829343770f979c6571b7ba42e43", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ff07f30d01da3bed8316af81d3836254ea1769/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=80ff07f30d01da3bed8316af81d3836254ea1769", "patch": "@@ -68,7 +68,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     pass_name: &str,\n     disambiguator: &dyn Display,\n     source: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n@@ -88,7 +88,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n         &node_path,\n         disambiguator,\n         source,\n-        mir,\n+        body,\n         extra_data,\n     );\n }\n@@ -124,7 +124,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     node_path: &str,\n     disambiguator: &dyn Display,\n     source: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     mut extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n@@ -135,21 +135,21 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n-        if let Some(ref layout) = mir.generator_layout {\n+        if let Some(ref layout) = body.generator_layout {\n             writeln!(file, \"// generator_layout = {:?}\", layout)?;\n         }\n         writeln!(file, \"\")?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n-        write_user_type_annotations(mir, &mut file)?;\n-        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        write_user_type_annotations(body, &mut file)?;\n+        write_mir_fn(tcx, source, body, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n     };\n \n     if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n         let _: io::Result<()> = try {\n             let mut file =\n                 create_dump_file(tcx, \"dot\", pass_num, pass_name, disambiguator, source)?;\n-            write_mir_fn_graphviz(tcx, source.def_id(), mir, &mut file)?;\n+            write_mir_fn_graphviz(tcx, source.def_id(), body, &mut file)?;\n         };\n     }\n }\n@@ -256,7 +256,7 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n \n     let mut first = true;\n     for def_id in dump_mir_def_ids(tcx, single) {\n-        let mir = &tcx.optimized_mir(def_id);\n+        let body = &tcx.optimized_mir(def_id);\n \n         if first {\n             first = false;\n@@ -265,15 +265,15 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n             writeln!(w, \"\")?;\n         }\n \n-        write_mir_fn(tcx, MirSource::item(def_id), mir, &mut |_, _| Ok(()), w)?;\n+        write_mir_fn(tcx, MirSource::item(def_id), body, &mut |_, _| Ok(()), w)?;\n \n-        for (i, mir) in mir.promoted.iter_enumerated() {\n+        for (i, body) in body.promoted.iter_enumerated() {\n             writeln!(w, \"\")?;\n             let src = MirSource {\n                 instance: ty::InstanceDef::Item(def_id),\n                 promoted: Some(i),\n             };\n-            write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n+            write_mir_fn(tcx, src, body, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n@@ -282,18 +282,18 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     extra_data: &mut F,\n     w: &mut dyn Write,\n ) -> io::Result<()>\n where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    write_mir_intro(tcx, src, mir, w)?;\n-    for block in mir.basic_blocks().indices() {\n+    write_mir_intro(tcx, src, body, w)?;\n+    for block in body.basic_blocks().indices() {\n         extra_data(PassWhere::BeforeBlock(block), w)?;\n-        write_basic_block(tcx, block, mir, extra_data, w)?;\n-        if block.index() + 1 != mir.basic_blocks().len() {\n+        write_basic_block(tcx, block, body, extra_data, w)?;\n+        if block.index() + 1 != body.basic_blocks().len() {\n             writeln!(w, \"\")?;\n         }\n     }\n@@ -306,14 +306,14 @@ where\n pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     block: BasicBlock,\n-    mir: &Body<'tcx>,\n+    body: &Body<'tcx>,\n     extra_data: &mut F,\n     w: &mut dyn Write,\n ) -> io::Result<()>\n where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n {\n-    let data = &mir[block];\n+    let data = &body[block];\n \n     // Basic block label at the top.\n     let cleanup_text = if data.is_cleanup { \" (cleanup)\" } else { \"\" };\n@@ -326,11 +326,11 @@ where\n     };\n     for statement in &data.statements {\n         extra_data(PassWhere::BeforeLocation(current_location), w)?;\n-        let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n+        let indented_body = format!(\"{0}{0}{1:?};\", INDENT, statement);\n         writeln!(\n             w,\n             \"{:A$} // {:?}: {}\",\n-            indented_mir,\n+            indented_body,\n             current_location,\n             comment(tcx, statement.source_info),\n             A = ALIGN,\n@@ -464,7 +464,7 @@ fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> S\n /// Prints local variables in a scope tree.\n fn write_scope_tree(\n     tcx: TyCtxt<'_, '_, '_>,\n-    mir: &Body<'_>,\n+    body: &Body<'_>,\n     scope_tree: &FxHashMap<SourceScope, Vec<SourceScope>>,\n     w: &mut dyn Write,\n     parent: SourceScope,\n@@ -473,8 +473,8 @@ fn write_scope_tree(\n     let indent = depth * INDENT.len();\n \n     // Local variable types (including the user's name in a comment).\n-    for (local, local_decl) in mir.local_decls.iter_enumerated() {\n-        if (1..mir.arg_count+1).contains(&local.index()) {\n+    for (local, local_decl) in body.local_decls.iter_enumerated() {\n+        if (1..body.arg_count+1).contains(&local.index()) {\n             // Skip over argument locals, they're printed in the signature.\n             continue;\n         }\n@@ -527,9 +527,9 @@ fn write_scope_tree(\n     };\n \n     for &child in children {\n-        assert_eq!(mir.source_scopes[child].parent_scope, Some(parent));\n+        assert_eq!(body.source_scopes[child].parent_scope, Some(parent));\n         writeln!(w, \"{0:1$}scope {2} {{\", \"\", indent, child.index())?;\n-        write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n+        write_scope_tree(tcx, body, scope_tree, w, child, depth + 1)?;\n         writeln!(w, \"{0:1$}}}\", \"\", depth * INDENT.len())?;\n     }\n \n@@ -541,15 +541,15 @@ fn write_scope_tree(\n pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Body<'_>,\n+    body: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    write_mir_sig(tcx, src, mir, w)?;\n+    write_mir_sig(tcx, src, body, w)?;\n     writeln!(w, \"{{\")?;\n \n     // construct a scope tree and write it out\n     let mut scope_tree: FxHashMap<SourceScope, Vec<SourceScope>> = Default::default();\n-    for (index, scope_data) in mir.source_scopes.iter().enumerate() {\n+    for (index, scope_data) in body.source_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n             scope_tree\n                 .entry(parent)\n@@ -561,7 +561,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n         }\n     }\n \n-    write_scope_tree(tcx, mir, &scope_tree, w, OUTERMOST_SOURCE_SCOPE, 1)?;\n+    write_scope_tree(tcx, body, &scope_tree, w, OUTERMOST_SOURCE_SCOPE, 1)?;\n \n     // Add an empty line before the first block is printed.\n     writeln!(w, \"\")?;\n@@ -572,7 +572,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n fn write_mir_sig(\n     tcx: TyCtxt<'_, '_, '_>,\n     src: MirSource<'tcx>,\n-    mir: &Body<'_>,\n+    body: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n     use rustc::hir::def::DefKind;\n@@ -605,20 +605,20 @@ fn write_mir_sig(\n         write!(w, \"(\")?;\n \n         // fn argument types.\n-        for (i, arg) in mir.args_iter().enumerate() {\n+        for (i, arg) in body.args_iter().enumerate() {\n             if i != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Place::Base(PlaceBase::Local(arg)), mir.local_decls[arg].ty)?;\n+            write!(w, \"{:?}: {}\", Place::Base(PlaceBase::Local(arg)), body.local_decls[arg].ty)?;\n         }\n \n-        write!(w, \") -> {}\", mir.return_ty())?;\n+        write!(w, \") -> {}\", body.return_ty())?;\n     } else {\n-        assert_eq!(mir.arg_count, 0);\n-        write!(w, \": {} =\", mir.return_ty())?;\n+        assert_eq!(body.arg_count, 0);\n+        write!(w, \": {} =\", body.return_ty())?;\n     }\n \n-    if let Some(yield_ty) = mir.yield_ty {\n+    if let Some(yield_ty) = body.yield_ty {\n         writeln!(w)?;\n         writeln!(w, \"yields {}\", yield_ty)?;\n     }\n@@ -629,14 +629,14 @@ fn write_mir_sig(\n     Ok(())\n }\n \n-fn write_user_type_annotations(mir: &Body<'_>, w: &mut dyn Write) -> io::Result<()> {\n-    if !mir.user_type_annotations.is_empty() {\n+fn write_user_type_annotations(body: &Body<'_>, w: &mut dyn Write) -> io::Result<()> {\n+    if !body.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;\n     }\n-    for (index, annotation) in mir.user_type_annotations.iter_enumerated() {\n+    for (index, annotation) in body.user_type_annotations.iter_enumerated() {\n         writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation.user_ty, annotation.span)?;\n     }\n-    if !mir.user_type_annotations.is_empty() {\n+    if !body.user_type_annotations.is_empty() {\n         writeln!(w, \"|\")?;\n     }\n     Ok(())"}]}