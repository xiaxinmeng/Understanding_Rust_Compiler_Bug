{"sha": "205baa6ca2272e21032f8fb5477edefe4120bcbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNWJhYTZjYTIyNzJlMjEwMzJmOGZiNTQ3N2VkZWZlNDEyMGJjYmM=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-21T14:19:34Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-07-21T16:29:20Z"}, "message": "Avoid blocks for static allocas and loading the closure environment\n\nThese blocks were required because previously we could only insert\ninstructions at the end of blocks, but we wanted to have all allocas in\none place, so they can be collapse. But now we have \"direct\" access the\nthe LLVM IR builder and can position it freely. This allows us to use\nthe same trick that clang uses, which means that we insert a dummy\n\"marker\" instruction to identify the spot at which we want to insert\nallocas. We can then later position the IR builder at that spot and\ninsert the alloca instruction, without any dedicated block.\n\nThe block for loading the closure environment can now also go away,\nbecause the function context now provides the toplevel block, and the\ntranslation of the loading happens first, so that's good enough.\n\nMakes the LLVM IR a bit more readable, saving a bunch of branches in the\nunoptimized code, which benefits unoptimized builds.", "tree": {"sha": "1ee4a81ac2e4955f103e1782f47d2f8313e449ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee4a81ac2e4955f103e1782f47d2f8313e449ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/205baa6ca2272e21032f8fb5477edefe4120bcbc", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/205baa6ca2272e21032f8fb5477edefe4120bcbc", "html_url": "https://github.com/rust-lang/rust/commit/205baa6ca2272e21032f8fb5477edefe4120bcbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/205baa6ca2272e21032f8fb5477edefe4120bcbc/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "565a9bf20b726c5182a6c4c816c1d9a4108c778a", "url": "https://api.github.com/repos/rust-lang/rust/commits/565a9bf20b726c5182a6c4c816c1d9a4108c778a", "html_url": "https://github.com/rust-lang/rust/commit/565a9bf20b726c5182a6c4c816c1d9a4108c778a"}], "stats": {"total": 191, "additions": 79, "deletions": 112}, "files": [{"sha": "d1a9e387d00ed6445c580a6cea7a83148e3fa7c4", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -984,6 +984,8 @@ pub mod llvm {\n         pub unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n         #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n+        pub unsafe fn LLVMInstructionEraseFromParent(Inst: ValueRef);\n \n         /* Operations on call sites */\n         #[fast_ffi]"}, {"sha": "2512b6e3ece892c7d0633ae8283916a63be54055", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -41,7 +41,7 @@ use middle::trans::_match;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build::*;\n-use middle::trans::builder::noname;\n+use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::consts;\n@@ -1503,34 +1503,35 @@ pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n }\n \n pub fn zero_mem(cx: block, llptr: ValueRef, t: ty::t) {\n+    if cx.unreachable { return; }\n     let _icx = push_ctxt(\"zero_mem\");\n     let bcx = cx;\n     let ccx = cx.ccx();\n     let llty = type_of::type_of(ccx, t);\n-    memzero(bcx, llptr, llty);\n+    memzero(&B(bcx), llptr, llty);\n }\n \n // Always use this function instead of storing a zero constant to the memory\n // in question. If you store a zero constant, LLVM will drown in vreg\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(cx: block, llptr: ValueRef, ty: Type) {\n+pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n-    let ccx = cx.ccx();\n+    let ccx = b.ccx;\n \n     let intrinsic_key = match ccx.sess.targ_cfg.arch {\n         X86 | Arm | Mips => \"llvm.memset.p0i8.i32\",\n         X86_64 => \"llvm.memset.p0i8.i64\"\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = PointerCast(cx, llptr, Type::i8().ptr_to());\n+    let llptr = b.pointercast(llptr, Type::i8().ptr_to());\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type);\n+    let size = machine::llsize_of(ccx, ty);\n     let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n-    Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n+    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t, name: &str) -> ValueRef {\n@@ -1553,9 +1554,12 @@ pub fn alloca_maybe_zeroed(cx: block, ty: Type, name: &str, zero: bool) -> Value\n             return llvm::LLVMGetUndef(ty.ptr_to().to_ref());\n         }\n     }\n-    let initcx = base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas());\n-    let p = Alloca(initcx, ty, name);\n-    if zero { memzero(initcx, p, ty); }\n+    let p = Alloca(cx, ty, name);\n+    if zero {\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        memzero(&b, p, ty);\n+    }\n     p\n }\n \n@@ -1566,7 +1570,7 @@ pub fn arrayalloca(cx: block, ty: Type, v: ValueRef) -> ValueRef {\n             return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n-    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.get_llstaticallocas()), ty, v);\n+    return ArrayAlloca(cx, ty, v);\n }\n \n pub struct BasicBlocks {\n@@ -1597,8 +1601,8 @@ pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n-            alloca(raw_block(fcx, false, fcx.get_llstaticallocas()), lloutputtype,\n-                   \"__make_return_pointer\")\n+            let bcx = fcx.entry_bcx.get();\n+            Alloca(bcx, lloutputtype, \"__make_return_pointer\")\n         }\n     }\n }\n@@ -1616,6 +1620,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         output_type: ty::t,\n                         skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n+                        opt_node_info: Option<NodeInfo>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n     for param_substs.iter().advance |p| { p.validate(); }\n@@ -1639,8 +1644,8 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n               llvm::LLVMGetUndef(Type::i8p().to_ref())\n           },\n           llretptr: None,\n-          llstaticallocas: None,\n-          llloadenv: None,\n+          entry_bcx: None,\n+          alloca_insert_pt: None,\n           llreturn: None,\n           llself: None,\n           personality: None,\n@@ -1658,6 +1663,15 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n     };\n+\n+    unsafe {\n+        let entry_bcx = top_scope_block(fcx, opt_node_info);\n+        Load(entry_bcx, C_null(Type::i8p()));\n+\n+        fcx.entry_bcx = Some(entry_bcx);\n+        fcx.alloca_insert_pt = Some(llvm::LLVMGetFirstInstruction(entry_bcx.llbb));\n+    }\n+\n     if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n         fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n     }\n@@ -1670,7 +1684,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, sp)\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1785,9 +1799,8 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n // Ties up the llstaticallocas -> llloadenv -> lltop edges,\n // and builds the return block.\n-pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n+pub fn finish_fn(fcx: fn_ctxt, last_bcx: block) {\n     let _icx = push_ctxt(\"finish_fn\");\n-    tie_up_header_blocks(fcx, lltop);\n \n     let ret_cx = match fcx.llreturn {\n         Some(llreturn) => {\n@@ -1799,6 +1812,7 @@ pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef, last_bcx: block) {\n         None => last_bcx\n     };\n     build_return_block(fcx, ret_cx);\n+    fcx.cleanup();\n }\n \n // Builds the return block for a function.\n@@ -1811,29 +1825,6 @@ pub fn build_return_block(fcx: fn_ctxt, ret_cx: block) {\n     }\n }\n \n-pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n-    let _icx = push_ctxt(\"tie_up_header_blocks\");\n-    let llnext = match fcx.llloadenv {\n-        Some(ll) => {\n-            unsafe {\n-                llvm::LLVMMoveBasicBlockBefore(ll, lltop);\n-            }\n-            Br(raw_block(fcx, false, ll), lltop);\n-            ll\n-        }\n-        None => lltop\n-    };\n-    match fcx.llstaticallocas {\n-        Some(ll) => {\n-            unsafe {\n-                llvm::LLVMMoveBasicBlockBefore(ll, llnext);\n-            }\n-            Br(raw_block(fcx, false, ll), llnext);\n-        }\n-        None => ()\n-    }\n-}\n-\n pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n \n // trans_closure: Builds an LLVM function out of a source function.\n@@ -1866,6 +1857,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                output_type,\n                                false,\n                                param_substs,\n+                               body.info(),\n                                Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n@@ -1877,9 +1869,8 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-    let bcx_top = top_scope_block(fcx, body.info());\n+    let bcx_top = fcx.entry_bcx.get();\n     let mut bcx = bcx_top;\n-    let lltop = bcx.llbb;\n     let block_ty = node_id_type(bcx, body.id);\n \n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n@@ -1915,7 +1906,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n     }\n \n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -2085,12 +2076,12 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                                result_ty,\n                                false,\n                                param_substs,\n+                               None,\n                                None);\n \n     let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n@@ -2108,7 +2099,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n         let arg_ty = arg_tys[i];\n         memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n     }\n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n }\n \n pub fn trans_enum_def(ccx: @mut CrateContext, enum_definition: &ast::enum_def,\n@@ -2336,9 +2327,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         // be updated if this assertion starts to fail.\n         assert!(fcx.has_immediate_return_value);\n \n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n-\n+        let bcx = fcx.entry_bcx.get();\n         // Call main.\n         let llenvarg = unsafe {\n             let env_arg = fcx.env_arg_pos();\n@@ -2347,7 +2336,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n         let args = ~[llenvarg];\n         Call(bcx, main_llfn, args);\n \n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n         return llfdecl;\n     }\n "}, {"sha": "a8c7efb2ad43de193024b6f08bbb4ce91b16696a", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -318,14 +318,18 @@ pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n pub fn Alloca(cx: block, Ty: Type, name: &str) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        B(cx).alloca(Ty, name)\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.alloca(Ty, name)\n     }\n }\n \n pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty.ptr_to().to_ref()); }\n-        B(cx).array_alloca(Ty, Val)\n+        let b = cx.fcx.ccx.builder();\n+        b.position_before(cx.fcx.alloca_insert_pt.get());\n+        b.array_alloca(Ty, Val)\n     }\n }\n "}, {"sha": "cdde96393a14f4a38a8fdf552657c46929736c25", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -11,7 +11,7 @@\n \n use back::abi;\n use back::link::{mangle_internal_name_by_path_and_seq};\n-use lib::llvm::{llvm, ValueRef};\n+use lib::llvm::ValueRef;\n use middle::moves;\n use middle::trans::base::*;\n use middle::trans::build::*;\n@@ -25,7 +25,6 @@ use util::ppaux::ty_to_str;\n \n use middle::trans::type_::Type;\n \n-use std::str;\n use std::vec;\n use syntax::ast;\n use syntax::ast_map::path_name;\n@@ -331,23 +330,7 @@ pub fn load_environment(fcx: fn_ctxt,\n         return;\n     }\n \n-    let llloadenv = match fcx.llloadenv {\n-        Some(ll) => ll,\n-        None => {\n-            let ll =\n-                str::as_c_str(\"load_env\",\n-                              |buf|\n-                              unsafe {\n-                                llvm::LLVMAppendBasicBlockInContext(fcx.ccx.llcx,\n-                                                                    fcx.llfn,\n-                                                                    buf)\n-                              });\n-            fcx.llloadenv = Some(ll);\n-            ll\n-        }\n-    };\n-\n-    let bcx = raw_block(fcx, false, llloadenv);\n+    let bcx = fcx.entry_bcx.get();\n \n     // Load a pointer to the closure data, skipping over the box header:\n     let llcdata = opaque_box_body(bcx, cdata_ty, fcx.llenv);"}, {"sha": "f53f15a83d71e3272e17f093e1ab1bff61a509e7", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -174,17 +174,14 @@ pub struct fn_ctxt_ {\n     // always be Some.\n     llretptr: Option<ValueRef>,\n \n+    entry_bcx: Option<block>,\n+\n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n     // the function, due to LLVM's quirks.\n-    // A block for all the function's static allocas, so that LLVM\n-    // will coalesce them into a single alloca call.\n-    llstaticallocas: Option<BasicBlockRef>,\n-    // A block containing code that copies incoming arguments to space\n-    // already allocated by code in one of the llallocas blocks.\n-    // (LLVM requires that arguments be copied to local allocas before\n-    // allowing most any operation to be performed on them.)\n-    llloadenv: Option<BasicBlockRef>,\n+    // A marker for the place where we want to insert the function's static\n+    // allocas, so that LLVM will coalesce them into a single alloca call.\n+    alloca_insert_pt: Option<ValueRef>,\n     llreturn: Option<BasicBlockRef>,\n     // The 'self' value currently in use in this function, if there\n     // is one.\n@@ -252,12 +249,12 @@ impl fn_ctxt_ {\n         }\n     }\n \n-    pub fn get_llstaticallocas(&mut self) -> BasicBlockRef {\n-        if self.llstaticallocas.is_none() {\n-            self.llstaticallocas = Some(base::mk_staticallocas_basic_block(self.llfn));\n+    pub fn cleanup(&mut self) {\n+        unsafe {\n+            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.get());\n         }\n-\n-        self.llstaticallocas.get()\n+        // Remove the cycle between fcx and bcx, so memory can be freed\n+        self.entry_bcx = None;\n     }\n \n     pub fn get_llreturn(&mut self) -> BasicBlockRef {"}, {"sha": "08fbfdee9eac0962d10d3c2010c6f3364bd04175", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -149,8 +149,7 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Declare the body of the shim function:\n     let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n \n     let llargbundle = get_param(llshimfn, 0u);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n@@ -162,13 +161,12 @@ fn build_shim_fn_(ccx: @mut CrateContext,\n \n     // Don't finish up the function in the usual way, because this doesn't\n     // follow the normal Rust calling conventions.\n-    tie_up_header_blocks(fcx, lltop);\n-\n     let ret_cx = match fcx.llreturn {\n         Some(llreturn) => raw_block(fcx, false, llreturn),\n         None => bcx\n     };\n     RetVoid(ret_cx);\n+    fcx.cleanup();\n \n     return llshimfn;\n }\n@@ -192,19 +190,15 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n                   ret_builder: wrap_ret_builder) {\n     let _icx = push_ctxt(\"foreign::build_wrap_fn_\");\n     let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n+    let bcx = fcx.entry_bcx.get();\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n     if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n-        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.get_llstaticallocas()),\n-                                   lloutputtype,\n-                                   \"\"));\n+        fcx.llretptr = Some(alloca(bcx, lloutputtype, \"\"));\n     }\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n-\n     // Allocate the struct and write the arguments into it.\n     let llargbundle = alloca(bcx, tys.bundle_ty, \"__llargbundle\");\n     arg_builder(bcx, tys, llwrapfn, llargbundle);\n@@ -215,10 +209,6 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n     Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n-    // Perform a custom version of `finish_fn`. First, tie up the header\n-    // blocks.\n-    tie_up_header_blocks(fcx, lltop);\n-\n     // Then return according to the C ABI.\n     let return_context = match fcx.llreturn {\n         Some(llreturn) => raw_block(fcx, false, llreturn),\n@@ -239,6 +229,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n         let llretptr = BitCast(return_context, fcx.llretptr.get(), return_type.ptr_to());\n         Ret(return_context, Load(return_context, llretptr));\n     }\n+    fcx.cleanup();\n }\n \n // For each foreign function F, we generate a wrapper function W and a shim\n@@ -430,8 +421,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n+        let bcx = fcx.entry_bcx.get();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n@@ -443,7 +433,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n     }\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n@@ -456,8 +446,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n-        let bcx = top_scope_block(fcx, None);\n-        let lltop = bcx.llbb;\n+        let bcx = fcx.entry_bcx.get();\n         let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n@@ -471,7 +460,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr.get());\n         }\n-        finish_fn(fcx, lltop, bcx);\n+        finish_fn(fcx, bcx);\n     }\n \n     fn build_wrap_fn(ccx: @mut CrateContext,\n@@ -619,6 +608,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                output_type,\n                                true,\n                                Some(substs),\n+                               None,\n                                Some(item.span));\n \n     set_always_inline(fcx.llfn);\n@@ -628,7 +618,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n-    let mut bcx = top_scope_block(fcx, None);\n+    let mut bcx = fcx.entry_bcx.get();\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -694,6 +684,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n         }\n \n+        fcx.cleanup();\n         return;\n     }\n \n@@ -942,6 +933,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n+    fcx.cleanup();\n }\n \n /**"}, {"sha": "d3f5b9844c930f6c1607c2637a976e063ad973da", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -615,7 +615,7 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) -> block {\n             // Zero out the struct\n             unsafe {\n                 let ty = Type::from_ref(llvm::LLVMTypeOf(v));\n-                memzero(bcx, v, ty);\n+                memzero(&B(bcx), v, ty);\n             }\n \n           }\n@@ -707,13 +707,12 @@ pub fn make_generic_glue_inner(ccx: @mut CrateContext,\n     // llfn is expected be declared to take a parameter of the appropriate\n     // type, so we don't need to explicitly cast the function parameter.\n \n-    let bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n+    let bcx = fcx.entry_bcx.get();\n     let rawptr0_arg = fcx.arg_pos(0u);\n     let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n \n-    finish_fn(fcx, lltop, bcx);\n+    finish_fn(fcx, bcx);\n \n     return llfn;\n }"}, {"sha": "6df1df454ff464aea41ec832fcd606fc152b8ff5", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -303,15 +303,15 @@ impl Reflector {\n                     //\n                     llvm::LLVMGetParam(llfdecl, fcx.arg_pos(0u) as c_uint)\n                 };\n-                let mut bcx = top_scope_block(fcx, None);\n+                let mut bcx = fcx.entry_bcx.get();\n                 let arg = BitCast(bcx, arg, llptrty);\n                 let ret = adt::trans_get_discr(bcx, repr, arg);\n                 Store(bcx, ret, fcx.llretptr.get());\n                 match fcx.llreturn {\n                     Some(llreturn) => cleanup_and_Br(bcx, bcx, llreturn),\n                     None => bcx = cleanup_block(bcx, Some(bcx.llbb))\n                 };\n-                finish_fn(fcx, bcx.llbb, bcx);\n+                finish_fn(fcx, bcx);\n                 llfdecl\n             };\n "}, {"sha": "48888760fc6650ca9ffdc5b853bb0c9b8833ca2e", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/205baa6ca2272e21032f8fb5477edefe4120bcbc/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=205baa6ca2272e21032f8fb5477edefe4120bcbc", "patch": "@@ -409,6 +409,7 @@ LLVMInsertBasicBlock\n LLVMInsertBasicBlockInContext\n LLVMInsertIntoBuilder\n LLVMInsertIntoBuilderWithName\n+LLVMInstructionEraseFromParent\n LLVMInt16Type\n LLVMInt16TypeInContext\n LLVMInt1Type"}]}