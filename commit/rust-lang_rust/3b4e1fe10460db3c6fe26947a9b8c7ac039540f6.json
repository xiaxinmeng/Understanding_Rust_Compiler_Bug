{"sha": "3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "node_id": "C_kwDOAAsO6NoAKDNiNGUxZmUxMDQ2MGRiM2M2ZmUyNjk0N2E5YjhjN2FjMDM5NTQwZjY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-05T15:36:01Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-09T17:59:35Z"}, "message": "Do not check StorageLive dominates address-taking.", "tree": {"sha": "54c494ef8b4e0c7eb5f97bcae59fa326e7c19ac4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c494ef8b4e0c7eb5f97bcae59fa326e7c19ac4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "html_url": "https://github.com/rust-lang/rust/commit/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3268f2e61dcf2132570f5e36147a67bc25355a40", "url": "https://api.github.com/repos/rust-lang/rust/commits/3268f2e61dcf2132570f5e36147a67bc25355a40", "html_url": "https://github.com/rust-lang/rust/commit/3268f2e61dcf2132570f5e36147a67bc25355a40"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "9afbae9d8d110e1928eca5d33532b27ae55dc2c9", "filename": "compiler/rustc_mir_transform/src/ref_prop.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs?ref=3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "patch": "@@ -8,7 +8,7 @@ use rustc_mir_dataflow::impls::MaybeStorageDead;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::Analysis;\n \n-use crate::ssa::SsaLocals;\n+use crate::ssa::{SsaLocals, StorageLiveLocals};\n use crate::MirPass;\n \n /// Propagate references using SSA analysis.\n@@ -39,7 +39,7 @@ use crate::MirPass;\n /// - all projections in `PROJECTIONS` have a stable offset (no dereference and no indexing).\n ///\n /// If `PLACE` is a direct projection of a local, we consider it as constant if:\n-/// - the local is always live, or it has a single `StorageLive` that dominates all uses;\n+/// - the local is always live, or it has a single `StorageLive`;\n /// - all projections have a stable offset.\n ///\n /// # Liveness\n@@ -110,9 +110,13 @@ fn compute_replacement<'tcx>(\n     body: &Body<'tcx>,\n     ssa: &SsaLocals,\n ) -> Replacer<'tcx> {\n+    let always_live_locals = always_storage_live_locals(body);\n+\n+    // Compute which locals have a single `StorageLive` statement ever.\n+    let storage_live = StorageLiveLocals::new(body, &always_live_locals);\n+\n     // Compute `MaybeStorageDead` dataflow to check that we only replace when the pointee is\n     // definitely live.\n-    let always_live_locals = always_storage_live_locals(body);\n     let mut maybe_dead = MaybeStorageDead::new(always_live_locals)\n         .into_engine(tcx, body)\n         .iterate_to_fixpoint()\n@@ -126,6 +130,38 @@ fn compute_replacement<'tcx>(\n \n     let fully_replacable_locals = fully_replacable_locals(ssa);\n \n+    // Returns true iff we can use `place` as a pointee.\n+    //\n+    // Note that we only need to verify that there is a single `StorageLive` statement, and we do\n+    // not need to verify that it dominates all uses of that local.\n+    //\n+    // Consider the three statements:\n+    //   SL : StorageLive(a)\n+    //   DEF: b = &raw? mut? a\n+    //   USE: stuff that uses *b\n+    //\n+    // First, we recall that DEF is checked to dominate USE. Now imagine for the sake of\n+    // contradiction there is a DEF -> SL -> USE path. Consider two cases:\n+    //\n+    // - DEF dominates SL. We always have UB the first time control flow reaches DEF,\n+    //   because the storage of `a` is dead. Since DEF dominates USE, that means we cannot\n+    //   reach USE and so our optimization is ok.\n+    //\n+    // - DEF does not dominate SL. Then there is a `START_BLOCK -> SL` path not including DEF.\n+    //   But we can extend this path to USE, meaning there is also a `START_BLOCK -> USE` path not\n+    //   including DEF. This violates the DEF dominates USE condition, and so is impossible.\n+    let is_constant_place = |place: Place<'_>| {\n+        // We only allow `Deref` as the first projection, to avoid surprises.\n+        if place.projection.first() == Some(&PlaceElem::Deref) {\n+            // `place == (*some_local).xxx`, it is constant only if `some_local` is constant.\n+            // We approximate constness using SSAness.\n+            ssa.is_ssa(place.local) && place.projection[1..].iter().all(PlaceElem::is_stable_offset)\n+        } else {\n+            storage_live.has_single_storage(place.local)\n+                && place.projection[..].iter().all(PlaceElem::is_stable_offset)\n+        }\n+    };\n+\n     let mut can_perform_opt = |target: Place<'tcx>, loc: Location| {\n         maybe_dead.seek_after_primary_effect(loc);\n         let maybe_dead = maybe_dead.contains(target.local);\n@@ -194,7 +230,7 @@ fn compute_replacement<'tcx>(\n                     place = target.project_deeper(&place.projection[1..], tcx);\n                 }\n                 assert_ne!(place.local, local);\n-                if ssa.is_constant_place(place) {\n+                if is_constant_place(place) {\n                     targets[local] = Value::Pointer(place, ty.is_mutable_ptr());\n                 }\n             }"}, {"sha": "5633adf673e9f1dae972833795dd9983a826221d", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b4e1fe10460db3c6fe26947a9b8c7ac039540f6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=3b4e1fe10460db3c6fe26947a9b8c7ac039540f6", "patch": "@@ -4,12 +4,6 @@\n //!\n //! As a consequence of rule 2, we consider that borrowed locals are not SSA, even if they are\n //! `Freeze`, as we do not track that the assignment dominates all uses of the borrow.\n-//!\n-//! We say a local has a stable address if its address has SSA-like properties:\n-//! 1/ It has a single `StorageLive` statement, or none at all (always-live);\n-//! 2/ This `StorageLive` statement dominates all statements that take this local's address.\n-//!\n-//! We do not discard borrowed locals from this analysis, as we cannot take their address' address.\n \n use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -18,7 +12,6 @@ use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_mir_dataflow::storage::always_storage_live_locals;\n \n #[derive(Debug)]\n pub struct SsaLocals {\n@@ -33,9 +26,6 @@ pub struct SsaLocals {\n     /// Number of \"direct\" uses of each local, ie. uses that are not dereferences.\n     /// We ignore non-uses (Storage statements, debuginfo).\n     direct_uses: IndexVec<Local, u32>,\n-    /// Set of \"StorageLive\" statements for each local. When the \"StorageLive\" statement does not\n-    /// dominate all uses of the local, we mark it as `Set1::Many`.\n-    storage_live: IndexVec<Local, Set1<LocationExtended>>,\n }\n \n /// We often encounter MIR bodies with 1 or 2 basic blocks. In those cases, it's unnecessary to\n@@ -83,18 +73,12 @@ impl SsaLocals {\n         let dominators = SmallDominators { inner: dominators };\n \n         let direct_uses = IndexVec::from_elem(0, &body.local_decls);\n-        let storage_live = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n-        let mut visitor =\n-            SsaVisitor { assignments, assignment_order, dominators, direct_uses, storage_live };\n+        let mut visitor = SsaVisitor { assignments, assignment_order, dominators, direct_uses };\n \n         for local in body.args_iter() {\n             visitor.assignments[local] = Set1::One(LocationExtended::Arg);\n         }\n \n-        for local in always_storage_live_locals(body).iter() {\n-            visitor.storage_live[local] = Set1::One(LocationExtended::Arg);\n-        }\n-\n         if body.basic_blocks.len() > 2 {\n             for (bb, data) in traversal::reverse_postorder(body) {\n                 visitor.visit_basic_block_data(bb, data);\n@@ -111,7 +95,6 @@ impl SsaLocals {\n \n         debug!(?visitor.assignments);\n         debug!(?visitor.direct_uses);\n-        debug!(?visitor.storage_live);\n \n         visitor\n             .assignment_order\n@@ -124,7 +107,6 @@ impl SsaLocals {\n             assignments: visitor.assignments,\n             assignment_order: visitor.assignment_order,\n             direct_uses: visitor.direct_uses,\n-            storage_live: visitor.storage_live,\n             copy_classes,\n         }\n     }\n@@ -141,19 +123,6 @@ impl SsaLocals {\n         matches!(self.assignments[local], Set1::One(_))\n     }\n \n-    /// Returns true iff we can use `p` as a pointee.\n-    pub fn is_constant_place(&self, p: Place<'_>) -> bool {\n-        // We only allow `Deref` as the first projection, to avoid surprises.\n-        if p.projection.first() == Some(&PlaceElem::Deref) {\n-            // `p == (*some_local).xxx`, it is constant only if `some_local` is constant.\n-            // We approximate constness using SSAness.\n-            self.is_ssa(p.local) && p.projection[1..].iter().all(PlaceElem::is_stable_offset)\n-        } else {\n-            matches!(self.storage_live[p.local], Set1::One(_))\n-                && p.projection[..].iter().all(PlaceElem::is_stable_offset)\n-        }\n-    }\n-\n     /// Return the number of uses if a local that are not \"Deref\".\n     pub fn num_direct_uses(&self, local: Local) -> u32 {\n         self.direct_uses[local]\n@@ -233,7 +202,6 @@ struct SsaVisitor {\n     assignments: IndexVec<Local, Set1<LocationExtended>>,\n     assignment_order: Vec<Local>,\n     direct_uses: IndexVec<Local, u32>,\n-    storage_live: IndexVec<Local, Set1<LocationExtended>>,\n }\n \n impl<'tcx> Visitor<'tcx> for SsaVisitor {\n@@ -259,15 +227,11 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n             )\n             | PlaceContext::MutatingUse(_) => {\n                 self.assignments[local] = Set1::Many;\n-                self.dominators.check_dominates(&mut self.storage_live[local], loc);\n             }\n             PlaceContext::NonMutatingUse(_) => {\n                 self.dominators.check_dominates(&mut self.assignments[local], loc);\n                 self.direct_uses[local] += 1;\n             }\n-            PlaceContext::NonUse(NonUseContext::StorageLive) => {\n-                self.storage_live[local].insert(LocationExtended::Plain(loc));\n-            }\n             PlaceContext::NonUse(_) => {}\n         }\n     }\n@@ -335,3 +299,37 @@ fn compute_copy_classes(ssa: &mut SsaVisitor, body: &Body<'_>) -> IndexVec<Local\n \n     copies\n }\n+\n+#[derive(Debug)]\n+pub(crate) struct StorageLiveLocals {\n+    /// Set of \"StorageLive\" statements for each local. When the \"StorageLive\" statement does not\n+    /// dominate all address-taking uses of the local, we mark it as `Set1::Many`.\n+    storage_live: IndexVec<Local, Set1<LocationExtended>>,\n+}\n+\n+impl StorageLiveLocals {\n+    pub(crate) fn new(\n+        body: &Body<'_>,\n+        always_storage_live_locals: &BitSet<Local>,\n+    ) -> StorageLiveLocals {\n+        let mut storage_live = IndexVec::from_elem(Set1::Empty, &body.local_decls);\n+        for local in always_storage_live_locals.iter() {\n+            storage_live[local] = Set1::One(LocationExtended::Arg);\n+        }\n+        for (block, bbdata) in body.basic_blocks.iter_enumerated() {\n+            for (statement_index, statement) in bbdata.statements.iter().enumerate() {\n+                if let StatementKind::StorageLive(local) = statement.kind {\n+                    storage_live[local]\n+                        .insert(LocationExtended::Plain(Location { block, statement_index }));\n+                }\n+            }\n+        }\n+        debug!(?storage_live);\n+        StorageLiveLocals { storage_live }\n+    }\n+\n+    #[inline]\n+    pub(crate) fn has_single_storage(&self, local: Local) -> bool {\n+        matches!(self.storage_live[local], Set1::One(_))\n+    }\n+}"}]}