{"sha": "e6176513842da1dd9e17d8536e7d76125a1bc610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MTc2NTEzODQyZGExZGQ5ZTE3ZDg1MzZlN2Q3NjEyNWExYmM2MTA=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-08-05T05:25:15Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-08-06T16:58:36Z"}, "message": "Removed convenience encoding trait impls\n\nEncoding should really only be done from [u8]<->str. The extra\nconvenience implementations don't really have a place, especially since\nthey're so trivial.\n\nAlso improved error messages in FromBase64.", "tree": {"sha": "f35216eac5f258b099066d02a9252248bea79bf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f35216eac5f258b099066d02a9252248bea79bf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6176513842da1dd9e17d8536e7d76125a1bc610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6176513842da1dd9e17d8536e7d76125a1bc610", "html_url": "https://github.com/rust-lang/rust/commit/e6176513842da1dd9e17d8536e7d76125a1bc610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6176513842da1dd9e17d8536e7d76125a1bc610/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "858e166119d81e76b8909da880b3b3d0e25718c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/858e166119d81e76b8909da880b3b3d0e25718c3", "html_url": "https://github.com/rust-lang/rust/commit/858e166119d81e76b8909da880b3b3d0e25718c3"}], "stats": {"total": 217, "additions": 63, "deletions": 154}, "files": [{"sha": "b4431004bd74cff0dd38693c5093d4b590c479be", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 41, "deletions": 84, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/e6176513842da1dd9e17d8536e7d76125a1bc610/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6176513842da1dd9e17d8536e7d76125a1bc610/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=e6176513842da1dd9e17d8536e7d76125a1bc610", "patch": "@@ -150,52 +150,38 @@ impl<'self> ToBase64 for &'self [u8] {\n     }\n }\n \n-impl<'self> ToBase64 for &'self str {\n-    /**\n-     * Convert any string (literal, `@`, `&`, or `~`) to base64 encoding.\n-     *\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, standard};\n-     *\n-     * fn main () {\n-     *     let str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     * }\n-     * ~~~\n-     *\n-     */\n-    fn to_base64(&self, config: Config) -> ~str {\n-        self.as_bytes().to_base64(config)\n-    }\n-}\n-\n /// A trait for converting from base64 encoded values.\n pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n     fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromBase64 for &'self [u8] {\n+impl<'self> FromBase64 for &'self str {\n     /**\n-     * Convert base64 `u8` vector into u8 byte values.\n-     * Every 4 encoded characters is converted into 3 octets, modulo padding.\n+     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n+     * This converts a string literal to base64 and back.\n+     *\n      * ~~~ {.rust}\n      * extern mod extra;\n      * use extra::base64::{ToBase64, FromBase64, standard};\n+     * use std::str;\n      *\n      * fn main () {\n-     *     let str = [52,32].to_base64(standard);\n-     *     printfln!(\"%s\", str);\n-     *     let bytes = str.from_base64();\n+     *     let hello_str = \"Hello, World\".to_base64(standard);\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_base64();\n      *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n      * }\n      * ~~~\n      */\n@@ -204,20 +190,20 @@ impl<'self> FromBase64 for &'self [u8] {\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n \n-        let mut it = self.iter();\n-        for &byte in it {\n-            let ch = byte as char;\n+        let mut it = self.byte_iter().enumerate();\n+        for (idx, byte) in it {\n             let val = byte as u32;\n \n-            match ch {\n+            match byte as char {\n                 'A'..'Z' => buf |= val - 0x41,\n                 'a'..'z' => buf |= val - 0x47,\n                 '0'..'9' => buf |= val + 0x04,\n                 '+'|'-' => buf |= 0x3E,\n                 '/'|'_' => buf |= 0x3F,\n                 '\\r'|'\\n' => loop,\n                 '=' => break,\n-                _ => return Err(~\"Invalid Base64 character\")\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n             }\n \n             buf <<= 6;\n@@ -230,8 +216,11 @@ impl<'self> FromBase64 for &'self [u8] {\n             }\n         }\n \n-        if !it.all(|&byte| {byte as char == '='}) {\n-            return Err(~\"Invalid Base64 character\");\n+        for (idx, byte) in it {\n+            if (byte as char) != '=' {\n+                return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                self.char_at(idx), idx));\n+            }\n         }\n \n         match modulus {\n@@ -250,67 +239,35 @@ impl<'self> FromBase64 for &'self [u8] {\n     }\n }\n \n-impl<'self> FromBase64 for &'self str {\n-    /**\n-     * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those\n-     * values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to base64 and back.\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::base64::{ToBase64, FromBase64, standard};\n-     * use std::str;\n-     *\n-     * fn main () {\n-     *     let hello_str = \"Hello, World\".to_base64(standard);\n-     *     printfln!(\"%s\", hello_str);\n-     *     let bytes = hello_str.from_base64();\n-     *     printfln!(\"%?\", bytes);\n-     *     let result_str = str::from_bytes(bytes);\n-     *     printfln!(\"%s\", result_str);\n-     * }\n-     * ~~~\n-     */\n-    fn from_base64(&self) -> Result<~[u8], ~str> {\n-        self.as_bytes().from_base64()\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use test::BenchHarness;\n     use base64::*;\n \n     #[test]\n     fn test_to_base64_basic() {\n-        assert_eq!(\"\".to_base64(STANDARD), ~\"\");\n-        assert_eq!(\"f\".to_base64(STANDARD), ~\"Zg==\");\n-        assert_eq!(\"fo\".to_base64(STANDARD), ~\"Zm8=\");\n-        assert_eq!(\"foo\".to_base64(STANDARD), ~\"Zm9v\");\n-        assert_eq!(\"foob\".to_base64(STANDARD), ~\"Zm9vYg==\");\n-        assert_eq!(\"fooba\".to_base64(STANDARD), ~\"Zm9vYmE=\");\n-        assert_eq!(\"foobar\".to_base64(STANDARD), ~\"Zm9vYmFy\");\n+        assert_eq!(\"\".as_bytes().to_base64(STANDARD), ~\"\");\n+        assert_eq!(\"f\".as_bytes().to_base64(STANDARD), ~\"Zg==\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(STANDARD), ~\"Zm8=\");\n+        assert_eq!(\"foo\".as_bytes().to_base64(STANDARD), ~\"Zm9v\");\n+        assert_eq!(\"foob\".as_bytes().to_base64(STANDARD), ~\"Zm9vYg==\");\n+        assert_eq!(\"fooba\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmE=\");\n+        assert_eq!(\"foobar\".as_bytes().to_base64(STANDARD), ~\"Zm9vYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_line_break() {\n         assert!(![0u8, 1000].to_base64(Config {line_length: None, ..STANDARD})\n                 .contains(\"\\r\\n\"));\n-        assert_eq!(\"foobar\".to_base64(Config {line_length: Some(4), ..STANDARD}),\n+        assert_eq!(\"foobar\".as_bytes().to_base64(Config {line_length: Some(4),\n+                                                         ..STANDARD}),\n                    ~\"Zm9v\\r\\nYmFy\");\n     }\n \n     #[test]\n     fn test_to_base64_padding() {\n-        assert_eq!(\"f\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n-        assert_eq!(\"fo\".to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n+        assert_eq!(\"f\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zg\");\n+        assert_eq!(\"fo\".as_bytes().to_base64(Config {pad: false, ..STANDARD}), ~\"Zm8\");\n     }\n \n     #[test]\n@@ -344,7 +301,7 @@ mod test {\n     #[test]\n     fn test_from_base64_invalid_char() {\n         assert!(\"Zm$=\".from_base64().is_err())\n-            assert!(\"Zg==$\".from_base64().is_err());\n+        assert!(\"Zg==$\".from_base64().is_err());\n     }\n \n     #[test]\n@@ -368,20 +325,20 @@ mod test {\n     }\n \n     #[bench]\n-    pub fn to_base64(bh: & mut BenchHarness) {\n+    pub fn bench_to_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         do bh.iter {\n-            s.to_base64(STANDARD);\n+            s.as_bytes().to_base64(STANDARD);\n         }\n         bh.bytes = s.len() as u64;\n     }\n \n     #[bench]\n-    pub fn from_base64(bh: & mut BenchHarness) {\n+    pub fn bench_from_base64(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let b = s.to_base64(STANDARD);\n+        let b = s.as_bytes().to_base64(STANDARD);\n         do bh.iter {\n             b.from_base64();\n         }"}, {"sha": "2a6a8a520556408402e82c9e900ba7ae6506d939", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 22, "deletions": 70, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e6176513842da1dd9e17d8536e7d76125a1bc610/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6176513842da1dd9e17d8536e7d76125a1bc610/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=e6176513842da1dd9e17d8536e7d76125a1bc610", "patch": "@@ -50,53 +50,38 @@ impl<'self> ToHex for &'self [u8] {\n     }\n }\n \n-impl<'self> ToHex for &'self str {\n-    /**\n-     * Convert any string (literal, `@`, `&`, or `~`) to hexadecimal encoding.\n-     *\n-     *\n-     * # Example\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::ToHex;\n-     *\n-     * fn main () {\n-     *     let str = \"Hello, World\".to_hex();\n-     *     printfln!(\"%s\", str);\n-     * }\n-     * ~~~\n-     *\n-     */\n-    fn to_hex(&self) -> ~str {\n-        self.as_bytes().to_hex()\n-    }\n-}\n-\n /// A trait for converting hexadecimal encoded values\n pub trait FromHex {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n     fn from_hex(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromHex for &'self [u8] {\n+impl<'self> FromHex for &'self str {\n     /**\n-     * Convert hexadecimal `u8` vector into u8 byte values.\n-     * Every 2 encoded characters is converted into 1 octet.\n-     * Whitespace is ignored.\n+     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n      *\n      * # Example\n      *\n+     * This converts a string literal to hexadecimal and back.\n+     *\n      * ~~~ {.rust}\n      * extern mod extra;\n-     * use extra::hex::{ToHex, FromHex};\n+     * use extra::hex::{FromHex, ToHex};\n+     * use std::str;\n      *\n      * fn main () {\n-     *     let str = [52,32].to_hex();\n-     *     printfln!(\"%s\", str);\n-     *     let bytes = str.from_hex().get();\n+     *     let hello_str = \"Hello, World\".to_hex();\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_hex().get();\n      *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n      * }\n      * ~~~\n      */\n@@ -106,7 +91,7 @@ impl<'self> FromHex for &'self [u8] {\n         let mut modulus = 0;\n         let mut buf = 0u8;\n \n-        for (idx, &byte) in self.iter().enumerate() {\n+        for (idx, byte) in self.byte_iter().enumerate() {\n             buf <<= 4;\n \n             match byte as char {\n@@ -117,8 +102,8 @@ impl<'self> FromHex for &'self [u8] {\n                     buf >>= 4;\n                     loop\n                 }\n-                _ => return Err(fmt!(\"Invalid byte '%c' found at position %u\",\n-                                     byte as char, idx))\n+                _ => return Err(fmt!(\"Invalid character '%c' at position %u\",\n+                                     self.char_at(idx), idx))\n             }\n \n             modulus += 1;\n@@ -135,47 +120,14 @@ impl<'self> FromHex for &'self [u8] {\n     }\n }\n \n-impl<'self> FromHex for &'self str {\n-    /**\n-     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n-     * to the byte values it encodes.\n-     *\n-     * You can use the `from_bytes` function in `std::str`\n-     * to turn a `[u8]` into a string with characters corresponding to those\n-     * values.\n-     *\n-     * # Example\n-     *\n-     * This converts a string literal to hexadecimal and back.\n-     *\n-     * ~~~ {.rust}\n-     * extern mod extra;\n-     * use extra::hex::{FromHex, ToHex};\n-     * use std::str;\n-     *\n-     * fn main () {\n-     *     let hello_str = \"Hello, World\".to_hex();\n-     *     printfln!(\"%s\", hello_str);\n-     *     let bytes = hello_str.from_hex().get();\n-     *     printfln!(\"%?\", bytes);\n-     *     let result_str = str::from_bytes(bytes);\n-     *     printfln!(\"%s\", result_str);\n-     * }\n-     * ~~~\n-     */\n-    fn from_hex(&self) -> Result<~[u8], ~str> {\n-        self.as_bytes().from_hex()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test::BenchHarness;\n     use hex::*;\n \n     #[test]\n     pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".to_hex(), ~\"666f6f626172\");\n+        assert_eq!(\"foobar\".as_bytes().to_hex(), ~\"666f6f626172\");\n     }\n \n     #[test]\n@@ -223,7 +175,7 @@ mod tests {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n         do bh.iter {\n-            s.to_hex();\n+            s.as_bytes().to_hex();\n         }\n         bh.bytes = s.len() as u64;\n     }\n@@ -232,7 +184,7 @@ mod tests {\n     pub fn bench_from_hex(bh: & mut BenchHarness) {\n         let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n                  \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let b = s.to_hex();\n+        let b = s.as_bytes().to_hex();\n         do bh.iter {\n             b.from_hex();\n         }"}]}