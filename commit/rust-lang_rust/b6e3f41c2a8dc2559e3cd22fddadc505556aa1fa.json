{"sha": "b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "node_id": "C_kwDOAAsO6NoAKGI2ZTNmNDFjMmE4ZGMyNTU5ZTNjZDIyZmRkYWRjNTA1NTU2YWExZmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T14:28:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-16T14:28:12Z"}, "message": "Auto merge of #13243 - Veykril:search-memchr, r=Veykril\n\nUse memmem when searching for usages in ide-db\n\nWe already have this dependency, so there is no reason not to use it as it is generally faster than std in our use case.", "tree": {"sha": "d7b0341d3f62dd69db6c02bdf6b206317891ef4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b0341d3f62dd69db6c02bdf6b206317891ef4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "html_url": "https://github.com/rust-lang/rust/commit/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "870bfc7e3bfcf5b0073abf32182e4b57e8dd6cf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/870bfc7e3bfcf5b0073abf32182e4b57e8dd6cf1", "html_url": "https://github.com/rust-lang/rust/commit/870bfc7e3bfcf5b0073abf32182e4b57e8dd6cf1"}, {"sha": "b73fa0be9c4f7e36e37443bcc35453a44ce24c92", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73fa0be9c4f7e36e37443bcc35453a44ce24c92", "html_url": "https://github.com/rust-lang/rust/commit/b73fa0be9c4f7e36e37443bcc35453a44ce24c92"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "eaadcc8b8c6d011cd4c305682c80ace2e3bcde58", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "patch": "@@ -660,6 +660,7 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"memchr\",\n  \"once_cell\",\n  \"parser\",\n  \"profile\","}, {"sha": "30272bc16f636754489c6838c64448ac48f8283a", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "patch": "@@ -20,6 +20,7 @@ either = \"1.7.0\"\n itertools = \"0.10.3\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n+memchr = \"2.5.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }"}, {"sha": "7cabdb55e8d284100a4a272f0888029340742bcb", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=b6e3f41c2a8dc2559e3cd22fddadc505556aa1fa", "patch": "@@ -8,6 +8,7 @@ use std::{mem, sync::Arc};\n \n use base_db::{FileId, FileRange, SourceDatabase, SourceDatabaseExt};\n use hir::{DefWithBody, HasAttrs, HasSource, InFile, ModuleSource, Semantics, Visibility};\n+use memchr::memmem::Finder;\n use once_cell::unsync::Lazy;\n use parser::SyntaxKind;\n use stdx::hash::NoHashHashMap;\n@@ -411,14 +412,17 @@ impl<'a> FindUsages<'a> {\n             Some(s) => s.as_str(),\n             None => return,\n         };\n+        let finder = &Finder::new(name);\n+        let include_self_kw_refs =\n+            self.include_self_kw_refs.as_ref().map(|ty| (ty, Finder::new(\"Self\")));\n \n-        // these can't be closures because rust infers the lifetimes wrong ...\n+        // for<'a> |text: &'a str, name: &'a str, search_range: TextRange| -> impl Iterator<Item = TextSize> + 'a { ... }\n         fn match_indices<'a>(\n             text: &'a str,\n-            name: &'a str,\n+            finder: &'a Finder<'a>,\n             search_range: TextRange,\n         ) -> impl Iterator<Item = TextSize> + 'a {\n-            text.match_indices(name).filter_map(move |(idx, _)| {\n+            finder.find_iter(text.as_bytes()).filter_map(move |idx| {\n                 let offset: TextSize = idx.try_into().unwrap();\n                 if !search_range.contains_inclusive(offset) {\n                     return None;\n@@ -427,6 +431,7 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n+        // for<'a> |scope: &'a SearchScope| -> impl Iterator<Item = (Arc<String>, FileId, TextRange)> + 'a { ... }\n         fn scope_files<'a>(\n             sema: &'a Semantics<'_, RootDatabase>,\n             scope: &'a SearchScope,\n@@ -450,7 +455,7 @@ impl<'a> FindUsages<'a> {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n-            for offset in match_indices(&text, name, search_range) {\n+            for offset in match_indices(&text, finder, search_range) {\n                 for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                     if match name {\n                         ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n@@ -462,8 +467,8 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n-            if let Some(self_ty) = &self.include_self_kw_refs {\n-                for offset in match_indices(&text, \"Self\", search_range) {\n+            if let Some((self_ty, finder)) = &include_self_kw_refs {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n                             return;\n@@ -479,20 +484,22 @@ impl<'a> FindUsages<'a> {\n                 let scope = search_scope\n                     .intersection(&SearchScope::module_and_children(self.sema.db, module));\n \n-                let is_crate_root = module.is_crate_root(self.sema.db);\n+                let is_crate_root =\n+                    module.is_crate_root(self.sema.db).then(|| Finder::new(\"crate\"));\n+                let finder = &Finder::new(\"super\");\n \n                 for (text, file_id, search_range) in scope_files(sema, &scope) {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n-                    for offset in match_indices(&text, \"super\", search_range) {\n+                    for offset in match_indices(&text, finder, search_range) {\n                         for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                             if self.found_name_ref(&name_ref, sink) {\n                                 return;\n                             }\n                         }\n                     }\n-                    if is_crate_root {\n-                        for offset in match_indices(&text, \"crate\", search_range) {\n+                    if let Some(finder) = &is_crate_root {\n+                        for offset in match_indices(&text, finder, search_range) {\n                             for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                                 if self.found_name_ref(&name_ref, sink) {\n                                     return;\n@@ -533,8 +540,9 @@ impl<'a> FindUsages<'a> {\n                     search_range.unwrap_or_else(|| TextRange::up_to(TextSize::of(text.as_str())));\n \n                 let tree = Lazy::new(|| sema.parse(file_id).syntax().clone());\n+                let finder = &Finder::new(\"self\");\n \n-                for offset in match_indices(&text, \"self\", search_range) {\n+                for offset in match_indices(&text, finder, search_range) {\n                     for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n                         if self.found_self_module_name_ref(&name_ref, sink) {\n                             return;"}]}