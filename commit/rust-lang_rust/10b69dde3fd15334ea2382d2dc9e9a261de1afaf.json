{"sha": "10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "node_id": "C_kwDOAAsO6NoAKDEwYjY5ZGRlM2ZkMTUzMzRlYTIzODJkMmRjOWU5YTI2MWRlMWFmYWY", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2023-05-03T22:52:31Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2023-05-03T22:52:31Z"}, "message": "debuginfo: split method declaration and definition\n\nWhen we're adding a method to a type DIE, we only want a DW_AT_declaration\nthere, because LLVM LTO can't unify type definitions when a child DIE is a\nfull subprogram definition. Now the subprogram definition gets added at the\nCU level with a specification link back to the abstract declaration.", "tree": {"sha": "adfef4e4846d83602d2d319ed48f5e5a40a172d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adfef4e4846d83602d2d319ed48f5e5a40a172d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "html_url": "https://github.com/rust-lang/rust/commit/10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a368898de758e1b8def6c9060044a5b40eb79e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/a368898de758e1b8def6c9060044a5b40eb79e84", "html_url": "https://github.com/rust-lang/rust/commit/a368898de758e1b8def6c9060044a5b40eb79e84"}], "stats": {"total": 143, "additions": 109, "deletions": 34}, "files": [{"sha": "b138b0c0e70a17205b7f4c5b3628370f0b6065b1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "patch": "@@ -322,7 +322,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n \n         let def_id = instance.def_id();\n-        let containing_scope = get_containing_scope(self, instance);\n+        let (containing_scope, is_method) = get_containing_scope(self, instance);\n         let span = tcx.def_span(def_id);\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n@@ -378,8 +378,29 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        unsafe {\n-            return llvm::LLVMRustDIBuilderCreateFunction(\n+        // When we're adding a method to a type DIE, we only want a DW_AT_declaration there, because\n+        // LLVM LTO can't unify type definitions when a child DIE is a full subprogram definition.\n+        // When we use this `decl` below, the subprogram definition gets created at the CU level\n+        // with a DW_AT_specification pointing back to the type's declaration.\n+        let decl = is_method.then(|| unsafe {\n+            llvm::LLVMRustDIBuilderCreateMethod(\n+                DIB(self),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n+                file_metadata,\n+                loc.line,\n+                function_type_metadata,\n+                flags,\n+                spflags & !DISPFlags::SPFlagDefinition,\n+                template_parameters,\n+            )\n+        });\n+\n+        return unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n                 name.as_ptr().cast(),\n@@ -394,9 +415,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 spflags,\n                 maybe_definition_llfn,\n                 template_parameters,\n-                None,\n-            );\n-        }\n+                decl,\n+            )\n+        };\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -493,14 +514,16 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             names\n         }\n \n+        /// Returns a scope, plus `true` if that's a type scope for \"class\" methods,\n+        /// otherwise `false` for plain namespace scopes.\n         fn get_containing_scope<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n             instance: Instance<'tcx>,\n-        ) -> &'ll DIScope {\n+        ) -> (&'ll DIScope, bool) {\n             // First, let's see if this is a method within an inherent impl. Because\n             // if yes, we want to make the result subroutine DIE a child of the\n             // subroutine's self-type.\n-            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+            if let Some(impl_def_id) = cx.tcx.impl_of_method(instance.def_id()) {\n                 // If the method does *not* belong to a trait, proceed\n                 if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n@@ -511,39 +534,33 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.kind() {\n-                        ty::Adt(def, ..) if !def.is_box() => {\n-                            // Again, only create type information if full debuginfo is enabled\n-                            if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.has_param()\n-                            {\n-                                Some(type_di_node(cx, impl_self_ty))\n-                            } else {\n-                                Some(namespace::item_namespace(cx, def.did()))\n-                            }\n+                    if let ty::Adt(def, ..) = impl_self_ty.kind() && !def.is_box() {\n+                        // Again, only create type information if full debuginfo is enabled\n+                        if cx.sess().opts.debuginfo == DebugInfo::Full && !impl_self_ty.has_param()\n+                        {\n+                            return (type_di_node(cx, impl_self_ty), true);\n+                        } else {\n+                            return (namespace::item_namespace(cx, def.did()), false);\n                         }\n-                        _ => None,\n                     }\n                 } else {\n                     // For trait method impls we still use the \"parallel namespace\"\n                     // strategy\n-                    None\n                 }\n-            });\n+            }\n \n-            self_type.unwrap_or_else(|| {\n-                namespace::item_namespace(\n-                    cx,\n-                    DefId {\n-                        krate: instance.def_id().krate,\n-                        index: cx\n-                            .tcx\n-                            .def_key(instance.def_id())\n-                            .parent\n-                            .expect(\"get_containing_scope: missing parent?\"),\n-                    },\n-                )\n-            })\n+            let scope = namespace::item_namespace(\n+                cx,\n+                DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx\n+                        .tcx\n+                        .def_key(instance.def_id())\n+                        .parent\n+                        .expect(\"get_containing_scope: missing parent?\"),\n+                },\n+            );\n+            (scope, false)\n         }\n     }\n "}, {"sha": "1f98d91c3205496aa3db26cbe98f5499d4cfede3", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "patch": "@@ -1987,6 +1987,21 @@ extern \"C\" {\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n \n+    pub fn LLVMRustDIBuilderCreateMethod<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        SPFlags: DISPFlags,\n+        TParam: &'a DIArray,\n+    ) -> &'a DISubprogram;\n+\n     pub fn LLVMRustDIBuilderCreateBasicType<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,"}, {"sha": "49acd71b3e106a9d8d4604def4782cdba908dd06", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "patch": "@@ -831,6 +831,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   return wrap(Sub);\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMethod(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n+    LLVMMetadataRef Ty, LLVMRustDIFlags Flags,\n+    LLVMRustDISPFlags SPFlags, LLVMMetadataRef TParam) {\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram::DISPFlags llvmSPFlags = fromRust(SPFlags);\n+  DINode::DIFlags llvmFlags = fromRust(Flags);\n+  DISubprogram *Sub = Builder->createMethod(\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty),\n+      0, 0, nullptr, // VTable params aren't used\n+      llvmFlags, llvmSPFlags, TParams);\n+  return wrap(Sub);\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     uint64_t SizeInBits, unsigned Encoding) {"}, {"sha": "3b7a99d3dbc62c8576fa582194855246a763952f", "filename": "tests/run-make/issue-109934-lto-debuginfo/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile?ref=10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "patch": "@@ -0,0 +1,12 @@\n+# ignore-cross-compile\n+include ../tools.mk\n+\n+# With the upgrade to LLVM 16, this was getting:\n+#\n+#   error: Cannot represent a difference across sections\n+#\n+# The error stemmed from DI function definitions under type scopes, fixed by\n+# only declaring in type scope and defining the subprogram elsewhere.\n+\n+all:\n+\t$(RUSTC) lib.rs --test -C lto=fat -C debuginfo=2 -C incremental=$(TMPDIR)/inc-fat"}, {"sha": "c405928bd18241f61e0c72c7d8e75409c2fc9be4", "filename": "tests/run-make/issue-109934-lto-debuginfo/lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b69dde3fd15334ea2382d2dc9e9a261de1afaf/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs?ref=10b69dde3fd15334ea2382d2dc9e9a261de1afaf", "patch": "@@ -0,0 +1,9 @@\n+extern crate alloc;\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn something_alloc() {\n+        assert_eq!(Vec::<u32>::new(), Vec::<u32>::new());\n+    }\n+}"}]}