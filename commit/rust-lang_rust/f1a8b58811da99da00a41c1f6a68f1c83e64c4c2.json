{"sha": "f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxYThiNTg4MTFkYTk5ZGEwMGE0MWMxZjZhNjhmMWM4M2U2NGM0YzI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-06T01:36:39Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-06T19:18:34Z"}, "message": "rustc: De-mode some bits of trans", "tree": {"sha": "43ed327c77feb9fb98072c177e28ec2278e92ec1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ed327c77feb9fb98072c177e28ec2278e92ec1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "html_url": "https://github.com/rust-lang/rust/commit/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b79a58d9d30c09366e562691d50182b335aef6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b79a58d9d30c09366e562691d50182b335aef6e", "html_url": "https://github.com/rust-lang/rust/commit/4b79a58d9d30c09366e562691d50182b335aef6e"}], "stats": {"total": 124, "additions": 61, "deletions": 63}, "files": [{"sha": "f9b704e267a0619287b9dc0dd8faff6594df56ba", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -197,7 +197,7 @@ pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n }\n \n pub fn trans_foreign_call(cx: block, externs: ExternMap,\n-                          llmod: ModuleRef, name: @str, args: ~[ValueRef]) ->\n+                          llmod: ModuleRef, name: @str, args: &[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n@@ -242,7 +242,7 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n // @llblobptr is the data part of a enum value; its actual type\n // is meaningless, as it will be cast away.\n pub fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n-                variant_id: ast::def_id, ty_substs: ~[ty::t],\n+                variant_id: ast::def_id, ty_substs: &[ty::t],\n                 ix: uint) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"GEP_enum\");\n     let ccx = bcx.ccx();\n@@ -449,7 +449,7 @@ pub fn set_inline_hint(f: ValueRef) {\n     }\n }\n \n-pub fn set_inline_hint_if_appr(attrs: ~[ast::attribute],\n+pub fn set_inline_hint_if_appr(attrs: &[ast::attribute],\n                                llfn: ValueRef) {\n     match attr::find_inline_attr(attrs) {\n       attr::ia_hint => set_inline_hint(llfn),\n@@ -489,7 +489,7 @@ pub fn note_unique_llvm_symbol(ccx: @CrateContext, +sym: ~str) {\n \n \n pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n-                    parent_id: ast::def_id, substs: ~[ty::t])\n+                    parent_id: ast::def_id, substs: &[ty::t])\n    -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n@@ -516,7 +516,7 @@ pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n }\n \n // Structural comparison: a rather involved form of glue.\n-pub fn maybe_name_value(cx: @CrateContext, v: ValueRef, s: ~str) {\n+pub fn maybe_name_value(cx: @CrateContext, v: ValueRef, s: &str) {\n     if cx.sess.opts.save_temps {\n         let _: () = str::as_c_str(s, |buf| {\n             unsafe {\n@@ -641,7 +641,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n \n     fn iter_variant(cx: block, a_tup: ValueRef,\n                     variant: ty::VariantInfo,\n-                    tps: ~[ty::t], tid: ast::def_id,\n+                    tps: &[ty::t], tid: ast::def_id,\n                     f: val_and_ty_fn) -> block {\n         let _icx = cx.insn_ctxt(\"iter_variant\");\n         if variant.args.len() == 0u { return cx; }\n@@ -916,7 +916,7 @@ pub fn have_cached_lpad(bcx: block) -> bool {\n     return res;\n }\n \n-pub fn in_lpad_scope_cx(bcx: block, f: fn(&mut scope_info)) {\n+pub fn in_lpad_scope_cx(bcx: block, f: fn(+si: &mut scope_info)) {\n     let mut bcx = bcx;\n     loop {\n         {\n@@ -1652,7 +1652,7 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n                                  ty_self: self_arg,\n-                                 args: ~[ast::arg]) -> ~[ValueRef] {\n+                                 args: &[ast::arg]) -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n \n     match ty_self {\n@@ -1865,7 +1865,7 @@ pub fn trans_fn(ccx: @CrateContext,\n     debug!(\"trans_fn(ty_self=%?)\", ty_self);\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n-    let the_path_str = path_str(ccx.sess, path);\n+    let the_path_str = path_str(ccx.sess, &path);\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id, impl_id,\n                   |fcx| {\n@@ -1883,7 +1883,7 @@ pub fn trans_fn(ccx: @CrateContext,\n pub fn trans_enum_variant(ccx: @CrateContext,\n                           enum_id: ast::node_id,\n                           variant: ast::variant,\n-                          args: ~[ast::variant_arg],\n+                          args: &[ast::variant_arg],\n                           disr: int,\n                           is_degen: bool,\n                           param_substs: Option<@param_substs>,\n@@ -1946,7 +1946,7 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n // NB: In theory this should be merged with the function above. But the AST\n // structures are completely different, so very little code would be shared.\n pub fn trans_tuple_struct(ccx: @CrateContext,\n-                          fields: ~[@ast::struct_field],\n+                          fields: &[@ast::struct_field],\n                           ctor_id: ast::node_id,\n                           param_substs: Option<@param_substs>,\n                           llfndecl: ValueRef) {\n@@ -2847,7 +2847,7 @@ pub fn trap(bcx: block) {\n     }\n }\n \n-pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: ~str) {\n+pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: &str) {\n     if !ccx.sess.opts.gc || !*ccx.uses_gc {\n         return;\n     }\n@@ -3014,7 +3014,7 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n+                   +maps: astencode::Maps) -> (ModuleRef, LinkMeta) {\n \n     let symbol_hasher = @hash::default_state();\n     let link_meta ="}, {"sha": "897d898eae6c0f090f7ad2f792d82a87bfe06000", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -117,7 +117,7 @@ pub fn Ret(cx: block, V: ValueRef) {\n     }\n }\n \n-pub fn AggregateRet(cx: block, RetVals: ~[ValueRef]) {\n+pub fn AggregateRet(cx: block, RetVals: &[ValueRef]) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n@@ -184,7 +184,7 @@ pub fn noname() -> *libc::c_char {\n     }\n }\n \n-pub fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+pub fn Invoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n               Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n@@ -202,7 +202,7 @@ pub fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     }\n }\n \n-pub fn FastInvoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+pub fn FastInvoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                   Then: BasicBlockRef, Catch: BasicBlockRef) {\n     if cx.unreachable { return; }\n     check_not_terminated(cx);\n@@ -567,7 +567,7 @@ pub fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     }\n }\n \n-pub fn GEP(cx: block, Pointer: ValueRef, Indices: ~[ValueRef]) -> ValueRef {\n+pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n         count_insn(cx, \"gep\");\n@@ -810,7 +810,7 @@ pub fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n     }\n }\n \n-pub fn Phi(cx: block, Ty: TypeRef, vals: ~[ValueRef], bbs: ~[BasicBlockRef])\n+pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n         if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n@@ -844,11 +844,10 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn add_span_comment(bcx: block, sp: span, text: ~str) {\n+pub fn add_span_comment(bcx: block, sp: span, text: &str) {\n     let ccx = bcx.ccx();\n     if !ccx.sess.no_asm_comments() {\n-        let s = text + ~\" (\" + ccx.sess.codemap.span_to_str(sp)\n-            + ~\")\";\n+        let s = fmt!(\"%s (%s)\", text, ccx.sess.codemap.span_to_str(sp));\n         log(debug, copy s);\n         add_comment(bcx, s);\n     }\n@@ -888,7 +887,7 @@ pub fn Call(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n+pub fn FastCall(cx: block, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {\n         count_insn(cx, \"fastcall\");\n@@ -899,7 +898,7 @@ pub fn FastCall(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn CallWithConv(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n+pub fn CallWithConv(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                     Conv: CallConv) -> ValueRef {\n     if cx.unreachable { return _UndefReturn(cx, Fn); }\n     unsafe {"}, {"sha": "e8d542efa16896c96663c03f2c64d84c164efbe3", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -187,7 +187,7 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n         bcx: block,\n         def_id: ast::def_id,\n         ref_id: ast::node_id,\n-        +type_params: ~[ty::t],\n+        type_params: &[ty::t],\n         vtables: Option<typeck::vtable_res>)\n      -> Callee {\n     Callee {bcx: bcx,\n@@ -199,7 +199,7 @@ pub fn trans_fn_ref_with_vtables(\n         bcx: block,            //\n         def_id: ast::def_id,   // def id of fn\n         ref_id: ast::node_id,  // node id of use of fn; may be zero if N/A\n-        +type_params: ~[ty::t], // values for fn's ty params\n+        type_params: &[ty::t], // values for fn's ty params\n         vtables: Option<typeck::vtable_res>)\n      -> FnData {\n     //!\n@@ -378,7 +378,7 @@ pub fn trans_lang_call(bcx: block,\n pub fn trans_lang_call_with_type_params(bcx: block,\n                                         did: ast::def_id,\n                                         args: &[ValueRef],\n-                                        type_params: ~[ty::t],\n+                                        type_params: &[ty::t],\n                                         dest: expr::Dest)\n     -> block {\n     let fty;\n@@ -394,7 +394,7 @@ pub fn trans_lang_call_with_type_params(bcx: block,\n         |bcx| {\n             let callee =\n                 trans_fn_ref_with_vtables_to_callee(bcx, did, 0,\n-                                                    copy type_params,\n+                                                    type_params,\n                                                     None);\n \n             let new_llval;\n@@ -636,8 +636,8 @@ pub enum AutorefArg {\n pub fn trans_arg_expr(bcx: block,\n                       formal_ty: ty::arg,\n                       arg_expr: @ast::expr,\n-                      temp_cleanups: &mut ~[ValueRef],\n-                      ret_flag: Option<ValueRef>,\n+                      +temp_cleanups: &mut ~[ValueRef],\n+                      +ret_flag: Option<ValueRef>,\n                       +autoref_arg: AutorefArg) -> Result {\n     let _icx = bcx.insn_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();"}, {"sha": "2d7149fdfb2bbb5d218309b56bc1380592a894b2", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -57,13 +57,12 @@ use syntax::codemap::span;\n use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n \n-pub type namegen = @fn(~str) -> ident;\n+pub type namegen = @fn(+s: ~str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n-    let f: @fn(~str) -> ident = |prefix| {\n-        // XXX: Bad copies.\n+    let f: @fn(+s: ~str) -> ident = |prefix| {\n         intr.gensym(@fmt!(\"%s_%u\",\n                           prefix,\n-                          intr.gensym(@copy prefix).repr))\n+                          intr.gensym(@prefix).repr))\n     };\n     f\n }\n@@ -325,10 +324,10 @@ pub struct fn_ctxt_ {\n \n pub type fn_ctxt = @mut fn_ctxt_;\n \n-pub fn warn_not_to_commit(ccx: @CrateContext, msg: ~str) {\n+pub fn warn_not_to_commit(ccx: @CrateContext, msg: &str) {\n     if !*ccx.do_not_commit_warning_issued {\n         *ccx.do_not_commit_warning_issued = true;\n-        ccx.sess.warn(msg + ~\" -- do not commit like this!\");\n+        ccx.sess.warn(msg.to_str() + ~\" -- do not commit like this!\");\n     }\n }\n \n@@ -358,7 +357,7 @@ pub struct cleanup_path {\n     dest: BasicBlockRef\n }\n \n-pub fn scope_clean_changed(scope_info: &mut scope_info) {\n+pub fn scope_clean_changed(+scope_info: &mut scope_info) {\n     if scope_info.cleanup_paths.len() > 0u { scope_info.cleanup_paths = ~[]; }\n     scope_info.landing_pad = None;\n }\n@@ -625,7 +624,7 @@ pub fn rslt(bcx: block, val: ValueRef) -> Result {\n }\n \n pub impl Result {\n-    fn unpack(&self, bcx: &mut block) -> ValueRef {\n+    fn unpack(&self, +bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -645,7 +644,7 @@ pub fn val_str(tn: @TypeNames, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n-pub fn in_scope_cx(cx: block, f: &fn(&mut scope_info)) {\n+pub fn in_scope_cx(cx: block, f: &fn(+si: &mut scope_info)) {\n     let mut cur = cx;\n     loop {\n         {\n@@ -811,7 +810,7 @@ pub fn T_size_t(targ_cfg: @session::config) -> TypeRef {\n     return T_int(targ_cfg);\n }\n \n-pub fn T_fn(inputs: ~[TypeRef], output: TypeRef) -> TypeRef {\n+pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n     unsafe {\n         return llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                    inputs.len() as c_uint,\n@@ -835,22 +834,22 @@ pub fn T_root(t: TypeRef, addrspace: addrspace) -> TypeRef {\n     }\n }\n \n-pub fn T_struct(elts: ~[TypeRef]) -> TypeRef {\n+pub fn T_struct(elts: &[TypeRef]) -> TypeRef {\n     unsafe {\n         return llvm::LLVMStructType(to_ptr(elts),\n                                     elts.len() as c_uint,\n                                     False);\n     }\n }\n \n-pub fn T_named_struct(name: ~str) -> TypeRef {\n+pub fn T_named_struct(name: &str) -> TypeRef {\n     unsafe {\n         let c = llvm::LLVMGetGlobalContext();\n         return str::as_c_str(name, |buf| llvm::LLVMStructCreateNamed(c, buf));\n     }\n }\n \n-pub fn set_struct_body(t: TypeRef, elts: ~[TypeRef]) {\n+pub fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n     unsafe {\n         llvm::LLVMStructSetBody(t,\n                                 to_ptr(elts),\n@@ -1094,7 +1093,7 @@ pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n     }\n }\n \n-pub fn C_floating(s: ~str, t: TypeRef) -> ValueRef {\n+pub fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n     unsafe {\n         return str::as_c_str(s, |buf| llvm::LLVMConstRealOfString(t, buf));\n     }\n@@ -1169,7 +1168,7 @@ pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n }\n \n // Returns a Plain Old LLVM String:\n-pub fn C_postr(s: ~str) -> ValueRef {\n+pub fn C_postr(s: &str) -> ValueRef {\n     unsafe {\n         return do str::as_c_str(s) |buf| {\n             llvm::LLVMConstString(buf, str::len(s) as c_uint, False)\n@@ -1212,22 +1211,22 @@ pub fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n-pub fn C_array(ty: TypeRef, elts: ~[ValueRef]) -> ValueRef {\n+pub fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstArray(ty, vec::raw::to_ptr(elts),\n                                  elts.len() as c_uint);\n     }\n }\n \n-pub fn C_bytes(bytes: ~[u8]) -> ValueRef {\n+pub fn C_bytes(bytes: &[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n             bytes.len() as c_uint, True);\n     }\n }\n \n-pub fn C_bytes_plus_null(bytes: ~[u8]) -> ValueRef {\n+pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstString(\n             cast::reinterpret_cast(&vec::raw::to_ptr(bytes)),\n@@ -1311,9 +1310,9 @@ pub fn align_to(cx: block, off: ValueRef, align: ValueRef) -> ValueRef {\n     return build::And(cx, bumped, build::Not(cx, mask));\n }\n \n-pub fn path_str(sess: session::Session, p: path) -> ~str {\n+pub fn path_str(sess: session::Session, p: &path) -> ~str {\n     let mut r = ~\"\", first = true;\n-    for vec::each(p) |e| {\n+    for vec::each(*p) |e| {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first { first = false; }"}, {"sha": "911cd347ed0cf7c95e4d1918b15e6c0c05a53fd2", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -108,7 +108,7 @@ pub fn trans_if(bcx: block,\n \n }\n \n-pub fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n+pub fn join_blocks(parent_bcx: block, in_cxs: &[block]) -> block {\n     let out = sub_block(parent_bcx, ~\"join\");\n     let mut reachable = false;\n     for vec::each(in_cxs) |bcx| {\n@@ -192,8 +192,7 @@ pub fn trans_log(log_ex: @ast::expr,\n         bcx.fcx.path.filtered(|e|\n             match *e { path_mod(_) => true, _ => false }\n         ));\n-    // XXX: Bad copy.\n-    let modname = path_str(ccx.sess, copy modpath);\n+    let modname = path_str(ccx.sess, &modpath);\n \n     let global = if ccx.module_data.contains_key(&modname) {\n         ccx.module_data.get(&modname)\n@@ -326,11 +325,11 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n pub fn trans_check_expr(bcx: block,\n                         chk_expr: @ast::expr,\n                         pred_expr: @ast::expr,\n-                        s: ~str)\n+                        s: &str)\n                      -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = @(s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n-        + ~\" failed\");\n+    let expr_str = @(fmt!(\"%s %s failed\",\n+                          s, expr_to_str(pred_expr, bcx.ccx().sess.intr())));\n     let Result {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n             expr::trans_to_datum(bcx, pred_expr).to_result()"}, {"sha": "ce472fd9f1fdbbfa77cfaafecc51b89b01cb07e3", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -815,7 +815,7 @@ pub impl Datum {\n }\n \n pub impl DatumBlock {\n-    fn unpack(&self, bcx: &mut block) -> Datum {\n+    fn unpack(&self, +bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }"}, {"sha": "7bed3e86190a2ed31210f7a31e3dcfcc8aaa51f5", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -756,7 +756,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n }\n \n pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n-                         helper: glue_helper, name: ~str)\n+                         helper: glue_helper, name: &str)\n                       -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n@@ -766,7 +766,7 @@ pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let start = time::get_time();\n     let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n     let end = time::get_time();\n-    log_fn_time(ccx, ~\"glue \" + name + ~\" \" + ty_to_short_str(ccx.tcx, t),\n+    log_fn_time(ccx, fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n                 start, end);\n     return llval;\n }"}, {"sha": "c0af1f4fad2a789ae8bbe93180a4b5d3ad735609", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -42,7 +42,7 @@ use syntax::parse::token::special_idents;\n \n pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::def_id,\n-                      real_substs: ~[ty::t],\n+                      real_substs: &[ty::t],\n                       vtables: Option<typeck::vtable_res>,\n                       impl_did_opt: Option<ast::def_id>,\n                       ref_id: Option<ast::node_id>) ->\n@@ -150,7 +150,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(/*bad*/copy *pt,\n-                         ~[path_name((ccx.names)(*ccx.sess.str_of(name)))]);\n+                         ~[path_name((ccx.names)(\n+                             copy *ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {\n@@ -322,10 +323,10 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n     }\n }\n \n-pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: ~[ty::t],\n+pub fn make_mono_id(ccx: @CrateContext, item: ast::def_id, substs: &[ty::t],\n                     vtables: Option<typeck::vtable_res>,\n                     impl_did_opt: Option<ast::def_id>,\n-                    param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n+                    +param_uses: Option<~[type_use::type_uses]>) -> mono_id {\n     let precise_param_ids = match vtables {\n       Some(vts) => {\n         let bounds = ty::lookup_item_type(ccx.tcx, item).bounds;"}, {"sha": "26cf91b03e1455c13cbec9806023907846a97ca1", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1a8b58811da99da00a41c1f6a68f1c83e64c4c2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=f1a8b58811da99da00a41c1f6a68f1c83e64c4c2", "patch": "@@ -360,7 +360,7 @@ pub enum named_ty { a_struct, an_enum }\n pub fn llvm_type_name(cx: @CrateContext,\n                       what: named_ty,\n                       did: ast::def_id,\n-                      tps: ~[ty::t]) -> ~str {\n+                      tps: &[ty::t]) -> ~str {\n     let name = match what {\n         a_struct => { \"~struct\" }\n         an_enum => { \"~enum\" }"}]}