{"sha": "efb8924f8848f39811a8e69db182effb465ad3cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjg5MjRmODg0OGYzOTgxMWE4ZTY5ZGIxODJlZmZiNDY1YWQzY2Y=", "commit": {"author": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-27T16:57:30Z"}, "committer": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-27T21:28:34Z"}, "message": "Add a variant of home_for_io that consumes the handle. Refactor out common parts of the home_for_io variants.", "tree": {"sha": "e612a673a54e6131468aa9eec5ced8e27fe09d34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e612a673a54e6131468aa9eec5ced8e27fe09d34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb8924f8848f39811a8e69db182effb465ad3cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb8924f8848f39811a8e69db182effb465ad3cf", "html_url": "https://github.com/rust-lang/rust/commit/efb8924f8848f39811a8e69db182effb465ad3cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb8924f8848f39811a8e69db182effb465ad3cf/comments", "author": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed422b88727807aee40495a6193a69e4c3842be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed422b88727807aee40495a6193a69e4c3842be1", "html_url": "https://github.com/rust-lang/rust/commit/ed422b88727807aee40495a6193a69e4c3842be1"}], "stats": {"total": 101, "additions": 53, "deletions": 48}, "files": [{"sha": "ad9d2a597947e8b009746240de5b6da51928e645", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 53, "deletions": 48, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/efb8924f8848f39811a8e69db182effb465ad3cf/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb8924f8848f39811a8e69db182effb465ad3cf/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=efb8924f8848f39811a8e69db182effb465ad3cf", "patch": "@@ -26,6 +26,7 @@ use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::tube::Tube;\n+use rt::task::SchedHome;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n@@ -47,76 +48,80 @@ use task;\n // XXX we should not be calling uvll functions in here.\n \n trait HomingIO {\n+\n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n+\n     /* XXX This will move pinned tasks to do IO on the proper scheduler\n      * and then move them back to their home.\n      */\n-    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n-        use rt::sched::{PinnedTask, TaskFromFriend};\n-        // go home\n-        let old_home = Cell::new_empty();\n-        let old_home_ptr = &old_home;\n+    fn go_to_IO_home(&mut self) -> SchedHome {\n+        use rt::sched::PinnedTask;\n+\n         do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                // get the old home first\n-                do task.wake().map_move |mut task| {\n-                    old_home_ptr.put_back(task.take_unwrap_home());\n-                    self.home().send(PinnedTask(task));\n-                };\n+            let mut old = None;\n+            {\n+                let ptr = &mut old;\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    /* FIXME(#8674) if the task was already killed then wake\n+                     * will return None. In that case, the home pointer will never be set.\n+                     *\n+                     * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n+                     */\n+                    do task.wake().map_move |mut task| {\n+                        *ptr = Some(task.take_unwrap_home());\n+                        self.home().send(PinnedTask(task));\n+                    };\n+                }\n             }\n+            old.expect(\"No old home because task had already been killed.\")\n         }\n+    }\n \n-        // do IO\n-        let a = io(self);\n+    // XXX dummy self param\n+    fn restore_original_home(_dummy_self: Option<Self>, old: SchedHome) {\n+        use rt::sched::TaskFromFriend;\n \n-        // unhome home\n+        let old = Cell::new(old);\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+                /* FIXME(#8674) if the task was already killed then wake\n+                 * will return None. In that case, the home pointer will never be restored.\n+                 *\n+                 * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n+                 */\n                 do task.wake().map_move |mut task| {\n-                    task.give_home(old_home.take());\n+                    task.give_home(old.take());\n                     scheduler.make_handle().send(TaskFromFriend(task));\n                 };\n             }\n         }\n-\n-        // return the result of the IO\n-        a\n     }\n \n-    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n-        use rt::sched::{PinnedTask, TaskFromFriend};\n-\n-        do task::unkillable { // FIXME(#8674)\n-            // go home\n-            let old_home = Cell::new_empty();\n-            let old_home_ptr = &old_home;\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                // get the old home first\n-                do task.wake().map_move |mut task| {\n-                    old_home_ptr.put_back(task.take_unwrap_home());\n-                    self.home().send(PinnedTask(task));\n-                };\n-            }\n+    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = io(self); // do IO\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return the result of the IO\n+    }\n \n-            // do IO\n-            let scheduler: ~Scheduler = Local::take();\n-            let a = io_sched(self, scheduler);\n+    fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n+        let mut this = self;\n+        let home = this.go_to_IO_home();\n+        let a = io(this); // do IO\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return the result of the IO\n+    }\n \n-            // unhome home\n+    fn home_for_io_with_sched<A>(&mut self, io_sched: &fn(&mut Self, ~Scheduler) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                do task.wake().map_move |mut task| {\n-                    task.give_home(old_home.take());\n-                    scheduler.make_handle().send(TaskFromFriend(task));\n-                };\n-            }\n-\n-            // return the result of the IO\n-            a\n-        }\n+            io_sched(self, scheduler) // do IO and scheduling action\n+        };\n+        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        a // return result of IO\n     }\n }\n "}]}