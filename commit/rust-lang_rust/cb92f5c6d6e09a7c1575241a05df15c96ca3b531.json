{"sha": "cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiOTJmNWM2ZDZlMDlhN2MxNTc1MjQxYTA1ZGYxNWM5NmNhM2I1MzE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T00:46:54Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T21:56:57Z"}, "message": "Rename StringReader::last_pos as pos.\n\nThis is a [breaking-change] for libsyntax.", "tree": {"sha": "015376a59cd62a6d357442638d5827e63e875340", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/015376a59cd62a6d357442638d5827e63e875340"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "html_url": "https://github.com/rust-lang/rust/commit/cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94565a4409f8b8a133db36d3a22221b5b38a1a13", "url": "https://api.github.com/repos/rust-lang/rust/commits/94565a4409f8b8a133db36d3a22221b5b38a1a13", "html_url": "https://github.com/rust-lang/rust/commit/94565a4409f8b8a133db36d3a22221b5b38a1a13"}], "stats": {"total": 200, "additions": 100, "deletions": 100}, "files": [{"sha": "c2a6e625fc08e101d0f20f5a21ec55feae155c80", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "patch": "@@ -149,7 +149,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n     comments.push(Comment {\n         style: BlankLine,\n         lines: Vec::new(),\n-        pos: rdr.last_pos,\n+        pos: rdr.pos,\n     });\n }\n \n@@ -167,7 +167,7 @@ fn read_shebang_comment(rdr: &mut StringReader,\n                         code_to_the_left: bool,\n                         comments: &mut Vec<Comment>) {\n     debug!(\">>> shebang comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.pos;\n     debug!(\"<<< shebang comment\");\n     comments.push(Comment {\n         style: if code_to_the_left { Trailing } else { Isolated },\n@@ -180,7 +180,7 @@ fn read_line_comments(rdr: &mut StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut Vec<Comment>) {\n     debug!(\">>> line comments\");\n-    let p = rdr.last_pos;\n+    let p = rdr.pos;\n     let mut lines: Vec<String> = Vec::new();\n     while rdr.curr_is('/') && rdr.nextch_is('/') {\n         let line = rdr.read_one_line_comment();\n@@ -240,7 +240,7 @@ fn read_block_comment(rdr: &mut StringReader,\n                       code_to_the_left: bool,\n                       comments: &mut Vec<Comment>) {\n     debug!(\">>> block comment\");\n-    let p = rdr.last_pos;\n+    let p = rdr.pos;\n     let mut lines: Vec<String> = Vec::new();\n     let col = rdr.col;\n     rdr.bump();\n@@ -369,7 +369,7 @@ pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n         }\n \n \n-        let bstart = rdr.last_pos;\n+        let bstart = rdr.pos;\n         rdr.next_token();\n         // discard, and look ahead; we're working with internal state\n         let TokenAndSpan { tok, sp } = rdr.peek();"}, {"sha": "db15e07656989eeefbaaeccd17cb5cb0c182219c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "patch": "@@ -78,8 +78,8 @@ pub struct StringReader<'a> {\n     pub span_diagnostic: &'a Handler,\n     /// The absolute offset within the codemap of the next character to read\n     pub next_pos: BytePos,\n-    /// The absolute offset within the codemap of the last character read(curr)\n-    pub last_pos: BytePos,\n+    /// The absolute offset within the codemap of the current character\n+    pub pos: BytePos,\n     /// The column of the next character to read\n     pub col: CharPos,\n     /// The last character to be read\n@@ -196,7 +196,7 @@ impl<'a> StringReader<'a> {\n         StringReader {\n             span_diagnostic: span_diagnostic,\n             next_pos: filemap.start_pos,\n-            last_pos: filemap.start_pos,\n+            pos: filemap.start_pos,\n             col: CharPos(0),\n             curr: Some('\\n'),\n             filemap: filemap,\n@@ -317,9 +317,9 @@ impl<'a> StringReader<'a> {\n                     self.peek_tok = token::Eof;\n                     self.peek_span = syntax_pos::mk_sp(self.filemap.end_pos, self.filemap.end_pos);\n                 } else {\n-                    let start_bytepos = self.last_pos;\n+                    let start_bytepos = self.pos;\n                     self.peek_tok = self.next_token_inner()?;\n-                    self.peek_span = syntax_pos::mk_sp(start_bytepos, self.last_pos);\n+                    self.peek_span = syntax_pos::mk_sp(start_bytepos, self.pos);\n                 };\n             }\n         }\n@@ -331,19 +331,19 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n-    /// up to but excluding `self.last_pos`, meaning the slice does not include\n+    /// up to but excluding `self.pos`, meaning the slice does not include\n     /// the character `self.curr`.\n     pub fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T\n         where F: FnOnce(&str) -> T\n     {\n-        self.with_str_from_to(start, self.last_pos, f)\n+        self.with_str_from_to(start, self.pos, f)\n     }\n \n     /// Create a Name from a given offset to the current offset, each\n     /// adjusted 1 towards each other (assumes that on either side there is a\n     /// single-byte delimiter).\n     pub fn name_from(&self, start: BytePos) -> ast::Name {\n-        debug!(\"taking an ident from {:?} to {:?}\", start, self.last_pos);\n+        debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n         self.with_str_from(start, token::intern)\n     }\n \n@@ -414,7 +414,7 @@ impl<'a> StringReader<'a> {\n     /// Advance the StringReader by one character. If a newline is\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n-        self.last_pos = self.next_pos;\n+        self.pos = self.next_pos;\n         let current_byte_offset = self.byte_offset(self.next_pos).to_usize();\n         if current_byte_offset < self.source_text.len() {\n             let last_char = self.curr.unwrap();\n@@ -425,13 +425,13 @@ impl<'a> StringReader<'a> {\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 if self.save_new_lines {\n-                    self.filemap.next_line(self.last_pos);\n+                    self.filemap.next_line(self.pos);\n                 }\n                 self.col = CharPos(0);\n             }\n \n             if byte_offset_diff > 1 {\n-                self.filemap.record_multibyte_char(self.last_pos, byte_offset_diff);\n+                self.filemap.record_multibyte_char(self.pos, byte_offset_diff);\n             }\n         } else {\n             self.curr = None;\n@@ -474,7 +474,7 @@ impl<'a> StringReader<'a> {\n         if !ident_start(self.curr) {\n             return None;\n         }\n-        let start = self.last_pos;\n+        let start = self.pos;\n         while ident_continue(self.curr) {\n             self.bump();\n         }\n@@ -493,7 +493,7 @@ impl<'a> StringReader<'a> {\n     fn scan_comment(&mut self) -> Option<TokenAndSpan> {\n         if let Some(c) = self.curr {\n             if c.is_whitespace() {\n-                self.span_diagnostic.span_err(syntax_pos::mk_sp(self.last_pos, self.last_pos),\n+                self.span_diagnostic.span_err(syntax_pos::mk_sp(self.pos, self.pos),\n                                               \"called consume_any_line_comment, but there \\\n                                                was whitespace\");\n             }\n@@ -507,7 +507,7 @@ impl<'a> StringReader<'a> {\n \n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n                     let doc_comment = self.curr_is('/') || self.curr_is('!');\n-                    let start_bpos = self.last_pos - BytePos(2);\n+                    let start_bpos = self.pos - BytePos(2);\n \n                     while !self.is_eof() {\n                         match self.curr.unwrap() {\n@@ -517,7 +517,7 @@ impl<'a> StringReader<'a> {\n                                     // CRLF\n                                     break;\n                                 } else if doc_comment {\n-                                    self.err_span_(self.last_pos,\n+                                    self.err_span_(self.pos,\n                                                    self.next_pos,\n                                                    \"bare CR not allowed in doc-comment\");\n                                 }\n@@ -538,13 +538,13 @@ impl<'a> StringReader<'a> {\n \n                             Some(TokenAndSpan {\n                                 tok: tok,\n-                                sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n+                                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n                             })\n                         })\n                     } else {\n                         Some(TokenAndSpan {\n                             tok: token::Comment,\n-                            sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n+                            sp: syntax_pos::mk_sp(start_bpos, self.pos),\n                         })\n                     };\n                 }\n@@ -567,17 +567,17 @@ impl<'a> StringReader<'a> {\n                 // we're at the beginning of the file...\n                 let cmap = CodeMap::new();\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n-                let loc = cmap.lookup_char_pos_adj(self.last_pos);\n+                let loc = cmap.lookup_char_pos_adj(self.pos);\n                 debug!(\"Skipping a shebang\");\n                 if loc.line == 1 && loc.col == CharPos(0) {\n                     // FIXME: Add shebang \"token\", return it\n-                    let start = self.last_pos;\n+                    let start = self.pos;\n                     while !self.curr_is('\\n') && !self.is_eof() {\n                         self.bump();\n                     }\n                     return Some(TokenAndSpan {\n                         tok: token::Shebang(self.name_from(start)),\n-                        sp: syntax_pos::mk_sp(start, self.last_pos),\n+                        sp: syntax_pos::mk_sp(start, self.pos),\n                     });\n                 }\n             }\n@@ -599,13 +599,13 @@ impl<'a> StringReader<'a> {\n                 c\n             },\n             c if is_pattern_whitespace(Some(c)) => {\n-                let start_bpos = self.last_pos;\n+                let start_bpos = self.pos;\n                 while is_pattern_whitespace(self.curr) {\n                     self.bump();\n                 }\n                 let c = Some(TokenAndSpan {\n                     tok: token::Whitespace,\n-                    sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n+                    sp: syntax_pos::mk_sp(start_bpos, self.pos),\n                 });\n                 debug!(\"scanning whitespace: {:?}\", c);\n                 c\n@@ -618,7 +618,7 @@ impl<'a> StringReader<'a> {\n     fn scan_block_comment(&mut self) -> Option<TokenAndSpan> {\n         // block comments starting with \"/**\" or \"/*!\" are doc-comments\n         let is_doc_comment = self.curr_is('*') || self.curr_is('!');\n-        let start_bpos = self.last_pos - BytePos(2);\n+        let start_bpos = self.pos - BytePos(2);\n \n         let mut level: isize = 1;\n         let mut has_cr = false;\n@@ -629,7 +629,7 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     \"unterminated block comment\"\n                 };\n-                let last_bpos = self.last_pos;\n+                let last_bpos = self.pos;\n                 panic!(self.fatal_span_(start_bpos, last_bpos, msg));\n             }\n             let n = self.curr.unwrap();\n@@ -667,7 +667,7 @@ impl<'a> StringReader<'a> {\n \n             Some(TokenAndSpan {\n                 tok: tok,\n-                sp: syntax_pos::mk_sp(start_bpos, self.last_pos),\n+                sp: syntax_pos::mk_sp(start_bpos, self.pos),\n             })\n         })\n     }\n@@ -694,7 +694,7 @@ impl<'a> StringReader<'a> {\n                     // check that the hypothetical digit is actually\n                     // in range for the true radix\n                     if c.unwrap().to_digit(real_radix).is_none() {\n-                        self.err_span_(self.last_pos,\n+                        self.err_span_(self.pos,\n                                        self.next_pos,\n                                        &format!(\"invalid digit for a base {} literal\", real_radix));\n                     }\n@@ -710,7 +710,7 @@ impl<'a> StringReader<'a> {\n     fn scan_number(&mut self, c: char) -> token::Lit {\n         let num_digits;\n         let mut base = 10;\n-        let start_bpos = self.last_pos;\n+        let start_bpos = self.pos;\n \n         self.bump();\n \n@@ -747,7 +747,7 @@ impl<'a> StringReader<'a> {\n \n         if num_digits == 0 {\n             self.err_span_(start_bpos,\n-                           self.last_pos,\n+                           self.pos,\n                            \"no valid digits found for number\");\n             return token::Integer(token::intern(\"0\"));\n         }\n@@ -766,15 +766,15 @@ impl<'a> StringReader<'a> {\n                 self.scan_digits(10, 10);\n                 self.scan_float_exponent();\n             }\n-            let last_pos = self.last_pos;\n-            self.check_float_base(start_bpos, last_pos, base);\n+            let pos = self.pos;\n+            self.check_float_base(start_bpos, pos, base);\n             return token::Float(self.name_from(start_bpos));\n         } else {\n             // it might be a float if it has an exponent\n             if self.curr_is('e') || self.curr_is('E') {\n                 self.scan_float_exponent();\n-                let last_pos = self.last_pos;\n-                self.check_float_base(start_bpos, last_pos, base);\n+                let pos = self.pos;\n+                self.check_float_base(start_bpos, pos, base);\n                 return token::Float(self.name_from(start_bpos));\n             }\n             // but we certainly have an integer!\n@@ -786,19 +786,19 @@ impl<'a> StringReader<'a> {\n     /// error if too many or too few digits are encountered.\n     fn scan_hex_digits(&mut self, n_digits: usize, delim: char, below_0x7f_only: bool) -> bool {\n         debug!(\"scanning {} digits until {:?}\", n_digits, delim);\n-        let start_bpos = self.last_pos;\n+        let start_bpos = self.pos;\n         let mut accum_int = 0;\n \n         let mut valid = true;\n         for _ in 0..n_digits {\n             if self.is_eof() {\n-                let last_bpos = self.last_pos;\n+                let last_bpos = self.pos;\n                 panic!(self.fatal_span_(start_bpos,\n                                         last_bpos,\n                                         \"unterminated numeric character escape\"));\n             }\n             if self.curr_is(delim) {\n-                let last_bpos = self.last_pos;\n+                let last_bpos = self.pos;\n                 self.err_span_(start_bpos,\n                                last_bpos,\n                                \"numeric character escape is too short\");\n@@ -808,7 +808,7 @@ impl<'a> StringReader<'a> {\n             let c = self.curr.unwrap_or('\\x00');\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n-                self.err_span_char(self.last_pos,\n+                self.err_span_char(self.pos,\n                                    self.next_pos,\n                                    \"invalid character in numeric character escape\",\n                                    c);\n@@ -821,7 +821,7 @@ impl<'a> StringReader<'a> {\n \n         if below_0x7f_only && accum_int >= 0x80 {\n             self.err_span_(start_bpos,\n-                           self.last_pos,\n+                           self.pos,\n                            \"this form of character escape may only be used with characters in \\\n                             the range [\\\\x00-\\\\x7f]\");\n             valid = false;\n@@ -830,7 +830,7 @@ impl<'a> StringReader<'a> {\n         match char::from_u32(accum_int) {\n             Some(_) => valid,\n             None => {\n-                let last_bpos = self.last_pos;\n+                let last_bpos = self.pos;\n                 self.err_span_(start_bpos, last_bpos, \"invalid numeric character escape\");\n                 false\n             }\n@@ -852,7 +852,7 @@ impl<'a> StringReader<'a> {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n                 let escaped = self.curr;\n-                let escaped_pos = self.last_pos;\n+                let escaped_pos = self.pos;\n                 self.bump();\n                 match escaped {\n                     None => {}  // EOF here is an error that will be checked later.\n@@ -864,7 +864,7 @@ impl<'a> StringReader<'a> {\n                                 let valid = if self.curr_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n-                                    let span = syntax_pos::mk_sp(start, self.last_pos);\n+                                    let span = syntax_pos::mk_sp(start, self.pos);\n                                     self.span_diagnostic\n                                         .struct_span_err(span, \"incorrect unicode escape sequence\")\n                                         .span_help(span,\n@@ -875,7 +875,7 @@ impl<'a> StringReader<'a> {\n                                 };\n                                 if ascii_only {\n                                     self.err_span_(start,\n-                                                   self.last_pos,\n+                                                   self.pos,\n                                                    \"unicode escape sequences cannot be used as a \\\n                                                     byte or in a byte string\");\n                                 }\n@@ -891,9 +891,9 @@ impl<'a> StringReader<'a> {\n                                 true\n                             }\n                             c => {\n-                                let last_pos = self.last_pos;\n+                                let pos = self.pos;\n                                 let mut err = self.struct_err_span_char(escaped_pos,\n-                                                                        last_pos,\n+                                                                        pos,\n                                                                         if ascii_only {\n                                                                             \"unknown byte escape\"\n                                                                         } else {\n@@ -902,13 +902,13 @@ impl<'a> StringReader<'a> {\n                                                                         },\n                                                                         c);\n                                 if e == '\\r' {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, last_pos),\n+                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n                                                   \"this is an isolated carriage return; consider \\\n                                                    checking your editor and version control \\\n                                                    settings\");\n                                 }\n                                 if (e == '{' || e == '}') && !ascii_only {\n-                                    err.span_help(syntax_pos::mk_sp(escaped_pos, last_pos),\n+                                    err.span_help(syntax_pos::mk_sp(escaped_pos, pos),\n                                                   \"if used in a formatting string, curly braces \\\n                                                    are escaped with `{{` and `}}`\");\n                                 }\n@@ -920,9 +920,9 @@ impl<'a> StringReader<'a> {\n                 }\n             }\n             '\\t' | '\\n' | '\\r' | '\\'' if delim == '\\'' => {\n-                let last_pos = self.last_pos;\n+                let pos = self.pos;\n                 self.err_span_char(start,\n-                                   last_pos,\n+                                   pos,\n                                    if ascii_only {\n                                        \"byte constant must be escaped\"\n                                    } else {\n@@ -937,16 +937,16 @@ impl<'a> StringReader<'a> {\n                     return true;\n                 } else {\n                     self.err_span_(start,\n-                                   self.last_pos,\n+                                   self.pos,\n                                    \"bare CR not allowed in string, use \\\\r instead\");\n                     return false;\n                 }\n             }\n             _ => {\n                 if ascii_only && first_source_char > '\\x7F' {\n-                    let last_pos = self.last_pos;\n+                    let pos = self.pos;\n                     self.err_span_(start,\n-                                   last_pos,\n+                                   pos,\n                                    \"byte constant must be ASCII. Use a \\\\xHH escape for a \\\n                                     non-ASCII byte\");\n                     return false;\n@@ -962,7 +962,7 @@ impl<'a> StringReader<'a> {\n     /// will read at least one digit, and up to 6, and pass over the }.\n     fn scan_unicode_escape(&mut self, delim: char) -> bool {\n         self.bump(); // past the {\n-        let start_bpos = self.last_pos;\n+        let start_bpos = self.pos;\n         let mut count = 0;\n         let mut accum_int = 0;\n         let mut valid = true;\n@@ -972,18 +972,18 @@ impl<'a> StringReader<'a> {\n                 Some(c) => c,\n                 None => {\n                     panic!(self.fatal_span_(start_bpos,\n-                                            self.last_pos,\n+                                            self.pos,\n                                             \"unterminated unicode escape (found EOF)\"));\n                 }\n             };\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 if c == delim {\n-                    panic!(self.fatal_span_(self.last_pos,\n+                    panic!(self.fatal_span_(self.pos,\n                                             self.next_pos,\n                                             \"unterminated unicode escape (needed a `}`)\"));\n                 } else {\n-                    self.err_span_char(self.last_pos,\n+                    self.err_span_char(self.pos,\n                                        self.next_pos,\n                                        \"invalid character in unicode escape\",\n                                        c);\n@@ -997,14 +997,14 @@ impl<'a> StringReader<'a> {\n \n         if count > 6 {\n             self.err_span_(start_bpos,\n-                           self.last_pos,\n+                           self.pos,\n                            \"overlong unicode escape (can have at most 6 hex digits)\");\n             valid = false;\n         }\n \n         if valid && (char::from_u32(accum_int).is_none() || count == 0) {\n             self.err_span_(start_bpos,\n-                           self.last_pos,\n+                           self.pos,\n                            \"invalid unicode character escape\");\n             valid = false;\n         }\n@@ -1021,7 +1021,7 @@ impl<'a> StringReader<'a> {\n                 self.bump();\n             }\n             if self.scan_digits(10, 10) == 0 {\n-                self.err_span_(self.last_pos,\n+                self.err_span_(self.pos,\n                                self.next_pos,\n                                \"expected at least one digit in exponent\")\n             }\n@@ -1078,7 +1078,7 @@ impl<'a> StringReader<'a> {\n             ('b', Some('r'), Some('#')) => false,\n             _ => true,\n         } {\n-            let start = self.last_pos;\n+            let start = self.pos;\n             while ident_continue(self.curr) {\n                 self.bump();\n             }\n@@ -1241,9 +1241,9 @@ impl<'a> StringReader<'a> {\n             }\n             '\\'' => {\n                 // Either a character constant 'a' OR a lifetime name 'abc\n-                let start_with_quote = self.last_pos;\n+                let start_with_quote = self.pos;\n                 self.bump();\n-                let start = self.last_pos;\n+                let start = self.pos;\n \n                 // the eof will be picked up by the final `'` check below\n                 let c2 = self.curr.unwrap_or('\\x00');\n@@ -1277,7 +1277,7 @@ impl<'a> StringReader<'a> {\n                         str_to_ident(lifetime_name)\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n-                    let last_bpos = self.last_pos;\n+                    let last_bpos = self.pos;\n                     if keyword_checking_token.is_any_keyword() &&\n                        !keyword_checking_token.is_keyword(keywords::Static) {\n                         self.err_span_(start, last_bpos, \"lifetimes cannot use keyword names\");\n@@ -1294,7 +1294,7 @@ impl<'a> StringReader<'a> {\n \n                 if !self.curr_is('\\'') {\n                     panic!(self.fatal_span_verbose(\n-                           start_with_quote, self.last_pos,\n+                           start_with_quote, self.pos,\n                            String::from(\"character literal may only contain one codepoint\")));\n                 }\n \n@@ -1319,18 +1319,18 @@ impl<'a> StringReader<'a> {\n                 return Ok(token::Literal(lit, suffix));\n             }\n             '\"' => {\n-                let start_bpos = self.last_pos;\n+                let start_bpos = self.pos;\n                 let mut valid = true;\n                 self.bump();\n                 while !self.curr_is('\"') {\n                     if self.is_eof() {\n-                        let last_bpos = self.last_pos;\n+                        let last_bpos = self.pos;\n                         panic!(self.fatal_span_(start_bpos,\n                                                 last_bpos,\n                                                 \"unterminated double quote string\"));\n                     }\n \n-                    let ch_start = self.last_pos;\n+                    let ch_start = self.pos;\n                     let ch = self.curr.unwrap();\n                     self.bump();\n                     valid &= self.scan_char_or_byte(ch_start,\n@@ -1350,7 +1350,7 @@ impl<'a> StringReader<'a> {\n                 return Ok(token::Literal(token::Str_(id), suffix));\n             }\n             'r' => {\n-                let start_bpos = self.last_pos;\n+                let start_bpos = self.pos;\n                 self.bump();\n                 let mut hash_count = 0;\n                 while self.curr_is('#') {\n@@ -1359,10 +1359,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 if self.is_eof() {\n-                    let last_bpos = self.last_pos;\n+                    let last_bpos = self.pos;\n                     panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n                 } else if !self.curr_is('\"') {\n-                    let last_bpos = self.last_pos;\n+                    let last_bpos = self.pos;\n                     let curr_char = self.curr.unwrap();\n                     panic!(self.fatal_span_char(start_bpos,\n                                                 last_bpos,\n@@ -1371,24 +1371,24 @@ impl<'a> StringReader<'a> {\n                                                 curr_char));\n                 }\n                 self.bump();\n-                let content_start_bpos = self.last_pos;\n+                let content_start_bpos = self.pos;\n                 let mut content_end_bpos;\n                 let mut valid = true;\n                 'outer: loop {\n                     if self.is_eof() {\n-                        let last_bpos = self.last_pos;\n+                        let last_bpos = self.pos;\n                         panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n                     }\n                     // if self.curr_is('\"') {\n-                    // content_end_bpos = self.last_pos;\n+                    // content_end_bpos = self.pos;\n                     // for _ in 0..hash_count {\n                     // self.bump();\n                     // if !self.curr_is('#') {\n                     // continue 'outer;\n                     let c = self.curr.unwrap();\n                     match c {\n                         '\"' => {\n-                            content_end_bpos = self.last_pos;\n+                            content_end_bpos = self.pos;\n                             for _ in 0..hash_count {\n                                 self.bump();\n                                 if !self.curr_is('#') {\n@@ -1399,7 +1399,7 @@ impl<'a> StringReader<'a> {\n                         }\n                         '\\r' => {\n                             if !self.nextch_is('\\n') {\n-                                let last_bpos = self.last_pos;\n+                                let last_bpos = self.pos;\n                                 self.err_span_(start_bpos,\n                                                last_bpos,\n                                                \"bare CR not allowed in raw string, use \\\\r \\\n@@ -1466,7 +1466,7 @@ impl<'a> StringReader<'a> {\n                 return Ok(self.binop(token::Percent));\n             }\n             c => {\n-                let last_bpos = self.last_pos;\n+                let last_bpos = self.pos;\n                 let bpos = self.next_pos;\n                 let mut err = self.struct_fatal_span_char(last_bpos,\n                                                           bpos,\n@@ -1518,7 +1518,7 @@ impl<'a> StringReader<'a> {\n \n     fn scan_byte(&mut self) -> token::Lit {\n         self.bump();\n-        let start = self.last_pos;\n+        let start = self.pos;\n \n         // the eof will be picked up by the final `'` check below\n         let c2 = self.curr.unwrap_or('\\x00');\n@@ -1533,9 +1533,9 @@ impl<'a> StringReader<'a> {\n             // Byte offsetting here is okay because the\n             // character before position `start` are an\n             // ascii single quote and ascii 'b'.\n-            let last_pos = self.last_pos;\n+            let pos = self.pos;\n             panic!(self.fatal_span_verbose(start - BytePos(2),\n-                                           last_pos,\n+                                           pos,\n                                            \"unterminated byte constant\".to_string()));\n         }\n \n@@ -1554,16 +1554,16 @@ impl<'a> StringReader<'a> {\n \n     fn scan_byte_string(&mut self) -> token::Lit {\n         self.bump();\n-        let start = self.last_pos;\n+        let start = self.pos;\n         let mut valid = true;\n \n         while !self.curr_is('\"') {\n             if self.is_eof() {\n-                let last_pos = self.last_pos;\n-                panic!(self.fatal_span_(start, last_pos, \"unterminated double quote byte string\"));\n+                let pos = self.pos;\n+                panic!(self.fatal_span_(start, pos, \"unterminated double quote byte string\"));\n             }\n \n-            let ch_start = self.last_pos;\n+            let ch_start = self.pos;\n             let ch = self.curr.unwrap();\n             self.bump();\n             valid &= self.scan_char_or_byte(ch_start,\n@@ -1582,7 +1582,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n-        let start_bpos = self.last_pos;\n+        let start_bpos = self.pos;\n         self.bump();\n         let mut hash_count = 0;\n         while self.curr_is('#') {\n@@ -1591,28 +1591,28 @@ impl<'a> StringReader<'a> {\n         }\n \n         if self.is_eof() {\n-            let last_pos = self.last_pos;\n-            panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"));\n+            let pos = self.pos;\n+            panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"));\n         } else if !self.curr_is('\"') {\n-            let last_pos = self.last_pos;\n+            let pos = self.pos;\n             let ch = self.curr.unwrap();\n             panic!(self.fatal_span_char(start_bpos,\n-                                        last_pos,\n+                                        pos,\n                                         \"found invalid character; only `#` is allowed in raw \\\n                                          string delimitation\",\n                                         ch));\n         }\n         self.bump();\n-        let content_start_bpos = self.last_pos;\n+        let content_start_bpos = self.pos;\n         let mut content_end_bpos;\n         'outer: loop {\n             match self.curr {\n                 None => {\n-                    let last_pos = self.last_pos;\n-                    panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"))\n+                    let pos = self.pos;\n+                    panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"))\n                 }\n                 Some('\"') => {\n-                    content_end_bpos = self.last_pos;\n+                    content_end_bpos = self.pos;\n                     for _ in 0..hash_count {\n                         self.bump();\n                         if !self.curr_is('#') {\n@@ -1623,8 +1623,8 @@ impl<'a> StringReader<'a> {\n                 }\n                 Some(c) => {\n                     if c > '\\x7F' {\n-                        let last_pos = self.last_pos;\n-                        self.err_span_char(last_pos, last_pos, \"raw byte string must be ASCII\", c);\n+                        let pos = self.pos;\n+                        self.err_span_char(pos, pos, \"raw byte string must be ASCII\", c);\n                     }\n                 }\n             }\n@@ -1738,7 +1738,7 @@ mod tests {\n         assert_eq!(tok1, tok2);\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n         // the 'main' id is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(28));\n+        assert_eq!(string_reader.pos.clone(), BytePos(28));\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n@@ -1751,7 +1751,7 @@ mod tests {\n         };\n         assert_eq!(tok3, tok4);\n         // the lparen is already read:\n-        assert_eq!(string_reader.last_pos.clone(), BytePos(29))\n+        assert_eq!(string_reader.pos.clone(), BytePos(29))\n     }\n \n     // check that the given reader produces the desired stream"}, {"sha": "1e08b20b7e1f4cca71ca043772d0537939af62e5", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb92f5c6d6e09a7c1575241a05df15c96ca3b531/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "patch": "@@ -234,7 +234,7 @@ pub fn check_for_substitution<'a>(reader: &StringReader<'a>,\n     .iter()\n     .find(|&&(c, _, _)| c == ch)\n     .map(|&(_, u_name, ascii_char)| {\n-        let span = make_span(reader.last_pos, reader.next_pos);\n+        let span = make_span(reader.pos, reader.next_pos);\n         match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n             Some(&(ascii_char, ascii_name)) => {\n                 let msg ="}]}