{"sha": "756880a5f5e5df2474a9770d27fa3751b0be4916", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Njg4MGE1ZjVlNWRmMjQ3NGE5NzcwZDI3ZmEzNzUxYjBiZTQ5MTY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-24T22:42:01Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-24T22:42:01Z"}, "message": "rustc: Parse simple patterns", "tree": {"sha": "a3afab0a271b5d9e10dba1f876ac262f1c6671f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3afab0a271b5d9e10dba1f876ac262f1c6671f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/756880a5f5e5df2474a9770d27fa3751b0be4916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/756880a5f5e5df2474a9770d27fa3751b0be4916", "html_url": "https://github.com/rust-lang/rust/commit/756880a5f5e5df2474a9770d27fa3751b0be4916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/756880a5f5e5df2474a9770d27fa3751b0be4916/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d72dae1d13fdbe6275d732aac7dd9a9ad604b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d72dae1d13fdbe6275d732aac7dd9a9ad604b6f", "html_url": "https://github.com/rust-lang/rust/commit/5d72dae1d13fdbe6275d732aac7dd9a9ad604b6f"}], "stats": {"total": 87, "additions": 87, "deletions": 0}, "files": [{"sha": "954440dd866ac62b14b2a77c19f87b12254b5a55", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/756880a5f5e5df2474a9770d27fa3751b0be4916/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756880a5f5e5df2474a9770d27fa3751b0be4916/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=756880a5f5e5df2474a9770d27fa3751b0be4916", "patch": "@@ -39,6 +39,15 @@ type block = spanned[block_];\n type block_ = rec(vec[@stmt] stmts,\n                   hashmap[ident,uint] index);\n \n+type pat = spanned[pat_];\n+tag pat_ {\n+    pat_wild;\n+    pat_bind(ident);\n+    pat_tag(ident, vec[@pat]);\n+}\n+\n+type arm = rec(@pat pat, block block);\n+\n tag binop {\n     add;\n     sub;\n@@ -104,6 +113,7 @@ tag expr_ {\n     expr_if(@expr, block, option.t[block], ann);\n     expr_while(@expr, block, ann);\n     expr_do_while(block, @expr, ann);\n+    expr_alt(@expr, vec[arm], ann);\n     expr_block(block, ann);\n     expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);"}, {"sha": "16c6ed1175161d905f6816849cf97eaf0b061ba1", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/756880a5f5e5df2474a9770d27fa3751b0be4916/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/756880a5f5e5df2474a9770d27fa3751b0be4916/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=756880a5f5e5df2474a9770d27fa3751b0be4916", "patch": "@@ -745,6 +745,38 @@ impure fn parse_do_while_expr(parser p) -> @ast.expr {\n     ret @spanned(lo, hi, ast.expr_do_while(body, cond, ast.ann_none));\n }\n \n+impure fn parse_alt_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    expect(p, token.ALT);\n+    expect(p, token.LPAREN);\n+    auto discriminant = parse_expr(p);\n+    expect(p, token.RPAREN);\n+    expect(p, token.LBRACE);\n+\n+    let vec[ast.arm] arms = vec();\n+    while (p.peek() != token.RBRACE) {\n+        alt (p.peek()) {\n+            case (token.CASE) {\n+                p.bump();\n+                expect(p, token.LPAREN);\n+                auto pat = parse_pat(p);\n+                expect(p, token.RPAREN);\n+                auto block = parse_block(p);\n+                arms += vec(rec(pat=pat, block=block));\n+            }\n+            case (token.RBRACE) { /* empty */ }\n+            case (?tok) {\n+                p.err(\"expected 'case' or '}' when parsing 'alt' statement \" +\n+                      \"but found \" + token.to_str(tok));\n+            }\n+        }\n+    }\n+\n+    auto expr = ast.expr_alt(discriminant, arms, ast.ann_none);\n+    auto hi = p.get_span();\n+    ret @spanned(lo, hi, expr);\n+}\n+\n impure fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n@@ -761,6 +793,9 @@ impure fn parse_expr(parser p) -> @ast.expr {\n         case (token.DO) {\n             ret parse_do_while_expr(p);\n         }\n+        case (token.ALT) {\n+            ret parse_alt_expr(p);\n+        }\n         case (_) {\n             ret parse_assign_expr(p);\n         }\n@@ -777,6 +812,48 @@ impure fn parse_initializer(parser p) -> option.t[@ast.expr] {\n     ret none[@ast.expr];\n }\n \n+impure fn parse_pat(parser p) -> @ast.pat {\n+    auto lo = p.get_span();\n+\n+    auto pat = ast.pat_wild;    // FIXME: typestate bug\n+    alt (p.peek()) {\n+        case (token.UNDERSCORE) { p.bump(); pat = ast.pat_wild; }\n+        case (token.QUES) {\n+            p.bump();\n+            alt (p.peek()) {\n+                case (token.IDENT(?id)) { p.bump(); pat = ast.pat_bind(id); }\n+                case (?tok) {\n+                    p.err(\"expected identifier after '?' in pattern but \" +\n+                          \"found \" + token.to_str(tok));\n+                    fail;\n+                }\n+            }\n+        }\n+        case (token.IDENT(?id)) {\n+            p.bump();\n+\n+            let vec[@ast.pat] args;\n+            alt (p.peek()) {\n+                case (token.LPAREN) {\n+                    auto f = parse_pat;\n+                    args = parse_seq[@ast.pat](token.LPAREN, token.RPAREN,\n+                                               some(token.COMMA), f, p).node;\n+                }\n+                case (_) { args = vec(); }\n+            }\n+\n+            pat = ast.pat_tag(id, args);\n+        }\n+        case (?tok) {\n+            p.err(\"expected pattern but found \" + token.to_str(tok));\n+            fail;\n+        }\n+    }\n+\n+    auto hi = p.get_span();\n+    ret @spanned(lo, hi, pat);\n+}\n+\n impure fn parse_let(parser p) -> @ast.decl {\n     auto lo = p.get_span();\n "}]}