{"sha": "30a5448d256b17e1924401f705d22f5313cb59ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYTU0NDhkMjU2YjE3ZTE5MjQ0MDFmNzA1ZDIyZjUzMTNjYjU5ZWQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-04-30T17:35:10Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-04-30T17:35:10Z"}, "message": "address review comments", "tree": {"sha": "ad23653abe1caf778432393af67c4768772cf61e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad23653abe1caf778432393af67c4768772cf61e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30a5448d256b17e1924401f705d22f5313cb59ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30a5448d256b17e1924401f705d22f5313cb59ed", "html_url": "https://github.com/rust-lang/rust/commit/30a5448d256b17e1924401f705d22f5313cb59ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30a5448d256b17e1924401f705d22f5313cb59ed/comments", "author": null, "committer": null, "parents": [{"sha": "7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ae4a8e9f3150f62964151ef54b3da3cd24ee123", "html_url": "https://github.com/rust-lang/rust/commit/7ae4a8e9f3150f62964151ef54b3da3cd24ee123"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "49371eae2652d78c00c0860daa73f53b3d56109a", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=30a5448d256b17e1924401f705d22f5313cb59ed", "patch": "@@ -1157,7 +1157,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         def.for_each_relevant_impl(\n             self.tcx(),\n-            obligation.predicate.0.trait_ref,\n+            obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n                 self.infcx.probe(|snapshot| {\n                     if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {"}, {"sha": "b9867425c35e2c7454f5f594e77e21ef42cf9198", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=30a5448d256b17e1924401f705d22f5313cb59ed", "patch": "@@ -2522,6 +2522,11 @@ pub struct TraitDef<'tcx> {\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<ast::Name>,\n \n+    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n+    // by a simplified version of their Self type: impls with a simplifiable\n+    // Self are stored in nonblanket_impls keyed by it, while all other impls\n+    // are stored in blanket_impls.\n+\n     /// Impls of the trait.\n     pub nonblanket_impls: RefCell<\n         FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n@@ -2530,6 +2535,7 @@ pub struct TraitDef<'tcx> {\n     /// Blanket impls associated with the trait.\n     pub blanket_impls: RefCell<Vec<DefId>>,\n \n+    /// Various flags\n     pub flags: Cell<TraitFlags>\n }\n \n@@ -2544,6 +2550,7 @@ impl<'tcx> TraitDef<'tcx> {\n     }\n \n     pub fn set_object_safety(&self, is_safe: bool) {\n+        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n         self.flags.set(\n             self.flags.get() | if is_safe {\n                 TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n@@ -2563,14 +2570,18 @@ impl<'tcx> TraitDef<'tcx> {\n \n         if let Some(sty) = fast_reject::simplify_type(tcx,\n                                                       impl_trait_ref.self_ty(), false) {\n-            if !self.nonblanket_impls.borrow().get(&sty).map(\n-                    |s| s.contains(&impl_def_id)).unwrap_or(false) {\n-                self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n+                if is.contains(&impl_def_id) {\n+                    return // duplicate - skip\n+                }\n             }\n+\n+            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n         } else {\n-            if !self.blanket_impls.borrow().contains(&impl_def_id) {\n-                self.blanket_impls.borrow_mut().push(impl_def_id)\n+            if self.blanket_impls.borrow().contains(&impl_def_id) {\n+                return // duplicate - skip\n             }\n+            self.blanket_impls.borrow_mut().push(impl_def_id)\n         }\n     }\n \n@@ -2591,7 +2602,7 @@ impl<'tcx> TraitDef<'tcx> {\n \n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n                                                    tcx: &ctxt<'tcx>,\n-                                                   trait_ref: TraitRef<'tcx>,\n+                                                   self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n         ty::populate_implementations_for_trait_if_necessary(tcx, self.trait_ref.def_id);\n@@ -2600,14 +2611,12 @@ impl<'tcx> TraitDef<'tcx> {\n             f(impl_def_id);\n         }\n \n-        if let Some(self_ty) = trait_ref.substs.self_ty() {\n-            if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n-                if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                    for &impl_def_id in impls {\n-                        f(impl_def_id);\n-                    }\n+        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, false) {\n+            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n+                for &impl_def_id in impls {\n+                    f(impl_def_id);\n                 }\n-                return; // don't process all non-blanket impls\n+                return; // we don't need to process the other non-blanket impls\n             }\n         }\n "}, {"sha": "46cce54301168b0cc256a297e656e510e6b42a99", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30a5448d256b17e1924401f705d22f5313cb59ed/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=30a5448d256b17e1924401f705d22f5313cb59ed", "patch": "@@ -134,7 +134,8 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                               impl2_def_id: ast::DefId)\n     {\n         if let Some((impl1_def_id, impl2_def_id)) = self.order_impls(\n-            impl1_def_id, impl2_def_id) {\n+            impl1_def_id, impl2_def_id)\n+        {\n             debug!(\"check_if_impls_overlap({}, {}, {})\",\n                    trait_def_id.repr(self.tcx),\n                    impl1_def_id.repr(self.tcx),"}]}