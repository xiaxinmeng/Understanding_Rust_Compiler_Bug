{"sha": "7e1992a0d9004d9bdbb2a73942789831e9554dba", "node_id": "C_kwDOAAsO6NoAKDdlMTk5MmEwZDkwMDRkOWJkYmIyYTczOTQyNzg5ODMxZTk1NTRkYmE", "commit": {"author": {"name": "Ariel Davis", "email": "ariel.z.davis@icloud.com", "date": "2023-05-04T02:18:41Z"}, "committer": {"name": "Ariel Davis", "email": "ariel.z.davis@icloud.com", "date": "2023-05-06T07:49:23Z"}, "message": "Make line-index an external lib", "tree": {"sha": "a50fd06549a4632fc56c1ed9319f74bc5611f658", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a50fd06549a4632fc56c1ed9319f74bc5611f658"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e1992a0d9004d9bdbb2a73942789831e9554dba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1992a0d9004d9bdbb2a73942789831e9554dba", "html_url": "https://github.com/rust-lang/rust/commit/7e1992a0d9004d9bdbb2a73942789831e9554dba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e1992a0d9004d9bdbb2a73942789831e9554dba/comments", "author": {"login": "azdavis", "id": 6496454, "node_id": "MDQ6VXNlcjY0OTY0NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6496454?v=4", "gravatar_id": "", "url": "https://api.github.com/users/azdavis", "html_url": "https://github.com/azdavis", "followers_url": "https://api.github.com/users/azdavis/followers", "following_url": "https://api.github.com/users/azdavis/following{/other_user}", "gists_url": "https://api.github.com/users/azdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/azdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/azdavis/subscriptions", "organizations_url": "https://api.github.com/users/azdavis/orgs", "repos_url": "https://api.github.com/users/azdavis/repos", "events_url": "https://api.github.com/users/azdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/azdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "azdavis", "id": 6496454, "node_id": "MDQ6VXNlcjY0OTY0NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6496454?v=4", "gravatar_id": "", "url": "https://api.github.com/users/azdavis", "html_url": "https://github.com/azdavis", "followers_url": "https://api.github.com/users/azdavis/followers", "following_url": "https://api.github.com/users/azdavis/following{/other_user}", "gists_url": "https://api.github.com/users/azdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/azdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/azdavis/subscriptions", "organizations_url": "https://api.github.com/users/azdavis/orgs", "repos_url": "https://api.github.com/users/azdavis/repos", "events_url": "https://api.github.com/users/azdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/azdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29256f22e4fb8db8558885e5eeeac5595c428031", "url": "https://api.github.com/repos/rust-lang/rust/commits/29256f22e4fb8db8558885e5eeeac5595c428031", "html_url": "https://github.com/rust-lang/rust/commit/29256f22e4fb8db8558885e5eeeac5595c428031"}], "stats": {"total": 319, "additions": 177, "deletions": 142}, "files": [{"sha": "8fc4680e21e2380c1f15c6c39ec9e6d63cd35bb0", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -717,6 +717,7 @@ dependencies = [\n  \"indexmap\",\n  \"itertools\",\n  \"limit\",\n+ \"line-index\",\n  \"memchr\",\n  \"once_cell\",\n  \"oorandom\",\n@@ -912,6 +913,14 @@ dependencies = [\n name = \"limit\"\n version = \"0.0.0\"\n \n+[[package]]\n+name = \"line-index\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"non-hash\",\n+ \"text-size\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.4.9\""}, {"sha": "022eb7859ce23658825c2ab6db9f9c94c6b9b027", "filename": "crates/ide-db/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2FCargo.toml?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -37,6 +37,9 @@ text-edit.workspace = true\n # something from some `hir-xxx` subpackage, reexport the API via `hir`.\n hir.workspace = true\n \n+# used to be a module, turned into its own library\n+line-index = { version = \"0.1.0\", path = \"../../lib/line-index\" }\n+\n [dev-dependencies]\n expect-test = \"1.4.0\"\n oorandom = \"11.1.3\""}, {"sha": "ff1a20f03f44cb24a094e3b8bf6b6e025541fa8c", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -13,7 +13,6 @@ pub mod famous_defs;\n pub mod helpers;\n pub mod items_locator;\n pub mod label;\n-pub mod line_index;\n pub mod path_transform;\n pub mod rename;\n pub mod rust_doc;\n@@ -55,6 +54,8 @@ use triomphe::Arc;\n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n pub use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n \n+pub use ::line_index;\n+\n /// `base_db` is normally also needed in places where `ide_db` is used, so this re-export is for convenience.\n pub use base_db;\n \n@@ -414,4 +415,5 @@ impl SnippetCap {\n #[cfg(test)]\n mod tests {\n     mod sourcegen_lints;\n+    mod line_index;\n }"}, {"sha": "c12936071d371f758b5e694e6b2d43e6afccb766", "filename": "crates/ide-db/src/tests/line_index.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftests%2Fline_index.rs?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -0,0 +1,54 @@\n+use line_index::{LineCol, LineIndex, WideEncoding};\n+use test_utils::skip_slow_tests;\n+\n+#[test]\n+fn test_every_chars() {\n+    if skip_slow_tests() {\n+        return;\n+    }\n+\n+    let text: String = {\n+        let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n+        chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n+        let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+        stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n+        chars.into_iter().collect()\n+    };\n+    assert!(text.contains('\ud83d\udca9')); // Sanity check.\n+\n+    let line_index = LineIndex::new(&text);\n+\n+    let mut lin_col = LineCol { line: 0, col: 0 };\n+    let mut col_utf16 = 0;\n+    let mut col_utf32 = 0;\n+    for (offset, c) in text.char_indices() {\n+        let got_offset = line_index.offset(lin_col).unwrap();\n+        assert_eq!(usize::from(got_offset), offset);\n+\n+        let got_lin_col = line_index.line_col(got_offset);\n+        assert_eq!(got_lin_col, lin_col);\n+\n+        for enc in [WideEncoding::Utf16, WideEncoding::Utf32] {\n+            let wide_lin_col = line_index.to_wide(enc, lin_col);\n+            let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n+            assert_eq!(got_lin_col, lin_col);\n+\n+            let want_col = match enc {\n+                WideEncoding::Utf16 => col_utf16,\n+                WideEncoding::Utf32 => col_utf32,\n+            };\n+            assert_eq!(wide_lin_col.col, want_col)\n+        }\n+\n+        if c == '\\n' {\n+            lin_col.line += 1;\n+            lin_col.col = 0;\n+            col_utf16 = 0;\n+            col_utf32 = 0;\n+        } else {\n+            lin_col.col += c.len_utf8() as u32;\n+            col_utf16 += c.len_utf16() as u32;\n+            col_utf32 += 1;\n+        }\n+    }\n+}"}, {"sha": "0abc539e892ef6cdb96c0d7e75b0ddba1bf889e5", "filename": "lib/line-index/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2FCargo.toml?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+name = \"line-index\"\n+version = \"0.1.0\"\n+description = \"Maps flat `TextSize` offsets into `(line, column)` representation.\"\n+license = \"MIT OR Apache-2.0\"\n+repository = \"https://github.com/rust-lang/rust-analyzer/tree/master/lib/non-hash\"\n+edition = \"2021\"\n+\n+[dependencies]\n+text-size = \"1\"\n+non-hash = { version = \"0.1.0\", path = \"../non-hash\" }"}, {"sha": "af01eafc281a7710e246933023941117a0938703", "filename": "lib/line-index/src/lib.rs", "status": "renamed", "additions": 24, "deletions": 141, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2Fsrc%2Flib.rs?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -1,10 +1,16 @@\n-//! `LineIndex` maps flat `TextSize` offsets into `(Line, Column)`\n-//! representation.\n+//! See [`LineIndex`].\n+\n+#![deny(clippy::pedantic, missing_debug_implementations, missing_docs, rust_2018_idioms)]\n+\n+#[cfg(test)]\n+mod tests;\n+\n use std::{iter, mem};\n \n-use stdx::hash::NoHashHashMap;\n-use syntax::{TextRange, TextSize};\n+use non_hash::NoHashHashMap;\n+use text_size::{TextRange, TextSize};\n \n+/// Maps flat [`TextSize`] offsets into `(line, column)` representation.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n     /// Offset the beginning of each line, zero-based.\n@@ -16,26 +22,29 @@ pub struct LineIndex {\n /// Line/Column information in native, utf8 format.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct LineCol {\n-    /// Zero-based\n+    /// Zero-based.\n     pub line: u32,\n-    /// Zero-based utf8 offset\n+    /// Zero-based UTF-8 offset.\n     pub col: u32,\n }\n \n+/// A kind of wide character encoding.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum WideEncoding {\n+    /// UTF-16.\n     Utf16,\n+    /// UTF-32.\n     Utf32,\n }\n \n /// Line/Column information in legacy encodings.\n ///\n-/// Deliberately not a generic type and different from `LineCol`.\n+/// Deliberately not a generic type and different from [`LineCol`].\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct WideLineCol {\n-    /// Zero-based\n+    /// Zero-based.\n     pub line: u32,\n-    /// Zero-based\n+    /// Zero-based.\n     pub col: u32,\n }\n \n@@ -70,6 +79,7 @@ impl WideChar {\n }\n \n impl LineIndex {\n+    /// Returns a `LineIndex` for the `text`.\n     pub fn new(text: &str) -> LineIndex {\n         let mut line_wide_chars = NoHashHashMap::default();\n         let mut wide_chars = Vec::new();\n@@ -115,29 +125,34 @@ impl LineIndex {\n         LineIndex { newlines, line_wide_chars }\n     }\n \n+    /// Transforms the `TextSize` into a `LineCol`.\n     pub fn line_col(&self, offset: TextSize) -> LineCol {\n         let line = self.newlines.partition_point(|&it| it <= offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n         LineCol { line: line as u32, col: col.into() }\n     }\n \n+    /// Transforms the `LineCol` into a `TextSize`.\n     pub fn offset(&self, line_col: LineCol) -> Option<TextSize> {\n         self.newlines\n             .get(line_col.line as usize)\n             .map(|offset| offset + TextSize::from(line_col.col))\n     }\n \n+    /// Transforms the `LineCol` with the given `WideEncoding` into a `WideLineCol`.\n     pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> WideLineCol {\n         let col = self.utf8_to_wide_col(enc, line_col.line, line_col.col.into());\n         WideLineCol { line: line_col.line, col: col as u32 }\n     }\n \n+    /// Transforms the `WideLineCol` with the given `WideEncoding` into a `LineCol`.\n     pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> LineCol {\n         let col = self.wide_to_utf8_col(enc, line_col.line, line_col.col);\n         LineCol { line: line_col.line, col: col.into() }\n     }\n \n+    /// Returns an iterator over the ranges for the lines.\n     pub fn lines(&self, range: TextRange) -> impl Iterator<Item = TextRange> + '_ {\n         let lo = self.newlines.partition_point(|&it| it < range.start());\n         let hi = self.newlines.partition_point(|&it| it <= range.end());\n@@ -183,135 +198,3 @@ impl LineIndex {\n         col.into()\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use test_utils::skip_slow_tests;\n-\n-    use super::WideEncoding::{Utf16, Utf32};\n-    use super::*;\n-\n-    #[test]\n-    fn test_line_index() {\n-        let text = \"hello\\nworld\";\n-        let table = [\n-            (00, 0, 0),\n-            (01, 0, 1),\n-            (05, 0, 5),\n-            (06, 1, 0),\n-            (07, 1, 1),\n-            (08, 1, 2),\n-            (10, 1, 4),\n-            (11, 1, 5),\n-            (12, 1, 6),\n-        ];\n-\n-        let index = LineIndex::new(text);\n-        for (offset, line, col) in table {\n-            assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n-        }\n-\n-        let text = \"\\nhello\\nworld\";\n-        let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n-        let index = LineIndex::new(text);\n-        for (offset, line, col) in table {\n-            assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n-        }\n-    }\n-\n-    #[test]\n-    fn test_char_len() {\n-        assert_eq!('\u30e1'.len_utf8(), 3);\n-        assert_eq!('\u30e1'.len_utf16(), 1);\n-    }\n-\n-    #[test]\n-    fn test_empty_index() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = 'x';\n-\",\n-        );\n-        assert_eq!(col_index.line_wide_chars.len(), 0);\n-    }\n-\n-    #[test]\n-    fn test_every_chars() {\n-        if skip_slow_tests() {\n-            return;\n-        }\n-\n-        let text: String = {\n-            let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n-            chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n-            let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n-            stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n-            chars.into_iter().collect()\n-        };\n-        assert!(text.contains('\ud83d\udca9')); // Sanity check.\n-\n-        let line_index = LineIndex::new(&text);\n-\n-        let mut lin_col = LineCol { line: 0, col: 0 };\n-        let mut col_utf16 = 0;\n-        let mut col_utf32 = 0;\n-        for (offset, c) in text.char_indices() {\n-            let got_offset = line_index.offset(lin_col).unwrap();\n-            assert_eq!(usize::from(got_offset), offset);\n-\n-            let got_lin_col = line_index.line_col(got_offset);\n-            assert_eq!(got_lin_col, lin_col);\n-\n-            for enc in [Utf16, Utf32] {\n-                let wide_lin_col = line_index.to_wide(enc, lin_col);\n-                let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n-                assert_eq!(got_lin_col, lin_col);\n-\n-                let want_col = match enc {\n-                    Utf16 => col_utf16,\n-                    Utf32 => col_utf32,\n-                };\n-                assert_eq!(wide_lin_col.col, want_col)\n-            }\n-\n-            if c == '\\n' {\n-                lin_col.line += 1;\n-                lin_col.col = 0;\n-                col_utf16 = 0;\n-                col_utf32 = 0;\n-            } else {\n-                lin_col.col += c.len_utf8() as u32;\n-                col_utf16 += c.len_utf16() as u32;\n-                col_utf32 += 1;\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_splitlines() {\n-        fn r(lo: u32, hi: u32) -> TextRange {\n-            TextRange::new(lo.into(), hi.into())\n-        }\n-\n-        let text = \"a\\nbb\\nccc\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n-        let expected = vec![];\n-        assert_eq!(actual, expected);\n-\n-        let text = \"\\n\";\n-        let line_index = LineIndex::new(text);\n-\n-        let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n-        let expected = vec![r(0, 1)];\n-        assert_eq!(actual, expected)\n-    }\n-}", "previous_filename": "crates/ide-db/src/line_index.rs"}, {"sha": "4b58cfc47dd834b683909857733a64f644f55abf", "filename": "lib/line-index/src/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1992a0d9004d9bdbb2a73942789831e9554dba/lib%2Fline-index%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fline-index%2Fsrc%2Ftests.rs?ref=7e1992a0d9004d9bdbb2a73942789831e9554dba", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+#[test]\n+fn test_line_index() {\n+    let text = \"hello\\nworld\";\n+    let table = [\n+        (00, 0, 0),\n+        (01, 0, 1),\n+        (05, 0, 5),\n+        (06, 1, 0),\n+        (07, 1, 1),\n+        (08, 1, 2),\n+        (10, 1, 4),\n+        (11, 1, 5),\n+        (12, 1, 6),\n+    ];\n+\n+    let index = LineIndex::new(text);\n+    for (offset, line, col) in table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n+\n+    let text = \"\\nhello\\nworld\";\n+    let table = [(0, 0, 0), (1, 1, 0), (2, 1, 1), (6, 1, 5), (7, 2, 0)];\n+    let index = LineIndex::new(text);\n+    for (offset, line, col) in table {\n+        assert_eq!(index.line_col(offset.into()), LineCol { line, col });\n+    }\n+}\n+\n+#[test]\n+fn test_char_len() {\n+    assert_eq!('\u30e1'.len_utf8(), 3);\n+    assert_eq!('\u30e1'.len_utf16(), 1);\n+}\n+\n+#[test]\n+fn test_empty_index() {\n+    let col_index = LineIndex::new(\n+        \"\n+const C: char = 'x';\n+\",\n+    );\n+    assert_eq!(col_index.line_wide_chars.len(), 0);\n+}\n+\n+#[test]\n+fn test_splitlines() {\n+    fn r(lo: u32, hi: u32) -> TextRange {\n+        TextRange::new(lo.into(), hi.into())\n+    }\n+\n+    let text = \"a\\nbb\\nccc\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 9)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 2), r(2, 5), r(5, 9)];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 0)).collect::<Vec<_>>();\n+    let expected = vec![];\n+    assert_eq!(actual, expected);\n+\n+    let text = \"\\n\";\n+    let line_index = LineIndex::new(text);\n+\n+    let actual = line_index.lines(r(0, 1)).collect::<Vec<_>>();\n+    let expected = vec![r(0, 1)];\n+    assert_eq!(actual, expected)\n+}"}]}