{"sha": "fe69dde96be4b7afcef4975e825d385b23b51799", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNjlkZGU5NmJlNGI3YWZjZWY0OTc1ZTgyNWQzODViMjNiNTE3OTk=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-10-05T11:50:19Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-10-05T11:50:19Z"}, "message": "Replace 'try_opt!' macro with a '?' operator", "tree": {"sha": "0f3fbd50eeaf537753c313df938e7edc3141c40e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f3fbd50eeaf537753c313df938e7edc3141c40e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe69dde96be4b7afcef4975e825d385b23b51799", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe69dde96be4b7afcef4975e825d385b23b51799", "html_url": "https://github.com/rust-lang/rust/commit/fe69dde96be4b7afcef4975e825d385b23b51799", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe69dde96be4b7afcef4975e825d385b23b51799/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ab2b5f5e3ebb3bdcd07c8de12d2604ce2981a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ab2b5f5e3ebb3bdcd07c8de12d2604ce2981a2", "html_url": "https://github.com/rust-lang/rust/commit/69ab2b5f5e3ebb3bdcd07c8de12d2604ce2981a2"}], "stats": {"total": 1133, "additions": 457, "deletions": 676}, "files": [{"sha": "74c43d783b7c9f9b6f231f6e8acef3d6d553f318", "filename": "src/chains.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -110,11 +110,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else {\n         shape\n     };\n-    let parent_rewrite = try_opt!(\n-        parent\n-            .rewrite(context, parent_shape)\n-            .map(|parent_rw| parent_rw + &repeat_try(prefix_try_num))\n-    );\n+    let parent_rewrite = parent\n+        .rewrite(context, parent_shape)\n+        .map(|parent_rw| parent_rw + &repeat_try(prefix_try_num))?;\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = parent_rewrite.len() <= context.config.tab_spaces();\n \n@@ -146,8 +144,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         let overhead = last_line_width(&parent_rewrite);\n         let offset = parent_rewrite.lines().rev().next().unwrap().trim().len();\n         match context.config.chain_indent() {\n-            IndentStyle::Visual => try_opt!(parent_shape.offset_left(overhead)),\n-            IndentStyle::Block => try_opt!(parent_shape.block().offset_left(offset)),\n+            IndentStyle::Visual => parent_shape.offset_left(overhead)?,\n+            IndentStyle::Block => parent_shape.block().offset_left(offset)?,\n         }\n     } else {\n         other_child_shape\n@@ -165,11 +163,9 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let last_subexpr = &subexpr_list[suffix_try_num];\n     let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n     let iter = subexpr_list.iter().skip(1).rev().zip(child_shape_iter);\n-    let mut rewrites = try_opt!(\n-        iter.map(|(e, shape)| {\n-            rewrite_chain_subexpr(e, total_span, context, shape)\n-        }).collect::<Option<Vec<_>>>()\n-    );\n+    let mut rewrites = iter.map(|(e, shape)| {\n+        rewrite_chain_subexpr(e, total_span, context, shape)\n+    }).collect::<Option<Vec<_>>>()?;\n \n     // Total of all items excluding the last.\n     let extend_last_subexr = last_line_extendable(&parent_rewrite) && rewrites.is_empty();\n@@ -187,7 +183,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         && rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n     let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, nested_shape);\n-    let (last_subexpr_str, fits_single_line) = try_opt!(if all_in_one_line || extend_last_subexr {\n+    let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexr {\n         parent_shape.offset_left(almost_total).map(|shape| {\n             if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n                 let line_count = rw.lines().count();\n@@ -207,11 +203,11 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             } else {\n                 (rewrite_last(), false)\n             }\n-        })\n+        })?\n     } else {\n-        Some((rewrite_last(), false))\n-    });\n-    rewrites.push(try_opt!(last_subexpr_str));\n+        (rewrite_last(), false)\n+    };\n+    rewrites.push(last_subexpr_str?);\n \n     let connector = if fits_single_line && !parent_rewrite_contains_newline {\n         // Yay, we can put everything on one line.\n@@ -288,7 +284,7 @@ fn rewrite_try(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n+    let sub_expr = expr.rewrite(context, shape.sub_width(try_count)?)?;\n     Some(format!(\"{}{}\", sub_expr, repeat_try(try_count)))\n }\n \n@@ -472,8 +468,10 @@ fn rewrite_method_call(\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi(), String::new())\n     } else {\n-        let type_list: Vec<_> =\n-            try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n+        let type_list = types\n+            .iter()\n+            .map(|ty| ty.rewrite(context, shape))\n+            .collect::<Option<Vec<_>>>()?;\n \n         let type_str = if context.config.spaces_within_angle_brackets() && !type_list.is_empty() {\n             format!(\"::< {} >\", type_list.join(\", \"))"}, {"sha": "f966d658dc8a092bffe0f112979876843ad669b8", "filename": "src/comment.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -152,7 +152,7 @@ pub fn combine_strs_with_missing_comments(\n         last_line_width(prev_str) + first_line_width(next_str) + first_sep.len();\n \n     let indent_str = shape.indent.to_string(context.config);\n-    let missing_comment = try_opt!(rewrite_missing_comment(span, shape, context));\n+    let missing_comment = rewrite_missing_comment(span, shape, context)?;\n \n     if missing_comment.is_empty() {\n         if allow_extend && prev_str.len() + first_sep.len() + next_str.len() <= shape.width {\n@@ -254,13 +254,7 @@ fn identify_comment(\n         .collect::<Vec<_>>()\n         .join(\"\\n\");\n \n-    let first_group_str = try_opt!(rewrite_comment_inner(\n-        &first_group,\n-        block_style,\n-        style,\n-        shape,\n-        config,\n-    ));\n+    let first_group_str = rewrite_comment_inner(&first_group, block_style, style, shape, config)?;\n     if rest.is_empty() {\n         Some(first_group_str)\n     } else {\n@@ -380,7 +374,7 @@ pub fn recover_missing_comment_in_span(\n     context: &RewriteContext,\n     used_width: usize,\n ) -> Option<String> {\n-    let missing_comment = try_opt!(rewrite_missing_comment(span, shape, context));\n+    let missing_comment = rewrite_missing_comment(span, shape, context)?;\n     if missing_comment.is_empty() {\n         Some(String::new())\n     } else {\n@@ -610,7 +604,7 @@ where\n     type Item = (FullCodeCharKind, T::Item);\n \n     fn next(&mut self) -> Option<(FullCodeCharKind, T::Item)> {\n-        let item = try_opt!(self.base.next());\n+        let item = self.base.next()?;\n         let chr = item.get_char();\n         self.status = match self.status {\n             CharClassesStatus::LitString => match chr {\n@@ -705,7 +699,7 @@ impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n     type Item = (CodeCharKind, usize, &'a str);\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let (kind, (start_idx, _)) = try_opt!(self.iter.next());\n+        let (kind, (start_idx, _)) = self.iter.next()?;\n         match kind {\n             FullCodeCharKind::Normal => {\n                 // Consume all the Normal code\n@@ -886,14 +880,14 @@ impl<'a> Iterator for CommentReducer<'a> {\n     type Item = char;\n     fn next(&mut self) -> Option<Self::Item> {\n         loop {\n-            let mut c = try_opt!(self.iter.next());\n+            let mut c = self.iter.next()?;\n             if self.is_block && self.at_start_line {\n                 while c.is_whitespace() {\n-                    c = try_opt!(self.iter.next());\n+                    c = self.iter.next()?;\n                 }\n                 // Ignore leading '*'\n                 if c == '*' {\n-                    c = try_opt!(self.iter.next());\n+                    c = self.iter.next()?;\n                 }\n             } else if c == '\\n' {\n                 self.at_start_line = true;"}, {"sha": "083aee5a225184e2d123bd7bf5c517d75781930c", "filename": "src/expr.rs", "status": "modified", "additions": 121, "deletions": 183, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -75,7 +75,7 @@ pub fn format_expr(\n         ast::ExprKind::Lit(ref l) => rewrite_literal(context, l, shape),\n         ast::ExprKind::Call(ref callee, ref args) => {\n             let inner_span = mk_sp(callee.span.hi(), expr.span.hi());\n-            let callee_str = try_opt!(callee.rewrite(context, shape));\n+            let callee_str = callee.rewrite(context, shape)?;\n             rewrite_call(context, &callee_str, &args, inner_span, shape)\n         }\n         ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape),\n@@ -120,7 +120,7 @@ pub fn format_expr(\n                         // Rewrite block without trying to put it in a single line.\n                         rw\n                     } else {\n-                        let prefix = try_opt!(block_prefix(context, block, shape));\n+                        let prefix = block_prefix(context, block, shape)?;\n                         rewrite_block_with_visitor(context, &prefix, block, shape)\n                     }\n                 }\n@@ -295,7 +295,7 @@ pub fn format_expr(\n                 Some(format!(\n                     \"{}{}\",\n                     \"do catch \",\n-                    try_opt!(block.rewrite(context, Shape::legacy(budget, shape.indent)))\n+                    block.rewrite(context, Shape::legacy(budget, shape.indent))?\n                 ))\n             }\n         }\n@@ -307,7 +307,7 @@ pub fn format_expr(\n         })\n         .and_then(|expr_str| {\n             let attrs = outer_attributes(&expr.attrs);\n-            let attrs_str = try_opt!(attrs.rewrite(context, shape));\n+            let attrs_str = attrs.rewrite(context, shape)?;\n             let span = mk_sp(\n                 attrs.last().map_or(expr.span.lo(), |attr| attr.span.hi()),\n                 expr.span.lo(),\n@@ -338,10 +338,8 @@ where\n         width: context.budget(lhs_overhead),\n         ..shape\n     };\n-    let lhs_result = try_opt!(\n-        lhs.rewrite(context, lhs_shape)\n-            .map(|lhs_str| format!(\"{}{}\", prefix, lhs_str))\n-    );\n+    let lhs_result = lhs.rewrite(context, lhs_shape)\n+        .map(|lhs_str| format!(\"{}{}\", prefix, lhs_str))?;\n \n     // Try to the both lhs and rhs on the same line.\n     let rhs_orig_result = shape\n@@ -367,25 +365,25 @@ where\n \n     // We have to use multiple lines.\n     // Re-evaluate the rhs because we have more space now:\n-    let mut rhs_shape = try_opt!(match context.config.control_style() {\n+    let mut rhs_shape = match context.config.control_style() {\n         Style::Legacy => shape\n-            .sub_width(suffix.len() + prefix.len())\n-            .map(|s| s.visual_indent(prefix.len())),\n+            .sub_width(suffix.len() + prefix.len())?\n+            .visual_indent(prefix.len()),\n         Style::Rfc => {\n             // Try to calculate the initial constraint on the right hand side.\n             let rhs_overhead = shape.rhs_overhead(context.config);\n             Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                .sub_width(rhs_overhead)\n+                .sub_width(rhs_overhead)?\n         }\n-    });\n+    };\n     let infix = match separator_place {\n         SeparatorPlace::Back => infix.trim_right(),\n         SeparatorPlace::Front => infix.trim_left(),\n     };\n     if separator_place == SeparatorPlace::Front {\n-        rhs_shape = try_opt!(rhs_shape.offset_left(infix.len()));\n+        rhs_shape = rhs_shape.offset_left(infix.len())?;\n     }\n-    let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n+    let rhs_result = rhs.rewrite(context, rhs_shape)?;\n     match separator_place {\n         SeparatorPlace::Back => Some(format!(\n             \"{}{}\\n{}{}{}\",\n@@ -423,18 +421,14 @@ where\n     };\n \n     let nested_shape = match context.config.array_layout() {\n-        IndentStyle::Block => try_opt!(\n-            shape\n-                .block()\n-                .block_indent(context.config.tab_spaces())\n-                .with_max_width(context.config)\n-                .sub_width(1)\n-        ),\n-        IndentStyle::Visual => try_opt!(\n-            shape\n-                .visual_indent(bracket_size)\n-                .sub_width(bracket_size * 2)\n-        ),\n+        IndentStyle::Block => shape\n+            .block()\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+            .sub_width(1)?,\n+        IndentStyle::Visual => shape\n+            .visual_indent(bracket_size)\n+            .sub_width(bracket_size * 2)?,\n     };\n \n     let items = itemize_list(\n@@ -507,7 +501,7 @@ where\n         preserve_newline: false,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&items, &fmt));\n+    let list_str = write_list(&items, &fmt)?;\n \n     let result = if context.config.array_layout() == IndentStyle::Visual\n         || tactic == DefinitiveListTactic::Horizontal\n@@ -545,12 +539,12 @@ fn rewrite_closure_fn_decl(\n     };\n     // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n     // a single expression.\n-    let nested_shape = try_opt!(try_opt!(shape.shrink_left(mover.len())).sub_width(4));\n+    let nested_shape = shape.shrink_left(mover.len())?.sub_width(4)?;\n \n     // 1 = |\n     let argument_offset = nested_shape.indent + 1;\n-    let arg_shape = try_opt!(nested_shape.offset_left(1)).visual_indent(0);\n-    let ret_str = try_opt!(fn_decl.output.rewrite(context, arg_shape));\n+    let arg_shape = nested_shape.offset_left(1)?.visual_indent(0);\n+    let ret_str = fn_decl.output.rewrite(context, arg_shape)?;\n \n     let arg_items = itemize_list(\n         context.codemap,\n@@ -576,7 +570,7 @@ fn rewrite_closure_fn_decl(\n         horizontal_budget,\n     );\n     let arg_shape = match tactic {\n-        DefinitiveListTactic::Horizontal => try_opt!(arg_shape.sub_width(ret_str.len() + 1)),\n+        DefinitiveListTactic::Horizontal => arg_shape.sub_width(ret_str.len() + 1)?,\n         _ => arg_shape,\n     };\n \n@@ -590,7 +584,7 @@ fn rewrite_closure_fn_decl(\n         preserve_newline: true,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&item_vec, &fmt));\n+    let list_str = write_list(&item_vec, &fmt)?;\n     let mut prefix = format!(\"{}|{}|\", mover, list_str);\n     // 1 = space between `|...|` and body.\n     let extra_offset = extra_offset(&prefix, shape) + 1;\n@@ -625,16 +619,10 @@ fn rewrite_closure(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let (prefix, extra_offset) = try_opt!(rewrite_closure_fn_decl(\n-        capture,\n-        fn_decl,\n-        body,\n-        span,\n-        context,\n-        shape,\n-    ));\n+    let (prefix, extra_offset) =\n+        rewrite_closure_fn_decl(capture, fn_decl, body, span, context, shape)?;\n     // 1 = space between `|...|` and body.\n-    let body_shape = try_opt!(shape.offset_left(extra_offset));\n+    let body_shape = shape.offset_left(extra_offset)?;\n \n     if let ast::ExprKind::Block(ref block) = body.node {\n         // The body of the closure is an empty block.\n@@ -741,7 +729,7 @@ fn rewrite_closure_block(\n     // The body of the closure is big enough to be block indented, that\n     // means we must re-format.\n     let block_shape = shape.block();\n-    let block_str = try_opt!(block.rewrite(context, block_shape));\n+    let block_str = block.rewrite(context, block_shape)?;\n     Some(format!(\"{} {}\", prefix, block_str))\n }\n \n@@ -791,21 +779,21 @@ fn block_prefix(context: &RewriteContext, block: &ast::Block, shape: Shape) -> O\n     Some(match block.rules {\n         ast::BlockCheckMode::Unsafe(..) => {\n             let snippet = context.snippet(block.span);\n-            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            let open_pos = snippet.find_uncommented(\"{\")?;\n             // Extract comment between unsafe and block start.\n             let trimmed = &snippet[6..open_pos].trim();\n \n             if !trimmed.is_empty() {\n                 // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n-                let budget = try_opt!(shape.width.checked_sub(9));\n+                let budget = shape.width.checked_sub(9)?;\n                 format!(\n                     \"unsafe {} \",\n-                    try_opt!(rewrite_comment(\n+                    rewrite_comment(\n                         trimmed,\n                         true,\n                         Shape::legacy(budget, shape.indent + 7),\n                         context.config,\n-                    ))\n+                    )?\n                 )\n             } else {\n                 \"unsafe \".to_owned()\n@@ -823,7 +811,7 @@ fn rewrite_single_line_block(\n ) -> Option<String> {\n     if is_simple_block(block, context.codemap) {\n         let expr_shape = Shape::legacy(shape.width - prefix.len(), shape.indent);\n-        let expr_str = try_opt!(block.stmts[0].rewrite(context, expr_shape));\n+        let expr_str = block.stmts[0].rewrite(context, expr_shape)?;\n         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n         if result.len() <= shape.width && !result.contains('\\n') {\n             return Some(result);\n@@ -848,7 +836,7 @@ fn rewrite_block_with_visitor(\n     match block.rules {\n         ast::BlockCheckMode::Unsafe(..) => {\n             let snippet = context.snippet(block.span);\n-            let open_pos = try_opt!(snippet.find_uncommented(\"{\"));\n+            let open_pos = snippet.find_uncommented(\"{\")?;\n             visitor.last_pos = block.span.lo() + BytePos(open_pos as u32)\n         }\n         ast::BlockCheckMode::Default => visitor.last_pos = block.span.lo(),\n@@ -866,7 +854,7 @@ impl Rewrite for ast::Block {\n             return rw;\n         }\n \n-        let prefix = try_opt!(block_prefix(context, self, shape));\n+        let prefix = block_prefix(context, self, shape)?;\n \n         let result = rewrite_block_with_visitor(context, &prefix, self, shape);\n         if let Some(ref result_str) = result {\n@@ -894,7 +882,7 @@ impl Rewrite for ast::Stmt {\n                     \"\"\n                 };\n \n-                let shape = try_opt!(shape.sub_width(suffix.len()));\n+                let shape = shape.sub_width(suffix.len())?;\n                 format_expr(ex, ExprType::Statement, context, shape).map(|s| s + suffix)\n             }\n             ast::StmtKind::Mac(..) | ast::StmtKind::Item(..) => None,\n@@ -909,8 +897,8 @@ fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Opt\n         ast::ExprKind::Match(ref cond, _) => {\n             // `match `cond` {`\n             let cond_shape = match context.config.control_style() {\n-                Style::Legacy => try_opt!(shape.shrink_left(6).and_then(|s| s.sub_width(2))),\n-                Style::Rfc => try_opt!(shape.offset_left(8)),\n+                Style::Legacy => shape.shrink_left(6).and_then(|s| s.sub_width(2))?,\n+                Style::Rfc => shape.offset_left(8)?,\n             };\n             cond.rewrite(context, cond_shape)\n         }\n@@ -1084,7 +1072,7 @@ impl<'a> ControlFlow<'a> {\n         width: usize,\n     ) -> Option<String> {\n         assert!(self.allow_single_line);\n-        let else_block = try_opt!(self.else_block);\n+        let else_block = self.else_block?;\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node) = else_block.node {\n@@ -1095,14 +1083,13 @@ impl<'a> ControlFlow<'a> {\n                 return None;\n             }\n \n-            let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n+            let new_width = width.checked_sub(pat_expr_str.len() + fixed_cost)?;\n             let expr = &self.block.stmts[0];\n-            let if_str = try_opt!(expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n+            let if_str = expr.rewrite(context, Shape::legacy(new_width, Indent::empty()))?;\n \n-            let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n+            let new_width = new_width.checked_sub(if_str.len())?;\n             let else_expr = &else_node.stmts[0];\n-            let else_str =\n-                try_opt!(else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty())));\n+            let else_str = else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty()))?;\n \n             if if_str.contains('\\n') || else_str.contains('\\n') {\n                 return None;\n@@ -1146,7 +1133,7 @@ impl<'a> ControlFlow<'a> {\n         let constr_shape = if self.nested_if {\n             // We are part of an if-elseif-else chain. Our constraints are tightened.\n             // 7 = \"} else \" .len()\n-            try_opt!(fresh_shape.offset_left(7))\n+            fresh_shape.offset_left(7)?\n         } else {\n             fresh_shape\n         };\n@@ -1158,18 +1145,18 @@ impl<'a> ControlFlow<'a> {\n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n                 let cond_shape = match context.config.control_style() {\n-                    Style::Legacy => try_opt!(constr_shape.shrink_left(offset)),\n-                    Style::Rfc => try_opt!(constr_shape.offset_left(offset)),\n+                    Style::Legacy => constr_shape.shrink_left(offset)?,\n+                    Style::Rfc => constr_shape.offset_left(offset)?,\n                 };\n-                try_opt!(rewrite_pat_expr(\n+                rewrite_pat_expr(\n                     context,\n                     self.pat,\n                     cond,\n                     self.matcher,\n                     self.connector,\n                     self.keyword,\n                     cond_shape,\n-                ))\n+                )?\n             }\n             None => String::new(),\n         };\n@@ -1271,7 +1258,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n         let alt_block_sep =\n             String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-        let (cond_str, used_width) = try_opt!(self.rewrite_cond(context, shape, &alt_block_sep));\n+        let (cond_str, used_width) = self.rewrite_cond(context, shape, &alt_block_sep)?;\n         // If `used_width` is 0, it indicates that whole control flow is written in a single line.\n         if used_width == 0 {\n             return Some(cond_str);\n@@ -1291,12 +1278,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         };\n         let mut block_context = context.clone();\n         block_context.is_if_else_block = self.else_block.is_some();\n-        let block_str = try_opt!(rewrite_block_with_visitor(\n-            &block_context,\n-            \"\",\n-            self.block,\n-            block_shape,\n-        ));\n+        let block_str = rewrite_block_with_visitor(&block_context, \"\", self.block, block_shape)?;\n \n         let mut result = format!(\"{}{}\", cond_str, block_str);\n \n@@ -1369,17 +1351,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n                 _ => \" \",\n             };\n-            try_opt!(\n-                write!(\n-                    &mut result,\n-                    \"{}else{}\",\n-                    between_kwd_else_block_comment\n-                        .as_ref()\n-                        .map_or(between_sep, |s| &**s),\n-                    after_else_comment.as_ref().map_or(after_sep, |s| &**s)\n-                ).ok()\n-            );\n-            result.push_str(&try_opt!(rewrite));\n+            write!(\n+                &mut result,\n+                \"{}else{}\",\n+                between_kwd_else_block_comment\n+                    .as_ref()\n+                    .map_or(between_sep, |s| &**s),\n+                after_else_comment.as_ref().map_or(after_sep, |s| &**s)\n+            ).ok()?;\n+            result.push_str(&rewrite?);\n         }\n \n         Some(result)\n@@ -1476,17 +1456,17 @@ fn rewrite_match(\n \n     // Do not take the rhs overhead from the upper expressions into account\n     // when rewriting match condition.\n-    let new_width = try_opt!(context.config.max_width().checked_sub(shape.used_width()));\n+    let new_width = context.config.max_width().checked_sub(shape.used_width())?;\n     let cond_shape = Shape {\n         width: new_width,\n         ..shape\n     };\n     // 6 = `match `\n     let cond_shape = match context.config.control_style() {\n-        Style::Legacy => try_opt!(cond_shape.shrink_left(6)),\n-        Style::Rfc => try_opt!(cond_shape.offset_left(6)),\n+        Style::Legacy => cond_shape.shrink_left(6)?,\n+        Style::Rfc => cond_shape.offset_left(6)?,\n     };\n-    let cond_str = try_opt!(cond.rewrite(context, cond_shape));\n+    let cond_str = cond.rewrite(context, cond_shape)?;\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n     let block_sep = match context.config.control_brace_style() {\n         ControlBraceStyle::AlwaysNextLine => &alt_block_sep,\n@@ -1505,11 +1485,9 @@ fn rewrite_match(\n     let inner_attrs_str = if inner_attrs.is_empty() {\n         String::new()\n     } else {\n-        try_opt!(\n-            inner_attrs\n-                .rewrite(context, shape)\n-                .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))\n-        )\n+        inner_attrs\n+            .rewrite(context, shape)\n+            .map(|s| format!(\"{}{}\\n\", nested_indent_str, s))?\n     };\n \n     let open_brace_pos = if inner_attrs.is_empty() {\n@@ -1532,13 +1510,7 @@ fn rewrite_match(\n         block_sep,\n         inner_attrs_str,\n         arm_indent_str,\n-        try_opt!(rewrite_match_arms(\n-            context,\n-            arms,\n-            shape,\n-            span,\n-            open_brace_pos,\n-        )),\n+        rewrite_match_arms(context, arms, shape, span, open_brace_pos,)?,\n         shape.indent.to_string(context.config),\n     ))\n }\n@@ -1626,12 +1598,12 @@ fn rewrite_match_arm(\n                 arm.attrs[arm.attrs.len() - 1].span.hi(),\n                 arm.pats[0].span.lo(),\n             ),\n-            try_opt!(arm.attrs.rewrite(context, shape)),\n+            arm.attrs.rewrite(context, shape)?,\n         )\n     } else {\n         (mk_sp(arm.span().lo(), arm.span().lo()), String::new())\n     };\n-    let pats_str = try_opt!(\n+    let pats_str =\n         rewrite_match_pattern(context, &arm.pats, &arm.guard, shape).and_then(|pats_str| {\n             combine_strs_with_missing_comments(\n                 context,\n@@ -1641,8 +1613,7 @@ fn rewrite_match_arm(\n                 shape,\n                 false,\n             )\n-        })\n-    );\n+        })?;\n     rewrite_match_body(\n         context,\n         &arm.body,\n@@ -1661,13 +1632,11 @@ fn rewrite_match_pattern(\n ) -> Option<String> {\n     // Patterns\n     // 5 = ` => {`\n-    let pat_shape = try_opt!(shape.sub_width(5));\n+    let pat_shape = shape.sub_width(5)?;\n \n-    let pat_strs = try_opt!(\n-        pats.iter()\n-            .map(|p| p.rewrite(context, pat_shape))\n-            .collect::<Option<Vec<_>>>()\n-    );\n+    let pat_strs = pats.iter()\n+        .map(|p| p.rewrite(context, pat_shape))\n+        .collect::<Option<Vec<_>>>()?;\n \n     let items: Vec<_> = pat_strs.into_iter().map(ListItem::from_str).collect();\n     let tactic = definitive_tactic(\n@@ -1686,15 +1655,10 @@ fn rewrite_match_pattern(\n         preserve_newline: false,\n         config: context.config,\n     };\n-    let pats_str = try_opt!(write_list(&items, &fmt));\n+    let pats_str = write_list(&items, &fmt)?;\n \n     // Guard\n-    let guard_str = try_opt!(rewrite_guard(\n-        context,\n-        guard,\n-        shape,\n-        trimmed_last_line_width(&pats_str),\n-    ));\n+    let guard_str = rewrite_guard(context, guard, shape, trimmed_last_line_width(&pats_str))?;\n \n     Some(format!(\"{}{}\", pats_str, guard_str))\n }\n@@ -1910,9 +1874,8 @@ fn rewrite_pat_expr(\n         } else {\n             format!(\"{} \", matcher)\n         };\n-        let pat_shape =\n-            try_opt!(try_opt!(shape.offset_left(matcher.len())).sub_width(connector.len()));\n-        let pat_string = try_opt!(pat.rewrite(context, pat_shape));\n+        let pat_shape = shape.offset_left(matcher.len())?.sub_width(connector.len())?;\n+        let pat_string = pat.rewrite(context, pat_shape)?;\n         let result = format!(\"{}{}{}\", matcher, pat_string, connector);\n         return rewrite_assign_rhs(context, result, expr, shape);\n     }\n@@ -2047,27 +2010,27 @@ where\n         1\n     };\n     let used_width = extra_offset(callee_str, shape);\n-    let one_line_width = try_opt!(shape.width.checked_sub(used_width + 2 * paren_overhead));\n+    let one_line_width = shape.width.checked_sub(used_width + 2 * paren_overhead)?;\n \n-    let nested_shape = try_opt!(shape_from_fn_call_style(\n+    let nested_shape = shape_from_fn_call_style(\n         context,\n         shape,\n         used_width + 2 * paren_overhead,\n         used_width + paren_overhead,\n-    ));\n+    )?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n     let args_span = mk_sp(span_lo, span.hi());\n \n-    let (extendable, list_str) = try_opt!(rewrite_call_args(\n+    let (extendable, list_str) = rewrite_call_args(\n         context,\n         args,\n         args_span,\n         nested_shape,\n         one_line_width,\n         args_max_width,\n         force_trailing_comma,\n-    ));\n+    )?;\n \n     if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n         let mut new_context = context.clone();\n@@ -2083,7 +2046,7 @@ where\n         );\n     }\n \n-    let args_shape = try_opt!(shape.sub_width(last_line_width(callee_str)));\n+    let args_shape = shape.sub_width(last_line_width(callee_str))?;\n     Some(format!(\n         \"{}{}\",\n         callee_str,\n@@ -2242,7 +2205,7 @@ fn last_arg_shape(\n         shape.block().indent\n     };\n     Some(Shape {\n-        width: try_opt!(max_width.checked_sub(overhead)),\n+        width: max_width.checked_sub(overhead)?,\n         indent: arg_indent,\n         offset: 0,\n     })\n@@ -2262,19 +2225,13 @@ fn rewrite_last_closure(\n             }\n             _ => body,\n         };\n-        let (prefix, extra_offset) = try_opt!(rewrite_closure_fn_decl(\n-            capture,\n-            fn_decl,\n-            body,\n-            expr.span,\n-            context,\n-            shape,\n-        ));\n+        let (prefix, extra_offset) =\n+            rewrite_closure_fn_decl(capture, fn_decl, body, expr.span, context, shape)?;\n         // If the closure goes multi line before its body, do not overflow the closure.\n         if prefix.contains('\\n') {\n             return None;\n         }\n-        let body_shape = try_opt!(shape.offset_left(extra_offset));\n+        let body_shape = shape.offset_left(extra_offset)?;\n         // When overflowing the closure which consists of a single control flow expression,\n         // force to use block if its condition uses multi line.\n         let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n@@ -2414,19 +2371,17 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     debug!(\"rewrite_paren, shape: {:?}\", shape);\n     let total_paren_overhead = paren_overhead(context);\n     let paren_overhead = total_paren_overhead / 2;\n-    let sub_shape = try_opt!(\n-        shape\n-            .offset_left(paren_overhead)\n-            .and_then(|s| s.sub_width(paren_overhead))\n-    );\n+    let sub_shape = shape\n+        .offset_left(paren_overhead)\n+        .and_then(|s| s.sub_width(paren_overhead))?;\n \n     let paren_wrapper = |s: &str| if context.config.spaces_within_parens() && !s.is_empty() {\n         format!(\"( {} )\", s)\n     } else {\n         format!(\"({})\", s)\n     };\n \n-    let subexpr_str = try_opt!(subexpr.rewrite(context, sub_shape));\n+    let subexpr_str = subexpr.rewrite(context, sub_shape)?;\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n     if subexpr_str.contains('\\n')\n@@ -2444,7 +2399,7 @@ fn rewrite_index(\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n-    let expr_str = try_opt!(expr.rewrite(context, shape));\n+    let expr_str = expr.rewrite(context, shape)?;\n \n     let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n         (\"[ \", \" ]\")\n@@ -2473,8 +2428,8 @@ fn rewrite_index(\n \n     // Try putting index on the next line and see if it fits in a single line.\n     let indent = shape.indent.block_indent(context.config);\n-    let index_shape = try_opt!(Shape::indented(indent, context.config).offset_left(lbr.len()));\n-    let index_shape = try_opt!(index_shape.sub_width(rbr.len() + rhs_overhead));\n+    let index_shape = Shape::indented(indent, context.config).offset_left(lbr.len())?;\n+    let index_shape = index_shape.sub_width(rbr.len() + rhs_overhead)?;\n     let new_index_rw = index.rewrite(context, index_shape);\n     match (orig_index_rw, new_index_rw) {\n         (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n@@ -2522,34 +2477,28 @@ fn rewrite_struct_lit<'a>(\n     }\n \n     // 2 = \" {\".len()\n-    let path_shape = try_opt!(shape.sub_width(2));\n-    let path_str = try_opt!(rewrite_path(\n-        context,\n-        PathContext::Expr,\n-        None,\n-        path,\n-        path_shape,\n-    ));\n+    let path_shape = shape.sub_width(2)?;\n+    let path_str = rewrite_path(context, PathContext::Expr, None, path, path_shape)?;\n \n     if fields.is_empty() && base.is_none() {\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n-    let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));\n+    let (h_shape, v_shape) = struct_lit_shape(shape, context, path_str.len() + 3, 2)?;\n \n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n     let body_lo = context.codemap.span_after(span, \"{\");\n     let fields_str = if struct_lit_can_be_aligned(fields, &base)\n         && context.config.struct_field_align_threshold() > 0\n     {\n-        try_opt!(rewrite_with_alignment(\n+        rewrite_with_alignment(\n             fields,\n             context,\n             shape,\n             mk_sp(body_lo, span.hi()),\n             one_line_width,\n-        ))\n+        )?\n     } else {\n         let field_iter = fields\n             .into_iter()\n@@ -2572,11 +2521,11 @@ fn rewrite_struct_lit<'a>(\n         let rewrite = |item: &StructLitField| match *item {\n             StructLitField::Regular(field) => {\n                 // The 1 taken from the v_budget is for the comma.\n-                rewrite_field(context, field, try_opt!(v_shape.sub_width(1)), 0)\n+                rewrite_field(context, field, v_shape.sub_width(1)?, 0)\n             }\n             StructLitField::Base(expr) => {\n                 // 2 = ..\n-                expr.rewrite(context, try_opt!(v_shape.offset_left(2)))\n+                expr.rewrite(context, v_shape.offset_left(2)?)\n                     .map(|s| format!(\"..{}\", s))\n             }\n         };\n@@ -2598,7 +2547,7 @@ fn rewrite_struct_lit<'a>(\n         let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n         let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n \n-        try_opt!(write_list(&item_vec, &fmt))\n+        write_list(&item_vec, &fmt)?\n     };\n \n     let fields_str = wrap_struct_field(context, &fields_str, shape, v_shape, one_line_width);\n@@ -2657,10 +2606,10 @@ pub fn rewrite_field(\n             separator.push(' ');\n         }\n         let overhead = name.len() + separator.len();\n-        let expr_shape = try_opt!(shape.offset_left(overhead));\n+        let expr_shape = shape.offset_left(overhead)?;\n         let expr = field.expr.rewrite(context, expr_shape);\n \n-        let mut attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n+        let mut attrs_str = field.attrs.rewrite(context, shape)?;\n         if !attrs_str.is_empty() {\n             attrs_str.push_str(&format!(\"\\n{}\", shape.indent.to_string(context.config)));\n         };\n@@ -2718,7 +2667,7 @@ where\n     debug!(\"rewrite_tuple_in_visual_indent_style {:?}\", shape);\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n-        let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n+        let nested_shape = shape.sub_width(3)?.visual_indent(1);\n         return items.next().unwrap().rewrite(context, nested_shape).map(\n             |s| if context.config.spaces_within_parens() {\n                 format!(\"( {}, )\", s)\n@@ -2729,7 +2678,7 @@ where\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");\n-    let nested_shape = try_opt!(shape.sub_width(2)).visual_indent(1);\n+    let nested_shape = shape.sub_width(2)?.visual_indent(1);\n     let items = itemize_list(\n         context.codemap,\n         items,\n@@ -2758,7 +2707,7 @@ where\n         preserve_newline: false,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&item_vec, &fmt));\n+    let list_str = write_list(&item_vec, &fmt)?;\n \n     if context.config.spaces_within_parens() && !list_str.is_empty() {\n         Some(format!(\"( {} )\", list_str))\n@@ -2805,7 +2754,7 @@ pub fn rewrite_unary_prefix<R: Rewrite>(\n     shape: Shape,\n ) -> Option<String> {\n     rewrite\n-        .rewrite(context, try_opt!(shape.offset_left(prefix.len())))\n+        .rewrite(context, shape.offset_left(prefix.len())?)\n         .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n@@ -2818,7 +2767,7 @@ pub fn rewrite_unary_suffix<R: Rewrite>(\n     shape: Shape,\n ) -> Option<String> {\n     rewrite\n-        .rewrite(context, try_opt!(shape.sub_width(suffix.len())))\n+        .rewrite(context, shape.sub_width(suffix.len())?)\n         .map(|mut r| {\n             r.push_str(suffix);\n             r\n@@ -2853,12 +2802,8 @@ fn rewrite_assignment(\n     };\n \n     // 1 = space between lhs and operator.\n-    let lhs_shape = try_opt!(shape.sub_width(operator_str.len() + 1));\n-    let lhs_str = format!(\n-        \"{} {}\",\n-        try_opt!(lhs.rewrite(context, lhs_shape)),\n-        operator_str\n-    );\n+    let lhs_shape = shape.sub_width(operator_str.len() + 1)?;\n+    let lhs_str = format!(\"{} {}\", lhs.rewrite(context, lhs_shape)?, operator_str);\n \n     rewrite_assign_rhs(context, lhs_str, rhs, shape)\n }\n@@ -2878,13 +2823,8 @@ pub fn rewrite_assign_rhs<S: Into<String>>(\n         0\n     };\n     // 1 = space between operator and rhs.\n-    let orig_shape = try_opt!(shape.offset_left(last_line_width + 1));\n-    let rhs = try_opt!(choose_rhs(\n-        context,\n-        ex,\n-        orig_shape,\n-        ex.rewrite(context, orig_shape)\n-    ));\n+    let orig_shape = shape.offset_left(last_line_width + 1)?;\n+    let rhs = choose_rhs(context, ex, orig_shape, ex.rewrite(context, orig_shape))?;\n     Some(lhs + &rhs)\n }\n \n@@ -2901,12 +2841,10 @@ fn choose_rhs(\n         _ => {\n             // Expression did not fit on the same line as the identifier.\n             // Try splitting the line and see if that works better.\n-            let new_shape = try_opt!(\n-                Shape::indented(\n-                    shape.block().indent.block_indent(context.config),\n-                    context.config,\n-                ).sub_width(shape.rhs_overhead(context.config))\n-            );\n+            let new_shape = Shape::indented(\n+                shape.block().indent.block_indent(context.config),\n+                context.config,\n+            ).sub_width(shape.rhs_overhead(context.config))?;\n             let new_rhs = expr.rewrite(context, new_shape);\n             let new_indent_str = &new_shape.indent.to_string(context.config);\n "}, {"sha": "68c3ec32897c62eaa7c74e5d6ff0817b5c63e3aa", "filename": "src/imports.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -140,21 +140,9 @@ fn rewrite_view_path_prefix(\n             span: path.span,\n             segments: path.segments[..path.segments.len() - 1].to_owned(),\n         };\n-        try_opt!(rewrite_path(\n-            context,\n-            PathContext::Import,\n-            None,\n-            path,\n-            shape,\n-        ))\n+        rewrite_path(context, PathContext::Import, None, path, shape)?\n     } else {\n-        try_opt!(rewrite_path(\n-            context,\n-            PathContext::Import,\n-            None,\n-            path,\n-            shape,\n-        ))\n+        rewrite_path(context, PathContext::Import, None, path, shape)?\n     };\n     Some(path_str)\n }\n@@ -167,15 +155,15 @@ impl Rewrite for ast::ViewPath {\n             }\n             ast::ViewPath_::ViewPathGlob(ref path) => {\n                 // 4 = \"::*\".len()\n-                let prefix_shape = try_opt!(shape.sub_width(3));\n-                let path_str = try_opt!(rewrite_view_path_prefix(path, context, prefix_shape));\n+                let prefix_shape = shape.sub_width(3)?;\n+                let path_str = rewrite_view_path_prefix(path, context, prefix_shape)?;\n                 Some(format!(\"{}::*\", path_str))\n             }\n             ast::ViewPath_::ViewPathSimple(ident, ref path) => {\n                 let ident_str = ident.to_string();\n                 // 4 = \" as \".len()\n-                let prefix_shape = try_opt!(shape.sub_width(ident_str.len() + 4));\n-                let path_str = try_opt!(rewrite_view_path_prefix(path, context, prefix_shape));\n+                let prefix_shape = shape.sub_width(ident_str.len() + 4)?;\n+                let path_str = rewrite_view_path_prefix(path, context, prefix_shape)?;\n \n                 Some(if path.segments.last().unwrap().identifier == ident {\n                     path_str\n@@ -228,7 +216,7 @@ fn rewrite_imports(\n         |item| item.span().lo(),\n         |item| item.span().hi(),\n         |item| {\n-            let attrs_str = try_opt!(item.attrs.rewrite(context, shape));\n+            let attrs_str = item.attrs.rewrite(context, shape)?;\n \n             let missed_span = if item.attrs.is_empty() {\n                 mk_sp(item.span.lo(), item.span.lo())\n@@ -238,9 +226,9 @@ fn rewrite_imports(\n \n             let item_str = match item.node {\n                 ast::ItemKind::Use(ref vp) => {\n-                    try_opt!(rewrite_import(context, &item.vis, vp, &item.attrs, shape))\n+                    rewrite_import(context, &item.vis, vp, &item.attrs, shape)?\n                 }\n-                ast::ItemKind::ExternCrate(..) => try_opt!(rewrite_extern_crate(context, item)),\n+                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n                 _ => return None,\n             };\n \n@@ -428,13 +416,7 @@ fn rewrite_use_list(\n     context: &RewriteContext,\n ) -> Option<String> {\n     // Returns a different option to distinguish `::foo` and `foo`\n-    let path_str = try_opt!(rewrite_path(\n-        context,\n-        PathContext::Import,\n-        None,\n-        path,\n-        shape,\n-    ));\n+    let path_str = rewrite_path(context, PathContext::Import, None, path, shape)?;\n \n     match path_list.len() {\n         0 => {\n@@ -521,7 +503,7 @@ fn rewrite_use_list(\n         preserve_newline: true,\n         config: context.config,\n     };\n-    let list_str = try_opt!(write_list(&items[first_index..], &fmt));\n+    let list_str = write_list(&items[first_index..], &fmt)?;\n \n     let result = if list_str.contains('\\n') && context.config.imports_indent() == IndentStyle::Block\n     {"}, {"sha": "e2580bea8de825dab7d2b2234902d0da687ba0ac", "filename": "src/items.rs", "status": "modified", "additions": 133, "deletions": 189, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -62,11 +62,11 @@ impl Rewrite for ast::Local {\n             return None;\n         }\n \n-        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        let attrs_str = self.attrs.rewrite(context, shape)?;\n         let mut result = if attrs_str.is_empty() {\n             \"let \".to_owned()\n         } else {\n-            try_opt!(combine_strs_with_missing_comments(\n+            combine_strs_with_missing_comments(\n                 context,\n                 &attrs_str,\n                 \"let \",\n@@ -76,14 +76,14 @@ impl Rewrite for ast::Local {\n                 ),\n                 shape,\n                 false,\n-            ))\n+            )?\n         };\n \n         // 4 = \"let \".len()\n-        let pat_shape = try_opt!(shape.offset_left(4));\n+        let pat_shape = shape.offset_left(4)?;\n         // 1 = ;\n-        let pat_shape = try_opt!(pat_shape.sub_width(1));\n-        let pat_str = try_opt!(self.pat.rewrite(context, pat_shape));\n+        let pat_shape = pat_shape.sub_width(1)?;\n+        let pat_str = self.pat.rewrite(context, pat_shape)?;\n         result.push_str(&pat_str);\n \n         // String that is placed within the assignment pattern and expression.\n@@ -94,8 +94,8 @@ impl Rewrite for ast::Local {\n                 let separator = type_annotation_separator(context.config);\n                 let indent = shape.indent + last_line_width(&result) + separator.len();\n                 // 1 = ;\n-                let budget = try_opt!(shape.width.checked_sub(indent.width() + 1));\n-                let rewrite = try_opt!(ty.rewrite(context, Shape::legacy(budget, indent)));\n+                let budget = shape.width.checked_sub(indent.width() + 1)?;\n+                let rewrite = ty.rewrite(context, Shape::legacy(budget, indent))?;\n \n                 infix.push_str(separator);\n                 infix.push_str(&rewrite);\n@@ -112,9 +112,9 @@ impl Rewrite for ast::Local {\n \n         if let Some(ref ex) = self.init {\n             // 1 = trailing semicolon;\n-            let nested_shape = try_opt!(shape.sub_width(1));\n+            let nested_shape = shape.sub_width(1)?;\n \n-            result = try_opt!(rewrite_assign_rhs(context, result, ex, nested_shape));\n+            result = rewrite_assign_rhs(context, result, ex, nested_shape)?;\n         }\n \n         result.push(';');\n@@ -306,15 +306,8 @@ impl<'a> FmtVisitor<'a> {\n         let mut newline_brace =\n             newline_for_brace(self.config, &fn_sig.generics.where_clause, has_body);\n \n-        let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(\n-            &context,\n-            indent,\n-            ident,\n-            fn_sig,\n-            span,\n-            newline_brace,\n-            true,\n-        ));\n+        let (mut result, force_newline_brace) =\n+            rewrite_fn_base(&context, indent, ident, fn_sig, span, newline_brace, true)?;\n \n         if self.config.fn_brace_style() == BraceStyle::AlwaysNextLine || force_newline_brace {\n             newline_brace = true;\n@@ -351,15 +344,15 @@ impl<'a> FmtVisitor<'a> {\n         let span = mk_sp(span.lo(), span.hi() - BytePos(1));\n         let context = self.get_context();\n \n-        let (mut result, _) = try_opt!(rewrite_fn_base(\n+        let (mut result, _) = rewrite_fn_base(\n             &context,\n             indent,\n             ident,\n             &FnSig::from_method_sig(sig),\n             span,\n             false,\n             false,\n-        ));\n+        )?;\n \n         // Re-attach semicolon\n         result.push(';');\n@@ -503,7 +496,7 @@ impl<'a> FmtVisitor<'a> {\n             config: self.config,\n         };\n \n-        let list = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+        let list = write_list(&items.collect::<Vec<_>>(), &fmt)?;\n         result.push_str(&list);\n         result.push('\\n');\n         Some(result)\n@@ -520,7 +513,7 @@ impl<'a> FmtVisitor<'a> {\n         let context = self.get_context();\n         let indent = self.block_indent;\n         let shape = self.shape();\n-        let attrs_str = try_opt!(field.node.attrs.rewrite(&context, shape));\n+        let attrs_str = field.node.attrs.rewrite(&context, shape)?;\n         let lo = field\n             .node\n             .attrs\n@@ -531,7 +524,7 @@ impl<'a> FmtVisitor<'a> {\n         let variant_body = match field.node.data {\n             ast::VariantData::Tuple(..) | ast::VariantData::Struct(..) => {\n                 // FIXME: Should limit the width, as we have a trailing comma\n-                try_opt!(format_struct(\n+                format_struct(\n                     &context,\n                     \"\",\n                     field.node.name,\n@@ -541,7 +534,7 @@ impl<'a> FmtVisitor<'a> {\n                     field.span,\n                     indent,\n                     Some(self.config.struct_variant_width()),\n-                ))\n+                )?\n             }\n             ast::VariantData::Unit(..) => if let Some(ref expr) = field.node.disr_expr {\n                 let one_line_width =\n@@ -586,7 +579,7 @@ pub fn format_impl(\n ) -> Option<String> {\n     if let ast::ItemKind::Impl(_, _, _, ref generics, _, ref self_ty, ref items) = item.node {\n         let mut result = String::with_capacity(128);\n-        let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n+        let ref_and_type = format_impl_ref_and_type(context, item, offset)?;\n         let indent_str = offset.to_string(context.config);\n         let sep = format!(\"\\n{}\", &indent_str);\n         result.push_str(&ref_and_type);\n@@ -597,7 +590,7 @@ pub fn format_impl(\n             context.budget(last_line_width(&result))\n         };\n         let option = WhereClauseOption::snuggled(&ref_and_type);\n-        let where_clause_str = try_opt!(rewrite_where_clause(\n+        let where_clause_str = rewrite_where_clause(\n             context,\n             &generics.where_clause,\n             context.config.item_brace_style(),\n@@ -607,7 +600,7 @@ pub fn format_impl(\n             where_span_end,\n             self_ty.span.hi(),\n             option,\n-        ));\n+        )?;\n \n         // If there is no where clause, we may have missing comments between the trait name and\n         // the opening brace.\n@@ -627,13 +620,7 @@ pub fn format_impl(\n             }\n         }\n \n-        if try_opt!(is_impl_single_line(\n-            context,\n-            items,\n-            &result,\n-            &where_clause_str,\n-            item,\n-        )) {\n+        if is_impl_single_line(context, items, &result, &where_clause_str, item)? {\n             result.push_str(&where_clause_str);\n             if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n                 result.push_str(&format!(\"{}{{{}}}\", &sep, &sep));\n@@ -665,7 +652,7 @@ pub fn format_impl(\n         result.push('{');\n \n         let snippet = context.snippet(item.span);\n-        let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n+        let open_pos = snippet.find_uncommented(\"{\")? + 1;\n \n         if !items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n@@ -708,7 +695,7 @@ fn is_impl_single_line(\n     item: &ast::Item,\n ) -> Option<bool> {\n     let snippet = context.snippet(item.span);\n-    let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n+    let open_pos = snippet.find_uncommented(\"{\")? + 1;\n \n     Some(\n         context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n')\n@@ -744,19 +731,14 @@ fn format_impl_ref_and_type(\n             Some(ref tr) => tr.path.span.lo(),\n             None => self_ty.span.lo(),\n         };\n-        let shape = try_opt!(generics_shape_from_config(\n+        let shape = generics_shape_from_config(\n             context.config,\n             Shape::indented(offset + last_line_width(&result), context.config),\n             0,\n-        ));\n-        let one_line_budget = try_opt!(shape.width.checked_sub(last_line_width(&result) + 2));\n-        let generics_str = try_opt!(rewrite_generics_inner(\n-            context,\n-            generics,\n-            shape,\n-            one_line_budget,\n-            mk_sp(lo, hi),\n-        ));\n+        )?;\n+        let one_line_budget = shape.width.checked_sub(last_line_width(&result) + 2)?;\n+        let generics_str =\n+            rewrite_generics_inner(context, generics, shape, one_line_budget, mk_sp(lo, hi))?;\n \n         let polarity_str = if polarity == ast::ImplPolarity::Negative {\n             \"!\"\n@@ -777,22 +759,17 @@ fn format_impl_ref_and_type(\n             ) {\n                 result.push_str(&trait_ref_str);\n             } else {\n-                let generics_str = try_opt!(rewrite_generics_inner(\n-                    context,\n-                    generics,\n-                    shape,\n-                    0,\n-                    mk_sp(lo, hi),\n-                ));\n-                result.push_str(&try_opt!(rewrite_trait_ref(\n+                let generics_str =\n+                    rewrite_generics_inner(context, generics, shape, 0, mk_sp(lo, hi))?;\n+                result.push_str(&rewrite_trait_ref(\n                     context,\n                     trait_ref,\n                     offset,\n                     &generics_str,\n                     false,\n                     polarity_str,\n                     result_len,\n-                )));\n+                )?);\n             }\n         } else {\n             result.push_str(&generics_str);\n@@ -839,9 +816,8 @@ fn format_impl_ref_and_type(\n             Style::Legacy => new_line_offset + trait_ref_overhead,\n             Style::Rfc => new_line_offset,\n         };\n-        result.push_str(&*try_opt!(\n-            self_ty.rewrite(context, Shape::legacy(budget, type_offset))\n-        ));\n+        result.push_str(&*self_ty\n+            .rewrite(context, Shape::legacy(budget, type_offset))?);\n         Some(result)\n     } else {\n         unreachable!();\n@@ -874,7 +850,7 @@ fn rewrite_trait_ref(\n     if !retry {\n         let offset = offset.block_indent(context.config);\n         let shape = Shape::indented(offset, context.config);\n-        let trait_ref_str = try_opt!(trait_ref.rewrite(context, shape));\n+        let trait_ref_str = trait_ref.rewrite(context, shape)?;\n         Some(format!(\n             \"{}\\n{}{}{}\",\n             generics_str,\n@@ -941,19 +917,15 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let body_lo = context.codemap.span_after(item.span, \"{\");\n \n         let shape = Shape::indented(offset + last_line_width(&result), context.config);\n-        let generics_str = try_opt!(rewrite_generics(\n-            context,\n-            generics,\n-            shape,\n-            mk_sp(item.span.lo(), body_lo),\n-        ));\n+        let generics_str =\n+            rewrite_generics(context, generics, shape, mk_sp(item.span.lo(), body_lo))?;\n         result.push_str(&generics_str);\n \n-        let trait_bound_str = try_opt!(rewrite_trait_bounds(\n+        let trait_bound_str = rewrite_trait_bounds(\n             context,\n             type_param_bounds,\n             Shape::indented(offset, context.config),\n-        ));\n+        )?;\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n         if offset.width() + last_line_width(&result) + trait_bound_str.len()\n@@ -985,7 +957,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             type_param_bounds[type_param_bounds.len() - 1].span().hi()\n         };\n         let option = WhereClauseOption::snuggled(&generics_str);\n-        let where_clause_str = try_opt!(rewrite_where_clause(\n+        let where_clause_str = rewrite_where_clause(\n             context,\n             &generics.where_clause,\n             context.config.item_brace_style(),\n@@ -995,7 +967,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             None,\n             pos_before_where,\n             option,\n-        ));\n+        )?;\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n         if !where_clause_str.contains('\\n')\n@@ -1053,7 +1025,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         result.push('{');\n \n         let snippet = context.snippet(item.span);\n-        let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n+        let open_pos = snippet.find_uncommented(\"{\")? + 1;\n \n         if !trait_items.is_empty() || contains_comment(&snippet[open_pos..]) {\n             let mut visitor = FmtVisitor::from_codemap(context.parse_session, context.config);\n@@ -1108,7 +1080,7 @@ pub fn format_struct_struct(\n     let body_lo = context.codemap.span_after(span, \"{\");\n \n     let generics_str = match generics {\n-        Some(g) => try_opt!(format_generics(\n+        Some(g) => format_generics(\n             context,\n             g,\n             \"{\",\n@@ -1118,7 +1090,7 @@ pub fn format_struct_struct(\n             offset,\n             mk_sp(span.lo(), body_lo),\n             last_line_width(&result),\n-        )),\n+        )?,\n         None => {\n             // 3 = ` {}`, 2 = ` {`.\n             let overhead = if fields.is_empty() { 3 } else { 2 };\n@@ -1166,13 +1138,13 @@ pub fn format_struct_struct(\n     let one_line_budget =\n         one_line_width.map_or(0, |one_line_width| min(one_line_width, one_line_budget));\n \n-    let items_str = try_opt!(rewrite_with_alignment(\n+    let items_str = rewrite_with_alignment(\n         fields,\n         context,\n         Shape::indented(offset, context.config),\n         mk_sp(body_lo, span.hi()),\n         one_line_budget,\n-    ));\n+    )?;\n \n     if !items_str.contains('\\n') && !result.contains('\\n') && items_str.len() <= one_line_budget {\n         Some(format!(\"{} {} }}\", result, items_str))\n@@ -1228,12 +1200,12 @@ fn format_tuple_struct(\n             let budget = context.budget(last_line_width(&header_str));\n             let shape = Shape::legacy(budget, offset);\n             let g_span = mk_sp(span.lo(), body_lo);\n-            let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n+            let generics_str = rewrite_generics(context, generics, shape, g_span)?;\n             result.push_str(&generics_str);\n \n             let where_budget = context.budget(last_line_width(&result));\n             let option = WhereClauseOption::new(true, false);\n-            try_opt!(rewrite_where_clause(\n+            rewrite_where_clause(\n                 context,\n                 &generics.where_clause,\n                 context.config.item_brace_style(),\n@@ -1243,7 +1215,7 @@ fn format_tuple_struct(\n                 None,\n                 body_hi,\n                 option,\n-            ))\n+            )?\n         }\n         None => \"\".to_owned(),\n     };\n@@ -1271,15 +1243,15 @@ fn format_tuple_struct(\n         result.push(')');\n     } else {\n         // 3 = `();`\n-        let body = try_opt!(rewrite_call_inner(\n+        let body = rewrite_call_inner(\n             context,\n             \"\",\n             &fields.iter().map(|field| field).collect::<Vec<_>>()[..],\n             span,\n             Shape::legacy(context.budget(last_line_width(&result) + 3), offset),\n             context.config.fn_call_width(),\n             false,\n-        ));\n+        )?;\n         result.push_str(&body);\n     }\n \n@@ -1315,14 +1287,14 @@ pub fn rewrite_type_alias(\n     result.push_str(&ident.to_string());\n \n     // 2 = `= `\n-    let shape = try_opt!(Shape::indented(indent + result.len(), context.config).sub_width(2));\n+    let shape = Shape::indented(indent + result.len(), context.config).sub_width(2)?;\n     let g_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo());\n-    let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n+    let generics_str = rewrite_generics(context, generics, shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let where_budget = context.budget(last_line_width(&result));\n     let option = WhereClauseOption::snuggled(&result);\n-    let where_clause_str = try_opt!(rewrite_where_clause(\n+    let where_clause_str = rewrite_where_clause(\n         context,\n         &generics.where_clause,\n         context.config.item_brace_style(),\n@@ -1332,7 +1304,7 @@ pub fn rewrite_type_alias(\n         Some(span.hi()),\n         generics.span.hi(),\n         option,\n-    ));\n+    )?;\n     result.push_str(&where_clause_str);\n     if where_clause_str.is_empty() {\n         result.push_str(\" = \");\n@@ -1346,20 +1318,18 @@ pub fn rewrite_type_alias(\n     let budget = context.budget(indent.width() + line_width + \";\".len());\n     let type_indent = indent + line_width;\n     // Try to fit the type on the same line\n-    let ty_str = try_opt!(\n-        ty.rewrite(context, Shape::legacy(budget, type_indent))\n-            .or_else(|| {\n-                // The line was too short, try to put the type on the next line\n-\n-                // Remove the space after '='\n-                result.pop();\n-                let type_indent = indent.block_indent(context.config);\n-                result.push('\\n');\n-                result.push_str(&type_indent.to_string(context.config));\n-                let budget = context.budget(type_indent.width() + \";\".len());\n-                ty.rewrite(context, Shape::legacy(budget, type_indent))\n-            })\n-    );\n+    let ty_str = ty.rewrite(context, Shape::legacy(budget, type_indent))\n+        .or_else(|| {\n+            // The line was too short, try to put the type on the next line\n+\n+            // Remove the space after '='\n+            result.pop();\n+            let type_indent = indent.block_indent(context.config);\n+            result.push('\\n');\n+            result.push_str(&type_indent.to_string(context.config));\n+            let budget = context.budget(type_indent.width() + \";\".len());\n+            ty.rewrite(context, Shape::legacy(budget, type_indent))\n+        })?;\n     result.push_str(&ty_str);\n     result.push_str(\";\");\n     Some(result)\n@@ -1399,7 +1369,7 @@ fn rewrite_struct_field_type(\n     spacing: &str,\n     shape: Shape,\n ) -> Option<String> {\n-    let ty_shape = try_opt!(shape.offset_left(last_line_width + spacing.len()));\n+    let ty_shape = shape.offset_left(last_line_width + spacing.len())?;\n     field\n         .ty\n         .rewrite(context, ty_shape)\n@@ -1423,9 +1393,9 @@ pub fn rewrite_struct_field(\n     }\n \n     let type_annotation_spacing = type_annotation_spacing(context.config);\n-    let prefix = try_opt!(rewrite_struct_field_prefix(context, field));\n+    let prefix = rewrite_struct_field_prefix(context, field)?;\n \n-    let attrs_str = try_opt!(field.attrs.rewrite(context, shape));\n+    let attrs_str = field.attrs.rewrite(context, shape)?;\n     let attrs_extendable = attrs_str.is_empty()\n         || (context.config.attributes_on_same_line_as_field()\n             && is_attributes_extendable(&attrs_str));\n@@ -1440,14 +1410,14 @@ pub fn rewrite_struct_field(\n         \"\"\n     });\n     // Try to put everything on a single line.\n-    let attr_prefix = try_opt!(combine_strs_with_missing_comments(\n+    let attr_prefix = combine_strs_with_missing_comments(\n         context,\n         &attrs_str,\n         &prefix,\n         missing_span,\n         shape,\n         attrs_extendable,\n-    ));\n+    )?;\n     let overhead = last_line_width(&attr_prefix);\n     let lhs_offset = lhs_max_width.checked_sub(overhead).unwrap_or(0);\n     for _ in 0..lhs_offset {\n@@ -1487,7 +1457,7 @@ pub fn rewrite_struct_field(\n             _ => prefix + ty,\n         },\n         _ => {\n-            let ty = try_opt!(rewrite_type_in_next_line());\n+            let ty = rewrite_type_in_next_line()?;\n             format!(\n                 \"{}\\n{}{}\",\n                 prefix,\n@@ -1530,12 +1500,10 @@ pub fn rewrite_static(\n         colon,\n     );\n     // 2 = \" =\".len()\n-    let ty_str = try_opt!(ty.rewrite(\n+    let ty_str = ty.rewrite(\n         context,\n-        try_opt!(\n-            Shape::indented(offset.block_only(), context.config).offset_left(prefix.len() + 2)\n-        ),\n-    ));\n+        Shape::indented(offset.block_only(), context.config).offset_left(prefix.len() + 2)?,\n+    )?;\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n@@ -1564,14 +1532,12 @@ pub fn rewrite_associated_type(\n \n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         // 2 = \": \".len()\n-        let shape = try_opt!(Shape::indented(indent, context.config).offset_left(prefix.len() + 2));\n+        let shape = Shape::indented(indent, context.config).offset_left(prefix.len() + 2)?;\n         let bounds: &[_] = ty_param_bounds;\n-        let bound_str = try_opt!(\n-            bounds\n-                .iter()\n-                .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                .collect::<Option<Vec<_>>>()\n-        );\n+        let bound_str = bounds\n+            .iter()\n+            .map(|ty_bound| ty_bound.rewrite(context, shape))\n+            .collect::<Option<Vec<_>>>()?;\n         if !bounds.is_empty() {\n             format!(\": {}\", join_bounds(context, shape, &bound_str))\n         } else {\n@@ -1582,13 +1548,13 @@ pub fn rewrite_associated_type(\n     };\n \n     if let Some(ty) = ty_opt {\n-        let ty_str = try_opt!(ty.rewrite(\n+        let ty_str = ty.rewrite(\n             context,\n             Shape::legacy(\n                 context.budget(indent.block_indent + prefix.len() + 2),\n                 indent.block_only(),\n             ),\n-        ));\n+        )?;\n         Some(format!(\"{}{} = {};\", prefix, type_bounds_str, ty_str))\n     } else {\n         Some(format!(\"{}{};\", prefix, type_bounds_str))\n@@ -1603,13 +1569,7 @@ pub fn rewrite_associated_impl_type(\n     context: &RewriteContext,\n     indent: Indent,\n ) -> Option<String> {\n-    let result = try_opt!(rewrite_associated_type(\n-        ident,\n-        ty_opt,\n-        ty_param_bounds_opt,\n-        context,\n-        indent,\n-    ));\n+    let result = rewrite_associated_type(ident, ty_opt, ty_param_bounds_opt, context, indent)?;\n \n     match defaultness {\n         ast::Defaultness::Default => Some(format!(\"default {}\", result)),\n@@ -1622,7 +1582,7 @@ impl Rewrite for ast::FunctionRetTy {\n         match *self {\n             ast::FunctionRetTy::Default(_) => Some(String::new()),\n             ast::FunctionRetTy::Ty(ref ty) => {\n-                let inner_width = try_opt!(shape.width.checked_sub(3));\n+                let inner_width = shape.width.checked_sub(3)?;\n                 ty.rewrite(context, Shape::legacy(inner_width, shape.indent + 3))\n                     .map(|r| format!(\"-> {}\", r))\n             }\n@@ -1643,10 +1603,8 @@ fn is_empty_infer(context: &RewriteContext, ty: &ast::Ty) -> bool {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n-            let mut result = try_opt!(\n-                self.pat\n-                    .rewrite(context, Shape::legacy(shape.width, shape.indent))\n-            );\n+            let mut result = self.pat\n+                .rewrite(context, Shape::legacy(shape.width, shape.indent))?;\n \n             if !is_empty_infer(context, &*self.ty) {\n                 if context.config.space_before_type_annotation() {\n@@ -1657,11 +1615,9 @@ impl Rewrite for ast::Arg {\n                     result.push_str(\" \");\n                 }\n                 let overhead = last_line_width(&result);\n-                let max_width = try_opt!(shape.width.checked_sub(overhead));\n-                let ty_str = try_opt!(\n-                    self.ty\n-                        .rewrite(context, Shape::legacy(max_width, shape.indent))\n-                );\n+                let max_width = shape.width.checked_sub(overhead)?;\n+                let ty_str = self.ty\n+                    .rewrite(context, Shape::legacy(max_width, shape.indent))?;\n                 result.push_str(&ty_str);\n             }\n \n@@ -1682,10 +1638,10 @@ fn rewrite_explicit_self(\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n-                    let lifetime_str = try_opt!(l.rewrite(\n+                    let lifetime_str = l.rewrite(\n                         context,\n                         Shape::legacy(context.config.max_width(), Indent::empty()),\n-                    ));\n+                    )?;\n                     Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n                 }\n                 None => Some(format!(\"&{}self\", mut_str)),\n@@ -1695,10 +1651,10 @@ fn rewrite_explicit_self(\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n-            let type_str = try_opt!(ty.rewrite(\n+            let type_str = ty.rewrite(\n                 context,\n                 Shape::legacy(context.config.max_width(), Indent::empty()),\n-            ));\n+            )?;\n \n             Some(format!(\n                 \"{}self: {}\",\n@@ -1788,7 +1744,7 @@ fn rewrite_fn_base(\n     };\n     let fd = fn_sig.decl;\n     let g_span = mk_sp(span.lo(), fd.output.span().lo());\n-    let generics_str = try_opt!(rewrite_generics(context, fn_sig.generics, shape, g_span));\n+    let generics_str = rewrite_generics(context, fn_sig.generics, shape, g_span)?;\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -1798,24 +1754,22 @@ fn rewrite_fn_base(\n \n     // Note that the width and indent don't really matter, we'll re-layout the\n     // return type later anyway.\n-    let ret_str = try_opt!(\n-        fd.output\n-            .rewrite(context, Shape::indented(indent, context.config))\n-    );\n+    let ret_str = fd.output\n+        .rewrite(context, Shape::indented(indent, context.config))?;\n \n     let multi_line_ret_str = ret_str.contains('\\n');\n     let ret_str_len = if multi_line_ret_str { 0 } else { ret_str.len() };\n \n     // Args.\n-    let (one_line_budget, multi_line_budget, mut arg_indent) = try_opt!(compute_budgets_for_args(\n+    let (one_line_budget, multi_line_budget, mut arg_indent) = compute_budgets_for_args(\n         context,\n         &result,\n         indent,\n         ret_str_len,\n         newline_brace,\n         has_body,\n         multi_line_ret_str,\n-    ));\n+    )?;\n \n     debug!(\n         \"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n@@ -1869,7 +1823,7 @@ fn rewrite_fn_base(\n             .span_after(mk_sp(args_start, span.hi()), \"(\"),\n         args_end,\n     );\n-    let arg_str = try_opt!(rewrite_args(\n+    let arg_str = rewrite_args(\n         context,\n         &fd.inputs,\n         fd.get_self().as_ref(),\n@@ -1880,7 +1834,7 @@ fn rewrite_fn_base(\n         args_span,\n         fd.variadic,\n         generics_str.contains('\\n'),\n-    ));\n+    )?;\n \n     let put_args_in_block = match context.config.fn_args_layout() {\n         IndentStyle::Block => arg_str.contains('\\n') || arg_str.len() > one_line_budget,\n@@ -1968,10 +1922,8 @@ fn rewrite_fn_base(\n         if multi_line_ret_str || ret_should_indent {\n             // Now that we know the proper indent and width, we need to\n             // re-layout the return type.\n-            let ret_str = try_opt!(\n-                fd.output\n-                    .rewrite(context, Shape::indented(ret_indent, context.config))\n-            );\n+            let ret_str = fd.output\n+                .rewrite(context, Shape::indented(ret_indent, context.config))?;\n             result.push_str(&ret_str);\n         } else {\n             result.push_str(&ret_str);\n@@ -2035,7 +1987,7 @@ fn rewrite_fn_base(\n     }\n \n     let option = WhereClauseOption::new(!has_body, put_args_in_block && ret_str.is_empty());\n-    let where_clause_str = try_opt!(rewrite_where_clause(\n+    let where_clause_str = rewrite_where_clause(\n         context,\n         where_clause,\n         context.config.fn_brace_style(),\n@@ -2045,7 +1997,7 @@ fn rewrite_fn_base(\n         Some(span.hi()),\n         pos_before_where,\n         option,\n-    ));\n+    )?;\n     // If there are neither where clause nor return type, we may be missing comments between\n     // args and `{`.\n     if where_clause_str.is_empty() {\n@@ -2116,13 +2068,11 @@ fn rewrite_args(\n     variadic: bool,\n     generics_str_contains_newline: bool,\n ) -> Option<String> {\n-    let mut arg_item_strs = try_opt!(\n-        args.iter()\n-            .map(|arg| {\n-                arg.rewrite(context, Shape::legacy(multi_line_budget, arg_indent))\n-            })\n-            .collect::<Option<Vec<_>>>()\n-    );\n+    let mut arg_item_strs = args.iter()\n+        .map(|arg| {\n+            arg.rewrite(context, Shape::legacy(multi_line_budget, arg_indent))\n+        })\n+        .collect::<Option<Vec<_>>>()?;\n \n     // Account for sugary self.\n     // FIXME: the comment for the self argument is dropped. This is blocked\n@@ -2344,7 +2294,7 @@ fn rewrite_generics(\n     shape: Shape,\n     span: Span,\n ) -> Option<String> {\n-    let g_shape = try_opt!(generics_shape_from_config(context.config, shape, 0));\n+    let g_shape = generics_shape_from_config(context.config, shape, 0)?;\n     let one_line_width = shape.width.checked_sub(2).unwrap_or(0);\n     rewrite_generics_inner(context, generics, g_shape, one_line_width, span).or_else(|| {\n         rewrite_generics_inner(context, generics, g_shape, 0, span)\n@@ -2452,7 +2402,7 @@ where\n         config: context.config,\n     };\n \n-    let list_str = try_opt!(write_list(&item_vec, &fmt));\n+    let list_str = write_list(&item_vec, &fmt)?;\n \n     Some(wrap_generics_with_angle_brackets(\n         context,\n@@ -2494,12 +2444,10 @@ fn rewrite_trait_bounds(\n     if bounds.is_empty() {\n         return Some(String::new());\n     }\n-    let bound_str = try_opt!(\n-        bounds\n-            .iter()\n-            .map(|ty_bound| ty_bound.rewrite(context, shape))\n-            .collect::<Option<Vec<_>>>()\n-    );\n+    let bound_str = bounds\n+        .iter()\n+        .map(|ty_bound| ty_bound.rewrite(context, shape))\n+        .collect::<Option<Vec<_>>>()?;\n     Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n }\n \n@@ -2516,22 +2464,18 @@ fn rewrite_where_clause_rfc_style(\n \n     let (span_before, span_after) =\n         missing_span_before_after_where(span_end_before_where, where_clause);\n-    let (comment_before, comment_after) = try_opt!(rewrite_comments_before_after_where(\n-        context,\n-        span_before,\n-        span_after,\n-        shape,\n-    ));\n+    let (comment_before, comment_after) =\n+        rewrite_comments_before_after_where(context, span_before, span_after, shape)?;\n \n     let starting_newline = if where_clause_option.snuggle && comment_before.is_empty() {\n         \" \".to_owned()\n     } else {\n         \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n     };\n \n-    let clause_shape = try_opt!(block_shape.block_left(context.config.tab_spaces()));\n+    let clause_shape = block_shape.block_left(context.config.tab_spaces())?;\n     // 1 = `,`\n-    let clause_shape = try_opt!(clause_shape.sub_width(1));\n+    let clause_shape = clause_shape.sub_width(1)?;\n     // each clause on one line, trailing comma (except if suppress_comma)\n     let span_start = where_clause.predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n@@ -2566,7 +2510,7 @@ fn rewrite_where_clause_rfc_style(\n         preserve_newline: true,\n         config: context.config,\n     };\n-    let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n+    let preds_str = write_list(&items.collect::<Vec<_>>(), &fmt)?;\n \n     let comment_separator = |comment: &str, shape: Shape| if comment.is_empty() {\n         String::new()\n@@ -2678,7 +2622,7 @@ fn rewrite_where_clause(\n         preserve_newline: true,\n         config: context.config,\n     };\n-    let preds_str = try_opt!(write_list(&item_vec, &fmt));\n+    let preds_str = write_list(&item_vec, &fmt)?;\n \n     let end_length = if terminator == \"{\" {\n         // If the brace is on the next line we don't need to count it otherwise it needs two\n@@ -2722,12 +2666,12 @@ fn rewrite_comments_before_after_where(\n     span_after_where: Span,\n     shape: Shape,\n ) -> Option<(String, String)> {\n-    let before_comment = try_opt!(rewrite_missing_comment(span_before_where, shape, context));\n-    let after_comment = try_opt!(rewrite_missing_comment(\n+    let before_comment = rewrite_missing_comment(span_before_where, shape, context)?;\n+    let after_comment = rewrite_missing_comment(\n         span_after_where,\n         shape.block_indent(context.config.tab_spaces()),\n         context,\n-    ));\n+    )?;\n     Some((before_comment, after_comment))\n }\n \n@@ -2747,12 +2691,12 @@ fn format_generics(\n     used_width: usize,\n ) -> Option<String> {\n     let shape = Shape::legacy(context.budget(used_width + offset.width()), offset);\n-    let mut result = try_opt!(rewrite_generics(context, generics, shape, span));\n+    let mut result = rewrite_generics(context, generics, shape, span)?;\n \n     let same_line_brace = if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = context.budget(last_line_used_width(&result, offset.width()));\n         let option = WhereClauseOption::snuggled(&result);\n-        let where_clause_str = try_opt!(rewrite_where_clause(\n+        let where_clause_str = rewrite_where_clause(\n             context,\n             &generics.where_clause,\n             brace_style,\n@@ -2762,7 +2706,7 @@ fn format_generics(\n             Some(span.hi()),\n             generics.span.hi(),\n             option,\n-        ));\n+        )?;\n         result.push_str(&where_clause_str);\n         force_same_line_brace || brace_style == BraceStyle::PreferSameLine\n             || (generics.where_clause.predicates.is_empty()\n@@ -2795,12 +2739,12 @@ fn format_generics(\n \n impl Rewrite for ast::ForeignItem {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        let attrs_str = self.attrs.rewrite(context, shape)?;\n         // Drop semicolon or it will be interpreted as comment.\n         // FIXME: this may be a faulty span from libsyntax.\n         let span = mk_sp(self.span.lo(), self.span.hi() - BytePos(1));\n \n-        let item_str = try_opt!(match self.node {\n+        let item_str = match self.node {\n             ast::ForeignItemKind::Fn(ref fn_decl, ref generics) => {\n                 rewrite_fn_base(\n                     context,\n@@ -2819,7 +2763,7 @@ impl Rewrite for ast::ForeignItem {\n                 let mut_str = if is_mutable { \"mut \" } else { \"\" };\n                 let prefix = format!(\"{}static {}{}:\", vis, mut_str, self.ident);\n                 // 1 = ;\n-                let shape = try_opt!(shape.sub_width(1));\n+                let shape = shape.sub_width(1)?;\n                 ty.rewrite(context, shape).map(|ty_str| {\n                     // 1 = space between prefix and type.\n                     let sep = if prefix.len() + ty_str.len() + 1 <= shape.width {\n@@ -2831,7 +2775,7 @@ impl Rewrite for ast::ForeignItem {\n                     format!(\"{}{}{};\", prefix, sep, ty_str)\n                 })\n             }\n-        });\n+        }?;\n \n         let missing_span = if self.attrs.is_empty() {\n             mk_sp(self.span.lo(), self.span.lo())"}, {"sha": "12fb4032094d4dc71de78cbceb8acb8f7c22ffe3", "filename": "src/lists.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -275,7 +275,7 @@ where\n     let indent_str = &formatting.shape.indent.to_string(formatting.config);\n     while let Some((i, item)) = iter.next() {\n         let item = item.as_ref();\n-        let inner_item = try_opt!(item.item.as_ref());\n+        let inner_item = item.item.as_ref()?;\n         let first = i == 0;\n         let last = iter.peek().is_none();\n         let mut separate = !last || trailing_separator;\n@@ -336,12 +336,8 @@ where\n             // Block style in non-vertical mode.\n             let block_mode = tactic != DefinitiveListTactic::Vertical;\n             // Width restriction is only relevant in vertical mode.\n-            let comment = try_opt!(rewrite_comment(\n-                comment,\n-                block_mode,\n-                formatting.shape,\n-                formatting.config,\n-            ));\n+            let comment =\n+                rewrite_comment(comment, block_mode, formatting.shape, formatting.config)?;\n             result.push_str(&comment);\n \n             if tactic == DefinitiveListTactic::Vertical {\n@@ -377,12 +373,12 @@ where\n         // Post-comments\n         if tactic != DefinitiveListTactic::Vertical && item.post_comment.is_some() {\n             let comment = item.post_comment.as_ref().unwrap();\n-            let formatted_comment = try_opt!(rewrite_comment(\n+            let formatted_comment = rewrite_comment(\n                 comment,\n                 true,\n                 Shape::legacy(formatting.shape.width, Indent::empty()),\n                 formatting.config,\n-            ));\n+            )?;\n \n             result.push(' ');\n             result.push_str(&formatted_comment);\n@@ -423,7 +419,7 @@ where\n                 rewrite_comment(comment, block_style, comment_shape, formatting.config)\n             };\n \n-            let mut formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n+            let mut formatted_comment = rewrite_post_comment(&mut item_max_width)?;\n \n             if !formatted_comment.starts_with('\\n') {\n                 let mut comment_alignment =\n@@ -432,7 +428,7 @@ where\n                     + comment_alignment + 1 > formatting.config.max_width()\n                 {\n                     item_max_width = None;\n-                    formatted_comment = try_opt!(rewrite_post_comment(&mut item_max_width));\n+                    formatted_comment = rewrite_post_comment(&mut item_max_width)?;\n                     comment_alignment = post_comment_alignment(item_max_width, inner_item.len());\n                 }\n                 for _ in 0..(comment_alignment + 1) {\n@@ -742,9 +738,10 @@ pub fn struct_lit_shape(\n     suffix_width: usize,\n ) -> Option<(Option<Shape>, Shape)> {\n     let v_shape = match context.config.struct_lit_style() {\n-        IndentStyle::Visual => try_opt!(\n-            try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n-        ),\n+        IndentStyle::Visual => shape\n+            .visual_indent(0)\n+            .shrink_left(prefix_width)?\n+            .sub_width(suffix_width)?,\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {"}, {"sha": "470f1e84fd8f6f8bf7cd43a76f45da94d05d0164", "filename": "src/macros.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -216,7 +216,7 @@ pub fn rewrite_macro(\n             })\n         }\n         MacroStyle::Brackets => {\n-            let mac_shape = try_opt!(shape.offset_left(macro_name.len()));\n+            let mac_shape = shape.offset_left(macro_name.len())?;\n             // Handle special case: `vec![expr; expr]`\n             if vec_with_semi {\n                 let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n@@ -227,8 +227,8 @@ pub fn rewrite_macro(\n                 // 6 = `vec!` + `; `\n                 let total_overhead = lbr.len() + rbr.len() + 6;\n                 let nested_shape = mac_shape.block_indent(context.config.tab_spaces());\n-                let lhs = try_opt!(arg_vec[0].rewrite(context, nested_shape));\n-                let rhs = try_opt!(arg_vec[1].rewrite(context, nested_shape));\n+                let lhs = arg_vec[0].rewrite(context, nested_shape)?;\n+                let rhs = arg_vec[1].rewrite(context, nested_shape)?;\n                 if !lhs.contains('\\n') && !rhs.contains('\\n')\n                     && lhs.len() + rhs.len() + total_overhead <= shape.width\n                 {\n@@ -271,13 +271,8 @@ pub fn rewrite_macro(\n                         .span_after(mac.span, original_style.opener()),\n                     mac.span.hi() - BytePos(1),\n                 );\n-                let rewrite = try_opt!(rewrite_array(\n-                    expr_vec.iter(),\n-                    sp,\n-                    context,\n-                    mac_shape,\n-                    trailing_comma,\n-                ));\n+                let rewrite =\n+                    rewrite_array(expr_vec.iter(), sp, context, mac_shape, trailing_comma)?;\n \n                 Some(format!(\"{}{}\", macro_name, rewrite))\n             }\n@@ -299,7 +294,7 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n \n         Some(ast::Expr {\n             id: ast::NodeId::new(0), // dummy value\n-            node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n+            node: ast::ExprKind::Try(parser.parse_expr().ok()?),\n             span: mac.span, // incorrect span, but shouldn't matter too much\n             attrs: ThinVec::new(),\n         })\n@@ -354,22 +349,20 @@ fn indent_macro_snippet(\n     indent: Indent,\n ) -> Option<String> {\n     let mut lines = macro_str.lines();\n-    let first_line = try_opt!(lines.next().map(|s| s.trim_right()));\n+    let first_line = lines.next().map(|s| s.trim_right())?;\n     let mut trimmed_lines = Vec::with_capacity(16);\n \n-    let min_prefix_space_width = try_opt!(\n-        lines\n-            .filter_map(|line| {\n-                let prefix_space_width = if is_empty_line(line) {\n-                    None\n-                } else {\n-                    Some(get_prefix_space_width(context, line))\n-                };\n-                trimmed_lines.push((line.trim(), prefix_space_width));\n-                prefix_space_width\n-            })\n-            .min()\n-    );\n+    let min_prefix_space_width = lines\n+        .filter_map(|line| {\n+            let prefix_space_width = if is_empty_line(line) {\n+                None\n+            } else {\n+                Some(get_prefix_space_width(context, line))\n+            };\n+            trimmed_lines.push((line.trim(), prefix_space_width));\n+            prefix_space_width\n+        })\n+        .min()?;\n \n     Some(\n         String::from(first_line) + \"\\n\""}, {"sha": "4df36b87e4da8d4f9ad072e2a5a5c012e7f3e833", "filename": "src/patterns.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -38,14 +38,12 @@ impl Rewrite for Pat {\n                 let sub_pat = match *sub_pat {\n                     Some(ref p) => {\n                         // 3 - ` @ `.\n-                        let width = try_opt!(\n-                            shape\n-                                .width\n-                                .checked_sub(prefix.len() + mut_infix.len() + id_str.len() + 3)\n-                        );\n+                        let width = shape\n+                            .width\n+                            .checked_sub(prefix.len() + mut_infix.len() + id_str.len() + 3)?;\n                         format!(\n                             \" @ {}\",\n-                            try_opt!(p.rewrite(context, Shape::legacy(width, shape.indent)))\n+                            p.rewrite(context, Shape::legacy(width, shape.indent))?\n                         )\n                     }\n                     None => \"\".to_owned(),\n@@ -86,8 +84,7 @@ impl Rewrite for Pat {\n                 rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n             }\n             PatKind::TupleStruct(ref path, ref pat_vec, dotdot_pos) => {\n-                let path_str =\n-                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n+                let path_str = rewrite_path(context, PathContext::Expr, None, path, shape)?;\n                 rewrite_tuple_pat(\n                     pat_vec,\n                     dotdot_pos,\n@@ -101,17 +98,17 @@ impl Rewrite for Pat {\n             PatKind::Slice(ref prefix, ref slice_pat, ref suffix) => {\n                 // Rewrite all the sub-patterns.\n                 let prefix = prefix.iter().map(|p| p.rewrite(context, shape));\n-                let slice_pat = slice_pat.as_ref().map(|p| {\n-                    Some(format!(\"{}..\", try_opt!(p.rewrite(context, shape))))\n-                });\n+                let slice_pat = slice_pat\n+                    .as_ref()\n+                    .map(|p| Some(format!(\"{}..\", p.rewrite(context, shape)?)));\n                 let suffix = suffix.iter().map(|p| p.rewrite(context, shape));\n \n                 // Munge them together.\n                 let pats: Option<Vec<String>> =\n                     prefix.chain(slice_pat.into_iter()).chain(suffix).collect();\n \n                 // Check that all the rewrites succeeded, and if not return None.\n-                let pats = try_opt!(pats);\n+                let pats = pats?;\n \n                 // Unwrap all the sub-strings and join them with commas.\n                 let result = if context.config.spaces_within_square_brackets() {\n@@ -139,14 +136,8 @@ fn rewrite_struct_pat(\n     shape: Shape,\n ) -> Option<String> {\n     // 2 =  ` {`\n-    let path_shape = try_opt!(shape.sub_width(2));\n-    let path_str = try_opt!(rewrite_path(\n-        context,\n-        PathContext::Expr,\n-        None,\n-        path,\n-        path_shape,\n-    ));\n+    let path_shape = shape.sub_width(2)?;\n+    let path_str = rewrite_path(context, PathContext::Expr, None, path, path_shape)?;\n \n     if fields.is_empty() && !elipses {\n         return Some(format!(\"{} {{}}\", path_str));\n@@ -155,12 +146,8 @@ fn rewrite_struct_pat(\n     let (elipses_str, terminator) = if elipses { (\", ..\", \"..\") } else { (\"\", \"}\") };\n \n     // 3 = ` { `, 2 = ` }`.\n-    let (h_shape, v_shape) = try_opt!(struct_lit_shape(\n-        shape,\n-        context,\n-        path_str.len() + 3,\n-        elipses_str.len() + 2,\n-    ));\n+    let (h_shape, v_shape) =\n+        struct_lit_shape(shape, context, path_str.len() + 3, elipses_str.len() + 2)?;\n \n     let items = itemize_list(\n         context.codemap,\n@@ -179,7 +166,7 @@ fn rewrite_struct_pat(\n     let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n     let fmt = struct_lit_formatting(nested_shape, tactic, context, false);\n \n-    let mut fields_str = try_opt!(write_list(&item_vec, &fmt));\n+    let mut fields_str = write_list(&item_vec, &fmt)?;\n     let one_line_width = h_shape.map_or(0, |shape| shape.width);\n \n     if elipses {\n@@ -215,14 +202,14 @@ impl Rewrite for FieldPat {\n         if self.is_shorthand {\n             pat\n         } else {\n-            let pat_str = try_opt!(pat);\n+            let pat_str = pat?;\n             let id_str = self.ident.to_string();\n             let one_line_width = id_str.len() + 2 + pat_str.len();\n             if one_line_width <= shape.width {\n                 Some(format!(\"{}: {}\", id_str, pat_str))\n             } else {\n                 let nested_shape = shape.block_indent(context.config.tab_spaces());\n-                let pat_str = try_opt!(self.pat.rewrite(context, nested_shape));\n+                let pat_str = self.pat.rewrite(context, nested_shape)?;\n                 Some(format!(\n                     \"{}:\\n{}{}\",\n                     id_str,"}, {"sha": "b5d57997e870672dbe3f9de0e177621d99bbdbcb", "filename": "src/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshape.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -229,14 +229,14 @@ impl Shape {\n \n     pub fn sub_width(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n+            width: self.width.checked_sub(width)?,\n             ..*self\n         })\n     }\n \n     pub fn shrink_left(&self, width: usize) -> Option<Shape> {\n         Some(Shape {\n-            width: try_opt!(self.width.checked_sub(width)),\n+            width: self.width.checked_sub(width)?,\n             indent: self.indent + width,\n             offset: self.offset + width,\n         })"}, {"sha": "c072d3186a206d8993e4928f664832dd218b18dc", "filename": "src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -67,7 +67,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let ender_length = fmt.line_end.len();\n     // If we cannot put at least a single character per line, the rewrite won't\n     // succeed.\n-    let max_chars = try_opt!(shape.width.checked_sub(fmt.opener.len() + ender_length + 1)) + 1;\n+    let max_chars = shape.width.checked_sub(fmt.opener.len() + ender_length + 1)? + 1;\n \n     // Snip a line at a time from `orig` until it is used up. Push the snippet\n     // onto result."}, {"sha": "c17112c94047739833d07efc424849bc6bad9e75", "filename": "src/types.rs", "status": "modified", "additions": 98, "deletions": 128, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -58,7 +58,7 @@ pub fn rewrite_path(\n             result.push_str(\" \")\n         }\n \n-        let fmt_ty = try_opt!(qself.ty.rewrite(context, shape));\n+        let fmt_ty = qself.ty.rewrite(context, shape)?;\n         result.push_str(&fmt_ty);\n \n         if skip_count > 0 {\n@@ -69,17 +69,17 @@ pub fn rewrite_path(\n \n             let extra_offset = extra_offset(&result, shape);\n             // 3 = \">::\".len()\n-            let shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(3));\n+            let shape = shape.shrink_left(extra_offset)?.sub_width(3)?;\n \n-            result = try_opt!(rewrite_path_segments(\n+            result = rewrite_path_segments(\n                 PathContext::Type,\n                 result,\n                 path.segments.iter().take(skip_count),\n                 span_lo,\n                 path.span.hi(),\n                 context,\n                 shape,\n-            ));\n+            )?;\n         }\n \n         if context.config.spaces_within_angle_brackets() {\n@@ -128,15 +128,15 @@ where\n         }\n \n         let extra_offset = extra_offset(&buffer, shape);\n-        let new_shape = try_opt!(shape.shrink_left(extra_offset));\n-        let segment_string = try_opt!(rewrite_segment(\n+        let new_shape = shape.shrink_left(extra_offset)?;\n+        let segment_string = rewrite_segment(\n             path_context,\n             segment,\n             &mut span_lo,\n             span_hi,\n             context,\n             new_shape,\n-        ));\n+        )?;\n \n         buffer.push_str(&segment_string);\n     }\n@@ -171,12 +171,10 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                     TypeDensity::Wide => format!(\"{} = \", binding.ident),\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n-                let budget = try_opt!(shape.width.checked_sub(result.len()));\n-                let rewrite = try_opt!(\n-                    binding\n-                        .ty\n-                        .rewrite(context, Shape::legacy(budget, shape.indent + result.len()))\n-                );\n+                let budget = shape.width.checked_sub(result.len())?;\n+                let rewrite = binding\n+                    .ty\n+                    .rewrite(context, Shape::legacy(budget, shape.indent + result.len()))?;\n                 result.push_str(&rewrite);\n                 Some(result)\n             }\n@@ -203,7 +201,7 @@ fn rewrite_segment(\n     shape: Shape,\n ) -> Option<String> {\n     let ident_len = segment.identifier.to_string().len();\n-    let shape = try_opt!(shape.shrink_left(ident_len));\n+    let shape = shape.shrink_left(ident_len)?;\n \n     let params = if let Some(ref params) = segment.parameters {\n         match **params {\n@@ -226,12 +224,9 @@ fn rewrite_segment(\n                     \"\"\n                 };\n \n-                let generics_shape = try_opt!(generics_shape_from_config(\n-                    context.config,\n-                    shape,\n-                    separator.len(),\n-                ));\n-                let one_line_width = try_opt!(shape.width.checked_sub(separator.len() + 2));\n+                let generics_shape =\n+                    generics_shape_from_config(context.config, shape, separator.len())?;\n+                let one_line_width = shape.width.checked_sub(separator.len() + 2)?;\n                 let items = itemize_list(\n                     context.codemap,\n                     param_list.into_iter(),\n@@ -243,12 +238,8 @@ fn rewrite_segment(\n                     span_hi,\n                     false,\n                 );\n-                let generics_str = try_opt!(format_generics_item_list(\n-                    context,\n-                    items,\n-                    generics_shape,\n-                    one_line_width,\n-                ));\n+                let generics_str =\n+                    format_generics_item_list(context, items, generics_shape, one_line_width)?;\n \n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n@@ -260,14 +251,14 @@ fn rewrite_segment(\n                     Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n                     None => FunctionRetTy::Default(codemap::DUMMY_SP),\n                 };\n-                try_opt!(format_function_type(\n+                format_function_type(\n                     data.inputs.iter().map(|x| &**x),\n                     &output,\n                     false,\n                     data.span,\n                     context,\n                     shape,\n-                ))\n+                )?\n             }\n             _ => String::new(),\n         }\n@@ -310,7 +301,7 @@ where\n     };\n \n     // 2 for ()\n-    let budget = try_opt!(shape.width.checked_sub(2));\n+    let budget = shape.width.checked_sub(2)?;\n     // 1 for (\n     let offset = match context.config.fn_args_layout() {\n         IndentStyle::Block => {\n@@ -372,21 +363,21 @@ where\n         config: context.config,\n     };\n \n-    let list_str = try_opt!(write_list(&item_vec, &fmt));\n+    let list_str = write_list(&item_vec, &fmt)?;\n \n     let ty_shape = match context.config.fn_args_layout() {\n         IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces()),\n-        IndentStyle::Visual => try_opt!(shape.block_left(4)),\n+        IndentStyle::Visual => shape.block_left(4)?,\n     };\n     let output = match *output {\n         FunctionRetTy::Ty(ref ty) => {\n-            let type_str = try_opt!(ty.rewrite(context, ty_shape));\n+            let type_str = ty.rewrite(context, ty_shape)?;\n             format!(\" -> {}\", type_str)\n         }\n         FunctionRetTy::Default(..) => String::new(),\n     };\n \n-    let shape = try_opt!(shape.sub_width(output.len()));\n+    let shape = shape.sub_width(output.len())?;\n     let extendable = !list_str.contains('\\n') || list_str.is_empty();\n     let args = wrap_args_with_parens(\n         context,\n@@ -424,27 +415,24 @@ impl Rewrite for ast::WherePredicate {\n                 ref bounds,\n                 ..\n             }) => {\n-                let type_str = try_opt!(bounded_ty.rewrite(context, shape));\n+                let type_str = bounded_ty.rewrite(context, shape)?;\n \n                 let colon = type_bound_colon(context);\n \n                 if !bound_lifetimes.is_empty() {\n-                    let lifetime_str: String = try_opt!(\n-                        bound_lifetimes\n-                            .iter()\n-                            .map(|lt| lt.rewrite(context, shape))\n-                            .collect::<Option<Vec<_>>>()\n-                    ).join(\", \");\n+                    let lifetime_str: String = bound_lifetimes\n+                        .iter()\n+                        .map(|lt| lt.rewrite(context, shape))\n+                        .collect::<Option<Vec<_>>>()?\n+                        .join(\", \");\n \n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n-                    let ty_shape = try_opt!(shape.offset_left(used_width));\n-                    let bounds: Vec<_> = try_opt!(\n-                        bounds\n-                            .iter()\n-                            .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                            .collect()\n-                    );\n+                    let ty_shape = shape.offset_left(used_width)?;\n+                    let bounds = bounds\n+                        .iter()\n+                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                        .collect::<Option<Vec<_>>>()?;\n                     let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     if context.config.spaces_within_angle_brackets() && !lifetime_str.is_empty() {\n@@ -461,18 +449,15 @@ impl Rewrite for ast::WherePredicate {\n                 } else {\n                     let used_width = type_str.len() + colon.len();\n                     let ty_shape = match context.config.where_style() {\n-                        Style::Legacy => try_opt!(shape.block_left(used_width)),\n+                        Style::Legacy => shape.block_left(used_width)?,\n                         Style::Rfc => shape,\n                     };\n-                    let bounds: Vec<_> = try_opt!(\n-                        bounds\n-                            .iter()\n-                            .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                            .collect()\n-                    );\n+                    let bounds = bounds\n+                        .iter()\n+                        .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                        .collect::<Option<Vec<_>>>()?;\n                     let overhead = type_str.len() + colon.len();\n-                    let bounds_str =\n-                        join_bounds(context, try_opt!(ty_shape.sub_width(overhead)), &bounds);\n+                    let bounds_str = join_bounds(context, ty_shape.sub_width(overhead)?, &bounds);\n \n                     format!(\"{}{}{}\", type_str, colon, bounds_str)\n                 }\n@@ -481,24 +466,18 @@ impl Rewrite for ast::WherePredicate {\n                 ref lifetime,\n                 ref bounds,\n                 ..\n-            }) => try_opt!(rewrite_bounded_lifetime(\n-                lifetime,\n-                bounds.iter(),\n-                context,\n-                shape,\n-            )),\n+            }) => rewrite_bounded_lifetime(lifetime, bounds.iter(), context, shape)?,\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                 ref lhs_ty,\n                 ref rhs_ty,\n                 ..\n             }) => {\n-                let lhs_ty_str = try_opt!(lhs_ty.rewrite(context, shape));\n+                let lhs_ty_str = lhs_ty.rewrite(context, shape)?;\n                 // 3 = \" = \".len()\n                 let used_width = 3 + lhs_ty_str.len();\n-                let budget = try_opt!(shape.width.checked_sub(used_width));\n-                let rhs_ty_str = try_opt!(\n-                    rhs_ty.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n-                );\n+                let budget = shape.width.checked_sub(used_width)?;\n+                let rhs_ty_str =\n+                    rhs_ty.rewrite(context, Shape::legacy(budget, shape.indent + used_width))?;\n                 format!(\"{} = {}\", lhs_ty_str, rhs_ty_str)\n             }\n         };\n@@ -522,24 +501,22 @@ fn rewrite_bounded_lifetime<'b, I>(\n where\n     I: ExactSizeIterator<Item = &'b ast::Lifetime>,\n {\n-    let result = try_opt!(lt.rewrite(context, shape));\n+    let result = lt.rewrite(context, shape)?;\n \n     if bounds.len() == 0 {\n         Some(result)\n     } else {\n-        let appendix: Vec<_> = try_opt!(\n-            bounds\n-                .into_iter()\n-                .map(|b| b.rewrite(context, shape))\n-                .collect()\n-        );\n+        let appendix = bounds\n+            .into_iter()\n+            .map(|b| b.rewrite(context, shape))\n+            .collect::<Option<Vec<_>>>()?;\n         let colon = type_bound_colon(context);\n         let overhead = last_line_width(&result) + colon.len();\n         let result = format!(\n             \"{}{}{}\",\n             result,\n             colon,\n-            join_bounds(context, try_opt!(shape.sub_width(overhead)), &appendix)\n+            join_bounds(context, shape.sub_width(overhead)?, &appendix)\n         );\n         Some(result)\n     }\n@@ -554,7 +531,7 @@ impl Rewrite for ast::TyParamBound {\n             ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => {\n                 Some(format!(\n                     \"?{}\",\n-                    try_opt!(tref.rewrite(context, try_opt!(shape.offset_left(1))))\n+                    tref.rewrite(context, shape.offset_left(1)?)?\n                 ))\n             }\n             ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, shape),\n@@ -570,7 +547,9 @@ impl Rewrite for ast::Lifetime {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n+        let strs = self.iter()\n+            .map(|b| b.rewrite(context, shape))\n+            .collect::<Option<Vec<_>>>()?;\n         join_bounds(context, shape, &strs).rewrite(context, shape)\n     }\n }\n@@ -586,12 +565,10 @@ impl Rewrite for ast::TyParam {\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));\n-            let strs: Vec<_> = try_opt!(\n-                self.bounds\n-                    .iter()\n-                    .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                    .collect()\n-            );\n+            let strs = self.bounds\n+                .iter()\n+                .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()?;\n             result.push_str(&join_bounds(context, shape, &strs));\n         }\n         if let Some(ref def) = self.default {\n@@ -600,9 +577,8 @@ impl Rewrite for ast::TyParam {\n                 TypeDensity::Wide => \" = \",\n             };\n             result.push_str(eq_str);\n-            let budget = try_opt!(shape.width.checked_sub(result.len()));\n-            let rewrite =\n-                try_opt!(def.rewrite(context, Shape::legacy(budget, shape.indent + result.len())));\n+            let budget = shape.width.checked_sub(result.len())?;\n+            let rewrite = def.rewrite(context, Shape::legacy(budget, shape.indent + result.len()))?;\n             result.push_str(&rewrite);\n         }\n \n@@ -613,19 +589,16 @@ impl Rewrite for ast::TyParam {\n impl Rewrite for ast::PolyTraitRef {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if !self.bound_lifetimes.is_empty() {\n-            let lifetime_str: String = try_opt!(\n-                self.bound_lifetimes\n-                    .iter()\n-                    .map(|lt| lt.rewrite(context, shape))\n-                    .collect::<Option<Vec<_>>>()\n-            ).join(\", \");\n+            let lifetime_str: String = self.bound_lifetimes\n+                .iter()\n+                .map(|lt| lt.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()?\n+                .join(\", \");\n \n             // 6 is \"for<> \".len()\n             let extra_offset = lifetime_str.len() + 6;\n-            let path_str = try_opt!(\n-                self.trait_ref\n-                    .rewrite(context, try_opt!(shape.offset_left(extra_offset)))\n-            );\n+            let path_str = self.trait_ref\n+                .rewrite(context, shape.offset_left(extra_offset)?)?;\n \n             Some(\n                 if context.config.spaces_within_angle_brackets() && !lifetime_str.is_empty() {\n@@ -663,42 +636,40 @@ impl Rewrite for ast::Ty {\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n                     Some(ref lifetime) => {\n-                        let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n-                        let lt_str = try_opt!(lifetime.rewrite(\n+                        let lt_budget = shape.width.checked_sub(2 + mut_len)?;\n+                        let lt_str = lifetime.rewrite(\n                             context,\n                             Shape::legacy(lt_budget, shape.indent + 2 + mut_len),\n-                        ));\n+                        )?;\n                         let lt_len = lt_str.len();\n-                        let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));\n+                        let budget = shape.width.checked_sub(2 + mut_len + lt_len)?;\n                         format!(\n                             \"&{} {}{}\",\n                             lt_str,\n                             mut_str,\n-                            try_opt!(mt.ty.rewrite(\n+                            mt.ty.rewrite(\n                                 context,\n-                                Shape::legacy(budget, shape.indent + 2 + mut_len + lt_len),\n-                            ))\n+                                Shape::legacy(budget, shape.indent + 2 + mut_len + lt_len)\n+                            )?\n                         )\n                     }\n                     None => {\n-                        let budget = try_opt!(shape.width.checked_sub(1 + mut_len));\n+                        let budget = shape.width.checked_sub(1 + mut_len)?;\n                         format!(\n                             \"&{}{}\",\n                             mut_str,\n-                            try_opt!(\n-                                mt.ty.rewrite(\n-                                    context,\n-                                    Shape::legacy(budget, shape.indent + 1 + mut_len),\n-                                )\n-                            )\n+                            mt.ty.rewrite(\n+                                context,\n+                                Shape::legacy(budget, shape.indent + 1 + mut_len),\n+                            )?\n                         )\n                     }\n                 })\n             }\n             // FIXME: we drop any comments here, even though it's a silly place to put\n             // comments.\n             ast::TyKind::Paren(ref ty) => {\n-                let budget = try_opt!(shape.width.checked_sub(2));\n+                let budget = shape.width.checked_sub(2)?;\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_parens() {\n                         format!(\"( {} )\", ty_str)\n@@ -708,9 +679,9 @@ impl Rewrite for ast::Ty {\n             }\n             ast::TyKind::Slice(ref ty) => {\n                 let budget = if context.config.spaces_within_square_brackets() {\n-                    try_opt!(shape.width.checked_sub(4))\n+                    shape.width.checked_sub(4)?\n                 } else {\n-                    try_opt!(shape.width.checked_sub(2))\n+                    shape.width.checked_sub(2)?\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n                     .map(|ty_str| if context.config.spaces_within_square_brackets() {\n@@ -772,18 +743,17 @@ fn rewrite_bare_fn(\n         // 6 = \"for<> \".len(), 4 = \"for<\".\n         // This doesn't work out so nicely for mutliline situation with lots of\n         // rightward drift. If that is a problem, we could use the list stuff.\n-        result.push_str(&try_opt!(\n-            bare_fn\n-                .lifetimes\n-                .iter()\n-                .map(|l| {\n-                    l.rewrite(\n-                        context,\n-                        Shape::legacy(try_opt!(shape.width.checked_sub(6)), shape.indent + 4),\n-                    )\n-                })\n-                .collect::<Option<Vec<_>>>()\n-        ).join(\", \"));\n+        result.push_str(&bare_fn\n+            .lifetimes\n+            .iter()\n+            .map(|l| {\n+                l.rewrite(\n+                    context,\n+                    Shape::legacy(shape.width.checked_sub(6)?, shape.indent + 4),\n+                )\n+            })\n+            .collect::<Option<Vec<_>>>()?\n+            .join(\", \"));\n         result.push_str(\"> \");\n     }\n \n@@ -797,16 +767,16 @@ fn rewrite_bare_fn(\n \n     result.push_str(\"fn\");\n \n-    let func_ty_shape = try_opt!(shape.offset_left(result.len()));\n+    let func_ty_shape = shape.offset_left(result.len())?;\n \n-    let rewrite = try_opt!(format_function_type(\n+    let rewrite = format_function_type(\n         bare_fn.decl.inputs.iter(),\n         &bare_fn.decl.output,\n         bare_fn.decl.variadic,\n         span,\n         context,\n         func_ty_shape,\n-    ));\n+    )?;\n \n     result.push_str(&rewrite);\n "}, {"sha": "d1324f1dafaa4051e5935a26b4bffa3e302b7271", "filename": "src/utils.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -343,15 +343,6 @@ macro_rules! impl_enum_serialize_and_deserialize {\n     };\n }\n \n-// Same as try!, but for Option\n-#[macro_export]\n-macro_rules! try_opt {\n-    ($expr:expr) => (match $expr {\n-        Some(val) => val,\n-        None => { return None; }\n-    })\n-}\n-\n macro_rules! msg {\n     ($($arg:tt)*) => (\n         match writeln!(&mut ::std::io::stderr(), $($arg)* ) {"}, {"sha": "f5636672422fba8771b62cceba50b6a5790725e8", "filename": "src/vertical.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -48,7 +48,7 @@ impl AlignedItem for ast::StructField {\n     }\n \n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        let attrs_str = self.attrs.rewrite(context, shape)?;\n         let missing_span = if self.attrs.is_empty() {\n             mk_sp(self.span.lo(), self.span.lo())\n         } else {\n@@ -88,7 +88,7 @@ impl AlignedItem for ast::Field {\n     }\n \n     fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let attrs_str = try_opt!(self.attrs.rewrite(context, shape));\n+        let attrs_str = self.attrs.rewrite(context, shape)?;\n         let name = &self.ident.node.to_string();\n         let missing_span = if self.attrs.is_empty() {\n             mk_sp(self.span.lo(), self.span.lo())\n@@ -166,24 +166,13 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n     };\n     let init_span = mk_sp(span.lo(), init_last_pos);\n     let one_line_width = if rest.is_empty() { one_line_width } else { 0 };\n-    let result = try_opt!(rewrite_aligned_items_inner(\n-        context,\n-        init,\n-        init_span,\n-        shape.indent,\n-        one_line_width,\n-    ));\n+    let result =\n+        rewrite_aligned_items_inner(context, init, init_span, shape.indent, one_line_width)?;\n     if rest.is_empty() {\n         Some(result + spaces)\n     } else {\n         let rest_span = mk_sp(init_last_pos, span.hi());\n-        let rest_str = try_opt!(rewrite_with_alignment(\n-            rest,\n-            context,\n-            shape,\n-            rest_span,\n-            one_line_width,\n-        ));\n+        let rest_str = rewrite_with_alignment(rest, context, shape, rest_span, one_line_width)?;\n         Some(\n             result + spaces + \"\\n\"\n                 + &shape\n@@ -228,7 +217,7 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n ) -> Option<String> {\n     let item_indent = offset.block_indent(context.config);\n     // 1 = \",\"\n-    let item_shape = try_opt!(Shape::indented(item_indent, context.config).sub_width(1));\n+    let item_shape = Shape::indented(item_indent, context.config).sub_width(1)?;\n     let (mut field_prefix_max_width, field_prefix_min_width) =\n         struct_field_preix_max_min_width(context, fields, item_shape);\n     let max_diff = field_prefix_max_width"}, {"sha": "80faa78a6fab193d4d922afc7418e6eb2da05338", "filename": "src/visitor.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe69dde96be4b7afcef4975e825d385b23b51799/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=fe69dde96be4b7afcef4975e825d385b23b51799", "patch": "@@ -811,12 +811,10 @@ impl Rewrite for ast::MetaItem {\n             ast::MetaItemKind::List(ref list) => {\n                 let name = self.name.as_str();\n                 // 1 = `(`, 2 = `]` and `)`\n-                let item_shape = try_opt!(\n-                    shape\n-                        .visual_indent(0)\n-                        .shrink_left(name.len() + 1)\n-                        .and_then(|s| s.sub_width(2))\n-                );\n+                let item_shape = shape\n+                    .visual_indent(0)\n+                    .shrink_left(name.len() + 1)\n+                    .and_then(|s| s.sub_width(2))?;\n                 let items = itemize_list(\n                     context.codemap,\n                     list.iter(),\n@@ -839,13 +837,13 @@ impl Rewrite for ast::MetaItem {\n                     preserve_newline: false,\n                     config: context.config,\n                 };\n-                format!(\"{}({})\", name, try_opt!(write_list(&item_vec, &fmt)))\n+                format!(\"{}({})\", name, write_list(&item_vec, &fmt)?)\n             }\n             ast::MetaItemKind::NameValue(ref literal) => {\n                 let name = self.name.as_str();\n                 // 3 = ` = `\n-                let lit_shape = try_opt!(shape.shrink_left(name.len() + 3));\n-                let value = try_opt!(rewrite_literal(context, literal, lit_shape));\n+                let lit_shape = shape.shrink_left(name.len() + 3)?;\n+                let value = rewrite_literal(context, literal, lit_shape)?;\n                 format!(\"{} = {}\", name, value)\n             }\n         })\n@@ -872,8 +870,8 @@ impl Rewrite for ast::Attribute {\n                 return Some(snippet);\n             }\n             // 1 = `[`\n-            let shape = try_opt!(shape.offset_left(prefix.len() + 1));\n-            try_opt!(self.meta())\n+            let shape = shape.offset_left(prefix.len() + 1)?;\n+            self.meta()?\n                 .rewrite(context, shape)\n                 .map(|rw| format!(\"{}[{}]\", prefix, rw))\n         }\n@@ -894,7 +892,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n         let mut insert_new_line = true;\n         let mut is_prev_sugared_doc = false;\n         while let Some((i, a)) = iter.next() {\n-            let a_str = try_opt!(a.rewrite(context, shape));\n+            let a_str = a.rewrite(context, shape)?;\n \n             // Write comments and blank lines between attributes.\n             if i > 0 {\n@@ -926,12 +924,12 @@ impl<'a> Rewrite for [ast::Attribute] {\n                     (false, false)\n                 };\n \n-                let comment = try_opt!(recover_missing_comment_in_span(\n+                let comment = recover_missing_comment_in_span(\n                     mk_sp(self[i - 1].span.hi(), a.span.lo()),\n                     shape.with_max_width(context.config),\n                     context,\n                     0,\n-                ));\n+                )?;\n \n                 if !comment.is_empty() {\n                     if multi_line_before {\n@@ -966,7 +964,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n                         Some(&(_, next_attr)) if is_derive(next_attr) => insert_new_line = false,\n                         // If not, rewrite the merged derives.\n                         _ => {\n-                            result.push_str(&try_opt!(format_derive(context, &derive_args, shape)));\n+                            result.push_str(&format_derive(context, &derive_args, shape)?);\n                             derive_args.clear();\n                         }\n                     }\n@@ -988,7 +986,7 @@ fn format_derive(context: &RewriteContext, derive_args: &[String], shape: Shape)\n     let mut result = String::with_capacity(128);\n     result.push_str(\"#[derive(\");\n     // 11 = `#[derive()]`\n-    let initial_budget = try_opt!(shape.width.checked_sub(11));\n+    let initial_budget = shape.width.checked_sub(11)?;\n     let mut budget = initial_budget;\n     let num = derive_args.len();\n     for (i, a) in derive_args.iter().enumerate() {"}]}