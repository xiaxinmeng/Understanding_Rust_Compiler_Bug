{"sha": "45d1cd83ab903d377f3b03fd2dc74da42100e308", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZDFjZDgzYWI5MDNkMzc3ZjNiMDNmZDJkYzc0ZGE0MjEwMGUzMDg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-12T19:02:08Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-10-12T19:02:08Z"}, "message": "Copyedit \"Items and attributes\" section in docs\n\nMost notably, I removed the \"foldl\" example in the section on pure functions,\nas IIRC this is no longer something you need an unsafe block for\n(pure functions are as pure as their arguments). Feel free to add\nan example where an unsafe block really is needed.", "tree": {"sha": "f7af9569e6c39bea7deda705b66ab38c5f8bd72d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7af9569e6c39bea7deda705b66ab38c5f8bd72d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d1cd83ab903d377f3b03fd2dc74da42100e308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d1cd83ab903d377f3b03fd2dc74da42100e308", "html_url": "https://github.com/rust-lang/rust/commit/45d1cd83ab903d377f3b03fd2dc74da42100e308", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d1cd83ab903d377f3b03fd2dc74da42100e308/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39c0d3591e0326874b7263a621ce09ecd64f0eb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/39c0d3591e0326874b7263a621ce09ecd64f0eb2", "html_url": "https://github.com/rust-lang/rust/commit/39c0d3591e0326874b7263a621ce09ecd64f0eb2"}], "stats": {"total": 125, "additions": 44, "deletions": 81}, "files": [{"sha": "568f429763589e96c06633c9f3cc3697382ff5b2", "filename": "doc/rust.md", "status": "modified", "additions": 44, "deletions": 81, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/45d1cd83ab903d377f3b03fd2dc74da42100e308/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/45d1cd83ab903d377f3b03fd2dc74da42100e308/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=45d1cd83ab903d377f3b03fd2dc74da42100e308", "patch": "@@ -703,22 +703,19 @@ otherwise compose the item body. The meaning of these scoped items is the same\n as if the item was declared outside the scope -- it is still a static item --\n except that the item's *path name* within the module namespace is qualified by\n the name of the enclosing item, or is private to the enclosing item (in the\n-case of functions). The exact locations in which sub-items may be declared is\n-given by the grammar.\n+case of functions).\n+The grammar specifies the exact locations in which sub-item declarations may appear.\n \n ### Type Parameters\n \n-All items except modules may be *parametrized* by type. Type parameters are\n+All items except modules may be *parameterized* by type. Type parameters are\n given as a comma-separated list of identifiers enclosed in angle brackets\n-(`<...>`), after the name of the item and before its definition. The type\n-parameters of an item are considered \"part of the name\", not the type of the\n-item; in order to refer to the type-parametrized item, a referencing\n-[path](#paths) must in general provide type arguments as a list of\n-comma-separated types enclosed within angle brackets. In practice, the\n-type-inference system can usually infer such argument types from\n-context. There are no general type-parametric types, only type-parametric\n-items.\n-\n+(`<...>`), after the name of the item and before its definition.\n+The type parameters of an item are considered \"part of the name\", not part of the type of the item.\n+A referencing [path](#paths) must (in principle) provide type arguments as a list of comma-separated types enclosed within angle brackets, in order to refer to the type-parameterized item.\n+In practice, the type-inference system can usually infer such argument types from context.\n+There are no general type-parametric types, only type-parametric items.\n+That is, Rust has no notion of type abstraction: there are no first-class \"forall\" types.\n \n ### Modules\n \n@@ -763,9 +760,9 @@ mod math {\n view_item : extern_mod_decl | use_decl ;\n ~~~~~~~~\n \n-A view item manages the namespace of a module; it does not define new items\n-but simply changes the visibility of other items. There are several kinds of\n-view item:\n+A view item manages the namespace of a module.\n+View items do not define new items, but rather, simply change other items' visibilit.\n+There are several kinds of view item:\n \n  * [`extern mod` declarations](#extern-mod-declarations)\n  * [`use` declarations](#use-declarations)\n@@ -789,7 +786,7 @@ compiler's library path and matching the `link_attrs` provided in the\n crate when it was compiled. If no `link_attrs` are provided, a default `name`\n attribute is assumed, equal to the `ident` given in the `use_decl`.\n \n-Two examples of `extern mod` declarations:\n+Three examples of `extern mod` declarations:\n \n ~~~~~~~~{.xfail-test}\n extern mod pcre (uuid = \"54aba0f8-a7b1-4beb-92f1-4cf625264841\");\n@@ -844,8 +841,8 @@ fn main() {\n     log(info, Some(1.0));\n \n     // Equivalent to 'log(core::info,\n-    //                    core::str::to_upper(core::str::slice(\"foo\", 0u, 1u)));'\n-    log(info, to_upper(slice(\"foo\", 0u, 1u)));\n+    //                    core::str::to_upper(core::str::slice(\"foo\", 0, 1)));'\n+    log(info, to_upper(slice(\"foo\", 0, 1)));\n }\n ~~~~\n \n@@ -857,13 +854,9 @@ If a sequence of such redirections form a cycle or cannot be unambiguously resol\n \n ### Functions\n \n-A _function item_ defines a sequence of [statements](#statements) and an\n-optional final [expression](#expressions) associated with a name and a set of\n-parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input* [*slots*](#memory-slots) as parameters, through which the\n-caller passes arguments into the function, and an *output*\n-[*slot*](#memory-slots) through which the function passes results back to\n-the caller.\n+A _function item_ defines a sequence of [statements](#statements) and an optional final [expression](#expressions), along with a name and a set of parameters.\n+Functions are declared with the keyword `fn`.\n+Functions declare a set of *input* [*slots*](#memory-slots) as parameters, through which the caller passes arguments into the function, and an *output* [*slot*](#memory-slots) through which the function passes results back to the caller.\n \n A function may also be copied into a first class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be\n@@ -941,23 +934,19 @@ Specifically, the following operations are considered unsafe:\n \n ##### Unsafe blocks\n \n-A block of code can also be prefixed with the `unsafe` keyword,\n-to permit a sequence of unsafe operations in an otherwise-safe function.\n-This facility exists because the static semantics of a Rust are a necessary approximation of the dynamic semantics.\n-When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe,\n-they can encapsulate that sequence (taken as a whole) within an `unsafe` block.\n-The compiler will consider uses of such code \"safe\", to the surrounding context.\n+A block of code can also be prefixed with the `unsafe` keyword, to permit a sequence of unsafe operations in an otherwise-safe function.\n+This facility exists because the static semantics of Rust are a necessary approximation of the dynamic semantics.\n+When a programmer has sufficient conviction that a sequence of unsafe operations is actually safe, they can encapsulate that sequence (taken as a whole) within an `unsafe` block. The compiler will consider uses of such code \"safe\", to the surrounding context.\n \n \n #### Pure functions\n \n A pure function declaration is identical to a function declaration, except that\n it is declared with the additional keyword `pure`. In addition, the typechecker\n checks the body of a pure function with a restricted set of typechecking rules.\n-A pure function\n-\n-* may not contain an assignment or self-call expression; and\n-* may only call other pure functions, not general functions.\n+A pure function may only modify data owned by its own stack frame.\n+So, a pure function may modify a local variable allocated on the stack, but not a mutable reference that it takes as an argument.\n+A pure function may only call other pure functions, not general functions.\n \n An example of a pure function:\n \n@@ -978,36 +967,13 @@ pure fn nonempty_list<T>(ls: List<T>) -> bool { pure_length(ls) > 0u }\n These purity-checking rules approximate the concept of referential transparency:\n that a call-expression could be rewritten with the literal-expression of its return value, without changing the meaning of the program.\n Since they are an approximation, sometimes these rules are *too* restrictive.\n-Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks).\n+Rust allows programmers to violate these rules using [`unsafe` blocks](#unsafe-blocks), which we already saw.\n As with any `unsafe` block, those that violate static purity carry transfer the burden of safety-proof from the compiler to the programmer.\n Programmers should exercise caution when breaking such rules.\n \n-An example of a pure function that uses an unsafe block:\n-\n-~~~~ {.xfail-test}\n-# use std::list::*;\n-\n-fn pure_foldl<T, U: Copy>(ls: List<T>, u: U, f: fn(&T, &U) -> U) -> U {\n-    match ls {\n-      Nil => u,\n-      Cons(hd, tl) => f(hd, pure_foldl(*tl, f(hd, u), f))\n-    }\n-}\n-\n-pure fn pure_length<T>(ls: List<T>) -> uint {\n-    fn count<T>(_t: &T, u: &uint) -> uint { *u + 1u }\n-    unsafe {\n-        pure_foldl(ls, 0u, count)\n-    }\n-}\n-~~~~\n-\n-Despite its name, `pure_foldl` is a `fn`, not a `pure fn`, because there is no\n-way in Rust to specify that the higher-order function argument `f` is a pure\n-function. So, to use `foldl` in a pure list length function that a pure function\n-could then use, we must use an `unsafe` block wrapped around the call to\n-`pure_foldl` in the definition of `pure_length`.\n+For more details on purity, see [the borrowed pointer tutorial][borrow].\n \n+[borrow]: tutorial-borrowed-ptr.html\n \n #### Diverging functions\n \n@@ -1092,10 +1058,8 @@ specific type; the type-specified aspects of a value include:\n * The sequence of memory operations required to access the value.\n * The [kind](#type-kinds) of the type.\n \n-For example, the type `{x: u8, y: u8`} defines the set of immutable values\n-that are composite records, each containing two unsigned 8-bit integers\n-accessed through the components `x` and `y`, and laid out in memory with the\n-`x` component preceding the `y` component.\n+For example, the type `(u8, u8)` defines the set of immutable values that are composite pairs,\n+each containing two unsigned 8-bit integers accessed by pattern-matching and laid out in memory with the `x` component preceding the `y` component.\n \n ### Structures\n \n@@ -1111,7 +1075,7 @@ let px: int = p.x;\n \n ### Enumerations\n \n-An _enumeration_ is a simulatneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,\n+An _enumeration_ is a simultaneous definition of a nominal [enumerated type](#enumerated-types) as well as a set of *constructors*,\n that can be used to create or pattern-match values of the corresponding enumerated type.\n \n Enumerations are declared with the keyword `enum`.\n@@ -1134,7 +1098,7 @@ a = Cat;\n const_item : \"const\" ident ':' type '=' expr ';' ;\n ~~~~~~~~\n \n-A Constant is a named value stored in read-only memory in a crate.\n+A *constant* is a named value stored in read-only memory in a crate.\n The value bound to a constant is evaluated at compile time.\n Constants are declared with the `const` keyword.\n A constant item must have an expression giving its definition.\n@@ -1206,7 +1170,7 @@ let myshape: Shape = @mycircle as @Shape;\n ~~~~\n \n The resulting value is a managed box containing the value that was cast,\n-along with information that identify the methods of the implementation that was used.\n+along with information that identifies the methods of the implementation that was used.\n Values with a trait type can have [methods called](#method-call-expressions) on them,\n for any method in the trait,\n and can be used to instantiate type parameters that are bounded by the trait.\n@@ -1271,9 +1235,9 @@ foreign_mod : [ foreign_fn ] * ;\n \n Foreign modules form the basis for Rust's foreign function interface. A\n foreign module describes functions in external, non-Rust\n-libraries. Functions within foreign modules are declared the same as other\n-Rust functions, with the exception that they may not have a body and are\n-instead terminated by a semi-colon.\n+libraries.\n+Functions within foreign modules are declared in the same way as other Rust functions,\n+with the exception that they may not have a body and are instead terminated by a semicolon.\n \n ~~~\n # use libc::{c_char, FILE};\n@@ -1284,9 +1248,8 @@ extern mod c {\n }\n ~~~\n \n-Functions within foreign modules may be called by Rust code as it would any\n-normal function and the Rust compiler will automatically translate between\n-the Rust ABI and the foreign ABI.\n+Functions within foreign modules may be called by Rust code, just like functions defined in Rust.\n+The Rust compiler automatically translates between the Rust ABI and the foreign ABI.\n \n The name of the foreign module has special meaning to the Rust compiler in\n that it will treat the module name as the name of a library to link to,\n@@ -1300,7 +1263,7 @@ A number of [attributes](#attributes) control the behavior of foreign\n modules.\n \n By default foreign modules assume that the library they are calling use the\n-standard C \"cdecl\" ABI. Other ABI's may be specified using the `abi`\n+standard C \"cdecl\" ABI. Other ABIs may be specified using the `abi`\n attribute as in\n \n ~~~{.xfail-test}\n@@ -1310,15 +1273,15 @@ extern mod kernel32 { }\n ~~~\n \n The `link_name` attribute allows the default library naming behavior to\n-be overriden by explicitly specifying the name of the library.\n+be overridden by explicitly specifying the name of the library.\n \n ~~~{.xfail-test}\n #[link_name = \"crypto\"]\n extern mod mycrypto { }\n ~~~\n \n-The `nolink` attribute tells the Rust compiler not to perform any linking\n-for the foreign module. This is particularly useful for creating foreign\n+The `nolink` attribute tells the Rust compiler not to do any linking for the foreign module.\n+This is particularly useful for creating foreign\n modules for libc, which tends to not follow standard library naming\n conventions and is linked to all Rust programs anyway.\n \n@@ -1333,9 +1296,9 @@ attr : ident [ '=' literal\n \n Static entities in Rust -- crates, modules and items -- may have _attributes_\n applied to them. ^[Attributes in Rust are modeled on Attributes in ECMA-335,\n-C#] An attribute is a general, free-form piece of metadata that is interpreted\n-according to name, convention, and language and compiler version.  Attributes\n-may appear as any of:\n+C#]\n+An attribute is a general, free-form metadatum that is interpreted according to name, convention, and language and compiler version.\n+Attributes may appear as any of\n \n * A single identifier, the attribute name\n * An identifier followed by the equals sign '=' and a literal, providing a key/value pair"}]}