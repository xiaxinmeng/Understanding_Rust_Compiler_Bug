{"sha": "5dd07b66ffc8d21b9d73c99def588ff8b2242974", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZDA3YjY2ZmZjOGQyMWI5ZDczYzk5ZGVmNTg4ZmY4YjIyNDI5NzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-05T06:01:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-05T06:01:24Z"}, "message": "Auto merge of #38756 - Mark-Simulacrum:2nd-trans-cleanup, r=eddyb\n\nAdditional cleanup to rustc_trans\n\nRemoves `BlockAndBuilder`, `FunctionContext`, and `MaybeSizedValue`.\n\n`LvalueRef` is used instead of `MaybeSizedValue`, which has the added benefit of making functions operating on `Lvalue`s be able to take just that (since it encodes the type with an `LvalueTy`, which can carry discriminant information) instead of a `MaybeSizedValue` and a discriminant.\n\nr? @eddyb", "tree": {"sha": "aeabb85bda3cf1cd22f7332c9fb5b04007a7822b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aeabb85bda3cf1cd22f7332c9fb5b04007a7822b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5dd07b66ffc8d21b9d73c99def588ff8b2242974", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd07b66ffc8d21b9d73c99def588ff8b2242974", "html_url": "https://github.com/rust-lang/rust/commit/5dd07b66ffc8d21b9d73c99def588ff8b2242974", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5dd07b66ffc8d21b9d73c99def588ff8b2242974/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80745e2a2323d47756c2afdd0d2584094ce35604", "url": "https://api.github.com/repos/rust-lang/rust/commits/80745e2a2323d47756c2afdd0d2584094ce35604", "html_url": "https://github.com/rust-lang/rust/commit/80745e2a2323d47756c2afdd0d2584094ce35604"}, {"sha": "b01b6e1d5664a1ebaf0e9264be5dddbbc8b4996b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b01b6e1d5664a1ebaf0e9264be5dddbbc8b4996b", "html_url": "https://github.com/rust-lang/rust/commit/b01b6e1d5664a1ebaf0e9264be5dddbbc8b4996b"}], "stats": {"total": 1736, "additions": 787, "deletions": 949}, "files": [{"sha": "ad4bb0fce22ad699922cb2b627f1bd54f7399a44", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -10,7 +10,8 @@\n \n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n-use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n+use builder::Builder;\n+use common::{type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -236,7 +237,7 @@ impl ArgType {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &BlockAndBuilder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -269,7 +270,7 @@ impl ArgType {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.fcx().alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\");\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n@@ -293,14 +294,14 @@ impl ArgType {\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &BlockAndBuilder, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder, idx: &mut usize, dst: ValueRef) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n         if self.is_ignore() {\n             return;\n         }\n-        let val = llvm::get_param(bcx.fcx().llfn, *idx as c_uint);\n+        let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n         *idx += 1;\n         self.store(bcx, val, dst);\n     }"}, {"sha": "c3b9a56ac9778569b4d1e4e835ff2571fbcae58d", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 12, "deletions": 366, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -49,53 +49,20 @@ use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n use common::*;\n-use glue;\n+use builder::Builder;\n use base;\n use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n-use value::Value;\n-\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum BranchKind {\n-    Switch,\n-    Single\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct MaybeSizedValue {\n-    pub value: ValueRef,\n-    pub meta: ValueRef,\n-}\n-\n-impl MaybeSizedValue {\n-    pub fn sized(value: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: std::ptr::null_mut()\n-        }\n-    }\n-\n-    pub fn unsized_(value: ValueRef, meta: ValueRef) -> MaybeSizedValue {\n-        MaybeSizedValue {\n-            value: value,\n-            meta: meta\n-        }\n-    }\n-\n-    pub fn has_meta(&self) -> bool {\n-        !self.meta.is_null()\n-    }\n-}\n \n /// Given an enum, struct, closure, or tuple, extracts fields.\n /// Treats closures as a struct with one variant.\n /// `empty_if_no_variants` is a switch to deal with empty enums.\n /// If true, `variant_index` is disregarded and an empty Vec returned in this case.\n-fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                            variant_index: usize,\n-                            empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n+pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n+                                variant_index: usize,\n+                                empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n     match t.sty {\n         ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n             Vec::default()\n@@ -300,28 +267,6 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>\n     }\n }\n \n-/// Obtain a representation of the discriminant sufficient to translate\n-/// destructuring; this may or may not involve the actual discriminant.\n-pub fn trans_switch<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    scrutinee: ValueRef,\n-    range_assert: bool\n-) -> (BranchKind, Option<ValueRef>) {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { .. } | layout::General { .. } |\n-        layout::RawNullablePointer { .. } | layout::StructWrappedNullablePointer { .. } => {\n-            (BranchKind::Switch, Some(trans_get_discr(bcx, t, scrutinee, None, range_assert)))\n-        }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => {\n-            // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n-            (BranchKind::Single, None)\n-        },\n-        _ => bug!(\"{} is not an enum.\", t)\n-    }\n-}\n-\n pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n     match *l {\n         layout::CEnum { signed, .. }=> signed,\n@@ -331,7 +276,7 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n \n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     scrutinee: ValueRef,\n     cast_to: Option<Type>,\n@@ -358,7 +303,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx,\n-                monomorphize::field_ty(bcx.ccx.tcx(), substs,\n+                monomorphize::field_ty(bcx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]));\n             bcx.icmp(cmp, bcx.load(scrutinee), C_null(llptrty))\n         }\n@@ -374,7 +319,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n }\n \n fn struct_wrapped_nullable_bitdiscr(\n-    bcx: &BlockAndBuilder,\n+    bcx: &Builder,\n     nndiscr: u64,\n     discrfield: &layout::FieldPath,\n     scrutinee: ValueRef\n@@ -387,7 +332,7 @@ fn struct_wrapped_nullable_bitdiscr(\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n+fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n     let llty = Type::from_integer(bcx.ccx, ity);\n@@ -415,7 +360,7 @@ fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n+pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n@@ -435,9 +380,7 @@ pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value:\n \n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n-pub fn trans_set_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n-) {\n+pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum{ discr, min, max, .. } => {\n@@ -484,315 +427,18 @@ pub fn trans_set_discr<'a, 'tcx>(\n     }\n }\n \n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>) -> bool {\n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n     bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n }\n \n-fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n+pub fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n     } else {\n         assert!(min <= discr || discr <= max)\n     }\n }\n \n-/// Access a field, at a point when the value's case is known.\n-pub fn trans_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    val: MaybeSizedValue,\n-    discr: Disr,\n-    ix: usize\n-) -> ValueRef {\n-    let l = bcx.ccx.layout_of(t);\n-    debug!(\"trans_field_ptr on {} represented as {:#?}\", t, l);\n-    // Note: if this ever needs to generate conditionals (e.g., if we\n-    // decide to do some kind of cdr-coding-like non-unique repr\n-    // someday), it will need to return a possibly-new bcx as well.\n-    match *l {\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n-            struct_field_ptr(bcx, &variant,\n-             &compute_fields(bcx.ccx, t, 0, false),\n-             val, ix, false)\n-        }\n-        layout::Vector { count, .. } => {\n-            assert_eq!(discr.0, 0);\n-            assert!((ix as u64) < count);\n-            bcx.struct_gep(val.value, ix)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let mut fields = compute_fields(bcx.ccx, t, discr.0 as usize, false);\n-            fields.insert(0, d.to_ty(&bcx.ccx.tcx(), false));\n-            struct_field_ptr(bcx, &variants[discr.0 as usize],\n-             &fields,\n-             val, ix + 1, true)\n-        }\n-        layout::UntaggedUnion { .. } => {\n-            let fields = compute_fields(bcx.ccx, t, 0, false);\n-            let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } |\n-        layout::StructWrappedNullablePointer { nndiscr,  .. } if discr.0 != nndiscr => {\n-            let nullfields = compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n-            // The unit-like case might have a nonzero number of unit-like fields.\n-            // (e.d., Result of Either with (), as one side.)\n-            let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n-            assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n-            assert_eq!(ix, 0);\n-            assert_eq!(discr.0, nndiscr);\n-            let ty = type_of::type_of(bcx.ccx, nnty);\n-            bcx.pointercast(val.value, ty.ptr_to())\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            assert_eq!(discr.0, nndiscr);\n-            struct_field_ptr(bcx, &nonnull,\n-             &compute_fields(bcx.ccx, t, discr.0 as usize, false),\n-             val, ix, false)\n-        }\n-        _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn struct_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    st: &layout::Struct,\n-    fields: &Vec<Ty<'tcx>>,\n-    val: MaybeSizedValue,\n-    ix: usize,\n-    needs_cast: bool\n-) -> ValueRef {\n-    let fty = fields[ix];\n-    let ccx = bcx.ccx;\n-\n-    let ptr_val = if needs_cast {\n-        let fields = st.field_index_by_increasing_offset().map(|i| {\n-            type_of::in_memory_type_of(ccx, fields[i])\n-        }).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n-        bcx.pointercast(val.value, real_ty.ptr_to())\n-    } else {\n-        val.value\n-    };\n-\n-    // Simple case - we can just GEP the field\n-    //   * First field - Always aligned properly\n-    //   * Packed struct - There is no alignment padding\n-    //   * Field is sized - pointer is properly aligned already\n-    if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-        bcx.ccx.shared().type_is_sized(fty) {\n-        return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-    }\n-\n-    // If the type of the last field is [T] or str, then we don't need to do\n-    // any adjusments\n-    match fty.sty {\n-        ty::TySlice(..) | ty::TyStr => {\n-            return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n-        }\n-        _ => ()\n-    }\n-\n-    // There's no metadata available, log the case and just do the GEP.\n-    if !val.has_meta() {\n-        debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n-               ix, Value(ptr_val));\n-        return bcx.struct_gep(ptr_val, ix);\n-    }\n-\n-    // We need to get the pointer manually now.\n-    // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n-    // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n-    // because the field may have an arbitrary alignment in the LLVM representation\n-    // anyway.\n-    //\n-    // To demonstrate:\n-    //   struct Foo<T: ?Sized> {\n-    //      x: u16,\n-    //      y: T\n-    //   }\n-    //\n-    // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n-    // the `y` field has 16-bit alignment.\n-\n-    let meta = val.meta;\n-\n-\n-    let offset = st.offsets[ix].bytes();\n-    let unaligned_offset = C_uint(bcx.ccx, offset);\n-\n-    // Get the alignment of the field\n-    let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n-\n-    // Bump the unaligned offset up to the appropriate alignment using the\n-    // following expression:\n-    //\n-    //   (unaligned offset + (align - 1)) & -align\n-\n-    // Calculate offset\n-    let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n-    let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n-                         bcx.neg(align));\n-\n-    debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n-\n-    // Cast and adjust pointer\n-    let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n-    let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n-\n-    // Finally, cast back to the type expected\n-    let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n-    debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n-    bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n-}\n-\n-/// Construct a constant value, suitable for initializing a\n-/// GlobalVariable, given a case and constant values for its fields.\n-/// Note that this may have a different LLVM type (and different\n-/// alignment!) from the representation's `type_of`, so it needs a\n-/// pointer cast before use.\n-///\n-/// The LLVM type system does not directly support unions, and only\n-/// pointers can be bitcast, so a constant (and, by extension, the\n-/// GlobalVariable initialized by it) will have a type that can vary\n-/// depending on which case of an enum it is.\n-///\n-/// To understand the alignment situation, consider `enum E { V64(u64),\n-/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n-/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n-/// i32, i32}`, which is 4-byte aligned.\n-///\n-/// Currently the returned value has the same size as the type, but\n-/// this could be changed in the future to avoid allocating unnecessary\n-/// space after values of shorter-than-maximum cases.\n-pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>, discr: Disr,\n-                             vals: &[ValueRef]) -> ValueRef {\n-    let l = ccx.layout_of(t);\n-    let dl = &ccx.tcx().data_layout;\n-    match *l {\n-        layout::CEnum { discr: d, min, max, .. } => {\n-            assert_eq!(vals.len(), 0);\n-            assert_discr_in_range(Disr(min), Disr(max), discr);\n-            C_integral(Type::from_integer(ccx, d), discr.0, true)\n-        }\n-        layout::General { discr: d, ref variants, .. } => {\n-            let variant = &variants[discr.0 as usize];\n-            let lldiscr = C_integral(Type::from_integer(ccx, d), discr.0 as u64, true);\n-            let mut vals_with_discr = vec![lldiscr];\n-            vals_with_discr.extend_from_slice(vals);\n-            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n-            if needed_padding > 0 {\n-                contents.push(padding(ccx, needed_padding));\n-            }\n-            C_struct(ccx, &contents[..], false)\n-        }\n-        layout::UntaggedUnion { ref variants, .. }=> {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_union(ccx, variants, vals[0]);\n-            C_struct(ccx, &contents, variants.packed)\n-        }\n-        layout::Univariant { ref variant, .. } => {\n-            assert_eq!(discr, Disr(0));\n-            let contents = build_const_struct(ccx, &variant, vals);\n-            C_struct(ccx, &contents[..], variant.packed)\n-        }\n-        layout::Vector { .. } => {\n-            C_vector(vals)\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(ccx, t, nndiscr as usize, false)[0];\n-            if discr.0 == nndiscr {\n-                assert_eq!(vals.len(), 1);\n-                vals[0]\n-            } else {\n-                C_null(type_of::sizing_type_of(ccx, nnty))\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-            if discr.0 == nndiscr {\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n-            } else {\n-                let fields = compute_fields(ccx, t, nndiscr as usize, false);\n-                let vals = fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `discrfield`th\n-                    // field; see #8506.\n-                    C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n-            }\n-        }\n-        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n-    }\n-}\n-\n-/// Building structs is a little complicated, because we might need to\n-/// insert padding if a field's value is less aligned than its type.\n-///\n-/// Continuing the example from `trans_const`, a value of type `(u32,\n-/// E)` should have the `E` at offset 8, but if that field's\n-/// initializer is 4-byte aligned then simply translating the tuple as\n-/// a two-element struct will locate it at offset 4, and accesses to it\n-/// will read the wrong memory.\n-fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                st: &layout::Struct,\n-                                vals: &[ValueRef])\n-                                -> Vec<ValueRef> {\n-    assert_eq!(vals.len(), st.offsets.len());\n-\n-    if vals.len() == 0 {\n-        return Vec::new();\n-    }\n-\n-    // offset of current value\n-    let mut offset = 0;\n-    let mut cfields = Vec::new();\n-    cfields.reserve(st.offsets.len()*2);\n-\n-    let parts = st.field_index_by_increasing_offset().map(|i| {\n-        (&vals[i], st.offsets[i].bytes())\n-    });\n-    for (&val, target_offset) in parts {\n-        if offset < target_offset {\n-            cfields.push(padding(ccx, target_offset - offset));\n-            offset = target_offset;\n-        }\n-        assert!(!is_undef(val));\n-        cfields.push(val);\n-        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n-    }\n-\n-    if offset < st.stride().bytes() {\n-        cfields.push(padding(ccx, st.stride().bytes() - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               un: &layout::Union,\n-                               field_val: ValueRef)\n-                               -> Vec<ValueRef> {\n-    let mut cfields = vec![field_val];\n-\n-    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n-    let size = un.stride().bytes();\n-    if offset != size {\n-        cfields.push(padding(ccx, size - offset));\n-    }\n-\n-    cfields\n-}\n-\n-fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n-    C_undef(Type::array(&Type::i8(ccx), size))\n-}\n-\n // FIXME this utility routine should be somewhere more general\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }"}, {"sha": "c95d414701876ef6a4d4c9e19d57b12925db5bc5", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -15,6 +15,7 @@ use base;\n use common::*;\n use type_of;\n use type_::Type;\n+use builder::Builder;\n \n use rustc::hir;\n use rustc::ty::Ty;\n@@ -25,7 +26,7 @@ use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<(ValueRef, Ty<'tcx>)>,\n     mut inputs: Vec<ValueRef>"}, {"sha": "4cdde24ed48b568a1f69c6cd4690cc62f29ce010", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -37,8 +37,9 @@ use llvm;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::StartFnLangItem;\n use rustc::ty::subst::Substs;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n@@ -47,14 +48,15 @@ use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n+use mir::lvalue::LvalueRef;\n use adt;\n use attributes;\n use builder::Builder;\n use callee::{Callee};\n-use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -161,7 +163,7 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n }\n \n pub fn compare_simd_types<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n@@ -218,7 +220,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     src: ValueRef,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n@@ -242,7 +244,7 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                      src: ValueRef,\n                                      src_ty: Ty<'tcx>,\n                                      dst: ValueRef,\n@@ -278,17 +280,17 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 monomorphize::field_ty(bcx.tcx(), substs_b, f)\n             });\n \n-            let src = adt::MaybeSizedValue::sized(src);\n-            let dst = adt::MaybeSizedValue::sized(dst);\n+            let src = LvalueRef::new_sized_ty(src, src_ty);\n+            let dst = LvalueRef::new_sized_ty(dst, dst_ty);\n \n             let iter = src_fields.zip(dst_fields).enumerate();\n             for (i, (src_fty, dst_fty)) in iter {\n                 if type_is_zero_size(bcx.ccx, dst_fty) {\n                     continue;\n                 }\n \n-                let src_f = adt::trans_field_ptr(bcx, src_ty, src, Disr(0), i);\n-                let dst_f = adt::trans_field_ptr(bcx, dst_ty, dst, Disr(0), i);\n+                let src_f = src.trans_field_ptr(bcx, i);\n+                let dst_f = dst.trans_field_ptr(bcx, i);\n                 if src_fty == dst_fty {\n                     memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n@@ -322,7 +324,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &BlockAndBuilder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+    cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n@@ -421,7 +423,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n+pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.ccx, t) {\n@@ -433,7 +435,7 @@ pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: Valu\n     }\n }\n \n-pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n                                data: ValueRef,\n                                extra: ValueRef,\n                                dst: ValueRef,\n@@ -459,15 +461,15 @@ pub fn load_fat_ptr<'a, 'tcx>(\n     (ptr, meta)\n }\n \n-pub fn from_immediate(bcx: &BlockAndBuilder, val: ValueRef) -> ValueRef {\n+pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     if val_ty(val) == Type::i1(bcx.ccx) {\n         bcx.zext(val, Type::i8(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n@@ -523,11 +525,13 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                           dst: ValueRef,\n-                           src: ValueRef,\n-                           t: Ty<'tcx>,\n-                           align: Option<u32>) {\n+pub fn memcpy_ty<'a, 'tcx>(\n+    bcx: &Builder<'a, 'tcx>,\n+    dst: ValueRef,\n+    src: ValueRef,\n+    t: Ty<'tcx>,\n+    align: Option<u32>,\n+) {\n     let ccx = bcx.ccx;\n \n     if type_is_zero_size(ccx, t) {\n@@ -553,11 +557,6 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    assert!(!ty.has_param_types());\n-    bcx.fcx().alloca(type_of::type_of(bcx.ccx, ty), name)\n-}\n-\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n@@ -593,43 +592,47 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, lldecl);\n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(&fcx, fn_ty, &mir, instance, &sig, abi);\n+    mir::trans_mir(ccx, lldecl, fn_ty, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n                                  disr: Disr,\n-                                 llfndecl: ValueRef) {\n-    attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n-    attributes::set_frame_pointer_elimination(ccx, llfndecl);\n+                                 llfn: ValueRef) {\n+    attributes::inline(llfn, attributes::InlineAttr::Hint);\n+    attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, llfndecl);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n     if !fn_ty.ret.is_ignore() {\n         // But if there are no nested returns, we skip the indirection\n         // and have a single retslot\n         let dest = if fn_ty.ret.is_indirect() {\n-            get_param(fcx.llfn, 0)\n+            get_param(llfn, 0)\n         } else {\n             // We create an alloca to hold a pointer of type `ret.original_ty`\n             // which will hold the pointer to the right alloca which has the\n             // final ret value\n-            fcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+            bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+        };\n+        // Can return unsized value\n+        let mut dest_val = LvalueRef::new_sized_ty(dest, sig.output());\n+        dest_val.ty = LvalueTy::Downcast {\n+            adt_def: sig.output().ty_adt_def().unwrap(),\n+            substs: substs,\n+            variant_index: disr.0 as usize,\n         };\n-        let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n         let mut arg_idx = 0;\n         for (i, arg_ty) in sig.inputs().iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(&bcx, sig.output(), dest_val, Disr::from(disr), i);\n+            let lldestptr = dest_val.trans_field_ptr(&bcx, i);\n             let arg = &fn_ty.args[arg_idx];\n             arg_idx += 1;\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n@@ -756,12 +759,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         // `main` should respect same config for frame pointer elimination as rest of code\n         attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-        let llbb = unsafe {\n-            let name = CString::new(\"top\").unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, name.as_ptr())\n-        };\n-        let bld = Builder::with_ccx(ccx);\n-        bld.position_at_end(llbb);\n+        let bld = Builder::new_block(ccx, llfn, \"top\");\n \n         debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n "}, {"sha": "cf7f3e9501d1a6e677a2576eac5e93681c4f84f4", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -19,12 +19,17 @@ use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n+use rustc::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc::session::Session;\n+use type_of;\n \n use std::borrow::Cow;\n use std::ffi::CString;\n use std::ptr;\n use syntax_pos::Span;\n \n+// All Builders must have an llfn associated with them\n+#[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n@@ -46,6 +51,20 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+        let builder = Builder::with_ccx(ccx);\n+        let llbb = unsafe {\n+            let name = CString::new(name).unwrap();\n+            llvm::LLVMAppendBasicBlockInContext(\n+                ccx.llcx(),\n+                llfn,\n+                name.as_ptr()\n+            )\n+        };\n+        builder.position_at_end(llbb);\n+        builder\n+    }\n+\n     pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n@@ -57,6 +76,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn build_sibling_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn(), name)\n+    }\n+\n+    pub fn sess(&self) -> &Session {\n+        self.ccx.sess()\n+    }\n+\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.ccx.tcx()\n+    }\n+\n+    pub fn llfn(&self) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMGetBasicBlockParent(self.llbb())\n+        }\n+    }\n+\n+    pub fn llbb(&self) -> BasicBlockRef {\n+        unsafe {\n+            llvm::LLVMGetInsertBlock(self.llbuilder)\n+        }\n+    }\n+\n     fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n             self.ccx.stats().n_llvm_insns.set(self.ccx.stats().n_llvm_insns.get() + 1);\n@@ -435,6 +478,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_start(unsafe {\n+            llvm::LLVMGetFirstBasicBlock(self.llfn())\n+        });\n+        builder.dynamic_alloca(ty, name)\n+    }\n+\n+    pub fn alloca_ty(&self, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+        assert!(!ty.has_param_types());\n+        self.alloca(type_of::type_of(self.ccx, ty), name)\n+    }\n+\n     pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {"}, {"sha": "257d6c01e4a653fda7d79997cfd243b7b32bb620", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -23,11 +23,10 @@ use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n use base;\n-use base::*;\n-use common::{\n-    self, CrateContext, FunctionContext, SharedCrateContext\n-};\n-use adt::MaybeSizedValue;\n+use builder::Builder;\n+use common::{self, CrateContext, SharedCrateContext};\n+use cleanup::CleanupScope;\n+use mir::lvalue::LvalueRef;\n use consts;\n use declare;\n use value::Value;\n@@ -330,8 +329,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let orig_fn_ty = fn_ty;\n-    let fcx = FunctionContext::new(ccx, lloncefn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::new_block(ccx, lloncefn, \"entry-block\");\n \n     let callee = Callee {\n         data: Fn(llreffn),\n@@ -340,15 +338,15 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(lloncefn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n     let env_arg = &orig_fn_ty.args[0];\n     let llenv = if env_arg.is_indirect() {\n         llargs[self_idx]\n     } else {\n-        let scratch = alloc_ty(&bcx, closure_ty, \"self\");\n+        let scratch = bcx.alloca_ty(closure_ty, \"self\");\n         let mut llarg_idx = self_idx;\n         env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch);\n         scratch\n@@ -365,12 +363,14 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(MaybeSizedValue::sized(llenv), closure_ty);\n+    let self_scope = CleanupScope::schedule_drop_mem(\n+        &bcx, LvalueRef::new_sized_ty(llenv, closure_ty)\n+    );\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;\n     if let Some(landing_pad) = self_scope.landing_pad {\n-        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n         llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {\n@@ -489,10 +489,9 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n \n     let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {"}, {"sha": "5d89a67d3fd80890029273f3c6b01bfc64c406ac", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -20,11 +20,12 @@\n \n use llvm::BasicBlockRef;\n use base;\n-use adt::MaybeSizedValue;\n-use common::{BlockAndBuilder, FunctionContext, Funclet};\n+use mir::lvalue::LvalueRef;\n+use rustc::mir::tcx::LvalueTy;\n+use builder::Builder;\n+use common::Funclet;\n use glue;\n use type_::Type;\n-use rustc::ty::Ty;\n \n pub struct CleanupScope<'tcx> {\n     // Cleanup to run upon scope exit.\n@@ -36,14 +37,13 @@ pub struct CleanupScope<'tcx> {\n \n #[derive(Copy, Clone)]\n pub struct DropValue<'tcx> {\n-    val: MaybeSizedValue,\n-    ty: Ty<'tcx>,\n+    val: LvalueRef<'tcx>,\n     skip_dtor: bool,\n }\n \n impl<'tcx> DropValue<'tcx> {\n-    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n-        glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n+    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n+        glue::call_drop_glue(bcx, self.val, self.skip_dtor, funclet)\n     }\n \n     /// Creates a landing pad for the top scope. The landing pad will perform all cleanups necessary\n@@ -52,13 +52,13 @@ impl<'tcx> DropValue<'tcx> {\n     ///     landing_pad -> ... cleanups ... -> [resume]\n     ///\n     /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n+    fn get_landing_pad<'a>(&self, bcx: &Builder<'a, 'tcx>) -> BasicBlockRef {\n         debug!(\"get_landing_pad\");\n-        let bcx = fcx.build_new_block(\"cleanup_unwind\");\n+        let bcx = bcx.build_sibling_block(\"cleanup_unwind\");\n         let llpersonality = bcx.ccx.eh_personality();\n         bcx.set_personality_fn(llpersonality);\n \n-        if base::wants_msvc_seh(fcx.ccx.sess()) {\n+        if base::wants_msvc_seh(bcx.sess()) {\n             let pad = bcx.cleanup_pad(None, &[]);\n             let funclet = Some(Funclet::new(pad));\n             self.trans(funclet.as_ref(), &bcx);\n@@ -68,10 +68,10 @@ impl<'tcx> DropValue<'tcx> {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n+            let llretty = Type::struct_(bcx.ccx, &[Type::i8p(bcx.ccx), Type::i32(bcx.ccx)], false);\n \n             // The only landing pad clause will be 'cleanup'\n-            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n+            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.llfn());\n \n             // The landing pad block is a cleanup\n             bcx.set_cleanup(llretval);\n@@ -92,46 +92,55 @@ impl<'tcx> DropValue<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+impl<'a, 'tcx> CleanupScope<'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(&self, val: MaybeSizedValue, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+    pub fn schedule_drop_mem(\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n+    ) -> CleanupScope<'tcx> {\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: false,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: MaybeSizedValue, ty: Ty<'tcx>)\n-        -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_adt_contents(\n+        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n+    ) -> CleanupScope<'tcx> {\n+        if let LvalueTy::Downcast { .. } = val.ty {\n+            bug!(\"Cannot drop downcast ty yet\");\n+        }\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n+            return CleanupScope::noop();\n+        }\n \n         let drop = DropValue {\n             val: val,\n-            ty: ty,\n             skip_dtor: true,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n-}\n \n-impl<'tcx> CleanupScope<'tcx> {\n-    fn new<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n+    fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n-            landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n-                Some(drop_val.get_landing_pad(fcx))\n+            landing_pad: if !bcx.sess().no_landing_pads() {\n+                Some(drop_val.get_landing_pad(bcx))\n             } else {\n                 None\n             },\n@@ -145,7 +154,7 @@ impl<'tcx> CleanupScope<'tcx> {\n         }\n     }\n \n-    pub fn trans<'a>(self, bcx: &'a BlockAndBuilder<'a, 'tcx>) {\n+    pub fn trans(self, bcx: &'a Builder<'a, 'tcx>) {\n         if let Some(cleanup) = self.cleanup {\n             cleanup.trans(None, &bcx);\n         }"}, {"sha": "13163518f941ec710875127a62f3a94b3fca34e7", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 6, "deletions": 195, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -12,11 +12,9 @@\n \n //! Code that is useful in various trans modules.\n \n-use session::Session;\n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n+use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n-use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::util::common::MemoizationMap;\n@@ -37,11 +35,9 @@ use rustc::hir;\n use libc::{c_uint, c_char};\n use std::borrow::Cow;\n use std::iter;\n-use std::ops::Deref;\n-use std::ffi::CString;\n \n use syntax::ast;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use syntax_pos::Span;\n \n use rustc_i128::u128;\n@@ -172,191 +168,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n *\n */\n \n-use Disr;\n-\n-/// The concrete version of ty::FieldDef. The name is the field index if\n-/// the field is numeric.\n-pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n-\n-/// The concrete version of ty::VariantDef\n-pub struct VariantInfo<'tcx> {\n-    pub discr: Disr,\n-    pub fields: Vec<Field<'tcx>>\n-}\n-\n-impl<'a, 'tcx> VariantInfo<'tcx> {\n-    pub fn from_ty(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   ty: Ty<'tcx>,\n-                   opt_def: Option<Def>)\n-                   -> Self\n-    {\n-        match ty.sty {\n-            ty::TyAdt(adt, substs) => {\n-                let variant = match opt_def {\n-                    None => adt.struct_variant(),\n-                    Some(def) => adt.variant_of_def(def)\n-                };\n-\n-                VariantInfo {\n-                    discr: Disr::from(variant.disr_val),\n-                    fields: variant.fields.iter().map(|f| {\n-                        Field(f.name, monomorphize::field_ty(tcx, substs, f))\n-                    }).collect()\n-                }\n-            }\n-\n-            ty::TyTuple(ref v) => {\n-                VariantInfo {\n-                    discr: Disr(0),\n-                    fields: v.iter().enumerate().map(|(i, &t)| {\n-                        Field(Symbol::intern(&i.to_string()), t)\n-                    }).collect()\n-                }\n-            }\n-\n-            _ => {\n-                bug!(\"cannot get field types from the type {:?}\", ty);\n-            }\n-        }\n-    }\n-}\n-\n-// Function context. Every LLVM function we create will have one of these.\n-pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-    // address of the first instruction in the sequence of\n-    // instructions for this function that will go in the .text\n-    // section of the executable we're generating.\n-    pub llfn: ValueRef,\n-\n-    // A marker for the place where we want to insert the function's static\n-    // allocas, so that LLVM will coalesce them into a single alloca call.\n-    alloca_insert_pt: Option<ValueRef>,\n-\n-    // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-\n-    alloca_builder: Builder<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    /// Create a function context for the given function.\n-    /// Call FunctionContext::get_entry_block for the first entry block.\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, llfndecl: ValueRef) -> FunctionContext<'a, 'tcx> {\n-        let mut fcx = FunctionContext {\n-            llfn: llfndecl,\n-            alloca_insert_pt: None,\n-            ccx: ccx,\n-            alloca_builder: Builder::with_ccx(ccx),\n-        };\n-\n-        let val = {\n-            let entry_bcx = fcx.build_new_block(\"entry-block\");\n-            let val = entry_bcx.load(C_null(Type::i8p(ccx)));\n-            fcx.alloca_builder.position_at_start(entry_bcx.llbb());\n-            val\n-        };\n-\n-        // Use a dummy instruction as the insertion point for all allocas.\n-        // This is later removed in the drop of FunctionContext.\n-        fcx.alloca_insert_pt = Some(val);\n-\n-        fcx\n-    }\n-\n-    pub fn get_entry_block(&'a self) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(unsafe {\n-            llvm::LLVMGetFirstBasicBlock(self.llfn)\n-        }, self)\n-    }\n-\n-    pub fn new_block(&'a self, name: &str) -> BasicBlockRef {\n-        unsafe {\n-            let name = CString::new(name).unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(\n-                self.ccx.llcx(),\n-                self.llfn,\n-                name.as_ptr()\n-            )\n-        }\n-    }\n-\n-    pub fn build_new_block(&'a self, name: &str) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.new_block(name), self)\n-    }\n-\n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n-        self.alloca_builder.dynamic_alloca(ty, name)\n-    }\n-}\n-\n-impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n-        }\n-    }\n-}\n-\n-#[must_use]\n-pub struct BlockAndBuilder<'a, 'tcx: 'a> {\n-    // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-    // block to the function pointed to by llfn.  We insert\n-    // instructions into that block by way of this block context.\n-    // The block pointing to this one in the function's digraph.\n-    llbb: BasicBlockRef,\n-\n-    // The function context for the function to which this block is\n-    // attached.\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n-\n-    builder: Builder<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef, fcx: &'a FunctionContext<'a, 'tcx>) -> Self {\n-        let builder = Builder::with_ccx(fcx.ccx);\n-        // Set the builder's position to this block's end.\n-        builder.position_at_end(llbb);\n-        BlockAndBuilder {\n-            llbb: llbb,\n-            fcx: fcx,\n-            builder: builder,\n-        }\n-    }\n-\n-    pub fn at_start<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n-    {\n-        self.position_at_start(self.llbb);\n-        let r = f(self);\n-        self.position_at_end(self.llbb);\n-        r\n-    }\n-\n-    pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n-        self.fcx\n-    }\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'a Session {\n-        self.ccx.sess()\n-    }\n-\n-    pub fn llbb(&self) -> BasicBlockRef {\n-        self.llbb\n-    }\n-}\n-\n-impl<'a, 'tcx> Deref for BlockAndBuilder<'a, 'tcx> {\n-    type Target = Builder<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.builder\n-    }\n-}\n-\n /// A structure representing an active landing pad for the duration of a basic\n /// block.\n ///\n@@ -725,7 +536,7 @@ pub fn langcall(tcx: TyCtxt,\n // of Java. (See related discussion on #1877 and #10183.)\n \n pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n@@ -736,7 +547,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n }\n \n pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+    bcx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n@@ -749,13 +560,13 @@ pub fn build_unchecked_rshift<'a, 'tcx>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n     bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n }\n \n pub fn shift_mask_val<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     llty: Type,\n     mask_llty: Type,\n     invert: bool"}, {"sha": "c6f8ba7b6dc78d79c5fdcb2f7955e086c24c1b27", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -14,7 +14,7 @@ use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -71,7 +71,7 @@ pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &Funct\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+        make_mir_scope(ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n     }\n \n     scopes"}, {"sha": "7a739071506dbe2f3b1c933d92dd4d4ef96f6b70", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -45,7 +45,7 @@\n //!\n //! All private state used by the module is stored within either the\n //! CrateDebugContext struct (owned by the CrateContext) or the\n-//! FunctionDebugContext (owned by the FunctionContext).\n+//! FunctionDebugContext (owned by the MirContext).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module"}, {"sha": "9117f49cf3ea5b8aaa3ec3fc0a343df1e0113a81", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -27,7 +27,8 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::{CrateContext, BlockAndBuilder};\n+use common::CrateContext;\n+use builder::Builder;\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n@@ -423,7 +424,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                dbg_context: &FunctionDebugContext,\n                                variable_name: ast::Name,\n                                variable_type: Ty<'tcx>,"}, {"sha": "e99e26261a3a1017d366f2a4af32142c1e358866", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -38,7 +38,7 @@ pub fn set_source_location(\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", builder.ccx.sess().codemap().span_to_string(span));\n+        debug!(\"set_source_location: {}\", builder.sess().codemap().span_to_string(span));\n         let loc = span_start(builder.ccx, span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {"}, {"sha": "4fe07c9b86abfa738fcd01b53b5a3c2f2a9cb3b5", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 94, "deletions": 73, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -13,18 +13,22 @@\n // Code relating to drop glue.\n \n use std;\n+use std::ptr;\n use std::iter;\n \n use llvm;\n use llvm::{ValueRef, get_param};\n use middle::lang_items::BoxFreeFnLangItem;\n use rustc::ty::subst::{Substs};\n use rustc::traits;\n-use rustc::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc::ty::{self, layout, AdtDef, AdtKind, Ty, TypeFoldable};\n use rustc::ty::subst::Kind;\n-use adt::{self, MaybeSizedValue};\n+use rustc::mir::tcx::LvalueTy;\n+use mir::lvalue::LvalueRef;\n+use adt;\n use base::*;\n use callee::Callee;\n+use cleanup::CleanupScope;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -34,23 +38,20 @@ use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n use Disr;\n-use cleanup::CleanupScope;\n+use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_ty<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    ptr: MaybeSizedValue,\n-    content_ty: Ty<'tcx>\n-) {\n+pub fn trans_exchange_free_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, ptr: LvalueRef<'tcx>) {\n+    let content_ty = ptr.ty.to_ty(bcx.tcx());\n     let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n     let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n     let callee = Callee::def(bcx.ccx, def_id, substs);\n \n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n \n     let llret = bcx.call(callee.reify(bcx.ccx),\n-        &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize], None);\n+        &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize], None);\n     fn_ty.apply_attrs_callsite(llret);\n }\n \n@@ -93,17 +94,17 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n-    call_drop_glue(bcx, args, t, false, None)\n+fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: LvalueRef<'tcx>) {\n+    call_drop_glue(bcx, args, false, None)\n }\n \n pub fn call_drop_glue<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n-    mut args: MaybeSizedValue,\n-    t: Ty<'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n+    mut args: LvalueRef<'tcx>,\n     skip_dtor: bool,\n     funclet: Option<&'a Funclet>,\n ) {\n+    let t = args.ty.to_ty(bcx.tcx());\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"call_drop_glue(t={:?}, skip_dtor={})\", t, skip_dtor);\n     if bcx.ccx.shared().type_needs_drop(t) {\n@@ -116,11 +117,11 @@ pub fn call_drop_glue<'a, 'tcx>(\n         let glue = get_drop_glue_core(ccx, g);\n         let glue_type = get_drop_glue_type(ccx.shared(), t);\n         if glue_type != t {\n-            args.value = bcx.pointercast(args.value, type_of(ccx, glue_type).ptr_to());\n+            args.llval = bcx.pointercast(args.llval, type_of(ccx, glue_type).ptr_to());\n         }\n \n         // No drop-hint ==> call standard drop glue\n-        bcx.call(glue, &[args.value, args.meta][..1 + args.has_meta() as usize],\n+        bcx.call(glue, &[args.llval, args.llextra][..1 + args.has_extra() as usize],\n             funclet.map(|b| b.bundle()));\n     }\n }\n@@ -173,8 +174,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n     let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -194,9 +194,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n \n     let value = get_param(llfn, 0);\n     let ptr = if ccx.shared().type_is_sized(t) {\n-        MaybeSizedValue::sized(value)\n+        LvalueRef::new_sized_ty(value, t)\n     } else {\n-        MaybeSizedValue::unsized_(value, get_param(llfn, 1))\n+        LvalueRef::new_unsized_ty(value, get_param(llfn, 1), t)\n     };\n \n     let skip_dtor = match g {\n@@ -211,23 +211,23 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // a safe-guard, assert TyBox not used with TyContents.\n             assert!(!skip_dtor);\n             let ptr = if !bcx.ccx.shared().type_is_sized(content_ty) {\n-                let llbox = bcx.load(get_dataptr(&bcx, ptr.value));\n-                let info = bcx.load(get_meta(&bcx, ptr.value));\n-                MaybeSizedValue::unsized_(llbox, info)\n+                let llbox = bcx.load(get_dataptr(&bcx, ptr.llval));\n+                let info = bcx.load(get_meta(&bcx, ptr.llval));\n+                LvalueRef::new_unsized_ty(llbox, info, content_ty)\n             } else {\n-                MaybeSizedValue::sized(bcx.load(ptr.value))\n+                LvalueRef::new_sized_ty(bcx.load(ptr.llval), content_ty)\n             };\n-            drop_ty(&bcx, ptr, content_ty);\n-            trans_exchange_free_ty(&bcx, ptr, content_ty);\n+            drop_ty(&bcx, ptr);\n+            trans_exchange_free_ty(&bcx, ptr);\n             bcx\n         }\n         ty::TyDynamic(..) => {\n             // No support in vtable for distinguishing destroying with\n             // versus without calling Drop::drop. Assert caller is\n             // okay with always calling the Drop impl, if any.\n             assert!(!skip_dtor);\n-            let dtor = bcx.load(ptr.meta);\n-            bcx.call(dtor, &[ptr.value], None);\n+            let dtor = bcx.load(ptr.llextra);\n+            bcx.call(dtor, &[ptr.llval], None);\n             bcx\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n@@ -245,7 +245,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // Issue #23611: schedule cleanup of contents, re-inspecting the\n             // discriminant (if any) in case of variant swap in drop code.\n             let contents_scope = if !shallow_drop {\n-                bcx.fcx().schedule_drop_adt_contents(ptr, t)\n+                CleanupScope::schedule_drop_adt_contents(&bcx, ptr)\n             } else {\n                 CleanupScope::noop()\n             };\n@@ -262,9 +262,9 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             let callee = Callee::def(bcx.ccx, dtor_did, vtbl.substs);\n             let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n             let llret;\n-            let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+            let args = &[ptr.llval, ptr.llextra][..1 + ptr.has_extra() as usize];\n             if let Some(landing_pad) = contents_scope.landing_pad {\n-                let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+                let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n                 llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n                 bcx = normal_bcx;\n             } else {\n@@ -279,7 +279,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n         }\n         _ => {\n             if bcx.ccx.shared().type_needs_drop(t) {\n-                drop_structural_ty(bcx, ptr, t)\n+                drop_structural_ty(bcx, ptr)\n             } else {\n                 bcx\n             }\n@@ -288,8 +288,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     bcx.ret_void();\n }\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                                       t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n@@ -397,60 +396,64 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n-                                ptr: MaybeSizedValue,\n-                                t: Ty<'tcx>)\n-                                -> BlockAndBuilder<'a, 'tcx> {\n-    fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n-                              t: Ty<'tcx>,\n-                              av: adt::MaybeSizedValue,\n-                              variant: &'tcx ty::VariantDef,\n-                              substs: &Substs<'tcx>) {\n+fn drop_structural_ty<'a, 'tcx>(\n+    cx: Builder<'a, 'tcx>,\n+    mut ptr: LvalueRef<'tcx>\n+) -> Builder<'a, 'tcx> {\n+    fn iter_variant_fields<'a, 'tcx>(\n+        cx: &'a Builder<'a, 'tcx>,\n+        av: LvalueRef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: usize,\n+        substs: &'tcx Substs<'tcx>\n+    ) {\n+        let variant = &adt_def.variants[variant_index];\n         let tcx = cx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n-            let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n-            drop_ty(&cx, MaybeSizedValue::sized(field_ptr), arg);\n+            let field_ptr = av.trans_field_ptr(&cx, i);\n+            drop_ty(&cx, LvalueRef::new_sized_ty(field_ptr, arg));\n         }\n     }\n \n     let mut cx = cx;\n+    let t = ptr.ty.to_ty(cx.tcx());\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n             for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n-                let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n+                let llupvar = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llupvar, upvar_ty));\n             }\n         }\n         ty::TyArray(_, n) => {\n-            let base = get_dataptr(&cx, ptr.value);\n+            let base = get_dataptr(&cx, ptr.llval);\n             let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n             let unit_ty = t.sequence_element_type(cx.tcx());\n-            cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n-                |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n+            cx = tvec::slice_for_each(&cx, ptr.llval, unit_ty, ptr.llextra,\n+                |bb, vv| drop_ty(bb, LvalueRef::new_sized_ty(vv, unit_ty)));\n         }\n         ty::TyTuple(ref args) => {\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n-                drop_ty(&cx, MaybeSizedValue::sized(llfld_a), *arg);\n+                let llfld_a = ptr.trans_field_ptr(&cx, i);\n+                drop_ty(&cx, LvalueRef::new_sized_ty(llfld_a, *arg));\n             }\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n-                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n-                for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                    let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n-                    let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n-                        MaybeSizedValue::sized(llfld_a)\n-                    } else {\n-                        MaybeSizedValue::unsized_(llfld_a, ptr.meta)\n-                    };\n-                    drop_ty(&cx, ptr, field_ty);\n+                for (i, field) in adt.variants[0].fields.iter().enumerate() {\n+                    let field_ty = monomorphize::field_ty(cx.tcx(), substs, field);\n+                    let mut field_ptr = ptr.clone();\n+                    field_ptr.llval = ptr.trans_field_ptr(&cx, i);\n+                    field_ptr.ty = LvalueTy::from_ty(field_ty);\n+                    if cx.ccx.shared().type_is_sized(field_ty) {\n+                        field_ptr.llextra = ptr::null_mut();\n+                    }\n+                    drop_ty(&cx, field_ptr);\n                 }\n             }\n             AdtKind::Union => {\n@@ -462,16 +465,29 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 // NB: we must hit the discriminant first so that structural\n                 // comparison know not to proceed when the discriminants differ.\n \n-                match adt::trans_switch(&cx, t, ptr.value, false) {\n-                    (adt::BranchKind::Single, None) => {\n+                // Obtain a representation of the discriminant sufficient to translate\n+                // destructuring; this may or may not involve the actual discriminant.\n+                let l = cx.ccx.layout_of(t);\n+                match *l {\n+                    layout::Univariant { .. } |\n+                    layout::UntaggedUnion { .. } => {\n                         if n_variants != 0 {\n                             assert!(n_variants == 1);\n-                            iter_variant(&cx, t, ptr, &adt.variants[0], substs);\n+                            ptr.ty = LvalueTy::Downcast {\n+                                adt_def: adt,\n+                                substs: substs,\n+                                variant_index: 0,\n+                            };\n+                            iter_variant_fields(&cx, ptr, &adt, 0, substs);\n                         }\n                     }\n-                    (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n+                    layout::CEnum { .. } |\n+                    layout::General { .. } |\n+                    layout::RawNullablePointer { .. } |\n+                    layout::StructWrappedNullablePointer { .. } => {\n+                        let lldiscrim_a = adt::trans_get_discr(&cx, t, ptr.llval, None, false);\n                         let tcx = cx.tcx();\n-                        drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n+                        drop_ty(&cx, LvalueRef::new_sized_ty(lldiscrim_a, tcx.types.isize));\n \n                         // Create a fall-through basic block for the \"else\" case of\n                         // the switch instruction we're about to generate. Note that\n@@ -486,23 +502,28 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = cx.fcx().build_new_block(\"enum-iter-ret-void\");\n+                        let ret_void_cx = cx.build_sibling_block(\"enum-iter-ret-void\");\n                         ret_void_cx.ret_void();\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = cx.fcx().build_new_block(\"enum-iter-next\");\n+                        let next_cx = cx.build_sibling_block(\"enum-iter-next\");\n \n-                        for variant in &adt.variants {\n+                        for (i, variant) in adt.variants.iter().enumerate() {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n-                            let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n+                            let variant_cx = cx.build_sibling_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n-                            iter_variant(&variant_cx, t, ptr, variant, substs);\n+                            ptr.ty = LvalueTy::Downcast {\n+                                adt_def: adt,\n+                                substs: substs,\n+                                variant_index: i,\n+                            };\n+                            iter_variant_fields(&variant_cx, ptr, &adt, i, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;\n                     }\n-                    _ => cx.ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+                    _ => bug!(\"{} is not an enum.\", t),\n                 }\n             }\n         },"}, {"sha": "842a21e98db46f12686db159bd8d27cb9421afcd", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -16,6 +16,7 @@ use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType};\n use adt;\n+use mir::lvalue::LvalueRef;\n use base::*;\n use common::*;\n use declare;\n@@ -24,10 +25,10 @@ use type_of;\n use machine;\n use type_::Type;\n use rustc::ty::{self, Ty};\n-use Disr;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use builder::Builder;\n \n use rustc::session::Session;\n use syntax_pos::Span;\n@@ -87,14 +88,14 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType,\n                                       llargs: &[ValueRef],\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n-    let tcx = bcx.tcx();\n+    let tcx = ccx.tcx();\n \n     let (def_id, substs, fty) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs, ref fty) => (def_id, substs, fty),\n@@ -125,7 +126,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult);\n+            try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n         \"breakpoint\" => {\n@@ -533,7 +534,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+            fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n                                           arg_type: Ty<'tcx>,\n                                           llarg: ValueRef)\n@@ -548,12 +549,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                         // destructors, and the contents are SIMD\n                         // etc.\n                         assert!(!bcx.ccx.shared().type_needs_drop(arg_type));\n-                        let arg = adt::MaybeSizedValue::sized(llarg);\n-                        (0..contents.len())\n-                            .map(|i| {\n-                                bcx.load(adt::trans_field_ptr(bcx, arg_type, arg, Disr(0), i))\n-                            })\n-                            .collect()\n+                        let arg = LvalueRef::new_sized_ty(llarg, arg_type);\n+                        (0..contents.len()).map(|i| bcx.load(arg.trans_field_ptr(bcx, i))).collect()\n                     }\n                     intrinsics::Type::Pointer(_, Some(ref llvm_elem), _) => {\n                         let llvm_elem = one(ty_to_type(bcx.ccx, llvm_elem, &mut false));\n@@ -634,7 +631,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n                             tp_ty: Ty<'tcx>,\n@@ -670,7 +667,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n fn memset_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n@@ -686,7 +683,8 @@ fn memset_intrinsic<'a, 'tcx>(\n }\n \n fn try_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n+    ccx: &CrateContext,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n@@ -696,9 +694,9 @@ fn try_intrinsic<'a, 'tcx>(\n         bcx.call(func, &[data], None);\n         bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n     } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, func, data, local_ptr, dest);\n+        trans_msvc_try(bcx, ccx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, func, data, local_ptr, dest);\n+        trans_gnu_try(bcx, ccx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -709,24 +707,25 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                            ccx: &CrateContext,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         bcx.set_personality_fn(bcx.ccx.eh_personality());\n \n-        let normal = bcx.fcx().build_new_block(\"normal\");\n-        let catchswitch = bcx.fcx().build_new_block(\"catchswitch\");\n-        let catchpad = bcx.fcx().build_new_block(\"catchpad\");\n-        let caught = bcx.fcx().build_new_block(\"caught\");\n+        let normal = bcx.build_sibling_block(\"normal\");\n+        let catchswitch = bcx.build_sibling_block(\"catchswitch\");\n+        let catchpad = bcx.build_sibling_block(\"catchpad\");\n+        let caught = bcx.build_sibling_block(\"caught\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n@@ -768,7 +767,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.fcx().alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\");\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -812,12 +811,13 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                           ccx: &CrateContext,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         // Translates the shims described above:\n@@ -837,12 +837,12 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.fcx().build_new_block(\"then\");\n-        let catch = bcx.fcx().build_new_block(\"catch\");\n+        let then = bcx.build_sibling_block(\"then\");\n+        let catch = bcx.build_sibling_block(\"catch\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n         bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(C_i32(ccx, 0));\n \n@@ -854,7 +854,7 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n                                     false);\n-        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.fcx().llfn);\n+        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.llfn());\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n         catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n@@ -869,13 +869,12 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n-                    trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+                    trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let ccx = fcx.ccx;\n     let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n \n     let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -884,19 +883,18 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    trans(fcx.get_entry_block());\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n+    trans(bcx);\n     llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                             trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                             trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    let ccx = fcx.ccx;\n     if let Some(llfn) = ccx.rust_try_fn().get() {\n         return llfn;\n     }\n@@ -910,7 +908,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(tcx.mk_fn_sig(iter::once(i8p), tcx.mk_nil(), false)),\n     }));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try\n }\n@@ -920,7 +918,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n }\n \n fn generic_simd_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     llargs: &[ValueRef],"}, {"sha": "aecba2f57e52cd156d0324f80fbf9f6c275d325e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -13,6 +13,7 @@ use llvm::{ValueRef, get_params};\n use rustc::traits;\n use callee::{Callee, CalleeData};\n use common::*;\n+use builder::Builder;\n use consts;\n use declare;\n use glue;\n@@ -27,7 +28,7 @@ use rustc::ty;\n const VTABLE_OFFSET: usize = 3;\n \n /// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                     llvtable: ValueRef,\n                                     vtable_index: usize)\n                                     -> ValueRef {\n@@ -75,10 +76,9 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(ccx, &[]);\n "}, {"sha": "6d92cd99fbeb971b3977ef32c9066027d648bb6e", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -14,10 +14,11 @@ use rustc::middle::lang_items;\n use rustc::ty::{self, layout};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt::{self, MaybeSizedValue};\n+use adt;\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, BlockAndBuilder, Funclet};\n+use builder::Builder;\n+use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use Disr;\n@@ -36,14 +37,14 @@ use std::cmp;\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n-use super::lvalue::{LvalueRef};\n+use super::lvalue::LvalueRef;\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Pair, Ref, Immediate};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock,\n         funclets: &IndexVec<mir::BasicBlock, Option<Funclet>>) {\n-        let mut bcx = self.build_block(bb);\n+        let mut bcx = self.get_builder(bb);\n         let data = &self.mir[bb];\n \n         debug!(\"trans_block({:?}={:?})\", bb, data);\n@@ -57,7 +58,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n-        let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n+        let funclet_br = |this: &Self, bcx: Builder, bb: mir::BasicBlock| {\n             let lltarget = this.blocks[bb];\n             if let Some(cp) = cleanup_pad {\n                 match this.cleanup_kinds[bb] {\n@@ -84,7 +85,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.fcx.build_new_block(name);\n+                        let trampoline = this.new_block(name);\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n                     }\n@@ -208,7 +209,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.fcx().alloca(ret.original_ty, \"ret\");\n+                            let llscratch = bcx.alloca(ret.original_ty, \"ret\");\n                             self.store_operand(&bcx, llscratch, op, None);\n                             llscratch\n                         }\n@@ -241,20 +242,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                let lvalue = self.trans_lvalue(&bcx, location);\n+                let mut lvalue = self.trans_lvalue(&bcx, location);\n                 let drop_fn = glue::get_drop_glue(bcx.ccx, ty);\n                 let drop_ty = glue::get_drop_glue_type(bcx.ccx.shared(), ty);\n-                let ptr = if bcx.ccx.shared().type_is_sized(ty) {\n-                    let value = if drop_ty != ty {\n-                        bcx.pointercast(lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to())\n-                    } else {\n-                        lvalue.llval\n-                    };\n-                    MaybeSizedValue::sized(value)\n-                } else {\n-                    MaybeSizedValue::unsized_(lvalue.llval, lvalue.llextra)\n-                };\n-                let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n+                if bcx.ccx.shared().type_is_sized(ty) && drop_ty != ty {\n+                    lvalue.llval = bcx.pointercast(\n+                        lvalue.llval, type_of::type_of(bcx.ccx, drop_ty).ptr_to());\n+                }\n+                let args = &[lvalue.llval, lvalue.llextra][..1 + lvalue.has_extra() as usize];\n                 if let Some(unwind) = unwind {\n                     bcx.invoke(\n                         drop_fn,\n@@ -301,7 +296,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n-                let panic_block = self.fcx.build_new_block(\"panic\");\n+                let panic_block = self.new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n@@ -584,15 +579,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n                     if let Some((_, target)) = *destination {\n-                        let ret_bcx = self.build_block(target);\n-                        ret_bcx.at_start(|ret_bcx| {\n-                            self.set_debug_loc(&ret_bcx, terminator.source_info);\n-                            let op = OperandRef {\n-                                val: Immediate(invokeret),\n-                                ty: sig.output(),\n-                            };\n-                            self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n-                        });\n+                        let ret_bcx = self.get_builder(target);\n+                        self.set_debug_loc(&ret_bcx, terminator.source_info);\n+                        let op = OperandRef {\n+                            val: Immediate(invokeret),\n+                            ty: sig.output(),\n+                        };\n+                        self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -613,7 +606,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_argument(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n@@ -658,7 +651,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.fcx().alloca(arg.original_ty, \"arg\");\n+                    let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n                     self.store_operand(bcx, llscratch, op, None);\n                     (llscratch, true)\n                 } else {\n@@ -689,7 +682,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_arguments_untupled(&mut self,\n-                                bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n@@ -706,9 +699,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // Handle both by-ref and immediate tuples.\n         match tuple.val {\n             Ref(llval) => {\n-                let base = adt::MaybeSizedValue::sized(llval);\n                 for (n, &ty) in arg_types.iter().enumerate() {\n-                    let ptr = adt::trans_field_ptr(bcx, tuple.ty, base, Disr(0), n);\n+                    let ptr = LvalueRef::new_sized_ty(llval, tuple.ty);\n+                    let ptr = ptr.trans_field_ptr(bcx, n);\n                     let val = if common::type_is_fat_ptr(bcx.ccx, ty) {\n                         let (lldata, llextra) = base::load_fat_ptr(bcx, ptr, ty);\n                         Pair(lldata, llextra)\n@@ -765,13 +758,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     }\n \n-    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx;\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.fcx().alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\");\n             self.llpersonalityslot = Some(slot);\n             Lifetime::Start.call(bcx, slot);\n             slot\n@@ -790,15 +783,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return self.blocks[target_bb];\n         }\n \n-        let target = self.build_block(target_bb);\n+        let target = self.get_builder(target_bb);\n \n-        let bcx = self.fcx.build_new_block(\"cleanup\");\n+        let bcx = self.new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n+        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot, None);\n@@ -808,18 +801,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.build_new_block(\"unreachable\");\n+            let bl = self.new_block(\"unreachable\");\n             bl.unreachable();\n             self.unreachable_block = Some(bl.llbb());\n             bl.llbb()\n         })\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.blocks[bb], self.fcx)\n+    pub fn new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn, name)\n+    }\n+\n+    pub fn get_builder(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_end(self.blocks[bb]);\n+        builder\n     }\n \n-    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n@@ -836,14 +835,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return if fn_ret_ty.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         llargs.push(tmp);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n@@ -864,7 +863,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n@@ -895,7 +894,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bcx: &BlockAndBuilder<'a, 'tcx>,\n+                    bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest,\n                     ret_ty: ArgType,\n                     op: OperandRef<'tcx>) {\n@@ -911,7 +910,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = base::alloc_ty(bcx, op.ty, \"tmp_ret\");\n+                    let tmp = bcx.alloca_ty(op.ty, \"tmp_ret\");\n                     ret_ty.store(bcx, op.immediate(), tmp);\n                     self.trans_load(bcx, tmp, op.ty)\n                 } else {"}, {"sha": "13e659a5ae0e8cb7149e052489cbd2689b30f962", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 163, "deletions": 15, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -18,16 +18,17 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n-use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use builder::Builder;\n+use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n-use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_u128};\n+use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n+use common::const_to_opt_u128;\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n@@ -548,16 +549,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::AggregateKind::Adt(..) |\n                     mir::AggregateKind::Closure(..) |\n                     mir::AggregateKind::Tuple => {\n-                        let disr = match *kind {\n-                            mir::AggregateKind::Adt(adt_def, index, _, _) => {\n-                                Disr::from(adt_def.variants[index].disr_val)\n-                            }\n-                            _ => Disr(0)\n-                        };\n-                        Const::new(\n-                            adt::trans_const(self.ccx, dest_ty, disr, &fields),\n-                            dest_ty\n-                        )\n+                        Const::new(trans_const(self.ccx, dest_ty, kind, &fields), dest_ty)\n                     }\n                 }\n             }\n@@ -900,7 +892,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n-                          bcx: &BlockAndBuilder<'a, 'tcx>,\n+                          bcx: &Builder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {\n@@ -945,3 +937,159 @@ pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }\n+\n+/// Construct a constant value, suitable for initializing a\n+/// GlobalVariable, given a case and constant values for its fields.\n+/// Note that this may have a different LLVM type (and different\n+/// alignment!) from the representation's `type_of`, so it needs a\n+/// pointer cast before use.\n+///\n+/// The LLVM type system does not directly support unions, and only\n+/// pointers can be bitcast, so a constant (and, by extension, the\n+/// GlobalVariable initialized by it) will have a type that can vary\n+/// depending on which case of an enum it is.\n+///\n+/// To understand the alignment situation, consider `enum E { V64(u64),\n+/// V32(u32, u32) }` on Windows.  The type has 8-byte alignment to\n+/// accommodate the u64, but `V32(x, y)` would have LLVM type `{i32,\n+/// i32, i32}`, which is 4-byte aligned.\n+///\n+/// Currently the returned value has the same size as the type, but\n+/// this could be changed in the future to avoid allocating unnecessary\n+/// space after values of shorter-than-maximum cases.\n+fn trans_const<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    t: Ty<'tcx>,\n+    kind: &mir::AggregateKind,\n+    vals: &[ValueRef]\n+) -> ValueRef {\n+    let l = ccx.layout_of(t);\n+    let dl = &ccx.tcx().data_layout;\n+    let variant_index = match *kind {\n+        mir::AggregateKind::Adt(_, index, _, _) => index,\n+        _ => 0,\n+    };\n+    match *l {\n+        layout::CEnum { discr: d, min, max, .. } => {\n+            let discr = match *kind {\n+                mir::AggregateKind::Adt(adt_def, _, _, _) => {\n+                    Disr::from(adt_def.variants[variant_index].disr_val)\n+                },\n+                _ => Disr(0),\n+            };\n+            assert_eq!(vals.len(), 0);\n+            adt::assert_discr_in_range(Disr(min), Disr(max), discr);\n+            C_integral(Type::from_integer(ccx, d), discr.0, true)\n+        }\n+        layout::General { discr: d, ref variants, .. } => {\n+            let variant = &variants[variant_index];\n+            let lldiscr = C_integral(Type::from_integer(ccx, d), variant_index as u64, true);\n+            let mut vals_with_discr = vec![lldiscr];\n+            vals_with_discr.extend_from_slice(vals);\n+            let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n+            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n+            if needed_padding > 0 {\n+                contents.push(padding(ccx, needed_padding));\n+            }\n+            C_struct(ccx, &contents[..], false)\n+        }\n+        layout::UntaggedUnion { ref variants, .. }=> {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_union(ccx, variants, vals[0]);\n+            C_struct(ccx, &contents, variants.packed)\n+        }\n+        layout::Univariant { ref variant, .. } => {\n+            assert_eq!(variant_index, 0);\n+            let contents = build_const_struct(ccx, &variant, vals);\n+            C_struct(ccx, &contents[..], variant.packed)\n+        }\n+        layout::Vector { .. } => {\n+            C_vector(vals)\n+        }\n+        layout::RawNullablePointer { nndiscr, .. } => {\n+            let nnty = adt::compute_fields(ccx, t, nndiscr as usize, false)[0];\n+            if variant_index as u64 == nndiscr {\n+                assert_eq!(vals.len(), 1);\n+                vals[0]\n+            } else {\n+                C_null(type_of::sizing_type_of(ccx, nnty))\n+            }\n+        }\n+        layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+            if variant_index as u64 == nndiscr {\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n+            } else {\n+                let fields = adt::compute_fields(ccx, t, nndiscr as usize, false);\n+                let vals = fields.iter().map(|&ty| {\n+                    // Always use null even if it's not the `discrfield`th\n+                    // field; see #8506.\n+                    C_null(type_of::sizing_type_of(ccx, ty))\n+                }).collect::<Vec<ValueRef>>();\n+                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n+            }\n+        }\n+        _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)\n+    }\n+}\n+\n+/// Building structs is a little complicated, because we might need to\n+/// insert padding if a field's value is less aligned than its type.\n+///\n+/// Continuing the example from `trans_const`, a value of type `(u32,\n+/// E)` should have the `E` at offset 8, but if that field's\n+/// initializer is 4-byte aligned then simply translating the tuple as\n+/// a two-element struct will locate it at offset 4, and accesses to it\n+/// will read the wrong memory.\n+fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                st: &layout::Struct,\n+                                vals: &[ValueRef])\n+                                -> Vec<ValueRef> {\n+    assert_eq!(vals.len(), st.offsets.len());\n+\n+    if vals.len() == 0 {\n+        return Vec::new();\n+    }\n+\n+    // offset of current value\n+    let mut offset = 0;\n+    let mut cfields = Vec::new();\n+    cfields.reserve(st.offsets.len()*2);\n+\n+    let parts = st.field_index_by_increasing_offset().map(|i| {\n+        (&vals[i], st.offsets[i].bytes())\n+    });\n+    for (&val, target_offset) in parts {\n+        if offset < target_offset {\n+            cfields.push(padding(ccx, target_offset - offset));\n+            offset = target_offset;\n+        }\n+        assert!(!is_undef(val));\n+        cfields.push(val);\n+        offset += machine::llsize_of_alloc(ccx, val_ty(val));\n+    }\n+\n+    if offset < st.stride().bytes() {\n+        cfields.push(padding(ccx, st.stride().bytes() - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               un: &layout::Union,\n+                               field_val: ValueRef)\n+                               -> Vec<ValueRef> {\n+    let mut cfields = vec![field_val];\n+\n+    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n+    let size = un.stride().bytes();\n+    if offset != size {\n+        cfields.push(padding(ccx, size - offset));\n+    }\n+\n+    cfields\n+}\n+\n+fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n+    C_undef(Type::array(&Type::i8(ccx), size))\n+}"}, {"sha": "bd6e70639bba540e4396742fdd5187ea5fc0bedf", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 183, "deletions": 45, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -9,18 +9,20 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, layout, Ty, TypeFoldable};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n-use base;\n-use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n+use builder::Builder;\n+use common::{self, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n use type_of;\n-use Disr;\n+use type_::Type;\n+use value::Value;\n+use glue;\n \n use std::ptr;\n \n@@ -39,22 +41,24 @@ pub struct LvalueRef<'tcx> {\n     pub ty: LvalueTy<'tcx>,\n }\n \n-impl<'tcx> LvalueRef<'tcx> {\n+impl<'a, 'tcx> LvalueRef<'tcx> {\n     pub fn new_sized(llval: ValueRef, lvalue_ty: LvalueTy<'tcx>) -> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n-    pub fn alloca<'a>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                        ty: Ty<'tcx>,\n-                        name: &str)\n-                        -> LvalueRef<'tcx>\n-    {\n-        assert!(!ty.has_erasable_regions());\n-        let lltemp = base::alloc_ty(bcx, ty, name);\n-        LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n+    pub fn new_sized_ty(llval: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef::new_sized(llval, LvalueTy::from_ty(ty))\n+    }\n+\n+    pub fn new_unsized_ty(llval: ValueRef, llextra: ValueRef, ty: Ty<'tcx>) -> LvalueRef<'tcx> {\n+        LvalueRef {\n+            llval: llval,\n+            llextra: llextra,\n+            ty: LvalueTy::from_ty(ty),\n+        }\n     }\n \n-    pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n+    pub fn len(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n             ty::TyArray(_, n) => common::C_uint(ccx, n),\n@@ -65,17 +69,170 @@ impl<'tcx> LvalueRef<'tcx> {\n             _ => bug!(\"unexpected type `{}` in LvalueRef::len\", ty)\n         }\n     }\n+\n+    pub fn has_extra(&self) -> bool {\n+        !self.llextra.is_null()\n+    }\n+\n+    fn struct_field_ptr(\n+        self,\n+        bcx: &Builder<'a, 'tcx>,\n+        st: &layout::Struct,\n+        fields: &Vec<Ty<'tcx>>,\n+        ix: usize,\n+        needs_cast: bool\n+    ) -> ValueRef {\n+        let fty = fields[ix];\n+        let ccx = bcx.ccx;\n+\n+        let ptr_val = if needs_cast {\n+            let fields = st.field_index_by_increasing_offset().map(|i| {\n+                type_of::in_memory_type_of(ccx, fields[i])\n+            }).collect::<Vec<_>>();\n+            let real_ty = Type::struct_(ccx, &fields[..], st.packed);\n+            bcx.pointercast(self.llval, real_ty.ptr_to())\n+        } else {\n+            self.llval\n+        };\n+\n+        // Simple case - we can just GEP the field\n+        //   * First field - Always aligned properly\n+        //   * Packed struct - There is no alignment padding\n+        //   * Field is sized - pointer is properly aligned already\n+        if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n+            bcx.ccx.shared().type_is_sized(fty) {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+\n+        // If the type of the last field is [T] or str, then we don't need to do\n+        // any adjusments\n+        match fty.sty {\n+            ty::TySlice(..) | ty::TyStr => {\n+                return bcx.struct_gep(ptr_val, st.memory_index[ix] as usize);\n+            }\n+            _ => ()\n+        }\n+\n+        // There's no metadata available, log the case and just do the GEP.\n+        if !self.has_extra() {\n+            debug!(\"Unsized field `{}`, of `{:?}` has no metadata for adjustment\",\n+                ix, Value(ptr_val));\n+            return bcx.struct_gep(ptr_val, ix);\n+        }\n+\n+        // We need to get the pointer manually now.\n+        // We do this by casting to a *i8, then offsetting it by the appropriate amount.\n+        // We do this instead of, say, simply adjusting the pointer from the result of a GEP\n+        // because the field may have an arbitrary alignment in the LLVM representation\n+        // anyway.\n+        //\n+        // To demonstrate:\n+        //   struct Foo<T: ?Sized> {\n+        //      x: u16,\n+        //      y: T\n+        //   }\n+        //\n+        // The type Foo<Foo<Trait>> is represented in LLVM as { u16, { u16, u8 }}, meaning that\n+        // the `y` field has 16-bit alignment.\n+\n+        let meta = self.llextra;\n+\n+\n+        let offset = st.offsets[ix].bytes();\n+        let unaligned_offset = C_uint(bcx.ccx, offset);\n+\n+        // Get the alignment of the field\n+        let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n+\n+        // Bump the unaligned offset up to the appropriate alignment using the\n+        // following expression:\n+        //\n+        //   (unaligned offset + (align - 1)) & -align\n+\n+        // Calculate offset\n+        let align_sub_1 = bcx.sub(align, C_uint(bcx.ccx, 1u64));\n+        let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n+        bcx.neg(align));\n+\n+        debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n+\n+        // Cast and adjust pointer\n+        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n+        let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n+\n+        // Finally, cast back to the type expected\n+        let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n+        debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n+        bcx.pointercast(byte_ptr, ll_fty.ptr_to())\n+    }\n+\n+    /// Access a field, at a point when the value's case is known.\n+    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> ValueRef {\n+        let discr = match self.ty {\n+            LvalueTy::Ty { .. } => 0,\n+            LvalueTy::Downcast { variant_index, .. } => variant_index,\n+        };\n+        let t = self.ty.to_ty(bcx.tcx());\n+        let l = bcx.ccx.layout_of(t);\n+        // Note: if this ever needs to generate conditionals (e.g., if we\n+        // decide to do some kind of cdr-coding-like non-unique repr\n+        // someday), it will need to return a possibly-new bcx as well.\n+        match *l {\n+            layout::Univariant { ref variant, .. } => {\n+                assert_eq!(discr, 0);\n+                self.struct_field_ptr(bcx, &variant,\n+                    &adt::compute_fields(bcx.ccx, t, 0, false), ix, false)\n+            }\n+            layout::Vector { count, .. } => {\n+                assert_eq!(discr, 0);\n+                assert!((ix as u64) < count);\n+                bcx.struct_gep(self.llval, ix)\n+            }\n+            layout::General { discr: d, ref variants, .. } => {\n+                let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n+                fields.insert(0, d.to_ty(&bcx.tcx(), false));\n+                self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n+            }\n+            layout::UntaggedUnion { .. } => {\n+                let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n+                let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n+                let nullfields = adt::compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.d., Result of Either with (), as one side.)\n+                let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n+                assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } => {\n+                let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n+                assert_eq!(ix, 0);\n+                assert_eq!(discr as u64, nndiscr);\n+                let ty = type_of::type_of(bcx.ccx, nnty);\n+                bcx.pointercast(self.llval, ty.ptr_to())\n+            }\n+            layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n+                assert_eq!(discr as u64, nndiscr);\n+                self.struct_field_ptr(bcx, &nonnull,\n+                    &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+            }\n+            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n+        }\n+    }\n }\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n-                        bcx: &BlockAndBuilder<'a, 'tcx>,\n+                        bcx: &Builder<'a, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n         let ccx = bcx.ccx;\n-        let tcx = bcx.tcx();\n+        let tcx = ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n@@ -134,26 +291,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (llprojected, llextra) = match projection.elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let base_ty = tr_base.ty.to_ty(tcx);\n-                        let discr = match tr_base.ty {\n-                            LvalueTy::Ty { .. } => 0,\n-                            LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n-                        };\n-                        let discr = discr as u64;\n-                        let is_sized = self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n-                        let base = if is_sized {\n-                            adt::MaybeSizedValue::sized(tr_base.llval)\n-                        } else {\n-                            adt::MaybeSizedValue::unsized_(tr_base.llval, tr_base.llextra)\n-                        };\n-                        let llprojected = adt::trans_field_ptr(bcx, base_ty, base, Disr(discr),\n-                            field.index());\n-                        let llextra = if is_sized {\n+                        let llextra = if self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx)) {\n                             ptr::null_mut()\n                         } else {\n                             tr_base.llextra\n                         };\n-                        (llprojected, llextra)\n+                        (tr_base.trans_field_ptr(bcx, field.index()), llextra)\n                     }\n                     mir::ProjectionElem::Index(ref index) => {\n                         let index = self.trans_operand(bcx, index);\n@@ -214,7 +357,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     // Perform an action using the given Lvalue.\n     // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n-    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &Builder<'a, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n@@ -223,9 +366,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 LocalRef::Lvalue(lvalue) => f(self, lvalue),\n                 LocalRef::Operand(None) => {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n-                    let lvalue = LvalueRef::alloca(bcx,\n-                                                   lvalue_ty,\n-                                                   \"lvalue_temp\");\n+                    assert!(!lvalue_ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(lvalue_ty, \"lvalue_temp\");\n+                    let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(lvalue_ty));\n                     let ret = f(self, lvalue);\n                     let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n@@ -254,18 +397,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// than we are.\n     ///\n     /// nmatsakis: is this still necessary? Not sure.\n-    fn prepare_index(&mut self,\n-                     bcx: &BlockAndBuilder<'a, 'tcx>,\n-                     llindex: ValueRef)\n-                     -> ValueRef\n-    {\n-        let ccx = bcx.ccx;\n+    fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n         if index_size < int_size {\n-            bcx.zext(llindex, ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.int_type())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.int_type())\n         } else {\n             llindex\n         }"}, {"sha": "eedd7956805b6a52fb7a43a074e27496ae387d7a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -19,7 +19,8 @@ use rustc::infer::TransNormalize;\n use rustc::ty::TypeFoldable;\n use session::config::FullDebugInfo;\n use base;\n-use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, Funclet};\n+use builder::Builder;\n+use common::{self, CrateContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n use abi::FnType;\n@@ -37,7 +38,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n pub use self::constant::trans_static_initializer;\n \n use self::analyze::CleanupKind;\n-use self::lvalue::{LvalueRef};\n+use self::lvalue::LvalueRef;\n use rustc::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n@@ -48,7 +49,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     debug_context: debuginfo::FunctionDebugContext,\n \n-    fcx: &'a common::FunctionContext<'a, 'tcx>,\n+    llfn: ValueRef,\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n@@ -106,7 +107,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n     }\n \n-    pub fn set_debug_loc(&mut self, bcx: &BlockAndBuilder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bcx, scope, span);\n     }\n@@ -198,7 +199,8 @@ impl<'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    llfn: ValueRef,\n     fn_ty: FnType,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n@@ -207,29 +209,29 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n ) {\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir);\n-    let bcx = fcx.get_entry_block();\n+        debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfn, mir);\n+    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n             if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\")\n+                bcx.build_sibling_block(\"start\").llbb()\n             } else {\n-                fcx.new_block(&format!(\"{:?}\", bb))\n+                bcx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n             }\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(fcx, mir, &debug_context);\n+    let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n \n     let mut mircx = MirContext {\n         mir: mir,\n-        fcx: fcx,\n+        llfn: llfn,\n         fn_ty: fn_ty,\n-        ccx: fcx.ccx,\n+        ccx: ccx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n@@ -266,7 +268,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                assert!(!ty.has_erasable_regions());\n+                let lltemp = bcx.alloca_ty(ty, &name.as_str());\n+                let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty));\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n@@ -278,11 +282,13 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 // Temporary or return pointer\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n-                    let llretptr = llvm::get_param(fcx.llfn, 0);\n+                    let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", local)))\n+                    assert!(!ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(ty, &format!(\"{:?}\", local));\n+                    LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -312,9 +318,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let funclets: IndexVec<mir::BasicBlock, Option<Funclet>> =\n     mircx.cleanup_kinds.iter_enumerated().map(|(bb, cleanup_kind)| {\n         if let CleanupKind::Funclet = *cleanup_kind {\n-            let bcx = mircx.build_block(bb);\n+            let bcx = mircx.get_builder(bb);\n             bcx.set_personality_fn(mircx.ccx.eh_personality());\n-            if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            if base::wants_msvc_seh(ccx.sess()) {\n                 return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n             }\n         }\n@@ -347,13 +353,12 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             mircx: &MirContext<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n-    let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n@@ -381,7 +386,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &mircx.fn_ty.args[idx];\n@@ -428,7 +433,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n         } else if !lvalue_locals.contains(local.index()) &&\n@@ -444,13 +449,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n-                let llmeta = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+                let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n                 OperandValue::Pair(llarg, llmeta)\n             } else {\n@@ -462,7 +467,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,\n@@ -514,7 +519,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // doesn't actually strip the offset when splitting the closure\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n-                let alloc = bcx.fcx().alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n+                let alloc = bcx.alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n                 bcx.store(llval, alloc, None);\n                 alloc\n             } else {\n@@ -573,7 +578,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n mod analyze;\n mod block;\n mod constant;\n-mod lvalue;\n+pub mod lvalue;\n mod operand;\n mod rvalue;\n mod statement;"}, {"sha": "28a247ee612a9078b6ba32322613439e40abb8b4", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -14,7 +14,8 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n use value::Value;\n use type_of;\n use type_::Type;\n@@ -85,8 +86,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                        -> OperandRef<'tcx> {\n+    pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n             let llty = type_of::type_of(bcx.ccx, self.ty);\n@@ -107,8 +107,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a pair in an Immediate,\n     /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                          -> OperandRef<'tcx> {\n+    pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n             if common::type_is_imm_pair(bcx.ccx, self.ty) {\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_load(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       llval: ValueRef,\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n@@ -165,7 +164,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_consume(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lvalue: &mir::Lvalue<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -217,7 +216,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -242,7 +241,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn store_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>,\n                          align: Option<u32>) {"}, {"sha": "67fb8cf576d6218afdeafd7bf834024cde76f6de", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -12,13 +12,15 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n+use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n \n use asm;\n use base;\n+use builder::Builder;\n use callee::Callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder};\n+use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n use machine;\n@@ -35,10 +37,10 @@ use super::lvalue::{LvalueRef};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: BlockAndBuilder<'a, 'tcx>,\n+                        bcx: Builder<'a, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> BlockAndBuilder<'a, 'tcx>\n+                        -> Builder<'a, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n@@ -79,7 +81,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let lltemp = base::alloc_ty(&bcx, operand.ty, \"__unsize_temp\");\n+                        let lltemp = bcx.alloca_ty(operand.ty, \"__unsize_temp\");\n                         base::store_ty(&bcx, llval, lltemp, operand.ty);\n                         lltemp\n                     }\n@@ -101,18 +103,22 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n-                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n                         let dest_ty = dest.ty.to_ty(bcx.tcx());\n                         adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx, op.ty) {\n-                                let val = adt::MaybeSizedValue::sized(dest.llval);\n+                                let mut val = LvalueRef::new_sized(dest.llval, dest.ty);\n                                 let field_index = active_field_index.unwrap_or(i);\n-                                let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n-                                    field_index);\n+                                val.ty = LvalueTy::Downcast {\n+                                    adt_def: adt_def,\n+                                    substs: self.monomorphize(&substs),\n+                                    variant_index: disr.0 as usize,\n+                                };\n+                                let lldest_i = val.trans_field_ptr(&bcx, field_index);\n                                 self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }\n@@ -170,9 +176,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: BlockAndBuilder<'a, 'tcx>,\n+                                bcx: Builder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (BlockAndBuilder<'a, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n@@ -477,7 +483,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: &BlockAndBuilder<'a, 'tcx>,\n+                              bcx: &Builder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -552,7 +558,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_fat_ptr_binop(&mut self,\n-                               bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               bcx: &Builder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -599,7 +605,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_checked_binop(&mut self,\n-                                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                      bcx: &Builder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -681,7 +687,7 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};"}, {"sha": "48fc9720e4b8317eb374fc1811499c0b048d8c62", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -11,7 +11,8 @@\n use rustc::mir;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n \n use super::MirContext;\n use super::LocalRef;\n@@ -20,9 +21,9 @@ use super::super::disr::Disr;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: BlockAndBuilder<'a, 'tcx>,\n+                           bcx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> BlockAndBuilder<'a, 'tcx> {\n+                           -> Builder<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bcx, statement.source_info);\n@@ -77,10 +78,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_storage_liveness(&self,\n-                              bcx: BlockAndBuilder<'a, 'tcx>,\n+                              bcx: Builder<'a, 'tcx>,\n                               lvalue: &mir::Lvalue<'tcx>,\n                               intrinsic: base::Lifetime)\n-                              -> BlockAndBuilder<'a, 'tcx> {\n+                              -> Builder<'a, 'tcx> {\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n                 intrinsic.call(&bcx, tr_lval.llval);"}, {"sha": "cbcbb02bdc89017ebb573ad6a9c06b57f2d94620", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -9,28 +9,29 @@\n // except according to those terms.\n \n use llvm;\n+use builder::Builder;\n use llvm::ValueRef;\n use common::*;\n use rustc::ty::Ty;\n \n pub fn slice_for_each<'a, 'tcx, F>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     data_ptr: ValueRef,\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> BlockAndBuilder<'a, 'tcx> where F: FnOnce(&BlockAndBuilder<'a, 'tcx>, ValueRef) {\n+) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx, unit_ty);\n-    let add = |bcx: &BlockAndBuilder, a, b| if zst {\n+    let add = |bcx: &Builder, a, b| if zst {\n         bcx.add(a, b)\n     } else {\n         bcx.inbounds_gep(a, &[b])\n     };\n \n-    let body_bcx = bcx.fcx().build_new_block(\"slice_loop_body\");\n-    let next_bcx = bcx.fcx().build_new_block(\"slice_loop_next\");\n-    let header_bcx = bcx.fcx().build_new_block(\"slice_loop_header\");\n+    let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n+    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n+    let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n \n     let start = if zst {\n         C_uint(bcx.ccx, 0usize)"}, {"sha": "6135f49eb711be0c9a2e8c22bd6e84cb6b9fc444", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5dd07b66ffc8d21b9d73c99def588ff8b2242974/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=5dd07b66ffc8d21b9d73c99def588ff8b2242974", "patch": "@@ -24,8 +24,8 @@ pub struct Bytes {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n-// CHECK: %arg1 = alloca [4 x i8]\n // CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: %arg1 = alloca [4 x i8]\n // CHECK: store i32 %1, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n@@ -38,8 +38,8 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n-// CHECK: %arg1 = alloca %Bytes\n // CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: %arg1 = alloca %Bytes\n // CHECK: store i32 %1, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*"}]}