{"sha": "12c974e21abc70689c59027adcf42ff3f4b29e84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYzk3NGUyMWFiYzcwNjg5YzU5MDI3YWRjZjQyZmYzZjRiMjllODQ=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-13T08:45:30Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-13T08:45:30Z"}, "message": "changed Constant to a struct with 'needed_resolution' bool", "tree": {"sha": "86bdee69918f217b92fdd8dca27db19e6a401332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86bdee69918f217b92fdd8dca27db19e6a401332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12c974e21abc70689c59027adcf42ff3f4b29e84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12c974e21abc70689c59027adcf42ff3f4b29e84", "html_url": "https://github.com/rust-lang/rust/commit/12c974e21abc70689c59027adcf42ff3f4b29e84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12c974e21abc70689c59027adcf42ff3f4b29e84/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b95537574182be0b7ef6301cdbafe11891ec95", "url": "https://api.github.com/repos/rust-lang/rust/commits/45b95537574182be0b7ef6301cdbafe11891ec95", "html_url": "https://github.com/rust-lang/rust/commit/45b95537574182be0b7ef6301cdbafe11891ec95"}], "stats": {"total": 202, "additions": 138, "deletions": 64}, "files": [{"sha": "cef2cd7f9fc08193c52fc40f4dae838c8ee17916", "filename": "src/const.rs", "status": "modified", "additions": 138, "deletions": 64, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/12c974e21abc70689c59027adcf42ff3f4b29e84/src%2Fconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12c974e21abc70689c59027adcf42ff3f4b29e84/src%2Fconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconst.rs?ref=12c974e21abc70689c59027adcf42ff3f4b29e84", "patch": "@@ -18,9 +18,25 @@ impl From<FloatTy> for FloatWidth {\n     }\n }\n \n+#[derive(PartialEq, Eq, Debug, Clone)]\n+pub struct Constant {\n+    constant: ConstantVariant,\n+    needed_resolution: bool\n+}\n+\n+impl Constant {\n+    fn new(variant: ConstantVariant) -> Constant {\n+        Constant { constant: variant, needed_resolution: false }\n+    }\n+\n+    fn new_resolved(variant: ConstantVariant) -> Constant {\n+        Constant { constant: variant, needed_resolution: true }\n+    }\n+}\n+\n /// a Lit_-like enum to fold constant `Expr`s into\n #[derive(PartialEq, Eq, Debug, Clone)]\n-pub enum Constant {\n+pub enum ConstantVariant {\n     /// a String \"abc\"\n     ConstantStr(&'static str, StrStyle),\n     /// a Binary String b\"abc\"\n@@ -43,103 +59,152 @@ pub enum Constant {\n     ConstantTuple(Vec<Constant>),\n }\n \n-/// simple constant folding\n-pub fn constant(cx: &Context, e: &Expr, follow: bool) -> Option<Constant> {\n+impl ConstantVariant {\n+    /// convert to u64 if possible\n+    ///\n+    /// # panics\n+    ///\n+    /// if the constant could not be converted to u64 losslessly\n+    fn as_u64(&self) -> u64 {\n+        if let &ConstantInt(val, _) = self {\n+            val // TODO we may want to check the sign if any\n+        } else {\n+            panic!(\"Could not convert a {:?} to u64\");\n+        }\n+    }\n+}\n+\n+/// simple constant folding: Insert an expression, get a constant or none.\n+pub fn constant(cx: &Context, e: &Expr) -> Option<Constant> {\n     match e {\n-        &ExprParen(ref inner) => constant(cx, inner, follow),\n-        &ExprPath(_, _) => if follow { fetch_path(cx, e) } else { None },\n-        &ExprBlock(ref block) => constant_block(cx, inner, follow),\n+        &ExprParen(ref inner) => constant(cx, inner),\n+        &ExprPath(_, _) => fetch_path(cx, e),\n+        &ExprBlock(ref block) => constant_block(cx, inner),\n         &ExprIf(ref cond, ref then, ref otherwise) =>\n-            match constant(cx, cond) {\n-                Some(ConstantBool(true)) => constant(cx, then, follow),\n-                Some(ConstantBool(false)) => constant(cx, otherwise, follow),\n-                _ => None,\n-            },\n+            constant_if(cx, cond, then, otherwise),\n         &ExprLit(ref lit) => Some(lit_to_constant(lit)),\n-        &ExprVec(ref vec) => constant_vec(cx, vec, follow),\n-        &ExprTup(ref tup) => constant_tup(cx, tup, follow),\n+        &ExprVec(ref vec) => constant_vec(cx, vec),\n+        &ExprTup(ref tup) => constant_tup(cx, tup),\n         &ExprRepeat(ref value, ref number) =>\n-            constant_binop_apply(cx, value, number,|v, n| ConstantRepeat(v, n)),\n-        &ExprUnary(op, ref operand) => constant(cx, operand, follow).and_then(\n+            constant_binop_apply(cx, value, number,|v, n| Constant {\n+                constant: ConstantRepeat(v, n.constant.as_u64()),\n+                needed_resolution: v.needed_resolution || n.needed_resolution\n+            }),\n+        &ExprUnary(op, ref operand) => constant(cx, operand).and_then(\n             |o| match op {\n                 UnNot =>\n-                    if let ConstantBool(b) = o {\n-                        Some(ConstantBool(!b))\n+                    if let ConstantBool(b) = o.variant {\n+                        Some(Constant{\n+                            needed_resolution: o.needed_resolution,\n+                            constant: ConstantBool(!b),\n+                        })\n                     } else { None },\n                 UnNeg => constant_negate(o),\n                 UnUniq | UnDeref => o,\n             }),\n         &ExprBinary(op, ref left, ref right) =>\n-            constant_binop(cx, op, left, right, follow),\n+            constant_binop(op, left, right),\n         //TODO: add other expressions\n         _ => None,\n     }\n }\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match lit {\n-        &LitStr(ref is, style) => ConstantStr(&*is, style),\n-        &LitBinary(ref blob) => ConstantBinary(blob.clone()),\n-        &LitByte(b) => ConstantByte(b),\n-        &LitChar(c) => ConstantChar(c),\n-        &LitInt(value, ty) => ConstantInt(value, ty),\n-        &LitFloat(ref is, ty) => ConstantFloat(Cow::Borrowed(&*is), ty.into()),\n+        &LitStr(ref is, style) => Constant::new(ConstantStr(&*is, style)),\n+        &LitBinary(ref blob) => Constant::new(ConstantBinary(blob.clone())),\n+        &LitByte(b) => Constant::new(ConstantByte(b)),\n+        &LitChar(c) => Constant::new(ConstantChar(c)),\n+        &LitInt(value, ty) => Constant::new(ConstantInt(value, ty)),\n+        &LitFloat(ref is, ty) =>\n+            Constant::new(ConstantFloat(Cow::Borrowed(&*is), ty.into())),\n         &LitFloatUnsuffixed(InternedString) =>\n-                ConstantFloat(Cow::Borrowed(&*is), FwAny),\n-        &LitBool(b) => ConstantBool(b),\n+            Constant::new(ConstantFloat(Cow::Borrowed(&*is), FwAny)),\n+        &LitBool(b) => Constant::new(ConstantBool(b)),\n     }\n }\n \n /// create `Some(ConstantVec(..))` of all constants, unless there is any\n /// non-constant part\n-fn constant_vec(cx: &Context, vec: &[&Expr], follow: bool) -> Option<Constant> {\n-    parts = Vec::new();\n+fn constant_vec(cx: &Context, vec: &[&Expr]) -> Option<Constant> {\n+    let mut parts = Vec::new();\n+    let mut resolved = false;\n     for opt_part in vec {\n-        match constant(cx, opt_part, follow) {\n-            Some(ref p) => parts.push(p),\n+        match constant(cx, opt_part) {\n+            Some(ref p) => {\n+                resolved |= p.needed_resolution;\n+                parts.push(p)\n+            },\n             None => { return None; },\n         }\n     }\n-    Some(ConstantVec(parts))\n+    Some(Constant {\n+        constant: ConstantVec(parts),\n+        needed_resolution: resolved\n+    })\n }\n \n-fn constant_tup(cx: &Context, tup: &[&Expr], follow: bool) -> Option<Constant> {\n-    parts = Vec::new();\n+fn constant_tup(cx: &Context, tup: &[&Expr]) -> Option<Constant> {\n+    let mut parts = Vec::new();\n+    let mut resolved = false;\n     for opt_part in vec {\n-        match constant(cx, opt_part, follow) {\n-            Some(ref p) => parts.push(p),\n+        match constant(cx, opt_part) {\n+            Some(ref p) => {\n+                resolved |= p.needed_resolution;\n+                parts.push(p)\n+            },\n             None => { return None; },\n         }\n     }\n-    Some(ConstantTuple(parts))\n+    Some(Constant {\n+        constant: ConstantTuple(parts),\n+        needed_resolution: resolved\n+    })\n }\n \n /// lookup a possibly constant expression from a ExprPath\n fn fetch_path(cx: &Context, e: &Expr) -> Option<Constant> {\n     if let Some(&PathResolution { base_def: DefConst(id), ..}) =\n             cx.tcx.def_map.borrow().get(&e.id) {\n-        lookup_const_by_id(cx.tcx, id, None).map(|l| constant(cx, l))\n+        lookup_const_by_id(cx.tcx, id, None).map(\n+            |l| Constant::new_resolved(constant(cx, l).constant))\n     } else { None }\n }\n \n /// A block can only yield a constant if it only has one constant expression\n-fn constant_block(cx: &Context, block: &Block, follow: bool) -> Option<Constant> {\n+fn constant_block(cx: &Context, block: &Block) -> Option<Constant> {\n     if block.stmts.is_empty() {\n-        block.expr.map(|b| constant(cx, b, follow))\n+        block.expr.map(|b| constant(cx, b))\n+    } else { None }\n+}\n+\n+fn constant_if(cx: &Context, cond: &Expr, then: &Expr, otherwise: &Expr) ->\n+        Option<Constant> {\n+    if let Some(Constant{ constant: ConstantBool(b), needed_resolution: res }) =\n+            constant(cx, cond) {\n+        let part = constant(cx, if b { then } else { otherwise });\n+        Some(Constant {\n+            constant: part.constant,\n+            needed_resolution: res || part.needed_resolution,\n+        })\n     } else { None }\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n-    match o {\n-        &ConstantInt(value, ty) =>\n-            Some(ConstantInt(value, match ty {\n-                SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n-                UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n-                _ => { return None; },\n-            })),\n-        &LitFloat(ref is, ref ty) => Some(ConstantFloat(neg_float_str(is), ty)),\n-        _ => None,\n-    }\n+    Some(Constant{\n+        needed_resolution: o.needed_resolution,\n+        constant: match o.constant {\n+            &ConstantInt(value, ty) =>\n+                ConstantInt(value, match ty {\n+                    SignedIntLit(ity, sign) =>\n+                        SignedIntLit(ity, neg_sign(sign)),\n+                    UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n+                    _ => { return None; },\n+                }),\n+            &LitFloat(ref is, ref ty) => ConstantFloat(neg_float_str(is), ty),\n+            _ => { return None; },\n+        }\n+    })\n }\n \n fn neg_sign(s: Sign) -> Sign {\n@@ -157,16 +222,16 @@ fn neg_float_str(s: &InternedString) -> Cow<'static, str> {\n     }\n }\n \n-fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr,\n-        follow: bool) -> Option<Constant> {\n+fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr)\n+        -> Option<Constant> {\n     match op.node {\n         //BiAdd,\n         //BiSub,\n         //BiMul,\n         //BiDiv,\n         //BiRem,\n-        BiAnd => constant_short_circuit(cx, left, right, false, follow),\n-        BiOr => constant_short_circuit(cx, left, right, true, follow),\n+        BiAnd => constant_short_circuit(cx, left, right, false),\n+        BiOr => constant_short_circuit(cx, left, right, true),\n         //BiBitXor,\n         //BiBitAnd,\n         //BiBitOr,\n@@ -182,21 +247,30 @@ fn constant_binop(cx: &Context, op: BinOp, left: &Expr, right: &Expr,\n     }\n }\n \n-fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F,\n-        follow: bool) -> Option<Constant>\n-where F: FnMut(Constant, Constant) -> Option<Constant> {\n-    constant(cx, left, follow).and_then(|l| constant(cx, right, follow)\n-        .and_then(|r| op(l, r)))\n+fn constant_binop_apply<F>(cx: &Context, left: &Expr, right: &Expr, op: F)\n+        -> Option<Constant>\n+where F: FnMut(ConstantVariant, ConstantVariant) -> Option<ConstantVariant> {\n+    constant(cx, left).and_then(|l| constant(cx, right).and_then(\n+        |r| Constant {\n+            needed_resolution: l.needed_resolution || r.needed_resolution,\n+            constant: op(l.constant, r.constant)\n+        }))\n }\n \n-fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool,\n-        follow: bool) -> Option<Constant> {\n-    if let ConstantBool(lbool) = constant(cx, left, follow) {\n+fn constant_short_circuit(cx: &Context, left: &Expr, right: &Expr, b: bool) ->\n+        Option<Constant> {\n+    let leftconst = constant(cx, left);\n+    if let ConstantBool(lbool) = leftconst.constant {\n         if l == b {\n-            Some(ConstantBool(b))\n+            Some(leftconst)\n         } else {\n-            if let ConstantBool(rbool) = constant(cx, right, follow) {\n-                Some(ConstantBool(rbool))\n+            let rightconst = constant(cx, right);\n+            if let ConstantBool(rbool) = rightconst.constant {\n+                Some(Constant {\n+                    constant: rightconst.constant,\n+                    needed_resolution: leftconst.needed_resolution ||\n+                                       rightconst.needed_resolution,\n+                })\n             } else { None }\n         }\n     } else { None }"}]}