{"sha": "e18748ed152989953e39492a6b44f8001267ce5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODc0OGVkMTUyOTg5OTUzZTM5NDkyYTZiNDRmODAwMTI2N2NlNWY=", "commit": {"author": {"name": "Dmitry", "email": "mamhigtt@gmail.com", "date": "2020-08-18T12:37:22Z"}, "committer": {"name": "Dmitry", "email": "mamhigtt@gmail.com", "date": "2020-08-18T12:37:22Z"}, "message": "Merge remote-tracking branch 'rust-analyzer/master'", "tree": {"sha": "300dc7ce2998d9521319ff76f4df6ec2d165d0a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/300dc7ce2998d9521319ff76f4df6ec2d165d0a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e18748ed152989953e39492a6b44f8001267ce5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e18748ed152989953e39492a6b44f8001267ce5f", "html_url": "https://github.com/rust-lang/rust/commit/e18748ed152989953e39492a6b44f8001267ce5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e18748ed152989953e39492a6b44f8001267ce5f/comments", "author": {"login": "godcodehunter", "id": 22272886, "node_id": "MDQ6VXNlcjIyMjcyODg2", "avatar_url": "https://avatars.githubusercontent.com/u/22272886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/godcodehunter", "html_url": "https://github.com/godcodehunter", "followers_url": "https://api.github.com/users/godcodehunter/followers", "following_url": "https://api.github.com/users/godcodehunter/following{/other_user}", "gists_url": "https://api.github.com/users/godcodehunter/gists{/gist_id}", "starred_url": "https://api.github.com/users/godcodehunter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/godcodehunter/subscriptions", "organizations_url": "https://api.github.com/users/godcodehunter/orgs", "repos_url": "https://api.github.com/users/godcodehunter/repos", "events_url": "https://api.github.com/users/godcodehunter/events{/privacy}", "received_events_url": "https://api.github.com/users/godcodehunter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "godcodehunter", "id": 22272886, "node_id": "MDQ6VXNlcjIyMjcyODg2", "avatar_url": "https://avatars.githubusercontent.com/u/22272886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/godcodehunter", "html_url": "https://github.com/godcodehunter", "followers_url": "https://api.github.com/users/godcodehunter/followers", "following_url": "https://api.github.com/users/godcodehunter/following{/other_user}", "gists_url": "https://api.github.com/users/godcodehunter/gists{/gist_id}", "starred_url": "https://api.github.com/users/godcodehunter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/godcodehunter/subscriptions", "organizations_url": "https://api.github.com/users/godcodehunter/orgs", "repos_url": "https://api.github.com/users/godcodehunter/repos", "events_url": "https://api.github.com/users/godcodehunter/events{/privacy}", "received_events_url": "https://api.github.com/users/godcodehunter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73315c9168901ef6d676f017daaa9b4976380c03", "url": "https://api.github.com/repos/rust-lang/rust/commits/73315c9168901ef6d676f017daaa9b4976380c03", "html_url": "https://github.com/rust-lang/rust/commit/73315c9168901ef6d676f017daaa9b4976380c03"}, {"sha": "b8dfc331abbfce6aad0c248c91c57bd9890a668f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8dfc331abbfce6aad0c248c91c57bd9890a668f", "html_url": "https://github.com/rust-lang/rust/commit/b8dfc331abbfce6aad0c248c91c57bd9890a668f"}], "stats": {"total": 1186, "additions": 859, "deletions": 327}, "files": [{"sha": "fb077e28d587107eeb21664d83cf56e948ebf6cf", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -25,7 +25,7 @@ jobs:\n     strategy:\n       fail-fast: false\n       matrix:\n-        os: [ubuntu-latest, windows-latest] #, macos-latest]\n+        os: [ubuntu-latest, windows-latest, macos-latest]\n \n     steps:\n     - name: Checkout repository\n@@ -70,10 +70,6 @@ jobs:\n     - name: Prepare cache\n       run: cargo xtask pre-cache\n \n-    - name: Prepare cache 2\n-      if: matrix.os == 'windows-latest'\n-      run: Remove-Item ./target/debug/xtask.exe, ./target/debug/deps/xtask.exe\n-\n   # Weird targets to catch non-portable code\n   rust-cross:\n     name: Rust Cross"}, {"sha": "ffa3851068c230a764e316524b0b1a313ad51f5d", "filename": "Cargo.lock", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -162,9 +162,9 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.21.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1df0dbb57d74b4acd20f20fa66ab2acd09776b79eaeb9d8f947b2f3e01c40bf\"\n+checksum = \"c3cb438e961fd7f1183dc5e0bdcfd09253bf9b90592cf665d1ce6787d8a4908f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -174,19 +174,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.21.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44361a25dbdb1dc428f56ad7a3c21ba9ca12f3225c26a47919ff6fcb10a583d4\"\n+checksum = \"bb332abfcb015b148c6fbab39b1d13282745b0f7f312019dd8e138f5f3f0855d\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.21.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dd89556b98de156d5eaf21077d297cd2198628f10f2df140798ea3a5dd84bc86\"\n+checksum = \"e7c7673f10c5fa1acf7fa07d4f4c5917cbcf161ed3a952d14530c79950de32d2\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -197,9 +197,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.21.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a886da37a0dc457057d86f78f026f7a09c6d8088aa13f4f4127fdb8dc80119a3\"\n+checksum = \"802de4eff72e5a5d2828e6c07224c74d66949dc6308aff025d0ae2871a11b4eb\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -214,9 +214,9 @@ dependencies = [\n \n [[package]]\n name = \"chrono\"\n-version = \"0.4.13\"\n+version = \"0.4.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c74d84029116787153e02106bf53e66828452a4b325cc8652b788b5967c0a0b6\"\n+checksum = \"942f72db697d8767c22d46a598e01f2d3b475501ea43d0db4f16d90259182d0b\"\n dependencies = [\n  \"num-integer\",\n  \"num-traits\",\n@@ -765,9 +765,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-server\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53b4ace8ebe5d2aff3687ce0ed507f6020d6a47a7de2b0d3d664ea237ffb0c62\"\n+checksum = \"87fce8851309a325974ec76efe7c9d954d152c9ff4fded6520eb3c96d0aa3a96\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"log\",\n@@ -971,9 +971,9 @@ checksum = \"1ab52be62400ca80aa00285d25253d7f7c437b7375c4de678f5405d3afe82ca5\"\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.4.0\"\n+version = \"1.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n+checksum = \"260e51e7efe62b592207e9e13a68e43692a7a279171d6ba57abd208bf23645ad\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1036,9 +1036,9 @@ dependencies = [\n \n [[package]]\n name = \"perf-event-open-sys\"\n-version = \"0.3.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"83e7183862f36d10263d0a1ccaef50fef734ade948bf026afd1bd97355c78273\"\n+checksum = \"d9ebe2b9ef0cb884ef778c5a533144e348e9839a9fcf67f3d24e1890ac9088d6\"\n dependencies = [\n  \"libc\",\n ]\n@@ -1097,12 +1097,17 @@ dependencies = [\n  \"mbe\",\n  \"memmap\",\n  \"proc_macro_api\",\n+ \"proc_macro_test\",\n  \"serde_derive\",\n  \"test_utils\",\n  \"toolchain\",\n  \"tt\",\n ]\n \n+[[package]]\n+name = \"proc_macro_test\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"profile\"\n version = \"0.0.0\"\n@@ -1259,9 +1264,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"671.0.0\"\n+version = \"673.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22e1221f3bfa2943c942cf8da319ab2346887f8757778c29c7f1822cd27b521f\"\n+checksum = \"f6b71fa1285bdefe5fb61e59b63d6cc246abf337f4acafdd620d721bc488e671\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1450,6 +1455,7 @@ dependencies = [\n  \"expect\",\n  \"hir\",\n  \"ide_db\",\n+ \"itertools\",\n  \"rustc-hash\",\n  \"syntax\",\n  \"test_utils\",\n@@ -1573,9 +1579,9 @@ dependencies = [\n \n [[package]]\n name = \"tinyvec\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53953d2d3a5ad81d9f844a32f14ebb121f50b650cd59d0ee2a07cf13c617efed\"\n+checksum = \"238ce071d267c5710f9d31451efec16c5ee22de34df17cc05e56cbc92e967117\"\n \n [[package]]\n name = \"toolchain\""}, {"sha": "5216862ba52d2f767ba0a3350f7d8d1e88d2bc93", "filename": "crates/assists/src/ast_transform.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fast_transform.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -7,6 +7,17 @@ use syntax::{\n     ast::{self, AstNode},\n };\n \n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n+    SyntaxRewriter::from_fn(|element| match element {\n+        syntax::SyntaxElement::Node(n) => {\n+            let replacement = transformer.get_substitution(&n)?;\n+            Some(replacement.into())\n+        }\n+        _ => None,\n+    })\n+    .rewrite_ast(&node)\n+}\n+\n pub trait AstTransform<'a> {\n     fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode>;\n \n@@ -107,10 +118,7 @@ impl<'a> SubstituteTypeParams<'a> {\n             ast::Type::PathType(path_type) => path_type.path()?,\n             _ => return None,\n         };\n-        // FIXME: use `hir::Path::from_src` instead.\n-        #[allow(deprecated)]\n-        let path = hir::Path::from_ast(path)?;\n-        let resolution = self.source_scope.resolve_hir_path(&path)?;\n+        let resolution = self.source_scope.speculative_resolve(&path)?;\n         match resolution {\n             hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n             _ => None,\n@@ -146,10 +154,7 @@ impl<'a> QualifyPaths<'a> {\n             // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n             return None;\n         }\n-        // FIXME: use `hir::Path::from_src` instead.\n-        #[allow(deprecated)]\n-        let hir_path = hir::Path::from_ast(p.clone());\n-        let resolution = self.source_scope.resolve_hir_path(&hir_path?)?;\n+        let resolution = self.source_scope.speculative_resolve(&p)?;\n         match resolution {\n             PathResolution::Def(def) => {\n                 let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n@@ -175,17 +180,6 @@ impl<'a> QualifyPaths<'a> {\n     }\n }\n \n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n-    SyntaxRewriter::from_fn(|element| match element {\n-        syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n)?;\n-            Some(replacement.into())\n-        }\n-        _ => None,\n-    })\n-    .rewrite_ast(&node)\n-}\n-\n impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n     fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n         self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))"}, {"sha": "83a2ada9a288f42d6518235145087d452cd7ee74", "filename": "crates/assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -48,7 +48,6 @@ enum AddMissingImplMembersMode {\n //     fn foo(&self) -> u32 {\n //         ${0:todo!()}\n //     }\n-//\n // }\n // ```\n pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -89,8 +88,8 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n // impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}\n-//     $0fn bar(&self) {}\n //\n+//     $0fn bar(&self) {}\n // }\n // ```\n pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -240,15 +239,18 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n+\n     $0type Output;\n+\n     const CONST: usize = 42;\n+\n     fn foo(&self) {\n         todo!()\n     }\n+\n     fn baz(&self) {\n         todo!()\n     }\n-\n }\"#,\n         );\n     }\n@@ -281,10 +283,10 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n+\n     fn foo(&self) {\n         ${0:todo!()}\n     }\n-\n }\"#,\n         );\n     }\n@@ -599,6 +601,7 @@ trait Foo {\n struct S;\n impl Foo for S {\n     $0type Output;\n+\n     fn foo(&self) {\n         todo!()\n     }\n@@ -705,6 +708,58 @@ trait Tr {\n \n impl Tr for () {\n     $0type Ty;\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_whitespace_fixup_preserves_bad_tokens() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for ()<|> {\n+    +++\n+}\"#,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for () {\n+    fn foo() {\n+        ${0:todo!()}\n+    }\n+    +++\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_whitespace_fixup_preserves_comments() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for ()<|> {\n+    // very important\n+}\"#,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for () {\n+    fn foo() {\n+        ${0:todo!()}\n+    }\n+    // very important\n }\"#,\n         )\n     }"}, {"sha": "b9ec3f10b65e2adefbba3b63265753cc839a7dac", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             |builder| {\n                 insert_use_statement(\n                     &auto_import_assets.syntax_under_caret,\n-                    &import,\n+                    &import.to_string(),\n                     ctx,\n                     builder.text_edit_builder(),\n                 );"}, {"sha": "81d0af2f353485735d44ae64ed80f79493732e2d", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n use ide_db::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n@@ -10,8 +11,6 @@ use crate::{\n     AssistId, AssistKind,\n };\n \n-use either::Either;\n-\n // Assist: expand_glob_import\n //\n // Expands glob imports.\n@@ -40,11 +39,15 @@ use either::Either;\n pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let star = ctx.find_token_at_offset(T![*])?;\n     let mod_path = find_mod_path(&star)?;\n+    let module = match ctx.sema.resolve_path(&mod_path)? {\n+        PathResolution::Def(ModuleDef::Module(it)) => it,\n+        _ => return None,\n+    };\n \n     let source_file = ctx.source_file();\n     let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n \n-    let defs_in_mod = find_defs_in_mod(ctx, scope, &mod_path)?;\n+    let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n     let name_refs_in_source_file =\n         source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n     let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n@@ -82,17 +85,8 @@ impl Def {\n fn find_defs_in_mod(\n     ctx: &AssistContext,\n     from: SemanticsScope<'_>,\n-    path: &ast::Path,\n+    module: hir::Module,\n ) -> Option<Vec<Def>> {\n-    let hir_path = ctx.sema.lower_path(&path)?;\n-    let module = if let Some(PathResolution::Def(ModuleDef::Module(module))) =\n-        from.resolve_hir_path_qualifier(&hir_path)\n-    {\n-        module\n-    } else {\n-        return None;\n-    };\n-\n     let module_scope = module.scope(ctx.db(), from.module());\n \n     let mut defs = vec![];"}, {"sha": "d62e06b4a81f32388125843933ffe1065518dccd", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -106,7 +106,12 @@ fn insert_import(\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n-        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+        insert_use_statement(\n+            path.syntax(),\n+            &mod_path.to_string(),\n+            ctx,\n+            builder.text_edit_builder(),\n+        );\n     }\n     Some(())\n }"}, {"sha": "470e5f8ff752bfcd6928de55c2250ff351e9d0bd", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -1,5 +1,5 @@\n-use hir;\n-use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode, TextRange};\n+use test_utils::mark;\n \n use crate::{\n     utils::{find_insert_use_container, insert_use_statement},\n@@ -28,25 +28,36 @@ pub(crate) fn replace_qualified_name_with_use(\n     if path.syntax().ancestors().find_map(ast::Use::cast).is_some() {\n         return None;\n     }\n-\n-    let hir_path = ctx.sema.lower_path(&path)?;\n-    let segments = collect_hir_path_segments(&hir_path)?;\n-    if segments.len() < 2 {\n+    if path.qualifier().is_none() {\n+        mark::hit!(dont_import_trivial_paths);\n         return None;\n     }\n+    let path_to_import = path.to_string().clone();\n+    let path_to_import = match path.segment()?.generic_arg_list() {\n+        Some(generic_args) => {\n+            let generic_args_start =\n+                generic_args.syntax().text_range().start() - path.syntax().text_range().start();\n+            &path_to_import[TextRange::up_to(generic_args_start)]\n+        }\n+        None => path_to_import.as_str(),\n+    };\n \n     let target = path.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n         target,\n         |builder| {\n-            let path_to_import = hir_path.mod_path().clone();\n             let container = match find_insert_use_container(path.syntax(), ctx) {\n                 Some(c) => c,\n                 None => return,\n             };\n-            insert_use_statement(path.syntax(), &path_to_import, ctx, builder.text_edit_builder());\n+            insert_use_statement(\n+                path.syntax(),\n+                &path_to_import.to_string(),\n+                ctx,\n+                builder.text_edit_builder(),\n+            );\n \n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n@@ -58,26 +69,6 @@ pub(crate) fn replace_qualified_name_with_use(\n     )\n }\n \n-fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n-    let mut ps = Vec::<SmolStr>::with_capacity(10);\n-    match path.kind() {\n-        hir::PathKind::Abs => ps.push(\"\".into()),\n-        hir::PathKind::Crate => ps.push(\"crate\".into()),\n-        hir::PathKind::Plain => {}\n-        hir::PathKind::Super(0) => ps.push(\"self\".into()),\n-        hir::PathKind::Super(lvl) => {\n-            let mut chain = \"super\".to_string();\n-            for _ in 0..*lvl {\n-                chain += \"::super\";\n-            }\n-            ps.push(chain.into());\n-        }\n-        hir::PathKind::DollarCrate(_) => return None,\n-    }\n-    ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n-    Some(ps)\n-}\n-\n /// Adds replacements to `re` that shorten `path` in all descendants of `node`.\n fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path: ast::Path) {\n     for child in node.children() {\n@@ -467,7 +458,8 @@ impl Debug for Foo {\n     }\n \n     #[test]\n-    fn test_replace_not_applicable_one_segment() {\n+    fn dont_import_trivial_paths() {\n+        mark::check!(dont_import_trivial_paths);\n         check_assist_not_applicable(\n             replace_qualified_name_with_use,\n             r\""}, {"sha": "c589b08dc4bdc0bb3288caa83eaee1a48efd298a", "filename": "crates/assists/src/lib.rs", "status": "modified", "additions": 10, "deletions": 27, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -66,13 +66,13 @@ pub struct GroupLabel(pub String);\n \n #[derive(Debug, Clone)]\n pub struct Assist {\n-    id: AssistId,\n+    pub id: AssistId,\n     /// Short description of the assist, as shown in the UI.\n     label: String,\n-    group: Option<GroupLabel>,\n+    pub group: Option<GroupLabel>,\n     /// Target ranges are used to sort assists: the smaller the target range,\n     /// the more specific assist is, and so it should be sorted first.\n-    target: TextRange,\n+    pub target: TextRange,\n }\n \n #[derive(Debug, Clone)]\n@@ -82,6 +82,11 @@ pub struct ResolvedAssist {\n }\n \n impl Assist {\n+    fn new(id: AssistId, label: String, group: Option<GroupLabel>, target: TextRange) -> Assist {\n+        assert!(label.starts_with(char::is_uppercase));\n+        Assist { id, label, group, target }\n+    }\n+\n     /// Return all the assists applicable at the given position.\n     ///\n     /// Assists are returned in the \"unresolved\" state, that is only labels are\n@@ -114,30 +119,8 @@ impl Assist {\n         acc.finish_resolved()\n     }\n \n-    pub(crate) fn new(\n-        id: AssistId,\n-        label: String,\n-        group: Option<GroupLabel>,\n-        target: TextRange,\n-    ) -> Assist {\n-        assert!(label.starts_with(|c: char| c.is_uppercase()));\n-        Assist { id, label, group, target }\n-    }\n-\n-    pub fn id(&self) -> AssistId {\n-        self.id\n-    }\n-\n-    pub fn label(&self) -> String {\n-        self.label.clone()\n-    }\n-\n-    pub fn group(&self) -> Option<GroupLabel> {\n-        self.group.clone()\n-    }\n-\n-    pub fn target(&self) -> TextRange {\n-        self.target\n+    pub fn label(&self) -> &str {\n+        self.label.as_str()\n     }\n }\n "}, {"sha": "17356700373c104f10b5d2d55360a279f3b9a465", "filename": "crates/assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -82,8 +82,8 @@ trait Trait {\n impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n-    $0fn bar(&self) {}\n \n+    $0fn bar(&self) {}\n }\n \"#####,\n     )\n@@ -115,7 +115,6 @@ impl Trait<u32> for () {\n     fn foo(&self) -> u32 {\n         ${0:todo!()}\n     }\n-\n }\n \"#####,\n     )"}, {"sha": "49096a67c7aef3e266392a6c865124a7b683e876", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -5,7 +5,6 @@\n use std::iter::successors;\n \n use either::Either;\n-use hir::{self, ModPath};\n use syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n     AstNode, AstToken, Direction, SmolStr,\n@@ -35,11 +34,11 @@ pub(crate) fn find_insert_use_container(\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n-    path_to_import: &ModPath,\n+    path_to_import: &str,\n     ctx: &AssistContext,\n     builder: &mut TextEditBuilder,\n ) {\n-    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n+    let target = path_to_import.split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n     let container = find_insert_use_container(position, ctx);\n \n     if let Some(container) = container {"}, {"sha": "c442654dd0fc2ddc3d3229d9e65656eed11436b0", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n+    path::ModPath,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -344,11 +345,7 @@ impl Module {\n \n     /// Finds a path that can be used to refer to the given item from within\n     /// this module, if possible.\n-    pub fn find_use_path(\n-        self,\n-        db: &dyn DefDatabase,\n-        item: impl Into<ItemInNs>,\n-    ) -> Option<hir_def::path::ModPath> {\n+    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n         hir_def::find_path::find_path(db, item.into(), self.into())\n     }\n }\n@@ -1126,7 +1123,7 @@ impl ImplDef {\n             .value\n             .attrs()\n             .filter_map(|it| {\n-                let path = hir_def::path::ModPath::from_src(it.path()?, &hygenic)?;\n+                let path = ModPath::from_src(it.path()?, &hygenic)?;\n                 if path.as_ident()?.to_string() == \"derive\" {\n                     Some(it)\n                 } else {"}, {"sha": "8961ba8fd6c52b8363e9d6ea468396ed0db9ef19", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -48,7 +48,7 @@ pub use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     nameres::ModuleSource,\n-    path::{ModPath, Path, PathKind},\n+    path::ModPath,\n     type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n@@ -60,4 +60,7 @@ pub use hir_ty::display::HirDisplay;\n // These are negative re-exports: pub using these names is forbidden, they\n // should remain private to hir internals.\n #[allow(unused)]\n-use hir_expand::hygiene::Hygiene;\n+use {\n+    hir_def::path::{Path, PathKind},\n+    hir_expand::hygiene::Hygiene,\n+};"}, {"sha": "c693176fa48f3ae7910708c69ca3115abf13880e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -6,7 +6,7 @@ use std::{cell::RefCell, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n use hir_def::{\n-    resolver::{self, HasResolver, Resolver},\n+    resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n@@ -22,12 +22,11 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n     Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, TypeRef,\n     VariantDef,\n };\n-use resolver::TypeNs;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathResolution {\n@@ -228,10 +227,6 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_variant(record_lit).map(VariantDef::from)\n     }\n \n-    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        self.imp.lower_path(path)\n-    }\n-\n     pub fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n@@ -467,11 +462,6 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n     }\n \n-    fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        let src = self.find_file(path.syntax().clone());\n-        Path::from_src(path.clone(), &Hygiene::new(self.db.upcast(), src.file_id.into()))\n-    }\n-\n     fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n@@ -758,28 +748,7 @@ impl<'a> SemanticsScope<'a> {\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n         let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n         let path = Path::from_src(path.clone(), &hygiene)?;\n-        self.resolve_hir_path(&path)\n-    }\n-\n-    pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path(self.db, &self.resolver, path)\n-    }\n-\n-    /// Resolves a path where we know it is a qualifier of another path.\n-    ///\n-    /// For example, if we have:\n-    /// ```\n-    /// mod my {\n-    ///     pub mod foo {\n-    ///         struct Bar;\n-    ///     }\n-    ///\n-    ///     pub fn foo() {}\n-    /// }\n-    /// ```\n-    /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+        resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }\n "}, {"sha": "1d13c4f1d3b7d276b883e0f9edb6e52a59ec9c1a", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n@@ -28,8 +29,7 @@ use syntax::{\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, Const, EnumVariant, Field, Function, Local,\n-    MacroDef, ModPath, ModuleDef, Path, PathKind, Static, Struct, Trait, Type, TypeAlias,\n-    TypeParam,\n+    MacroDef, ModuleDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n use base_db::CrateId;\n \n@@ -508,7 +508,7 @@ pub(crate) fn resolve_hir_path(\n /// }\n /// ```\n /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-pub(crate) fn resolve_hir_path_qualifier(\n+fn resolve_hir_path_qualifier(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n     path: &Path,"}, {"sha": "c7723de0067a0d86baaea4a019a3f6def98717e1", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -15,6 +15,9 @@ pub struct UnresolvedModule {\n }\n \n impl Diagnostic for UnresolvedModule {\n+    fn name(&self) -> &'static str {\n+        \"unresolved-module\"\n+    }\n     fn message(&self) -> String {\n         \"unresolved module\".to_string()\n     }"}, {"sha": "99395667defcde5c9e23fc5d2ffa5ee48cd3f62f", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -153,12 +153,6 @@ pub enum GenericArg {\n }\n \n impl Path {\n-    /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    #[deprecated = \"Doesn't handle hygiene, don't add new calls, remove old ones\"]\n-    pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        lower::lower_path(path, &Hygiene::new_unhygienic())\n-    }\n-\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {"}, {"sha": "6c81b2501a5ba52afdc29b940fd058a134b8bbe9", "filename": "crates/hir_expand/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -21,6 +21,7 @@ use syntax::SyntaxNodePtr;\n use crate::InFile;\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n+    fn name(&self) -> &'static str;\n     fn message(&self) -> String;\n     /// Used in highlighting and related purposes\n     fn display_source(&self) -> InFile<SyntaxNodePtr>;"}, {"sha": "a319b0ce8e34cc535758f6d8063a3bba00c02d8b", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -16,9 +16,9 @@ ena = \"0.14.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1\"\n-chalk-solve = { version = \"0.21.0\" }\n-chalk-ir = { version = \"0.21.0\" }\n-chalk-recursive = { version = \"0.21.0\" }\n+chalk-solve = { version = \"0.23.0\" }\n+chalk-ir = { version = \"0.23.0\" }\n+chalk-recursive = { version = \"0.23.0\" }\n \n stdx = { path = \"../stdx\" }\n hir_def = { path = \"../hir_def\" }"}, {"sha": "38fa24ee0a264a08677f5784aeda8d2bc0c12643", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -32,6 +32,10 @@ pub struct NoSuchField {\n }\n \n impl Diagnostic for NoSuchField {\n+    fn name(&self) -> &'static str {\n+        \"no-such-field\"\n+    }\n+\n     fn message(&self) -> String {\n         \"no such field\".to_string()\n     }\n@@ -54,6 +58,9 @@ pub struct MissingFields {\n }\n \n impl Diagnostic for MissingFields {\n+    fn name(&self) -> &'static str {\n+        \"missing-structure-fields\"\n+    }\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n@@ -87,6 +94,9 @@ pub struct MissingPatFields {\n }\n \n impl Diagnostic for MissingPatFields {\n+    fn name(&self) -> &'static str {\n+        \"missing-pat-fields\"\n+    }\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n@@ -117,6 +127,9 @@ pub struct MissingMatchArms {\n }\n \n impl Diagnostic for MissingMatchArms {\n+    fn name(&self) -> &'static str {\n+        \"missing-match-arm\"\n+    }\n     fn message(&self) -> String {\n         String::from(\"Missing match arm\")\n     }\n@@ -135,6 +148,9 @@ pub struct MissingOkInTailExpr {\n }\n \n impl Diagnostic for MissingOkInTailExpr {\n+    fn name(&self) -> &'static str {\n+        \"missing-ok-in-tail-expr\"\n+    }\n     fn message(&self) -> String {\n         \"wrap return expression in Ok\".to_string()\n     }\n@@ -153,6 +169,9 @@ pub struct BreakOutsideOfLoop {\n }\n \n impl Diagnostic for BreakOutsideOfLoop {\n+    fn name(&self) -> &'static str {\n+        \"break-outside-of-loop\"\n+    }\n     fn message(&self) -> String {\n         \"break outside of loop\".to_string()\n     }\n@@ -171,6 +190,9 @@ pub struct MissingUnsafe {\n }\n \n impl Diagnostic for MissingUnsafe {\n+    fn name(&self) -> &'static str {\n+        \"missing-unsafe\"\n+    }\n     fn message(&self) -> String {\n         format!(\"This operation is unsafe and requires an unsafe function or block\")\n     }\n@@ -191,6 +213,9 @@ pub struct MismatchedArgCount {\n }\n \n impl Diagnostic for MismatchedArgCount {\n+    fn name(&self) -> &'static str {\n+        \"mismatched-arg-count\"\n+    }\n     fn message(&self) -> String {\n         let s = if self.expected == 1 { \"\" } else { \"s\" };\n         format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)"}, {"sha": "278a4b94726aca5bcd31aaf860a3b99a7d94019f", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -223,10 +223,10 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             db.body_with_source_map(self.owner.into());\n \n         let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n-            Some(ty) => ty,\n             // If we can't resolve the type of the match expression\n             // we cannot perform exhaustiveness checks.\n-            None => return,\n+            None | Some(Ty::Unknown) => return,\n+            Some(ty) => ty,\n         };\n \n         let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };"}, {"sha": "5bd03f2ac00d1c6046ded5f1960a0c8773c3d4b0", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -1335,6 +1335,23 @@ fn panic(a: Category, b: Category) {\n         );\n     }\n \n+    #[test]\n+    fn unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}, {"sha": "14cd3a2b446745baa2d6dc87b0a547ea725da678", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -170,11 +170,11 @@ fn solve(\n     let mut solve = || {\n         if is_chalk_print() {\n             let logging_db = LoggingRustIrDatabase::new(context);\n-            let solution = solver.solve_limited(&logging_db, goal, should_continue);\n+            let solution = solver.solve_limited(&logging_db, goal, &should_continue);\n             log::debug!(\"chalk program:\\n{}\", logging_db);\n             solution\n         } else {\n-            solver.solve_limited(&context, goal, should_continue)\n+            solver.solve_limited(&context, goal, &should_continue)\n         }\n     };\n "}, {"sha": "606a6064b42f796f3a68632d09eeb5e1c34ec896", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -4,7 +4,7 @@\n //! macro-expanded files, but we need to present them to the users in terms of\n //! original files. So we need to map the ranges.\n \n-use std::cell::RefCell;\n+use std::{cell::RefCell, collections::HashSet};\n \n use base_db::SourceDatabase;\n use hir::{diagnostics::DiagnosticSinkBuilder, Semantics};\n@@ -31,6 +31,7 @@ pub(crate) fn diagnostics(\n     db: &RootDatabase,\n     file_id: FileId,\n     enable_experimental: bool,\n+    disabled_diagnostics: Option<HashSet<String>>,\n ) -> Vec<Diagnostic> {\n     let _p = profile::span(\"diagnostics\");\n     let sema = Semantics::new(db);\n@@ -39,6 +40,7 @@ pub(crate) fn diagnostics(\n \n     // [#34344] Only take first 128 errors to prevent slowing down editor/ide, the number 128 is chosen arbitrarily.\n     res.extend(parse.errors().iter().take(128).map(|err| Diagnostic {\n+        name: None,\n         range: err.range(),\n         message: format!(\"Syntax Error: {}\", err),\n         severity: Severity::Error,\n@@ -50,7 +52,7 @@ pub(crate) fn diagnostics(\n         check_struct_shorthand_initialization(&mut res, file_id, &node);\n     }\n     let res = RefCell::new(res);\n-    let mut sink = DiagnosticSinkBuilder::new()\n+    let mut sink_builder = DiagnosticSinkBuilder::new()\n         .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n@@ -64,10 +66,19 @@ pub(crate) fn diagnostics(\n             res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         // Only collect experimental diagnostics when they're enabled.\n-        .filter(|diag| !diag.is_experimental() || enable_experimental)\n+        .filter(|diag| !diag.is_experimental() || enable_experimental);\n+\n+    if let Some(disabled_diagnostics) = disabled_diagnostics {\n+        // Do not collect disabled diagnostics.\n+        sink_builder = sink_builder.filter(move |diag| !disabled_diagnostics.contains(diag.name()));\n+    }\n+\n+    // Finalize the `DiagnosticSink` building process.\n+    let mut sink = sink_builder\n         // Diagnostics not handled above get no fix and default treatment.\n         .build(|d| {\n             res.borrow_mut().push(Diagnostic {\n+                name: Some(d.name().into()),\n                 message: d.message(),\n                 range: sema.diagnostics_display_range(d).range,\n                 severity: Severity::Error,\n@@ -84,6 +95,7 @@ pub(crate) fn diagnostics(\n \n fn diagnostic_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n     Diagnostic {\n+        name: Some(d.name().into()),\n         range: sema.diagnostics_display_range(d).range,\n         message: d.message(),\n         severity: Severity::Error,\n@@ -110,6 +122,7 @@ fn check_unnecessary_braces_in_use_statement(\n                 });\n \n         acc.push(Diagnostic {\n+            name: None,\n             range: use_range,\n             message: \"Unnecessary braces in use statement\".to_string(),\n             severity: Severity::WeakWarning,\n@@ -156,6 +169,7 @@ fn check_struct_shorthand_initialization(\n \n                 let field_range = record_field.syntax().text_range();\n                 acc.push(Diagnostic {\n+                    name: None,\n                     range: field_range,\n                     message: \"Shorthand struct initialization\".to_string(),\n                     severity: Severity::WeakWarning,\n@@ -173,6 +187,7 @@ fn check_struct_shorthand_initialization(\n \n #[cfg(test)]\n mod tests {\n+    use std::collections::HashSet;\n     use stdx::trim_indent;\n     use test_utils::assert_eq_text;\n \n@@ -188,7 +203,8 @@ mod tests {\n         let after = trim_indent(ra_fixture_after);\n \n         let (analysis, file_position) = analysis_and_position(ra_fixture_before);\n-        let diagnostic = analysis.diagnostics(file_position.file_id, true).unwrap().pop().unwrap();\n+        let diagnostic =\n+            analysis.diagnostics(file_position.file_id, true, None).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n         let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n@@ -214,7 +230,7 @@ mod tests {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, file_pos) = analysis_and_position(ra_fixture_before);\n         let current_file_id = file_pos.file_id;\n-        let diagnostic = analysis.diagnostics(current_file_id, true).unwrap().pop().unwrap();\n+        let diagnostic = analysis.diagnostics(current_file_id, true, None).unwrap().pop().unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap();\n         let changed_file_id = edit.file_id;\n@@ -235,14 +251,58 @@ mod tests {\n         let analysis = mock.analysis();\n         let diagnostics = files\n             .into_iter()\n-            .flat_map(|file_id| analysis.diagnostics(file_id, true).unwrap())\n+            .flat_map(|file_id| analysis.diagnostics(file_id, true, None).unwrap())\n             .collect::<Vec<_>>();\n         assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n     }\n \n+    /// Takes a multi-file input fixture with annotated cursor position and the list of disabled diagnostics,\n+    /// and checks that provided diagnostics aren't spawned during analysis.\n+    fn check_disabled_diagnostics(ra_fixture: &str, disabled_diagnostics: &[&'static str]) {\n+        let disabled_diagnostics: HashSet<_> =\n+            disabled_diagnostics.into_iter().map(|diag| diag.to_string()).collect();\n+\n+        let mock = MockAnalysis::with_files(ra_fixture);\n+        let files = mock.files().map(|(it, _)| it).collect::<Vec<_>>();\n+        let analysis = mock.analysis();\n+\n+        let diagnostics = files\n+            .clone()\n+            .into_iter()\n+            .flat_map(|file_id| {\n+                analysis.diagnostics(file_id, true, Some(disabled_diagnostics.clone())).unwrap()\n+            })\n+            .collect::<Vec<_>>();\n+\n+        // First, we have to check that diagnostic is not emitted when it's added to the disabled diagnostics list.\n+        for diagnostic in diagnostics {\n+            if let Some(name) = diagnostic.name {\n+                assert!(!disabled_diagnostics.contains(&name), \"Diagnostic {} is disabled\", name);\n+            }\n+        }\n+\n+        // Then, we must reset the config and repeat the check, so that we'll be sure that without\n+        // config these diagnostics are emitted.\n+        // This is required for tests to not become outdated if e.g. diagnostics name changes:\n+        // without this additional run the test will pass simply because a diagnostic with an old name\n+        // will no longer exist.\n+        let diagnostics = files\n+            .into_iter()\n+            .flat_map(|file_id| analysis.diagnostics(file_id, true, None).unwrap())\n+            .collect::<Vec<_>>();\n+\n+        assert!(\n+            diagnostics\n+                .into_iter()\n+                .filter_map(|diag| diag.name)\n+                .any(|name| disabled_diagnostics.contains(&name)),\n+            \"At least one of the diagnostics was not emitted even without config; are the diagnostics names correct?\"\n+        );\n+    }\n+\n     fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = single_file(ra_fixture);\n-        let diagnostics = analysis.diagnostics(file_id, true).unwrap();\n+        let diagnostics = analysis.diagnostics(file_id, true, None).unwrap();\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n@@ -502,6 +562,9 @@ fn test_fn() {\n             expect![[r#\"\n                 [\n                     Diagnostic {\n+                        name: Some(\n+                            \"unresolved-module\",\n+                        ),\n                         message: \"unresolved module\",\n                         range: 0..8,\n                         severity: Error,\n@@ -675,4 +738,9 @@ struct Foo {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn test_disabled_diagnostics() {\n+        check_disabled_diagnostics(r#\"mod foo;\"#, &[\"unresolved-module\"]);\n+    }\n }"}, {"sha": "596bc872dbaadfc3ecda4fbbb975a80746adb74e", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -43,7 +43,7 @@ pub struct InlayHint {\n // rust-analyzer shows additional information inline with the source code.\n // Editors usually render this using read-only virtual text snippets interspersed with code.\n //\n-// rust-analyzer shows hits for\n+// rust-analyzer shows hints for\n //\n // * types of local variables\n // * names of function arguments"}, {"sha": "4b797f374c0e4ac504e651daccd8fe1f2120ee27", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -44,7 +44,7 @@ mod syntax_highlighting;\n mod syntax_tree;\n mod typing;\n \n-use std::sync::Arc;\n+use std::{collections::HashSet, sync::Arc};\n \n use base_db::{\n     salsa::{self, ParallelDatabase},\n@@ -101,6 +101,7 @@ pub type Cancelable<T> = Result<T, Canceled>;\n \n #[derive(Debug)]\n pub struct Diagnostic {\n+    pub name: Option<String>,\n     pub message: String,\n     pub range: TextRange,\n     pub severity: Severity,\n@@ -147,7 +148,7 @@ pub struct AnalysisHost {\n }\n \n impl AnalysisHost {\n-    pub fn new(lru_capacity: Option<usize>) -> AnalysisHost {\n+    pub fn new(lru_capacity: Option<usize>) -> Self {\n         AnalysisHost { db: RootDatabase::new(lru_capacity) }\n     }\n \n@@ -496,8 +497,11 @@ impl Analysis {\n         &self,\n         file_id: FileId,\n         enable_experimental: bool,\n+        disabled_diagnostics: Option<HashSet<String>>,\n     ) -> Cancelable<Vec<Diagnostic>> {\n-        self.with_db(|db| diagnostics::diagnostics(db, file_id, enable_experimental))\n+        self.with_db(|db| {\n+            diagnostics::diagnostics(db, file_id, enable_experimental, disabled_diagnostics)\n+        })\n     }\n \n     /// Returns the edit required to rename reference at the position to the new"}, {"sha": "d5e87cf7d59cbf5c5453c2d4cf0da381714292aa", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -89,9 +89,8 @@ impl ProcMacroClient {\n                 macros\n                     .into_iter()\n                     .filter_map(|(name, kind)| {\n-                        // FIXME: Support custom derive only for now.\n                         match kind {\n-                            ProcMacroKind::CustomDerive => {\n+                            ProcMacroKind::CustomDerive | ProcMacroKind::FuncLike => {\n                                 let name = SmolStr::new(&name);\n                                 let expander: Arc<dyn tt::TokenExpander> =\n                                     Arc::new(ProcMacroProcessExpander {\n@@ -101,7 +100,8 @@ impl ProcMacroClient {\n                                     });\n                                 Some((name, expander))\n                             }\n-                            _ => None,\n+                            // FIXME: Attribute macro are currently unsupported.\n+                            ProcMacroKind::Attr => None,\n                         }\n                     })\n                     .collect()"}, {"sha": "a468b5560982665bd0a95d923b585b7310b977f5", "filename": "crates/proc_macro_srv/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2FCargo.toml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -21,7 +21,9 @@ test_utils = { path = \"../test_utils\" }\n [dev-dependencies]\n cargo_metadata = \"0.11.1\"\n difference = \"2.0.0\"\n-# used as proc macro test target\n+\n+# used as proc macro test targets\n serde_derive = \"1.0.106\"\n+proc_macro_test = { path = \"../proc_macro_test\" }\n \n toolchain = { path = \"../toolchain\" }"}, {"sha": "1a827cbd76cec6c7959c7358efd3116566eef7ec", "filename": "crates/proc_macro_srv/src/tests/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Fmod.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -35,11 +35,24 @@ SUBTREE $\n \n #[test]\n fn test_derive_proc_macro_list() {\n-    let res = list(\"serde_derive\", \"1.0\").join(\"\\n\");\n+    let res = list(\"serde_derive\", \"1\").join(\"\\n\");\n \n     assert_eq_text!(\n         &res,\n         r#\"Serialize [CustomDerive]\n Deserialize [CustomDerive]\"#\n     );\n }\n+\n+/// Tests that we find and classify non-derive macros correctly.\n+#[test]\n+fn list_test_macros() {\n+    let res = list(\"proc_macro_test\", \"0.0.0\").join(\"\\n\");\n+\n+    assert_eq_text!(\n+        &res,\n+        r#\"function_like_macro [FuncLike]\n+attribute_macro [Attr]\n+DummyTrait [CustomDerive]\"#\n+    );\n+}"}, {"sha": "36942147d9e6fee60d1713c8e5d372855aa06b32", "filename": "crates/proc_macro_srv/src/tests/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Ftests%2Futils.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -13,7 +13,7 @@ mod fixtures {\n     // Use current project metadata to get the proc-macro dylib path\n     pub fn dylib_path(crate_name: &str, version: &str) -> std::path::PathBuf {\n         let command = Command::new(toolchain::cargo())\n-            .args(&[\"check\", \"--message-format\", \"json\"])\n+            .args(&[\"check\", \"--tests\", \"--message-format\", \"json\"])\n             .output()\n             .unwrap()\n             .stdout;"}, {"sha": "7b0f64f318c52dc3dafbe0ccf0530bc2ae44cecb", "filename": "crates/proc_macro_test/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_test%2FCargo.toml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+name = \"proc_macro_test\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+proc-macro = true"}, {"sha": "ec2a114a35d987f5dc23115a2892ff596a761365", "filename": "crates/proc_macro_test/src/lib.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fproc_macro_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_test%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -0,0 +1,18 @@\n+//! Exports a few trivial procedural macros for testing.\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn function_like_macro(args: TokenStream) -> TokenStream {\n+    args\n+}\n+\n+#[proc_macro_attribute]\n+pub fn attribute_macro(_args: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\n+#[proc_macro_derive(DummyTrait)]\n+pub fn derive_macro(_item: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "43f0196afc6ba76cc9ae66640c9c4525c7f00498", "filename": "crates/rust-analyzer/src/cli/analysis_bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_bench.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -71,7 +71,7 @@ impl BenchCmd {\n         match &self.what {\n             BenchWhat::Highlight { .. } => {\n                 let res = do_work(&mut host, file_id, |analysis| {\n-                    analysis.diagnostics(file_id, true).unwrap();\n+                    analysis.diagnostics(file_id, true, None).unwrap();\n                     analysis.highlight_as_html(file_id, false).unwrap()\n                 });\n                 if verbosity.is_verbose() {"}, {"sha": "31eb7ff3f889b6415f7e7f5a3467ed634168d03e", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -47,7 +47,7 @@ pub fn diagnostics(\n                 String::from(\"unknown\")\n             };\n             println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n-            for diagnostic in analysis.diagnostics(file_id, true).unwrap() {\n+            for diagnostic in analysis.diagnostics(file_id, true, None).unwrap() {\n                 if matches!(diagnostic.severity, Severity::Error) {\n                     found_error = true;\n                 }"}, {"sha": "44fd7c286fdee443481ddc605e70ef98f36dfe63", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -7,7 +7,7 @@\n //! configure the server itself, feature flags are passed into analysis, and\n //! tweak things like automatic insertion of `()` in completions.\n \n-use std::{ffi::OsString, path::PathBuf};\n+use std::{collections::HashSet, ffi::OsString, path::PathBuf};\n \n use flycheck::FlycheckConfig;\n use ide::{AssistConfig, CompletionConfig, HoverConfig, InlayHintsConfig};\n@@ -45,6 +45,14 @@ pub struct Config {\n     pub with_sysroot: bool,\n     pub linked_projects: Vec<LinkedProject>,\n     pub root_path: AbsPathBuf,\n+\n+    pub analysis: AnalysisConfig,\n+}\n+\n+/// Configuration parameters for the analysis run.\n+#[derive(Debug, Default, Clone)]\n+pub struct AnalysisConfig {\n+    pub disabled_diagnostics: HashSet<String>,\n }\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -176,6 +184,8 @@ impl Config {\n             hover: HoverConfig::default(),\n             linked_projects: Vec::new(),\n             root_path,\n+\n+            analysis: AnalysisConfig::default(),\n         }\n     }\n \n@@ -293,6 +303,8 @@ impl Config {\n             goto_type_def: data.hoverActions_enable && data.hoverActions_gotoTypeDef,\n         };\n \n+        self.analysis = AnalysisConfig { disabled_diagnostics: data.analysis_disabledDiagnostics };\n+\n         log::info!(\"Config::update() = {:#?}\", self);\n     }\n \n@@ -357,6 +369,14 @@ impl Config {\n             self.client_caps.status_notification = get_bool(\"statusNotification\");\n         }\n     }\n+\n+    pub fn disabled_diagnostics(&self) -> Option<HashSet<String>> {\n+        if self.analysis.disabled_diagnostics.is_empty() {\n+            None\n+        } else {\n+            Some(self.analysis.disabled_diagnostics.clone())\n+        }\n+    }\n }\n \n #[derive(Deserialize)]\n@@ -444,5 +464,7 @@ config_data! {\n         rustfmt_overrideCommand: Option<Vec<String>> = None,\n \n         withSysroot: bool = true,\n+\n+        analysis_disabledDiagnostics: HashSet<String> = HashSet::new(),\n     }\n }"}, {"sha": "4f77b1b4d26d970b3609ab979527a5e50cc87515", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -272,19 +272,24 @@ pub(crate) fn handle_document_symbol(\n         parents.push((doc_symbol, symbol.parent));\n     }\n     let mut document_symbols = Vec::new();\n+    // Constructs `document_symbols` from `parents`, in order from the end.\n     while let Some((node, parent)) = parents.pop() {\n         match parent {\n             None => document_symbols.push(node),\n             Some(i) => {\n-                let children = &mut parents[i].0.children;\n-                if children.is_none() {\n-                    *children = Some(Vec::new());\n-                }\n-                children.as_mut().unwrap().push(node);\n+                parents[i].0.children.get_or_insert_with(Vec::new).push(node);\n             }\n         }\n     }\n \n+    fn reverse(symbols: &mut Vec<DocumentSymbol>) {\n+        for sym in symbols.iter_mut() {\n+            sym.children.as_mut().map(|c| reverse(c));\n+        }\n+        symbols.reverse();\n+    }\n+    reverse(&mut document_symbols);\n+\n     let res = if snap.config.client_caps.hierarchical_symbols {\n         document_symbols.into()\n     } else {\n@@ -770,7 +775,11 @@ fn handle_fixes(\n         None => {}\n     };\n \n-    let diagnostics = snap.analysis.diagnostics(file_id, snap.config.experimental_diagnostics)?;\n+    let diagnostics = snap.analysis.diagnostics(\n+        file_id,\n+        snap.config.experimental_diagnostics,\n+        snap.config.disabled_diagnostics(),\n+    )?;\n \n     for fix in diagnostics\n         .into_iter()\n@@ -859,10 +868,10 @@ pub(crate) fn handle_resolve_code_action(\n         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n     let assists = snap.analysis.resolved_assists(&snap.config.assist, frange)?;\n-    let (id_string, index) = split_once(&params.id, ':').unwrap();\n+    let (id, index) = split_once(&params.id, ':').unwrap();\n     let index = index.parse::<usize>().unwrap();\n     let assist = &assists[index];\n-    assert!(assist.assist.id().0 == id_string);\n+    assert!(assist.assist.id.0 == id);\n     Ok(to_proto::resolved_code_action(&snap, assist.clone())?.edit)\n }\n \n@@ -1044,7 +1053,11 @@ pub(crate) fn publish_diagnostics(\n     let line_index = snap.analysis.file_line_index(file_id)?;\n     let diagnostics: Vec<Diagnostic> = snap\n         .analysis\n-        .diagnostics(file_id, snap.config.experimental_diagnostics)?\n+        .diagnostics(\n+            file_id,\n+            snap.config.experimental_diagnostics,\n+            snap.config.disabled_diagnostics(),\n+        )?\n         .into_iter()\n         .map(|d| Diagnostic {\n             range: to_proto::range(&line_index, d.range),"}, {"sha": "e1a28b1b4bade2dd7e18721dad9eab7060378045", "filename": "crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -237,8 +237,13 @@ pub enum Status {\n     Invalid,\n }\n \n+#[derive(Deserialize, Serialize)]\n+pub struct StatusParams {\n+    pub status: Status,\n+}\n+\n impl Notification for StatusNotification {\n-    type Params = Status;\n+    type Params = StatusParams;\n     const METHOD: &'static str = \"rust-analyzer/status\";\n }\n "}, {"sha": "505505a779619b9168d2f37b158567fa868b2eea", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -13,6 +13,7 @@ use crate::{\n     lsp_ext,\n     main_loop::Task,\n };\n+use lsp_ext::StatusParams;\n \n impl GlobalState {\n     pub(crate) fn update_configuration(&mut self, config: Config) {\n@@ -85,7 +86,9 @@ impl GlobalState {\n                 Status::Invalid => lsp_ext::Status::Invalid,\n                 Status::NeedsReload => lsp_ext::Status::NeedsReload,\n             };\n-            self.send_notification::<lsp_ext::StatusNotification>(lsp_status);\n+            self.send_notification::<lsp_ext::StatusNotification>(StatusParams {\n+                status: lsp_status,\n+            });\n         }\n     }\n     pub(crate) fn fetch_workspaces(&mut self) {"}, {"sha": "535de2f71ab4092d592c0d7bde2a6a4c46698381", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -704,10 +704,10 @@ pub(crate) fn unresolved_code_action(\n     index: usize,\n ) -> Result<lsp_ext::CodeAction> {\n     let res = lsp_ext::CodeAction {\n-        title: assist.label(),\n-        id: Some(format!(\"{}:{}\", assist.id().0.to_owned(), index.to_string())),\n-        group: assist.group().filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n-        kind: Some(code_action_kind(assist.id().1)),\n+        title: assist.label().to_string(),\n+        id: Some(format!(\"{}:{}\", assist.id.0, index.to_string())),\n+        group: assist.group.filter(|_| snap.config.client_caps.code_action_group).map(|gr| gr.0),\n+        kind: Some(code_action_kind(assist.id.1)),\n         edit: None,\n         is_preferred: None,\n     };"}, {"sha": "fa315ff8eefcf8bc5de75cd8b9f6ffc117770af2", "filename": "crates/rust-analyzer/tests/rust-analyzer/main.rs", "status": "renamed", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fmain.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -1,3 +1,13 @@\n+//! The most high-level integrated tests for rust-analyzer.\n+//!\n+//! This tests run a full LSP event loop, spawn cargo and process stdlib from\n+//! sysroot. For this reason, the tests here are very slow, and should be\n+//! avoided unless absolutely necessary.\n+//!\n+//! In particular, it's fine *not* to test that client & server agree on\n+//! specific JSON shapes here -- there's little value in such tests, as we can't\n+//! be sure without a real client anyway.\n+\n mod testdir;\n mod support;\n ", "previous_filename": "crates/rust-analyzer/tests/heavy_tests/main.rs"}, {"sha": "5bafeba79776f00955bfcfbb96cfffeacf95c852", "filename": "crates/rust-analyzer/tests/rust-analyzer/support.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Fsupport.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "previous_filename": "crates/rust-analyzer/tests/heavy_tests/support.rs"}, {"sha": "7487e7429473b598e14a5c3370832e8d488e68bc", "filename": "crates/rust-analyzer/tests/rust-analyzer/testdir.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Ftestdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Ftestdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Ftests%2Frust-analyzer%2Ftestdir.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "previous_filename": "crates/rust-analyzer/tests/heavy_tests/testdir.rs"}, {"sha": "7c2090de3cc59d9640e7376c46966489aa4ff5ea", "filename": "crates/ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2FCargo.toml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -12,6 +12,7 @@ doctest = false\n \n [dependencies]\n rustc-hash = \"1.1.0\"\n+itertools = \"0.9.0\"\n \n text_edit = { path = \"../text_edit\" }\n syntax = { path = \"../syntax\" }"}, {"sha": "ba669fd56c98631f7a88dce6c50cbd799d2eeb6e", "filename": "crates/ssr/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -21,7 +21,10 @@\n // code in the `foo` module, we'll insert just `Bar`.\n //\n // Inherent method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will\n-// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`. When a\n+// placeholder is the receiver of a method call in the search pattern (e.g. `$s.foo()`), but not in\n+// the replacement template (e.g. `bar($s)`), then *, & and &mut will be added as needed to mirror\n+// whatever autoderef and autoref was happening implicitly in the matched code.\n //\n // The scope of the search / replace will be restricted to the current selection if any, otherwise\n // it will apply to the whole workspace."}, {"sha": "8bb5ced9007ff3e70f1c2c9a614d9cce0daf95eb", "filename": "crates/ssr/src/matching.rs", "status": "modified", "additions": 66, "deletions": 29, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fmatching.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -2,7 +2,7 @@\n //! process of matching, placeholder values are recorded.\n \n use crate::{\n-    parsing::{Constraint, NodeKind, Placeholder},\n+    parsing::{Constraint, NodeKind, Placeholder, Var},\n     resolving::{ResolvedPattern, ResolvedRule, UfcsCallInfo},\n     SsrMatches,\n };\n@@ -56,10 +56,6 @@ pub struct Match {\n     pub(crate) rendered_template_paths: FxHashMap<SyntaxNode, hir::ModPath>,\n }\n \n-/// Represents a `$var` in an SSR query.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub(crate) struct Var(pub String);\n-\n /// Information about a placeholder bound in a match.\n #[derive(Debug)]\n pub(crate) struct PlaceholderMatch {\n@@ -69,6 +65,10 @@ pub(crate) struct PlaceholderMatch {\n     pub(crate) range: FileRange,\n     /// More matches, found within `node`.\n     pub(crate) inner_matches: SsrMatches,\n+    /// How many times the code that the placeholder matched needed to be dereferenced. Will only be\n+    /// non-zero if the placeholder matched to the receiver of a method call.\n+    pub(crate) autoderef_count: usize,\n+    pub(crate) autoref_kind: ast::SelfParamKind,\n }\n \n #[derive(Debug)]\n@@ -173,7 +173,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         // Handle placeholders.\n-        if let Some(placeholder) = self.get_placeholder(&SyntaxElement::Node(pattern.clone())) {\n+        if let Some(placeholder) = self.get_placeholder_for_node(pattern) {\n             for constraint in &placeholder.constraints {\n                 self.check_constraint(constraint, code)?;\n             }\n@@ -183,8 +183,8 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 // probably can't fail range validation, but just to be safe...\n                 self.validate_range(&original_range)?;\n                 matches_out.placeholder_values.insert(\n-                    Var(placeholder.ident.to_string()),\n-                    PlaceholderMatch::new(code, original_range),\n+                    placeholder.ident.clone(),\n+                    PlaceholderMatch::new(Some(code), original_range),\n                 );\n             }\n             return Ok(());\n@@ -487,7 +487,7 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n                 }\n                 if let Phase::Second(match_out) = phase {\n                     match_out.placeholder_values.insert(\n-                        Var(placeholder.ident.to_string()),\n+                        placeholder.ident.clone(),\n                         PlaceholderMatch::from_range(FileRange {\n                             file_id: self.sema.original_range(code).file_id,\n                             range: first_matched_token\n@@ -536,18 +536,40 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         if pattern_ufcs.function != code_resolved_function {\n             fail_match!(\"Method call resolved to a different function\");\n         }\n-        if code_resolved_function.has_self_param(self.sema.db) {\n-            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n-                self.check_expr_type(pattern_type, expr)?;\n-            }\n-        }\n         // Check arguments.\n         let mut pattern_args = pattern_ufcs\n             .call_expr\n             .arg_list()\n             .ok_or_else(|| match_error!(\"Pattern function call has no args\"))?\n             .args();\n-        self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        // If the function we're calling takes a self parameter, then we store additional\n+        // information on the placeholder match about autoderef and autoref. This allows us to use\n+        // the placeholder in a context where autoderef and autoref don't apply.\n+        if code_resolved_function.has_self_param(self.sema.db) {\n+            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n+                let deref_count = self.check_expr_type(pattern_type, expr)?;\n+                let pattern_receiver = pattern_args.next();\n+                self.attempt_match_opt(phase, pattern_receiver.clone(), code.expr())?;\n+                if let Phase::Second(match_out) = phase {\n+                    if let Some(placeholder_value) = pattern_receiver\n+                        .and_then(|n| self.get_placeholder_for_node(n.syntax()))\n+                        .and_then(|placeholder| {\n+                            match_out.placeholder_values.get_mut(&placeholder.ident)\n+                        })\n+                    {\n+                        placeholder_value.autoderef_count = deref_count;\n+                        placeholder_value.autoref_kind = self\n+                            .sema\n+                            .resolve_method_call_as_callable(code)\n+                            .and_then(|callable| callable.receiver_param(self.sema.db))\n+                            .map(|self_param| self_param.kind())\n+                            .unwrap_or(ast::SelfParamKind::Owned);\n+                    }\n+                }\n+            }\n+        } else {\n+            self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        }\n         let mut code_args =\n             code.arg_list().ok_or_else(|| match_error!(\"Code method call has no args\"))?.args();\n         loop {\n@@ -575,26 +597,35 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         self.attempt_match_node_children(phase, pattern_ufcs.call_expr.syntax(), code.syntax())\n     }\n \n+    /// Verifies that `expr` matches `pattern_type`, possibly after dereferencing some number of\n+    /// times. Returns the number of times it needed to be dereferenced.\n     fn check_expr_type(\n         &self,\n         pattern_type: &hir::Type,\n         expr: &ast::Expr,\n-    ) -> Result<(), MatchFailed> {\n+    ) -> Result<usize, MatchFailed> {\n         use hir::HirDisplay;\n         let code_type = self.sema.type_of_expr(&expr).ok_or_else(|| {\n             match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n         })?;\n-        if !code_type\n+        // Temporary needed to make the borrow checker happy.\n+        let res = code_type\n             .autoderef(self.sema.db)\n-            .any(|deref_code_type| *pattern_type == deref_code_type)\n-        {\n-            fail_match!(\n-                \"Pattern type `{}` didn't match code type `{}`\",\n-                pattern_type.display(self.sema.db),\n-                code_type.display(self.sema.db)\n-            );\n-        }\n-        Ok(())\n+            .enumerate()\n+            .find(|(_, deref_code_type)| pattern_type == deref_code_type)\n+            .map(|(count, _)| count)\n+            .ok_or_else(|| {\n+                match_error!(\n+                    \"Pattern type `{}` didn't match code type `{}`\",\n+                    pattern_type.display(self.sema.db),\n+                    code_type.display(self.sema.db)\n+                )\n+            });\n+        res\n+    }\n+\n+    fn get_placeholder_for_node(&self, node: &SyntaxNode) -> Option<&Placeholder> {\n+        self.get_placeholder(&SyntaxElement::Node(node.clone()))\n     }\n \n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n@@ -676,12 +707,18 @@ fn recording_match_fail_reasons() -> bool {\n }\n \n impl PlaceholderMatch {\n-    fn new(node: &SyntaxNode, range: FileRange) -> Self {\n-        Self { node: Some(node.clone()), range, inner_matches: SsrMatches::default() }\n+    fn new(node: Option<&SyntaxNode>, range: FileRange) -> Self {\n+        Self {\n+            node: node.cloned(),\n+            range,\n+            inner_matches: SsrMatches::default(),\n+            autoderef_count: 0,\n+            autoref_kind: ast::SelfParamKind::Owned,\n+        }\n     }\n \n     fn from_range(range: FileRange) -> Self {\n-        Self { node: None, range, inner_matches: SsrMatches::default() }\n+        Self::new(None, range)\n     }\n }\n "}, {"sha": "05b66dcd780e511181e809528e5b343473e45d5e", "filename": "crates/ssr/src/parsing.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fparsing.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -8,7 +8,7 @@\n use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use std::str::FromStr;\n+use std::{fmt::Display, str::FromStr};\n use syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, T};\n use test_utils::mark;\n \n@@ -34,12 +34,16 @@ pub(crate) enum PatternElement {\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Placeholder {\n     /// The name of this placeholder. e.g. for \"$a\", this would be \"a\"\n-    pub(crate) ident: SmolStr,\n+    pub(crate) ident: Var,\n     /// A unique name used in place of this placeholder when we parse the pattern as Rust code.\n     stand_in_name: String,\n     pub(crate) constraints: Vec<Constraint>,\n }\n \n+/// Represents a `$var` in an SSR query.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub(crate) struct Var(pub String);\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Constraint {\n     Kind(NodeKind),\n@@ -205,7 +209,7 @@ fn parse_pattern(pattern_str: &str) -> Result<Vec<PatternElement>, SsrError> {\n         if token.kind == T![$] {\n             let placeholder = parse_placeholder(&mut tokens)?;\n             if !placeholder_names.insert(placeholder.ident.clone()) {\n-                bail!(\"Name `{}` repeats more than once\", placeholder.ident);\n+                bail!(\"Placeholder `{}` repeats more than once\", placeholder.ident);\n             }\n             res.push(PatternElement::Placeholder(placeholder));\n         } else {\n@@ -228,7 +232,7 @@ fn validate_rule(rule: &SsrRule) -> Result<(), SsrError> {\n     for p in &rule.template.tokens {\n         if let PatternElement::Placeholder(placeholder) = p {\n             if !defined_placeholders.contains(&placeholder.ident) {\n-                undefined.push(format!(\"${}\", placeholder.ident));\n+                undefined.push(placeholder.ident.to_string());\n             }\n             if !placeholder.constraints.is_empty() {\n                 bail!(\"Replacement placeholders cannot have constraints\");\n@@ -344,7 +348,17 @@ impl NodeKind {\n \n impl Placeholder {\n     fn new(name: SmolStr, constraints: Vec<Constraint>) -> Self {\n-        Self { stand_in_name: format!(\"__placeholder_{}\", name), constraints, ident: name }\n+        Self {\n+            stand_in_name: format!(\"__placeholder_{}\", name),\n+            constraints,\n+            ident: Var(name.to_string()),\n+        }\n+    }\n+}\n+\n+impl Display for Var {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"${}\", self.0)\n     }\n }\n "}, {"sha": "29284e3f1c2dad5e5294de577735ffbb66ff973d", "filename": "crates/ssr/src/replacing.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Freplacing.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -1,10 +1,11 @@\n //! Code for applying replacement templates for matches that have previously been found.\n \n-use crate::matching::Var;\n use crate::{resolving::ResolvedRule, Match, SsrMatches};\n+use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast::{self, AstToken};\n use syntax::{SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize};\n+use test_utils::mark;\n use text_edit::TextEdit;\n \n /// Returns a text edit that will replace each match in `matches` with its corresponding replacement\n@@ -114,11 +115,33 @@ impl ReplacementRenderer<'_> {\n     fn render_token(&mut self, token: &SyntaxToken) {\n         if let Some(placeholder) = self.rule.get_placeholder(&token) {\n             if let Some(placeholder_value) =\n-                self.match_info.placeholder_values.get(&Var(placeholder.ident.to_string()))\n+                self.match_info.placeholder_values.get(&placeholder.ident)\n             {\n                 let range = &placeholder_value.range.range;\n                 let mut matched_text =\n                     self.file_src[usize::from(range.start())..usize::from(range.end())].to_owned();\n+                // If a method call is performed directly on the placeholder, then autoderef and\n+                // autoref will apply, so we can just substitute whatever the placeholder matched to\n+                // directly. If we're not applying a method call, then we need to add explicitly\n+                // deref and ref in order to match whatever was being done implicitly at the match\n+                // site.\n+                if !token_is_method_call_receiver(token)\n+                    && (placeholder_value.autoderef_count > 0\n+                        || placeholder_value.autoref_kind != ast::SelfParamKind::Owned)\n+                {\n+                    mark::hit!(replace_autoref_autoderef_capture);\n+                    let ref_kind = match placeholder_value.autoref_kind {\n+                        ast::SelfParamKind::Owned => \"\",\n+                        ast::SelfParamKind::Ref => \"&\",\n+                        ast::SelfParamKind::MutRef => \"&mut \",\n+                    };\n+                    matched_text = format!(\n+                        \"{}{}{}\",\n+                        ref_kind,\n+                        \"*\".repeat(placeholder_value.autoderef_count),\n+                        matched_text\n+                    );\n+                }\n                 let edit = matches_to_edit_at_offset(\n                     &placeholder_value.inner_matches,\n                     self.file_src,\n@@ -179,6 +202,29 @@ impl ReplacementRenderer<'_> {\n     }\n }\n \n+/// Returns whether token is the receiver of a method call. Note, being within the receiver of a\n+/// method call doesn't count. e.g. if the token is `$a`, then `$a.foo()` will return true, while\n+/// `($a + $b).foo()` or `x.foo($a)` will return false.\n+fn token_is_method_call_receiver(token: &SyntaxToken) -> bool {\n+    use syntax::ast::AstNode;\n+    // Find the first method call among the ancestors of `token`, then check if the only token\n+    // within the receiver is `token`.\n+    if let Some(receiver) =\n+        token.ancestors().find_map(ast::MethodCallExpr::cast).and_then(|call| call.expr())\n+    {\n+        let tokens = receiver.syntax().descendants_with_tokens().filter_map(|node_or_token| {\n+            match node_or_token {\n+                SyntaxElement::Token(t) => Some(t),\n+                _ => None,\n+            }\n+        });\n+        if let Some((only_token,)) = tokens.collect_tuple() {\n+            return only_token == *token;\n+        }\n+    }\n+    false\n+}\n+\n fn parse_as_kind(code: &str, kind: SyntaxKind) -> Option<SyntaxNode> {\n     use syntax::ast::AstNode;\n     if ast::Expr::can_cast(kind) {"}, {"sha": "e45c88864d7aabc0d106d1f240575b2cd15e0fc6", "filename": "crates/ssr/src/tests.rs", "status": "modified", "additions": 108, "deletions": 1, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Ftests.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -31,7 +31,7 @@ fn parser_two_delimiters() {\n fn parser_repeated_name() {\n     assert_eq!(\n         parse_error_text(\"foo($a, $a) ==>>\"),\n-        \"Parse error: Name `a` repeats more than once\"\n+        \"Parse error: Placeholder `$a` repeats more than once\"\n     );\n }\n \n@@ -1172,3 +1172,110 @@ fn match_trait_method_call() {\n     assert_matches(\"Bar::foo($a, $b)\", code, &[\"v1.foo(1)\", \"Bar::foo(&v1, 3)\", \"v1_ref.foo(5)\"]);\n     assert_matches(\"Bar2::foo($a, $b)\", code, &[\"v2.foo(2)\", \"Bar2::foo(&v2, 4)\", \"v2_ref.foo(6)\"]);\n }\n+\n+#[test]\n+fn replace_autoref_autoderef_capture() {\n+    // Here we have several calls to `$a.foo()`. In the first case autoref is applied, in the\n+    // second, we already have a reference, so it isn't. When $a is used in a context where autoref\n+    // doesn't apply, we need to prefix it with `&`. Finally, we have some cases where autoderef\n+    // needs to be applied.\n+    mark::check!(replace_autoref_autoderef_capture);\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&self) {}\n+            fn foo2(&self) {}\n+        }\n+        fn bar(_: &Foo) {}\n+        fn main() {\n+            let f = Foo {};\n+            let fr = &f;\n+            let fr2 = &fr;\n+            let fr3 = &fr2;\n+            f.foo();\n+            fr.foo();\n+            fr2.foo();\n+            fr3.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                bar(&f);\n+                bar(&*fr);\n+                bar(&**fr2);\n+                bar(&***fr3);\n+            }\n+        \"#]],\n+    );\n+    // If the placeholder is used as the receiver of another method call, then we don't need to\n+    // explicitly autoderef or autoref.\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> $a.foo2()\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&self) {}\n+                fn foo2(&self) {}\n+            }\n+            fn bar(_: &Foo) {}\n+            fn main() {\n+                let f = Foo {};\n+                let fr = &f;\n+                let fr2 = &fr;\n+                let fr3 = &fr2;\n+                f.foo2();\n+                fr.foo2();\n+                fr2.foo2();\n+                fr3.foo2();\n+            }\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_autoref_mut() {\n+    let code = r#\"\n+        struct Foo {}\n+        impl Foo {\n+            fn foo(&mut self) {}\n+        }\n+        fn bar(_: &mut Foo) {}\n+        fn main() {\n+            let mut f = Foo {};\n+            f.foo();\n+            let fr = &mut f;\n+            fr.foo();\n+        }\n+        \"#;\n+    assert_ssr_transform(\n+        \"Foo::foo($a) ==>> bar($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn foo(&mut self) {}\n+            }\n+            fn bar(_: &mut Foo) {}\n+            fn main() {\n+                let mut f = Foo {};\n+                bar(&mut f);\n+                let fr = &mut f;\n+                bar(&mut *fr);\n+            }\n+        \"#]],\n+    );\n+}"}, {"sha": "265d192883e4150031e52c789bc745a7c337c58a", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -17,7 +17,7 @@ pub fn timeit(label: &'static str) -> impl Drop {\n \n     impl Drop for Guard {\n         fn drop(&mut self) {\n-            eprintln!(\"{}: {:?}\", self.label, self.start.elapsed())\n+            eprintln!(\"{}: {:.2?}\", self.label, self.start.elapsed())\n         }\n     }\n "}, {"sha": "ec3132da8d771ad9f5375edfbec1ed5e20e7eed2", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -13,7 +13,7 @@ doctest = false\n [dependencies]\n itertools = \"0.9.0\"\n rowan = \"0.10.0\"\n-rustc_lexer = { version = \"671.0.0\", package = \"rustc-ap-rustc_lexer\" }\n+rustc_lexer = { version = \"673.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.5.1\"\n once_cell = \"1.3.1\""}, {"sha": "060b209663e61e6ce9380e4380a8dad47cccd74a", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -91,29 +91,52 @@ impl ast::AssocItemList {\n             res = make_multiline(res);\n         }\n         items.into_iter().for_each(|it| res = res.append_item(it));\n-        res\n+        res.fixup_trailing_whitespace().unwrap_or(res)\n     }\n \n     #[must_use]\n     pub fn append_item(&self, item: ast::AssocItem) -> ast::AssocItemList {\n-        let (indent, position) = match self.assoc_items().last() {\n+        let (indent, position, whitespace) = match self.assoc_items().last() {\n             Some(it) => (\n                 leading_indent(it.syntax()).unwrap_or_default().to_string(),\n                 InsertPosition::After(it.syntax().clone().into()),\n+                \"\\n\\n\",\n             ),\n             None => match self.l_curly_token() {\n                 Some(it) => (\n                     \"    \".to_string() + &leading_indent(self.syntax()).unwrap_or_default(),\n                     InsertPosition::After(it.into()),\n+                    \"\\n\",\n                 ),\n                 None => return self.clone(),\n             },\n         };\n-        let ws = tokens::WsBuilder::new(&format!(\"\\n{}\", indent));\n+        let ws = tokens::WsBuilder::new(&format!(\"{}{}\", whitespace, indent));\n         let to_insert: ArrayVec<[SyntaxElement; 2]> =\n             [ws.ws().into(), item.syntax().clone().into()].into();\n         self.insert_children(position, to_insert)\n     }\n+\n+    /// Remove extra whitespace between last item and closing curly brace.\n+    fn fixup_trailing_whitespace(&self) -> Option<ast::AssocItemList> {\n+        let first_token_after_items =\n+            self.assoc_items().last()?.syntax().next_sibling_or_token()?;\n+        let last_token_before_curly = self.r_curly_token()?.prev_sibling_or_token()?;\n+        if last_token_before_curly != first_token_after_items {\n+            // there is something more between last item and\n+            // right curly than just whitespace - bail out\n+            return None;\n+        }\n+        let whitespace =\n+            last_token_before_curly.clone().into_token().and_then(ast::Whitespace::cast)?;\n+        let text = whitespace.syntax().text();\n+        let newline = text.rfind(\"\\n\")?;\n+        let keep = tokens::WsBuilder::new(&text[newline..]);\n+        Some(self.replace_children(\n+            first_token_after_items..=last_token_before_curly,\n+            std::iter::once(keep.ws().into()),\n+        ))\n+    }\n }\n \n impl ast::RecordExprFieldList {"}, {"sha": "2e3133449fb44fbe3e60291d285db19ec15a5a44", "filename": "docs/dev/lsp-extensions.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/docs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/docs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Flsp-extensions.md?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -412,7 +412,13 @@ Reloads project information (that is, re-executes `cargo metadata`).\n \n **Method:** `rust-analyzer/status`\n \n-**Notification:** `\"loading\" | \"ready\" | \"invalid\" | \"needsReload\"`\n+**Notification:**\n+\n+```typescript\n+interface StatusParams {\n+    status: \"loading\" | \"ready\" | \"invalid\" | \"needsReload\",\n+}\n+```\n \n This notification is sent from server to client.\n The client can use it to display persistent status to the user (in modline)."}, {"sha": "8effddcda55d76f616b902b651242519a08156ae", "filename": "docs/dev/style.md", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -176,6 +176,35 @@ fn frobnicate(walrus: Option<Walrus>) {\n }\n ```\n \n+# Getters & Setters\n+\n+If a field can have any value without breaking invariants, make the field public.\n+Conversely, if there is an invariant, document it, enforce it in the \"constructor\" function, make the field private, and provide a getter.\n+Never provide setters.\n+\n+Getters should return borrowed data:\n+\n+```\n+struct Person {\n+    // Invariant: never empty\n+    first_name: String,\n+    middle_name: Option<String>\n+}\n+\n+// Good\n+impl Person {\n+    fn first_name(&self) -> &str { self.first_name.as_str() }\n+    fn middle_name(&self) -> Option<&str> { self.middle_name.as_ref() }\n+}\n+\n+// Not as good\n+impl Person {\n+    fn first_name(&self) -> String { self.first_name.clone() }\n+    fn middle_name(&self) -> &Option<String> { &self.middle_name }\n+}\n+```\n+\n+\n # Premature Pessimization\n \n Avoid writing code which is slower than it needs to be."}, {"sha": "3df5c860bd5950f31719963702f54fcad62372dc", "filename": "editors/code/.eslintignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2F.eslintignore", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2F.eslintignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2F.eslintignore?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -0,0 +1,3 @@\n+node_modules\n+.eslintrc.js\n+rollup.config.js\n\\ No newline at end of file"}, {"sha": "429ff5def414699c97934002761015717ab9160f", "filename": "editors/code/package.json", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -609,6 +609,15 @@\n                     },\n                     \"description\": \"List of warnings that should be displayed with hint severity.\\nThe warnings will be indicated by faded text or three dots in code and will not show up in the problems panel.\",\n                     \"default\": []\n+                },\n+                \"rust-analyzer.analysis.disabledDiagnostics\": {\n+                    \"type\": \"array\",\n+                    \"uniqueItems\": true,\n+                    \"items\": {\n+                        \"type\": \"string\"\n+                    },\n+                    \"description\": \"List of rust-analyzer diagnostics to disable\",\n+                    \"default\": []\n                 }\n             }\n         },"}, {"sha": "543f7e02e389b0840fb874b6c4a62899d35873e0", "filename": "editors/code/src/ctx.ts", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fsrc%2Fctx.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fsrc%2Fctx.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fctx.ts?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -36,7 +36,7 @@ export class Ctx {\n \n         res.pushCleanup(client.start());\n         await client.onReady();\n-        client.onNotification(ra.status, (status) => res.setStatus(status));\n+        client.onNotification(ra.status, (params) => res.setStatus(params.status));\n         return res;\n     }\n "}, {"sha": "8663737a6849ca38ad261c3f5777a7c534b937aa", "filename": "editors/code/src/lsp_ext.ts", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/editors%2Fcode%2Fsrc%2Flsp_ext.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Flsp_ext.ts?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -8,7 +8,10 @@ export const analyzerStatus = new lc.RequestType<null, string, void>(\"rust-analy\n export const memoryUsage = new lc.RequestType<null, string, void>(\"rust-analyzer/memoryUsage\");\n \n export type Status = \"loading\" | \"ready\" | \"invalid\" | \"needsReload\";\n-export const status = new lc.NotificationType<Status>(\"rust-analyzer/status\");\n+export interface StatusParams {\n+    status: Status;\n+}\n+export const status = new lc.NotificationType<StatusParams>(\"rust-analyzer/status\");\n \n export const reloadWorkspace = new lc.RequestType<null, null, void>(\"rust-analyzer/reloadWorkspace\");\n "}, {"sha": "c468468de1b06fd69c43d5a3dda405a955a4bbbd", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -16,7 +16,11 @@ use std::{\n     path::{Path, PathBuf},\n };\n \n-use crate::{not_bash::fs2, project_root, Result};\n+use crate::{\n+    ensure_rustfmt,\n+    not_bash::{fs2, pushenv, run},\n+    project_root, Result,\n+};\n \n pub use self::{\n     gen_assists_docs::{generate_assists_docs, generate_assists_tests},\n@@ -71,6 +75,18 @@ fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n     }\n }\n \n+const PREAMBLE: &str = \"Generated file, do not edit by hand, see `xtask/src/codegen`\";\n+\n+fn reformat(text: impl std::fmt::Display) -> Result<String> {\n+    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n+    ensure_rustfmt()?;\n+    let stdout = run!(\n+        \"rustfmt --config-path {} --config fn_single_line=true\", project_root().join(\"rustfmt.toml\").display();\n+        <text.to_string().as_bytes()\n+    )?;\n+    Ok(format!(\"//! {}\\n\\n{}\\n\", PREAMBLE, stdout))\n+}\n+\n fn extract_comment_blocks(text: &str) -> Vec<Vec<String>> {\n     do_extract_comment_blocks(text, false).into_iter().map(|(_line, block)| block).collect()\n }"}, {"sha": "4f49685944fba0235f51ccc068317056298bd32c", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -3,7 +3,7 @@\n use std::{fmt, fs, path::Path};\n \n use crate::{\n-    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n+    codegen::{self, extract_comment_blocks_with_empty_lines, reformat, Location, Mode, PREAMBLE},\n     project_root, rust_files, Result,\n };\n \n@@ -15,7 +15,7 @@ pub fn generate_assists_tests(mode: Mode) -> Result<()> {\n pub fn generate_assists_docs(mode: Mode) -> Result<()> {\n     let assists = Assist::collect()?;\n     let contents = assists.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n-    let contents = contents.trim().to_string() + \"\\n\";\n+    let contents = format!(\"//{}\\n{}\\n\", PREAMBLE, contents.trim());\n     let dst = project_root().join(\"docs/user/generated_assists.adoc\");\n     codegen::update(&dst, &contents, mode)\n }\n@@ -134,7 +134,7 @@ r#####\"\n \n         buf.push_str(&test)\n     }\n-    let buf = crate::reformat(buf)?;\n+    let buf = reformat(buf)?;\n     codegen::update(&project_root().join(codegen::ASSISTS_TESTS), &buf, mode)\n }\n "}, {"sha": "3f0013e82ab1556feaaf2d2e7c01df1649f46131", "filename": "xtask/src/codegen/gen_feature_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -3,14 +3,14 @@\n use std::{fmt, fs, path::PathBuf};\n \n use crate::{\n-    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode},\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Location, Mode, PREAMBLE},\n     project_root, rust_files, Result,\n };\n \n pub fn generate_feature_docs(mode: Mode) -> Result<()> {\n     let features = Feature::collect()?;\n     let contents = features.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n-    let contents = contents.trim().to_string() + \"\\n\";\n+    let contents = format!(\"//{}\\n{}\\n\", PREAMBLE, contents.trim());\n     let dst = project_root().join(\"docs/user/generated_features.adoc\");\n     codegen::update(&dst, &contents, mode)?;\n     Ok(())"}, {"sha": "df3ec22c8d4c9170c765dc533a8b5cccda329372", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -14,7 +14,7 @@ use ungrammar::{rust_grammar, Grammar, Rule};\n \n use crate::{\n     ast_src::{AstEnumSrc, AstNodeSrc, AstSrc, Cardinality, Field, KindsSrc, KINDS_SRC},\n-    codegen::{self, update, Mode},\n+    codegen::{self, reformat, update, Mode},\n     project_root, Result,\n };\n \n@@ -61,7 +61,7 @@ fn generate_tokens(grammar: &AstSrc) -> Result<String> {\n         }\n     });\n \n-    let pretty = crate::reformat(quote! {\n+    let pretty = reformat(quote! {\n         use crate::{SyntaxKind::{self, *}, SyntaxToken, ast::AstToken};\n         #(#tokens)*\n     })?\n@@ -261,7 +261,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> Result<String> {\n         }\n     }\n \n-    let pretty = crate::reformat(res)?;\n+    let pretty = reformat(res)?;\n     Ok(pretty)\n }\n \n@@ -383,7 +383,7 @@ fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n         }\n     };\n \n-    crate::reformat(ast)\n+    reformat(ast)\n }\n \n fn to_upper_snake_case(s: &str) -> String {"}, {"sha": "e790d995fb37b38be146efa6dcbbabfe6d371928", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 5, "deletions": 51, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -3,14 +3,15 @@\n //! See https://github.com/matklad/cargo-xtask/\n \n pub mod not_bash;\n+pub mod codegen;\n+mod ast_src;\n+\n pub mod install;\n pub mod release;\n pub mod dist;\n pub mod pre_commit;\n pub mod metrics;\n-\n-pub mod codegen;\n-mod ast_src;\n+pub mod pre_cache;\n \n use std::{\n     env,\n@@ -21,7 +22,7 @@ use walkdir::{DirEntry, WalkDir};\n \n use crate::{\n     codegen::Mode,\n-    not_bash::{fs2, pushd, pushenv, rm_rf},\n+    not_bash::{pushd, pushenv},\n };\n \n pub use anyhow::{bail, Context as _, Result};\n@@ -62,17 +63,6 @@ pub fn run_rustfmt(mode: Mode) -> Result<()> {\n     Ok(())\n }\n \n-fn reformat(text: impl std::fmt::Display) -> Result<String> {\n-    let _e = pushenv(\"RUSTUP_TOOLCHAIN\", \"stable\");\n-    ensure_rustfmt()?;\n-    let stdout = run!(\n-        \"rustfmt --config-path {} --config fn_single_line=true\", project_root().join(\"rustfmt.toml\").display();\n-        <text.to_string().as_bytes()\n-    )?;\n-    let preamble = \"Generated file, do not edit by hand, see `xtask/src/codegen`\";\n-    Ok(format!(\"//! {}\\n\\n{}\\n\", preamble, stdout))\n-}\n-\n fn ensure_rustfmt() -> Result<()> {\n     let out = run!(\"rustfmt --version\")?;\n     if !out.contains(\"stable\") {\n@@ -119,42 +109,6 @@ pub fn run_fuzzer() -> Result<()> {\n     Ok(())\n }\n \n-/// Cleans the `./target` dir after the build such that only\n-/// dependencies are cached on CI.\n-pub fn run_pre_cache() -> Result<()> {\n-    let slow_tests_cookie = Path::new(\"./target/.slow_tests_cookie\");\n-    if !slow_tests_cookie.exists() {\n-        panic!(\"slow tests were skipped on CI!\")\n-    }\n-    rm_rf(slow_tests_cookie)?;\n-\n-    for entry in Path::new(\"./target/debug\").read_dir()? {\n-        let entry = entry?;\n-        if entry.file_type().map(|it| it.is_file()).ok() == Some(true) {\n-            // Can't delete yourself on windows :-(\n-            if !entry.path().ends_with(\"xtask.exe\") {\n-                rm_rf(&entry.path())?\n-            }\n-        }\n-    }\n-\n-    fs2::remove_file(\"./target/.rustc_info.json\")?;\n-    let to_delete = [\"hir\", \"heavy_test\", \"xtask\", \"ide\", \"rust-analyzer\"];\n-    for &dir in [\"./target/debug/deps\", \"target/debug/.fingerprint\"].iter() {\n-        for entry in Path::new(dir).read_dir()? {\n-            let entry = entry?;\n-            if to_delete.iter().any(|&it| entry.path().display().to_string().contains(it)) {\n-                // Can't delete yourself on windows :-(\n-                if !entry.path().ends_with(\"xtask.exe\") {\n-                    rm_rf(&entry.path())?\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n fn is_release_tag(tag: &str) -> bool {\n     tag.len() == \"2020-02-24\".len() && tag.starts_with(|c: char| c.is_ascii_digit())\n }"}, {"sha": "c4a15f4bdfe140d825e215cca780db465eaf02fc", "filename": "xtask/src/main.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -17,9 +17,10 @@ use xtask::{\n     install::{ClientOpt, InstallCmd, Malloc, ServerOpt},\n     metrics::MetricsCmd,\n     not_bash::pushd,\n+    pre_cache::PreCacheCmd,\n     pre_commit, project_root,\n     release::{PromoteCmd, ReleaseCmd},\n-    run_clippy, run_fuzzer, run_pre_cache, run_rustfmt, Result,\n+    run_clippy, run_fuzzer, run_rustfmt, Result,\n };\n \n fn main() -> Result<()> {\n@@ -101,7 +102,7 @@ FLAGS:\n         }\n         \"pre-cache\" => {\n             args.finish()?;\n-            run_pre_cache()\n+            PreCacheCmd.run()\n         }\n         \"release\" => {\n             let dry_run = args.contains(\"--dry-run\");"}, {"sha": "47ba6ba246c5f599862605a06b8854ba2ca70779", "filename": "xtask/src/pre_cache.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fpre_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Fsrc%2Fpre_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fpre_cache.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -0,0 +1,80 @@\n+use std::{\n+    fs::FileType,\n+    path::{Path, PathBuf},\n+};\n+\n+use anyhow::Result;\n+\n+use crate::not_bash::{fs2, rm_rf};\n+\n+pub struct PreCacheCmd;\n+\n+impl PreCacheCmd {\n+    /// Cleans the `./target` dir after the build such that only\n+    /// dependencies are cached on CI.\n+    pub fn run(self) -> Result<()> {\n+        let slow_tests_cookie = Path::new(\"./target/.slow_tests_cookie\");\n+        if !slow_tests_cookie.exists() {\n+            panic!(\"slow tests were skipped on CI!\")\n+        }\n+        rm_rf(slow_tests_cookie)?;\n+\n+        for path in read_dir(\"./target/debug\", FileType::is_file)? {\n+            // Can't delete yourself on windows :-(\n+            if !path.ends_with(\"xtask.exe\") {\n+                rm_rf(&path)?\n+            }\n+        }\n+\n+        fs2::remove_file(\"./target/.rustc_info.json\")?;\n+\n+        let to_delete = read_dir(\"./crates\", FileType::is_dir)?\n+            .into_iter()\n+            .map(|path| path.file_name().unwrap().to_string_lossy().replace('-', \"_\"))\n+            .collect::<Vec<_>>();\n+\n+        for &dir in [\"./target/debug/deps\", \"target/debug/.fingerprint\"].iter() {\n+            for path in read_dir(dir, |_file_type| true)? {\n+                if path.ends_with(\"xtask.exe\") {\n+                    continue;\n+                }\n+                let file_name = path.file_name().unwrap().to_string_lossy();\n+                let (stem, _) = match rsplit_once(&file_name, '-') {\n+                    Some(it) => it,\n+                    None => {\n+                        rm_rf(path)?;\n+                        continue;\n+                    }\n+                };\n+                let stem = stem.replace('-', \"_\");\n+                if to_delete.contains(&stem) {\n+                    rm_rf(path)?;\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+fn read_dir(path: impl AsRef<Path>, cond: impl Fn(&FileType) -> bool) -> Result<Vec<PathBuf>> {\n+    read_dir_impl(path.as_ref(), &cond)\n+}\n+\n+fn read_dir_impl(path: &Path, cond: &dyn Fn(&FileType) -> bool) -> Result<Vec<PathBuf>> {\n+    let mut res = Vec::new();\n+    for entry in path.read_dir()? {\n+        let entry = entry?;\n+        let file_type = entry.file_type()?;\n+        if cond(&file_type) {\n+            res.push(entry.path())\n+        }\n+    }\n+    Ok(res)\n+}\n+\n+fn rsplit_once(haystack: &str, delim: char) -> Option<(&str, &str)> {\n+    let mut split = haystack.rsplitn(2, delim);\n+    let suffix = split.next()?;\n+    let prefix = split.next()?;\n+    Some((prefix, suffix))\n+}"}, {"sha": "bec3c630b765b425d14fe85d903c7af42937defd", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18748ed152989953e39492a6b44f8001267ce5f/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=e18748ed152989953e39492a6b44f8001267ce5f", "patch": "@@ -82,7 +82,7 @@ MIT/Apache-2.0\n MIT/Apache-2.0 AND BSD-2-Clause\n Unlicense OR MIT\n Unlicense/MIT\n-Zlib\n+Zlib OR Apache-2.0 OR MIT\n \"\n     .lines()\n     .filter(|it| !it.is_empty())"}]}