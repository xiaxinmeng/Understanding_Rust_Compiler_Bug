{"sha": "70b9ad1748748d93ccef95b59435a7357b350d11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYjlhZDE3NDg3NDhkOTNjY2VmOTViNTk0MzVhNzM1N2IzNTBkMTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-30T18:09:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-30T18:09:14Z"}, "message": "rustc: work around issue with default-method-simple, fix some rebase\nerrors", "tree": {"sha": "28e07d02ce1594f54da8b3d2cc6f39011201d2a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28e07d02ce1594f54da8b3d2cc6f39011201d2a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70b9ad1748748d93ccef95b59435a7357b350d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70b9ad1748748d93ccef95b59435a7357b350d11", "html_url": "https://github.com/rust-lang/rust/commit/70b9ad1748748d93ccef95b59435a7357b350d11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70b9ad1748748d93ccef95b59435a7357b350d11/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "545d51c1608198aed4e3bdca0dac23bcc6af19b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/545d51c1608198aed4e3bdca0dac23bcc6af19b9", "html_url": "https://github.com/rust-lang/rust/commit/545d51c1608198aed4e3bdca0dac23bcc6af19b9"}], "stats": {"total": 36, "additions": 29, "deletions": 7}, "files": [{"sha": "b17dac82048bf66b06cbcd1be105b3b3621e14ad", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=70b9ad1748748d93ccef95b59435a7357b350d11", "patch": "@@ -1553,6 +1553,13 @@ pub fn type_is_ty_var(ty: t) -> bool {\n \n pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n+pub fn type_is_self(ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_self(*) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_closure(_) | ty_trait(*) |"}, {"sha": "de6530fb464c503a7660dd779303752edfec9199", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=70b9ad1748748d93ccef95b59435a7357b350d11", "patch": "@@ -658,6 +658,12 @@ pub impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         return match ty::get(self_ty).sty {\n+            ty::ty_rptr(_, self_mt) if default_method_hack(self_mt) => {\n+                (self_ty,\n+                 ty::AutoDerefRef(ty::AutoDerefRef {\n+                     autoderefs: autoderefs,\n+                     autoref: None}))\n+            }\n             ty::ty_rptr(_, self_mt) => {\n                 let region = self.infcx().next_region_var_nb(self.expr.span);\n                 (ty::mk_rptr(tcx, region, self_mt),\n@@ -679,6 +685,16 @@ pub impl<'self> LookupContext<'self> {\n                      autoref: None}))\n             }\n         };\n+\n+        fn default_method_hack(self_mt: ty::mt) -> bool {\n+            // FIXME(#6129). Default methods can't deal with autoref.\n+            //\n+            // I am a horrible monster and I pray for death. Currently\n+            // the default method code fails when you try to reborrow\n+            // because it is not handling types correctly. In lieu of\n+            // fixing that, I am introducing this horrible hack. - ndm\n+            self_mt.mutbl == m_imm && ty::type_is_self(self_mt.ty)\n+        }\n     }\n \n     fn search_for_autosliced_method("}, {"sha": "fb58df3d55c683f4383a3afe10c93c7d0fb1de97", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=70b9ad1748748d93ccef95b59435a7357b350d11", "patch": "@@ -2966,7 +2966,8 @@ pub fn check_block(fcx0: @mut FnCtxt, blk: &ast::blk)  {\n pub fn check_block_with_expected(fcx: @mut FnCtxt,\n                                  blk: &ast::blk,\n                                  expected: Option<ty::t>) {\n-    let prev = replace(&mut fcx.ps, fcx.ps.recurse(blk));\n+    let purity_state = fcx.ps.recurse(blk);\n+    let prev = replace(&mut fcx.ps, purity_state);\n \n     do fcx.with_region_lb(blk.node.id) {\n         let mut warned = false;"}, {"sha": "be513cbb0f3071a2b34d1102f379d7dff895412c", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b9ad1748748d93ccef95b59435a7357b350d11/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=70b9ad1748748d93ccef95b59435a7357b350d11", "patch": "@@ -457,20 +457,18 @@ fn constrain_call(rcx: @mut Rcx,\n     let callee_scope = call_expr.id;\n     let callee_region = ty::re_scope(callee_scope);\n \n-    for fn_sig.inputs.eachi |i, input| {\n+    for arg_exprs.each |&arg_expr| {\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n-            rcx, arg_exprs[i].id, callee_region, arg_exprs[i].span);\n+            rcx, arg_expr.id, callee_region, arg_expr.span);\n \n         // unfortunately, there are two means of taking implicit\n         // references, and we need to propagate constraints as a\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n-        ty::set_default_mode(tcx, input.mode, ast::by_copy);\n-        let is_by_ref = ty::resolved_mode(tcx, input.mode) == ast::by_ref;\n-        if implicitly_ref_args || is_by_ref {\n-            guarantor::for_by_ref(rcx, arg_exprs[i], callee_scope);\n+        if implicitly_ref_args {\n+            guarantor::for_by_ref(rcx, arg_expr, callee_scope);\n         }\n     }\n "}]}