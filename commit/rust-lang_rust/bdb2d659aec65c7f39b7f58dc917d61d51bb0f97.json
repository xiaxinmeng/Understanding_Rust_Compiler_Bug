{"sha": "bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYjJkNjU5YWVjNjVjN2YzOWI3ZjU4ZGM5MTdkNjFkNTFiYjBmOTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-15T01:50:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-12-15T02:19:07Z"}, "message": "librustc: Ensure that no moves from the inside of @ or & boxes occur. rs=crashing-servo", "tree": {"sha": "eacb19b3a303991a5f1324890b8e061a3bc2fe19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eacb19b3a303991a5f1324890b8e061a3bc2fe19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "html_url": "https://github.com/rust-lang/rust/commit/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e67190a0d2ce04ab1647205a8ff7a5ddf5d6e8d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e67190a0d2ce04ab1647205a8ff7a5ddf5d6e8d6", "html_url": "https://github.com/rust-lang/rust/commit/e67190a0d2ce04ab1647205a8ff7a5ddf5d6e8d6"}], "stats": {"total": 147, "additions": 121, "deletions": 26}, "files": [{"sha": "197a88d9ddee269a544fc6dcfaca743356220beb", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "patch": "@@ -40,15 +40,29 @@ fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n     tcx.sess.abort_if_errors();\n }\n \n+fn expr_is_non_moving_lvalue(cx: @AltCheckCtxt, expr: @expr) -> bool {\n+    if !ty::expr_is_lval(cx.tcx, cx.method_map, expr) {\n+        return false;\n+    }\n+\n+    match cx.tcx.value_modes.find(expr.id) {\n+        Some(MoveValue) => return false,\n+        Some(CopyValue) | Some(ReadValue) => return true,\n+        None => {\n+            cx.tcx.sess.span_bug(expr.span, ~\"no entry in value mode map\");\n+        }\n+    }\n+}\n+\n fn check_expr(cx: @AltCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     match ex.node {\n       expr_match(scrut, ref arms) => {\n         // First, check legality of move bindings.\n-        let is_lvalue = ty::expr_is_lval(cx.tcx, cx.method_map, scrut);\n+        let is_non_moving_lvalue = expr_is_non_moving_lvalue(cx, ex);\n         for arms.each |arm| {\n             check_legality_of_move_bindings(cx,\n-                                            is_lvalue,\n+                                            is_non_moving_lvalue,\n                                             arm.guard.is_some(),\n                                             arm.pats);\n         }\n@@ -524,7 +538,7 @@ fn check_local(cx: @AltCheckCtxt, loc: @local, &&s: (), v: visit::vt<()>) {\n \n     // Check legality of move bindings.\n     let is_lvalue = match loc.node.init {\n-        Some(init) => ty::expr_is_lval(cx.tcx, cx.method_map, init),\n+        Some(init) => expr_is_non_moving_lvalue(cx, init),\n         None => true\n     };\n     check_legality_of_move_bindings(cx, is_lvalue, false, [ loc.node.pat ]);\n@@ -616,40 +630,98 @@ fn check_legality_of_move_bindings(cx: @AltCheckCtxt,\n         }\n     }\n \n+    let check_move: &fn(@pat, Option<@pat>) = |p, sub| {\n+        // check legality of moving out of the enum\n+        if sub.is_some() {\n+            tcx.sess.span_err(\n+                p.span,\n+                ~\"cannot bind by-move with sub-bindings\");\n+        } else if has_guard {\n+            tcx.sess.span_err(\n+                p.span,\n+                ~\"cannot bind by-move into a pattern guard\");\n+        } else if by_ref_span.is_some() {\n+            tcx.sess.span_err(\n+                p.span,\n+                ~\"cannot bind by-move and by-ref \\\n+                  in the same pattern\");\n+            tcx.sess.span_note(\n+                by_ref_span.get(),\n+                ~\"by-ref binding occurs here\");\n+        } else if is_lvalue {\n+            tcx.sess.span_err(\n+                p.span,\n+                ~\"cannot bind by-move when \\\n+                  matching an lvalue\");\n+        }\n+    };\n+\n     if !any_by_move { return; } // pointless micro-optimization\n     for pats.each |pat| {\n         do walk_pat(*pat) |p| {\n             if pat_is_binding(def_map, p) {\n                 match p.node {\n-                    pat_ident(bind_by_move, _, sub) => {\n-                        // check legality of moving out of the enum\n-                        if sub.is_some() {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move with sub-bindings\");\n-                        } else if has_guard {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move into a pattern guard\");\n-                        } else if by_ref_span.is_some() {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move and by-ref \\\n-                                  in the same pattern\");\n-                            tcx.sess.span_note(\n-                                by_ref_span.get(),\n-                                ~\"by-ref binding occurs here\");\n-                        } else if is_lvalue {\n-                            tcx.sess.span_err(\n-                                p.span,\n-                                ~\"cannot bind by-move when \\\n-                                  matching an lvalue\");\n+                    pat_ident(bind_by_move, _, sub) => check_move(p, sub),\n+                    pat_ident(bind_infer, _, sub) => {\n+                        match tcx.value_modes.find(p.id) {\n+                            Some(MoveValue) => check_move(p, sub),\n+                            Some(CopyValue) | Some(ReadValue) => {}\n+                            None => {\n+                                cx.tcx.sess.span_bug(\n+                                    pat.span, ~\"no mode for pat binding\");\n+                            }\n                         }\n                     }\n                     _ => {}\n                 }\n             }\n         }\n+\n+        // Now check to ensure that any move binding is not behind an @ or &.\n+        // This is always illegal.\n+        let vt = visit::mk_vt(@{\n+            visit_pat: |pat, behind_bad_pointer, v| {\n+                let error_out = || {\n+                    cx.tcx.sess.span_err(pat.span, ~\"by-move pattern \\\n+                                                     bindings may not occur \\\n+                                                     behind @ or & bindings\");\n+                };\n+                match pat.node {\n+                    pat_ident(binding_mode, _, sub) => {\n+                        debug!(\"(check legality of move) checking pat \\\n+                                ident with behind_bad_pointer %?\",\n+                                behind_bad_pointer);\n+                        match binding_mode {\n+                            bind_by_move if behind_bad_pointer => error_out(),\n+                            bind_infer if behind_bad_pointer => {\n+                                match cx.tcx.value_modes.find(pat.id) {\n+                                    Some(MoveValue) => error_out(),\n+                                    Some(CopyValue) |\n+                                    Some(ReadValue) => {}\n+                                    None => {\n+                                        cx.tcx.sess.span_bug(pat.span,\n+                                            ~\"no mode for pat binding\");\n+                                    }\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                        match sub {\n+                            None => {}\n+                            Some(subpat) => {\n+                                (v.visit_pat)(subpat, behind_bad_pointer, v);\n+                            }\n+                        }\n+                    }\n+                    pat_box(subpat) | pat_region(subpat) => {\n+                        (v.visit_pat)(subpat, true, v);\n+                    }\n+                    _ => visit::visit_pat(pat, behind_bad_pointer, v)\n+                }\n+            },\n+            .. *visit::default_visitor::<bool>()\n+        });\n+        (vt.visit_pat)(*pat, false, vt);\n     }\n }\n "}, {"sha": "95091f15ce0e57afbf465ec69656b736f34b9b89", "filename": "src/test/compile-fail/by-move-pattern-binding.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb2d659aec65c7f39b7f58dc917d61d51bb0f97/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fby-move-pattern-binding.rs?ref=bdb2d659aec65c7f39b7f58dc917d61d51bb0f97", "patch": "@@ -0,0 +1,23 @@\n+enum E {\n+    Foo,\n+    Bar(~str)\n+}\n+\n+struct S {\n+    x: E\n+}\n+\n+fn f(x: ~str) {}\n+\n+fn main() {\n+    let s = S { x: Bar(~\"hello\") };\n+    match &s.x {\n+        &Foo => {}\n+        &Bar(identifier) => f(copy identifier)  //~ ERROR by-move pattern bindings may not occur\n+    };\n+    match &s.x {\n+        &Foo => {}\n+        &Bar(ref identifier) => io::println(*identifier)\n+    };\n+}\n+    "}]}