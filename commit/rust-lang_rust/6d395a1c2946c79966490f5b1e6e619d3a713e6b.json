{"sha": "6d395a1c2946c79966490f5b1e6e619d3a713e6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMzk1YTFjMjk0NmM3OTk2NjQ5MGY1YjFlNmU2MTlkM2E3MTNlNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-13T19:36:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-13T19:36:46Z"}, "message": "Auto merge of #85186 - nikomatsakis:issue-83538-polluted-cache, r=jackh726\n\nhave on_completion record subcycles\n\nhave on_completion record subcycles\n\nRework `on_completion` method so that it removes all\nprovisional cache entries that are \"below\" a completed\nnode (while leaving those entries that are not below\nthe node).\n\nThis corrects an imprecise result that could in turn lead\nto an incremental compilation failure. Under the old\nscheme, if you had:\n\n* A depends on...\n   * B depends on A\n   * C depends on...\n       * D depends on C\n * T: 'static\n\nthen the provisional results for A, B, C, and D would all\nbe entangled. Thus, if A was `EvaluatedToOkModuloRegions`\n(because of that final condition), then the result for C and\nD would also be demoted to \"ok modulo regions\".\n\nIn reality, though, the result for C depends only on C and itself,\nand is not dependent on regions. If we happen to evaluate the\ncycle starting from C, we would never reach A, and hence the\nresult would be \"ok\".\n\nUnder the new scheme, the provisional results for C and D\nare moved to the permanent cache immediately and are not affected\nby the result of A.\n\nFixes #83538\n\nr? `@Aaron1011`", "tree": {"sha": "727094550edc56dd8fffed74f435517a81ab4f06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/727094550edc56dd8fffed74f435517a81ab4f06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d395a1c2946c79966490f5b1e6e619d3a713e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d395a1c2946c79966490f5b1e6e619d3a713e6b", "html_url": "https://github.com/rust-lang/rust/commit/6d395a1c2946c79966490f5b1e6e619d3a713e6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d395a1c2946c79966490f5b1e6e619d3a713e6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2", "html_url": "https://github.com/rust-lang/rust/commit/952c5732c2d25a875f90e5cd5dd29a1a21c1d4a2"}, {"sha": "89c58eac6826bf6067d4a1cb9d74b9b9282d4688", "url": "https://api.github.com/repos/rust-lang/rust/commits/89c58eac6826bf6067d4a1cb9d74b9b9282d4688", "html_url": "https://github.com/rust-lang/rust/commit/89c58eac6826bf6067d4a1cb9d74b9b9282d4688"}], "stats": {"total": 311, "additions": 260, "deletions": 51}, "files": [{"sha": "51d69167f7b3ea7e6ba69d8fac2431b20b5e779a", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -564,6 +564,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word, List: \"delay_span_bug_from_inside_query\")\n     ),\n     rustc_attr!(TEST, rustc_dump_user_substs, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_evaluate_where_clauses, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_if_this_changed, AssumedUsed, template!(Word, List: \"DepNode\")),\n     rustc_attr!(TEST, rustc_then_this_would_need, AssumedUsed, template!(List: \"DepNode\")),\n     rustc_attr!("}, {"sha": "0b3dece09aecc8d528a1d443362c2e19c5178c73", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -1011,6 +1011,7 @@ symbols! {\n         rustc_dump_program_clauses,\n         rustc_dump_user_substs,\n         rustc_error,\n+        rustc_evaluate_where_clauses,\n         rustc_expected_cgu_reuse,\n         rustc_if_this_changed,\n         rustc_inherit_overflow_checks,"}, {"sha": "bf3c8643f0d6b0c7fb788ba010b1ac12a4c22240", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -14,6 +14,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(hash_drain_filter)]\n #![feature(in_band_lifetimes)]\n #![feature(iter_zip)]\n #![feature(never_type)]"}, {"sha": "a292de148a67aaa231e0fb44b5f7713d5dc15915", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -636,8 +636,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         if let Some(result) = stack.cache().get_provisional(fresh_trait_ref) {\n             debug!(?result, \"PROVISIONAL CACHE HIT\");\n-            stack.update_reached_depth(stack.cache().current_reached_depth());\n-            return Ok(result);\n+            stack.update_reached_depth(result.reached_depth);\n+            return Ok(result.result);\n         }\n \n         // Check if this is a match for something already on the\n@@ -661,7 +661,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(?result, \"CACHE MISS\");\n             self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n \n-            stack.cache().on_completion(stack.depth, |fresh_trait_ref, provisional_result| {\n+            stack.cache().on_completion(stack.dfn, |fresh_trait_ref, provisional_result| {\n                 self.insert_evaluation_cache(\n                     obligation.param_env,\n                     fresh_trait_ref,\n@@ -2162,7 +2162,7 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     /// required accessing something from the stack at depth `reached_depth`.\n     fn update_reached_depth(&self, reached_depth: usize) {\n         assert!(\n-            self.depth > reached_depth,\n+            self.depth >= reached_depth,\n             \"invoked `update_reached_depth` with something under this stack: \\\n              self.depth={} reached_depth={}\",\n             self.depth,\n@@ -2235,23 +2235,6 @@ struct ProvisionalEvaluationCache<'tcx> {\n     /// next \"depth first number\" to issue -- just a counter\n     dfn: Cell<usize>,\n \n-    /// Stores the \"coldest\" depth (bottom of stack) reached by any of\n-    /// the evaluation entries. The idea here is that all things in the provisional\n-    /// cache are always dependent on *something* that is colder in the stack:\n-    /// therefore, if we add a new entry that is dependent on something *colder still*,\n-    /// we have to modify the depth for all entries at once.\n-    ///\n-    /// Example:\n-    ///\n-    /// Imagine we have a stack `A B C D E` (with `E` being the top of\n-    /// the stack).  We cache something with depth 2, which means that\n-    /// it was dependent on C.  Then we pop E but go on and process a\n-    /// new node F: A B C D F.  Now F adds something to the cache with\n-    /// depth 1, meaning it is dependent on B.  Our original cache\n-    /// entry is also dependent on B, because there is a path from E\n-    /// to C and then from C to F and from F to B.\n-    reached_depth: Cell<usize>,\n-\n     /// Map from cache key to the provisionally evaluated thing.\n     /// The cache entries contain the result but also the DFN in which they\n     /// were added. The DFN is used to clear out values on failure.\n@@ -2275,12 +2258,13 @@ struct ProvisionalEvaluationCache<'tcx> {\n #[derive(Copy, Clone, Debug)]\n struct ProvisionalEvaluation {\n     from_dfn: usize,\n+    reached_depth: usize,\n     result: EvaluationResult,\n }\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n     fn default() -> Self {\n-        Self { dfn: Cell::new(0), reached_depth: Cell::new(usize::MAX), map: Default::default() }\n+        Self { dfn: Cell::new(0), map: Default::default() }\n     }\n }\n \n@@ -2295,22 +2279,17 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// Check the provisional cache for any result for\n     /// `fresh_trait_ref`. If there is a hit, then you must consider\n     /// it an access to the stack slots at depth\n-    /// `self.current_reached_depth()` and above.\n-    fn get_provisional(&self, fresh_trait_ref: ty::PolyTraitRef<'tcx>) -> Option<EvaluationResult> {\n+    /// `reached_depth` (from the returned value).\n+    fn get_provisional(\n+        &self,\n+        fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Option<ProvisionalEvaluation> {\n         debug!(\n             ?fresh_trait_ref,\n-            reached_depth = ?self.reached_depth.get(),\n             \"get_provisional = {:#?}\",\n             self.map.borrow().get(&fresh_trait_ref),\n         );\n-        Some(self.map.borrow().get(&fresh_trait_ref)?.result)\n-    }\n-\n-    /// Current value of the `reached_depth` counter -- all the\n-    /// provisional cache entries are dependent on the item at this\n-    /// depth.\n-    fn current_reached_depth(&self) -> usize {\n-        self.reached_depth.get()\n+        Some(self.map.borrow().get(&fresh_trait_ref)?.clone())\n     }\n \n     /// Insert a provisional result into the cache. The result came\n@@ -2324,13 +2303,31 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n         result: EvaluationResult,\n     ) {\n-        debug!(?from_dfn, ?reached_depth, ?fresh_trait_ref, ?result, \"insert_provisional\");\n-        let r_d = self.reached_depth.get();\n-        self.reached_depth.set(r_d.min(reached_depth));\n+        debug!(?from_dfn, ?fresh_trait_ref, ?result, \"insert_provisional\");\n \n-        debug!(reached_depth = self.reached_depth.get());\n+        let mut map = self.map.borrow_mut();\n+\n+        // Subtle: when we complete working on the DFN `from_dfn`, anything\n+        // that remains in the provisional cache must be dependent on some older\n+        // stack entry than `from_dfn`. We have to update their depth with our transitive\n+        // depth in that case or else it would be referring to some popped note.\n+        //\n+        // Example:\n+        // A (reached depth 0)\n+        //   ...\n+        //      B // depth 1 -- reached depth = 0\n+        //          C // depth 2 -- reached depth = 1 (should be 0)\n+        //              B\n+        //          A // depth 0\n+        //   D (reached depth 1)\n+        //      C (cache -- reached depth = 2)\n+        for (_k, v) in &mut *map {\n+            if v.from_dfn >= from_dfn {\n+                v.reached_depth = reached_depth.min(v.reached_depth);\n+            }\n+        }\n \n-        self.map.borrow_mut().insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, result });\n+        map.insert(fresh_trait_ref, ProvisionalEvaluation { from_dfn, reached_depth, result });\n     }\n \n     /// Invoked when the node with dfn `dfn` does not get a successful\n@@ -2358,25 +2355,40 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     /// was a failure, then `on_failure` should have been invoked\n     /// already). The callback `op` will be invoked for each\n     /// provisional entry that we can now confirm.\n+    ///\n+    /// Note that we may still have provisional cache items remaining\n+    /// in the cache when this is done. For example, if there is a\n+    /// cycle:\n+    ///\n+    /// * A depends on...\n+    ///     * B depends on A\n+    ///     * C depends on...\n+    ///         * D depends on C\n+    ///     * ...\n+    ///\n+    /// Then as we complete the C node we will have a provisional cache\n+    /// with results for A, B, C, and D. This method would clear out\n+    /// the C and D results, but leave A and B provisional.\n+    ///\n+    /// This is determined based on the DFN: we remove any provisional\n+    /// results created since `dfn` started (e.g., in our example, dfn\n+    /// would be 2, representing the C node, and hence we would\n+    /// remove the result for D, which has DFN 3, but not the results for\n+    /// A and B, which have DFNs 0 and 1 respectively).\n     fn on_completion(\n         &self,\n-        depth: usize,\n+        dfn: usize,\n         mut op: impl FnMut(ty::PolyTraitRef<'tcx>, EvaluationResult),\n     ) {\n-        debug!(?depth, reached_depth = ?self.reached_depth.get(), \"on_completion\");\n+        debug!(?dfn, \"on_completion\");\n \n-        if self.reached_depth.get() < depth {\n-            debug!(\"on_completion: did not yet reach depth to complete\");\n-            return;\n-        }\n-\n-        for (fresh_trait_ref, eval) in self.map.borrow_mut().drain() {\n+        for (fresh_trait_ref, eval) in\n+            self.map.borrow_mut().drain_filter(|_k, eval| eval.from_dfn >= dfn)\n+        {\n             debug!(?fresh_trait_ref, ?eval, \"on_completion\");\n \n             op(fresh_trait_ref, eval.result);\n         }\n-\n-        self.reached_depth.set(usize::MAX);\n     }\n }\n "}, {"sha": "cb8f336721ad6a4d06c1c175e493e4575e803b32", "filename": "compiler/rustc_typeck/src/check/callee.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcallee.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -6,8 +6,14 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{Namespace, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::{infer, traits};\n+use rustc_infer::{\n+    infer,\n+    traits::{self, Obligation},\n+};\n+use rustc_infer::{\n+    infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n+    traits::ObligationCause,\n+};\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n@@ -17,6 +23,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use std::iter;\n \n /// Checks that it is legal to call methods of the trait corresponding\n@@ -294,7 +301,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Expectation<'tcx>,\n     ) -> Ty<'tcx> {\n         let (fn_sig, def_id) = match *callee_ty.kind() {\n-            ty::FnDef(def_id, _) => (callee_ty.fn_sig(self.tcx), Some(def_id)),\n+            ty::FnDef(def_id, subst) => {\n+                // Unit testing: function items annotated with\n+                // `#[rustc_evaluate_where_clauses]` trigger special output\n+                // to let us test the trait evaluation system.\n+                if self.tcx.has_attr(def_id, sym::rustc_evaluate_where_clauses) {\n+                    let predicates = self.tcx.predicates_of(def_id);\n+                    let predicates = predicates.instantiate(self.tcx, subst);\n+                    for (predicate, predicate_span) in\n+                        predicates.predicates.iter().zip(&predicates.spans)\n+                    {\n+                        let obligation = Obligation::new(\n+                            ObligationCause::dummy_with_span(callee_expr.span),\n+                            self.param_env,\n+                            predicate.clone(),\n+                        );\n+                        let result = self.infcx.evaluate_obligation(&obligation);\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                callee_expr.span,\n+                                &format!(\"evaluate({:?}) = {:?}\", predicate, result),\n+                            )\n+                            .span_label(*predicate_span, \"predicate\")\n+                            .emit();\n+                    }\n+                }\n+                (callee_ty.fn_sig(self.tcx), Some(def_id))\n+            }\n             ty::FnPtr(sig) => (sig, None),\n             ref t => {\n                 let mut unit_variant = None;"}, {"sha": "4318e07d07a1819e54c9c2cceff064811734bb44", "filename": "src/test/ui/traits/cache-reached-depth-ice.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -0,0 +1,45 @@\n+#![feature(rustc_attrs)]\n+\n+// Test for a particular corner case where the evaluation\n+// cache can get out of date. The problem here is that\n+// when we cache C, we have observed that it reaches\n+// to depth 2 (the node for B), but we later realize\n+// that B itself depends on A (reached depth 0). We\n+// failed to update the depth for C transitively, which\n+// resulted in an assertion failure when it was referenced\n+// from D.\n+//\n+// A (reached depth 0)\n+//   E\n+//      B // depth 2 -- reached depth = 0\n+//          C // depth 3 -- reached depth = 2 (should be 0)\n+//              B\n+//          A // depth 0\n+//   D (depth 1)\n+//      C (cache -- reached depth = 2)\n+\n+struct A {\n+    e: E,\n+    d: C,\n+}\n+\n+struct E {\n+    b: B,\n+}\n+\n+struct B {\n+    a: Option<Box<A>>,\n+    c: C,\n+}\n+\n+struct C {\n+    b: Option<Box<B>>,\n+}\n+\n+#[rustc_evaluate_where_clauses]\n+fn test<X: ?Sized + Send>() {}\n+\n+fn main() {\n+    test::<A>();\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+}"}, {"sha": "5e662970bb94c481fa10542331195cd8a84ec6c4", "filename": "src/test/ui/traits/cache-reached-depth-ice.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcache-reached-depth-ice.stderr?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -0,0 +1,11 @@\n+error: evaluate(Binder(TraitPredicate(<A as std::marker::Send>), [])) = Ok(EvaluatedToOk)\n+  --> $DIR/cache-reached-depth-ice.rs:43:5\n+   |\n+LL | fn test<X: ?Sized + Send>() {}\n+   |                     ---- predicate\n+...\n+LL |     test::<A>();\n+   |     ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "e186570167d76e8b32efee96b4c747cca17923a1", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.rs?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -0,0 +1,66 @@\n+// Regression test for issue #83538. The problem here is that we have\n+// two cycles:\n+//\n+// * `Ty` embeds `Box<Ty>` indirectly, which depends on `Global: 'static`, which is OkModuloRegions.\n+// * But `Ty` also references `First`, which has a cycle on itself. That should just be `Ok`.\n+//\n+// But our caching mechanism was blending both cycles and giving the incorrect result.\n+\n+#![feature(rustc_attrs)]\n+#![allow(bad_style)]\n+\n+struct First {\n+    b: Vec<First>,\n+}\n+\n+pub struct Second {\n+    d: Vec<First>,\n+}\n+\n+struct Third<f> {\n+    g: Vec<f>,\n+}\n+\n+enum Ty {\n+    j(Fourth, Fifth, Sixth),\n+}\n+\n+struct Fourth {\n+    o: Vec<Ty>,\n+}\n+\n+struct Fifth {\n+    bounds: First,\n+}\n+\n+struct Sixth {\n+    p: Box<Ty>,\n+}\n+\n+#[rustc_evaluate_where_clauses]\n+fn forward()\n+where\n+    Vec<First>: Unpin,\n+    Third<Ty>: Unpin,\n+{\n+}\n+\n+#[rustc_evaluate_where_clauses]\n+fn reverse()\n+where\n+    Third<Ty>: Unpin,\n+    Vec<First>: Unpin,\n+{\n+}\n+\n+fn main() {\n+    // Key is that Vec<First> is \"ok\" and Third<Ty> is \"ok modulo regions\":\n+\n+    forward();\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+\n+    reverse();\n+    //~^ ERROR evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+    //~| ERROR evaluate(Binder(TraitPredicate(<Third<Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+}"}, {"sha": "bfe3e76b214b0c3ba930880cdbae41b7bf021cc5", "filename": "src/test/ui/traits/issue-83538-tainted-cache-after-cycle.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d395a1c2946c79966490f5b1e6e619d3a713e6b/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-83538-tainted-cache-after-cycle.stderr?ref=6d395a1c2946c79966490f5b1e6e619d3a713e6b", "patch": "@@ -0,0 +1,38 @@\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+  --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n+   |\n+LL |     Vec<First>: Unpin,\n+   |                 ----- predicate\n+...\n+LL |     forward();\n+   |     ^^^^^^^\n+\n+error: evaluate(Binder(TraitPredicate(<Third<Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+  --> $DIR/issue-83538-tainted-cache-after-cycle.rs:59:5\n+   |\n+LL |     Third<Ty>: Unpin,\n+   |                ----- predicate\n+...\n+LL |     forward();\n+   |     ^^^^^^^\n+\n+error: evaluate(Binder(TraitPredicate(<Third<Ty> as std::marker::Unpin>), [])) = Ok(EvaluatedToOkModuloRegions)\n+  --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n+   |\n+LL |     Third<Ty>: Unpin,\n+   |                ----- predicate\n+...\n+LL |     reverse();\n+   |     ^^^^^^^\n+\n+error: evaluate(Binder(TraitPredicate(<std::vec::Vec<First> as std::marker::Unpin>), [])) = Ok(EvaluatedToOk)\n+  --> $DIR/issue-83538-tainted-cache-after-cycle.rs:63:5\n+   |\n+LL |     Vec<First>: Unpin,\n+   |                 ----- predicate\n+...\n+LL |     reverse();\n+   |     ^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}