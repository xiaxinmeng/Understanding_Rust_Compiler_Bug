{"sha": "3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2NjJlZTc2YWJkNzc3Y2U2ZmNmMTEyOWU5YjkyMjQxNWY0YzRmZDg=", "commit": {"author": {"name": "Mateusz Miku\u0142a", "email": "mati865@gmail.com", "date": "2018-03-15T09:49:13Z"}, "committer": {"name": "Mateusz Miku\u0142a", "email": "mati865@gmail.com", "date": "2018-03-15T09:49:13Z"}, "message": "Merge branch 'miri'", "tree": {"sha": "b633d6b23095b42acf5dcc31d2cbe54c0d65ed68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b633d6b23095b42acf5dcc31d2cbe54c0d65ed68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "html_url": "https://github.com/rust-lang/rust/commit/3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/comments", "author": {"login": "mati865", "id": 1174646, "node_id": "MDQ6VXNlcjExNzQ2NDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1174646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mati865", "html_url": "https://github.com/mati865", "followers_url": "https://api.github.com/users/mati865/followers", "following_url": "https://api.github.com/users/mati865/following{/other_user}", "gists_url": "https://api.github.com/users/mati865/gists{/gist_id}", "starred_url": "https://api.github.com/users/mati865/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mati865/subscriptions", "organizations_url": "https://api.github.com/users/mati865/orgs", "repos_url": "https://api.github.com/users/mati865/repos", "events_url": "https://api.github.com/users/mati865/events{/privacy}", "received_events_url": "https://api.github.com/users/mati865/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mati865", "id": 1174646, "node_id": "MDQ6VXNlcjExNzQ2NDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1174646?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mati865", "html_url": "https://github.com/mati865", "followers_url": "https://api.github.com/users/mati865/followers", "following_url": "https://api.github.com/users/mati865/following{/other_user}", "gists_url": "https://api.github.com/users/mati865/gists{/gist_id}", "starred_url": "https://api.github.com/users/mati865/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mati865/subscriptions", "organizations_url": "https://api.github.com/users/mati865/orgs", "repos_url": "https://api.github.com/users/mati865/repos", "events_url": "https://api.github.com/users/mati865/events{/privacy}", "received_events_url": "https://api.github.com/users/mati865/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce0a6043f55ed20b827f55174da99aa517e916e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0a6043f55ed20b827f55174da99aa517e916e1", "html_url": "https://github.com/rust-lang/rust/commit/ce0a6043f55ed20b827f55174da99aa517e916e1"}, {"sha": "ca785afc31315966548e74edf380d250ebb0361b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca785afc31315966548e74edf380d250ebb0361b", "html_url": "https://github.com/rust-lang/rust/commit/ca785afc31315966548e74edf380d250ebb0361b"}], "stats": {"total": 1011, "additions": 406, "deletions": 605}, "files": [{"sha": "53d0d7cebaa1a6cf4ff5fa4709eea24736df0550", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,13 +1,9 @@\n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n-use rustc_const_eval::ConstContext;\n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc::hir;\n use syntax::ast::RangeLimits;\n use utils::{self, higher};\n-use utils::const_to_u64;\n+use consts::{constant, Constant};\n \n /// **What it does:** Checks for out of bounds array indexing with a constant\n /// index.\n@@ -63,29 +59,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tables.expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n-                let size = ConstInt::Usize(\n-                    ConstUsize::new(const_to_u64(size), cx.sess().target.usize_ty).expect(\"array size is invalid\"),\n-                );\n-                let parent_item = cx.tcx.hir.get_parent(e.id);\n-                let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-                let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-                let constcx = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables);\n+                let size = size.val.to_raw_bits().unwrap();\n \n                 // Index is a constant uint\n-                if let Ok(const_index) = constcx.eval(index) {\n-                    if let ConstVal::Integral(const_index) = const_index.val {\n-                        if size <= const_index {\n-                            utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n-                        }\n-\n-                        return;\n+                if let Some((Constant::Int(const_index), _)) = constant(cx, index) {\n+                    if size <= const_index {\n+                        utils::span_lint(cx, OUT_OF_BOUNDS_INDEXING, e.span, \"const index is out of bounds\");\n                     }\n+\n+                    return;\n                 }\n \n                 // Index is a constant range\n                 if let Some(range) = higher::range(index) {\n-                    let start = range.start.map(|start| constcx.eval(start)).map(|v| v.ok());\n-                    let end = range.end.map(|end| constcx.eval(end)).map(|v| v.ok());\n+                    let start = range.start.map(|start| constant(cx, start).map(|(c, _)| c));\n+                    let end = range.end.map(|end| constant(cx, end).map(|(c, _)| c));\n \n                     if let Some((start, end)) = to_const_range(&start, &end, range.limits, size) {\n                         if start > size || end > size {\n@@ -114,43 +102,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n /// Returns an option containing a tuple with the start and end (exclusive) of\n /// the range.\n fn to_const_range(\n-    start: &Option<Option<&ty::Const>>,\n-    end: &Option<Option<&ty::Const>>,\n+    start: &Option<Option<Constant>>,\n+    end: &Option<Option<Constant>>,\n     limits: RangeLimits,\n-    array_size: ConstInt,\n-) -> Option<(ConstInt, ConstInt)> {\n+    array_size: u128,\n+) -> Option<(u128, u128)> {\n     let start = match *start {\n-        Some(Some(&ty::Const {\n-            val: ConstVal::Integral(x),\n-            ..\n-        })) => x,\n+        Some(Some(Constant::Int(x))) => x,\n         Some(_) => return None,\n-        None => ConstInt::U8(0),\n+        None => 0,\n     };\n \n     let end = match *end {\n-        Some(Some(&ty::Const {\n-            val: ConstVal::Integral(x),\n-            ..\n-        })) => if limits == RangeLimits::Closed {\n-            match x {\n-                ConstInt::U8(_) => (x + ConstInt::U8(1)),\n-                ConstInt::U16(_) => (x + ConstInt::U16(1)),\n-                ConstInt::U32(_) => (x + ConstInt::U32(1)),\n-                ConstInt::U64(_) => (x + ConstInt::U64(1)),\n-                ConstInt::U128(_) => (x + ConstInt::U128(1)),\n-                ConstInt::Usize(ConstUsize::Us16(_)) => (x + ConstInt::Usize(ConstUsize::Us16(1))),\n-                ConstInt::Usize(ConstUsize::Us32(_)) => (x + ConstInt::Usize(ConstUsize::Us32(1))),\n-                ConstInt::Usize(ConstUsize::Us64(_)) => (x + ConstInt::Usize(ConstUsize::Us64(1))),\n-                ConstInt::I8(_) => (x + ConstInt::I8(1)),\n-                ConstInt::I16(_) => (x + ConstInt::I16(1)),\n-                ConstInt::I32(_) => (x + ConstInt::I32(1)),\n-                ConstInt::I64(_) => (x + ConstInt::I64(1)),\n-                ConstInt::I128(_) => (x + ConstInt::I128(1)),\n-                ConstInt::Isize(ConstIsize::Is16(_)) => (x + ConstInt::Isize(ConstIsize::Is16(1))),\n-                ConstInt::Isize(ConstIsize::Is32(_)) => (x + ConstInt::Isize(ConstIsize::Is32(1))),\n-                ConstInt::Isize(ConstIsize::Is64(_)) => (x + ConstInt::Isize(ConstIsize::Is64(1))),\n-            }.expect(\"such a big array is not realistic\")\n+        Some(Some(Constant::Int(x))) => if limits == RangeLimits::Closed {\n+            x + 1\n         } else {\n             x\n         },"}, {"sha": "7eb6477b269d0b00a984332c9bfef455cf43dc6b", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,11 +1,10 @@\n use rustc::hir::*;\n-use rustc::hir::def::Def;\n use rustc::lint::*;\n-use rustc_const_eval::lookup_const_by_id;\n use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::{span_lint, span_lint_and_then};\n use utils::sugg::Sugg;\n+use consts::{constant, Constant};\n \n /// **What it does:** Checks for incompatible bit masks in comparisons.\n ///\n@@ -302,31 +301,8 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str\n }\n \n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n-    use rustc::ty::subst::Substs;\n-    match lit.node {\n-        ExprLit(ref lit_ptr) => {\n-            if let LitKind::Int(value, _) = lit_ptr.node {\n-                Some(value) // TODO: Handle sign\n-            } else {\n-                None\n-            }\n-        },\n-        ExprPath(ref qpath) => {\n-            let def = cx.tables.qpath_def(qpath, lit.hir_id);\n-            if let Def::Const(def_id) = def {\n-                lookup_const_by_id(cx.tcx, cx.param_env.and((def_id, Substs::empty()))).and_then(|(l, _ty)| {\n-                    let body = if let Some(id) = cx.tcx.hir.as_local_node_id(l) {\n-                        cx.tcx.mir_const_qualif(def_id);\n-                        cx.tcx.hir.body(cx.tcx.hir.body_owned_by(id))\n-                    } else {\n-                        cx.tcx.extern_const_body(def_id).body\n-                    };\n-                    fetch_int_literal(cx, &body.value)\n-                })\n-            } else {\n-                None\n-            }\n-        },\n+    match constant(cx, lit)?.0 {\n+        Constant::Int(n) => Some(n),\n         _ => None,\n     }\n }"}, {"sha": "7c43cb668b3ed8df0a7b6df7ecbe450e7cb40865", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 210, "deletions": 144, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -2,19 +2,18 @@\n \n use rustc::lint::LateContext;\n use rustc::hir::def::Def;\n-use rustc_const_eval::lookup_const_by_id;\n-use rustc_const_math::ConstInt;\n use rustc::hir::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, Instance};\n use rustc::ty::subst::{Subst, Substs};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitKind, StrStyle};\n+use syntax::ast::{FloatTy, LitKind};\n use syntax::ptr::P;\n-use utils::const_to_u64;\n+use rustc::middle::const_val::ConstVal;\n+use utils::{sext, unsext, clip};\n \n #[derive(Debug, Copy, Clone)]\n pub enum FloatWidth {\n@@ -36,15 +35,17 @@ impl From<FloatTy> for FloatWidth {\n #[derive(Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\"\n-    Str(String, StrStyle),\n+    Str(String),\n     /// a Binary String b\"abc\"\n     Binary(Rc<Vec<u8>>),\n     /// a single char 'a'\n     Char(char),\n-    /// an integer, third argument is whether the value is negated\n-    Int(ConstInt),\n-    /// a float with given type\n-    Float(String, FloatWidth),\n+    /// an integer's bit representation\n+    Int(u128),\n+    /// an f32\n+    F32(f32),\n+    /// an f64\n+    F64(f64),\n     /// true or false\n     Bool(bool),\n     /// an array of constants\n@@ -58,20 +59,21 @@ pub enum Constant {\n impl PartialEq for Constant {\n     fn eq(&self, other: &Self) -> bool {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => ls == rs && l_sty == r_sty,\n+            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => ls == rs,\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n-            (&Constant::Int(l), &Constant::Int(r)) => {\n-                l.is_negative() == r.is_negative() && l.to_u128_unchecked() == r.to_u128_unchecked()\n+            (&Constant::Int(l), &Constant::Int(r)) => l == r,\n+            (&Constant::F64(l), &Constant::F64(r)) => {\n+                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n+                // `Fw32 == Fw64` so don\u2019t compare them\n+                // mem::transmute is required to catch non-matching 0.0, -0.0, and NaNs\n+                unsafe { mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r) }\n             },\n-            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n+            (&Constant::F32(l), &Constant::F32(r)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n                 // `Fw32 == Fw64` so don\u2019t compare them\n-                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                    // mem::transmute is required to catch non-matching 0.0, -0.0, and NaNs\n-                    (Ok(l), Ok(r)) => unsafe { mem::transmute::<f64, u64>(l) == mem::transmute::<f64, u64>(r) },\n-                    _ => false,\n-                }\n+                // mem::transmute is required to catch non-matching 0.0, -0.0, and NaNs\n+                unsafe { mem::transmute::<f64, u64>(l as f64) == mem::transmute::<f64, u64>(r as f64) }\n             },\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n             (&Constant::Vec(ref l), &Constant::Vec(ref r)) | (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) => l == r,\n@@ -87,9 +89,8 @@ impl Hash for Constant {\n         H: Hasher,\n     {\n         match *self {\n-            Constant::Str(ref s, ref k) => {\n+            Constant::Str(ref s) => {\n                 s.hash(state);\n-                k.hash(state);\n             },\n             Constant::Binary(ref b) => {\n                 b.hash(state);\n@@ -98,14 +99,13 @@ impl Hash for Constant {\n                 c.hash(state);\n             },\n             Constant::Int(i) => {\n-                i.to_u128_unchecked().hash(state);\n-                i.is_negative().hash(state);\n+                i.hash(state);\n             },\n-            Constant::Float(ref f, _) => {\n-                // don\u2019t use the width here because of PartialEq implementation\n-                if let Ok(f) = f.parse::<f64>() {\n-                    unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n-                }\n+            Constant::F32(f) => {\n+                unsafe { mem::transmute::<f64, u64>(f as f64) }.hash(state);\n+            },\n+            Constant::F64(f) => {\n+                unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n             },\n             Constant::Bool(b) => {\n                 b.hash(state);\n@@ -124,25 +124,11 @@ impl Hash for Constant {\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         match (self, other) {\n-            (&Constant::Str(ref ls, ref l_sty), &Constant::Str(ref rs, ref r_sty)) => if l_sty == r_sty {\n-                Some(ls.cmp(rs))\n-            } else {\n-                None\n-            },\n+            (&Constant::Str(ref ls), &Constant::Str(ref rs)) => Some(ls.cmp(rs)),\n             (&Constant::Char(ref l), &Constant::Char(ref r)) => Some(l.cmp(r)),\n             (&Constant::Int(l), &Constant::Int(r)) => Some(l.cmp(&r)),\n-            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n-                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                    (Ok(ref l), Ok(ref r)) => {\n-                        match (l.partial_cmp(r), l.is_sign_positive() == r.is_sign_positive()) {\n-                            // Check for comparison of -0.0 and 0.0\n-                            (Some(Ordering::Equal), false) => None,\n-                            (x, _) => x,\n-                        }\n-                    },\n-                    _ => None,\n-                }\n-            },\n+            (&Constant::F64(l), &Constant::F64(r)) => l.partial_cmp(&r),\n+            (&Constant::F32(l), &Constant::F32(r)) => l.partial_cmp(&r),\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),\n             (&Constant::Tuple(ref l), &Constant::Tuple(ref r)) | (&Constant::Vec(ref l), &Constant::Vec(ref r)) => {\n                 l.partial_cmp(r)\n@@ -157,63 +143,25 @@ impl PartialOrd for Constant {\n }\n \n /// parse a `LitKind` to a `Constant`\n-#[allow(cast_possible_wrap)]\n-pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: Ty<'tcx>) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n-    use syntax::ast::LitIntType::*;\n-    use rustc::ty::util::IntTypeExt;\n \n-    if let ty::TyAdt(adt, _) = ty.sty {\n-        if adt.is_enum() {\n-            ty = adt.repr.discr_type().to_ty(tcx)\n-        }\n-    }\n     match *lit {\n-        LitKind::Str(ref is, style) => Constant::Str(is.to_string(), style),\n-        LitKind::Byte(b) => Constant::Int(ConstInt::U8(b)),\n+        LitKind::Str(ref is, _) => Constant::Str(is.to_string()),\n+        LitKind::Byte(b) => Constant::Int(b as u128),\n         LitKind::ByteStr(ref s) => Constant::Binary(Rc::clone(s)),\n         LitKind::Char(c) => Constant::Char(c),\n-        LitKind::Int(n, hint) => match (&ty.sty, hint) {\n-            (&ty::TyInt(ity), _) | (_, Signed(ity)) => {\n-                Constant::Int(ConstInt::new_signed_truncating(n as i128, ity, tcx.sess.target.isize_ty))\n-            },\n-            (&ty::TyUint(uty), _) | (_, Unsigned(uty)) => {\n-                Constant::Int(ConstInt::new_unsigned_truncating(n as u128, uty, tcx.sess.target.usize_ty))\n-            },\n+        LitKind::Int(n, _) => Constant::Int(n),\n+        LitKind::Float(ref is, _) |\n+        LitKind::FloatUnsuffixed(ref is) => match ty.sty {\n+            ty::TyFloat(FloatTy::F32) => Constant::F32(is.as_str().parse().unwrap()),\n+            ty::TyFloat(FloatTy::F64) => Constant::F64(is.as_str().parse().unwrap()),\n             _ => bug!(),\n         },\n-        LitKind::Float(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n-        LitKind::FloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::Any),\n         LitKind::Bool(b) => Constant::Bool(b),\n     }\n }\n \n-fn constant_not(o: &Constant) -> Option<Constant> {\n-    use self::Constant::*;\n-    match *o {\n-        Bool(b) => Some(Bool(!b)),\n-        Int(value) => (!value).ok().map(Int),\n-        _ => None,\n-    }\n-}\n-\n-fn constant_negate(o: Constant) -> Option<Constant> {\n-    use self::Constant::*;\n-    match o {\n-        Int(value) => (-value).ok().map(Int),\n-        Float(is, ty) => Some(Float(neg_float_str(&is), ty)),\n-        _ => None,\n-    }\n-}\n-\n-fn neg_float_str(s: &str) -> String {\n-    if s.starts_with('-') {\n-        s[1..].to_owned()\n-    } else {\n-        format!(\"-{}\", s)\n-    }\n-}\n-\n pub fn constant(lcx: &LateContext, e: &Expr) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         tcx: lcx.tcx,\n@@ -255,19 +203,19 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprPath(ref qpath) => self.fetch_path(qpath, e.hir_id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n-            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tcx, self.tables.expr_ty(e))),\n+            ExprLit(ref lit) => Some(lit_to_constant(&lit.node, self.tables.expr_ty(e))),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n             ExprRepeat(ref value, _) => {\n                 let n = match self.tables.expr_ty(e).sty {\n-                    ty::TyArray(_, n) => const_to_u64(n),\n+                    ty::TyArray(_, n) => n.val.to_raw_bits().expect(\"array length\"),\n                     _ => span_bug!(e.span, \"typeck error\"),\n                 };\n-                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n))\n+                self.expr(value).map(|v| Constant::Repeat(Box::new(v), n as u64))\n             },\n             ExprUnary(op, ref operand) => self.expr(operand).and_then(|o| match op {\n-                UnNot => constant_not(&o),\n-                UnNeg => constant_negate(o),\n+                UnNot => self.constant_not(&o, self.tables.expr_ty(e)),\n+                UnNeg => self.constant_negate(o, self.tables.expr_ty(e)),\n                 UnDeref => Some(o),\n             }),\n             ExprBinary(op, ref left, ref right) => self.binop(op, left, right),\n@@ -276,6 +224,42 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n+    fn constant_not(&self, o: &Constant, ty: ty::Ty) -> Option<Constant> {\n+        use self::Constant::*;\n+        match *o {\n+            Bool(b) => Some(Bool(!b)),\n+            Int(value) => {\n+                let mut value = !value;\n+                match ty.sty {\n+                    ty::TyInt(ity) => Some(Int(unsext(self.tcx, value as i128, ity))),\n+                    ty::TyUint(ity) => Some(Int(clip(self.tcx, value, ity))),\n+                    _ => None,\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn constant_negate(&self, o: Constant, ty: ty::Ty) -> Option<Constant> {\n+        use self::Constant::*;\n+        match o {\n+            Int(value) => {\n+                let ity = match ty.sty {\n+                    ty::TyInt(ity) => ity,\n+                    _ => return None,\n+                };\n+                // sign extend\n+                let value = sext(self.tcx, value, ity);\n+                let value = value.checked_neg()?;\n+                // clear unused bits\n+                Some(Int(unsext(self.tcx, value, ity)))\n+            },\n+            F32(f) => Some(F32(-f)),\n+            F64(f) => Some(F64(-f)),\n+            _ => None,\n+        }\n+    }\n+\n     /// create `Some(Vec![..])` of all constants, unless there is any\n     /// non-constant part\n     fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n@@ -295,27 +279,18 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                 } else {\n                     substs.subst(self.tcx, self.substs)\n                 };\n-                let param_env = self.param_env.and((def_id, substs));\n-                if let Some((def_id, substs)) = lookup_const_by_id(self.tcx, param_env) {\n-                    let mut cx = Self {\n-                        tcx: self.tcx,\n-                        tables: self.tcx.typeck_tables_of(def_id),\n-                        needed_resolution: false,\n-                        substs: substs,\n-                        param_env: param_env.param_env,\n-                    };\n-                    let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        self.tcx.mir_const_qualif(def_id);\n-                        self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n-                    } else {\n-                        self.tcx.extern_const_body(def_id).body\n-                    };\n-                    let ret = cx.expr(&body.value);\n-                    if ret.is_some() {\n-                        self.needed_resolution = true;\n-                    }\n-                    return ret;\n+                let instance = Instance::resolve(self.tcx, self.param_env, def_id, substs)?;\n+                let gid = GlobalId {\n+                    instance,\n+                    promoted: None,\n+                };\n+                use rustc::mir::interpret::GlobalId;\n+                let result = self.tcx.const_eval(self.param_env.and(gid)).ok()?;\n+                let ret = miri_to_const(self.tcx, result);\n+                if ret.is_some() {\n+                    self.needed_resolution = true;\n                 }\n+                return ret;\n             },\n             _ => {},\n         }\n@@ -344,36 +319,127 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n-        let l = if let Some(l) = self.expr(left) {\n-            l\n-        } else {\n-            return None;\n-        };\n+        let l = self.expr(left)?;\n         let r = self.expr(right);\n-        match (op.node, l, r) {\n-            (BiAdd, Constant::Int(l), Some(Constant::Int(r))) => (l + r).ok().map(Constant::Int),\n-            (BiSub, Constant::Int(l), Some(Constant::Int(r))) => (l - r).ok().map(Constant::Int),\n-            (BiMul, Constant::Int(l), Some(Constant::Int(r))) => (l * r).ok().map(Constant::Int),\n-            (BiDiv, Constant::Int(l), Some(Constant::Int(r))) => (l / r).ok().map(Constant::Int),\n-            (BiRem, Constant::Int(l), Some(Constant::Int(r))) => (l % r).ok().map(Constant::Int),\n-            (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n-            (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n-            (BiAnd, Constant::Bool(true), Some(r)) | (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n-            (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n-            (BiBitXor, Constant::Int(l), Some(Constant::Int(r))) => (l ^ r).ok().map(Constant::Int),\n-            (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n-            (BiBitAnd, Constant::Int(l), Some(Constant::Int(r))) => (l & r).ok().map(Constant::Int),\n-            (BiBitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n-            (BiBitOr, Constant::Int(l), Some(Constant::Int(r))) => (l | r).ok().map(Constant::Int),\n-            (BiShl, Constant::Int(l), Some(Constant::Int(r))) => (l << r).ok().map(Constant::Int),\n-            (BiShr, Constant::Int(l), Some(Constant::Int(r))) => (l >> r).ok().map(Constant::Int),\n-            (BiEq, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l == r)),\n-            (BiNe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l != r)),\n-            (BiLt, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l < r)),\n-            (BiLe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l <= r)),\n-            (BiGe, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l >= r)),\n-            (BiGt, Constant::Int(l), Some(Constant::Int(r))) => Some(Constant::Bool(l > r)),\n+        match (l, r) {\n+            (Constant::Int(l), Some(Constant::Int(r))) => {\n+                match self.tables.expr_ty(left).sty {\n+                    ty::TyInt(ity) => {\n+                        let l = sext(self.tcx, l, ity);\n+                        let r = sext(self.tcx, r, ity);\n+                        let zext = |n: i128| Constant::Int(unsext(self.tcx, n, ity));\n+                        match op.node {\n+                            BiAdd => l.checked_add(r).map(zext),\n+                            BiSub => l.checked_sub(r).map(zext),\n+                            BiMul => l.checked_mul(r).map(zext),\n+                            BiDiv if r != 0 => l.checked_div(r).map(zext),\n+                            BiRem if r != 0 => l.checked_rem(r).map(zext),\n+                            BiShr => l.checked_shr(r as u128 as u32).map(zext),\n+                            BiShl => l.checked_shl(r as u128 as u32).map(zext),\n+                            BiBitXor => Some(zext(l ^ r)),\n+                            BiBitOr => Some(zext(l | r)),\n+                            BiBitAnd => Some(zext(l & r)),\n+                            BiEq => Some(Constant::Bool(l == r)),\n+                            BiNe => Some(Constant::Bool(l != r)),\n+                            BiLt => Some(Constant::Bool(l < r)),\n+                            BiLe => Some(Constant::Bool(l <= r)),\n+                            BiGe => Some(Constant::Bool(l >= r)),\n+                            BiGt => Some(Constant::Bool(l > r)),\n+                            _ => None,\n+                        }\n+                    }\n+                    ty::TyUint(_) => {\n+                        match op.node {\n+                            BiAdd => l.checked_add(r).map(Constant::Int),\n+                            BiSub => l.checked_sub(r).map(Constant::Int),\n+                            BiMul => l.checked_mul(r).map(Constant::Int),\n+                            BiDiv => l.checked_div(r).map(Constant::Int),\n+                            BiRem => l.checked_rem(r).map(Constant::Int),\n+                            BiShr => l.checked_shr(r as u32).map(Constant::Int),\n+                            BiShl => l.checked_shl(r as u32).map(Constant::Int),\n+                            BiBitXor => Some(Constant::Int(l ^ r)),\n+                            BiBitOr => Some(Constant::Int(l | r)),\n+                            BiBitAnd => Some(Constant::Int(l & r)),\n+                            BiEq => Some(Constant::Bool(l == r)),\n+                            BiNe => Some(Constant::Bool(l != r)),\n+                            BiLt => Some(Constant::Bool(l < r)),\n+                            BiLe => Some(Constant::Bool(l <= r)),\n+                            BiGe => Some(Constant::Bool(l >= r)),\n+                            BiGt => Some(Constant::Bool(l > r)),\n+                            _ => None,\n+                        }\n+                    },\n+                    _ => None,\n+                }\n+            },\n+            (Constant::F32(l), Some(Constant::F32(r))) => match op.node {\n+                BiAdd => Some(Constant::F32(l + r)),\n+                BiSub => Some(Constant::F32(l - r)),\n+                BiMul => Some(Constant::F32(l * r)),\n+                BiDiv => Some(Constant::F32(l / r)),\n+                BiRem => Some(Constant::F32(l * r)),\n+                BiEq => Some(Constant::Bool(l == r)),\n+                BiNe => Some(Constant::Bool(l != r)),\n+                BiLt => Some(Constant::Bool(l < r)),\n+                BiLe => Some(Constant::Bool(l <= r)),\n+                BiGe => Some(Constant::Bool(l >= r)),\n+                BiGt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (Constant::F64(l), Some(Constant::F64(r))) => match op.node {\n+                BiAdd => Some(Constant::F64(l + r)),\n+                BiSub => Some(Constant::F64(l - r)),\n+                BiMul => Some(Constant::F64(l * r)),\n+                BiDiv => Some(Constant::F64(l / r)),\n+                BiRem => Some(Constant::F64(l * r)),\n+                BiEq => Some(Constant::Bool(l == r)),\n+                BiNe => Some(Constant::Bool(l != r)),\n+                BiLt => Some(Constant::Bool(l < r)),\n+                BiLe => Some(Constant::Bool(l <= r)),\n+                BiGe => Some(Constant::Bool(l >= r)),\n+                BiGt => Some(Constant::Bool(l > r)),\n+                _ => None,\n+            },\n+            (l, r) => match (op.node, l, r) {\n+                (BiAnd, Constant::Bool(false), _) => Some(Constant::Bool(false)),\n+                (BiOr, Constant::Bool(true), _) => Some(Constant::Bool(true)),\n+                (BiAnd, Constant::Bool(true), Some(r)) | (BiOr, Constant::Bool(false), Some(r)) => Some(r),\n+                (BiBitXor, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l ^ r)),\n+                (BiBitAnd, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l & r)),\n+                (BiBitOr, Constant::Bool(l), Some(Constant::Bool(r))) => Some(Constant::Bool(l | r)),\n+                _ => None,\n+            },\n+        }\n+    }\n+}\n+\n+pub fn miri_to_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, result: &ty::Const<'tcx>) -> Option<Constant> {\n+    use rustc::mir::interpret::{Value, PrimVal};\n+    match result.val {\n+        ConstVal::Value(Value::ByVal(PrimVal::Bytes(b))) => match result.ty.sty {\n+            ty::TyBool => Some(Constant::Bool(b == 1)),\n+            ty::TyUint(_) | ty::TyInt(_) => Some(Constant::Int(b)),\n+            ty::TyFloat(FloatTy::F32) => Some(Constant::F32(f32::from_bits(b as u32))),\n+            ty::TyFloat(FloatTy::F64) => Some(Constant::F64(f64::from_bits(b as u64))),\n+            // FIXME: implement other conversion\n+            _ => None,\n+        },\n+        ConstVal::Value(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(n))) => match result.ty.sty {\n+            ty::TyRef(_, tam) => match tam.ty.sty {\n+                ty::TyStr => {\n+                    let alloc = tcx\n+                        .interpret_interner\n+                        .get_alloc(ptr.alloc_id)\n+                        .unwrap();\n+                    let offset = ptr.offset as usize;\n+                    let n = n as usize;\n+                    String::from_utf8(alloc.bytes[offset..(offset + n)].to_owned()).ok().map(Constant::Str)\n+                },\n+                _ => None,\n+            },\n             _ => None,\n         }\n+        // FIXME: implement other conversions\n+        _ => None,\n     }\n }"}, {"sha": "5da6457edd15e290fc916bc56867a5ae44b98ae5", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -2,13 +2,14 @@\n //! don't fit into an `i32`\n \n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n-use rustc_const_math::*;\n use rustc::hir::*;\n-use rustc::ty;\n-use rustc::traits::Reveal;\n+use rustc::{ty, traits};\n use rustc::ty::subst::Substs;\n+use syntax::ast::{IntTy, UintTy};\n use utils::span_lint;\n+use consts::{Constant, miri_to_const};\n+use rustc::ty::util::IntTypeExt;\n+use rustc::mir::interpret::GlobalId;\n \n /// **What it does:** Checks for C-like enumerations that are\n /// `repr(isize/usize)` and have values that don't fit into an `i32`.\n@@ -43,36 +44,46 @@ impl LintPass for UnportableVariant {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n     #[allow(cast_possible_truncation, cast_sign_loss)]\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if cx.tcx.data_layout.pointer_size.bits() != 64 {\n+            return;\n+        }\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;\n                 if let Some(body_id) = variant.disr_expr {\n-                    let expr = &cx.tcx.hir.body(body_id).value;\n+                    let param_env = ty::ParamEnv::empty();\n                     let did = cx.tcx.hir.body_owner_def_id(body_id);\n-                    let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                     let substs = Substs::identity_for_item(cx.tcx.global_tcx(), did);\n-                    let bad = match cx.tcx\n-                        .at(expr.span)\n-                        .const_eval(param_env.and((did, substs)))\n-                    {\n-                        Ok(&ty::Const {\n-                            val: ConstVal::Integral(Usize(Us64(i))),\n-                            ..\n-                        }) => u64::from(i as u32) != i,\n-                        Ok(&ty::Const {\n-                            val: ConstVal::Integral(Isize(Is64(i))),\n-                            ..\n-                        }) => i64::from(i as i32) != i,\n-                        _ => false,\n+                    let instance = ty::Instance::new(did, substs);\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None\n                     };\n-                    if bad {\n+                    let constant = cx.tcx.const_eval(param_env.and(cid)).ok();\n+                    if let Some(Constant::Int(val)) = constant.and_then(|c| miri_to_const(cx.tcx, c)) {\n+                        let mut ty = cx.tcx.type_of(did);\n+                        if let ty::TyAdt(adt, _) = ty.sty {\n+                            if adt.is_enum() {\n+                                ty = adt.repr.discr_type().to_ty(cx.tcx);\n+                            }\n+                        }\n+                        match ty.sty {\n+                            ty::TyInt(IntTy::Isize) => {\n+                                let val = ((val as i128) << 64) >> 64;\n+                                if val <= i32::max_value() as i128 && val >= i32::min_value() as i128 {\n+                                    continue;\n+                                }\n+                            }\n+                            ty::TyUint(UintTy::Usize) if val > u32::max_value() as u128 => {},\n+                            _ => continue,\n+                        }\n                         span_lint(\n                             cx,\n                             ENUM_CLIKE_UNPORTABLE_VARIANT,\n                             var.span,\n                             \"Clike enum variant discriminant is not portable to 32-bit targets\",\n                         );\n-                    }\n+                    };\n                 }\n             }\n         }"}, {"sha": "a601d91a185278b316fa7150180ce4bd9a7680d7", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n \n fn check(cx: &LateContext, e: &Expr, span: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n-        if v.to_u128_unchecked() == 0 {\n+        if v == 0 {\n             span_lint(\n                 cx,\n                 ERASING_OP,"}, {"sha": "717245ec0f5242a79ea5cdcc3311b27ca7235df3", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,9 +1,9 @@\n use consts::{constant_simple, Constant};\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc_const_math::ConstInt;\n use syntax::codemap::Span;\n-use utils::{in_macro, snippet, span_lint};\n+use utils::{in_macro, snippet, span_lint, unsext, clip};\n+use rustc::ty;\n \n /// **What it does:** Checks for identity operations, e.g. `x + 0`.\n ///\n@@ -58,29 +58,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n     }\n }\n \n-fn all_ones(v: &ConstInt) -> bool {\n-    match *v {\n-        ConstInt::I8(i) => i == !0,\n-        ConstInt::I16(i) => i == !0,\n-        ConstInt::I32(i) => i == !0,\n-        ConstInt::I64(i) => i == !0,\n-        ConstInt::I128(i) => i == !0,\n-        ConstInt::U8(i) => i == !0,\n-        ConstInt::U16(i) => i == !0,\n-        ConstInt::U32(i) => i == !0,\n-        ConstInt::U64(i) => i == !0,\n-        ConstInt::U128(i) => i == !0,\n-        _ => false,\n-    }\n-}\n-\n #[allow(cast_possible_wrap)]\n fn check(cx: &LateContext, e: &Expr, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, e) {\n+        let check = match cx.tables.expr_ty(e).sty {\n+            ty::TyInt(ity) => unsext(cx.tcx, -1i128, ity),\n+            ty::TyUint(uty) => clip(cx.tcx, !0, uty),\n+            _ => return,\n+        };\n         if match m {\n-            0 => v.to_u128_unchecked() == 0,\n-            -1 => all_ones(&v),\n-            1 => v.to_u128_unchecked() == 1,\n+            0 => v == 0,\n+            -1 => v == check,\n+            1 => v == 1,\n             _ => unreachable!(),\n         } {\n             span_lint("}, {"sha": "0034e28fac2f70430ef2ca2c750de3621fa43539", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -10,6 +10,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(inclusive_range_syntax, range_contains)]\n #![feature(macro_vis_matcher)]\n+#![feature(dotdoteq_in_patterns)]\n #![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n #![recursion_limit = \"256\"]\n \n@@ -37,7 +38,6 @@ extern crate regex_syntax;\n \n extern crate quine_mc_cluskey;\n \n-extern crate rustc_const_eval;\n extern crate rustc_const_math;\n extern crate rustc_errors;\n extern crate rustc_plugin;"}, {"sha": "a0f3db7b784dab1caebb5a3b3bc5b12d3590ca47", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -6,23 +6,19 @@ use rustc::hir::def_id;\n use rustc::hir::intravisit::{walk_block, walk_decl, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc::hir::map::Node::{NodeBlock, NodeExpr, NodeStmt};\n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::middle::region;\n // use rustc::middle::region::CodeExtent;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::cmt;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::{Subst, Substs};\n-use rustc_const_eval::ConstContext;\n+use rustc::ty::subst::Subst;\n use std::collections::{HashMap, HashSet};\n use std::iter::{once, Iterator};\n use syntax::ast;\n use syntax::codemap::Span;\n-use utils::sugg;\n-use utils::const_to_u64;\n-\n-use consts::constant;\n+use utils::{sugg, sext};\n+use consts::{constant, Constant};\n \n use utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n             last_path_segment, match_trait_method, match_type, match_var, multispan_sugg, snippet, snippet_opt,\n@@ -1113,27 +1109,22 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }) = higher::range(arg)\n     {\n         // ...and both sides are compile-time constant integers...\n-        let parent_item = cx.tcx.hir.get_parent(arg.id);\n-        let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-        let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-        let constcx = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables);\n-        if let Ok(start_idx) = constcx.eval(start) {\n-            if let Ok(end_idx) = constcx.eval(end) {\n+        if let Some((start_idx, _)) = constant(cx, start) {\n+            if let Some((end_idx, _)) = constant(cx, end) {\n                 // ...and the start index is greater than the end index,\n                 // this loop will never run. This is often confusing for developers\n                 // who think that this will iterate from the larger value to the\n                 // smaller value.\n+                let ty = cx.tables.expr_ty(start);\n                 let (sup, eq) = match (start_idx, end_idx) {\n                     (\n-                        &ty::Const {\n-                            val: ConstVal::Integral(start_idx),\n-                            ..\n-                        },\n-                        &ty::Const {\n-                            val: ConstVal::Integral(end_idx),\n-                            ..\n-                        },\n-                    ) => (start_idx > end_idx, start_idx == end_idx),\n+                        Constant::Int(start_idx),\n+                        Constant::Int(end_idx),\n+                    ) => (match ty.sty {\n+                        ty::TyInt(ity) => sext(cx.tcx, start_idx, ity) > sext(cx.tcx, end_idx, ity),\n+                        ty::TyUint(_) => start_idx > end_idx,\n+                        _ => false,\n+                    }, start_idx == end_idx),\n                     _ => (false, false),\n                 };\n \n@@ -1220,7 +1211,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                     match cx.tables.expr_ty(&args[0]).sty {\n                         // If the length is greater than 32 no traits are implemented for array and\n                         // therefore we cannot use `&`.\n-                        ty::TypeVariants::TyArray(_, size) if const_to_u64(size) > 32 => (),\n+                        ty::TypeVariants::TyArray(_, size) if size.val.to_raw_bits().expect(\"array size\") > 32 => (),\n                         _ => lint_iter_method(cx, args, arg, method_name),\n                     };\n                 } else {\n@@ -1795,7 +1786,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n fn is_iterable_array(ty: Ty) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n-        ty::TyArray(_, n) => (0..=32).contains(const_to_u64(n)),\n+        ty::TyArray(_, n) => (0..=32).contains(n.val.to_raw_bits().expect(\"array length\")),\n         _ => false,\n     }\n }\n@@ -2249,4 +2240,4 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n     }\n \n     fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-}\n\\ No newline at end of file\n+}"}, {"sha": "b617f098e3e7a27899f6695905e4aab90d61827c", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,19 +1,15 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::Substs;\n-use rustc_const_eval::ConstContext;\n-use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n use std::collections::Bound;\n use syntax::ast::LitKind;\n-use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::paths;\n use utils::{expr_block, in_external_macro, is_allowed, is_expn_of, match_qpath, match_type, multispan_sugg,\n             remove_blocks, snippet, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty};\n use utils::sugg::Sugg;\n+use consts::{constant, Constant};\n \n /// **What it does:** Checks for matches with a single arm where an `if let`\n /// will usually suffice.\n@@ -343,7 +339,7 @@ fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n \n fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr, arms: &'tcx [Arm]) {\n     if arms.len() >= 2 && cx.tables.expr_ty(ex).is_integral() {\n-        let ranges = all_ranges(cx, arms, ex.id);\n+        let ranges = all_ranges(cx, arms);\n         let type_ranges = type_ranges(&ranges);\n         if !type_ranges.is_empty() {\n             if let Some((start, end)) = overlapping(&type_ranges) {\n@@ -460,12 +456,7 @@ fn check_match_as_ref(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n fn all_ranges<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     arms: &'tcx [Arm],\n-    id: NodeId,\n-) -> Vec<SpannedRange<&'tcx ty::Const<'tcx>>> {\n-    let parent_item = cx.tcx.hir.get_parent(id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    let constcx = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables);\n+) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm {\n@@ -478,25 +469,19 @@ fn all_ranges<'a, 'tcx>(\n             } else {\n                 [].iter()\n             }.filter_map(|pat| {\n-                if_chain! {\n-                    if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node;\n-                    if let Ok(lhs) = constcx.eval(lhs);\n-                    if let Ok(rhs) = constcx.eval(rhs);\n-                    then {\n-                        let rhs = match *range_end {\n-                            RangeEnd::Included => Bound::Included(rhs),\n-                            RangeEnd::Excluded => Bound::Excluded(rhs),\n-                        };\n-                        return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n-                    }\n+                if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node {\n+                    let lhs = constant(cx, lhs)?.0;\n+                    let rhs = constant(cx, rhs)?.0;\n+                    let rhs = match *range_end {\n+                        RangeEnd::Included => Bound::Included(rhs),\n+                        RangeEnd::Excluded => Bound::Excluded(rhs),\n+                    };\n+                    return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n                 }\n \n-                if_chain! {\n-                    if let PatKind::Lit(ref value) = pat.node;\n-                    if let Ok(value) = constcx.eval(value);\n-                    then {\n-                        return Some(SpannedRange { span: pat.span, node: (value, Bound::Included(value)) });\n-                    }\n+                if let PatKind::Lit(ref value) = pat.node {\n+                    let value = constant(cx, value)?.0;\n+                    return Some(SpannedRange { span: pat.span, node: (value.clone(), Bound::Included(value)) });\n                 }\n \n                 None\n@@ -511,46 +496,31 @@ pub struct SpannedRange<T> {\n     pub node: (T, Bound<T>),\n }\n \n-type TypedRanges = Vec<SpannedRange<ConstInt>>;\n+type TypedRanges = Vec<SpannedRange<u128>>;\n \n /// Get all `Int` ranges or all `Uint` ranges. Mixed types are an error anyway\n /// and other types than\n /// `Uint` and `Int` probably don't make sense.\n-fn type_ranges(ranges: &[SpannedRange<&ty::Const>]) -> TypedRanges {\n+fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n     ranges\n         .iter()\n         .filter_map(|range| match range.node {\n             (\n-                &ty::Const {\n-                    val: ConstVal::Integral(start),\n-                    ..\n-                },\n-                Bound::Included(&ty::Const {\n-                    val: ConstVal::Integral(end),\n-                    ..\n-                }),\n+                Constant::Int(start),\n+                Bound::Included(Constant::Int(end)),\n             ) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Included(end)),\n             }),\n             (\n-                &ty::Const {\n-                    val: ConstVal::Integral(start),\n-                    ..\n-                },\n-                Bound::Excluded(&ty::Const {\n-                    val: ConstVal::Integral(end),\n-                    ..\n-                }),\n+                Constant::Int(start),\n+                Bound::Excluded(Constant::Int(end)),\n             ) => Some(SpannedRange {\n                 span: range.span,\n                 node: (start, Bound::Excluded(end)),\n             }),\n             (\n-                &ty::Const {\n-                    val: ConstVal::Integral(start),\n-                    ..\n-                },\n+                Constant::Int(start),\n                 Bound::Unbounded,\n             ) => Some(SpannedRange {\n                 span: range.span,"}, {"sha": "0e55d0f8a3aa9697286c04729148c11a91bb04eb", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,10 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n-use rustc::ty::subst::Substs;\n-use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n use std::iter;\n@@ -16,7 +13,7 @@ use utils::{get_arg_name, get_trait_def_id, implements_trait, in_external_macro,\n             span_lint, span_lint_and_sugg, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::paths;\n use utils::sugg;\n-use utils::const_to_u64;\n+use consts::{constant, Constant};\n \n #[derive(Clone)]\n pub struct Pass;\n@@ -1302,7 +1299,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::TyAdt(..) => match_type(cx, ty, &paths::VEC),\n-            ty::TyArray(_, size) => const_to_u64(size) < 32,\n+            ty::TyArray(_, size) => size.val.to_raw_bits().expect(\"array length\") < 32,\n             ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) => may_slice(cx, inner),\n             _ => false,\n         }\n@@ -1754,14 +1751,7 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n-    let parent_item = cx.tcx.hir.get_parent(arg.id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    if let Ok(&ty::Const {\n-        val: ConstVal::Str(r),\n-        ..\n-    }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg)\n-    {\n+    if let Some((Constant::Str(r), _)) = constant(cx, arg) {\n         if r.len() == 1 {\n             let c = r.chars().next().unwrap();\n             let snip = snippet(cx, expr.span, \"..\");"}, {"sha": "172de7a15a5a95d9f43f7f1cd8a7c95fd80eca06", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 6, "deletions": 58, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -2,18 +2,14 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::intravisit::FnKind;\n use rustc::lint::*;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n-use rustc::ty::subst::Substs;\n-use rustc_const_eval::ConstContext;\n-use rustc_const_math::ConstFloat;\n use syntax::codemap::{ExpnFormat, Span};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_constant, in_macro, is_integer_literal,\n             iter_input_pats, last_path_segment, match_qpath, match_trait_method, paths, snippet, span_lint,\n             span_lint_and_then, walk_ptrs_ty};\n use utils::sugg::Sugg;\n-use syntax::ast::{FloatTy, LitKind, CRATE_NODE_ID};\n-use consts::constant;\n+use syntax::ast::{LitKind, CRATE_NODE_ID};\n+use consts::{constant, Constant};\n \n /// **What it does:** Checks for function arguments and let bindings denoted as\n /// `ref`.\n@@ -457,58 +453,10 @@ fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) ->\n }\n \n fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n-    let parent_item = cx.tcx.hir.get_parent(expr.id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    let res = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(expr);\n-    if let Ok(&ty::Const {\n-        val: ConstVal::Float(val),\n-        ..\n-    }) = res\n-    {\n-        use std::cmp::Ordering;\n-        match val.ty {\n-            FloatTy::F32 => {\n-                let zero = ConstFloat {\n-                    ty: FloatTy::F32,\n-                    bits: u128::from(0.0_f32.to_bits()),\n-                };\n-\n-                let infinity = ConstFloat {\n-                    ty: FloatTy::F32,\n-                    bits: u128::from(::std::f32::INFINITY.to_bits()),\n-                };\n-\n-                let neg_infinity = ConstFloat {\n-                    ty: FloatTy::F32,\n-                    bits: u128::from(::std::f32::NEG_INFINITY.to_bits()),\n-                };\n-\n-                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal)\n-                    || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n-            },\n-            FloatTy::F64 => {\n-                let zero = ConstFloat {\n-                    ty: FloatTy::F64,\n-                    bits: u128::from(0.0_f64.to_bits()),\n-                };\n-\n-                let infinity = ConstFloat {\n-                    ty: FloatTy::F64,\n-                    bits: u128::from(::std::f64::INFINITY.to_bits()),\n-                };\n-\n-                let neg_infinity = ConstFloat {\n-                    ty: FloatTy::F64,\n-                    bits: u128::from(::std::f64::NEG_INFINITY.to_bits()),\n-                };\n-\n-                val.try_cmp(zero) == Ok(Ordering::Equal) || val.try_cmp(infinity) == Ok(Ordering::Equal)\n-                    || val.try_cmp(neg_infinity) == Ok(Ordering::Equal)\n-            },\n-        }\n-    } else {\n-        false\n+    match constant(cx, expr) {\n+        Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n+        Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n+        _ => false,\n     }\n }\n "}, {"sha": "ca9044c6e8b1c1797389061aa3138b37837c6a74", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -205,7 +205,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     let sugg = |db: &mut DiagnosticBuilder| {\n                         if let ty::TypeVariants::TyAdt(ref def, ..) = ty.sty {\n                             if let Some(span) = cx.tcx.hir.span_if_local(def.did) {\n-                                let param_env = ty::ParamEnv::empty(traits::Reveal::UserFacing);\n+                                let param_env = ty::ParamEnv::empty();\n                                 if param_env.can_type_implement_copy(cx.tcx, ty, span).is_ok() {\n                                     db.span_help(span, \"consider marking this type as Copy\");\n                                 }"}, {"sha": "2ac195f555b917675ff8c79993203bc97b277f81", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -47,8 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n     if_chain! {\n         if let ExprLit(ref l) = lit.node;\n-        if let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit));\n-        if let Some(val) = ci.to_u64();\n+        if let Constant::Int(val) = consts::lit_to_constant(&l.node, cx.tables.expr_ty(lit));\n         if val == 1;\n         if cx.tables.expr_ty(exp).is_integral();\n         then {"}, {"sha": "c98df6464d453f05830c35999be464a78bbefe55", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -94,16 +94,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) {\n                 use consts::{constant, Constant};\n-                use rustc_const_math::ConstInt::Usize;\n-                if let Some((Constant::Int(Usize(us)), _)) = constant(cx, &args[1]) {\n-                    if us.as_u64() == 0 {\n-                        span_lint(\n-                            cx,\n-                            ITERATOR_STEP_BY_ZERO,\n-                            expr.span,\n-                            \"Iterator::step_by(0) will panic at runtime\",\n-                        );\n-                    }\n+                if let Some((Constant::Int(0), _)) = constant(cx, &args[1]) {\n+                    span_lint(\n+                        cx,\n+                        ITERATOR_STEP_BY_ZERO,\n+                        expr.span,\n+                        \"Iterator::step_by(0) will panic at runtime\",\n+                    );\n                 }\n             } else if name == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;"}, {"sha": "93ba3f0e8e7d66beacb61bb71d5e89085cdf1d56", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,15 +1,11 @@\n use regex_syntax;\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::ty;\n-use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::ConstContext;\n-use rustc::ty::subst::Substs;\n use std::collections::HashSet;\n use syntax::ast::{LitKind, NodeId, StrStyle};\n use syntax::codemap::{BytePos, Span};\n-use syntax::symbol::InternedString;\n use utils::{is_expn_of, match_def_path, match_type, opt_def_id, paths, span_help_and_lint, span_lint};\n+use consts::{constant, Constant};\n \n /// **What it does:** Checks [regex](https://crates.io/crates/regex) creation\n /// (with `Regex::new`,`RegexBuilder::new` or `RegexSet::new`) for correct\n@@ -141,17 +137,11 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: usize) -> Span {\n     Span::new(start, end, base.ctxt())\n }\n \n-fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<InternedString> {\n-    let parent_item = cx.tcx.hir.get_parent(e.id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    match ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(e) {\n-        Ok(&ty::Const {\n-            val: ConstVal::Str(r),\n-            ..\n-        }) => Some(r),\n+fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<String> {\n+    constant(cx, e).and_then(|(c, _)| match c {\n+        Constant::Str(s) => Some(s),\n         _ => None,\n-    }\n+    })\n }\n \n fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {"}, {"sha": "0e9d8bdfefdec34ecce39502df088693890436d4", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 19, "deletions": 66, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -5,19 +5,18 @@ use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisito\n use rustc::lint::*;\n use rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n use rustc::ty::layout::LayoutOf;\n-use rustc::ty::subst::Substs;\n use rustc_typeck::hir_ty_to_ty;\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n-use syntax::attr::IntType;\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n use utils::{comparisons, higher, in_constant, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n             multispan_sugg, opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint,\n-            span_lint_and_sugg, span_lint_and_then};\n+            span_lint_and_sugg, span_lint_and_then, clip, unsext, sext, int_bits};\n use utils::paths;\n+use consts::{constant, Constant};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -1298,58 +1297,20 @@ fn detect_absurd_comparison<'a, 'tcx>(\n }\n \n fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<ExtremeExpr<'tcx>> {\n-    use rustc::middle::const_val::ConstVal::*;\n-    use rustc_const_math::*;\n-    use rustc_const_eval::*;\n     use types::ExtremeType::*;\n \n     let ty = cx.tables.expr_ty(expr);\n \n-    match ty.sty {\n-        ty::TyBool | ty::TyInt(_) | ty::TyUint(_) => (),\n-        _ => return None,\n-    };\n+    let cv = constant(cx, expr)?.0;\n \n-    let parent_item = cx.tcx.hir.get_parent(expr.id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    let cv = match ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(expr) {\n-        Ok(val) => val,\n-        Err(_) => return None,\n-    };\n+    let which = match (&ty.sty, cv) {\n+        (&ty::TyBool, Constant::Bool(false)) |\n+        (&ty::TyUint(_), Constant::Int(0)) => Minimum,\n+        (&ty::TyInt(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Minimum,\n \n-    let which = match (&ty.sty, cv.val) {\n-        (&ty::TyBool, Bool(false)) |\n-        (&ty::TyInt(IntTy::Isize), Integral(Isize(Is32(::std::i32::MIN)))) |\n-        (&ty::TyInt(IntTy::Isize), Integral(Isize(Is64(::std::i64::MIN)))) |\n-        (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MIN))) |\n-        (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MIN))) |\n-        (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MIN))) |\n-        (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MIN))) |\n-        (&ty::TyInt(IntTy::I128), Integral(I128(::std::i128::MIN))) |\n-        (&ty::TyUint(UintTy::Usize), Integral(Usize(Us32(::std::u32::MIN)))) |\n-        (&ty::TyUint(UintTy::Usize), Integral(Usize(Us64(::std::u64::MIN)))) |\n-        (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MIN))) |\n-        (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MIN))) |\n-        (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MIN))) |\n-        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) |\n-        (&ty::TyUint(UintTy::U128), Integral(U128(::std::u128::MIN))) => Minimum,\n-\n-        (&ty::TyBool, Bool(true)) |\n-        (&ty::TyInt(IntTy::Isize), Integral(Isize(Is32(::std::i32::MAX)))) |\n-        (&ty::TyInt(IntTy::Isize), Integral(Isize(Is64(::std::i64::MAX)))) |\n-        (&ty::TyInt(IntTy::I8), Integral(I8(::std::i8::MAX))) |\n-        (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MAX))) |\n-        (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MAX))) |\n-        (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MAX))) |\n-        (&ty::TyInt(IntTy::I128), Integral(I128(::std::i128::MAX))) |\n-        (&ty::TyUint(UintTy::Usize), Integral(Usize(Us32(::std::u32::MAX)))) |\n-        (&ty::TyUint(UintTy::Usize), Integral(Usize(Us64(::std::u64::MAX)))) |\n-        (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MAX))) |\n-        (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MAX))) |\n-        (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MAX))) |\n-        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MAX))) |\n-        (&ty::TyUint(UintTy::U128), Integral(U128(::std::u128::MAX))) => Maximum,\n+        (&ty::TyBool, Constant::Bool(true)) => Maximum,\n+        (&ty::TyInt(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) => Maximum,\n+        (&ty::TyUint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n \n         _ => return None,\n     };\n@@ -1524,24 +1485,16 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n     }\n }\n \n-#[allow(cast_possible_wrap)]\n fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<FullInt> {\n-    use rustc::middle::const_val::ConstVal::*;\n-    use rustc_const_eval::ConstContext;\n-\n-    let parent_item = cx.tcx.hir.get_parent(expr.id);\n-    let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-    let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    match ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(expr) {\n-        Ok(val) => if let Integral(const_int) = val.val {\n-            match const_int.int_type() {\n-                IntType::SignedInt(_) => Some(FullInt::S(const_int.to_u128_unchecked() as i128)),\n-                IntType::UnsignedInt(_) => Some(FullInt::U(const_int.to_u128_unchecked())),\n-            }\n-        } else {\n-            None\n-        },\n-        Err(_) => None,\n+    let val = constant(cx, expr)?.0;\n+    if let Constant::Int(const_int) = val {\n+        match cx.tables.expr_ty(expr).sty {\n+            ty::TyInt(ity) => Some(FullInt::S(sext(cx.tcx, const_int, ity))),\n+            ty::TyUint(_) => Some(FullInt::U(const_int)),\n+            _ => None,\n+        }\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "b171bdf403058242513c6d0a8d8873a54ea48d78", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::map::Node;\n use rustc::lint::{LateContext, Level, Lint, LintContext};\n use rustc::session::Session;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, layout};\n use rustc_errors;\n use std::borrow::Cow;\n use std::env;\n@@ -276,14 +276,6 @@ pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     }\n }\n \n-pub fn const_to_u64(c: &ty::Const) -> u64 {\n-    c.val\n-        .to_const_int()\n-        .expect(\"eddyb says this works\")\n-        .to_u64()\n-        .expect(\"see previous expect\")\n-}\n-\n /// Convenience function to get the `DefId` of a trait by path.\n pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n     let def = match path_to_def(cx, path) {\n@@ -1071,3 +1063,26 @@ pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n         _ => None,\n     }\n }\n+\n+pub fn int_bits(tcx: TyCtxt, ity: ast::IntTy) -> u64 {\n+    layout::Integer::from_attr(tcx, attr::IntType::SignedInt(ity)).size().bits()\n+}\n+\n+/// Turn a constant int byte representation into an i128\n+pub fn sext(tcx: TyCtxt, u: u128, ity: ast::IntTy) -> i128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as i128) << amt) >> amt\n+}\n+\n+/// clip unused bytes\n+pub fn unsext(tcx: TyCtxt, u: i128, ity: ast::IntTy) -> u128 {\n+    let amt = 128 - int_bits(tcx, ity);\n+    ((u as u128) << amt) >> amt\n+}\n+\n+/// clip unused bytes\n+pub fn clip(tcx: TyCtxt, u: u128, ity: ast::UintTy) -> u128 {\n+    let bits = layout::Integer::from_attr(tcx, attr::IntType::UnsignedInt(ity)).size().bits();\n+    let amt = 128 - bits;\n+    (u << amt) >> amt\n+}"}, {"sha": "4762c730683fd039f898b7e745b5780d76ee909b", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,10 +1,9 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::Substs;\n-use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_sugg};\n+use consts::constant;\n \n /// **What it does:** Checks for usage of `&vec![..]` when using `&[..]` would\n /// be possible.\n@@ -67,13 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_vec_macro<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, vec_args: &higher::VecArgs<'tcx>, span: Span) {\n     let snippet = match *vec_args {\n         higher::VecArgs::Repeat(elem, len) => {\n-            let parent_item = cx.tcx.hir.get_parent(len.id);\n-            let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n-            let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-            if ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables)\n-                .eval(len)\n-                .is_ok()\n-            {\n+            if constant(cx, len).is_some() {\n                 format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\"))\n             } else {\n                 return;"}, {"sha": "416ee155174cccd56c32381a670abd3b5d599e9a", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,4 +1,4 @@\n-use consts::{constant_simple, Constant, FloatWidth};\n+use consts::{constant_simple, Constant};\n use rustc::lint::*;\n use rustc::hir::*;\n use utils::span_help_and_lint;\n@@ -37,16 +37,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            if let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left);\n-            if let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right);\n-            if Ok(0.0) == lhs_value.parse();\n-            if Ok(0.0) == rhs_value.parse();\n+            if let Some(lhs_value) = constant_simple(cx, left);\n+            if let Some(rhs_value) = constant_simple(cx, right);\n+            if Constant::F32(0.0) == lhs_value || Constant::F64(0.0) == lhs_value;\n+            if Constant::F32(0.0) == rhs_value || Constant::F64(0.0) == rhs_value;\n             then {\n                 // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n                 // match the precision of the literals that are given.\n-                let float_type = match (lhs_width, rhs_width) {\n-                    (FloatWidth::F64, _)\n-                    | (_, FloatWidth::F64) => \"f64\",\n+                let float_type = match (lhs_value, rhs_value) {\n+                    (Constant::F64(_), _)\n+                    | (_, Constant::F64(_)) => \"f64\",\n                     _ => \"f32\"\n                 };\n                 span_help_and_lint("}, {"sha": "5757a6ef3904ad08b553a2eab31fab87d9534196", "filename": "tests/ui/builtin-type-shadow.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fbuiltin-type-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fbuiltin-type-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin-type-shadow.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -19,4 +19,4 @@ error[E0308]: mismatched types\n \n error: aborting due to 2 previous errors\n \n-If you want more information on this error, try using \"rustc --explain E0308\"\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "094b7d49cb55321b21ea4129529bc0d792a7a383", "filename": "tests/ui/conf_bad_arg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_bad_arg.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "640b1c5e6101bc09b74b8120a4a006a8f94e1f29", "filename": "tests/ui/conf_bad_toml.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_toml.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_toml.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_bad_toml.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f92b52ec03248824448ae34a53705a39a8579c94", "filename": "tests/ui/conf_bad_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_bad_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_bad_type.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "214226ac2f9646740e4ce54fc667c64ddc08ddc5", "filename": "tests/ui/conf_french_blacklisted_name.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_french_blacklisted_name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_french_blacklisted_name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_french_blacklisted_name.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "10b007b0de0f4ed3fa96158adaa0b327fb9dbe3e", "filename": "tests/ui/conf_path_non_string.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_path_non_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_path_non_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_path_non_string.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "d7ac055c5174c5520ccf10d7806ddaf82934a7b0", "filename": "tests/ui/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconf_unknown_key.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -8,4 +8,4 @@ error[E0658]: compiler plugins are experimental and possibly buggy (see issue #2\n \n error: aborting due to previous error\n \n-If you want more information on this error, try using \"rustc --explain E0658\"\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "df404a1eec3f00a2d9b4803a86ad78b097f7c4f9", "filename": "tests/ui/float_cmp.stderr", "status": "modified", "additions": 2, "deletions": 62, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Ffloat_cmp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Ffloat_cmp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloat_cmp.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -1,70 +1,10 @@\n-error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:43:5\n-   |\n-43 |     ONE == 1f32;\n-   |     ^^^^^^^^^^^ help: consider comparing them within some error: `(ONE - 1f32).abs() < error`\n-   |\n-   = note: `-D float-cmp` implied by `-D warnings`\n-note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:43:5\n-   |\n-43 |     ONE == 1f32;\n-   |     ^^^^^^^^^^^\n-\n-error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:44:5\n-   |\n-44 |     ONE == 1.0 + 0.0;\n-   |     ^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE - (1.0 + 0.0)).abs() < error`\n-   |\n-note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:44:5\n-   |\n-44 |     ONE == 1.0 + 0.0;\n-   |     ^^^^^^^^^^^^^^^^\n-\n-error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:45:5\n-   |\n-45 |     ONE + ONE == ZERO + ONE + ONE;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE + ONE - (ZERO + ONE + ONE)).abs() < error`\n-   |\n-note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:45:5\n-   |\n-45 |     ONE + ONE == ZERO + ONE + ONE;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:46:5\n-   |\n-46 |     ONE != 2.0;\n-   |     ^^^^^^^^^^ help: consider comparing them within some error: `(ONE - 2.0).abs() < error`\n-   |\n-note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:46:5\n-   |\n-46 |     ONE != 2.0;\n-   |     ^^^^^^^^^^\n-\n-error: strict comparison of f32 or f64\n-  --> $DIR/float_cmp.rs:48:5\n-   |\n-48 |     twice(ONE) != ONE;\n-   |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(twice(ONE) - ONE).abs() < error`\n-   |\n-note: std::f32::EPSILON and std::f64::EPSILON are available.\n-  --> $DIR/float_cmp.rs:48:5\n-   |\n-48 |     twice(ONE) != ONE;\n-   |     ^^^^^^^^^^^^^^^^^\n-\n error: strict comparison of f32 or f64\n   --> $DIR/float_cmp.rs:49:5\n    |\n 49 |     ONE as f64 != 2.0;\n    |     ^^^^^^^^^^^^^^^^^ help: consider comparing them within some error: `(ONE as f64 - 2.0).abs() < error`\n    |\n+   = note: `-D float-cmp` implied by `-D warnings`\n note: std::f32::EPSILON and std::f64::EPSILON are available.\n   --> $DIR/float_cmp.rs:49:5\n    |\n@@ -95,5 +35,5 @@ note: std::f32::EPSILON and std::f64::EPSILON are available.\n 57 |     twice(x) != twice(ONE as f64);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "28223563db1999b9f246edc8705cd173f4f3faef", "filename": "tests/ui/op_ref.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fop_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fop_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fop_ref.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -10,5 +10,13 @@ help: use the values directly\n 13 |     let foo = 5 - 6;\n    |\n \n-error: aborting due to previous error\n+error: taken reference of right operand\n+  --> $DIR/op_ref.rs:21:8\n+   |\n+21 |     if b < &a {\n+   |        ^^^^--\n+   |            |\n+   |            help: use the right value directly: `a`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "bc2a70beffd5bf58b023af092773bebe403bb648", "filename": "tests/ui/zero_div_zero.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fzero_div_zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3662ee76abd777ce6fcf1129e9b922415f4c4fd8/tests%2Fui%2Fzero_div_zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fzero_div_zero.stderr?ref=3662ee76abd777ce6fcf1129e9b922415f4c4fd8", "patch": "@@ -13,7 +13,7 @@ error: constant division of 0.0 with 0.0 will always result in NaN\n   |               ^^^^^^^^^\n   |\n   = note: `-D zero-divided-by-zero` implied by `-D warnings`\n-  = help: Consider using `std::f32::NAN` if you would like a constant representing NaN\n+  = help: Consider using `std::f64::NAN` if you would like a constant representing NaN\n \n error: equal expressions as operands to `/`\n  --> $DIR/zero_div_zero.rs:8:19"}]}