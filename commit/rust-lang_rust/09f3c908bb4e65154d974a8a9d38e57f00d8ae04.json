{"sha": "09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjNjOTA4YmI0ZTY1MTU0ZDk3NGE4YTlkMzhlNTdmMDBkOGFlMDQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-30T18:15:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-30T18:15:20Z"}, "message": "Rollup merge of #70950 - nikomatsakis:leak-check-nll-2, r=matthewjasper\n\nextend NLL checker to understand `'empty` combined with universes\n\nThis PR extends the NLL region checker to understand `'empty` combined with universes. In particular, it means that the NLL region checker no longer considers `exists<R2> { forall<R1> { R1: R2 } }` to be provable. This is work towards https://github.com/rust-lang/rust/issues/59490, but we're not all the way there. One thing in particular it does not address is error messages.\n\nThe modifications to the NLL region inference code turned out to be simpler than expected. The main change is to require that if `R1: R2` then `universe(R1) <= universe(R2)`.\n\nThis constraint follows from the region lattice (shown below), because we assume then that `R2` is \"at least\" `empty(Universe(R2))`, and hence if `R1: R2` (i.e., `R1 >= R2` on the lattice) then `R1` must be in some universe that can name `'empty(Universe(R2))`, which requires that `Universe(R1) <= Universe(R2)`.\n\n```\nstatic ----------+-----...------+       (greatest)\n|                |              |\nearly-bound and  |              |\nfree regions     |              |\n|                |              |\nscope regions    |              |\n|                |              |\nempty(root)   placeholder(U1)   |\n|            /                  |\n|           /         placeholder(Un)\nempty(U1) --         /\n|                   /\n...                /\n|                 /\nempty(Un) --------                      (smallest)\n```\n\nI also made what turned out to be a somewhat unrelated change to add a special region to represent `'empty(U0)`, which we use (somewhat hackily) to indicate well-formedness checks in some parts of the compiler. This fixes #68550.\n\nI did some investigation into fixing the error message situation. That's a bit trickier: the existing \"nice region error\" code around placeholders relies on having better error tracing than NLL currently provides, so that it knows (e.g.) that the constraint arose from applying a trait impl and things like that. I feel like I was hoping *not* to do such fine-grained tracing in NLL, and it seems like we...largely...got away with that. I'm not sure yet if we'll have to add more tracing information or if there is some sort of alternative.\n\nIt's worth pointing out though that I've not kind of shifted my opinion on whose job it should be to enforce lifetimes: I tend to think we ought to be moving back towards *something like* the leak-check (just not the one we *had*). If we took that approach, it would actually resolve this aspect of the error message problem, because we would be resolving 'higher-ranked errors' in the trait solver itself, and hence we wouldn't have to thread as much causal information back to the region checker. I think it would also help us with removing the leak check while not breaking some of the existing crates out there.\n\nRegardless, I think it's worth landing this change, because it was relatively simple and it aligns the set of programs that NLL accepts with those that are accepted by the main region checker, and hence should at least *help* us in migration (though I guess we still also have to resolve the existing crates that rely on leak check for coherence).\n\nr? @matthewjasper", "tree": {"sha": "aa32bbb2b635217db09218da0d9d4db872ddfa0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa32bbb2b635217db09218da0d9d4db872ddfa0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeqxW4CRBK7hj4Ov3rIwAAdHIIAFD98qgN/k8ybukCLf6kpzvi\n5V8gf6BflONXc/oIDySurW7kfS9/r6jOgu08UN8KlQx4Q4g8yY7PROABhwGI70B3\n+mHPFcParQf5FBDDZ3GNNpJdlaI9eqzEnFk8AmHmyKHfuGLoclXUObXQ3oe3fmT7\nQdTC7JTyk/bPnZ9HQKw7depa3+7Kw4wv4DG8QcW3BG6B9bcE15qaWmOiq0ryRXsv\nk7D0LqGSXjU5wrQrKnemC7nWhmQsqaXDe89XXmliClCAx4/bepPiXK0eT/DNIKUr\niyBBl69jASy41Ug/BlFJbw4+ItkShpXwkJKuBBV/JExChmvbxYWaS7QnyYC9UO0=\n=HLmy\n-----END PGP SIGNATURE-----\n", "payload": "tree aa32bbb2b635217db09218da0d9d4db872ddfa0b\nparent eece58a8e35c444afba6fa34873bc0244e32cd29\nparent cb9458d3ff7f64c309bc80776d71e4f73705f4ce\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588270520 +0200\ncommitter GitHub <noreply@github.com> 1588270520 +0200\n\nRollup merge of #70950 - nikomatsakis:leak-check-nll-2, r=matthewjasper\n\nextend NLL checker to understand `'empty` combined with universes\n\nThis PR extends the NLL region checker to understand `'empty` combined with universes. In particular, it means that the NLL region checker no longer considers `exists<R2> { forall<R1> { R1: R2 } }` to be provable. This is work towards https://github.com/rust-lang/rust/issues/59490, but we're not all the way there. One thing in particular it does not address is error messages.\n\nThe modifications to the NLL region inference code turned out to be simpler than expected. The main change is to require that if `R1: R2` then `universe(R1) <= universe(R2)`.\n\nThis constraint follows from the region lattice (shown below), because we assume then that `R2` is \"at least\" `empty(Universe(R2))`, and hence if `R1: R2` (i.e., `R1 >= R2` on the lattice) then `R1` must be in some universe that can name `'empty(Universe(R2))`, which requires that `Universe(R1) <= Universe(R2)`.\n\n```\nstatic ----------+-----...------+       (greatest)\n|                |              |\nearly-bound and  |              |\nfree regions     |              |\n|                |              |\nscope regions    |              |\n|                |              |\nempty(root)   placeholder(U1)   |\n|            /                  |\n|           /         placeholder(Un)\nempty(U1) --         /\n|                   /\n...                /\n|                 /\nempty(Un) --------                      (smallest)\n```\n\nI also made what turned out to be a somewhat unrelated change to add a special region to represent `'empty(U0)`, which we use (somewhat hackily) to indicate well-formedness checks in some parts of the compiler. This fixes #68550.\n\nI did some investigation into fixing the error message situation. That's a bit trickier: the existing \"nice region error\" code around placeholders relies on having better error tracing than NLL currently provides, so that it knows (e.g.) that the constraint arose from applying a trait impl and things like that. I feel like I was hoping *not* to do such fine-grained tracing in NLL, and it seems like we...largely...got away with that. I'm not sure yet if we'll have to add more tracing information or if there is some sort of alternative.\n\nIt's worth pointing out though that I've not kind of shifted my opinion on whose job it should be to enforce lifetimes: I tend to think we ought to be moving back towards *something like* the leak-check (just not the one we *had*). If we took that approach, it would actually resolve this aspect of the error message problem, because we would be resolving 'higher-ranked errors' in the trait solver itself, and hence we wouldn't have to thread as much causal information back to the region checker. I think it would also help us with removing the leak check while not breaking some of the existing crates out there.\n\nRegardless, I think it's worth landing this change, because it was relatively simple and it aligns the set of programs that NLL accepts with those that are accepted by the main region checker, and hence should at least *help* us in migration (though I guess we still also have to resolve the existing crates that rely on leak check for coherence).\n\nr? @matthewjasper\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "html_url": "https://github.com/rust-lang/rust/commit/09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eece58a8e35c444afba6fa34873bc0244e32cd29", "url": "https://api.github.com/repos/rust-lang/rust/commits/eece58a8e35c444afba6fa34873bc0244e32cd29", "html_url": "https://github.com/rust-lang/rust/commit/eece58a8e35c444afba6fa34873bc0244e32cd29"}, {"sha": "cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb9458d3ff7f64c309bc80776d71e4f73705f4ce", "html_url": "https://github.com/rust-lang/rust/commit/cb9458d3ff7f64c309bc80776d71e4f73705f4ce"}], "stats": {"total": 626, "additions": 403, "deletions": 223}, "files": [{"sha": "57eaf56f268f86505a86f67ecb7ec0c4cd73d132", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -47,6 +47,11 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     }\n \n     /// Returns an iterator over the SCCs in the graph.\n+    ///\n+    /// The SCCs will be iterated in **dependency order** (or **post order**),\n+    /// meaning that if `S1 -> S2`, we will visit `S2` first and `S1` after.\n+    /// This is convenient when the edges represent dependencies: when you visit\n+    /// `S1`, the value for `S2` will already have been computed.\n     pub fn all_sccs(&self) -> impl Iterator<Item = S> {\n         (0..self.scc_data.len()).map(S::new)\n     }"}, {"sha": "497001d009fe307174daf0a9afe7ff4a4217e32f", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -472,6 +472,9 @@ pub enum NLLRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n+    /// The variable we create to represent `'empty(U0)`.\n+    RootEmptyRegion,\n+\n     Existential {\n         /// If this is true, then this variable was created to represent a lifetime\n         /// bound in a `for` binder. For example, it might have been created to\n@@ -493,6 +496,7 @@ impl NLLRegionVariableOrigin {\n             NLLRegionVariableOrigin::FreeRegion => true,\n             NLLRegionVariableOrigin::Placeholder(..) => true,\n             NLLRegionVariableOrigin::Existential { .. } => false,\n+            NLLRegionVariableOrigin::RootEmptyRegion => false,\n         }\n     }\n "}, {"sha": "fe1138438008685bcd6b83e3642a2be8e32ebef9", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n@@ -315,16 +314,81 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// SCC could have as well. This implies that the SCC must have\n     /// the minimum, or narrowest, universe.\n     fn compute_scc_universes(\n-        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        constraint_sccs: &Sccs<RegionVid, ConstraintSccIndex>,\n         definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n-        let num_sccs = constraints_scc.num_sccs();\n+        let num_sccs = constraint_sccs.num_sccs();\n         let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n \n+        debug!(\"compute_scc_universes()\");\n+\n+        // For each region R in universe U, ensure that the universe for the SCC\n+        // that contains R is \"no bigger\" than U. This effectively sets the universe\n+        // for each SCC to be the minimum of the regions within.\n         for (region_vid, region_definition) in definitions.iter_enumerated() {\n-            let scc = constraints_scc.scc(region_vid);\n+            let scc = constraint_sccs.scc(region_vid);\n             let scc_universe = &mut scc_universes[scc];\n-            *scc_universe = ::std::cmp::min(*scc_universe, region_definition.universe);\n+            let scc_min = std::cmp::min(region_definition.universe, *scc_universe);\n+            if scc_min != *scc_universe {\n+                *scc_universe = scc_min;\n+                debug!(\n+                    \"compute_scc_universes: lowered universe of {scc:?} to {scc_min:?} \\\n+                    because it contains {region_vid:?} in {region_universe:?}\",\n+                    scc = scc,\n+                    scc_min = scc_min,\n+                    region_vid = region_vid,\n+                    region_universe = region_definition.universe,\n+                );\n+            }\n+        }\n+\n+        // Walk each SCC `A` and `B` such that `A: B`\n+        // and ensure that universe(A) can see universe(B).\n+        //\n+        // This serves to enforce the 'empty/placeholder' hierarchy\n+        // (described in more detail on `RegionKind`):\n+        //\n+        // ```\n+        // static -----+\n+        //   |         |\n+        // empty(U0) placeholder(U1)\n+        //   |      /\n+        // empty(U1)\n+        // ```\n+        //\n+        // In particular, imagine we have variables R0 in U0 and R1\n+        // created in U1, and constraints like this;\n+        //\n+        // ```\n+        // R1: !1 // R1 outlives the placeholder in U1\n+        // R1: R0 // R1 outlives R0\n+        // ```\n+        //\n+        // Here, we wish for R1 to be `'static`, because it\n+        // cannot outlive `placeholder(U1)` and `empty(U0)` any other way.\n+        //\n+        // Thanks to this loop, what happens is that the `R1: R0`\n+        // constraint lowers the universe of `R1` to `U0`, which in turn\n+        // means that the `R1: !1` constraint will (later) cause\n+        // `R1` to become `'static`.\n+        for scc_a in constraint_sccs.all_sccs() {\n+            for &scc_b in constraint_sccs.successors(scc_a) {\n+                let scc_universe_a = scc_universes[scc_a];\n+                let scc_universe_b = scc_universes[scc_b];\n+                let scc_universe_min = std::cmp::min(scc_universe_a, scc_universe_b);\n+                if scc_universe_a != scc_universe_min {\n+                    scc_universes[scc_a] = scc_universe_min;\n+\n+                    debug!(\n+                        \"compute_scc_universes: lowered universe of {scc_a:?} to {scc_universe_min:?} \\\n+                        because {scc_a:?}: {scc_b:?} and {scc_b:?} is in universe {scc_universe_b:?}\",\n+                        scc_a = scc_a,\n+                        scc_b = scc_b,\n+                        scc_universe_min = scc_universe_min,\n+                        scc_universe_b = scc_universe_b\n+                    );\n+                }\n+            }\n         }\n \n         debug!(\"compute_scc_universes: scc_universe = {:#?}\", scc_universes);\n@@ -416,7 +480,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -550,47 +615,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut BitSet::new_empty(self.constraint_sccs.num_sccs());\n-        for scc_index in self.constraint_sccs.all_sccs() {\n-            self.propagate_constraint_sccs_if_new(scc_index, visited);\n+        let constraint_sccs = self.constraint_sccs.clone();\n+        for scc in constraint_sccs.all_sccs() {\n+            self.compute_value_for_scc(scc);\n         }\n \n         // Sort the applied member constraints so we can binary search\n         // through them later.\n         self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n-    /// Computes the value of the SCC `scc_a` if it has not already\n-    /// been computed. The `visited` parameter is a bitset\n-    #[inline]\n-    fn propagate_constraint_sccs_if_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n-        if visited.insert(scc_a) {\n-            self.propagate_constraint_sccs_new(scc_a, visited);\n-        }\n-    }\n-\n     /// Computes the value of the SCC `scc_a`, which has not yet been\n-    /// computed. This works by first computing all successors of the\n-    /// SCC (if they haven't been computed already) and then unioning\n-    /// together their elements.\n-    fn propagate_constraint_sccs_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n+    /// computed, by unioning the values of its successors.\n+    /// Assumes that all successors have been computed already\n+    /// (which is assured by iterating over SCCs in dependency order).\n+    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n             debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n-            // ...compute the value of `B`...\n-            self.propagate_constraint_sccs_if_new(scc_b, visited);\n-\n             // ...and add elements from `B` into `A`. One complication\n             // arises because of universes: If `B` contains something\n             // that `A` cannot name, then `A` can only contain `B` if\n@@ -1258,7 +1303,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1360,7 +1406,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1633,9 +1680,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n-                false\n-            }\n+            NLLRegionVariableOrigin::RootEmptyRegion\n+            | NLLRegionVariableOrigin::FreeRegion\n+            | NLLRegionVariableOrigin::Existential { .. } => false,\n         }\n     }\n \n@@ -1773,6 +1820,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        debug!(\"find_sub_region_live_at: {:?} is in scc {:?}\", fr1, self.constraint_sccs.scc(fr1));\n+        debug!(\n+            \"find_sub_region_live_at: {:?} is in universe {:?}\",\n+            fr1,\n+            self.scc_universes[self.constraint_sccs.scc(fr1)]\n+        );\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n             debug!(\n@@ -1794,13 +1847,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         .or_else(|| {\n             // If we fail to find THAT, it may be that `fr1` is a\n             // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // case, there should be some `r` where `fr1: r` and `fr1` is a\n             // placeholder that `r` cannot name. We can blame that\n             // edge.\n+            //\n+            // Remember that if `R1: R2`, then the universe of R1\n+            // must be able to name the universe of R2, because R2 will\n+            // be at least `'empty(Universe(R2))`, and `R1` must be at\n+            // larger than that.\n             self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n+                self.cannot_name_placeholder(r, fr1)\n             })\n         })\n         .map(|(_path, r)| r)\n@@ -1944,7 +2000,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let blame_source = match from_region_origin {\n             NLLRegionVariableOrigin::FreeRegion\n             | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::Placeholder(_)\n+            NLLRegionVariableOrigin::RootEmptyRegion\n+            | NLLRegionVariableOrigin::Placeholder(_)\n             | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n "}, {"sha": "711271a63fbff2c3cd853b37dc6a555207ebc0b7", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -160,10 +160,6 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        // FIXME -- this is not the fix I would prefer\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n-            return;\n-        }\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n         self.add_outlives(b, a);\n@@ -176,10 +172,6 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n-        // FIXME: I'd prefer if NLL had a notion of empty\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n-            return;\n-        }\n         let type_test = self.verify_to_type_test(kind, a, bound);\n         self.add_type_test(type_test);\n     }"}, {"sha": "3003f4639d9fa3806d48b2d32f319f9ee6350e07", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -54,6 +54,13 @@ pub struct UniversalRegions<'tcx> {\n     /// The total number of universal region variables instantiated.\n     num_universals: usize,\n \n+    /// A special region variable created for the `'empty(U0)` region.\n+    /// Note that this is **not** a \"universal\" region, as it doesn't\n+    /// represent a universally bound placeholder or any such thing.\n+    /// But we do create it here in this type because it's a useful region\n+    /// to have around in a few limited cases.\n+    pub root_empty: RegionVid,\n+\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated. For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `FnDef`.\n@@ -317,7 +324,11 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// See `UniversalRegionIndices::to_region_vid`.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        self.indices.to_region_vid(r)\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = r {\n+            self.root_empty\n+        } else {\n+            self.indices.to_region_vid(r)\n+        }\n     }\n \n     /// As part of the NLL unit tests, you can annotate a function with\n@@ -473,10 +484,16 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             _ => None,\n         };\n \n+        let root_empty = self\n+            .infcx\n+            .next_nll_region_var(NLLRegionVariableOrigin::RootEmptyRegion)\n+            .to_region_vid();\n+\n         UniversalRegions {\n             indices,\n             fr_static,\n             fr_fn_body,\n+            root_empty,\n             first_extern_index,\n             first_local_index,\n             num_universals,"}, {"sha": "dcfb069b84aad17a803994a6757006d7f59209c0", "filename": "src/test/mir-opt/nll/named-lifetimes-basic/rustc.use_x.nll.0.mir", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -13,27 +13,28 @@\n | '_#2r | U0 | {bb0[0..=1], '_#2r}\n | '_#3r | U0 | {bb0[0..=1], '_#3r}\n | '_#4r | U0 | {bb0[0..=1], '_#4r}\n-| '_#5r | U0 | {bb0[0..=1], '_#1r}\n-| '_#6r | U0 | {bb0[0..=1], '_#2r}\n-| '_#7r | U0 | {bb0[0..=1], '_#1r}\n-| '_#8r | U0 | {bb0[0..=1], '_#3r}\n+| '_#5r | U0 | {}\n+| '_#6r | U0 | {bb0[0..=1], '_#1r}\n+| '_#7r | U0 | {bb0[0..=1], '_#2r}\n+| '_#8r | U0 | {bb0[0..=1], '_#1r}\n+| '_#9r | U0 | {bb0[0..=1], '_#3r}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=1]}\n | '_#1r live at {bb0[0..=1]}\n | '_#2r live at {bb0[0..=1]}\n | '_#3r live at {bb0[0..=1]}\n | '_#4r live at {bb0[0..=1]}\n-| '_#1r: '_#5r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n-| '_#1r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n-| '_#2r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n-| '_#3r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n-| '_#5r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n-| '_#6r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n-| '_#7r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n-| '_#8r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n+| '_#1r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n+| '_#1r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n+| '_#2r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n+| '_#3r: '_#9r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n+| '_#6r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n+| '_#7r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n+| '_#8r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n+| '_#9r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n |\n-fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {\n+fn use_x(_1: &'_#6r mut i32, _2: &'_#7r u32, _3: &'_#8r u32, _4: &'_#9r u32) -> bool {\n     debug w => _1;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:26: 12:27\n     debug x => _2;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:42: 12:43\n     debug y => _3;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:54: 12:55"}, {"sha": "66d7cda2b85a0b885ba9e52da76a05a11742c81d", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -7,7 +7,9 @@\n \n #![allow(warnings)]\n \n-fn use_x(_: usize) -> bool { true }\n+fn use_x(_: usize) -> bool {\n+    true\n+}\n \n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n // EMIT_MIR rustc.main.nll.0.mir"}, {"sha": "3e0867d9b09d9833c5d9c45ab062b16fc1b5657a", "filename": "src/test/mir-opt/nll/region-subtyping-basic/32bit/rustc.main.nll.0.mir", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -7,164 +7,165 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#1r}\n-| '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n-| '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n-| '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n+| '_#4r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n+| '_#5r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n | '_#1r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n-| '_#2r live at {bb2[0]}\n-| '_#3r live at {bb2[1..=3]}\n-| '_#4r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n-| '_#2r: '_#3r due to Assignment at Single(bb2[0])\n-| '_#3r: '_#4r due to Assignment at Single(bb2[3])\n+| '_#3r live at {bb2[0]}\n+| '_#4r live at {bb2[1..=3]}\n+| '_#5r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#3r: '_#4r due to Assignment at Single(bb2[0])\n+| '_#4r: '_#5r due to Assignment at Single(bb2[3])\n |\n fn main() -> () {\n-    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:14:11: 14:11\n-    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n+    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n     scope 1 {\n-        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n+        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n         scope 2 {\n-            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             scope 3 {\n-                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        _1 = [const Const(Value(Scalar(0x00000001)): usize), const Const(Value(Scalar(0x00000002)): usize), const Const(Value(Scalar(0x00000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:15:17: 15:26\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        _1 = [const Const(Value(Scalar(0x00000001)): usize), const Const(Value(Scalar(0x00000002)): usize), const Const(Value(Scalar(0x00000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:17:17: 17:26\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000001))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:18: 15:19\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:18: 17:19\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000001)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000002))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:21: 15:22\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:21: 17:22\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000003))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:24: 15:25\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:24: 17:25\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n-        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-        _3 = const Const(Value(Scalar(0x00000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n+        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+        _3 = const Const(Value(Scalar(0x00000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000000))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:16:16: 16:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000000)) }\n-        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n+        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     }\n \n     bb1 (cleanup): {\n-        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:14:1: 23:2\n+        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:16:1: 25:2\n     }\n \n     bb2: {\n-        _2 = &'_#2r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:16:13: 16:18\n-        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:17:13: 17:14\n-        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n+        _2 = &'_#3r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:18:13: 18:18\n+        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:19:13: 19:14\n+        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // ty::Const\n                                          // + ty: bool\n                                          // + val: Value(Scalar(0x01))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:8: 18:12\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb3: {\n-        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb4: {\n-        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n-        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x00000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n+        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x00000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:9: 23:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000016))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:15: 21:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:15: 23:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000016)) }\n     }\n \n     bb5: {\n-        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n+        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:19:9: 19:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb6: {\n-        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:17: 19:18\n-        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:18: 19:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:13: 20:6\n+        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:17: 21:18\n+        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:13: 20:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb7: {\n-        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:20:12: 22:6\n+        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:18: 23:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:20:12: 22:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb8: {\n-        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:23:2: 23:2\n+        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:25:2: 25:2\n     }\n }"}, {"sha": "61db4dba5862755a96cb56034295a631fbdd79f9", "filename": "src/test/mir-opt/nll/region-subtyping-basic/64bit/rustc.main.nll.0.mir", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -7,164 +7,165 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#1r}\n-| '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n-| '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n-| '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n+| '_#4r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n+| '_#5r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n | '_#1r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n-| '_#2r live at {bb2[0]}\n-| '_#3r live at {bb2[1..=3]}\n-| '_#4r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n-| '_#2r: '_#3r due to Assignment at Single(bb2[0])\n-| '_#3r: '_#4r due to Assignment at Single(bb2[3])\n+| '_#3r live at {bb2[0]}\n+| '_#4r live at {bb2[1..=3]}\n+| '_#5r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#3r: '_#4r due to Assignment at Single(bb2[0])\n+| '_#4r: '_#5r due to Assignment at Single(bb2[3])\n |\n fn main() -> () {\n-    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:14:11: 14:11\n-    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n+    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n     scope 1 {\n-        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n+        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n         scope 2 {\n-            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             scope 3 {\n-                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        _1 = [const Const(Value(Scalar(0x0000000000000001)): usize), const Const(Value(Scalar(0x0000000000000002)): usize), const Const(Value(Scalar(0x0000000000000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:15:17: 15:26\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        _1 = [const Const(Value(Scalar(0x0000000000000001)): usize), const Const(Value(Scalar(0x0000000000000002)): usize), const Const(Value(Scalar(0x0000000000000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:17:17: 17:26\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000001))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:18: 15:19\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:18: 17:19\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000001)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000002))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:21: 15:22\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:21: 17:22\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000003))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:24: 15:25\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:24: 17:25\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n-        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-        _3 = const Const(Value(Scalar(0x0000000000000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n+        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+        _3 = const Const(Value(Scalar(0x0000000000000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000000))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:16:16: 16:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000000)) }\n-        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n+        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     }\n \n     bb1 (cleanup): {\n-        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:14:1: 23:2\n+        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:16:1: 25:2\n     }\n \n     bb2: {\n-        _2 = &'_#2r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:16:13: 16:18\n-        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:17:13: 17:14\n-        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n+        _2 = &'_#3r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:18:13: 18:18\n+        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:19:13: 19:14\n+        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // ty::Const\n                                          // + ty: bool\n                                          // + val: Value(Scalar(0x01))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:8: 18:12\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb3: {\n-        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb4: {\n-        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n-        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x0000000000000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n+        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x0000000000000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:9: 23:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000016))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:15: 21:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:15: 23:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000016)) }\n     }\n \n     bb5: {\n-        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n+        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:19:9: 19:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb6: {\n-        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:17: 19:18\n-        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:18: 19:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:13: 20:6\n+        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:17: 21:18\n+        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:13: 20:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb7: {\n-        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:20:12: 22:6\n+        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:18: 23:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:20:12: 22:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb8: {\n-        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:23:2: 23:2\n+        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:25:2: 25:2\n     }\n }"}, {"sha": "7799f20d974bcfbb2bf8235b941c8f8c47357262", "filename": "src/test/mir-opt/storage_ranges/rustc.main.nll.0.mir", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -7,15 +7,16 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=22], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=22], '_#1r}\n-| '_#2r | U0 | {bb0[10..=11]}\n-| '_#3r | U0 | {bb0[11]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb0[10..=11]}\n+| '_#4r | U0 | {bb0[11]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=22]}\n | '_#1r live at {bb0[0..=22]}\n-| '_#2r live at {bb0[10]}\n-| '_#3r live at {bb0[11]}\n-| '_#2r: '_#3r due to Assignment at Single(bb0[10])\n+| '_#3r live at {bb0[10]}\n+| '_#4r live at {bb0[11]}\n+| '_#3r: '_#4r due to Assignment at Single(bb0[10])\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/storage_ranges.rs:3:11: 3:11"}, {"sha": "da584e8ad4e0d2dd1907ca5491fd4158073381c9", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -34,7 +34,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-   = note: hidden type `(&u8, &u8)` captures lifetime '_#4r\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#5r\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-no-fg.rs:9:1\n@@ -48,7 +48,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-   = note: hidden type `(&u8, &u8)` captures lifetime '_#5r\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#6r\n \n error: aborting due to 5 previous errors\n "}, {"sha": "90803a0adb01bf8cb1083f1fd396eb2a5aec79d9", "filename": "src/test/ui/hrtb/due-to-where-clause.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -2,7 +2,7 @@ error: higher-ranked subtype error\n   --> $DIR/due-to-where-clause.rs:2:5\n    |\n LL |     test::<FooS>(&mut 42);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "129af80ce4a629616ad632650692cdc115701e20", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#8r\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#9r\n \n error: aborting due to previous error\n "}, {"sha": "de6d5edcae511d9ffd631f7c675ca707c6b05b43", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#5r\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#6r\n \n error: aborting due to previous error\n "}, {"sha": "6bfd18de18c6ae995e7eff2d76910eb0706df8fc", "filename": "src/test/ui/nll/issue-68550.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for issue #68550.\n+//\n+// The `&'static A:` where clause was triggering\n+// ICEs because it wound up being compiled to reference\n+// the `'empty(U0)` region.\n+\n+fn run<'a, A>(x: A)\n+where\n+    A: 'static,\n+    &'static A: ,\n+{\n+    let _: &'a A = &x; //~ ERROR `x` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "e234ebb04e16a5ea874c7482a3cf11da6bc03dd5", "filename": "src/test/ui/nll/issue-68550.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -0,0 +1,16 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-68550.rs:12:20\n+   |\n+LL | fn run<'a, A>(x: A)\n+   |        -- lifetime `'a` defined here\n+...\n+LL |     let _: &'a A = &x;\n+   |            -----   ^^ borrowed value does not live long enough\n+   |            |\n+   |            type annotation requires that `x` is borrowed for `'a`\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "d3964a7f515deee842f9d71fa08a2f93a2fe8dcf", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -0,0 +1,36 @@\n+// Test that the NLL solver cannot find a solution\n+// for `exists<R1> { forall<R1> { R2: R1 } }`.\n+//\n+// In this test, the impl should match `fn(T)` for some `T`,\n+// but we ask it to match `for<'a> fn(&'a ())`. Due to argument\n+// contravariance, this effectively requires a `T = &'b ()` where\n+// `forall<'a> { 'a: 'b }`. Therefore, we get an error.\n+//\n+// Note the use of `-Zno-leak-check` and `feature(nll)` here. These\n+// are presently required in order to skip the leak-check errors.\n+//\n+// c.f. Issue #57642.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+trait Y {\n+    type F;\n+    fn make_f() -> Self::F;\n+}\n+\n+impl<T> Y for fn(T) {\n+    type F = fn(T);\n+\n+    fn make_f() -> Self::F {\n+        |_| {}\n+    }\n+}\n+\n+fn main() {\n+    let _x = <fn(&())>::make_f();\n+    //~^ higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+}"}, {"sha": "70fb877d716899e276f49c13f99fe6f4c8b15bdc", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -0,0 +1,20 @@\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "298a6ef7ab3c5b85551b5621b91a7eed9cce79ca", "filename": "src/test/ui/nll/type-check-pointer-comparisons.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -21,13 +21,13 @@ fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n }\n \n fn compare_hr_fn_ptr<'a>(f: fn(&'a i32), g: fn(&i32)) {\n-    // Ideally this should compile with the operands swapped as well, but HIR\n-    // type checking prevents it (and stops compilation) for now.\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn compare_const_fn_ptr<'a>(f: *const fn(&'a i32), g: *const fn(&i32)) {\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn main() {}"}, {"sha": "0fc7480260fdb96eb7ee83663f1590debb079ff0", "filename": "src/test/ui/nll/type-check-pointer-comparisons.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09f3c908bb4e65154d974a8a9d38e57f00d8ae04/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr?ref=09f3c908bb4e65154d974a8a9d38e57f00d8ae04", "patch": "@@ -76,5 +76,17 @@ LL |     f == g;\n \n help: `'a` and `'b` must be the same: replace one with the other\n \n-error: aborting due to 6 previous errors\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:24:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:29:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: aborting due to 8 previous errors\n "}]}