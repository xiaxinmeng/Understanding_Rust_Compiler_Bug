{"sha": "0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNTI2OTNkYjIxZjQ4YTUxNmY5YTM2Y2RlYjhiMmRkN2UzM2JkMDI=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-28T18:18:09Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-06-29T01:09:02Z"}, "message": "Improve handling of trait bounds on a trait in default methods.\n\nThis is work on #7460.\nIt does not properly handle certain cross crate situations,\nbecause we don't properly export vtable resolution information.", "tree": {"sha": "dda74f26f5d0a6008a52297c462f427d280975a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dda74f26f5d0a6008a52297c462f427d280975a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "html_url": "https://github.com/rust-lang/rust/commit/0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0252693db21f48a516f9a36cdeb8b2dd7e33bd02/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "649b26f7c64a573b2d1ee03a0b866dd351510338", "url": "https://api.github.com/repos/rust-lang/rust/commits/649b26f7c64a573b2d1ee03a0b866dd351510338", "html_url": "https://github.com/rust-lang/rust/commit/649b26f7c64a573b2d1ee03a0b866dd351510338"}], "stats": {"total": 130, "additions": 92, "deletions": 38}, "files": [{"sha": "4c07f88f16eba38b250708c08e63491fc53357e0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 65, "deletions": 31, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/0252693db21f48a516f9a36cdeb8b2dd7e33bd02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0252693db21f48a516f9a36cdeb8b2dd7e33bd02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "patch": "@@ -195,6 +195,58 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n+fn get_impl_resolutions(bcx: block,\n+                        impl_id: ast::def_id)\n+                         -> typeck::vtable_res {\n+    if impl_id.crate == ast::local_crate {\n+        *bcx.ccx().maps.vtable_map.get(&impl_id.node)\n+    } else {\n+        // XXX: This is a temporary hack to work around not properly\n+        // exporting information about resolutions for impls.\n+        // This doesn't actually work if the trait has param bounds,\n+        // but it does allow us to survive the case when it does not.\n+        let trait_ref = ty::impl_trait_ref(bcx.tcx(), impl_id).get();\n+        @vec::from_elem(trait_ref.substs.tps.len(), @~[])\n+    }\n+}\n+\n+fn resolve_default_method_vtables(bcx: block,\n+                                  impl_id: ast::def_id,\n+                                  method: &ty::Method,\n+                                  substs: &ty::substs,\n+                                  impl_vtables: Option<typeck::vtable_res>)\n+                                 -> typeck::vtable_res {\n+\n+    // Get the vtables that the impl implements the trait at\n+    let trait_vtables = get_impl_resolutions(bcx, impl_id);\n+\n+    // Build up a param_substs that we are going to resolve the\n+    // trait_vtables under.\n+    let param_substs = Some(@param_substs {\n+        tys: copy substs.tps,\n+        self_ty: substs.self_ty,\n+        vtables: impl_vtables,\n+        self_vtable: None\n+    });\n+\n+    let trait_vtables_fixed = resolve_vtables_under_param_substs(\n+        bcx.tcx(), param_substs, trait_vtables);\n+\n+    // Now we pull any vtables for parameters on the actual method.\n+    let num_method_vtables = method.generics.type_param_defs.len();\n+    let method_vtables = match impl_vtables {\n+        Some(vtables) => {\n+            let num_impl_type_parameters =\n+                vtables.len() - num_method_vtables;\n+            vtables.tailn(num_impl_type_parameters).to_owned()\n+        },\n+        None => vec::from_elem(num_method_vtables, @~[])\n+    };\n+\n+    @(*trait_vtables_fixed + method_vtables)\n+}\n+\n+\n pub fn trans_fn_ref_with_vtables(\n         bcx: block,            //\n         def_id: ast::def_id,   // def id of fn\n@@ -246,9 +298,9 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (def_id, opt_impl_did, substs, self_vtable) =\n+    let (def_id, opt_impl_did, substs, self_vtable, vtables) =\n         match tcx.provided_method_sources.find(&def_id) {\n-        None => (def_id, None, substs, None),\n+        None => (def_id, None, substs, None, vtables),\n         Some(source) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -282,49 +334,31 @@ pub fn trans_fn_ref_with_vtables(\n             let self_vtable =\n                 typeck::vtable_static(source.impl_id, receiver_substs,\n                                       receiver_vtables);\n-\n-            // XXX: I think that if the *trait* has vtables on it,\n-            // it is all over\n-\n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n                 tcx, source.impl_id, trait_ref, method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n+\n+\n+            let vtables =\n+                resolve_default_method_vtables(bcx, source.impl_id,\n+                                               method, &new_substs, vtables);\n+\n             debug!(\"trans_fn_with_vtables - default method: \\\n                     substs = %s, trait_subst = %s, \\\n-                    first_subst = %s, new_subst = %s\",\n+                    first_subst = %s, new_subst = %s, \\\n+                    self_vtable = %s, vtables = %s\",\n                    substs.repr(tcx), trait_ref.substs.repr(tcx),\n-                   first_subst.repr(tcx), new_substs.repr(tcx));\n-\n+                   first_subst.repr(tcx), new_substs.repr(tcx),\n+                   self_vtable.repr(tcx), vtables.repr(tcx));\n \n             (source.method_id, Some(source.impl_id),\n-             new_substs, Some(self_vtable))\n+             new_substs, Some(self_vtable), Some(vtables))\n         }\n     };\n \n-    // XXX: this is *completely* bad and wrong. I feel bad.  Handling\n-    // of vtables is currently bogus for default methods, and changing\n-    // to an unflattented representation of vtables causes this to\n-    // show up in cases that it did not previously. We need to make\n-    // the vtables list be the same length as the substs.  There is\n-    // nothing right about this. I really need to emphasize just how\n-    // wrong it is: it is completely wrong.\n-    // XXX: bad.\n-    // This will be fixed in the next commit.\n-    let vtables = do vtables.map |vtbls| {\n-        if vtbls.len() < substs.tps.len() {\n-            @(vec::from_elem(substs.tps.len() - vtbls.len(), @~[]) +\n-              **vtbls)\n-        } else if vtbls.len() > substs.tps.len() {\n-            @vtbls.tailn(vtbls.len() - substs.tps.len()).to_owned()\n-        } else {\n-            *vtbls\n-        }\n-    };\n-\n-\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = {"}, {"sha": "653687ea39f912167ee192bb2346ca68c93e6832", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0252693db21f48a516f9a36cdeb8b2dd7e33bd02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0252693db21f48a516f9a36cdeb8b2dd7e33bd02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0252693db21f48a516f9a36cdeb8b2dd7e33bd02", "patch": "@@ -1035,30 +1035,50 @@ pub fn node_vtables(bcx: block, id: ast::node_id)\n \n pub fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n+    resolve_vtables_under_param_substs(fcx.ccx.tcx,\n+                                       fcx.param_substs,\n+                                       vts)\n+}\n+\n+pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n+                                          param_substs: Option<@param_substs>,\n+                                          vts: typeck::vtable_res)\n+    -> typeck::vtable_res {\n     @vec::map(*vts, |ds|\n-      @vec::map(**ds, |d|  resolve_vtable_in_fn_ctxt(fcx, copy *d)))\n+      @vec::map(**ds, |d|\n+                resolve_vtable_under_param_substs(tcx, param_substs, copy *d)))\n }\n \n+\n // Apply the typaram substitutions in the fn_ctxt to a vtable. This should\n // eliminate any vtable_params.\n pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n     -> typeck::vtable_origin {\n-    let tcx = fcx.ccx.tcx;\n+    resolve_vtable_under_param_substs(fcx.ccx.tcx,\n+                                      fcx.param_substs,\n+                                      vt)\n+}\n+\n+pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n+                                         param_substs: Option<@param_substs>,\n+                                         vt: typeck::vtable_origin)\n+    -> typeck::vtable_origin {\n     match vt {\n         typeck::vtable_static(trait_id, tys, sub) => {\n-            let tys = match fcx.param_substs {\n+            let tys = match param_substs {\n                 Some(substs) => {\n                     do vec::map(tys) |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n                     }\n                 }\n                 _ => tys\n             };\n-            typeck::vtable_static(trait_id, tys,\n-                                  resolve_vtables_in_fn_ctxt(fcx, sub))\n+            typeck::vtable_static(\n+                trait_id, tys,\n+                resolve_vtables_under_param_substs(tcx, param_substs, sub))\n         }\n         typeck::vtable_param(n_param, n_bound) => {\n-            match fcx.param_substs {\n+            match param_substs {\n                 Some(substs) => {\n                     find_vtable(tcx, substs, n_param, n_bound)\n                 }\n@@ -1070,7 +1090,7 @@ pub fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n             }\n         }\n         typeck::vtable_self(_trait_id) => {\n-            match fcx.param_substs {\n+            match param_substs {\n                 Some(@param_substs\n                      {self_vtable: Some(ref self_vtable), _}) => {\n                     copy *self_vtable"}]}