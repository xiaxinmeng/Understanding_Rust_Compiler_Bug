{"sha": "936eba3b348e65b658b60218cc9237f02abdbeb4", "node_id": "C_kwDOAAsO6NoAKDkzNmViYTNiMzQ4ZTY1YjY1OGI2MDIxOGNjOTIzN2YwMmFiZGJlYjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T12:45:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-18T12:45:44Z"}, "message": "Auto merge of #96867 - michaelwoerister:path-prefix-fixes-2, r=davidtwco\n\n--remap-path-prefix: Fix duplicated path components in debuginfo\n\nThis PR fixes an issue with `--remap-path-prefix` where path components could appear twice in the remapped version of the path (e.g. https://github.com/rust-lang/rust/issues/78479). The underlying problem was that `--remap-path-prefix` is often used to map an absolute path to something that looks like a relative path, e.g.:\n\n```\n--remap-path-prefix=/home/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823=crates.io\",\n```\n\nand relative paths in debuginfo are interpreted as being relative to the compilation directory. So if Cargo invokes the compiler with `/home/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/some_crate-0.1.0/src/lib.rs` as input and `/home/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/some_crate-0.1.0` as the compiler's working directory, then debuginfo will state that the working directory was `crates.io/some_crate-0.1.0` and the file is question was `crates.io/some_crate-0.1.0/src/lib.rs`, which combined gives the path:\n\n```\ncrates.io/some_crate-0.1.0/crates.io/some_crate-0.1.0/src/lib.rs\n```\n\nWith this PR the compiler will detect this situation and set up debuginfo in LLVM in a way that makes it strip the duplicated path components when emitting DWARF.\n\nThe PR also extracts the logic for making remapped paths absolute into a common helper function that is now used by debuginfo too (instead of just during crate metadata generation).", "tree": {"sha": "170ce02aaa1fca72948775fc8adaccf2952f82e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/170ce02aaa1fca72948775fc8adaccf2952f82e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/936eba3b348e65b658b60218cc9237f02abdbeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/936eba3b348e65b658b60218cc9237f02abdbeb4", "html_url": "https://github.com/rust-lang/rust/commit/936eba3b348e65b658b60218cc9237f02abdbeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/936eba3b348e65b658b60218cc9237f02abdbeb4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5732a21711e7cefa6eb22e1790406b269d6197a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5732a21711e7cefa6eb22e1790406b269d6197a", "html_url": "https://github.com/rust-lang/rust/commit/e5732a21711e7cefa6eb22e1790406b269d6197a"}, {"sha": "6411fef3aba5ba54a02b54b171b4e9bc83687ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6411fef3aba5ba54a02b54b171b4e9bc83687ce9", "html_url": "https://github.com/rust-lang/rust/commit/6411fef3aba5ba54a02b54b171b4e9bc83687ce9"}], "stats": {"total": 660, "additions": 463, "deletions": 197}, "files": [{"sha": "97d3acb34ce75ee360eb4acfd0fd5f2e4a723916", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 95, "deletions": 67, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -36,20 +36,21 @@ use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt, COMMON_VTABLE_ENTRIES};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n+use rustc_span::FileName;\n use rustc_span::FileNameDisplayPreference;\n-use rustc_span::{self, SourceFile, SourceFileHash};\n+use rustc_span::{self, SourceFile};\n use rustc_target::abi::{Align, Size};\n use smallvec::smallvec;\n use tracing::debug;\n \n use libc::{c_longlong, c_uint};\n use std::borrow::Cow;\n-use std::collections::hash_map::Entry;\n use std::fmt::{self, Write};\n use std::hash::{Hash, Hasher};\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::ptr;\n+use tracing::instrument;\n \n impl PartialEq for llvm::Metadata {\n     fn eq(&self, other: &Self) -> bool {\n@@ -527,78 +528,105 @@ fn hex_encode(data: &[u8]) -> String {\n }\n \n pub fn file_metadata<'ll>(cx: &CodegenCx<'ll, '_>, source_file: &SourceFile) -> &'ll DIFile {\n-    debug!(\"file_metadata: file_name: {:?}\", source_file.name);\n-\n-    let hash = Some(&source_file.src_hash);\n-    let file_name = Some(source_file.name.prefer_remapped().to_string());\n-    let directory = if source_file.is_real_file() && !source_file.is_imported() {\n-        Some(\n-            cx.sess()\n-                .opts\n-                .working_dir\n-                .to_string_lossy(FileNameDisplayPreference::Remapped)\n-                .to_string(),\n-        )\n-    } else {\n-        // If the path comes from an upstream crate we assume it has been made\n-        // independent of the compiler's working directory one way or another.\n-        None\n-    };\n-    file_metadata_raw(cx, file_name, directory, hash)\n-}\n-\n-pub fn unknown_file_metadata<'ll>(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n-    file_metadata_raw(cx, None, None, None)\n-}\n-\n-fn file_metadata_raw<'ll>(\n-    cx: &CodegenCx<'ll, '_>,\n-    file_name: Option<String>,\n-    directory: Option<String>,\n-    hash: Option<&SourceFileHash>,\n-) -> &'ll DIFile {\n-    let key = (file_name, directory);\n-\n-    match debug_context(cx).created_files.borrow_mut().entry(key) {\n-        Entry::Occupied(o) => o.get(),\n-        Entry::Vacant(v) => {\n-            let (file_name, directory) = v.key();\n-            debug!(\"file_metadata: file_name: {:?}, directory: {:?}\", file_name, directory);\n-\n-            let file_name = file_name.as_deref().unwrap_or(\"<unknown>\");\n-            let directory = directory.as_deref().unwrap_or(\"\");\n-\n-            let (hash_kind, hash_value) = match hash {\n-                Some(hash) => {\n-                    let kind = match hash.kind {\n-                        rustc_span::SourceFileHashAlgorithm::Md5 => llvm::ChecksumKind::MD5,\n-                        rustc_span::SourceFileHashAlgorithm::Sha1 => llvm::ChecksumKind::SHA1,\n-                        rustc_span::SourceFileHashAlgorithm::Sha256 => llvm::ChecksumKind::SHA256,\n-                    };\n-                    (kind, hex_encode(hash.hash_bytes()))\n+    let cache_key = Some((source_file.name_hash, source_file.src_hash));\n+    return debug_context(cx)\n+        .created_files\n+        .borrow_mut()\n+        .entry(cache_key)\n+        .or_insert_with(|| alloc_new_file_metadata(cx, source_file));\n+\n+    #[instrument(skip(cx, source_file), level = \"debug\")]\n+    fn alloc_new_file_metadata<'ll>(\n+        cx: &CodegenCx<'ll, '_>,\n+        source_file: &SourceFile,\n+    ) -> &'ll DIFile {\n+        debug!(?source_file.name);\n+\n+        let (directory, file_name) = match &source_file.name {\n+            FileName::Real(filename) => {\n+                let working_directory = &cx.sess().opts.working_dir;\n+                debug!(?working_directory);\n+\n+                let filename = cx\n+                    .sess()\n+                    .source_map()\n+                    .path_mapping()\n+                    .to_embeddable_absolute_path(filename.clone(), working_directory);\n+\n+                // Construct the absolute path of the file\n+                let abs_path = filename.remapped_path_if_available();\n+                debug!(?abs_path);\n+\n+                if let Ok(rel_path) =\n+                    abs_path.strip_prefix(working_directory.remapped_path_if_available())\n+                {\n+                    // If the compiler's working directory (which also is the DW_AT_comp_dir of\n+                    // the compilation unit) is a prefix of the path we are about to emit, then\n+                    // only emit the part relative to the working directory.\n+                    // Because of path remapping we sometimes see strange things here: `abs_path`\n+                    // might actually look like a relative path\n+                    // (e.g. `<crate-name-and-version>/src/lib.rs`), so if we emit it without\n+                    // taking the working directory into account, downstream tooling will\n+                    // interpret it as `<working-directory>/<crate-name-and-version>/src/lib.rs`,\n+                    // which makes no sense. Usually in such cases the working directory will also\n+                    // be remapped to `<crate-name-and-version>` or some other prefix of the path\n+                    // we are remapping, so we end up with\n+                    // `<crate-name-and-version>/<crate-name-and-version>/src/lib.rs`.\n+                    // By moving the working directory portion into the `directory` part of the\n+                    // DIFile, we allow LLVM to emit just the relative path for DWARF, while\n+                    // still emitting the correct absolute path for CodeView.\n+                    (\n+                        working_directory.to_string_lossy(FileNameDisplayPreference::Remapped),\n+                        rel_path.to_string_lossy().into_owned(),\n+                    )\n+                } else {\n+                    (\"\".into(), abs_path.to_string_lossy().into_owned())\n                 }\n-                None => (llvm::ChecksumKind::None, String::new()),\n-            };\n+            }\n+            other => (\"\".into(), other.prefer_remapped().to_string_lossy().into_owned()),\n+        };\n \n-            let file_metadata = unsafe {\n-                llvm::LLVMRustDIBuilderCreateFile(\n-                    DIB(cx),\n-                    file_name.as_ptr().cast(),\n-                    file_name.len(),\n-                    directory.as_ptr().cast(),\n-                    directory.len(),\n-                    hash_kind,\n-                    hash_value.as_ptr().cast(),\n-                    hash_value.len(),\n-                )\n-            };\n+        let hash_kind = match source_file.src_hash.kind {\n+            rustc_span::SourceFileHashAlgorithm::Md5 => llvm::ChecksumKind::MD5,\n+            rustc_span::SourceFileHashAlgorithm::Sha1 => llvm::ChecksumKind::SHA1,\n+            rustc_span::SourceFileHashAlgorithm::Sha256 => llvm::ChecksumKind::SHA256,\n+        };\n+        let hash_value = hex_encode(source_file.src_hash.hash_bytes());\n \n-            v.insert(file_metadata);\n-            file_metadata\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateFile(\n+                DIB(cx),\n+                file_name.as_ptr().cast(),\n+                file_name.len(),\n+                directory.as_ptr().cast(),\n+                directory.len(),\n+                hash_kind,\n+                hash_value.as_ptr().cast(),\n+                hash_value.len(),\n+            )\n         }\n     }\n }\n \n+pub fn unknown_file_metadata<'ll>(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n+    debug_context(cx).created_files.borrow_mut().entry(None).or_insert_with(|| unsafe {\n+        let file_name = \"<unknown>\";\n+        let directory = \"\";\n+        let hash_value = \"\";\n+\n+        llvm::LLVMRustDIBuilderCreateFile(\n+            DIB(cx),\n+            file_name.as_ptr().cast(),\n+            file_name.len(),\n+            directory.as_ptr().cast(),\n+            directory.len(),\n+            llvm::ChecksumKind::None,\n+            hash_value.as_ptr().cast(),\n+            hash_value.len(),\n+        )\n+    })\n+}\n+\n trait MsvcBasicName {\n     fn msvc_basic_name(self) -> &'static str;\n }"}, {"sha": "0910e7c94ea122579c798737a16e7d42983f1e25", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TypeFoldable};\n use rustc_session::config::{self, DebugInfo};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, Span};\n+use rustc_span::{self, BytePos, Pos, SourceFile, SourceFileAndLine, SourceFileHash, Span};\n use rustc_target::abi::Size;\n \n use libc::c_uint;\n@@ -61,7 +61,7 @@ pub struct CodegenUnitDebugContext<'ll, 'tcx> {\n     llcontext: &'ll llvm::Context,\n     llmod: &'ll llvm::Module,\n     builder: &'ll mut DIBuilder<'ll>,\n-    created_files: RefCell<FxHashMap<(Option<String>, Option<String>), &'ll DIFile>>,\n+    created_files: RefCell<FxHashMap<Option<(u128, SourceFileHash)>, &'ll DIFile>>,\n \n     type_map: metadata::TypeMap<'ll, 'tcx>,\n     namespace_map: RefCell<DefIdMap<&'ll DIScope>>,"}, {"sha": "086f1bd94b6c01475946e23f91b2422931289852", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 36, "deletions": 64, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -33,18 +33,14 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n+use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{\n     self, DebuggerVisualizerFile, ExternalSource, FileName, SourceFile, Span, SyntaxContext,\n };\n-use rustc_span::{\n-    hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind},\n-    RealFileName,\n-};\n use rustc_target::abi::VariantIdx;\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n-use std::path::Path;\n use tracing::{debug, trace};\n \n pub(super) struct EncodeContext<'a, 'tcx> {\n@@ -490,6 +486,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // is done.\n         let required_source_files = self.required_source_files.take().unwrap();\n \n+        let working_directory = &self.tcx.sess.opts.working_dir;\n+\n         let adapted = all_source_files\n             .iter()\n             .enumerate()\n@@ -502,76 +500,50 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 (!source_file.is_imported() || self.is_proc_macro)\n             })\n             .map(|(_, source_file)| {\n-                let mut adapted = match source_file.name {\n-                    FileName::Real(ref realname) => {\n-                        let mut adapted = (**source_file).clone();\n-                        adapted.name = FileName::Real(match realname {\n-                            RealFileName::LocalPath(path_to_file) => {\n-                                // Prepend path of working directory onto potentially\n-                                // relative paths, because they could become relative\n-                                // to a wrong directory.\n-                                // We include `working_dir` as part of the crate hash,\n-                                // so it's okay for us to use it as part of the encoded\n-                                // metadata.\n-                                let working_dir = &self.tcx.sess.opts.working_dir;\n-                                match working_dir {\n-                                    RealFileName::LocalPath(absolute) => {\n-                                        // Although neither working_dir or the file name were subject\n-                                        // to path remapping, the concatenation between the two may\n-                                        // be. Hence we need to do a remapping here.\n-                                        let joined = Path::new(absolute).join(path_to_file);\n-                                        let (joined, remapped) =\n-                                            source_map.path_mapping().map_prefix(joined);\n-                                        if remapped {\n-                                            RealFileName::Remapped {\n-                                                local_path: None,\n-                                                virtual_name: joined,\n-                                            }\n-                                        } else {\n-                                            RealFileName::LocalPath(joined)\n-                                        }\n-                                    }\n-                                    RealFileName::Remapped { local_path: _, virtual_name } => {\n-                                        // If working_dir has been remapped, then we emit\n-                                        // Remapped variant as the expanded path won't be valid\n-                                        RealFileName::Remapped {\n-                                            local_path: None,\n-                                            virtual_name: Path::new(virtual_name)\n-                                                .join(path_to_file),\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            RealFileName::Remapped { local_path: _, virtual_name } => {\n-                                RealFileName::Remapped {\n-                                    // We do not want any local path to be exported into metadata\n-                                    local_path: None,\n-                                    virtual_name: virtual_name.clone(),\n-                                }\n-                            }\n-                        });\n-                        adapted.name_hash = {\n-                            let mut hasher: StableHasher = StableHasher::new();\n-                            adapted.name.hash(&mut hasher);\n-                            hasher.finish::<u128>()\n-                        };\n-                        Lrc::new(adapted)\n+                // At export time we expand all source file paths to absolute paths because\n+                // downstream compilation sessions can have a different compiler working\n+                // directory, so relative paths from this or any other upstream crate\n+                // won't be valid anymore.\n+                //\n+                // At this point we also erase the actual on-disk path and only keep\n+                // the remapped version -- as is necessary for reproducible builds.\n+                match source_file.name {\n+                    FileName::Real(ref original_file_name) => {\n+                        let adapted_file_name =\n+                            source_map.path_mapping().to_embeddable_absolute_path(\n+                                original_file_name.clone(),\n+                                working_directory,\n+                            );\n+\n+                        if adapted_file_name != *original_file_name {\n+                            let mut adapted: SourceFile = (**source_file).clone();\n+                            adapted.name = FileName::Real(adapted_file_name);\n+                            adapted.name_hash = {\n+                                let mut hasher: StableHasher = StableHasher::new();\n+                                adapted.name.hash(&mut hasher);\n+                                hasher.finish::<u128>()\n+                            };\n+                            Lrc::new(adapted)\n+                        } else {\n+                            // Nothing to adapt\n+                            source_file.clone()\n+                        }\n                     }\n-\n                     // expanded code, not from a file\n                     _ => source_file.clone(),\n-                };\n-\n+                }\n+            })\n+            .map(|mut source_file| {\n                 // We're serializing this `SourceFile` into our crate metadata,\n                 // so mark it as coming from this crate.\n                 // This also ensures that we don't try to deserialize the\n                 // `CrateNum` for a proc-macro dependency - since proc macro\n                 // dependencies aren't loaded when we deserialize a proc-macro,\n                 // trying to remap the `CrateNum` would fail.\n                 if self.is_proc_macro {\n-                    Lrc::make_mut(&mut adapted).cnum = LOCAL_CRATE;\n+                    Lrc::make_mut(&mut source_file).cnum = LOCAL_CRATE;\n                 }\n-                adapted\n+                source_file\n             })\n             .collect::<Vec<_>>();\n "}, {"sha": "1f4578c08a3f2443d6eb02d8171318f2f9692d24", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -335,8 +335,8 @@ impl fmt::Display for FileNameDisplay<'_> {\n     }\n }\n \n-impl FileNameDisplay<'_> {\n-    pub fn to_string_lossy(&self) -> Cow<'_, str> {\n+impl<'a> FileNameDisplay<'a> {\n+    pub fn to_string_lossy(&self) -> Cow<'a, str> {\n         match self.inner {\n             FileName::Real(ref inner) => inner.to_string_lossy(self.display_pref),\n             _ => Cow::from(format!(\"{}\", self)),\n@@ -1153,7 +1153,7 @@ impl FromStr for SourceFileHashAlgorithm {\n }\n \n /// The hash of the on-disk source file used for debug info.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n #[derive(HashStable_Generic, Encodable, Decodable)]\n pub struct SourceFileHash {\n     pub kind: SourceFileHashAlgorithm,"}, {"sha": "020ae3ad0c78cf438c1f12f1571a7733c9afa5bf", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 115, "deletions": 19, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -1098,28 +1098,45 @@ impl FilePathMapping {\n     /// The return value is the remapped path and a boolean indicating whether\n     /// the path was affected by the mapping.\n     pub fn map_prefix(&self, path: PathBuf) -> (PathBuf, bool) {\n-        // NOTE: We are iterating over the mapping entries from last to first\n-        //       because entries specified later on the command line should\n-        //       take precedence.\n-        for &(ref from, ref to) in self.mapping.iter().rev() {\n-            if let Ok(rest) = path.strip_prefix(from) {\n-                let remapped = if rest.as_os_str().is_empty() {\n-                    // This is subtle, joining an empty path onto e.g. `foo/bar` will\n-                    // result in `foo/bar/`, that is, there'll be an additional directory\n-                    // separator at the end. This can lead to duplicated directory separators\n-                    // in remapped paths down the line.\n-                    // So, if we have an exact match, we just return that without a call\n-                    // to `Path::join()`.\n-                    to.clone()\n-                } else {\n-                    to.join(rest)\n-                };\n+        if path.as_os_str().is_empty() {\n+            // Exit early if the path is empty and therefore there's nothing to remap.\n+            // This is mostly to reduce spam for `RUSTC_LOG=[remap_path_prefix]`.\n+            return (path, false);\n+        }\n \n-                return (remapped, true);\n+        return remap_path_prefix(&self.mapping, path);\n+\n+        #[instrument(level = \"debug\", skip(mapping))]\n+        fn remap_path_prefix(mapping: &[(PathBuf, PathBuf)], path: PathBuf) -> (PathBuf, bool) {\n+            // NOTE: We are iterating over the mapping entries from last to first\n+            //       because entries specified later on the command line should\n+            //       take precedence.\n+            for &(ref from, ref to) in mapping.iter().rev() {\n+                debug!(\"Trying to apply {:?} => {:?}\", from, to);\n+\n+                if let Ok(rest) = path.strip_prefix(from) {\n+                    let remapped = if rest.as_os_str().is_empty() {\n+                        // This is subtle, joining an empty path onto e.g. `foo/bar` will\n+                        // result in `foo/bar/`, that is, there'll be an additional directory\n+                        // separator at the end. This can lead to duplicated directory separators\n+                        // in remapped paths down the line.\n+                        // So, if we have an exact match, we just return that without a call\n+                        // to `Path::join()`.\n+                        to.clone()\n+                    } else {\n+                        to.join(rest)\n+                    };\n+                    debug!(\"Match - remapped {:?} => {:?}\", path, remapped);\n+\n+                    return (remapped, true);\n+                } else {\n+                    debug!(\"No match - prefix {:?} does not match {:?}\", from, path);\n+                }\n             }\n-        }\n \n-        (path, false)\n+            debug!(\"Path {:?} was not remapped\", path);\n+            (path, false)\n+        }\n     }\n \n     fn map_filename_prefix(&self, file: &FileName) -> (FileName, bool) {\n@@ -1140,4 +1157,83 @@ impl FilePathMapping {\n             other => (other.clone(), false),\n         }\n     }\n+\n+    /// Expand a relative path to an absolute path with remapping taken into account.\n+    /// Use this when absolute paths are required (e.g. debuginfo or crate metadata).\n+    ///\n+    /// The resulting `RealFileName` will have its `local_path` portion erased if\n+    /// possible (i.e. if there's also a remapped path).\n+    pub fn to_embeddable_absolute_path(\n+        &self,\n+        file_path: RealFileName,\n+        working_directory: &RealFileName,\n+    ) -> RealFileName {\n+        match file_path {\n+            // Anything that's already remapped we don't modify, except for erasing\n+            // the `local_path` portion.\n+            RealFileName::Remapped { local_path: _, virtual_name } => {\n+                RealFileName::Remapped {\n+                    // We do not want any local path to be exported into metadata\n+                    local_path: None,\n+                    // We use the remapped name verbatim, even if it looks like a relative\n+                    // path. The assumption is that the user doesn't want us to further\n+                    // process paths that have gone through remapping.\n+                    virtual_name,\n+                }\n+            }\n+\n+            RealFileName::LocalPath(unmapped_file_path) => {\n+                // If no remapping has been applied yet, try to do so\n+                let (new_path, was_remapped) = self.map_prefix(unmapped_file_path);\n+                if was_remapped {\n+                    // It was remapped, so don't modify further\n+                    return RealFileName::Remapped { local_path: None, virtual_name: new_path };\n+                }\n+\n+                if new_path.is_absolute() {\n+                    // No remapping has applied to this path and it is absolute,\n+                    // so the working directory cannot influence it either, so\n+                    // we are done.\n+                    return RealFileName::LocalPath(new_path);\n+                }\n+\n+                debug_assert!(new_path.is_relative());\n+                let unmapped_file_path_rel = new_path;\n+\n+                match working_directory {\n+                    RealFileName::LocalPath(unmapped_working_dir_abs) => {\n+                        let file_path_abs = unmapped_working_dir_abs.join(unmapped_file_path_rel);\n+\n+                        // Although neither `working_directory` nor the file name were subject\n+                        // to path remapping, the concatenation between the two may be. Hence\n+                        // we need to do a remapping here.\n+                        let (file_path_abs, was_remapped) = self.map_prefix(file_path_abs);\n+                        if was_remapped {\n+                            RealFileName::Remapped {\n+                                // Erase the actual path\n+                                local_path: None,\n+                                virtual_name: file_path_abs,\n+                            }\n+                        } else {\n+                            // No kind of remapping applied to this path, so\n+                            // we leave it as it is.\n+                            RealFileName::LocalPath(file_path_abs)\n+                        }\n+                    }\n+                    RealFileName::Remapped {\n+                        local_path: _,\n+                        virtual_name: remapped_working_dir_abs,\n+                    } => {\n+                        // If working_directory has been remapped, then we emit\n+                        // Remapped variant as the expanded path won't be valid\n+                        RealFileName::Remapped {\n+                            local_path: None,\n+                            virtual_name: Path::new(remapped_working_dir_abs)\n+                                .join(unmapped_file_path_rel),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "be827cea8744b6f90f8ce9ffb487160a9d08f391", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 128, "deletions": 41, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -313,82 +313,169 @@ impl SourceMapExtension for SourceMap {\n     }\n }\n \n-fn map_path_prefix(mapping: &FilePathMapping, path: &str) -> String {\n+// Takes a unix-style path and returns a platform specific path.\n+fn path(p: &str) -> PathBuf {\n+    path_str(p).into()\n+}\n+\n+// Takes a unix-style path and returns a platform specific path.\n+fn path_str(p: &str) -> String {\n+    #[cfg(not(windows))]\n+    {\n+        return p.into();\n+    }\n+\n+    #[cfg(windows)]\n+    {\n+        let mut path = p.replace('/', \"\\\\\");\n+        if let Some(rest) = path.strip_prefix('\\\\') {\n+            path = [\"X:\\\\\", rest].concat();\n+        }\n+\n+        path\n+    }\n+}\n+\n+fn map_path_prefix(mapping: &FilePathMapping, p: &str) -> String {\n     // It's important that we convert to a string here because that's what\n     // later stages do too (e.g. in the backend), and comparing `Path` values\n     // won't catch some differences at the string level, e.g. \"abc\" and \"abc/\"\n     // compare as equal.\n-    mapping.map_prefix(path.into()).0.to_string_lossy().to_string()\n+    mapping.map_prefix(path(p)).0.to_string_lossy().to_string()\n }\n \n-#[cfg(unix)]\n #[test]\n fn path_prefix_remapping() {\n     // Relative to relative\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"abc/def\".into(), \"foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"abc/def\"), path(\"foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), \"foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc/def\"), \"foo\");\n+        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), path_str(\"foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"abc/def\"), path_str(\"foo\"));\n     }\n \n     // Relative to absolute\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"abc/def\".into(), \"/foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"abc/def\"), path(\"/foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), \"/foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc/def\"), \"/foo\");\n+        assert_eq!(map_path_prefix(mapping, \"abc/def/src/main.rs\"), path_str(\"/foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"abc/def\"), path_str(\"/foo\"));\n     }\n \n     // Absolute to relative\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"/abc/def\".into(), \"foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"/abc/def\"), path(\"foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), \"foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), \"foo\");\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), path_str(\"foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), path_str(\"foo\"));\n     }\n \n     // Absolute to absolute\n     {\n-        let mapping = &FilePathMapping::new(vec![(\"/abc/def\".into(), \"/foo\".into())]);\n+        let mapping = &FilePathMapping::new(vec![(path(\"/abc/def\"), path(\"/foo\"))]);\n \n-        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), \"/foo/src/main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), \"/foo\");\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def/src/main.rs\"), path_str(\"/foo/src/main.rs\"));\n+        assert_eq!(map_path_prefix(mapping, \"/abc/def\"), path_str(\"/foo\"));\n     }\n }\n \n-#[cfg(windows)]\n #[test]\n-fn path_prefix_remapping_from_relative2() {\n-    // Relative to relative\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"abc\\\\def\".into(), \"foo\".into())]);\n+fn path_prefix_remapping_expand_to_absolute() {\n+    // \"virtual\" working directory is relative path\n+    let mapping =\n+        &FilePathMapping::new(vec![(path(\"/foo\"), path(\"FOO\")), (path(\"/bar\"), path(\"BAR\"))]);\n+    let working_directory = path(\"/foo\");\n+    let working_directory = RealFileName::Remapped {\n+        local_path: Some(working_directory.clone()),\n+        virtual_name: mapping.map_prefix(working_directory).0,\n+    };\n+\n+    assert_eq!(working_directory.remapped_path_if_available(), path(\"FOO\"));\n+\n+    // Unmapped absolute path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/foo/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\\\\src\\\\main.rs\"), \"foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\"), \"foo\");\n-    }\n+    // Unmapped absolute path with unrelated working directory\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/bar/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"BAR/src/main.rs\") }\n+    );\n \n-    // Relative to absolute\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"abc\\\\def\".into(), \"X:\\\\foo\".into())]);\n+    // Unmapped absolute path that does not match any prefix\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"/quux/src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::LocalPath(path(\"/quux/src/main.rs\")),\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\\\\src\\\\main.rs\"), \"X:\\\\foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"abc\\\\def\"), \"X:\\\\foo\");\n-    }\n+    // Unmapped relative path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-    // Absolute to relative\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"X:\\\\abc\\\\def\".into(), \"foo\".into())]);\n+    // Unmapped relative path with `./`\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"./src/main.rs\")),\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\\\\src\\\\main.rs\"), \"foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\"), \"foo\");\n-    }\n+    // Unmapped relative path that does not match any prefix\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::LocalPath(path(\"quux/src/main.rs\")),\n+            &RealFileName::LocalPath(path(\"/abc\")),\n+        ),\n+        RealFileName::LocalPath(path(\"/abc/quux/src/main.rs\")),\n+    );\n \n-    // Absolute to absolute\n-    {\n-        let mapping = &FilePathMapping::new(vec![(\"X:\\\\abc\\\\def\".into(), \"X:\\\\foo\".into())]);\n+    // Already remapped absolute path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped {\n+                local_path: Some(path(\"/foo/src/main.rs\")),\n+                virtual_name: path(\"FOO/src/main.rs\"),\n+            },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"FOO/src/main.rs\") }\n+    );\n \n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\\\\src\\\\main.rs\"), \"X:\\\\foo\\\\src\\\\main.rs\");\n-        assert_eq!(map_path_prefix(mapping, \"X:\\\\abc\\\\def\"), \"X:\\\\foo\");\n-    }\n+    // Already remapped absolute path, with unrelated working directory\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped {\n+                local_path: Some(path(\"/bar/src/main.rs\")),\n+                virtual_name: path(\"BAR/src/main.rs\"),\n+            },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"BAR/src/main.rs\") }\n+    );\n+\n+    // Already remapped relative path\n+    assert_eq!(\n+        mapping.to_embeddable_absolute_path(\n+            RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") },\n+            &working_directory\n+        ),\n+        RealFileName::Remapped { local_path: None, virtual_name: path(\"XYZ/src/main.rs\") }\n+    );\n }"}, {"sha": "16727f4398dff5c425fe9aaff6472beca5a0b0c2", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -2047,6 +2047,7 @@ impl Step for RustDev {\n             \"llvm-cov\",\n             \"llvm-dwp\",\n             \"llvm-nm\",\n+            \"llvm-dwarfdump\",\n         ] {\n             tarball.add_file(src_bindir.join(exe(bin, target)), \"bin\", 0o755);\n         }"}, {"sha": "381f11ff1efcc0265fef35d44600c28a503e2918", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -22,7 +22,7 @@ fn main() {\n }\n \n // Here we check that local debuginfo is mapped correctly.\n-// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd\"\n+// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"\"\n \n // And here that debuginfo from other crates are expanded to absolute paths.\n // CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\""}, {"sha": "561a343d60b947368d82c5c5d1b78277cfeb23ab", "filename": "src/test/run-make/remap-path-prefix-dwarf/Makefile", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2FMakefile?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -0,0 +1,77 @@\n+# This test makes sure that --remap-path-prefix has the expected effects on paths in debuginfo.\n+# It tests several cases, each of them has a detailed description attached to it.\n+\n+# ignore-windows\n+\n+SRC_DIR := $(abspath .)\n+SRC_DIR_PARENT := $(abspath ..)\n+\n+-include ../../run-make-fulldeps/tools.mk\n+\n+all: \\\n+  abs_input_outside_working_dir \\\n+  rel_input_remap_working_dir \\\n+  rel_input_remap_working_dir_parent \\\n+  rel_input_remap_working_dir_child \\\n+  abs_input_inside_working_dir \\\n+  abs_input_outside_working_dir\n+\n+# The compiler is called with an *ABSOLUTE PATH* as input, and that absolute path *is* within\n+# the working directory of the compiler. We are remapping the path that contains `src`.\n+abs_input_inside_working_dir:\n+\t# We explicitly switch to a directory that *is* a prefix of the directory our\n+\t# source code is contained in.\n+\tcd $(SRC_DIR) && $(RUSTC) $(SRC_DIR)/src/quux.rs -o \"$(TMPDIR)/abs_input_inside_working_dir.rlib\" -Cdebuginfo=2 --remap-path-prefix $(SRC_DIR)=REMAPPED\n+\t# We expect the path to the main source file to be remapped.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump $(TMPDIR)/abs_input_inside_working_dir.rlib | $(CGREP) \"REMAPPED/src/quux.rs\"\n+\t# No weird duplication of remapped components (see #78479)\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump $(TMPDIR)/abs_input_inside_working_dir.rlib | $(CGREP) -v \"REMAPPED/REMAPPED\"\n+\n+# The compiler is called with an *ABSOLUTE PATH* as input, and that absolute path is *not* within\n+# the working directory of the compiler. We are remapping both the path that contains `src` and\n+# the working directory to the same thing. This setup corresponds to a workaround that is needed\n+# when trying to remap everything to something that looks like a local path.\n+# Relative paths are interpreted as relative to the compiler's working directory (e.g. in\n+# debuginfo). If we also remap the working directory, the compiler strip it from other paths so\n+# that the final outcome is the desired one again.\n+abs_input_outside_working_dir:\n+\t# We explicitly switch to a directory that is *not* a prefix of the directory our\n+\t# source code is contained in.\n+\tcd $(TMPDIR) && $(RUSTC) $(SRC_DIR)/src/quux.rs -o \"$(TMPDIR)/abs_input_outside_working_dir.rlib\" -Cdebuginfo=2 --remap-path-prefix $(SRC_DIR)=REMAPPED --remap-path-prefix $(TMPDIR)=REMAPPED\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump $(TMPDIR)/abs_input_outside_working_dir.rlib | $(CGREP) \"REMAPPED/src/quux.rs\"\n+\t# No weird duplication of remapped components (see #78479)\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump $(TMPDIR)/abs_input_outside_working_dir.rlib | $(CGREP) -v \"REMAPPED/REMAPPED\"\n+\n+# The compiler is called with a *RELATIVE PATH* as input. We are remapping the working directory of\n+# the compiler, which naturally is an implicit prefix of our relative input path. Debuginfo will\n+# expand the relative path to an absolute path and we expect the working directory to be remapped\n+# in that expansion.\n+rel_input_remap_working_dir:\n+\tcd $(SRC_DIR) && $(RUSTC) src/quux.rs -o \"$(TMPDIR)/rel_input_remap_working_dir.rlib\" -Cdebuginfo=2 --remap-path-prefix \"$(SRC_DIR)=REMAPPED\"\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir.rlib\" | $(CGREP) \"REMAPPED/src/quux.rs\"\n+\t# No weird duplication of remapped components (see #78479)\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir.rlib\" | $(CGREP) -v \"REMAPPED/REMAPPED\"\n+\n+# The compiler is called with a *RELATIVE PATH* as input. We are remapping a *SUB-DIRECTORY* of the\n+# compiler's working directory. This test makes sure that that directory is remapped even though it\n+# won't actually show up in this form in the compiler's SourceMap and instead is only constructed\n+# on demand during debuginfo generation.\n+rel_input_remap_working_dir_child:\n+\tcd $(SRC_DIR) && $(RUSTC) src/quux.rs -o \"$(TMPDIR)/rel_input_remap_working_dir_child.rlib\" -Cdebuginfo=2 --remap-path-prefix \"$(SRC_DIR)/src=REMAPPED\"\n+\t# We expect `src/quux.rs` to have been remapped to `REMAPPED/quux.rs`.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_child.rlib\" | $(CGREP) \"REMAPPED/quux.rs\"\n+\t# We don't want to find the path that we just remapped anywhere in the DWARF\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_child.rlib\" | $(CGREP) -v \"$(SRC_DIR)/src\"\n+\t# No weird duplication of remapped components (see #78479)\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_child.rlib\" | $(CGREP) -v \"REMAPPED/REMAPPED\"\n+\n+# The compiler is called with a *RELATIVE PATH* as input. We are remapping a *PARENT DIRECTORY* of\n+# the compiler's working directory.\n+rel_input_remap_working_dir_parent:\n+\tcd $(SRC_DIR) && $(RUSTC) src/quux.rs -o \"$(TMPDIR)/rel_input_remap_working_dir_parent.rlib\" -Cdebuginfo=2 --remap-path-prefix \"$(SRC_DIR_PARENT)=REMAPPED\"\n+\t# We expect `src/quux.rs` to have been remapped to `REMAPPED/remap-path-prefix-dwarf/src/quux.rs`.\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_parent.rlib\" | $(CGREP) \"REMAPPED/remap-path-prefix-dwarf/src/quux.rs\"\n+\t# We don't want to find the path that we just remapped anywhere in the DWARF\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_parent.rlib\" | $(CGREP) -v \"$(SRC_DIR_PARENT)\"\n+\t# No weird duplication of remapped components (see #78479)\n+\t\"$(LLVM_BIN_DIR)\"/llvm-dwarfdump \"$(TMPDIR)/rel_input_remap_working_dir_parent.rlib\" | $(CGREP) -v \"REMAPPED/REMAPPED\""}, {"sha": "38d5ef6194cd210e197a193f4edc7f4f1314c25c", "filename": "src/test/run-make/remap-path-prefix-dwarf/src/quux.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2Fsrc%2Fquux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936eba3b348e65b658b60218cc9237f02abdbeb4/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2Fsrc%2Fquux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fremap-path-prefix-dwarf%2Fsrc%2Fquux.rs?ref=936eba3b348e65b658b60218cc9237f02abdbeb4", "patch": "@@ -0,0 +1,5 @@\n+#![crate_type = \"rlib\"]\n+\n+pub fn foo() {\n+    println!(\"foo\");\n+}"}]}