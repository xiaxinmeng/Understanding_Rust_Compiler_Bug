{"sha": "1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYjZkMGI0ODVhY2M1ZjZlMGQ5ZjliMDk0NjAwMGJjZTEyZjViZmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-11T08:00:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-11T22:16:00Z"}, "message": "Remove `Interner<T>` and rename `StrInterner` to `Interner`.", "tree": {"sha": "6e9133cd328816c9c03bc1bc854c7bf74d202232", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e9133cd328816c9c03bc1bc854c7bf74d202232"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "html_url": "https://github.com/rust-lang/rust/commit/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8a934e971fdef496e69e82ab0e7166363efd3f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a934e971fdef496e69e82ab0e7166363efd3f5", "html_url": "https://github.com/rust-lang/rust/commit/f8a934e971fdef496e69e82ab0e7166363efd3f5"}], "stats": {"total": 165, "additions": 21, "deletions": 144}, "files": [{"sha": "6dfd340a3fb4ee8619f787f2a7b595442a61582e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "patch": "@@ -450,7 +450,7 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n                                   struct_field_family_to_visibility(ff))\n         }).chain(reader::tagged_docs(doc, tag_item_unnamed_field).map(|f| {\n             let ff = item_family(f);\n-            let name = intr.intern(&index.to_string());\n+            let name = intr.intern(index.to_string());\n             index += 1;\n             ty::FieldDefData::new(item_def_id(f, cdata), name,\n                                   struct_field_family_to_visibility(ff))\n@@ -1187,7 +1187,7 @@ pub fn get_struct_field_names(intr: &IdentInterner, cdata: Cmd, id: DefIndex)\n     reader::tagged_docs(item, tag_item_field).map(|an_item| {\n         item_name(intr, an_item)\n     }).chain(reader::tagged_docs(item, tag_item_unnamed_field).map(|_| {\n-        let name = intr.intern(&index.to_string());\n+        let name = intr.intern(index.to_string());\n         index += 1;\n         name\n     })).collect()"}, {"sha": "46813d957dce3b58c5b4268592497aed9ce7aefc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "patch": "@@ -81,7 +81,7 @@ pub struct UniqueTypeId(ast::Name);\n // UniqueTypeIds.\n pub struct TypeMap<'tcx> {\n     // The UniqueTypeIds created so far\n-    unique_id_interner: Interner<Rc<String>>,\n+    unique_id_interner: Interner,\n     // A map from UniqueTypeId to debuginfo metadata for that type. This is a 1:1 mapping.\n     unique_id_to_metadata: FnvHashMap<UniqueTypeId, DIType>,\n     // A map from types to debuginfo metadata. This is a N:1 mapping.\n@@ -313,7 +313,7 @@ impl<'tcx> TypeMap<'tcx> {\n         // Trim to size before storing permanently\n         unique_type_id.shrink_to_fit();\n \n-        let key = self.unique_id_interner.intern(Rc::new(unique_type_id));\n+        let key = self.unique_id_interner.intern(unique_type_id);\n         self.type_to_unique_id.insert(type_, UniqueTypeId(key));\n \n         return UniqueTypeId(key);\n@@ -383,7 +383,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n-        let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n+        let interner_key = self.unique_id_interner.intern(enum_variant_type_id);\n         UniqueTypeId(interner_key)\n     }\n }"}, {"sha": "222cf65b78ee31a7bdd1299187179dac0a2dbb78", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "patch": "@@ -17,7 +17,7 @@ pub use self::Token::*;\n use ast::{self, BinOpKind};\n use ext::mtwt;\n use ptr::P;\n-use util::interner::StrInterner;\n+use util::interner::Interner;\n use tokenstream;\n \n use serialize::{Decodable, Decoder, Encodable, Encoder};\n@@ -396,7 +396,7 @@ macro_rules! declare_keywords {(\n     }\n \n     fn mk_fresh_ident_interner() -> IdentInterner {\n-        StrInterner::prefill(&[$($string,)*])\n+        Interner::prefill(&[$($string,)*])\n     }\n }}\n \n@@ -472,7 +472,7 @@ declare_keywords! {\n }\n \n // looks like we can get rid of this completely...\n-pub type IdentInterner = StrInterner;\n+pub type IdentInterner = Interner;\n \n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one."}, {"sha": "2dd69c769587119084a85871253e528d31092a2f", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 13, "deletions": 136, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=1eb6d0b485acc5f6e0d9f9b0946000bce12f5bfc", "patch": "@@ -17,122 +17,45 @@ use ast::Name;\n use std::borrow::Borrow;\n use std::cell::RefCell;\n use std::collections::HashMap;\n-use std::hash::Hash;\n use std::rc::Rc;\n \n-pub struct Interner<T> {\n-    map: RefCell<HashMap<T, Name>>,\n-    vect: RefCell<Vec<T> >,\n-}\n-\n-// when traits can extend traits, we should extend index<Name,T> to get []\n-impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n-    pub fn new() -> Interner<T> {\n-        Interner {\n-            map: RefCell::new(HashMap::new()),\n-            vect: RefCell::new(Vec::new()),\n-        }\n-    }\n-\n-    pub fn prefill(init: &[T]) -> Interner<T> {\n-        let rv = Interner::new();\n-        for v in init {\n-            rv.intern((*v).clone());\n-        }\n-        rv\n-    }\n-\n-    pub fn intern(&self, val: T) -> Name {\n-        let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = (*map).get(&val) {\n-            return idx;\n-        }\n-\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        (*map).insert(val.clone(), new_idx);\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn gensym(&self, val: T) -> Name {\n-        let mut vect = self.vect.borrow_mut();\n-        let new_idx = Name((*vect).len() as u32);\n-        // leave out of .map to avoid colliding\n-        (*vect).push(val);\n-        new_idx\n-    }\n-\n-    pub fn get(&self, idx: Name) -> T {\n-        let vect = self.vect.borrow();\n-        (*vect)[idx.0 as usize].clone()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        let vect = self.vect.borrow();\n-        (*vect).len()\n-    }\n-\n-    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n-    where T: Borrow<Q>, Q: Eq + Hash {\n-        let map = self.map.borrow();\n-        match (*map).get(val) {\n-            Some(v) => Some(*v),\n-            None => None,\n-        }\n-    }\n-\n-    pub fn clear(&self) {\n-        *self.map.borrow_mut() = HashMap::new();\n-        *self.vect.borrow_mut() = Vec::new();\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq, Eq, Hash)]\n struct RcStr(Rc<String>);\n \n-impl RcStr {\n-    fn new(string: &str) -> Self {\n-        RcStr(Rc::new(string.to_owned()))\n-    }\n-}\n-\n impl Borrow<str> for RcStr {\n     fn borrow(&self) -> &str {\n         &self.0\n     }\n }\n \n-/// A StrInterner differs from Interner<String> in that it accepts\n-/// &str rather than RcStr, resulting in less allocation.\n-pub struct StrInterner {\n+pub struct Interner {\n     map: RefCell<HashMap<RcStr, Name>>,\n     vect: RefCell<Vec<Rc<String>> >,\n }\n \n /// When traits can extend traits, we should extend index<Name,T> to get []\n-impl StrInterner {\n-    pub fn new() -> StrInterner {\n-        StrInterner {\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner {\n             map: RefCell::new(HashMap::new()),\n             vect: RefCell::new(Vec::new()),\n         }\n     }\n \n-    pub fn prefill(init: &[&str]) -> StrInterner {\n-        let rv = StrInterner::new();\n+    pub fn prefill(init: &[&str]) -> Self {\n+        let rv = Interner::new();\n         for &v in init { rv.intern(v); }\n         rv\n     }\n \n-    pub fn intern(&self, val: &str) -> Name {\n+    pub fn intern<T: Borrow<str> + Into<String>>(&self, val: T) -> Name {\n         let mut map = self.map.borrow_mut();\n-        if let Some(&idx) = map.get(val) {\n+        if let Some(&idx) = map.get(val.borrow()) {\n             return idx;\n         }\n \n         let new_idx = Name(self.len() as u32);\n-        let val = Rc::new(val.to_owned());\n+        let val = Rc::new(val.into());\n         map.insert(RcStr(val.clone()), new_idx);\n         self.vect.borrow_mut().push(val);\n         new_idx\n@@ -181,7 +104,7 @@ impl StrInterner {\n         *self.vect.borrow_mut() = Vec::new();\n     }\n \n-    pub fn reset(&self, other: StrInterner) {\n+    pub fn reset(&self, other: Interner) {\n         *self.map.borrow_mut() = other.map.into_inner();\n         *self.vect.borrow_mut() = other.vect.into_inner();\n     }\n@@ -190,57 +113,11 @@ impl StrInterner {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use super::RcStr;\n     use ast::Name;\n \n     #[test]\n-    #[should_panic]\n-    fn i1 () {\n-        let i : Interner<RcStr> = Interner::new();\n-        i.get(Name(13));\n-    }\n-\n-    #[test]\n-    fn interner_tests () {\n-        let i : Interner<RcStr> = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        assert_eq!(i.intern(RcStr::new(\"cat\")), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(RcStr::new(\"dog\")), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(RcStr::new(\"zebra\") ), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym (RcStr::new(\"zebra\") ), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(RcStr::new(\"dog\")), Name(4));\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"dog\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"cat\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(3)), RcStr::new(\"zebra\"));\n-        assert_eq!(i.get(Name(4)), RcStr::new(\"dog\"));\n-    }\n-\n-    #[test]\n-    fn i3 () {\n-        let i : Interner<RcStr> = Interner::prefill(&[\n-            RcStr::new(\"Alan\"),\n-            RcStr::new(\"Bob\"),\n-            RcStr::new(\"Carol\")\n-        ]);\n-        assert_eq!(i.get(Name(0)), RcStr::new(\"Alan\"));\n-        assert_eq!(i.get(Name(1)), RcStr::new(\"Bob\"));\n-        assert_eq!(i.get(Name(2)), RcStr::new(\"Carol\"));\n-        assert_eq!(i.intern(RcStr::new(\"Bob\")), Name(1));\n-    }\n-\n-    #[test]\n-    fn string_interner_tests() {\n-        let i : StrInterner = StrInterner::new();\n+    fn interner_tests() {\n+        let i : Interner = Interner::new();\n         // first one is zero:\n         assert_eq!(i.intern(\"dog\"), Name(0));\n         // re-use gets the same entry:"}]}