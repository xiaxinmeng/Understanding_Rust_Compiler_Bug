{"sha": "95ff52f06fce389f2d5634c8b15916419cd876a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZmY1MmYwNmZjZTM4OWYyZDU2MzRjOGIxNTkxNjQxOWNkODc2YTg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T03:35:16Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-22T06:41:38Z"}, "message": "Tabbed/Inherit indent for chains works even without a newline after first item.", "tree": {"sha": "00f86c7fad8475d4d77195e3640c712c732dbb88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00f86c7fad8475d4d77195e3640c712c732dbb88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95ff52f06fce389f2d5634c8b15916419cd876a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95ff52f06fce389f2d5634c8b15916419cd876a8", "html_url": "https://github.com/rust-lang/rust/commit/95ff52f06fce389f2d5634c8b15916419cd876a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95ff52f06fce389f2d5634c8b15916419cd876a8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d46532e72a693b0ca9100b7ba9f721e4daaff31", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d46532e72a693b0ca9100b7ba9f721e4daaff31", "html_url": "https://github.com/rust-lang/rust/commit/3d46532e72a693b0ca9100b7ba9f721e4daaff31"}], "stats": {"total": 84, "additions": 48, "deletions": 36}, "files": [{"sha": "5d2ce8fedf79fd8ecd18207d18de2f97820e97ca", "filename": "src/chains.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/95ff52f06fce389f2d5634c8b15916419cd876a8/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ff52f06fce389f2d5634c8b15916419cd876a8/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=95ff52f06fce389f2d5634c8b15916419cd876a8", "patch": "@@ -118,14 +118,16 @@ pub fn rewrite_chain(expr: &ast::Expr,\n     // put the first non-parent item on the same line as the parent.\n     let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n                               parent_rewrite.len() <= context.config.tab_spaces {\n-        // Try and put the whole chain on one line.\n-        (offset + Indent::new(0, parent_rewrite.len()), true)\n+        // Try and put at least the first two items on the same line.\n+        (chain_indent(context, offset + Indent::new(0, parent_rewrite.len())), true)\n     } else if is_block_expr(parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n         (parent_block_indent, false)\n+    } else if parent_rewrite.contains('\\n') {\n+        (chain_indent(context, parent_block_indent.block_indent(context.config)), false)\n     } else {\n-        (chain_indent(context, offset), false)\n+        (hacked_chain_indent(context, offset + Indent::new(0, parent_rewrite.len())), false)\n     };\n \n     let max_width = try_opt!((width + offset.width()).checked_sub(indent.width()));\n@@ -204,38 +206,6 @@ pub fn rewrite_chain(expr: &ast::Expr,\n              offset)\n }\n \n-fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n-                                     last: &mut String,\n-                                     almost_total: usize,\n-                                     width: usize,\n-                                     total_span: Span,\n-                                     context: &RewriteContext,\n-                                     offset: Indent)\n-                                     -> bool {\n-    if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n-        let budget = match width.checked_sub(almost_total) {\n-            Some(b) => b,\n-            None => return false,\n-        };\n-        let mut last_rewrite = rewrite_method_call(method_name.node,\n-                                                   types,\n-                                                   expressions,\n-                                                   total_span,\n-                                                   context,\n-                                                   budget,\n-                                                   offset + almost_total);\n-\n-        if let Some(ref mut s) = last_rewrite {\n-            ::std::mem::swap(s, last);\n-            true\n-        } else {\n-            false\n-        }\n-    } else {\n-        unreachable!();\n-    }\n-}\n-\n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n@@ -290,9 +260,51 @@ fn chain_base_indent(context: &RewriteContext, offset: Indent) -> Indent {\n \n fn chain_indent(context: &RewriteContext, offset: Indent) -> Indent {\n     match context.config.chain_indent {\n+        BlockIndentStyle::Visual => offset,\n         BlockIndentStyle::Inherit => context.block_indent,\n         BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n-        BlockIndentStyle::Visual => offset + Indent::new(context.config.tab_spaces, 0),\n+    }\n+}\n+\n+// Temporary hack - ignores visual indenting because this function should be\n+// called where it is not possible to use visual indentation.\n+fn hacked_chain_indent(context: &RewriteContext, _offset: Indent) -> Indent {\n+    match context.config.chain_indent {\n+        BlockIndentStyle::Inherit => context.block_indent,\n+        BlockIndentStyle::Visual |\n+        BlockIndentStyle::Tabbed => context.block_indent.block_indent(context.config),\n+    }\n+}\n+\n+fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n+                                     last: &mut String,\n+                                     almost_total: usize,\n+                                     width: usize,\n+                                     total_span: Span,\n+                                     context: &RewriteContext,\n+                                     offset: Indent)\n+                                     -> bool {\n+    if let &ast::ExprKind::MethodCall(ref method_name, ref types, ref expressions) = expr_kind {\n+        let budget = match width.checked_sub(almost_total) {\n+            Some(b) => b,\n+            None => return false,\n+        };\n+        let mut last_rewrite = rewrite_method_call(method_name.node,\n+                                                   types,\n+                                                   expressions,\n+                                                   total_span,\n+                                                   context,\n+                                                   budget,\n+                                                   offset + almost_total);\n+\n+        if let Some(ref mut s) = last_rewrite {\n+            ::std::mem::swap(s, last);\n+            true\n+        } else {\n+            false\n+        }\n+    } else {\n+        unreachable!();\n     }\n }\n "}]}