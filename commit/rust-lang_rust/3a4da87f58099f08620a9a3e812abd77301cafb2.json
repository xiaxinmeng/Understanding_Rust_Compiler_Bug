{"sha": "3a4da87f58099f08620a9a3e812abd77301cafb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNGRhODdmNTgwOTlmMDg2MjBhOWEzZTgxMmFiZDc3MzAxY2FmYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-24T10:29:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-24T10:29:14Z"}, "message": "Auto merge of #77049 - lcnr:const-eval-function-signature, r=oli-obk\n\nconst_evaluatable_checked: extend predicate collection\n\nWe now walk the hir instead of using `ty` so that we get better spans here, While I am still not completely sure if that's\nwhat we want in the end, it does seem a lot closer to the final goal than the previous version.\n\nWe also look into type aliases (and use a `TypeVisitor` here), about which I am not completely sure, but we will see how well this works.\n\nWe also look into fn decls, so the following should work now.\n```rust\nfn test<T>() -> [u8; std::mem::size_of::<T>()] {\n    [0; std::mem::size_of::<T>()]\n}\n```\nAdditionally, we visit the optional trait and self type of impls.\n\nr? `@oli-obk`", "tree": {"sha": "6159733c14fd9c85f9ba72955c7cdf0768a0c61f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6159733c14fd9c85f9ba72955c7cdf0768a0c61f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a4da87f58099f08620a9a3e812abd77301cafb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a4da87f58099f08620a9a3e812abd77301cafb2", "html_url": "https://github.com/rust-lang/rust/commit/3a4da87f58099f08620a9a3e812abd77301cafb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a4da87f58099f08620a9a3e812abd77301cafb2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86b4172305bb28612510db9ad3ebf2a4bb86f70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b4172305bb28612510db9ad3ebf2a4bb86f70f", "html_url": "https://github.com/rust-lang/rust/commit/86b4172305bb28612510db9ad3ebf2a4bb86f70f"}, {"sha": "21edd10dc5ae8cde041f84a38fd0c4a44a36965d", "url": "https://api.github.com/repos/rust-lang/rust/commits/21edd10dc5ae8cde041f84a38fd0c4a44a36965d", "html_url": "https://github.com/rust-lang/rust/commit/21edd10dc5ae8cde041f84a38fd0c4a44a36965d"}], "stats": {"total": 287, "additions": 206, "deletions": 81}, "files": [{"sha": "909cd2aa1551ec3bd93f7393a4da20c961334ffb", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -7,8 +7,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_span::Span;\n-use std::rc::Rc;\n \n+use std::iter;\n+use std::rc::Rc;\n /// Returns the set of obligations needed to make `arg` well-formed.\n /// If `arg` contains unresolved inference variables, this may include\n /// further WF obligations. However, if `arg` IS an unresolved\n@@ -616,13 +617,24 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.infcx.tcx.predicates_of(def_id).instantiate(self.infcx.tcx, substs);\n+        let predicates = self.infcx.tcx.predicates_of(def_id);\n+        let mut origins = vec![def_id; predicates.predicates.len()];\n+        let mut head = predicates;\n+        while let Some(parent) = head.parent {\n+            head = self.infcx.tcx.predicates_of(parent);\n+            origins.extend(iter::repeat(parent).take(head.predicates.len()));\n+        }\n+\n+        let predicates = predicates.instantiate(self.infcx.tcx, substs);\n+        debug_assert_eq!(predicates.predicates.len(), origins.len());\n+\n         predicates\n             .predicates\n             .into_iter()\n             .zip(predicates.spans.into_iter())\n-            .map(|(pred, span)| {\n-                let cause = self.cause(traits::BindingObligation(def_id, span));\n+            .zip(origins.into_iter().rev())\n+            .map(|((pred, span), origin_def_id)| {\n+                let cause = self.cause(traits::BindingObligation(origin_def_id, span));\n                 traits::Obligation::new(cause, self.param_env, pred)\n             })\n             .filter(|pred| !pred.has_escaping_bound_vars())"}, {"sha": "a571bd58abc34706a3b9908c2b6bc9efb5097abf", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 106, "deletions": 71, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -37,12 +37,11 @@ use rustc_middle::hir::map::Map;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate, WithConstness};\n-use rustc_middle::ty::{TypeFoldable, TypeVisitor};\n use rustc_session::config::SanitizerSet;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -51,8 +50,6 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n \n-use smallvec::SmallVec;\n-\n mod type_of;\n \n struct OnlySelfBounds(bool);\n@@ -1676,47 +1673,10 @@ fn predicates_defined_on(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicate\n         }\n     }\n \n-    if tcx.features().const_evaluatable_checked {\n-        let const_evaluatable = const_evaluatable_predicates_of(tcx, def_id, &result);\n-        result.predicates =\n-            tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(const_evaluatable));\n-    }\n-\n     debug!(\"predicates_defined_on({:?}) = {:?}\", def_id, result);\n     result\n }\n \n-pub fn const_evaluatable_predicates_of<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-    predicates: &ty::GenericPredicates<'tcx>,\n-) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n-    #[derive(Default)]\n-    struct ConstCollector<'tcx> {\n-        ct: SmallVec<[(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>, Span); 4]>,\n-        curr_span: Span,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for ConstCollector<'tcx> {\n-        fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n-            if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n-                self.ct.push((def, substs, self.curr_span));\n-            }\n-            false\n-        }\n-    }\n-\n-    let mut collector = ConstCollector::default();\n-    for &(pred, span) in predicates.predicates.iter() {\n-        collector.curr_span = span;\n-        pred.visit_with(&mut collector);\n-    }\n-    warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.ct);\n-    collector.ct.into_iter().map(move |(def_id, subst, span)| {\n-        (ty::PredicateAtom::ConstEvaluatable(def_id, subst).to_predicate(tcx), span)\n-    })\n-}\n-\n /// Returns a list of all type predicates (explicit and implicit) for the definition with\n /// ID `def_id`. This includes all predicates returned by `predicates_defined_on`, plus\n /// `Self: Trait` predicates for traits.\n@@ -1754,29 +1714,6 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     debug!(\"explicit_predicates_of(def_id={:?})\", def_id);\n \n-    /// A data structure with unique elements, which preserves order of insertion.\n-    /// Preserving the order of insertion is important here so as not to break\n-    /// compile-fail UI tests.\n-    struct UniquePredicates<'tcx> {\n-        predicates: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n-    }\n-\n-    impl<'tcx> UniquePredicates<'tcx> {\n-        fn new() -> Self {\n-            UniquePredicates { predicates: FxIndexSet::default() }\n-        }\n-\n-        fn push(&mut self, value: (ty::Predicate<'tcx>, Span)) {\n-            self.predicates.insert(value);\n-        }\n-\n-        fn extend<I: IntoIterator<Item = (ty::Predicate<'tcx>, Span)>>(&mut self, iter: I) {\n-            for value in iter {\n-                self.push(value);\n-            }\n-        }\n-    }\n-\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n@@ -1789,7 +1726,10 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     const NO_GENERICS: &hir::Generics<'_> = &hir::Generics::empty();\n \n-    let mut predicates = UniquePredicates::new();\n+    // We use an `IndexSet` to preserves order of insertion.\n+    // Preserving the order of insertion is important here so as not to break\n+    // compile-fail UI tests.\n+    let mut predicates: FxIndexSet<(ty::Predicate<'_>, Span)> = FxIndexSet::default();\n \n     let ast_generics = match node {\n         Node::TraitItem(item) => {\n@@ -1891,7 +1831,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // (see below). Recall that a default impl is not itself an impl, but rather a\n     // set of defaults that can be incorporated into another impl.\n     if let Some(trait_ref) = is_default_impl_trait {\n-        predicates.push((\n+        predicates.insert((\n             trait_ref.to_poly_trait_ref().without_const().to_predicate(tcx),\n             tcx.def_span(def_id),\n         ));\n@@ -1915,7 +1855,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = AstConv::ast_region_to_region(&icx, &lt, None);\n                         let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n-                        predicates.push((outlives.to_predicate(tcx), lt.span));\n+                        predicates.insert((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n                 });\n@@ -1970,7 +1910,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n-                        predicates.push((\n+                        predicates.insert((\n                             ty::PredicateAtom::TypeOutlives(predicate)\n                                 .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n@@ -2014,11 +1954,11 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n-                            predicates.push((\n+                            predicates.insert((\n                                 ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n                                     .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n-                            ))\n+                            ));\n                         }\n                     }\n                 }\n@@ -2063,7 +2003,11 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }))\n     }\n \n-    let mut predicates: Vec<_> = predicates.predicates.into_iter().collect();\n+    if tcx.features().const_evaluatable_checked {\n+        predicates.extend(const_evaluatable_predicates_of(tcx, def_id.expect_local()));\n+    }\n+\n+    let mut predicates: Vec<_> = predicates.into_iter().collect();\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n@@ -2089,6 +2033,97 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     result\n }\n \n+fn const_evaluatable_predicates_of<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> FxIndexSet<(ty::Predicate<'tcx>, Span)> {\n+    struct ConstCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        preds: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n+    }\n+\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstCollector<'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+            let def_id = self.tcx.hir().local_def_id(c.hir_id);\n+            let ct = ty::Const::from_anon_const(self.tcx, def_id);\n+            if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n+                let span = self.tcx.hir().span(c.hir_id);\n+                self.preds.insert((\n+                    ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                    span,\n+                ));\n+            }\n+        }\n+\n+        // Look into `TyAlias`.\n+        fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n+            use ty::fold::{TypeFoldable, TypeVisitor};\n+            struct TyAliasVisitor<'a, 'tcx> {\n+                tcx: TyCtxt<'tcx>,\n+                preds: &'a mut FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n+                span: Span,\n+            }\n+\n+            impl<'a, 'tcx> TypeVisitor<'tcx> for TyAliasVisitor<'a, 'tcx> {\n+                fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> bool {\n+                    if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n+                        self.preds.insert((\n+                            ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                            self.span,\n+                        ));\n+                    }\n+                    false\n+                }\n+            }\n+\n+            if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ty.kind {\n+                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n+                    let mut visitor =\n+                        TyAliasVisitor { tcx: self.tcx, preds: &mut self.preds, span: path.span };\n+                    self.tcx.type_of(def_id).visit_with(&mut visitor);\n+                }\n+            }\n+\n+            intravisit::walk_ty(self, ty)\n+        }\n+    }\n+\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(hir_id);\n+\n+    let mut collector = ConstCollector { tcx, preds: FxIndexSet::default() };\n+    if let hir::Node::Item(item) = node {\n+        if let hir::ItemKind::Impl { ref of_trait, ref self_ty, .. } = item.kind {\n+            if let Some(of_trait) = of_trait {\n+                warn!(\"const_evaluatable_predicates_of({:?}): visit impl trait_ref\", def_id);\n+                collector.visit_trait_ref(of_trait);\n+            }\n+\n+            warn!(\"const_evaluatable_predicates_of({:?}): visit_self_ty\", def_id);\n+            collector.visit_ty(self_ty);\n+        }\n+    }\n+\n+    if let Some(generics) = node.generics() {\n+        warn!(\"const_evaluatable_predicates_of({:?}): visit_generics\", def_id);\n+        collector.visit_generics(generics);\n+    }\n+\n+    if let Some(fn_sig) = tcx.hir().fn_sig_by_hir_id(hir_id) {\n+        warn!(\"const_evaluatable_predicates_of({:?}): visit_fn_decl\", def_id);\n+        collector.visit_fn_decl(fn_sig.decl);\n+    }\n+    warn!(\"const_evaluatable_predicates_of({:?}) = {:?}\", def_id, collector.preds);\n+\n+    collector.preds\n+}\n+\n fn projection_ty_from_predicates(\n     tcx: TyCtxt<'tcx>,\n     key: ("}, {"sha": "52b89cfa0458866698188b1fd6745b54a3008af2", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -8,6 +8,7 @@ fn user<T>() {\n     //~^ ERROR constant expression depends\n     //~| ERROR constant expression depends\n     //~| ERROR constant expression depends\n+    //~| ERROR constant expression depends\n }\n \n fn main() {}"}, {"sha": "4af68118be31fda7ff6c53d2ec9a430ae8417982", "filename": "src/test/ui/const-generics/const_evaluatable_checked/cross_crate_predicate.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fcross_crate_predicate.stderr?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -4,10 +4,23 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1`\n+   |          ---------------------------- required by this bound in `test1`\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/cross_crate_predicate.rs:7:13\n+   |\n+LL |     let _ = const_evaluatable_lib::test1::<T>();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | \n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n+   |\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ---------------------------- required by this bound in `test1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n@@ -17,10 +30,10 @@ error: constant expression depends on a generic parameter\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    | \n-  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:41\n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:6:10\n    |\n LL |     [u8; std::mem::size_of::<T>() - 1]: Sized,\n-   |                                         ----- required by this bound in `test1::{{constant}}#1`\n+   |          ---------------------------- required by this bound in `test1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n@@ -29,8 +42,13 @@ error: constant expression depends on a generic parameter\n    |\n LL |     let _ = const_evaluatable_lib::test1::<T>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | \n+  ::: $DIR/auxiliary/const_evaluatable_lib.rs:4:27\n+   |\n+LL | pub fn test1<T>() -> [u8; std::mem::size_of::<T>() - 1]\n+   |                           ---------------------------- required by this bound in `test1`\n    |\n    = note: this may fail depending on what value the parameter takes\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "3da4688702c96d83dbebeb11a8acc76d5735ae94", "filename": "src/test/ui/const-generics/const_evaluatable_checked/from-sig-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -0,0 +1,11 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+fn test<const N: usize>() -> [u8; N - 1] {\n+    //~^ ERROR evaluation of constant\n+    todo!()\n+}\n+\n+fn main() {\n+    test::<0>();\n+}"}, {"sha": "a5acfec34aa87feaa054540ec58a11b9e5eadb47", "filename": "src/test/ui/const-generics/const_evaluatable_checked/from-sig-fail.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig-fail.stderr?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/from-sig-fail.rs:4:35\n+   |\n+LL | fn test<const N: usize>() -> [u8; N - 1] {\n+   |                                   ^^^^^ attempt to compute `0_usize - 1_usize` which would overflow\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "5c05a5acfe96d310e980229200fa8ecd2547b5ea", "filename": "src/test/ui/const-generics/const_evaluatable_checked/from-sig.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffrom-sig.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -0,0 +1,14 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+struct Foo<const B: bool>;\n+\n+fn test<const N: usize>() -> Foo<{ N > 10 }> {\n+    Foo\n+}\n+\n+fn main() {\n+    let _: Foo<true> = test::<12>();\n+    let _: Foo<false> = test::<9>();\n+}"}, {"sha": "193a365f9b65bbb783a189720dd7993b15e80523", "filename": "src/test/ui/const-generics/const_evaluatable_checked/impl-bounds.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fimpl-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fimpl-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fimpl-bounds.rs?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+use std::mem::size_of;\n+\n+struct Foo<T, const N: usize>(T);\n+\n+impl<T> Foo<T, { size_of::<T>() }> {\n+    fn test() {\n+        let _: [u8; std::mem::size_of::<T>()];\n+    }\n+}\n+\n+trait Bar<const N: usize> {\n+    fn test_me();\n+}\n+\n+impl<T> Bar<{ size_of::<T>() }> for Foo<T, 3> {\n+    fn test_me() {\n+        let _: [u8; std::mem::size_of::<T>()];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bbc81693fc0ef31d5d4dd7625b2c3f73a4fd2b6b", "filename": "src/test/ui/const-generics/issues/issue-76595.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3a4da87f58099f08620a9a3e812abd77301cafb2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr?ref=3a4da87f58099f08620a9a3e812abd77301cafb2", "patch": "@@ -8,7 +8,7 @@ error: constant expression depends on a generic parameter\n   --> $DIR/issue-76595.rs:15:5\n    |\n LL | fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n-   |                                                                           ---- required by this bound in `test`\n+   |                                         ------------------------------- required by this bound in `test`\n ...\n LL |     test::<2>();\n    |     ^^^^^^^^^"}]}