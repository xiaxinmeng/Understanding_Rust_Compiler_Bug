{"sha": "7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYzFlODUyZDQzY2I4YzllNzdkYzFlNTMwMTRmMGViODVkMmViZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T23:18:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T23:18:43Z"}, "message": "Auto merge of #79539 - aDotInTheVoid:json-mvp, r=jyn514\n\nRustdoc: JSON backend experimental impl, with new tests.\n\nBased on #75114 by `@P1n3appl3`\n\nThe first commit is all of #75114, but squased to 1 commit, as that was much easier to rebase onto master.\n\nThe git history is a mess, but I think I'll edit it after review, so it's obvious whats new.\n\n## Still to do\n\n- [ ] Update docs.\n- [ ] Add bless option to tests.\n- [ ] Add test option for multiple files in same crate.\n- [ ] Decide if the tests should check for json to be equal or subset.\n- [ ] Go through the rest of the review for the original pr. (This is open because the test system is done(ish), but stuff like [not using a hashmap](https://github.com/rust-lang/rust/pull/75114#discussion_r519474420) and [using `CRATE_DEF_INDEX` ](https://github.com/rust-lang/rust/pull/75114#discussion_r519470764) hasn't)\n\nI'm also sure how many of these we need to do before landing on nightly, as it would be nice to get this in tree, so it isn't effected by churn like #79125, #79041, #79061\n\nr? `@jyn514`", "tree": {"sha": "d39b67bbcb458c5cfa9a7e3ebc50571011235e20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d39b67bbcb458c5cfa9a7e3ebc50571011235e20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "html_url": "https://github.com/rust-lang/rust/commit/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4db9ffb22dfcb702dbdb2e0607cb91791866b57", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4db9ffb22dfcb702dbdb2e0607cb91791866b57", "html_url": "https://github.com/rust-lang/rust/commit/f4db9ffb22dfcb702dbdb2e0607cb91791866b57"}, {"sha": "d619271f2bf90a4fce327ef868920ef39ee22a4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d619271f2bf90a4fce327ef868920ef39ee22a4c", "html_url": "https://github.com/rust-lang/rust/commit/d619271f2bf90a4fce327ef868920ef39ee22a4c"}], "stats": {"total": 2213, "additions": 2192, "deletions": 21}, "files": [{"sha": "6d97943548d5a24d6496c9869966bbe2a90a4e1f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -425,6 +425,7 @@ impl<'a> Builder<'a> {\n                 test::RustdocJSNotStd,\n                 test::RustdocTheme,\n                 test::RustdocUi,\n+                test::RustdocJson,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows"}, {"sha": "78b5de7897d1f4dd2be8dbfaf32c7c8d9ba37b19", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -904,6 +904,12 @@ host_test!(UiFullDeps { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-ful\n host_test!(Rustdoc { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" });\n host_test!(RustdocUi { path: \"src/test/rustdoc-ui\", mode: \"ui\", suite: \"rustdoc-ui\" });\n \n+host_test!(RustdocJson {\n+    path: \"src/test/rustdoc-json\",\n+    mode: \"rustdoc-json\",\n+    suite: \"rustdoc-json\"\n+});\n+\n host_test!(Pretty { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" });\n \n default_test!(RunMake { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" });\n@@ -1001,6 +1007,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n             || (mode == \"run-make\" && suite.ends_with(\"fulldeps\"))\n             || (mode == \"ui\" && is_rustdoc)\n             || mode == \"js-doc-test\"\n+            || mode == \"rustdoc-json\"\n         {\n             cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n         }"}, {"sha": "d4796b7ed66ca3405b025cb70472a266c8cca889", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -337,6 +337,42 @@ crate enum ItemKind {\n }\n \n impl ItemKind {\n+    /// Some items contain others such as structs (for their fields) and Enums\n+    /// (for their variants). This method returns those contained items.\n+    crate fn inner_items(&self) -> impl Iterator<Item = &Item> {\n+        match self {\n+            StructItem(s) => s.fields.iter(),\n+            UnionItem(u) => u.fields.iter(),\n+            VariantItem(Variant { kind: VariantKind::Struct(v) }) => v.fields.iter(),\n+            EnumItem(e) => e.variants.iter(),\n+            TraitItem(t) => t.items.iter(),\n+            ImplItem(i) => i.items.iter(),\n+            ModuleItem(m) => m.items.iter(),\n+            ExternCrateItem(_, _)\n+            | ImportItem(_)\n+            | FunctionItem(_)\n+            | TypedefItem(_, _)\n+            | OpaqueTyItem(_)\n+            | StaticItem(_)\n+            | ConstantItem(_)\n+            | TraitAliasItem(_)\n+            | TyMethodItem(_)\n+            | MethodItem(_, _)\n+            | StructFieldItem(_)\n+            | VariantItem(_)\n+            | ForeignFunctionItem(_)\n+            | ForeignStaticItem(_)\n+            | ForeignTypeItem\n+            | MacroItem(_)\n+            | ProcMacroItem(_)\n+            | PrimitiveItem(_)\n+            | AssocConstItem(_, _)\n+            | AssocTypeItem(_, _)\n+            | StrippedItem(_)\n+            | KeywordItem(_) => [].iter(),\n+        }\n+    }\n+\n     crate fn is_type_alias(&self) -> bool {\n         match *self {\n             ItemKind::TypedefItem(_, _) | ItemKind::AssocTypeItem(_, _) => true,\n@@ -1613,6 +1649,11 @@ impl Path {\n     crate fn last_name(&self) -> &str {\n         self.segments.last().expect(\"segments were empty\").name.as_str()\n     }\n+\n+    crate fn whole_name(&self) -> String {\n+        String::from(if self.global { \"::\" } else { \"\" })\n+            + &self.segments.iter().map(|s| s.name.clone()).collect::<Vec<_>>().join(\"::\")\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "afb8dfa676657892f698646b69229b72ad321d96", "filename": "src/librustdoc/json/conversions.rs", "status": "added", "additions": 599, "deletions": 0, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,599 @@\n+//! These from impls are used to create the JSON types which get serialized. They're very close to\n+//! the `clean` types but with some fields removed or stringified to simplify the output and not\n+//! expose unstable compiler internals.\n+\n+use std::convert::From;\n+\n+use rustc_ast::ast;\n+use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n+\n+use crate::clean;\n+use crate::doctree;\n+use crate::formats::item_type::ItemType;\n+use crate::json::types::*;\n+\n+impl From<clean::Item> for Option<Item> {\n+    fn from(item: clean::Item) -> Self {\n+        let item_type = ItemType::from(&item);\n+        let clean::Item {\n+            source,\n+            name,\n+            attrs,\n+            kind,\n+            visibility,\n+            def_id,\n+            stability: _,\n+            const_stability: _,\n+            deprecation,\n+        } = item;\n+        match kind {\n+            clean::StrippedItem(_) => None,\n+            _ => Some(Item {\n+                id: def_id.into(),\n+                crate_id: def_id.krate.as_u32(),\n+                name,\n+                source: source.into(),\n+                visibility: visibility.into(),\n+                docs: attrs.collapsed_doc_value().unwrap_or_default(),\n+                links: attrs\n+                    .links\n+                    .into_iter()\n+                    .filter_map(|clean::ItemLink { link, did, .. }| {\n+                        did.map(|did| (link, did.into()))\n+                    })\n+                    .collect(),\n+                attrs: attrs\n+                    .other_attrs\n+                    .iter()\n+                    .map(rustc_ast_pretty::pprust::attribute_to_string)\n+                    .collect(),\n+                deprecation: deprecation.map(Into::into),\n+                kind: item_type.into(),\n+                inner: kind.into(),\n+            }),\n+        }\n+    }\n+}\n+\n+impl From<clean::Span> for Option<Span> {\n+    fn from(span: clean::Span) -> Self {\n+        let clean::Span { loline, locol, hiline, hicol, .. } = span;\n+        match span.filename {\n+            rustc_span::FileName::Real(name) => Some(Span {\n+                filename: match name {\n+                    rustc_span::RealFileName::Named(path) => path,\n+                    rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n+                        local_path\n+                    }\n+                },\n+                begin: (loline, locol),\n+                end: (hiline, hicol),\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl From<clean::Deprecation> for Deprecation {\n+    fn from(deprecation: clean::Deprecation) -> Self {\n+        let clean::Deprecation { since, note, is_since_rustc_version: _ } = deprecation;\n+        Deprecation { since, note }\n+    }\n+}\n+\n+impl From<clean::Visibility> for Visibility {\n+    fn from(v: clean::Visibility) -> Self {\n+        use clean::Visibility::*;\n+        match v {\n+            Public => Visibility::Public,\n+            Inherited => Visibility::Default,\n+            Restricted(did, _) if did.index == CRATE_DEF_INDEX => Visibility::Crate,\n+            Restricted(did, path) => Visibility::Restricted {\n+                parent: did.into(),\n+                path: path.to_string_no_crate_verbose(),\n+            },\n+        }\n+    }\n+}\n+\n+impl From<clean::GenericArgs> for GenericArgs {\n+    fn from(args: clean::GenericArgs) -> Self {\n+        use clean::GenericArgs::*;\n+        match args {\n+            AngleBracketed { args, bindings } => GenericArgs::AngleBracketed {\n+                args: args.into_iter().map(Into::into).collect(),\n+                bindings: bindings.into_iter().map(Into::into).collect(),\n+            },\n+            Parenthesized { inputs, output } => GenericArgs::Parenthesized {\n+                inputs: inputs.into_iter().map(Into::into).collect(),\n+                output: output.map(Into::into),\n+            },\n+        }\n+    }\n+}\n+\n+impl From<clean::GenericArg> for GenericArg {\n+    fn from(arg: clean::GenericArg) -> Self {\n+        use clean::GenericArg::*;\n+        match arg {\n+            Lifetime(l) => GenericArg::Lifetime(l.0),\n+            Type(t) => GenericArg::Type(t.into()),\n+            Const(c) => GenericArg::Const(c.into()),\n+        }\n+    }\n+}\n+\n+impl From<clean::Constant> for Constant {\n+    fn from(constant: clean::Constant) -> Self {\n+        let clean::Constant { type_, expr, value, is_literal } = constant;\n+        Constant { type_: type_.into(), expr, value, is_literal }\n+    }\n+}\n+\n+impl From<clean::TypeBinding> for TypeBinding {\n+    fn from(binding: clean::TypeBinding) -> Self {\n+        TypeBinding { name: binding.name, binding: binding.kind.into() }\n+    }\n+}\n+\n+impl From<clean::TypeBindingKind> for TypeBindingKind {\n+    fn from(kind: clean::TypeBindingKind) -> Self {\n+        use clean::TypeBindingKind::*;\n+        match kind {\n+            Equality { ty } => TypeBindingKind::Equality(ty.into()),\n+            Constraint { bounds } => {\n+                TypeBindingKind::Constraint(bounds.into_iter().map(Into::into).collect())\n+            }\n+        }\n+    }\n+}\n+\n+impl From<DefId> for Id {\n+    fn from(did: DefId) -> Self {\n+        Id(format!(\"{}:{}\", did.krate.as_u32(), u32::from(did.index)))\n+    }\n+}\n+\n+impl From<clean::ItemKind> for ItemEnum {\n+    fn from(item: clean::ItemKind) -> Self {\n+        use clean::ItemKind::*;\n+        match item {\n+            ModuleItem(m) => ItemEnum::ModuleItem(m.into()),\n+            ExternCrateItem(c, a) => ItemEnum::ExternCrateItem { name: c, rename: a },\n+            ImportItem(i) => ItemEnum::ImportItem(i.into()),\n+            StructItem(s) => ItemEnum::StructItem(s.into()),\n+            UnionItem(u) => ItemEnum::StructItem(u.into()),\n+            StructFieldItem(f) => ItemEnum::StructFieldItem(f.into()),\n+            EnumItem(e) => ItemEnum::EnumItem(e.into()),\n+            VariantItem(v) => ItemEnum::VariantItem(v.into()),\n+            FunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n+            ForeignFunctionItem(f) => ItemEnum::FunctionItem(f.into()),\n+            TraitItem(t) => ItemEnum::TraitItem(t.into()),\n+            TraitAliasItem(t) => ItemEnum::TraitAliasItem(t.into()),\n+            MethodItem(m, _) => ItemEnum::MethodItem(m.into()),\n+            TyMethodItem(m) => ItemEnum::MethodItem(m.into()),\n+            ImplItem(i) => ItemEnum::ImplItem(i.into()),\n+            StaticItem(s) => ItemEnum::StaticItem(s.into()),\n+            ForeignStaticItem(s) => ItemEnum::StaticItem(s.into()),\n+            ForeignTypeItem => ItemEnum::ForeignTypeItem,\n+            TypedefItem(t, _) => ItemEnum::TypedefItem(t.into()),\n+            OpaqueTyItem(t) => ItemEnum::OpaqueTyItem(t.into()),\n+            ConstantItem(c) => ItemEnum::ConstantItem(c.into()),\n+            MacroItem(m) => ItemEnum::MacroItem(m.source),\n+            ProcMacroItem(m) => ItemEnum::ProcMacroItem(m.into()),\n+            AssocConstItem(t, s) => ItemEnum::AssocConstItem { type_: t.into(), default: s },\n+            AssocTypeItem(g, t) => ItemEnum::AssocTypeItem {\n+                bounds: g.into_iter().map(Into::into).collect(),\n+                default: t.map(Into::into),\n+            },\n+            StrippedItem(inner) => (*inner).into(),\n+            PrimitiveItem(_) | KeywordItem(_) => {\n+                panic!(\"{:?} is not supported for JSON output\", item)\n+            }\n+        }\n+    }\n+}\n+\n+impl From<clean::Module> for Module {\n+    fn from(module: clean::Module) -> Self {\n+        Module { is_crate: module.is_crate, items: ids(module.items) }\n+    }\n+}\n+\n+impl From<clean::Struct> for Struct {\n+    fn from(struct_: clean::Struct) -> Self {\n+        let clean::Struct { struct_type, generics, fields, fields_stripped } = struct_;\n+        Struct {\n+            struct_type: struct_type.into(),\n+            generics: generics.into(),\n+            fields_stripped,\n+            fields: ids(fields),\n+            impls: Vec::new(), // Added in JsonRenderer::item\n+        }\n+    }\n+}\n+\n+impl From<clean::Union> for Struct {\n+    fn from(struct_: clean::Union) -> Self {\n+        let clean::Union { struct_type, generics, fields, fields_stripped } = struct_;\n+        Struct {\n+            struct_type: struct_type.into(),\n+            generics: generics.into(),\n+            fields_stripped,\n+            fields: ids(fields),\n+            impls: Vec::new(), // Added in JsonRenderer::item\n+        }\n+    }\n+}\n+\n+impl From<doctree::StructType> for StructType {\n+    fn from(struct_type: doctree::StructType) -> Self {\n+        use doctree::StructType::*;\n+        match struct_type {\n+            Plain => StructType::Plain,\n+            Tuple => StructType::Tuple,\n+            Unit => StructType::Unit,\n+        }\n+    }\n+}\n+\n+fn stringify_header(header: &rustc_hir::FnHeader) -> String {\n+    let mut s = String::from(header.unsafety.prefix_str());\n+    if header.asyncness == rustc_hir::IsAsync::Async {\n+        s.push_str(\"async \")\n+    }\n+    if header.constness == rustc_hir::Constness::Const {\n+        s.push_str(\"const \")\n+    }\n+    s\n+}\n+\n+impl From<clean::Function> for Function {\n+    fn from(function: clean::Function) -> Self {\n+        let clean::Function { decl, generics, header, all_types: _, ret_types: _ } = function;\n+        Function {\n+            decl: decl.into(),\n+            generics: generics.into(),\n+            header: stringify_header(&header),\n+            abi: header.abi.to_string(),\n+        }\n+    }\n+}\n+\n+impl From<clean::Generics> for Generics {\n+    fn from(generics: clean::Generics) -> Self {\n+        Generics {\n+            params: generics.params.into_iter().map(Into::into).collect(),\n+            where_predicates: generics.where_predicates.into_iter().map(Into::into).collect(),\n+        }\n+    }\n+}\n+\n+impl From<clean::GenericParamDef> for GenericParamDef {\n+    fn from(generic_param: clean::GenericParamDef) -> Self {\n+        GenericParamDef { name: generic_param.name, kind: generic_param.kind.into() }\n+    }\n+}\n+\n+impl From<clean::GenericParamDefKind> for GenericParamDefKind {\n+    fn from(kind: clean::GenericParamDefKind) -> Self {\n+        use clean::GenericParamDefKind::*;\n+        match kind {\n+            Lifetime => GenericParamDefKind::Lifetime,\n+            Type { did: _, bounds, default, synthetic: _ } => GenericParamDefKind::Type {\n+                bounds: bounds.into_iter().map(Into::into).collect(),\n+                default: default.map(Into::into),\n+            },\n+            Const { did: _, ty } => GenericParamDefKind::Const(ty.into()),\n+        }\n+    }\n+}\n+\n+impl From<clean::WherePredicate> for WherePredicate {\n+    fn from(predicate: clean::WherePredicate) -> Self {\n+        use clean::WherePredicate::*;\n+        match predicate {\n+            BoundPredicate { ty, bounds } => WherePredicate::BoundPredicate {\n+                ty: ty.into(),\n+                bounds: bounds.into_iter().map(Into::into).collect(),\n+            },\n+            RegionPredicate { lifetime, bounds } => WherePredicate::RegionPredicate {\n+                lifetime: lifetime.0,\n+                bounds: bounds.into_iter().map(Into::into).collect(),\n+            },\n+            EqPredicate { lhs, rhs } => {\n+                WherePredicate::EqPredicate { lhs: lhs.into(), rhs: rhs.into() }\n+            }\n+        }\n+    }\n+}\n+\n+impl From<clean::GenericBound> for GenericBound {\n+    fn from(bound: clean::GenericBound) -> Self {\n+        use clean::GenericBound::*;\n+        match bound {\n+            TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n+                GenericBound::TraitBound {\n+                    trait_: trait_.into(),\n+                    generic_params: generic_params.into_iter().map(Into::into).collect(),\n+                    modifier: modifier.into(),\n+                }\n+            }\n+            Outlives(lifetime) => GenericBound::Outlives(lifetime.0),\n+        }\n+    }\n+}\n+\n+impl From<rustc_hir::TraitBoundModifier> for TraitBoundModifier {\n+    fn from(modifier: rustc_hir::TraitBoundModifier) -> Self {\n+        use rustc_hir::TraitBoundModifier::*;\n+        match modifier {\n+            None => TraitBoundModifier::None,\n+            Maybe => TraitBoundModifier::Maybe,\n+            MaybeConst => TraitBoundModifier::MaybeConst,\n+        }\n+    }\n+}\n+\n+impl From<clean::Type> for Type {\n+    fn from(ty: clean::Type) -> Self {\n+        use clean::Type::*;\n+        match ty {\n+            ResolvedPath { path, param_names, did, is_generic: _ } => Type::ResolvedPath {\n+                name: path.whole_name(),\n+                id: did.into(),\n+                args: path.segments.last().map(|args| Box::new(args.clone().args.into())),\n+                param_names: param_names\n+                    .map(|v| v.into_iter().map(Into::into).collect())\n+                    .unwrap_or_default(),\n+            },\n+            Generic(s) => Type::Generic(s),\n+            Primitive(p) => Type::Primitive(p.as_str().to_string()),\n+            BareFunction(f) => Type::FunctionPointer(Box::new((*f).into())),\n+            Tuple(t) => Type::Tuple(t.into_iter().map(Into::into).collect()),\n+            Slice(t) => Type::Slice(Box::new((*t).into())),\n+            Array(t, s) => Type::Array { type_: Box::new((*t).into()), len: s },\n+            ImplTrait(g) => Type::ImplTrait(g.into_iter().map(Into::into).collect()),\n+            Never => Type::Never,\n+            Infer => Type::Infer,\n+            RawPointer(mutability, type_) => Type::RawPointer {\n+                mutable: mutability == ast::Mutability::Mut,\n+                type_: Box::new((*type_).into()),\n+            },\n+            BorrowedRef { lifetime, mutability, type_ } => Type::BorrowedRef {\n+                lifetime: lifetime.map(|l| l.0),\n+                mutable: mutability == ast::Mutability::Mut,\n+                type_: Box::new((*type_).into()),\n+            },\n+            QPath { name, self_type, trait_ } => Type::QualifiedPath {\n+                name,\n+                self_type: Box::new((*self_type).into()),\n+                trait_: Box::new((*trait_).into()),\n+            },\n+        }\n+    }\n+}\n+\n+impl From<clean::BareFunctionDecl> for FunctionPointer {\n+    fn from(bare_decl: clean::BareFunctionDecl) -> Self {\n+        let clean::BareFunctionDecl { unsafety, generic_params, decl, abi } = bare_decl;\n+        FunctionPointer {\n+            is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n+            generic_params: generic_params.into_iter().map(Into::into).collect(),\n+            decl: decl.into(),\n+            abi: abi.to_string(),\n+        }\n+    }\n+}\n+\n+impl From<clean::FnDecl> for FnDecl {\n+    fn from(decl: clean::FnDecl) -> Self {\n+        let clean::FnDecl { inputs, output, c_variadic, attrs: _ } = decl;\n+        FnDecl {\n+            inputs: inputs.values.into_iter().map(|arg| (arg.name, arg.type_.into())).collect(),\n+            output: match output {\n+                clean::FnRetTy::Return(t) => Some(t.into()),\n+                clean::FnRetTy::DefaultReturn => None,\n+            },\n+            c_variadic,\n+        }\n+    }\n+}\n+\n+impl From<clean::Trait> for Trait {\n+    fn from(trait_: clean::Trait) -> Self {\n+        let clean::Trait { unsafety, items, generics, bounds, is_spotlight: _, is_auto } = trait_;\n+        Trait {\n+            is_auto,\n+            is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n+            items: ids(items),\n+            generics: generics.into(),\n+            bounds: bounds.into_iter().map(Into::into).collect(),\n+            implementors: Vec::new(), // Added in JsonRenderer::item\n+        }\n+    }\n+}\n+\n+impl From<clean::Impl> for Impl {\n+    fn from(impl_: clean::Impl) -> Self {\n+        let clean::Impl {\n+            unsafety,\n+            generics,\n+            provided_trait_methods,\n+            trait_,\n+            for_,\n+            items,\n+            polarity,\n+            synthetic,\n+            blanket_impl,\n+        } = impl_;\n+        Impl {\n+            is_unsafe: unsafety == rustc_hir::Unsafety::Unsafe,\n+            generics: generics.into(),\n+            provided_trait_methods: provided_trait_methods.into_iter().collect(),\n+            trait_: trait_.map(Into::into),\n+            for_: for_.into(),\n+            items: ids(items),\n+            negative: polarity == Some(clean::ImplPolarity::Negative),\n+            synthetic,\n+            blanket_impl: blanket_impl.map(Into::into),\n+        }\n+    }\n+}\n+\n+impl From<clean::Function> for Method {\n+    fn from(function: clean::Function) -> Self {\n+        let clean::Function { header, decl, generics, all_types: _, ret_types: _ } = function;\n+        Method {\n+            decl: decl.into(),\n+            generics: generics.into(),\n+            header: stringify_header(&header),\n+            has_body: true,\n+        }\n+    }\n+}\n+\n+impl From<clean::Enum> for Enum {\n+    fn from(enum_: clean::Enum) -> Self {\n+        let clean::Enum { variants, generics, variants_stripped } = enum_;\n+        Enum {\n+            generics: generics.into(),\n+            variants_stripped,\n+            variants: ids(variants),\n+            impls: Vec::new(), // Added in JsonRenderer::item\n+        }\n+    }\n+}\n+\n+impl From<clean::VariantStruct> for Struct {\n+    fn from(struct_: clean::VariantStruct) -> Self {\n+        let clean::VariantStruct { struct_type, fields, fields_stripped } = struct_;\n+        Struct {\n+            struct_type: struct_type.into(),\n+            generics: Default::default(),\n+            fields_stripped,\n+            fields: ids(fields),\n+            impls: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl From<clean::Variant> for Variant {\n+    fn from(variant: clean::Variant) -> Self {\n+        use clean::VariantKind::*;\n+        match variant.kind {\n+            CLike => Variant::Plain,\n+            Tuple(t) => Variant::Tuple(t.into_iter().map(Into::into).collect()),\n+            Struct(s) => Variant::Struct(ids(s.fields)),\n+        }\n+    }\n+}\n+\n+impl From<clean::Import> for Import {\n+    fn from(import: clean::Import) -> Self {\n+        use clean::ImportKind::*;\n+        match import.kind {\n+            Simple(s) => Import {\n+                span: import.source.path.whole_name(),\n+                name: s,\n+                id: import.source.did.map(Into::into),\n+                glob: false,\n+            },\n+            Glob => Import {\n+                span: import.source.path.whole_name(),\n+                name: import.source.path.last_name().to_string(),\n+                id: import.source.did.map(Into::into),\n+                glob: true,\n+            },\n+        }\n+    }\n+}\n+\n+impl From<clean::ProcMacro> for ProcMacro {\n+    fn from(mac: clean::ProcMacro) -> Self {\n+        ProcMacro { kind: mac.kind.into(), helpers: mac.helpers }\n+    }\n+}\n+\n+impl From<rustc_span::hygiene::MacroKind> for MacroKind {\n+    fn from(kind: rustc_span::hygiene::MacroKind) -> Self {\n+        use rustc_span::hygiene::MacroKind::*;\n+        match kind {\n+            Bang => MacroKind::Bang,\n+            Attr => MacroKind::Attr,\n+            Derive => MacroKind::Derive,\n+        }\n+    }\n+}\n+\n+impl From<clean::Typedef> for Typedef {\n+    fn from(typedef: clean::Typedef) -> Self {\n+        let clean::Typedef { type_, generics, item_type: _ } = typedef;\n+        Typedef { type_: type_.into(), generics: generics.into() }\n+    }\n+}\n+\n+impl From<clean::OpaqueTy> for OpaqueTy {\n+    fn from(opaque: clean::OpaqueTy) -> Self {\n+        OpaqueTy {\n+            bounds: opaque.bounds.into_iter().map(Into::into).collect(),\n+            generics: opaque.generics.into(),\n+        }\n+    }\n+}\n+\n+impl From<clean::Static> for Static {\n+    fn from(stat: clean::Static) -> Self {\n+        Static {\n+            type_: stat.type_.into(),\n+            mutable: stat.mutability == ast::Mutability::Mut,\n+            expr: stat.expr,\n+        }\n+    }\n+}\n+\n+impl From<clean::TraitAlias> for TraitAlias {\n+    fn from(alias: clean::TraitAlias) -> Self {\n+        TraitAlias {\n+            generics: alias.generics.into(),\n+            params: alias.bounds.into_iter().map(Into::into).collect(),\n+        }\n+    }\n+}\n+\n+impl From<ItemType> for ItemKind {\n+    fn from(kind: ItemType) -> Self {\n+        use ItemType::*;\n+        match kind {\n+            Module => ItemKind::Module,\n+            ExternCrate => ItemKind::ExternCrate,\n+            Import => ItemKind::Import,\n+            Struct => ItemKind::Struct,\n+            Union => ItemKind::Union,\n+            Enum => ItemKind::Enum,\n+            Function => ItemKind::Function,\n+            Typedef => ItemKind::Typedef,\n+            OpaqueTy => ItemKind::OpaqueTy,\n+            Static => ItemKind::Static,\n+            Constant => ItemKind::Constant,\n+            Trait => ItemKind::Trait,\n+            Impl => ItemKind::Impl,\n+            TyMethod | Method => ItemKind::Method,\n+            StructField => ItemKind::StructField,\n+            Variant => ItemKind::Variant,\n+            Macro => ItemKind::Macro,\n+            Primitive => ItemKind::Primitive,\n+            AssocConst => ItemKind::AssocConst,\n+            AssocType => ItemKind::AssocType,\n+            ForeignType => ItemKind::ForeignType,\n+            Keyword => ItemKind::Keyword,\n+            TraitAlias => ItemKind::TraitAlias,\n+            ProcAttribute => ItemKind::ProcAttribute,\n+            ProcDerive => ItemKind::ProcDerive,\n+        }\n+    }\n+}\n+\n+fn ids(items: impl IntoIterator<Item = clean::Item>) -> Vec<Id> {\n+    items.into_iter().filter(|x| !x.is_stripped()).map(|i| i.def_id.into()).collect()\n+}"}, {"sha": "c080ad21c0f33f5d6a9c52e1195d771e12e4594a", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 207, "deletions": 16, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -1,47 +1,238 @@\n+//! Rustdoc's JSON backend\n+//!\n+//! This module contains the logic for rendering a crate as JSON rather than the normal static HTML\n+//! output. See [the RFC](https://github.com/rust-lang/rfcs/pull/2963) and the [`types`] module\n+//! docs for usage and details.\n+\n+mod conversions;\n+pub mod types;\n+\n+use std::cell::RefCell;\n+use std::fs::File;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::edition::Edition;\n+\n use crate::clean;\n use crate::config::{RenderInfo, RenderOptions};\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-\n-use rustc_span::edition::Edition;\n+use crate::html::render::cache::ExternalLocation;\n \n #[derive(Clone)]\n-crate struct JsonRenderer {}\n+crate struct JsonRenderer {\n+    /// A mapping of IDs that contains all local items for this crate which gets output as a top\n+    /// level field of the JSON blob.\n+    index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n+    /// The directory where the blob will be written to.\n+    out_path: PathBuf,\n+}\n+\n+impl JsonRenderer {\n+    fn get_trait_implementors(\n+        &mut self,\n+        id: rustc_span::def_id::DefId,\n+        cache: &Cache,\n+    ) -> Vec<types::Id> {\n+        cache\n+            .implementors\n+            .get(&id)\n+            .map(|implementors| {\n+                implementors\n+                    .iter()\n+                    .map(|i| {\n+                        let item = &i.impl_item;\n+                        self.item(item.clone(), cache).unwrap();\n+                        item.def_id.into()\n+                    })\n+                    .collect()\n+            })\n+            .unwrap_or_default()\n+    }\n+\n+    fn get_impls(&mut self, id: rustc_span::def_id::DefId, cache: &Cache) -> Vec<types::Id> {\n+        cache\n+            .impls\n+            .get(&id)\n+            .map(|impls| {\n+                impls\n+                    .iter()\n+                    .filter_map(|i| {\n+                        let item = &i.impl_item;\n+                        if item.def_id.is_local() {\n+                            self.item(item.clone(), cache).unwrap();\n+                            Some(item.def_id.into())\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect()\n+            })\n+            .unwrap_or_default()\n+    }\n+\n+    fn get_trait_items(&mut self, cache: &Cache) -> Vec<(types::Id, types::Item)> {\n+        cache\n+            .traits\n+            .iter()\n+            .filter_map(|(&id, trait_item)| {\n+                // only need to synthesize items for external traits\n+                if !id.is_local() {\n+                    trait_item.items.clone().into_iter().for_each(|i| self.item(i, cache).unwrap());\n+                    Some((\n+                        id.into(),\n+                        types::Item {\n+                            id: id.into(),\n+                            crate_id: id.krate.as_u32(),\n+                            name: cache\n+                                .paths\n+                                .get(&id)\n+                                .unwrap_or_else(|| {\n+                                    cache\n+                                        .external_paths\n+                                        .get(&id)\n+                                        .expect(\"Trait should either be in local or external paths\")\n+                                })\n+                                .0\n+                                .last()\n+                                .map(Clone::clone),\n+                            visibility: types::Visibility::Public,\n+                            kind: types::ItemKind::Trait,\n+                            inner: types::ItemEnum::TraitItem(trait_item.clone().into()),\n+                            source: None,\n+                            docs: Default::default(),\n+                            links: Default::default(),\n+                            attrs: Default::default(),\n+                            deprecation: Default::default(),\n+                        },\n+                    ))\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    }\n+}\n \n impl FormatRenderer for JsonRenderer {\n     fn init(\n-        _krate: clean::Crate,\n-        _options: RenderOptions,\n+        krate: clean::Crate,\n+        options: RenderOptions,\n         _render_info: RenderInfo,\n         _edition: Edition,\n         _cache: &mut Cache,\n     ) -> Result<(Self, clean::Crate), Error> {\n-        unimplemented!()\n+        debug!(\"Initializing json renderer\");\n+        Ok((\n+            JsonRenderer {\n+                index: Rc::new(RefCell::new(FxHashMap::default())),\n+                out_path: options.output,\n+            },\n+            krate,\n+        ))\n     }\n \n-    fn item(&mut self, _item: clean::Item, _cache: &Cache) -> Result<(), Error> {\n-        unimplemented!()\n+    /// Inserts an item into the index. This should be used rather than directly calling insert on\n+    /// the hashmap because certain items (traits and types) need to have their mappings for trait\n+    /// implementations filled out before they're inserted.\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n+        // Flatten items that recursively store other items\n+        item.kind.inner_items().for_each(|i| self.item(i.clone(), cache).unwrap());\n+\n+        let id = item.def_id;\n+        if let Some(mut new_item) = item.into(): Option<types::Item> {\n+            if let types::ItemEnum::TraitItem(ref mut t) = new_item.inner {\n+                t.implementors = self.get_trait_implementors(id, cache)\n+            } else if let types::ItemEnum::StructItem(ref mut s) = new_item.inner {\n+                s.impls = self.get_impls(id, cache)\n+            } else if let types::ItemEnum::EnumItem(ref mut e) = new_item.inner {\n+                e.impls = self.get_impls(id, cache)\n+            }\n+            self.index.borrow_mut().insert(id.into(), new_item);\n+        }\n+\n+        Ok(())\n     }\n \n     fn mod_item_in(\n         &mut self,\n-        _item: &clean::Item,\n-        _item_name: &str,\n-        _cache: &Cache,\n+        item: &clean::Item,\n+        _module_name: &str,\n+        cache: &Cache,\n     ) -> Result<(), Error> {\n-        unimplemented!()\n+        use clean::types::ItemKind::*;\n+        if let ModuleItem(m) = &item.kind {\n+            for item in &m.items {\n+                match &item.kind {\n+                    // These don't have names so they don't get added to the output by default\n+                    ImportItem(_) => self.item(item.clone(), cache).unwrap(),\n+                    ExternCrateItem(_, _) => self.item(item.clone(), cache).unwrap(),\n+                    ImplItem(i) => {\n+                        i.items.iter().for_each(|i| self.item(i.clone(), cache).unwrap())\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        self.item(item.clone(), cache).unwrap();\n+        Ok(())\n     }\n \n     fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n-        unimplemented!()\n+        Ok(())\n     }\n \n-    fn after_krate(&mut self, _krate: &clean::Crate, _cache: &Cache) -> Result<(), Error> {\n-        unimplemented!()\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error> {\n+        debug!(\"Done with crate\");\n+        let mut index = (*self.index).clone().into_inner();\n+        index.extend(self.get_trait_items(cache));\n+        let output = types::Crate {\n+            root: types::Id(String::from(\"0:0\")),\n+            crate_version: krate.version.clone(),\n+            includes_private: cache.document_private,\n+            index,\n+            paths: cache\n+                .paths\n+                .clone()\n+                .into_iter()\n+                .chain(cache.external_paths.clone().into_iter())\n+                .map(|(k, (path, kind))| {\n+                    (\n+                        k.into(),\n+                        types::ItemSummary { crate_id: k.krate.as_u32(), path, kind: kind.into() },\n+                    )\n+                })\n+                .collect(),\n+            external_crates: cache\n+                .extern_locations\n+                .iter()\n+                .map(|(k, v)| {\n+                    (\n+                        k.as_u32(),\n+                        types::ExternalCrate {\n+                            name: v.0.clone(),\n+                            html_root_url: match &v.2 {\n+                                ExternalLocation::Remote(s) => Some(s.clone()),\n+                                _ => None,\n+                            },\n+                        },\n+                    )\n+                })\n+                .collect(),\n+            format_version: 1,\n+        };\n+        let mut p = self.out_path.clone();\n+        p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());\n+        p.set_extension(\"json\");\n+        let file = File::create(&p).map_err(|error| Error { error: error.to_string(), file: p })?;\n+        serde_json::ser::to_writer(&file, &output).unwrap();\n+        Ok(())\n     }\n \n     fn after_run(&mut self, _diag: &rustc_errors::Handler) -> Result<(), Error> {\n-        unimplemented!()\n+        Ok(())\n     }\n }"}, {"sha": "10bf2a2acc5b9e908d95aeb9b163ad79064053c5", "filename": "src/librustdoc/json/types.rs", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Fjson%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Ftypes.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,490 @@\n+//! Rustdoc's JSON output interface\n+//!\n+//! These types are the public API exposed through the `--output-format json` flag. The [`Crate`]\n+//! struct is the root of the JSON blob and all other items are contained within.\n+\n+use std::path::PathBuf;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use serde::{Deserialize, Serialize};\n+\n+/// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n+/// about the language items in the local crate, as well as info about external items to allow\n+/// tools to find or link to them.\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Crate {\n+    /// The id of the root [`Module`] item of the local crate.\n+    pub root: Id,\n+    /// The version string given to `--crate-version`, if any.\n+    pub crate_version: Option<String>,\n+    /// Whether or not the output includes private items.\n+    pub includes_private: bool,\n+    /// A collection of all items in the local crate as well as some external traits and their\n+    /// items that are referenced locally.\n+    pub index: FxHashMap<Id, Item>,\n+    /// Maps IDs to fully qualified paths and other info helpful for generating links.\n+    pub paths: FxHashMap<Id, ItemSummary>,\n+    /// Maps `crate_id` of items to a crate name and html_root_url if it exists.\n+    pub external_crates: FxHashMap<u32, ExternalCrate>,\n+    /// A single version number to be used in the future when making backwards incompatible changes\n+    /// to the JSON output.\n+    pub format_version: u32,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct ExternalCrate {\n+    pub name: String,\n+    pub html_root_url: Option<String>,\n+}\n+\n+/// For external (not defined in the local crate) items, you don't get the same level of\n+/// information. This struct should contain enough to generate a link/reference to the item in\n+/// question, or can be used by a tool that takes the json output of multiple crates to find\n+/// the actual item definition with all the relevant info.\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct ItemSummary {\n+    /// Can be used to look up the name and html_root_url of the crate this item came from in the\n+    /// `external_crates` map.\n+    pub crate_id: u32,\n+    /// The list of path components for the fully qualified path of this item (e.g.\n+    /// `[\"std\", \"io\", \"lazy\", \"Lazy\"]` for `std::io::lazy::Lazy`).\n+    pub path: Vec<String>,\n+    /// Whether this item is a struct, trait, macro, etc.\n+    pub kind: ItemKind,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Item {\n+    /// The unique identifier of this item. Can be used to find this item in various mappings.\n+    pub id: Id,\n+    /// This can be used as a key to the `external_crates` map of [`Crate`] to see which crate\n+    /// this item came from.\n+    pub crate_id: u32,\n+    /// Some items such as impls don't have names.\n+    pub name: Option<String>,\n+    /// The source location of this item (absent if it came from a macro expansion or inline\n+    /// assembly).\n+    pub source: Option<Span>,\n+    /// By default all documented items are public, but you can tell rustdoc to output private items\n+    /// so this field is needed to differentiate.\n+    pub visibility: Visibility,\n+    /// The full markdown docstring of this item.\n+    pub docs: String,\n+    /// This mapping resolves [intra-doc links](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md) from the docstring to their IDs\n+    pub links: FxHashMap<String, Id>,\n+    /// Stringified versions of the attributes on this item (e.g. `\"#[inline]\"`)\n+    pub attrs: Vec<String>,\n+    pub deprecation: Option<Deprecation>,\n+    pub kind: ItemKind,\n+    pub inner: ItemEnum,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Span {\n+    /// The path to the source file for this span relative to the path `rustdoc` was invoked with.\n+    pub filename: PathBuf,\n+    /// Zero indexed Line and Column of the first character of the `Span`\n+    pub begin: (usize, usize),\n+    /// Zero indexed Line and Column of the last character of the `Span`\n+    pub end: (usize, usize),\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Deprecation {\n+    pub since: Option<String>,\n+    pub note: Option<String>,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum Visibility {\n+    Public,\n+    /// For the most part items are private by default. The exceptions are associated items of\n+    /// public traits and variants of public enums.\n+    Default,\n+    Crate,\n+    /// For `pub(in path)` visibility. `parent` is the module it's restricted to and `path` is how\n+    /// that module was referenced (like `\"super::super\"` or `\"crate::foo::bar\"`).\n+    Restricted {\n+        parent: Id,\n+        path: String,\n+    },\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum GenericArgs {\n+    /// <'a, 32, B: Copy, C = u32>\n+    AngleBracketed { args: Vec<GenericArg>, bindings: Vec<TypeBinding> },\n+    /// Fn(A, B) -> C\n+    Parenthesized { inputs: Vec<Type>, output: Option<Type> },\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum GenericArg {\n+    Lifetime(String),\n+    Type(Type),\n+    Const(Constant),\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Constant {\n+    #[serde(rename = \"type\")]\n+    pub type_: Type,\n+    pub expr: String,\n+    pub value: Option<String>,\n+    pub is_literal: bool,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct TypeBinding {\n+    pub name: String,\n+    pub binding: TypeBindingKind,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum TypeBindingKind {\n+    Equality(Type),\n+    Constraint(Vec<GenericBound>),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+pub struct Id(pub String);\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum ItemKind {\n+    Module,\n+    ExternCrate,\n+    Import,\n+    Struct,\n+    StructField,\n+    Union,\n+    Enum,\n+    Variant,\n+    Function,\n+    Typedef,\n+    OpaqueTy,\n+    Constant,\n+    Trait,\n+    TraitAlias,\n+    Method,\n+    Impl,\n+    Static,\n+    ForeignType,\n+    Macro,\n+    ProcAttribute,\n+    ProcDerive,\n+    AssocConst,\n+    AssocType,\n+    Primitive,\n+    Keyword,\n+}\n+\n+#[serde(untagged)]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum ItemEnum {\n+    ModuleItem(Module),\n+    ExternCrateItem {\n+        name: String,\n+        rename: Option<String>,\n+    },\n+    ImportItem(Import),\n+\n+    StructItem(Struct),\n+    StructFieldItem(Type),\n+    EnumItem(Enum),\n+    VariantItem(Variant),\n+\n+    FunctionItem(Function),\n+\n+    TraitItem(Trait),\n+    TraitAliasItem(TraitAlias),\n+    MethodItem(Method),\n+    ImplItem(Impl),\n+\n+    TypedefItem(Typedef),\n+    OpaqueTyItem(OpaqueTy),\n+    ConstantItem(Constant),\n+\n+    StaticItem(Static),\n+\n+    /// `type`s from an extern block\n+    ForeignTypeItem,\n+\n+    /// Declarative macro_rules! macro\n+    MacroItem(String),\n+    ProcMacroItem(ProcMacro),\n+\n+    AssocConstItem {\n+        #[serde(rename = \"type\")]\n+        type_: Type,\n+        /// e.g. `const X: usize = 5;`\n+        default: Option<String>,\n+    },\n+    AssocTypeItem {\n+        bounds: Vec<GenericBound>,\n+        /// e.g. `type X = usize;`\n+        default: Option<Type>,\n+    },\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Module {\n+    pub is_crate: bool,\n+    pub items: Vec<Id>,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Struct {\n+    pub struct_type: StructType,\n+    pub generics: Generics,\n+    pub fields_stripped: bool,\n+    pub fields: Vec<Id>,\n+    pub impls: Vec<Id>,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Enum {\n+    pub generics: Generics,\n+    pub variants_stripped: bool,\n+    pub variants: Vec<Id>,\n+    pub impls: Vec<Id>,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[serde(tag = \"variant_kind\", content = \"variant_inner\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum Variant {\n+    Plain,\n+    Tuple(Vec<Type>),\n+    Struct(Vec<Id>),\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum StructType {\n+    Plain,\n+    Tuple,\n+    Unit,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Function {\n+    pub decl: FnDecl,\n+    pub generics: Generics,\n+    pub header: String,\n+    pub abi: String,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Method {\n+    pub decl: FnDecl,\n+    pub generics: Generics,\n+    pub header: String,\n+    pub has_body: bool,\n+}\n+\n+#[derive(Clone, Debug, Default, Serialize, Deserialize)]\n+pub struct Generics {\n+    pub params: Vec<GenericParamDef>,\n+    pub where_predicates: Vec<WherePredicate>,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct GenericParamDef {\n+    pub name: String,\n+    pub kind: GenericParamDefKind,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum GenericParamDefKind {\n+    Lifetime,\n+    Type { bounds: Vec<GenericBound>, default: Option<Type> },\n+    Const(Type),\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum WherePredicate {\n+    BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n+    RegionPredicate { lifetime: String, bounds: Vec<GenericBound> },\n+    EqPredicate { lhs: Type, rhs: Type },\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum GenericBound {\n+    TraitBound {\n+        #[serde(rename = \"trait\")]\n+        trait_: Type,\n+        /// Used for HRTBs\n+        generic_params: Vec<GenericParamDef>,\n+        modifier: TraitBoundModifier,\n+    },\n+    Outlives(String),\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+    MaybeConst,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[serde(tag = \"kind\", content = \"inner\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum Type {\n+    /// Structs, enums, and traits\n+    ResolvedPath {\n+        name: String,\n+        id: Id,\n+        args: Option<Box<GenericArgs>>,\n+        param_names: Vec<GenericBound>,\n+    },\n+    /// Parameterized types\n+    Generic(String),\n+    /// Fixed-size numeric types (plus int/usize/float), char, arrays, slices, and tuples\n+    Primitive(String),\n+    /// `extern \"ABI\" fn`\n+    FunctionPointer(Box<FunctionPointer>),\n+    /// `(String, u32, Box<usize>)`\n+    Tuple(Vec<Type>),\n+    /// `[u32]`\n+    Slice(Box<Type>),\n+    /// [u32; 15]\n+    Array {\n+        #[serde(rename = \"type\")]\n+        type_: Box<Type>,\n+        len: String,\n+    },\n+    /// `impl TraitA + TraitB + ...`\n+    ImplTrait(Vec<GenericBound>),\n+    /// `!`\n+    Never,\n+    /// `_`\n+    Infer,\n+    /// `*mut u32`, `*u8`, etc.\n+    RawPointer {\n+        mutable: bool,\n+        #[serde(rename = \"type\")]\n+        type_: Box<Type>,\n+    },\n+    /// `&'a mut String`, `&str`, etc.\n+    BorrowedRef {\n+        lifetime: Option<String>,\n+        mutable: bool,\n+        #[serde(rename = \"type\")]\n+        type_: Box<Type>,\n+    },\n+    /// `<Type as Trait>::Name` or associated types like `T::Item` where `T: Iterator`\n+    QualifiedPath {\n+        name: String,\n+        self_type: Box<Type>,\n+        #[serde(rename = \"trait\")]\n+        trait_: Box<Type>,\n+    },\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct FunctionPointer {\n+    pub is_unsafe: bool,\n+    pub generic_params: Vec<GenericParamDef>,\n+    pub decl: FnDecl,\n+    pub abi: String,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct FnDecl {\n+    pub inputs: Vec<(String, Type)>,\n+    pub output: Option<Type>,\n+    pub c_variadic: bool,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Trait {\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub items: Vec<Id>,\n+    pub generics: Generics,\n+    pub bounds: Vec<GenericBound>,\n+    pub implementors: Vec<Id>,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct TraitAlias {\n+    pub generics: Generics,\n+    pub params: Vec<GenericBound>,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Impl {\n+    pub is_unsafe: bool,\n+    pub generics: Generics,\n+    pub provided_trait_methods: Vec<String>,\n+    #[serde(rename = \"trait\")]\n+    pub trait_: Option<Type>,\n+    #[serde(rename = \"for\")]\n+    pub for_: Type,\n+    pub items: Vec<Id>,\n+    pub negative: bool,\n+    pub synthetic: bool,\n+    pub blanket_impl: Option<Type>,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Import {\n+    /// The full path being imported.\n+    pub span: String,\n+    /// May be different from the last segment of `source` when renaming imports:\n+    /// `use source as name;`\n+    pub name: String,\n+    /// The ID of the item being imported.\n+    pub id: Option<Id>, // FIXME is this actually ever None?\n+    /// Whether this import uses a glob: `use source::*;`\n+    pub glob: bool,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct ProcMacro {\n+    pub kind: MacroKind,\n+    pub helpers: Vec<String>,\n+}\n+\n+#[serde(rename_all = \"snake_case\")]\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub enum MacroKind {\n+    /// A bang macro `foo!()`.\n+    Bang,\n+    /// An attribute macro `#[foo]`.\n+    Attr,\n+    /// A derive macro `#[derive(Foo)]`\n+    Derive,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Typedef {\n+    #[serde(rename = \"type\")]\n+    pub type_: Type,\n+    pub generics: Generics,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct OpaqueTy {\n+    pub bounds: Vec<GenericBound>,\n+    pub generics: Generics,\n+}\n+\n+#[derive(Clone, Debug, Serialize, Deserialize)]\n+pub struct Static {\n+    #[serde(rename = \"type\")]\n+    pub type_: Type,\n+    pub mutable: bool,\n+    pub expr: String,\n+}"}, {"sha": "80a9c3811cf666c1cc00841b4509ae660d235147", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -14,6 +14,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![feature(once_cell)]\n+#![feature(type_ascription)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "3a3bf7fa3ed58da538e503dbf6263377f7aaaa18", "filename": "src/test/rustdoc-json/check_missing_items.py", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fcheck_missing_items.py?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,187 @@\n+#!/usr/bin/env python\n+\n+# This test ensures that every ID in the produced json actually resolves to an item either in\n+# `index` or `paths`. It DOES NOT check that the structure of the produced json is actually in\n+# any way correct, for example an empty map would pass.\n+\n+import sys\n+import json\n+\n+crate = json.load(open(sys.argv[1]))\n+\n+\n+def get_local_item(item_id):\n+    if item_id in crate[\"index\"]:\n+        return crate[\"index\"][item_id]\n+    print(\"Missing local ID:\", item_id)\n+    sys.exit(1)\n+\n+\n+# local IDs have to be in `index`, external ones can sometimes be in `index` but otherwise have\n+# to be in `paths`\n+def valid_id(item_id):\n+    return item_id in crate[\"index\"] or item_id[0] != \"0\" and item_id in crate[\"paths\"]\n+\n+\n+def check_generics(generics):\n+    for param in generics[\"params\"]:\n+        check_generic_param(param)\n+    for where_predicate in generics[\"where_predicates\"]:\n+        if \"bound_predicate\" in where_predicate:\n+            pred = where_predicate[\"bound_predicate\"]\n+            check_type(pred[\"ty\"])\n+            for bound in pred[\"bounds\"]:\n+                check_generic_bound(bound)\n+        elif \"region_predicate\" in where_predicate:\n+            pred = where_predicate[\"region_predicate\"]\n+            for bound in pred[\"bounds\"]:\n+                check_generic_bound(bound)\n+        elif \"eq_predicate\" in where_predicate:\n+            pred = where_predicate[\"eq_predicate\"]\n+            check_type(pred[\"rhs\"])\n+            check_type(pred[\"lhs\"])\n+\n+\n+def check_generic_param(param):\n+    if \"type\" in param[\"kind\"]:\n+        ty = param[\"kind\"][\"type\"]\n+        if ty[\"default\"]:\n+            check_type(ty[\"default\"])\n+        for bound in ty[\"bounds\"]:\n+            check_generic_bound(bound)\n+    elif \"const\" in param[\"kind\"]:\n+        check_type(param[\"kind\"][\"const\"])\n+\n+\n+def check_generic_bound(bound):\n+    if \"trait_bound\" in bound:\n+        for param in bound[\"trait_bound\"][\"generic_params\"]:\n+            check_generic_param(param)\n+        check_type(bound[\"trait_bound\"][\"trait\"])\n+\n+\n+def check_decl(decl):\n+    for (_name, ty) in decl[\"inputs\"]:\n+        check_type(ty)\n+    if decl[\"output\"]:\n+        check_type(decl[\"output\"])\n+\n+\n+def check_type(ty):\n+    if ty[\"kind\"] == \"resolved_path\":\n+        for bound in ty[\"inner\"][\"param_names\"]:\n+            check_generic_bound(bound)\n+        args = ty[\"inner\"][\"args\"]\n+        if args:\n+            if \"angle_bracketed\" in args:\n+                for arg in args[\"angle_bracketed\"][\"args\"]:\n+                    if \"type\" in arg:\n+                        check_type(arg[\"type\"])\n+                    elif \"const\" in arg:\n+                        check_type(arg[\"const\"][\"type\"])\n+                for binding in args[\"angle_bracketed\"][\"bindings\"]:\n+                    if \"equality\" in binding[\"binding\"]:\n+                        check_type(binding[\"binding\"][\"equality\"])\n+                    elif \"constraint\" in binding[\"binding\"]:\n+                        for bound in binding[\"binding\"][\"constraint\"]:\n+                            check_generic_bound(bound)\n+            elif \"parenthesized\" in args:\n+                for ty in args[\"parenthesized\"][\"inputs\"]:\n+                    check_type(ty)\n+                if args[\"parenthesized\"][\"output\"]:\n+                    check_type(args[\"parenthesized\"][\"output\"])\n+        if not valid_id(ty[\"inner\"][\"id\"]):\n+            print(\"Type contained an invalid ID:\", ty[\"inner\"][\"id\"])\n+            sys.exit(1)\n+    elif ty[\"kind\"] == \"tuple\":\n+        for ty in ty[\"inner\"]:\n+            check_type(ty)\n+    elif ty[\"kind\"] == \"slice\":\n+        check_type(ty[\"inner\"])\n+    elif ty[\"kind\"] == \"impl_trait\":\n+        for bound in ty[\"inner\"]:\n+            check_generic_bound(bound)\n+    elif ty[\"kind\"] in (\"raw_pointer\", \"borrowed_ref\", \"array\"):\n+        check_type(ty[\"inner\"][\"type\"])\n+    elif ty[\"kind\"] == \"function_pointer\":\n+        for param in ty[\"inner\"][\"generic_params\"]:\n+            check_generic_param(param)\n+        check_decl(ty[\"inner\"][\"inner\"])\n+    elif ty[\"kind\"] == \"qualified_path\":\n+        check_type(ty[\"inner\"][\"self_type\"])\n+        check_type(ty[\"inner\"][\"trait\"])\n+\n+\n+work_list = set([crate[\"root\"]])\n+visited = work_list.copy()\n+\n+while work_list:\n+    current = work_list.pop()\n+    visited.add(current)\n+    item = get_local_item(current)\n+    # check intradoc links\n+    for (_name, link) in item[\"links\"].items():\n+        if not valid_id(link):\n+            print(\"Intra-doc link contains invalid ID:\", link)\n+\n+    # check all fields that reference types such as generics as well as nested items\n+    # (modules, structs, traits, and enums)\n+    if item[\"kind\"] == \"module\":\n+        work_list |= set(item[\"inner\"][\"items\"]) - visited\n+    elif item[\"kind\"] == \"struct\":\n+        check_generics(item[\"inner\"][\"generics\"])\n+        work_list |= (\n+            set(item[\"inner\"][\"fields\"]) | set(item[\"inner\"][\"impls\"])\n+        ) - visited\n+    elif item[\"kind\"] == \"struct_field\":\n+        check_type(item[\"inner\"])\n+    elif item[\"kind\"] == \"enum\":\n+        check_generics(item[\"inner\"][\"generics\"])\n+        work_list |= (\n+            set(item[\"inner\"][\"variants\"]) | set(item[\"inner\"][\"impls\"])\n+        ) - visited\n+    elif item[\"kind\"] == \"variant\":\n+        if item[\"inner\"][\"variant_kind\"] == \"tuple\":\n+            for ty in item[\"inner\"][\"variant_inner\"]:\n+                check_type(ty)\n+        elif item[\"inner\"][\"variant_kind\"] == \"struct\":\n+            work_list |= set(item[\"inner\"][\"variant_inner\"]) - visited\n+    elif item[\"kind\"] in (\"function\", \"method\"):\n+        check_generics(item[\"inner\"][\"generics\"])\n+        check_decl(item[\"inner\"][\"decl\"])\n+    elif item[\"kind\"] in (\"static\", \"constant\", \"assoc_const\"):\n+        check_type(item[\"inner\"][\"type\"])\n+    elif item[\"kind\"] == \"typedef\":\n+        check_type(item[\"inner\"][\"type\"])\n+        check_generics(item[\"inner\"][\"generics\"])\n+    elif item[\"kind\"] == \"opaque_ty\":\n+        check_generics(item[\"inner\"][\"generics\"])\n+        for bound in item[\"inner\"][\"bounds\"]:\n+            check_generic_bound(bound)\n+    elif item[\"kind\"] == \"trait_alias\":\n+        check_generics(item[\"inner\"][\"params\"])\n+        for bound in item[\"inner\"][\"bounds\"]:\n+            check_generic_bound(bound)\n+    elif item[\"kind\"] == \"trait\":\n+        check_generics(item[\"inner\"][\"generics\"])\n+        for bound in item[\"inner\"][\"bounds\"]:\n+            check_generic_bound(bound)\n+        work_list |= (\n+            set(item[\"inner\"][\"items\"]) | set(item[\"inner\"][\"implementors\"])\n+        ) - visited\n+    elif item[\"kind\"] == \"impl\":\n+        check_generics(item[\"inner\"][\"generics\"])\n+        if item[\"inner\"][\"trait\"]:\n+            check_type(item[\"inner\"][\"trait\"])\n+        if item[\"inner\"][\"blanket_impl\"]:\n+            check_type(item[\"inner\"][\"blanket_impl\"])\n+        check_type(item[\"inner\"][\"for\"])\n+        for assoc_item in item[\"inner\"][\"items\"]:\n+            if not valid_id(assoc_item):\n+                print(\"Impl block referenced a missing ID:\", assoc_item)\n+                sys.exit(1)\n+    elif item[\"kind\"] == \"assoc_type\":\n+        for bound in item[\"inner\"][\"bounds\"]:\n+            check_generic_bound(bound)\n+        if item[\"inner\"][\"default\"]:\n+            check_type(item[\"inner\"][\"default\"])"}, {"sha": "b0c5b16a197008c696acb821ac2d89a0798d8b01", "filename": "src/test/rustdoc-json/compare.py", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fcompare.py", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fcompare.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fcompare.py?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,129 @@\n+#!/usr/bin/env python\n+\n+# This script can check that an expected json blob is a subset of what actually gets produced.\n+# The comparison is independent of the value of IDs (which are unstable) and instead uses their\n+# relative ordering to check them against eachother by looking them up in their respective blob's\n+# `index` or `paths` mappings. To add a new test run `rustdoc --output-format json -o . yourtest.rs`\n+# and then create `yourtest.expected` by stripping unnecessary details from `yourtest.json`. If\n+# you're on windows, replace `\\` with `/`.\n+\n+import copy\n+import sys\n+import json\n+import types\n+\n+# Used instead of the string ids when used as references.\n+# Not used as keys in `index` or `paths`\n+class ID(str):\n+    pass\n+\n+\n+class SubsetException(Exception):\n+    def __init__(self, msg, trace):\n+        self.msg = msg\n+        self.trace = msg\n+        super().__init__(\"{}: {}\".format(trace, msg))\n+\n+\n+def check_subset(expected_main, actual_main, base_dir):\n+    expected_index = expected_main[\"index\"]\n+    expected_paths = expected_main[\"paths\"]\n+    actual_index = actual_main[\"index\"]\n+    actual_paths = actual_main[\"paths\"]\n+    already_checked = set()\n+\n+    def _check_subset(expected, actual, trace):\n+        expected_type = type(expected)\n+        actual_type = type(actual)\n+\n+        if actual_type is str:\n+            actual = normalize(actual).replace(base_dir, \"$TEST_BASE_DIR\")\n+\n+        if expected_type is not actual_type:\n+            raise SubsetException(\n+                \"expected type `{}`, got `{}`\".format(expected_type, actual_type), trace\n+            )\n+\n+\n+        if expected_type in (int, bool, str) and expected != actual:\n+            raise SubsetException(\"expected `{}`, got: `{}`\".format(expected, actual), trace)\n+        if expected_type is dict:\n+            for key in expected:\n+                if key not in actual:\n+                    raise SubsetException(\n+                        \"Key `{}` not found in output\".format(key), trace\n+                    )\n+                new_trace = copy.deepcopy(trace)\n+                new_trace.append(key)\n+                _check_subset(expected[key], actual[key], new_trace)\n+        elif expected_type is list:\n+            expected_elements = len(expected)\n+            actual_elements = len(actual)\n+            if expected_elements != actual_elements:\n+                raise SubsetException(\n+                    \"Found {} items, expected {}\".format(\n+                        expected_elements, actual_elements\n+                    ),\n+                    trace,\n+                )\n+            for expected, actual in zip(expected, actual):\n+                new_trace = copy.deepcopy(trace)\n+                new_trace.append(expected)\n+                _check_subset(expected, actual, new_trace)\n+        elif expected_type is ID and expected not in already_checked:\n+            already_checked.add(expected)\n+            _check_subset(\n+                expected_index.get(expected, {}), actual_index.get(actual, {}), trace\n+            )\n+            _check_subset(\n+                expected_paths.get(expected, {}), actual_paths.get(actual, {}), trace\n+            )\n+\n+    _check_subset(expected_main[\"root\"], actual_main[\"root\"], [])\n+\n+\n+def rustdoc_object_hook(obj):\n+    # No need to convert paths, index and external_crates keys to ids, since\n+    # they are the target of resolution, and never a source itself.\n+    if \"id\" in obj and obj[\"id\"]:\n+        obj[\"id\"] = ID(obj[\"id\"])\n+    if \"root\" in obj:\n+        obj[\"root\"] = ID(obj[\"root\"])\n+    if \"items\" in obj:\n+        obj[\"items\"] = [ID(id) for id in obj[\"items\"]]\n+    if \"variants\" in obj:\n+        obj[\"variants\"] = [ID(id) for id in obj[\"variants\"]]\n+    if \"fields\" in obj:\n+        obj[\"fields\"] = [ID(id) for id in obj[\"fields\"]]\n+    if \"impls\" in obj:\n+        obj[\"impls\"] = [ID(id) for id in obj[\"impls\"]]\n+    if \"implementors\" in obj:\n+        obj[\"implementors\"] = [ID(id) for id in obj[\"implementors\"]]\n+    if \"links\" in obj:\n+        obj[\"links\"] = {s: ID(id) for s, id in obj[\"links\"]}\n+    if \"variant_kind\" in obj and obj[\"variant_kind\"] == \"struct\":\n+        obj[\"variant_inner\"] = [ID(id) for id in obj[\"variant_inner\"]]\n+    return obj\n+\n+\n+def main(expected_fpath, actual_fpath, base_dir):\n+    print(\n+        \"checking that {} is a logical subset of {}\".format(\n+            expected_fpath, actual_fpath\n+        )\n+    )\n+    with open(expected_fpath) as expected_file:\n+        expected_main = json.load(expected_file, object_hook=rustdoc_object_hook)\n+    with open(actual_fpath) as actual_file:\n+        actual_main = json.load(actual_file, object_hook=rustdoc_object_hook)\n+    check_subset(expected_main, actual_main, base_dir)\n+    print(\"all checks passed\")\n+\n+def normalize(s):\n+    return s.replace('\\\\', '/')\n+\n+if __name__ == \"__main__\":\n+    if len(sys.argv) < 4:\n+        print(\"Usage: `compare.py expected.json actual.json test-dir`\")\n+    else:\n+        main(sys.argv[1], sys.argv[2], normalize(sys.argv[3]))"}, {"sha": "799829de3fd6c9a6a29d52e6a8d90e9b30d24ea4", "filename": "src/test/rustdoc-json/structs.expected", "status": "added", "additions": 456, "deletions": 0, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fstructs.expected", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fstructs.expected", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs.expected?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,456 @@\n+{\n+  \"root\": \"0:0\",\n+  \"version\": null,\n+  \"includes_private\": false,\n+  \"index\": {\n+    \"0:9\": {\n+      \"crate_id\": 0,\n+      \"name\": \"Unit\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          7,\n+          0\n+        ],\n+        \"end\": [\n+          7,\n+          16\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct\",\n+      \"inner\": {\n+        \"struct_type\": \"unit\",\n+        \"generics\": {\n+          \"params\": [],\n+          \"where_predicates\": []\n+        },\n+        \"fields_stripped\": false,\n+        \"fields\": []\n+      }\n+    },\n+    \"0:8\": {\n+      \"crate_id\": 0,\n+      \"name\": \"1\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          5,\n+          22\n+        ],\n+        \"end\": [\n+          5,\n+          28\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"resolved_path\",\n+        \"inner\": {\n+          \"name\": \"String\",\n+          \"id\": \"5:5035\",\n+          \"args\": {\n+            \"angle_bracketed\": {\n+              \"args\": [],\n+              \"bindings\": []\n+            }\n+          },\n+          \"param_names\": []\n+        }\n+      }\n+    },\n+    \"0:18\": {\n+      \"crate_id\": 0,\n+      \"name\": \"stuff\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          15,\n+          4\n+        ],\n+        \"end\": [\n+          15,\n+          17\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"resolved_path\",\n+        \"inner\": {\n+          \"name\": \"Vec\",\n+          \"id\": \"5:4322\",\n+          \"args\": {\n+            \"angle_bracketed\": {\n+              \"args\": [\n+                {\n+                  \"type\": {\n+                    \"kind\": \"generic\",\n+                    \"inner\": \"T\"\n+                  }\n+                }\n+              ],\n+              \"bindings\": []\n+            }\n+          },\n+          \"param_names\": []\n+        }\n+      }\n+    },\n+    \"0:11\": {\n+      \"crate_id\": 0,\n+      \"name\": \"WithPrimitives\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          9,\n+          0\n+        ],\n+        \"end\": [\n+          12,\n+          1\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct\",\n+      \"inner\": {\n+        \"struct_type\": \"plain\",\n+        \"generics\": {\n+          \"params\": [\n+            {\n+              \"name\": \"'a\",\n+              \"kind\": \"lifetime\"\n+            }\n+          ],\n+          \"where_predicates\": []\n+        },\n+        \"fields_stripped\": true\n+      }\n+    },\n+    \"0:14\": {\n+      \"crate_id\": 0,\n+      \"name\": \"s\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          11,\n+          4\n+        ],\n+        \"end\": [\n+          11,\n+          14\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"borrowed_ref\",\n+        \"inner\": {\n+          \"lifetime\": \"'a\",\n+          \"mutable\": false,\n+          \"type\": {\n+            \"kind\": \"primitive\",\n+            \"inner\": \"str\"\n+          }\n+        }\n+      }\n+    },\n+    \"0:19\": {\n+      \"crate_id\": 0,\n+      \"name\": \"things\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          16,\n+          4\n+        ],\n+        \"end\": [\n+          16,\n+          25\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"resolved_path\",\n+        \"inner\": {\n+          \"name\": \"HashMap\",\n+          \"id\": \"1:6600\",\n+          \"args\": {\n+            \"angle_bracketed\": {\n+              \"args\": [\n+                {\n+                  \"type\": {\n+                    \"kind\": \"generic\",\n+                    \"inner\": \"U\"\n+                  }\n+                },\n+                {\n+                  \"type\": {\n+                    \"kind\": \"generic\",\n+                    \"inner\": \"U\"\n+                  }\n+                }\n+              ],\n+              \"bindings\": []\n+            }\n+          },\n+          \"param_names\": []\n+        }\n+      }\n+    },\n+    \"0:15\": {\n+      \"crate_id\": 0,\n+      \"name\": \"WithGenerics\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          14,\n+          0\n+        ],\n+        \"end\": [\n+          17,\n+          1\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct\",\n+      \"inner\": {\n+        \"struct_type\": \"plain\",\n+        \"generics\": {\n+          \"params\": [\n+            {\n+              \"name\": \"T\",\n+              \"kind\": {\n+                \"type\": {\n+                  \"bounds\": [],\n+                  \"default\": null\n+                }\n+              }\n+            },\n+            {\n+              \"name\": \"U\",\n+              \"kind\": {\n+                \"type\": {\n+                  \"bounds\": [],\n+                  \"default\": null\n+                }\n+              }\n+            }\n+          ],\n+          \"where_predicates\": []\n+        },\n+        \"fields_stripped\": true\n+      }\n+    },\n+    \"0:0\": {\n+      \"crate_id\": 0,\n+      \"name\": \"structs\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          1,\n+          0\n+        ],\n+        \"end\": [\n+          17,\n+          1\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"module\",\n+      \"inner\": {\n+        \"is_crate\": true,\n+        \"items\": [\n+          \"0:4\",\n+          \"0:5\",\n+          \"0:9\",\n+          \"0:11\",\n+          \"0:15\"\n+        ]\n+      }\n+    },\n+    \"0:13\": {\n+      \"crate_id\": 0,\n+      \"name\": \"num\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          10,\n+          4\n+        ],\n+        \"end\": [\n+          10,\n+          12\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"primitive\",\n+        \"inner\": \"u32\"\n+      }\n+    },\n+    \"0:5\": {\n+      \"crate_id\": 0,\n+      \"name\": \"Tuple\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          5,\n+          0\n+        ],\n+        \"end\": [\n+          5,\n+          30\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct\",\n+      \"inner\": {\n+        \"struct_type\": \"tuple\",\n+        \"generics\": {\n+          \"params\": [],\n+          \"where_predicates\": []\n+        },\n+        \"fields_stripped\": true\n+      }\n+    },\n+    \"0:4\": {\n+      \"crate_id\": 0,\n+      \"name\": \"PlainEmpty\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          3,\n+          0\n+        ],\n+        \"end\": [\n+          3,\n+          24\n+        ]\n+      },\n+      \"visibility\": \"public\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct\",\n+      \"inner\": {\n+        \"struct_type\": \"plain\",\n+        \"generics\": {\n+          \"params\": [],\n+          \"where_predicates\": []\n+        },\n+        \"fields_stripped\": false,\n+        \"fields\": []\n+      }\n+    },\n+    \"0:7\": {\n+      \"crate_id\": 0,\n+      \"name\": \"0\",\n+      \"source\": {\n+        \"filename\": \"$TEST_BASE_DIR/structs.rs\",\n+        \"begin\": [\n+          5,\n+          17\n+        ],\n+        \"end\": [\n+          5,\n+          20\n+        ]\n+      },\n+      \"visibility\": \"default\",\n+      \"docs\": \"\",\n+      \"links\": {},\n+      \"attrs\": [],\n+      \"deprecation\": null,\n+      \"kind\": \"struct_field\",\n+      \"inner\": {\n+        \"kind\": \"primitive\",\n+        \"inner\": \"u32\"\n+      }\n+    }\n+  },\n+  \"paths\": {\n+    \"5:4322\": {\n+      \"crate_id\": 5,\n+      \"path\": [\n+        \"alloc\",\n+        \"vec\",\n+        \"Vec\"\n+      ],\n+      \"kind\": \"struct\"\n+    },\n+    \"5:5035\": {\n+      \"crate_id\": 5,\n+      \"path\": [\n+        \"alloc\",\n+        \"string\",\n+        \"String\"\n+      ],\n+      \"kind\": \"struct\"\n+    },\n+    \"1:6600\": {\n+      \"crate_id\": 1,\n+      \"path\": [\n+        \"std\",\n+        \"collections\",\n+        \"hash\",\n+        \"map\",\n+        \"HashMap\"\n+      ],\n+      \"kind\": \"struct\"\n+    }\n+  },\n+  \"external_crates\": {\n+    \"1\": {\n+      \"name\": \"std\"\n+    },\n+    \"5\": {\n+      \"name\": \"alloc\"\n+    }\n+  },\n+  \"format_version\": 1\n+}"}, {"sha": "43fc4743503aa5348f02b06a042ae7de7fc91200", "filename": "src/test/rustdoc-json/structs.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftest%2Frustdoc-json%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstructs.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -0,0 +1,17 @@\n+use std::collections::HashMap;\n+\n+pub struct PlainEmpty {}\n+\n+pub struct Tuple(u32, String);\n+\n+pub struct Unit;\n+\n+pub struct WithPrimitives<'a> {\n+    num: u32,\n+    s: &'a str,\n+}\n+\n+pub struct WithGenerics<T, U> {\n+    stuff: Vec<T>,\n+    things: HashMap<U, U>,\n+}"}, {"sha": "eba02333c8cb2e9cffdc7a177d85a4b9214a986f", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -17,6 +17,7 @@ pub enum Mode {\n     DebugInfo,\n     Codegen,\n     Rustdoc,\n+    RustdocJson,\n     CodegenUnits,\n     Incremental,\n     RunMake,\n@@ -48,6 +49,7 @@ impl FromStr for Mode {\n             \"debuginfo\" => Ok(DebugInfo),\n             \"codegen\" => Ok(Codegen),\n             \"rustdoc\" => Ok(Rustdoc),\n+            \"rustdoc-json\" => Ok(RustdocJson),\n             \"codegen-units\" => Ok(CodegenUnits),\n             \"incremental\" => Ok(Incremental),\n             \"run-make\" => Ok(RunMake),\n@@ -70,6 +72,7 @@ impl fmt::Display for Mode {\n             DebugInfo => \"debuginfo\",\n             Codegen => \"codegen\",\n             Rustdoc => \"rustdoc\",\n+            RustdocJson => \"rustdoc-json\",\n             CodegenUnits => \"codegen-units\",\n             Incremental => \"incremental\",\n             RunMake => \"run-make\","}, {"sha": "0541548aefd6de041a723a68bdb4c520c2fbaf54", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -68,7 +68,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"mode\",\n             \"which sort of compile tests to run\",\n             \"compile-fail | run-fail | run-pass-valgrind | pretty | debug-info | codegen | rustdoc \\\n-             codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n+            | rustdoc-json | codegen-units | incremental | run-make | ui | js-doc-test | mir-opt | assembly\",\n         )\n         .reqopt(\n             \"\","}, {"sha": "e9089b4b15baa30b843018e0534cdce187505ce1", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=7dc1e852d43cb8c9e77dc1e53014f0eb85d2ebfb", "patch": "@@ -2,7 +2,7 @@\n \n use crate::common::{expected_output_path, UI_EXTENSIONS, UI_FIXED, UI_STDERR, UI_STDOUT};\n use crate::common::{output_base_dir, output_base_name, output_testname_unique};\n-use crate::common::{Assembly, Incremental, JsDocTest, MirOpt, RunMake, Ui};\n+use crate::common::{Assembly, Incremental, JsDocTest, MirOpt, RunMake, RustdocJson, Ui};\n use crate::common::{Codegen, CodegenUnits, DebugInfo, Debugger, Rustdoc};\n use crate::common::{CompareMode, FailMode, PassMode};\n use crate::common::{CompileFail, Pretty, RunFail, RunPassValgrind};\n@@ -342,6 +342,7 @@ impl<'test> TestCx<'test> {\n             DebugInfo => self.run_debuginfo_test(),\n             Codegen => self.run_codegen_test(),\n             Rustdoc => self.run_rustdoc_test(),\n+            RustdocJson => self.run_rustdoc_json_test(),\n             CodegenUnits => self.run_codegen_units_test(),\n             Incremental => self.run_incremental_test(),\n             RunMake => self.run_rmake_test(),\n@@ -1600,6 +1601,10 @@ impl<'test> TestCx<'test> {\n             .arg(&self.testpaths.file)\n             .args(&self.props.compile_flags);\n \n+        if self.config.mode == RustdocJson {\n+            rustdoc.arg(\"--output-format\").arg(\"json\");\n+        }\n+\n         if let Some(ref linker) = self.config.linker {\n             rustdoc.arg(format!(\"-Clinker={}\", linker));\n         }\n@@ -1887,7 +1892,9 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn is_rustdoc(&self) -> bool {\n-        self.config.src_base.ends_with(\"rustdoc-ui\") || self.config.src_base.ends_with(\"rustdoc-js\")\n+        self.config.src_base.ends_with(\"rustdoc-ui\")\n+            || self.config.src_base.ends_with(\"rustdoc-js\")\n+            || self.config.src_base.ends_with(\"rustdoc-json\")\n     }\n \n     fn make_compile_args(\n@@ -1968,8 +1975,8 @@ impl<'test> TestCx<'test> {\n \n                 rustc.arg(dir_opt);\n             }\n-            RunFail | RunPassValgrind | Pretty | DebugInfo | Codegen | Rustdoc | RunMake\n-            | CodegenUnits | JsDocTest | Assembly => {\n+            RunFail | RunPassValgrind | Pretty | DebugInfo | Codegen | Rustdoc | RustdocJson\n+            | RunMake | CodegenUnits | JsDocTest | Assembly => {\n                 // do not use JSON output\n             }\n         }\n@@ -2466,6 +2473,48 @@ impl<'test> TestCx<'test> {\n         eprintln!(\"{}\", String::from_utf8_lossy(&output.stderr));\n     }\n \n+    fn run_rustdoc_json_test(&self) {\n+        //FIXME: Add bless option.\n+\n+        assert!(self.revision.is_none(), \"revisions not relevant here\");\n+\n+        let out_dir = self.output_base_dir();\n+        let _ = fs::remove_dir_all(&out_dir);\n+        create_dir_all(&out_dir).unwrap();\n+\n+        let proc_res = self.document(&out_dir);\n+        if !proc_res.status.success() {\n+            self.fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n+        }\n+\n+        let root = self.config.find_rust_src_root().unwrap();\n+        let mut json_out = out_dir.join(self.testpaths.file.file_stem().unwrap());\n+        json_out.set_extension(\"json\");\n+        let res = self.cmd2procres(\n+            Command::new(&self.config.docck_python)\n+                .arg(root.join(\"src/test/rustdoc-json/check_missing_items.py\"))\n+                .arg(&json_out),\n+        );\n+\n+        if !res.status.success() {\n+            self.fatal_proc_rec(\"check_missing_items failed!\", &res);\n+        }\n+\n+        let mut expected = self.testpaths.file.clone();\n+        expected.set_extension(\"expected\");\n+        let res = self.cmd2procres(\n+            Command::new(&self.config.docck_python)\n+                .arg(root.join(\"src/test/rustdoc-json/compare.py\"))\n+                .arg(&expected)\n+                .arg(&json_out)\n+                .arg(&expected.parent().unwrap()),\n+        );\n+\n+        if !res.status.success() {\n+            self.fatal_proc_rec(\"compare failed!\", &res);\n+        }\n+    }\n+\n     fn get_lines<P: AsRef<Path>>(\n         &self,\n         path: &P,"}]}