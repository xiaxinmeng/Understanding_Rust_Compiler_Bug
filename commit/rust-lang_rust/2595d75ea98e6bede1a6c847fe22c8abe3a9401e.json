{"sha": "2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1OTVkNzVlYTk4ZTZiZWRlMWE2Yzg0N2ZlMjJjOGFiZTNhOTQwMWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-27T12:04:54Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-02T12:09:25Z"}, "message": "Introduce NonterminalKind\n\nIt encapsulate the (part of) the interface between the parser and\nmacro by example (macro_rules) parser.\n\nThe second bit is somewhat more general `parse_ast_fragment`, which is\nthe reason why we keep some `parse_xxx` functions as public.", "tree": {"sha": "f57df0b05414a96442dc90894acb44993a629027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f57df0b05414a96442dc90894acb44993a629027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "html_url": "https://github.com/rust-lang/rust/commit/2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe1e3b641abbede6230e3931d14f0d43e5b8e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe1e3b641abbede6230e3931d14f0d43e5b8e54", "html_url": "https://github.com/rust-lang/rust/commit/dfe1e3b641abbede6230e3931d14f0d43e5b8e54"}], "stats": {"total": 442, "additions": 231, "deletions": 211}, "files": [{"sha": "1d26a60f90f4402ea704ae494c9e8ba3346d3c5a", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -760,6 +760,44 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+#[derive(Copy, Clone)]\n+pub enum NonterminalKind {\n+    Item,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Expr,\n+    Ty,\n+    Ident,\n+    Lifetime,\n+    Literal,\n+    Meta,\n+    Path,\n+    Vis,\n+    TT,\n+}\n+\n+impl NonterminalKind {\n+    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+        Some(match symbol {\n+            sym::item => NonterminalKind::Item,\n+            sym::block => NonterminalKind::Block,\n+            sym::stmt => NonterminalKind::Stmt,\n+            sym::pat => NonterminalKind::Pat,\n+            sym::expr => NonterminalKind::Expr,\n+            sym::ty => NonterminalKind::Ty,\n+            sym::ident => NonterminalKind::Ident,\n+            sym::lifetime => NonterminalKind::Lifetime,\n+            sym::literal => NonterminalKind::Literal,\n+            sym::meta => NonterminalKind::Meta,\n+            sym::path => NonterminalKind::Path,\n+            sym::vis => NonterminalKind::Vis,\n+            sym::tt => NonterminalKind::TT,\n+            _ => return None,\n+        })\n+    }\n+}\n+\n impl Nonterminal {\n     fn span(&self) -> Span {\n         match self {"}, {"sha": "d0d2e5a2124a70c79d8a3e5e4847e309710d659a", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 18, "deletions": 185, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -76,15 +76,11 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n+use rustc_ast::token::{self, DocComment, Nonterminal, NonterminalKind, Token};\n+use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, MacroRulesNormalizedIdent};\n \n-use rustc_errors::PResult;\n-use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -576,7 +572,8 @@ fn inner_parse_loop<'root, 'tt>(\n                 TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(token, id.name) {\n+                    let kind = NonterminalKind::from_symbol(id.name).unwrap();\n+                    if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -738,8 +735,19 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let mut item = bb_items.pop().unwrap();\n             if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n-                    Err(()) => return ErrorReported,\n+                let kind = NonterminalKind::from_symbol(ident.name).unwrap();\n+                let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                    Err(mut err) => {\n+                        err.span_label(\n+                            span,\n+                            format!(\n+                                \"while parsing argument for this `{}` macro fragment\",\n+                                ident.name\n+                            ),\n+                        )\n+                        .emit();\n+                        return ErrorReported;\n+                    }\n                     Ok(nt) => nt,\n                 };\n                 item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n@@ -754,178 +762,3 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n         assert!(!cur_items.is_empty());\n     }\n }\n-\n-/// The token is an identifier, but not `_`.\n-/// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n-    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n-}\n-\n-/// Checks whether a non-terminal may begin with a particular token.\n-///\n-/// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n-/// token. Be conservative (return true) if not sure.\n-fn may_begin_with(token: &Token, name: Symbol) -> bool {\n-    /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n-    fn may_be_ident(nt: &token::Nonterminal) -> bool {\n-        match *nt {\n-            token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => false,\n-            _ => true,\n-        }\n-    }\n-\n-    match name {\n-        sym::expr => {\n-            token.can_begin_expr()\n-            // This exception is here for backwards compatibility.\n-            && !token.is_keyword(kw::Let)\n-        }\n-        sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_ident(token).is_some(),\n-        sym::literal => token.can_begin_literal_maybe_minus(),\n-        sym::vis => match token.kind {\n-            // The follow-set of :vis + \"priv\" keyword + interpolated\n-            token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n-            _ => token.can_begin_type(),\n-        },\n-        sym::block => match token.kind {\n-            token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtItem(_)\n-                | token::NtPat(_)\n-                | token::NtTy(_)\n-                | token::NtIdent(..)\n-                | token::NtMeta(_)\n-                | token::NtPath(_)\n-                | token::NtVis(_) => false, // none of these may start with '{'.\n-                _ => true,\n-            },\n-            _ => false,\n-        },\n-        sym::path | sym::meta => match token.kind {\n-            token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPath(_) | token::NtMeta(_) => true,\n-                _ => may_be_ident(&nt),\n-            },\n-            _ => false,\n-        },\n-        sym::pat => match token.kind {\n-            token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n-            token::OpenDelim(token::Paren) |    // tuple pattern\n-            token::OpenDelim(token::Bracket) |  // slice pattern\n-            token::BinOp(token::And) |          // reference\n-            token::BinOp(token::Minus) |        // negative literal\n-            token::AndAnd |                     // double reference\n-            token::Literal(..) |                // literal\n-            token::DotDot |                     // range pattern (future compat)\n-            token::DotDotDot |                  // range pattern (future compat)\n-            token::ModSep |                     // path\n-            token::Lt |                         // path (UFCS constant)\n-            token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt) => may_be_ident(nt),\n-            _ => false,\n-        },\n-        sym::lifetime => match token.kind {\n-            token::Lifetime(_) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtLifetime(_) | token::NtTT(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => match token.kind {\n-            token::CloseDelim(_) => false,\n-            _ => true,\n-        },\n-    }\n-}\n-\n-/// A call to the \"black-box\" parser to parse some Rust non-terminal.\n-///\n-/// # Parameters\n-///\n-/// - `p`: the \"black-box\" parser to use\n-/// - `sp`: the `Span` we want to parse\n-/// - `name`: the name of the metavar _matcher_ we want to match (e.g., `tt`, `ident`, `block`,\n-///   etc...)\n-///\n-/// # Returns\n-///\n-/// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n-    // FIXME(Centril): Consider moving this to `parser.rs` to make\n-    // the visibilities of the methods used below `pub(super)` at most.\n-    if name == sym::tt {\n-        return Ok(token::NtTT(p.parse_token_tree()));\n-    }\n-    parse_nt_inner(p, sp, name).map_err(|mut err| {\n-        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n-            .emit()\n-    })\n-}\n-\n-fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n-    // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n-    // needs to have them force-captured here.\n-    // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n-    // which requires having captured tokens available. Since we cannot determine\n-    // in advance whether or not a proc-macro will be (transitively) invoked,\n-    // we always capture tokens for any `Nonterminal` which needs them.\n-    Ok(match name {\n-        sym::item => match p.collect_tokens(|this| this.parse_item())? {\n-            (Some(mut item), tokens) => {\n-                // If we captured tokens during parsing (due to outer attributes),\n-                // use those.\n-                if item.tokens.is_none() {\n-                    item.tokens = Some(tokens);\n-                }\n-                token::NtItem(item)\n-            }\n-            (None, _) => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n-        },\n-        sym::block => token::NtBlock(p.parse_block()?),\n-        sym::stmt => match p.parse_stmt()? {\n-            Some(s) => token::NtStmt(s),\n-            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n-        },\n-        sym::pat => token::NtPat(p.parse_pat(None)?),\n-        sym::expr => {\n-            let (mut expr, tokens) = p.collect_tokens(|this| this.parse_expr())?;\n-            // If we captured tokens during parsing (due to outer attributes),\n-            // use those.\n-            if expr.tokens.is_none() {\n-                expr.tokens = Some(tokens);\n-            }\n-            token::NtExpr(expr)\n-        }\n-        sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n-        sym::ty => token::NtTy(p.parse_ty()?),\n-        // this could be handled like a token, since it is one\n-        sym::ident => {\n-            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n-                p.bump();\n-                token::NtIdent(ident, is_raw)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n-        sym::meta => token::NtMeta(P(p.parse_attr_item()?)),\n-        sym::vis => token::NtVis(p.parse_visibility(FollowedByType::Yes)?),\n-        sym::lifetime => {\n-            if p.check_lifetime() {\n-                token::NtLifetime(p.expect_lifetime().ident)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        // this is not supposed to happen, since it has been checked\n-        // when compiling the macro.\n-        _ => p.span_bug(sp, \"invalid fragment specifier\"),\n-    })\n-}"}, {"sha": "657c72225928c63e0d15c82485f3a4288542c256", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -9,7 +9,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, NtTT, Token, TokenKind::*};\n+use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n@@ -1228,23 +1228,7 @@ fn is_legal_fragment_specifier(\n      * for checking against feature gates. See past versions of\n      * this function.\n      */\n-    match frag_name {\n-        sym::item\n-        | sym::block\n-        | sym::stmt\n-        | sym::expr\n-        | sym::pat\n-        | sym::lifetime\n-        | sym::path\n-        | sym::ty\n-        | sym::ident\n-        | sym::meta\n-        | sym::tt\n-        | sym::vis\n-        | sym::literal\n-        | kw::Invalid => true,\n-        _ => false,\n-    }\n+    NonterminalKind::from_symbol(frag_name).is_some() || frag_name == kw::Invalid\n }\n \n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {"}, {"sha": "3aec300d86d4f5dcb6bb6cf386fb3b8c9d1d64e4", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -1450,7 +1450,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub(super) fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let lo = self.token.span;"}, {"sha": "38d2bd9b7566bade2cd73a4abe247e635b6b58d5", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -1,6 +1,7 @@\n pub mod attr;\n mod expr;\n mod item;\n+mod nonterminal;\n mod pat;\n mod path;\n mod ty;\n@@ -10,6 +11,7 @@ mod generics;\n mod stmt;\n use diagnostics::Error;\n \n+\n use crate::lexer::UnmatchedBrace;\n \n use log::debug;\n@@ -958,7 +960,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> TokenTree {\n+    pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n                 let frame = mem::replace(\n@@ -1017,7 +1019,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n+    pub(crate) fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));"}, {"sha": "12139771bbfdaa172c9d4cc9f0d7026fd59ab8a1", "filename": "src/librustc_parse/parser/nonterminal.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -0,0 +1,163 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::PResult;\n+use rustc_span::symbol::{kw, Ident};\n+\n+use crate::parser::{FollowedByType, Parser, PathStyle};\n+\n+impl<'a> Parser<'a> {\n+    /// Checks whether a non-terminal may begin with a particular token.\n+    ///\n+    /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n+    /// token. Be conservative (return true) if not sure.\n+    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n+        /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n+        fn may_be_ident(nt: &token::Nonterminal) -> bool {\n+            match *nt {\n+                token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => {\n+                    false\n+                }\n+                _ => true,\n+            }\n+        }\n+\n+        match kind {\n+            NonterminalKind::Expr => {\n+                token.can_begin_expr()\n+                // This exception is here for backwards compatibility.\n+                && !token.is_keyword(kw::Let)\n+            }\n+            NonterminalKind::Ty => token.can_begin_type(),\n+            NonterminalKind::Ident => get_macro_ident(token).is_some(),\n+            NonterminalKind::Literal => token.can_begin_literal_maybe_minus(),\n+            NonterminalKind::Vis => match token.kind {\n+                // The follow-set of :vis + \"priv\" keyword + interpolated\n+                token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n+                _ => token.can_begin_type(),\n+            },\n+            NonterminalKind::Block => match token.kind {\n+                token::OpenDelim(token::Brace) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtItem(_)\n+                    | token::NtPat(_)\n+                    | token::NtTy(_)\n+                    | token::NtIdent(..)\n+                    | token::NtMeta(_)\n+                    | token::NtPath(_)\n+                    | token::NtVis(_) => false, // none of these may start with '{'.\n+                    _ => true,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+                token::ModSep | token::Ident(..) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtPath(_) | token::NtMeta(_) => true,\n+                    _ => may_be_ident(&nt),\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Pat => match token.kind {\n+                token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n+                token::OpenDelim(token::Paren) |    // tuple pattern\n+                token::OpenDelim(token::Bracket) |  // slice pattern\n+                token::BinOp(token::And) |          // reference\n+                token::BinOp(token::Minus) |        // negative literal\n+                token::AndAnd |                     // double reference\n+                token::Literal(..) |                // literal\n+                token::DotDot |                     // range pattern (future compat)\n+                token::DotDotDot |                  // range pattern (future compat)\n+                token::ModSep |                     // path\n+                token::Lt |                         // path (UFCS constant)\n+                token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                token::Interpolated(ref nt) => may_be_ident(nt),\n+                _ => false,\n+            },\n+            NonterminalKind::Lifetime => match token.kind {\n+                token::Lifetime(_) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtLifetime(_) | token::NtTT(_) => true,\n+                    _ => false,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => match token.kind\n+            {\n+                token::CloseDelim(_) => false,\n+                _ => true,\n+            },\n+        }\n+    }\n+\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+        // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n+        // needs to have them force-captured here.\n+        // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n+        // which requires having captured tokens available. Since we cannot determine\n+        // in advance whether or not a proc-macro will be (transitively) invoked,\n+        // we always capture tokens for any `Nonterminal` which needs them.\n+        Ok(match kind {\n+            NonterminalKind::Item => match self.collect_tokens(|this| this.parse_item())? {\n+                (Some(mut item), tokens) => {\n+                    // If we captured tokens during parsing (due to outer attributes),\n+                    // use those.\n+                    if item.tokens.is_none() {\n+                        item.tokens = Some(tokens);\n+                    }\n+                    token::NtItem(item)\n+                }\n+                (None, _) => {\n+                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                }\n+            },\n+            NonterminalKind::Block => token::NtBlock(self.parse_block()?),\n+            NonterminalKind::Stmt => match self.parse_stmt()? {\n+                Some(s) => token::NtStmt(s),\n+                None => return Err(self.struct_span_err(self.token.span, \"expected a statement\")),\n+            },\n+            NonterminalKind::Pat => token::NtPat(self.parse_pat(None)?),\n+            NonterminalKind::Expr => {\n+                let (mut expr, tokens) = self.collect_tokens(|this| this.parse_expr())?;\n+                // If we captured tokens during parsing (due to outer attributes),\n+                // use those.\n+                if expr.tokens.is_none() {\n+                    expr.tokens = Some(tokens);\n+                }\n+                token::NtExpr(expr)\n+            }\n+            NonterminalKind::Literal => token::NtLiteral(self.parse_literal_maybe_minus()?),\n+            NonterminalKind::Ty => token::NtTy(self.parse_ty()?),\n+            // this could be handled like a token, since it is one\n+            NonterminalKind::Ident => {\n+                if let Some((ident, is_raw)) = get_macro_ident(&self.token) {\n+                    self.bump();\n+                    token::NtIdent(ident, is_raw)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected ident, found {}\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+            NonterminalKind::Path => token::NtPath(self.parse_path(PathStyle::Type)?),\n+            NonterminalKind::Meta => token::NtMeta(P(self.parse_attr_item()?)),\n+            NonterminalKind::TT => token::NtTT(self.parse_token_tree()),\n+            NonterminalKind::Vis => token::NtVis(self.parse_visibility(FollowedByType::Yes)?),\n+            NonterminalKind::Lifetime => {\n+                if self.check_lifetime() {\n+                    token::NtLifetime(self.expect_lifetime().ident)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// The token is an identifier, but not `_`.\n+/// We prohibit passing `_` to macros expecting `ident` for now.\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n+}"}, {"sha": "d4e44c54b127405fdcdc4c11fe474dda129938f5", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {"}, {"sha": "5c3a5e9987324c93f4c56aab60dbd88bc4797d86", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub(super) fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n@@ -247,7 +247,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+    pub(super) fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         let (attrs, block) = self.parse_inner_attrs_and_block()?;\n         if let [.., last] = &*attrs {\n             self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);"}, {"sha": "cd66b917f232a016e9912d81c1e329dd3d784828", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2595d75ea98e6bede1a6c847fe22c8abe3a9401e/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=2595d75ea98e6bede1a6c847fe22c8abe3a9401e", "patch": "@@ -610,13 +610,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_lifetime(&mut self) -> bool {\n+    pub(super) fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()\n     }\n \n     /// Parses a single lifetime `'a` or panics.\n-    pub fn expect_lifetime(&mut self) -> Lifetime {\n+    pub(super) fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n             self.bump();\n             Lifetime { ident, id: ast::DUMMY_NODE_ID }"}]}