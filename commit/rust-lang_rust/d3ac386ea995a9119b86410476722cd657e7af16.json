{"sha": "d3ac386ea995a9119b86410476722cd657e7af16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYWMzODZlYTk5NWE5MTE5Yjg2NDEwNDc2NzIyY2Q2NTdlN2FmMTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-04T01:31:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-04T01:31:09Z"}, "message": "auto merge of #16139 : michaelwoerister/rust/rlib-bc-versioning, r=alexcrichton\n\nBefore this commit, the LLVM IR of exported items was simply zip-compressed and stored as an object file inside rlib archives. This commit adds a header to this \"object\" containing a file identifier and a format version number so the compiler can deal with changes in the way bytecode objects are stored within rlibs.\r\n\r\nWhile updating the format of bytecode objects, this commit also worksaround a problem in LLDB which could not handle odd-sized objects within archives before mid-2014.\r\n\r\nFixes #15950.", "tree": {"sha": "1177e450d39432bd8e4afcc485c465e59b5a142e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1177e450d39432bd8e4afcc485c465e59b5a142e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3ac386ea995a9119b86410476722cd657e7af16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ac386ea995a9119b86410476722cd657e7af16", "html_url": "https://github.com/rust-lang/rust/commit/d3ac386ea995a9119b86410476722cd657e7af16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3ac386ea995a9119b86410476722cd657e7af16/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25741603fe3d5caebda7d41babb7eb0c265dfc70", "url": "https://api.github.com/repos/rust-lang/rust/commits/25741603fe3d5caebda7d41babb7eb0c265dfc70", "html_url": "https://github.com/rust-lang/rust/commit/25741603fe3d5caebda7d41babb7eb0c265dfc70"}, {"sha": "ff0fa8f1d16763f178df488b473ec2ab37da7429", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0fa8f1d16763f178df488b473ec2ab37da7429", "html_url": "https://github.com/rust-lang/rust/commit/ff0fa8f1d16763f178df488b473ec2ab37da7429"}], "stats": {"total": 206, "additions": 168, "deletions": 38}, "files": [{"sha": "0909765414964c7fcd390031ffa6aacc8fa86064", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d3ac386ea995a9119b86410476722cd657e7af16/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ac386ea995a9119b86410476722cd657e7af16/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d3ac386ea995a9119b86410476722cd657e7af16", "patch": "@@ -32,6 +32,7 @@ use std::char;\n use std::collections::HashSet;\n use std::io::{fs, TempDir, Command};\n use std::io;\n+use std::mem;\n use std::ptr;\n use std::str;\n use std::string::String;\n@@ -45,6 +46,36 @@ use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::parse::token;\n \n+// RLIB LLVM-BYTECODE OBJECT LAYOUT\n+// Version 1\n+// Bytes    Data\n+// 0..10    \"RUST_OBJECT\" encoded in ASCII\n+// 11..14   format version as little-endian u32\n+// 15..22   size in bytes of deflate compressed LLVM bitcode as\n+//          little-endian u64\n+// 23..     compressed LLVM bitcode\n+\n+// This is the \"magic number\" expected at the beginning of a LLVM bytecode\n+// object in an rlib.\n+pub static RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n+\n+// The version number this compiler will write to bytecode objects in rlibs\n+pub static RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n+\n+// The offset in bytes the bytecode object format version number can be found at\n+pub static RLIB_BYTECODE_OBJECT_VERSION_OFFSET: uint = 11;\n+\n+// The offset in bytes the size of the compressed bytecode can be found at in\n+// format version 1\n+pub static RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: uint =\n+    RLIB_BYTECODE_OBJECT_VERSION_OFFSET + 4;\n+\n+// The offset in bytes the compressed LLVM bytecode can be found at in format\n+// version 1\n+pub static RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n+    RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n+\n+\n #[deriving(Clone, PartialEq, PartialOrd, Ord, Eq)]\n pub enum OutputType {\n     OutputTypeBitcode,\n@@ -1103,28 +1134,44 @@ fn link_rlib<'a>(sess: &'a Session,\n             // is never exactly 16 bytes long by adding a 16 byte extension to\n             // it. This is to work around a bug in LLDB that would cause it to\n             // crash if the name of a file in an archive was exactly 16 bytes.\n-            let bc = obj_filename.with_extension(\"bc\");\n-            let bc_deflated = obj_filename.with_extension(\"bytecode.deflate\");\n-            match fs::File::open(&bc).read_to_end().and_then(|data| {\n-                fs::File::create(&bc_deflated)\n-                    .write(match flate::deflate_bytes(data.as_slice()) {\n-                        Some(compressed) => compressed,\n-                        None => sess.fatal(\"failed to compress bytecode\")\n-                     }.as_slice())\n-            }) {\n+            let bc_filename = obj_filename.with_extension(\"bc\");\n+            let bc_deflated_filename = obj_filename.with_extension(\"bytecode.deflate\");\n+\n+            let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n+                Ok(buffer) => buffer,\n+                Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n+                                             e).as_slice())\n+            };\n+\n+            let bc_data_deflated = match flate::deflate_bytes(bc_data.as_slice()) {\n+                Some(compressed) => compressed,\n+                None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n+                                           bc_filename.display()).as_slice())\n+            };\n+\n+            let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n+                Ok(file) => file,\n+                Err(e) => {\n+                    sess.fatal(format!(\"failed to create compressed bytecode \\\n+                                        file: {}\", e).as_slice())\n+                }\n+            };\n+\n+            match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n+                                                bc_data_deflated.as_slice()) {\n                 Ok(()) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write compressed bytecode: \\\n-                                      {}\",\n-                                     e).as_slice());\n+                                      {}\", e).as_slice());\n                     sess.abort_if_errors()\n                 }\n-            }\n-            ab.add_file(&bc_deflated).unwrap();\n-            remove(sess, &bc_deflated);\n+            };\n+\n+            ab.add_file(&bc_deflated_filename).unwrap();\n+            remove(sess, &bc_deflated_filename);\n             if !sess.opts.cg.save_temps &&\n                !sess.opts.output_types.contains(&OutputTypeBitcode) {\n-                remove(sess, &bc);\n+                remove(sess, &bc_filename);\n             }\n         }\n \n@@ -1134,6 +1181,32 @@ fn link_rlib<'a>(sess: &'a Session,\n     ab\n }\n \n+fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n+                                            bc_data_deflated: &[u8])\n+                                         -> ::std::io::IoResult<()> {\n+    let bc_data_deflated_size: u64 = bc_data_deflated.as_slice().len() as u64;\n+\n+    try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n+    try! { writer.write_le_u32(1) };\n+    try! { writer.write_le_u64(bc_data_deflated_size) };\n+    try! { writer.write(bc_data_deflated.as_slice()) };\n+\n+    let number_of_bytes_written_so_far =\n+        RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n+        mem::size_of_val(&RLIB_BYTECODE_OBJECT_VERSION) + // version\n+        mem::size_of_val(&bc_data_deflated_size) +        // data size field\n+        bc_data_deflated_size as uint;                    // actual data\n+\n+    // If the number of bytes written to the object so far is odd, add a\n+    // padding byte to make it even. This works around a crash bug in LLDB\n+    // (see issue #15950)\n+    if number_of_bytes_written_so_far % 2 == 1 {\n+        try! { writer.write_u8(0) };\n+    }\n+\n+    return Ok(());\n+}\n+\n // Create a static archive\n //\n // This is essentially the same thing as an rlib, but it also involves adding"}, {"sha": "4212513f56a400b636764d77e76a45550bfc6c6a", "filename": "src/librustc/back/lto.rs", "status": "modified", "additions": 80, "deletions": 23, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/d3ac386ea995a9119b86410476722cd657e7af16/src%2Flibrustc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ac386ea995a9119b86410476722cd657e7af16/src%2Flibrustc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flto.rs?ref=d3ac386ea995a9119b86410476722cd657e7af16", "patch": "@@ -20,6 +20,8 @@ use util::common::time;\n use libc;\n use flate;\n \n+use std::mem;\n+\n pub fn run(sess: &session::Session, llmod: ModuleRef,\n            tm: TargetMachineRef, reachable: &[String]) {\n     if sess.opts.cg.prefer_dynamic {\n@@ -57,36 +59,66 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let file = path.filename_str().unwrap();\n         let file = file.slice(3, file.len() - 5); // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n-        let bc = time(sess.time_passes(),\n-                      format!(\"read {}.bytecode.deflate\", name).as_slice(),\n-                      (),\n-                      |_| {\n-                          archive.read(format!(\"{}.bytecode.deflate\",\n-                                               file).as_slice())\n-                      });\n-        let bc = bc.expect(\"missing compressed bytecode in archive!\");\n-        let bc = time(sess.time_passes(),\n-                      format!(\"inflate {}.bc\", file).as_slice(),\n-                      (),\n-                      |_| {\n-                          match flate::inflate_bytes(bc) {\n-                              Some(bc) => bc,\n-                              None => {\n-                                  sess.fatal(format!(\"failed to decompress \\\n-                                                      bc of `{}`\",\n-                                                     name).as_slice())\n-                              }\n-                          }\n-                      });\n-        let ptr = bc.as_slice().as_ptr();\n+        let bc_encoded = time(sess.time_passes(),\n+                              format!(\"read {}.bytecode.deflate\", name).as_slice(),\n+                              (),\n+                              |_| {\n+                                  archive.read(format!(\"{}.bytecode.deflate\",\n+                                                       file).as_slice())\n+                              });\n+        let bc_encoded = bc_encoded.expect(\"missing compressed bytecode in archive!\");\n+        let bc_extractor = if is_versioned_bytecode_format(bc_encoded) {\n+            |_| {\n+                // Read the version\n+                let version = extract_bytecode_format_version(bc_encoded);\n+\n+                if version == 1 {\n+                    // The only version existing so far\n+                    let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n+                    let compressed_data = bc_encoded.slice(\n+                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET,\n+                        link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint);\n+\n+                    match flate::inflate_bytes(compressed_data) {\n+                        Some(inflated) => inflated,\n+                        None => {\n+                            sess.fatal(format!(\"failed to decompress bc of `{}`\",\n+                                               name).as_slice())\n+                        }\n+                    }\n+                } else {\n+                    sess.fatal(format!(\"Unsupported bytecode format version {}\",\n+                                       version).as_slice())\n+                }\n+            }\n+        } else {\n+            // the object must be in the old, pre-versioning format, so simply\n+            // inflate everything and let LLVM decide if it can make sense of it\n+            |_| {\n+                match flate::inflate_bytes(bc_encoded) {\n+                    Some(bc) => bc,\n+                    None => {\n+                        sess.fatal(format!(\"failed to decompress bc of `{}`\",\n+                                           name).as_slice())\n+                    }\n+                }\n+            }\n+        };\n+\n+        let bc_decoded = time(sess.time_passes(),\n+                              format!(\"decode {}.bc\", file).as_slice(),\n+                              (),\n+                              bc_extractor);\n+\n+        let ptr = bc_decoded.as_slice().as_ptr();\n         debug!(\"linking {}\", name);\n         time(sess.time_passes(),\n              format!(\"ll link {}\", name).as_slice(),\n              (),\n              |()| unsafe {\n             if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                     ptr as *const libc::c_char,\n-                                                    bc.len() as libc::size_t) {\n+                                                    bc_decoded.len() as libc::size_t) {\n                 link::llvm_err(sess,\n                                format!(\"failed to load bc of `{}`\",\n                                        name.as_slice()));\n@@ -137,3 +169,28 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n     }\n     debug!(\"lto done\");\n }\n+\n+fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n+    let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n+    return bc.len() > magic_id_byte_count &&\n+           bc.slice(0, magic_id_byte_count) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+}\n+\n+fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n+    return read_from_le_bytes::<u32>(bc, link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET);\n+}\n+\n+fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n+    return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n+}\n+\n+fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n+    let byte_data = bytes.slice(position_in_bytes,\n+                                position_in_bytes + mem::size_of::<T>());\n+    let data = unsafe {\n+        *(byte_data.as_ptr() as *const T)\n+    };\n+\n+    Int::from_le(data)\n+}\n+"}]}