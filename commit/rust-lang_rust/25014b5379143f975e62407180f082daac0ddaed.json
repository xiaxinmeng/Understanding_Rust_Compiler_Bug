{"sha": "25014b5379143f975e62407180f082daac0ddaed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MDE0YjUzNzkxNDNmOTc1ZTYyNDA3MTgwZjA4MmRhYWMwZGRhZWQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-16T11:16:04Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-16T12:44:40Z"}, "message": "rustc_data_structures: Add implementation of 128 bit SipHash.", "tree": {"sha": "26044eed964f8d3a8b1d125ea82813781ffb3336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26044eed964f8d3a8b1d125ea82813781ffb3336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25014b5379143f975e62407180f082daac0ddaed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25014b5379143f975e62407180f082daac0ddaed", "html_url": "https://github.com/rust-lang/rust/commit/25014b5379143f975e62407180f082daac0ddaed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25014b5379143f975e62407180f082daac0ddaed/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe7c87eefe4a15b7e83feb6b8962ae15452c16c", "html_url": "https://github.com/rust-lang/rust/commit/abe7c87eefe4a15b7e83feb6b8962ae15452c16c"}], "stats": {"total": 535, "additions": 535, "deletions": 0}, "files": [{"sha": "d82de082da6d0d84cc4cd76b32bf08658bbe8a49", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25014b5379143f975e62407180f082daac0ddaed/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25014b5379143f975e62407180f082daac0ddaed/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=25014b5379143f975e62407180f082daac0ddaed", "patch": "@@ -72,6 +72,7 @@ struct Hasher<S: Sip> {\n }\n \n #[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n struct State {\n     // v0, v2 and v1, v3 show up in pairs in the algorithm,\n     // and simd implementations of SipHash will use vectors"}, {"sha": "1277123d700dc203c46d23f9b3978a5fa41139ae", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25014b5379143f975e62407180f082daac0ddaed/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25014b5379143f975e62407180f082daac0ddaed/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=25014b5379143f975e62407180f082daac0ddaed", "patch": "@@ -54,6 +54,7 @@ pub mod graph;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;\n+pub mod sip128;\n pub mod snapshot_map;\n pub mod snapshot_vec;\n pub mod stable_hasher;"}, {"sha": "1f0b0d9cbfb0b54f9c9a6af05aa598805b1c736a", "filename": "src/librustc_data_structures/sip128.rs", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/25014b5379143f975e62407180f082daac0ddaed/src%2Flibrustc_data_structures%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25014b5379143f975e62407180f082daac0ddaed/src%2Flibrustc_data_structures%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsip128.rs?ref=25014b5379143f975e62407180f082daac0ddaed", "patch": "@@ -0,0 +1,533 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is a copy of `core::hash::sip` adapted to providing 128 bit hashes.\n+\n+use std::cmp;\n+use std::hash::Hasher;\n+use std::slice;\n+use std::ptr;\n+use std::mem;\n+\n+#[derive(Debug, Clone)]\n+pub struct SipHasher128 {\n+    k0: u64,\n+    k1: u64,\n+    length: usize, // how many bytes we've processed\n+    state: State, // hash State\n+    tail: u64, // unprocessed bytes le\n+    ntail: usize, // how many bytes in tail are valid\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+#[repr(C)]\n+struct State {\n+    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n+    // and simd implementations of SipHash will use vectors\n+    // of v02 and v13. By placing them in this order in the struct,\n+    // the compiler can pick up on just a few simd optimizations by itself.\n+    v0: u64,\n+    v2: u64,\n+    v1: u64,\n+    v3: u64,\n+}\n+\n+macro_rules! compress {\n+    ($state:expr) => ({\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    });\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n+    ({\n+        $v0 = $v0.wrapping_add($v1); $v1 = $v1.rotate_left(13); $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3); $v3 = $v3.rotate_left(16); $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3); $v3 = $v3.rotate_left(21); $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1); $v1 = $v1.rotate_left(17); $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n+    });\n+}\n+\n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) =>\n+    ({\n+       debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+       let mut data = 0 as $int_ty;\n+       ptr::copy_nonoverlapping($buf.get_unchecked($i),\n+                                &mut data as *mut _ as *mut u8,\n+                                mem::size_of::<$int_ty>());\n+       data.to_le()\n+    });\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = load_int_le!(buf, start + i, u32) as u64;\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n+\n+impl SipHasher128 {\n+    #[inline]\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher128 {\n+        let mut state = SipHasher128 {\n+            k0: key0,\n+            k1: key1,\n+            length: 0,\n+            state: State {\n+                v0: 0,\n+                v1: 0,\n+                v2: 0,\n+                v3: 0,\n+            },\n+            tail: 0,\n+            ntail: 0,\n+        };\n+        state.reset();\n+        state\n+    }\n+\n+    #[inline]\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.state.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+\n+        // This is only done in the 128 bit version:\n+        self.state.v1 ^= 0xee;\n+    }\n+\n+    // Specialized write function that is only valid for buffers with len <= 8.\n+    // It's used to force inlining of write_u8 and write_usize, those would normally be inlined\n+    // except for composite types (that includes slices and str hashing because of delimiter).\n+    // Without this extra push the compiler is very reluctant to inline delimiter writes,\n+    // degrading performance substantially for the most common use cases.\n+    #[inline]\n+    fn short_write(&mut self, msg: &[u8]) {\n+        debug_assert!(msg.len() <= 8);\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let needed = 8 - self.ntail;\n+        let fill = cmp::min(length, needed);\n+        if fill == 8 {\n+            self.tail = unsafe { load_int_le!(msg, 0, u64) };\n+        } else {\n+            self.tail |= unsafe { u8to64_le(msg, 0, fill) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            }\n+        }\n+        self.state.v3 ^= self.tail;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= self.tail;\n+\n+        // Buffered tail is now flushed, process new input.\n+        self.ntail = length - needed;\n+        self.tail = unsafe { u8to64_le(msg, needed, self.ntail) };\n+    }\n+\n+    #[inline(always)]\n+    fn short_write_gen<T>(&mut self, x: T) {\n+        let bytes = unsafe {\n+            slice::from_raw_parts(&x as *const T as *const u8, mem::size_of::<T>())\n+        };\n+        self.short_write(bytes);\n+    }\n+\n+    #[inline]\n+    pub fn finish128(mut self) -> (u64, u64) {\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n+\n+        self.state.v3 ^= b;\n+        Sip24Rounds::c_rounds(&mut self.state);\n+        self.state.v0 ^= b;\n+\n+        self.state.v2 ^= 0xee;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _0 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+\n+        self.state.v1 ^= 0xdd;\n+        Sip24Rounds::d_rounds(&mut self.state);\n+        let _1 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+        (_0, _1)\n+    }\n+}\n+\n+impl Hasher for SipHasher128 {\n+    #[inline]\n+    fn write_u8(&mut self, i: u8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u16(&mut self, i: u16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u32(&mut self, i: u32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_u64(&mut self, i: u64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_usize(&mut self, i: usize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, i: i8) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i16(&mut self, i: i16) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i32(&mut self, i: i32) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_i64(&mut self, i: i64) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write_isize(&mut self, i: isize) {\n+        self.short_write_gen(i);\n+    }\n+\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let mut needed = 0;\n+\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << 8 * self.ntail;\n+            if length < needed {\n+                self.ntail += length;\n+                return\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                Sip24Rounds::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n+            }\n+        }\n+\n+        // Buffered tail is now flushed, process new input.\n+        let len = length - needed;\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < len - left {\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n+\n+            self.state.v3 ^= mi;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.ntail = left;\n+    }\n+\n+    fn finish(&self) -> u64 {\n+        panic!(\"SipHasher128 cannot provide valid 64 bit hashes\")\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default)]\n+struct Sip24Rounds;\n+\n+impl Sip24Rounds {\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::hash::{Hash, Hasher};\n+    use std::{slice, mem};\n+    use super::SipHasher128;\n+\n+    // Hash just the bytes of the slice, without length prefix\n+    struct Bytes<'a>(&'a [u8]);\n+\n+    impl<'a> Hash for Bytes<'a> {\n+        #[allow(unused_must_use)]\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            for byte in self.0 {\n+                state.write_u8(*byte);\n+            }\n+        }\n+    }\n+\n+    fn hash_with<T: Hash>(mut st: SipHasher128, x: &T) -> (u64, u64) {\n+        x.hash(&mut st);\n+        st.finish128()\n+    }\n+\n+    fn hash<T: Hash>(x: &T) -> (u64, u64) {\n+        hash_with(SipHasher128::new_with_keys(0, 0), x)\n+    }\n+\n+    const TEST_VECTOR : [[u8; 16]; 64] = [\n+        [0xa3,0x81,0x7f,0x04,0xba,0x25,0xa8,0xe6,0x6d,0xf6,0x72,0x14,0xc7,0x55,0x02,0x93],\n+        [0xda,0x87,0xc1,0xd8,0x6b,0x99,0xaf,0x44,0x34,0x76,0x59,0x11,0x9b,0x22,0xfc,0x45],\n+        [0x81,0x77,0x22,0x8d,0xa4,0xa4,0x5d,0xc7,0xfc,0xa3,0x8b,0xde,0xf6,0x0a,0xff,0xe4],\n+        [0x9c,0x70,0xb6,0x0c,0x52,0x67,0xa9,0x4e,0x5f,0x33,0xb6,0xb0,0x29,0x85,0xed,0x51],\n+        [0xf8,0x81,0x64,0xc1,0x2d,0x9c,0x8f,0xaf,0x7d,0x0f,0x6e,0x7c,0x7b,0xcd,0x55,0x79],\n+        [0x13,0x68,0x87,0x59,0x80,0x77,0x6f,0x88,0x54,0x52,0x7a,0x07,0x69,0x0e,0x96,0x27],\n+        [0x14,0xee,0xca,0x33,0x8b,0x20,0x86,0x13,0x48,0x5e,0xa0,0x30,0x8f,0xd7,0xa1,0x5e],\n+        [0xa1,0xf1,0xeb,0xbe,0xd8,0xdb,0xc1,0x53,0xc0,0xb8,0x4a,0xa6,0x1f,0xf0,0x82,0x39],\n+        [0x3b,0x62,0xa9,0xba,0x62,0x58,0xf5,0x61,0x0f,0x83,0xe2,0x64,0xf3,0x14,0x97,0xb4],\n+        [0x26,0x44,0x99,0x06,0x0a,0xd9,0xba,0xab,0xc4,0x7f,0x8b,0x02,0xbb,0x6d,0x71,0xed],\n+        [0x00,0x11,0x0d,0xc3,0x78,0x14,0x69,0x56,0xc9,0x54,0x47,0xd3,0xf3,0xd0,0xfb,0xba],\n+        [0x01,0x51,0xc5,0x68,0x38,0x6b,0x66,0x77,0xa2,0xb4,0xdc,0x6f,0x81,0xe5,0xdc,0x18],\n+        [0xd6,0x26,0xb2,0x66,0x90,0x5e,0xf3,0x58,0x82,0x63,0x4d,0xf6,0x85,0x32,0xc1,0x25],\n+        [0x98,0x69,0xe2,0x47,0xe9,0xc0,0x8b,0x10,0xd0,0x29,0x93,0x4f,0xc4,0xb9,0x52,0xf7],\n+        [0x31,0xfc,0xef,0xac,0x66,0xd7,0xde,0x9c,0x7e,0xc7,0x48,0x5f,0xe4,0x49,0x49,0x02],\n+        [0x54,0x93,0xe9,0x99,0x33,0xb0,0xa8,0x11,0x7e,0x08,0xec,0x0f,0x97,0xcf,0xc3,0xd9],\n+        [0x6e,0xe2,0xa4,0xca,0x67,0xb0,0x54,0xbb,0xfd,0x33,0x15,0xbf,0x85,0x23,0x05,0x77],\n+        [0x47,0x3d,0x06,0xe8,0x73,0x8d,0xb8,0x98,0x54,0xc0,0x66,0xc4,0x7a,0xe4,0x77,0x40],\n+        [0xa4,0x26,0xe5,0xe4,0x23,0xbf,0x48,0x85,0x29,0x4d,0xa4,0x81,0xfe,0xae,0xf7,0x23],\n+        [0x78,0x01,0x77,0x31,0xcf,0x65,0xfa,0xb0,0x74,0xd5,0x20,0x89,0x52,0x51,0x2e,0xb1],\n+        [0x9e,0x25,0xfc,0x83,0x3f,0x22,0x90,0x73,0x3e,0x93,0x44,0xa5,0xe8,0x38,0x39,0xeb],\n+        [0x56,0x8e,0x49,0x5a,0xbe,0x52,0x5a,0x21,0x8a,0x22,0x14,0xcd,0x3e,0x07,0x1d,0x12],\n+        [0x4a,0x29,0xb5,0x45,0x52,0xd1,0x6b,0x9a,0x46,0x9c,0x10,0x52,0x8e,0xff,0x0a,0xae],\n+        [0xc9,0xd1,0x84,0xdd,0xd5,0xa9,0xf5,0xe0,0xcf,0x8c,0xe2,0x9a,0x9a,0xbf,0x69,0x1c],\n+        [0x2d,0xb4,0x79,0xae,0x78,0xbd,0x50,0xd8,0x88,0x2a,0x8a,0x17,0x8a,0x61,0x32,0xad],\n+        [0x8e,0xce,0x5f,0x04,0x2d,0x5e,0x44,0x7b,0x50,0x51,0xb9,0xea,0xcb,0x8d,0x8f,0x6f],\n+        [0x9c,0x0b,0x53,0xb4,0xb3,0xc3,0x07,0xe8,0x7e,0xae,0xe0,0x86,0x78,0x14,0x1f,0x66],\n+        [0xab,0xf2,0x48,0xaf,0x69,0xa6,0xea,0xe4,0xbf,0xd3,0xeb,0x2f,0x12,0x9e,0xeb,0x94],\n+        [0x06,0x64,0xda,0x16,0x68,0x57,0x4b,0x88,0xb9,0x35,0xf3,0x02,0x73,0x58,0xae,0xf4],\n+        [0xaa,0x4b,0x9d,0xc4,0xbf,0x33,0x7d,0xe9,0x0c,0xd4,0xfd,0x3c,0x46,0x7c,0x6a,0xb7],\n+        [0xea,0x5c,0x7f,0x47,0x1f,0xaf,0x6b,0xde,0x2b,0x1a,0xd7,0xd4,0x68,0x6d,0x22,0x87],\n+        [0x29,0x39,0xb0,0x18,0x32,0x23,0xfa,0xfc,0x17,0x23,0xde,0x4f,0x52,0xc4,0x3d,0x35],\n+        [0x7c,0x39,0x56,0xca,0x5e,0xea,0xfc,0x3e,0x36,0x3e,0x9d,0x55,0x65,0x46,0xeb,0x68],\n+        [0x77,0xc6,0x07,0x71,0x46,0xf0,0x1c,0x32,0xb6,0xb6,0x9d,0x5f,0x4e,0xa9,0xff,0xcf],\n+        [0x37,0xa6,0x98,0x6c,0xb8,0x84,0x7e,0xdf,0x09,0x25,0xf0,0xf1,0x30,0x9b,0x54,0xde],\n+        [0xa7,0x05,0xf0,0xe6,0x9d,0xa9,0xa8,0xf9,0x07,0x24,0x1a,0x2e,0x92,0x3c,0x8c,0xc8],\n+        [0x3d,0xc4,0x7d,0x1f,0x29,0xc4,0x48,0x46,0x1e,0x9e,0x76,0xed,0x90,0x4f,0x67,0x11],\n+        [0x0d,0x62,0xbf,0x01,0xe6,0xfc,0x0e,0x1a,0x0d,0x3c,0x47,0x51,0xc5,0xd3,0x69,0x2b],\n+        [0x8c,0x03,0x46,0x8b,0xca,0x7c,0x66,0x9e,0xe4,0xfd,0x5e,0x08,0x4b,0xbe,0xe7,0xb5],\n+        [0x52,0x8a,0x5b,0xb9,0x3b,0xaf,0x2c,0x9c,0x44,0x73,0xcc,0xe5,0xd0,0xd2,0x2b,0xd9],\n+        [0xdf,0x6a,0x30,0x1e,0x95,0xc9,0x5d,0xad,0x97,0xae,0x0c,0xc8,0xc6,0x91,0x3b,0xd8],\n+        [0x80,0x11,0x89,0x90,0x2c,0x85,0x7f,0x39,0xe7,0x35,0x91,0x28,0x5e,0x70,0xb6,0xdb],\n+        [0xe6,0x17,0x34,0x6a,0xc9,0xc2,0x31,0xbb,0x36,0x50,0xae,0x34,0xcc,0xca,0x0c,0x5b],\n+        [0x27,0xd9,0x34,0x37,0xef,0xb7,0x21,0xaa,0x40,0x18,0x21,0xdc,0xec,0x5a,0xdf,0x89],\n+        [0x89,0x23,0x7d,0x9d,0xed,0x9c,0x5e,0x78,0xd8,0xb1,0xc9,0xb1,0x66,0xcc,0x73,0x42],\n+        [0x4a,0x6d,0x80,0x91,0xbf,0x5e,0x7d,0x65,0x11,0x89,0xfa,0x94,0xa2,0x50,0xb1,0x4c],\n+        [0x0e,0x33,0xf9,0x60,0x55,0xe7,0xae,0x89,0x3f,0xfc,0x0e,0x3d,0xcf,0x49,0x29,0x02],\n+        [0xe6,0x1c,0x43,0x2b,0x72,0x0b,0x19,0xd1,0x8e,0xc8,0xd8,0x4b,0xdc,0x63,0x15,0x1b],\n+        [0xf7,0xe5,0xae,0xf5,0x49,0xf7,0x82,0xcf,0x37,0x90,0x55,0xa6,0x08,0x26,0x9b,0x16],\n+        [0x43,0x8d,0x03,0x0f,0xd0,0xb7,0xa5,0x4f,0xa8,0x37,0xf2,0xad,0x20,0x1a,0x64,0x03],\n+        [0xa5,0x90,0xd3,0xee,0x4f,0xbf,0x04,0xe3,0x24,0x7e,0x0d,0x27,0xf2,0x86,0x42,0x3f],\n+        [0x5f,0xe2,0xc1,0xa1,0x72,0xfe,0x93,0xc4,0xb1,0x5c,0xd3,0x7c,0xae,0xf9,0xf5,0x38],\n+        [0x2c,0x97,0x32,0x5c,0xbd,0x06,0xb3,0x6e,0xb2,0x13,0x3d,0xd0,0x8b,0x3a,0x01,0x7c],\n+        [0x92,0xc8,0x14,0x22,0x7a,0x6b,0xca,0x94,0x9f,0xf0,0x65,0x9f,0x00,0x2a,0xd3,0x9e],\n+        [0xdc,0xe8,0x50,0x11,0x0b,0xd8,0x32,0x8c,0xfb,0xd5,0x08,0x41,0xd6,0x91,0x1d,0x87],\n+        [0x67,0xf1,0x49,0x84,0xc7,0xda,0x79,0x12,0x48,0xe3,0x2b,0xb5,0x92,0x25,0x83,0xda],\n+        [0x19,0x38,0xf2,0xcf,0x72,0xd5,0x4e,0xe9,0x7e,0x94,0x16,0x6f,0xa9,0x1d,0x2a,0x36],\n+        [0x74,0x48,0x1e,0x96,0x46,0xed,0x49,0xfe,0x0f,0x62,0x24,0x30,0x16,0x04,0x69,0x8e],\n+        [0x57,0xfc,0xa5,0xde,0x98,0xa9,0xd6,0xd8,0x00,0x64,0x38,0xd0,0x58,0x3d,0x8a,0x1d],\n+        [0x9f,0xec,0xde,0x1c,0xef,0xdc,0x1c,0xbe,0xd4,0x76,0x36,0x74,0xd9,0x57,0x53,0x59],\n+        [0xe3,0x04,0x0c,0x00,0xeb,0x28,0xf1,0x53,0x66,0xca,0x73,0xcb,0xd8,0x72,0xe7,0x40],\n+        [0x76,0x97,0x00,0x9a,0x6a,0x83,0x1d,0xfe,0xcc,0xa9,0x1c,0x59,0x93,0x67,0x0f,0x7a],\n+        [0x58,0x53,0x54,0x23,0x21,0xf5,0x67,0xa0,0x05,0xd5,0x47,0xa4,0xf0,0x47,0x59,0xbd],\n+        [0x51,0x50,0xd1,0x77,0x2f,0x50,0x83,0x4a,0x50,0x3e,0x06,0x9a,0x97,0x3f,0xbd,0x7c],\n+    ];\n+\n+    // Test vector from reference implementation\n+    #[test]\n+    fn test_siphash_2_4_test_vector() {\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+\n+        let mut input: Vec<u8> = Vec::new();\n+\n+        for i in 0 .. 64 {\n+            let out = hash_with(SipHasher128::new_with_keys(k0, k1),\n+                                &Bytes(&input[..]));\n+            let expected = (\n+                ((TEST_VECTOR[i][0] as u64) <<  0) |\n+                ((TEST_VECTOR[i][1] as u64) <<  8) |\n+                ((TEST_VECTOR[i][2] as u64) << 16) |\n+                ((TEST_VECTOR[i][3] as u64) << 24) |\n+                ((TEST_VECTOR[i][4] as u64) << 32) |\n+                ((TEST_VECTOR[i][5] as u64) << 40) |\n+                ((TEST_VECTOR[i][6] as u64) << 48) |\n+                ((TEST_VECTOR[i][7] as u64) << 56),\n+\n+                ((TEST_VECTOR[i][8] as u64) <<  0) |\n+                ((TEST_VECTOR[i][9] as u64) <<  8) |\n+                ((TEST_VECTOR[i][10] as u64) << 16) |\n+                ((TEST_VECTOR[i][11] as u64) << 24) |\n+                ((TEST_VECTOR[i][12] as u64) << 32) |\n+                ((TEST_VECTOR[i][13] as u64) << 40) |\n+                ((TEST_VECTOR[i][14] as u64) << 48) |\n+                ((TEST_VECTOR[i][15] as u64) << 56),\n+            );\n+\n+            assert_eq!(out, expected);\n+            input.push(i as u8);\n+        }\n+    }\n+\n+    #[test] #[cfg(target_arch = \"arm\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86_64\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+        assert!(hash(&(val as u32)) != hash(&(val as usize)));\n+    }\n+    #[test] #[cfg(target_arch = \"x86\")]\n+    fn test_hash_usize() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+        assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+        assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n+    }\n+\n+    #[test]\n+    fn test_hash_idempotent() {\n+        let val64 = 0xdeadbeef_deadbeef_u64;\n+        assert_eq!(hash(&val64), hash(&val64));\n+        let val32 = 0xdeadbeef_u32;\n+        assert_eq!(hash(&val32), hash(&val32));\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_64() {\n+        let val = 0xdeadbeef_deadbeef_u64;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n+\n+        fn zero_byte(val: u64, byte: usize) -> u64 {\n+            assert!(byte < 8);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_bytes_dropped_32() {\n+        let val = 0xdeadbeef_u32;\n+\n+        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n+        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n+\n+        fn zero_byte(val: u32, byte: usize) -> u32 {\n+            assert!(byte < 4);\n+            val & !(0xff << (byte * 8))\n+        }\n+    }\n+\n+    #[test]\n+    fn test_hash_no_concat_alias() {\n+        let s = (\"aa\", \"bb\");\n+        let t = (\"aabb\", \"\");\n+        let u = (\"a\", \"abb\");\n+\n+        assert!(s != t && t != u);\n+        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n+\n+        let u = [1, 0, 0, 0];\n+        let v = (&u[..1], &u[1..3], &u[3..]);\n+        let w = (&u[..], &u[4..4], &u[4..4]);\n+\n+        assert!(v != w);\n+        assert!(hash(&v) != hash(&w));\n+    }\n+\n+    #[test]\n+    fn test_write_short_works() {\n+        let test_usize = 0xd0c0b0a0usize;\n+        let mut h1 = SipHasher128::new_with_keys(0, 0);\n+        h1.write_usize(test_usize);\n+        h1.write(b\"bytes\");\n+        h1.write(b\"string\");\n+        h1.write_u8(0xFFu8);\n+        h1.write_u8(0x01u8);\n+        let mut h2 = SipHasher128::new_with_keys(0, 0);\n+        h2.write(unsafe {\n+            slice::from_raw_parts(&test_usize as *const _ as *const u8,\n+                                  mem::size_of::<usize>())\n+        });\n+        h2.write(b\"bytes\");\n+        h2.write(b\"string\");\n+        h2.write(&[0xFFu8, 0x01u8]);\n+        assert_eq!(h1.finish128(), h2.finish128());\n+    }\n+\n+}"}]}