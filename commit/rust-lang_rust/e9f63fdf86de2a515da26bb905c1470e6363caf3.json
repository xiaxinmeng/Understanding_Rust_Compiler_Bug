{"sha": "e9f63fdf86de2a515da26bb905c1470e6363caf3", "node_id": "C_kwDOAAsO6NoAKGU5ZjYzZmRmODZkZTJhNTE1ZGEyNmJiOTA1YzE0NzBlNjM2M2NhZjM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-19T01:02:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-19T01:02:00Z"}, "message": "Rollup merge of #92663 - cuviper:generic-write-cursor, r=dtolnay\n\nImplement `Write for Cursor<[u8; N]>`, plus `A: Allocator` cursor support\n\nThis implements `Write for Cursor<[u8; N]>`, and also adds support for generic `A: Allocator` in `Box` and `Vec` cursors.\n\nThis was inspired by a user questioning why they couldn't write a `Cursor<[u8; N]>`:\nhttps://users.rust-lang.org/t/why-vec-and-not-u8-makes-cursor-have-write/68210\n\nRelated history:\n- #27197 switched `AsRef<[u8]>` for reading and seeking\n- #67415 tried to use `AsMut<[u8]>` for writing, but did not specialize `Vec`.", "tree": {"sha": "48775cea983a7eaa28dabbeea0148b924bd23459", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48775cea983a7eaa28dabbeea0148b924bd23459"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9f63fdf86de2a515da26bb905c1470e6363caf3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiNSuICRBK7hj4Ov3rIwAAkmwIACbcr+cO8NxTW93GihF1Ho7q\nZqzIhJLeHzW0xrjUf4yBo9qwmid7s6ZcghGRHmzwEnQF8Nz5/wBlVf+NWbP9EFbD\nXI86jQzLplj+/ELIeaVyAh+86+lprPqw7PQZ6/LFMvQ4hUVlUEk2dSHeo8EwnfPJ\nUI5WzjRO/ohm5oSKfTuiKHY+Hunvh2H4EgSTyHgkG+NT/SzgLyri1as5se5ck8mZ\n5FikmWgEvOVwYiWgMIDLvNfi3OQ2oFDay9BZ1VzD1c/jF2bqooUPICiqurmvHVky\nr0UL7HPwJubXO9lZXNQIPV6hEayCzatfwOVY7riXUhK9E3oYw1iBBLXJhN5K0b8=\n=vQpK\n-----END PGP SIGNATURE-----\n", "payload": "tree 48775cea983a7eaa28dabbeea0148b924bd23459\nparent a87590e34e18646aee82771471649761d9acf02f\nparent 7d44316bcf3fbe220412589f08befb3116328b21\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1647651720 +0100\ncommitter GitHub <noreply@github.com> 1647651720 +0100\n\nRollup merge of #92663 - cuviper:generic-write-cursor, r=dtolnay\n\nImplement `Write for Cursor<[u8; N]>`, plus `A: Allocator` cursor support\n\nThis implements `Write for Cursor<[u8; N]>`, and also adds support for generic `A: Allocator` in `Box` and `Vec` cursors.\n\nThis was inspired by a user questioning why they couldn't write a `Cursor<[u8; N]>`:\nhttps://users.rust-lang.org/t/why-vec-and-not-u8-makes-cursor-have-write/68210\n\nRelated history:\n- #27197 switched `AsRef<[u8]>` for reading and seeking\n- #67415 tried to use `AsMut<[u8]>` for writing, but did not specialize `Vec`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9f63fdf86de2a515da26bb905c1470e6363caf3", "html_url": "https://github.com/rust-lang/rust/commit/e9f63fdf86de2a515da26bb905c1470e6363caf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9f63fdf86de2a515da26bb905c1470e6363caf3/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a87590e34e18646aee82771471649761d9acf02f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a87590e34e18646aee82771471649761d9acf02f", "html_url": "https://github.com/rust-lang/rust/commit/a87590e34e18646aee82771471649761d9acf02f"}, {"sha": "7d44316bcf3fbe220412589f08befb3116328b21", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d44316bcf3fbe220412589f08befb3116328b21", "html_url": "https://github.com/rust-lang/rust/commit/7d44316bcf3fbe220412589f08befb3116328b21"}], "stats": {"total": 137, "additions": 86, "deletions": 51}, "files": [{"sha": "57f1d628f6ad994c4dea0a9fdd3736f121803b36", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e9f63fdf86de2a515da26bb905c1470e6363caf3/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f63fdf86de2a515da26bb905c1470e6363caf3/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=e9f63fdf86de2a515da26bb905c1470e6363caf3", "patch": "@@ -3,6 +3,7 @@ mod tests;\n \n use crate::io::prelude::*;\n \n+use crate::alloc::Allocator;\n use crate::cmp;\n use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n \n@@ -398,7 +399,10 @@ fn slice_write_vectored(\n }\n \n // Resizing write implementation\n-fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usize> {\n+fn vec_write<A>(pos_mut: &mut u64, vec: &mut Vec<u8, A>, buf: &[u8]) -> io::Result<usize>\n+where\n+    A: Allocator,\n+{\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n         io::const_io_error!(\n             ErrorKind::InvalidInput,\n@@ -426,11 +430,14 @@ fn vec_write(pos_mut: &mut u64, vec: &mut Vec<u8>, buf: &[u8]) -> io::Result<usi\n     Ok(buf.len())\n }\n \n-fn vec_write_vectored(\n+fn vec_write_vectored<A>(\n     pos_mut: &mut u64,\n-    vec: &mut Vec<u8>,\n+    vec: &mut Vec<u8, A>,\n     bufs: &[IoSlice<'_>],\n-) -> io::Result<usize> {\n+) -> io::Result<usize>\n+where\n+    A: Allocator,\n+{\n     let mut nwritten = 0;\n     for buf in bufs {\n         nwritten += vec_write(pos_mut, vec, buf)?;\n@@ -462,7 +469,10 @@ impl Write for Cursor<&mut [u8]> {\n }\n \n #[stable(feature = \"cursor_mut_vec\", since = \"1.25.0\")]\n-impl Write for Cursor<&mut Vec<u8>> {\n+impl<A> Write for Cursor<&mut Vec<u8, A>>\n+where\n+    A: Allocator,\n+{\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, self.inner, buf)\n     }\n@@ -483,7 +493,10 @@ impl Write for Cursor<&mut Vec<u8>> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Write for Cursor<Vec<u8>> {\n+impl<A> Write for Cursor<Vec<u8, A>>\n+where\n+    A: Allocator,\n+{\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         vec_write(&mut self.pos, &mut self.inner, buf)\n     }\n@@ -504,7 +517,33 @@ impl Write for Cursor<Vec<u8>> {\n }\n \n #[stable(feature = \"cursor_box_slice\", since = \"1.5.0\")]\n-impl Write for Cursor<Box<[u8]>> {\n+impl<A> Write for Cursor<Box<[u8], A>>\n+where\n+    A: Allocator,\n+{\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        slice_write(&mut self.pos, &mut self.inner, buf)\n+    }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        slice_write_vectored(&mut self.pos, &mut self.inner, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"cursor_array\", since = \"1.61.0\")]\n+impl<const N: usize> Write for Cursor<[u8; N]> {\n     #[inline]\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         slice_write(&mut self.pos, &mut self.inner, buf)"}, {"sha": "f1ee177b7f3bccaaef053a128053334ab8c63a58", "filename": "library/std/src/io/cursor/tests.rs", "status": "modified", "additions": 40, "deletions": 44, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e9f63fdf86de2a515da26bb905c1470e6363caf3/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9f63fdf86de2a515da26bb905c1470e6363caf3/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs?ref=e9f63fdf86de2a515da26bb905c1470e6363caf3", "patch": "@@ -50,9 +50,11 @@ fn test_mem_mut_writer() {\n     assert_eq!(&writer.get_ref()[..], b);\n }\n \n-#[test]\n-fn test_box_slice_writer() {\n-    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+fn test_slice_writer<T>(writer: &mut Cursor<T>)\n+where\n+    T: AsRef<[u8]>,\n+    Cursor<T>: Write,\n+{\n     assert_eq!(writer.position(), 0);\n     assert_eq!(writer.write(&[0]).unwrap(), 1);\n     assert_eq!(writer.position(), 1);\n@@ -65,12 +67,14 @@ fn test_box_slice_writer() {\n     assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n     assert_eq!(writer.write(&[10]).unwrap(), 0);\n     let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(&**writer.get_ref(), b);\n+    assert_eq!(writer.get_ref().as_ref(), b);\n }\n \n-#[test]\n-fn test_box_slice_writer_vectored() {\n-    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+fn test_slice_writer_vectored<T>(writer: &mut Cursor<T>)\n+where\n+    T: AsRef<[u8]>,\n+    Cursor<T>: Write,\n+{\n     assert_eq!(writer.position(), 0);\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n     assert_eq!(writer.position(), 1);\n@@ -85,53 +89,45 @@ fn test_box_slice_writer_vectored() {\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n     assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n     let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(&**writer.get_ref(), b);\n+    assert_eq!(writer.get_ref().as_ref(), b);\n+}\n+\n+#[test]\n+fn test_box_slice_writer() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    test_slice_writer(&mut writer);\n+}\n+\n+#[test]\n+fn test_box_slice_writer_vectored() {\n+    let mut writer = Cursor::new(vec![0u8; 9].into_boxed_slice());\n+    test_slice_writer_vectored(&mut writer);\n+}\n+\n+#[test]\n+fn test_array_writer() {\n+    let mut writer = Cursor::new([0u8; 9]);\n+    test_slice_writer(&mut writer);\n+}\n+\n+#[test]\n+fn test_array_writer_vectored() {\n+    let mut writer = Cursor::new([0u8; 9]);\n+    test_slice_writer_vectored(&mut writer);\n }\n \n #[test]\n fn test_buf_writer() {\n     let mut buf = [0 as u8; 9];\n-    {\n-        let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write(&[0]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n-        assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write(&[8, 9]).unwrap(), 1);\n-        assert_eq!(writer.write(&[10]).unwrap(), 0);\n-    }\n-    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(buf, b);\n+    let mut writer = Cursor::new(&mut buf[..]);\n+    test_slice_writer(&mut writer);\n }\n \n #[test]\n fn test_buf_writer_vectored() {\n     let mut buf = [0 as u8; 9];\n-    {\n-        let mut writer = Cursor::new(&mut buf[..]);\n-        assert_eq!(writer.position(), 0);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[0])]).unwrap(), 1);\n-        assert_eq!(writer.position(), 1);\n-        assert_eq!(\n-            writer\n-                .write_vectored(&[IoSlice::new(&[1, 2, 3]), IoSlice::new(&[4, 5, 6, 7])],)\n-                .unwrap(),\n-            7,\n-        );\n-        assert_eq!(writer.position(), 8);\n-        assert_eq!(writer.write_vectored(&[]).unwrap(), 0);\n-        assert_eq!(writer.position(), 8);\n-\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[8, 9])]).unwrap(), 1);\n-        assert_eq!(writer.write_vectored(&[IoSlice::new(&[10])]).unwrap(), 0);\n-    }\n-    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    assert_eq!(buf, b);\n+    let mut writer = Cursor::new(&mut buf[..]);\n+    test_slice_writer_vectored(&mut writer);\n }\n \n #[test]"}]}