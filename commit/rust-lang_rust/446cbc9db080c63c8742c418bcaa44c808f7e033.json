{"sha": "446cbc9db080c63c8742c418bcaa44c808f7e033", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NmNiYzlkYjA4MGM2M2M4NzQyYzQxOGJjYWE0NGM4MDhmN2UwMzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T02:59:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T02:59:14Z"}, "message": "Auto merge of #80594 - bjorn3:abi_refactor3, r=petrochenkov\n\nVarious ABI refactorings\n\nThis includes changes to the rust abi and various refactorings that will hopefully make it easier to use the abi handling infrastructure of rustc in cg_clif. There are several refactorings that I haven't done. I am opening this draft PR to check that I haven't broken any non x86_64 architectures.\n\nr? `@ghost`", "tree": {"sha": "5765bd43ca1d0289c48f6ced5b6f613b9d47862a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5765bd43ca1d0289c48f6ced5b6f613b9d47862a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/446cbc9db080c63c8742c418bcaa44c808f7e033", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/446cbc9db080c63c8742c418bcaa44c808f7e033", "html_url": "https://github.com/rust-lang/rust/commit/446cbc9db080c63c8742c418bcaa44c808f7e033", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/446cbc9db080c63c8742c418bcaa44c808f7e033/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26c2d1f408bc1b107cbc23df5f83d23208fc1c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/26c2d1f408bc1b107cbc23df5f83d23208fc1c2e", "html_url": "https://github.com/rust-lang/rust/commit/26c2d1f408bc1b107cbc23df5f83d23208fc1c2e"}, {"sha": "fa12fdbc2974f201fcfd210e8dab74a469b26857", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa12fdbc2974f201fcfd210e8dab74a469b26857", "html_url": "https://github.com/rust-lang/rust/commit/fa12fdbc2974f201fcfd210e8dab74a469b26857"}], "stats": {"total": 213, "additions": 118, "deletions": 95}, "files": [{"sha": "de5158ab073f74a0c0fcfcf8876ecccf2e075cd6", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/446cbc9db080c63c8742c418bcaa44c808f7e033/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/446cbc9db080c63c8742c418bcaa44c808f7e033/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=446cbc9db080c63c8742c418bcaa44c808f7e033", "patch": "@@ -3551,7 +3551,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"rustc_ast\",\n  \"rustc_span\",\n- \"rustc_target\",\n  \"tracing\",\n ]\n "}, {"sha": "6ea942a2f3018a4a86b90f80952538934d679262", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=446cbc9db080c63c8742c418bcaa44c808f7e033", "patch": "@@ -11,4 +11,3 @@ doctest = false\n tracing = \"0.1\"\n rustc_span = { path = \"../rustc_span\" }\n rustc_ast = { path = \"../rustc_ast\" }\n-rustc_target = { path = \"../rustc_target\" }"}, {"sha": "ef467ed6514549a834bf8872ee11ce06c891a478", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=446cbc9db080c63c8742c418bcaa44c808f7e033", "patch": "@@ -2514,7 +2514,7 @@ where\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n+        make_self_ptr_thin: bool,\n     ) -> Self;\n     fn adjust_for_abi(&mut self, cx: &C, abi: SpecAbi);\n }\n@@ -2574,9 +2574,7 @@ where\n         // Assume that fn pointers may always unwind\n         let codegen_fn_attr_flags = CodegenFnAttrFlags::UNWIND;\n \n-        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, |ty, _| {\n-            ArgAbi::new(cx.layout_of(ty))\n-        })\n+        call::FnAbi::new_internal(cx, sig, extra_args, None, codegen_fn_attr_flags, false)\n     }\n \n     fn of_instance(cx: &C, instance: ty::Instance<'tcx>, extra_args: &[Ty<'tcx>]) -> Self {\n@@ -2590,55 +2588,14 @@ where\n \n         let attrs = cx.tcx().codegen_fn_attrs(instance.def_id()).flags;\n \n-        call::FnAbi::new_internal(cx, sig, extra_args, caller_location, attrs, |ty, arg_idx| {\n-            let mut layout = cx.layout_of(ty);\n-            // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n-            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n-            if let (ty::InstanceDef::Virtual(..), Some(0)) = (&instance.def, arg_idx) {\n-                let fat_pointer_ty = if layout.is_unsized() {\n-                    // unsized `self` is passed as a pointer to `self`\n-                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n-                    cx.tcx().mk_mut_ptr(layout.ty)\n-                } else {\n-                    match layout.abi {\n-                        Abi::ScalarPair(..) => (),\n-                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n-                    }\n-\n-                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n-                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n-                    // elsewhere in the compiler as a method on a `dyn Trait`.\n-                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n-                    // get a built-in pointer type\n-                    let mut fat_pointer_layout = layout;\n-                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n-                        && !fat_pointer_layout.ty.is_region_ptr()\n-                    {\n-                        for i in 0..fat_pointer_layout.fields.count() {\n-                            let field_layout = fat_pointer_layout.field(cx, i);\n-\n-                            if !field_layout.is_zst() {\n-                                fat_pointer_layout = field_layout;\n-                                continue 'descend_newtypes;\n-                            }\n-                        }\n-\n-                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n-                    }\n-\n-                    fat_pointer_layout.ty\n-                };\n-\n-                // we now have a type like `*mut RcBox<dyn Trait>`\n-                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n-                // this is understood as a special case elsewhere in the compiler\n-                let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n-                layout = cx.layout_of(unit_pointer_ty);\n-                layout.ty = fat_pointer_ty;\n-            }\n-            ArgAbi::new(layout)\n-        })\n+        call::FnAbi::new_internal(\n+            cx,\n+            sig,\n+            extra_args,\n+            caller_location,\n+            attrs,\n+            matches!(instance.def, ty::InstanceDef::Virtual(..)),\n+        )\n     }\n \n     fn new_internal(\n@@ -2647,7 +2604,7 @@ where\n         extra_args: &[Ty<'tcx>],\n         caller_location: Option<Ty<'tcx>>,\n         codegen_fn_attr_flags: CodegenFnAttrFlags,\n-        mk_arg_type: impl Fn(Ty<'tcx>, Option<usize>) -> ArgAbi<'tcx, Ty<'tcx>>,\n+        force_thin_self_ptr: bool,\n     ) -> Self {\n         debug!(\"FnAbi::new_internal({:?}, {:?})\", sig, extra_args);\n \n@@ -2778,7 +2735,23 @@ where\n \n         let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| {\n             let is_return = arg_idx.is_none();\n-            let mut arg = mk_arg_type(ty, arg_idx);\n+\n+            let layout = cx.layout_of(ty);\n+            let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n+                // Don't pass the vtable, it's not an argument of the virtual fn.\n+                // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+                // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n+                make_thin_self_ptr(cx, layout)\n+            } else {\n+                layout\n+            };\n+\n+            let mut arg = ArgAbi::new(cx, layout, |layout, scalar, offset| {\n+                let mut attrs = ArgAttributes::new();\n+                adjust_for_rust_scalar(&mut attrs, scalar, *layout, offset, is_return);\n+                attrs\n+            });\n+\n             if arg.layout.is_zst() {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n@@ -2794,30 +2767,6 @@ where\n                 }\n             }\n \n-            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n-            if !is_return && rust_abi {\n-                if let Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n-                    let mut a_attrs = ArgAttributes::new();\n-                    let mut b_attrs = ArgAttributes::new();\n-                    adjust_for_rust_scalar(&mut a_attrs, a, arg.layout, Size::ZERO, false);\n-                    adjust_for_rust_scalar(\n-                        &mut b_attrs,\n-                        b,\n-                        arg.layout,\n-                        a.value.size(cx).align_to(b.value.align(cx).abi),\n-                        false,\n-                    );\n-                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n-                    return arg;\n-                }\n-            }\n-\n-            if let Abi::Scalar(ref scalar) = arg.layout.abi {\n-                if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    adjust_for_rust_scalar(attrs, scalar, arg.layout, Size::ZERO, is_return);\n-                }\n-            }\n-\n             arg\n         };\n \n@@ -2894,9 +2843,10 @@ where\n                 let max_by_val_size = Pointer.size(cx) * 2;\n                 let size = arg.layout.size;\n \n-                if arg.layout.is_unsized() || size > max_by_val_size {\n-                    arg.make_indirect();\n-                } else {\n+                let is_indirect_not_on_stack =\n+                    matches!(arg.mode, PassMode::Indirect { on_stack: false, .. });\n+                assert!(is_indirect_not_on_stack, \"{:?}\", arg);\n+                if !arg.layout.is_unsized() && size <= max_by_val_size {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n@@ -2915,3 +2865,52 @@ where\n         }\n     }\n }\n+\n+fn make_thin_self_ptr<'tcx, C>(cx: &C, mut layout: TyAndLayout<'tcx>) -> TyAndLayout<'tcx>\n+where\n+    C: LayoutOf<Ty = Ty<'tcx>, TyAndLayout = TyAndLayout<'tcx>>\n+        + HasTyCtxt<'tcx>\n+        + HasParamEnv<'tcx>,\n+{\n+    let fat_pointer_ty = if layout.is_unsized() {\n+        // unsized `self` is passed as a pointer to `self`\n+        // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+        cx.tcx().mk_mut_ptr(layout.ty)\n+    } else {\n+        match layout.abi {\n+            Abi::ScalarPair(..) => (),\n+            _ => bug!(\"receiver type has unsupported layout: {:?}\", layout),\n+        }\n+\n+        // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+        // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+        // elsewhere in the compiler as a method on a `dyn Trait`.\n+        // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+        // get a built-in pointer type\n+        let mut fat_pointer_layout = layout;\n+        'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+            && !fat_pointer_layout.ty.is_region_ptr()\n+        {\n+            for i in 0..fat_pointer_layout.fields.count() {\n+                let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                if !field_layout.is_zst() {\n+                    fat_pointer_layout = field_layout;\n+                    continue 'descend_newtypes;\n+                }\n+            }\n+\n+            bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+        }\n+\n+        fat_pointer_layout.ty\n+    };\n+\n+    // we now have a type like `*mut RcBox<dyn Trait>`\n+    // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+    // this is understood as a special case elsewhere in the compiler\n+    let unit_pointer_ty = cx.tcx().mk_mut_ptr(cx.tcx().mk_unit());\n+    layout = cx.layout_of(unit_pointer_ty);\n+    layout.ty = fat_pointer_ty;\n+    layout\n+}"}, {"sha": "2cbd52bf3e9a7b84061ba41cdd506df0a256ff7e", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/446cbc9db080c63c8742c418bcaa44c808f7e033/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=446cbc9db080c63c8742c418bcaa44c808f7e033", "patch": "@@ -27,10 +27,16 @@ mod x86_win64;\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PassMode {\n     /// Ignore the argument.\n+    ///\n+    /// The argument is either uninhabited or a ZST.\n     Ignore,\n     /// Pass the argument directly.\n+    ///\n+    /// The argument has a layout abi of `Scalar` or `Vector`.\n     Direct(ArgAttributes),\n     /// Pass a pair's elements directly in two arguments.\n+    ///\n+    /// The argument has a layout abi of `ScalarPair`.\n     Pair(ArgAttributes, ArgAttributes),\n     /// Pass the argument after casting it, to either\n     /// a single uniform or a pair of registers.\n@@ -434,28 +440,49 @@ pub struct ArgAbi<'a, Ty> {\n }\n \n impl<'a, Ty> ArgAbi<'a, Ty> {\n-    pub fn new(layout: TyAndLayout<'a, Ty>) -> Self {\n-        ArgAbi { layout, pad: None, mode: PassMode::Direct(ArgAttributes::new()) }\n+    pub fn new(\n+        cx: &impl HasDataLayout,\n+        layout: TyAndLayout<'a, Ty>,\n+        scalar_attrs: impl Fn(&TyAndLayout<'a, Ty>, &abi::Scalar, Size) -> ArgAttributes,\n+    ) -> Self {\n+        let mode = match &layout.abi {\n+            Abi::Uninhabited => PassMode::Ignore,\n+            Abi::Scalar(scalar) => PassMode::Direct(scalar_attrs(&layout, scalar, Size::ZERO)),\n+            Abi::ScalarPair(a, b) => PassMode::Pair(\n+                scalar_attrs(&layout, a, Size::ZERO),\n+                scalar_attrs(&layout, b, a.value.size(cx).align_to(b.value.align(cx).abi)),\n+            ),\n+            Abi::Vector { .. } => PassMode::Direct(ArgAttributes::new()),\n+            Abi::Aggregate { .. } => Self::indirect_pass_mode(&layout),\n+        };\n+        ArgAbi { layout, pad: None, mode }\n     }\n \n-    pub fn make_indirect(&mut self) {\n-        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n-\n-        // Start with fresh attributes for the pointer.\n+    fn indirect_pass_mode(layout: &TyAndLayout<'a, Ty>) -> PassMode {\n         let mut attrs = ArgAttributes::new();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n         attrs.set(ArgAttribute::NoAlias).set(ArgAttribute::NoCapture).set(ArgAttribute::NonNull);\n-        attrs.pointee_size = self.layout.size;\n+        attrs.pointee_size = layout.size;\n         // FIXME(eddyb) We should be doing this, but at least on\n         // i686-pc-windows-msvc, it results in wrong stack offsets.\n-        // attrs.pointee_align = Some(self.layout.align.abi);\n+        // attrs.pointee_align = Some(layout.align.abi);\n+\n+        let extra_attrs = layout.is_unsized().then_some(ArgAttributes::new());\n \n-        let extra_attrs = self.layout.is_unsized().then_some(ArgAttributes::new());\n+        PassMode::Indirect { attrs, extra_attrs, on_stack: false }\n+    }\n+\n+    pub fn make_indirect(&mut self) {\n+        match self.mode {\n+            PassMode::Direct(_) | PassMode::Pair(_, _) => {}\n+            PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: false } => return,\n+            _ => panic!(\"Tried to make {:?} indirect\", self.mode),\n+        }\n \n-        self.mode = PassMode::Indirect { attrs, extra_attrs, on_stack: false };\n+        self.mode = Self::indirect_pass_mode(&self.layout);\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n@@ -486,7 +513,6 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n         self.mode = PassMode::Cast(target.into());\n     }\n "}]}