{"sha": "a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MjE4MmZmZGVkYWFiYjNiNzJhMTFlOGE2N2E0MTExMjRlY2I5YWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T00:28:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-17T00:28:48Z"}, "message": "Auto merge of #24420 - pnkfelix:oflo-api, r=alexcrichton\n\nFill in missing parts of Integer overflow API \r\n\r\nSee todo list at #22020", "tree": {"sha": "c1676995fc0a56d04a42805b17309d74fd2fff87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1676995fc0a56d04a42805b17309d74fd2fff87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "html_url": "https://github.com/rust-lang/rust/commit/a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1014ac44f6271a55249b0488a2ce1cc49deed338", "url": "https://api.github.com/repos/rust-lang/rust/commits/1014ac44f6271a55249b0488a2ce1cc49deed338", "html_url": "https://github.com/rust-lang/rust/commit/1014ac44f6271a55249b0488a2ce1cc49deed338"}, {"sha": "4f678509649a59daa17dc968b2aeb1023fb23c0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f678509649a59daa17dc968b2aeb1023fb23c0f", "html_url": "https://github.com/rust-lang/rust/commit/4f678509649a59daa17dc968b2aeb1023fb23c0f"}], "stats": {"total": 393, "additions": 392, "deletions": 1}, "files": [{"sha": "c7714afc4fa263b7435b2e8880fa33880c0cb977", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "patch": "@@ -1219,6 +1219,66 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// divides `MIN / -1` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is equivalent\n+        /// to `-MIN`, a positive value that is too large to represent\n+        /// in the type. In such a case, this function returns `MIN`\n+        /// itself..\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_div(self, rhs: $T) -> $T {\n+            self.overflowing_div(rhs).0\n+        }\n+\n+        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Such wrap-around never actually occurs mathematically;\n+        /// implementation artifacts make `x % y` illegal for `MIN /\n+        /// -1` on a signed type illegal (where `MIN` is the negative\n+        /// minimal value). In such a case, this function returns `0`.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+            self.overflowing_rem(rhs).0\n+        }\n+\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// negates `MIN` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is a positive\n+        /// value that is too large to represent in the type. In such\n+        /// a case, this function returns `MIN` itself.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_neg(self) -> $T {\n+            self.overflowing_neg().0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+            self.overflowing_shl(rhs).0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+            self.overflowing_shr(rhs).0\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples\n@@ -1739,6 +1799,66 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Wrapping (modular) division. Computes `floor(self / other)`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// divides `MIN / -1` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is equivalent\n+        /// to `-MIN`, a positive value that is too large to represent\n+        /// in the type. In such a case, this function returns `MIN`\n+        /// itself..\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_div(self, rhs: $T) -> $T {\n+            self.overflowing_div(rhs).0\n+        }\n+\n+        /// Wrapping (modular) remainder. Computes `self % other`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// Such wrap-around never actually occurs mathematically;\n+        /// implementation artifacts make `x % y` illegal for `MIN /\n+        /// -1` on a signed type illegal (where `MIN` is the negative\n+        /// minimal value). In such a case, this function returns `0`.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+            self.overflowing_rem(rhs).0\n+        }\n+\n+        /// Wrapping (modular) negation. Computes `-self`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one\n+        /// negates `MIN` on a signed type (where `MIN` is the\n+        /// negative minimal value for the type); this is a positive\n+        /// value that is too large to represent in the type. In such\n+        /// a case, this function returns `MIN` itself.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_neg(self) -> $T {\n+            self.overflowing_neg().0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+            self.overflowing_shl(rhs).0\n+        }\n+\n+        /// Panic-free bitwise shift-left; yields `self >> mask(rhs)`,\n+        /// where `mask` removes any high-order bits of `rhs` that\n+        /// would cause the shift to exceed the bitwidth of the type.\n+        #[unstable(feature = \"core\", since = \"1.0.0\")]\n+        #[inline(always)]\n+        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+            self.overflowing_shr(rhs).0\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples"}, {"sha": "aa84708816b8717b2eb8d035783eb01a37296721", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "patch": "@@ -48,6 +48,7 @@ pub trait OverflowingOps {\n \n     fn overflowing_div(self, rhs: Self) -> (Self, bool);\n     fn overflowing_rem(self, rhs: Self) -> (Self, bool);\n+    fn overflowing_neg(self) -> (Self, bool);\n \n     fn overflowing_shl(self, rhs: u32) -> (Self, bool);\n     fn overflowing_shr(self, rhs: u32) -> (Self, bool);\n@@ -231,7 +232,7 @@ macro_rules! signed_overflowing_impl {\n             #[inline(always)]\n             fn overflowing_div(self, rhs: $t) -> ($t, bool) {\n                 if self == $t::MIN && rhs == -1 {\n-                    (1, true)\n+                    (self, true)\n                 } else {\n                     (self/rhs, false)\n                 }\n@@ -255,6 +256,15 @@ macro_rules! signed_overflowing_impl {\n                 (self >> (rhs & self::shift_max::$t),\n                  (rhs > self::shift_max::$t))\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_neg(self) -> ($t, bool) {\n+                if self == $t::MIN {\n+                    ($t::MIN, true)\n+                } else {\n+                    (-self, false)\n+                }\n+            }\n         }\n     )*)\n }\n@@ -300,6 +310,11 @@ macro_rules! unsigned_overflowing_impl {\n                 (self >> (rhs & self::shift_max::$t),\n                  (rhs > self::shift_max::$t))\n             }\n+\n+            #[inline(always)]\n+            fn overflowing_neg(self) -> ($t, bool) {\n+                ((!self).wrapping_add(1), true)\n+            }\n         }\n     )*)\n }\n@@ -341,6 +356,11 @@ impl OverflowingOps for usize {\n         (r as usize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (usize, bool) {\n+        let (r, f) = (self as u64).overflowing_neg();\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n         let (r, f) = (self as u64).overflowing_shl(rhs);\n         (r as usize, f)\n@@ -386,6 +406,11 @@ impl OverflowingOps for usize {\n         (r as usize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (usize, bool) {\n+        let (r, f) = (self as u32).overflowing_neg();\n+        (r as usize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (usize, bool) {\n         let (r, f) = (self as u32).overflowing_shl(rhs);\n         (r as usize, f)\n@@ -431,6 +456,11 @@ impl OverflowingOps for isize {\n         (r as isize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (isize, bool) {\n+        let (r, f) = (self as i64).overflowing_neg();\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n         let (r, f) = (self as i64).overflowing_shl(rhs);\n         (r as isize, f)\n@@ -476,6 +506,11 @@ impl OverflowingOps for isize {\n         (r as isize, f)\n     }\n     #[inline(always)]\n+    fn overflowing_neg(self) -> (isize, bool) {\n+        let (r, f) = (self as i32).overflowing_neg();\n+        (r as isize, f)\n+    }\n+    #[inline(always)]\n     fn overflowing_shl(self, rhs: u32) -> (isize, bool) {\n         let (r, f) = (self as i32).overflowing_shl(rhs);\n         (r as isize, f)"}, {"sha": "e195d624fe529758cdbd26aa9194126142e2b99c", "filename": "src/test/run-pass/wrapping-int-api.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52182ffdedaabb3b72a11e8a67a411124ecb9ac/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwrapping-int-api.rs?ref=a52182ffdedaabb3b72a11e8a67a411124ecb9ac", "patch": "@@ -0,0 +1,236 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+\n+// Test inherent wrapping_* methods for {i,u}{size,8,16,32,64}.\n+\n+use std::{i8, i16, i32, i64, isize};\n+use std::{u8, u16, u32, u64, usize};\n+\n+fn main() {\n+    assert_eq!(   i8::MAX.wrapping_add(1),    i8::MIN);\n+    assert_eq!(  i16::MAX.wrapping_add(1),   i16::MIN);\n+    assert_eq!(  i32::MAX.wrapping_add(1),   i32::MIN);\n+    assert_eq!(  i64::MAX.wrapping_add(1),   i64::MIN);\n+    assert_eq!(isize::MAX.wrapping_add(1), isize::MIN);\n+\n+    assert_eq!(   i8::MIN.wrapping_sub(1),    i8::MAX);\n+    assert_eq!(  i16::MIN.wrapping_sub(1),   i16::MAX);\n+    assert_eq!(  i32::MIN.wrapping_sub(1),   i32::MAX);\n+    assert_eq!(  i64::MIN.wrapping_sub(1),   i64::MAX);\n+    assert_eq!(isize::MIN.wrapping_sub(1), isize::MAX);\n+\n+    assert_eq!(   u8::MAX.wrapping_add(1),    u8::MIN);\n+    assert_eq!(  u16::MAX.wrapping_add(1),   u16::MIN);\n+    assert_eq!(  u32::MAX.wrapping_add(1),   u32::MIN);\n+    assert_eq!(  u64::MAX.wrapping_add(1),   u64::MIN);\n+    assert_eq!(usize::MAX.wrapping_add(1), usize::MIN);\n+\n+    assert_eq!(   u8::MIN.wrapping_sub(1),    u8::MAX);\n+    assert_eq!(  u16::MIN.wrapping_sub(1),   u16::MAX);\n+    assert_eq!(  u32::MIN.wrapping_sub(1),   u32::MAX);\n+    assert_eq!(  u64::MIN.wrapping_sub(1),   u64::MAX);\n+    assert_eq!(usize::MIN.wrapping_sub(1), usize::MAX);\n+\n+    assert_eq!((0xfe_u8 as i8).wrapping_mul(16),\n+               (0xe0_u8 as i8));\n+    assert_eq!((0xfedc_u16 as i16).wrapping_mul(16),\n+               (0xedc0_u16 as i16));\n+    assert_eq!((0xfedc_ba98_u32 as i32).wrapping_mul(16),\n+               (0xedcb_a980_u32 as i32));\n+    assert_eq!((0xfedc_ba98_7654_3217_u64 as i64).wrapping_mul(16),\n+               (0xedcb_a987_6543_2170_u64 as i64));\n+\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98_u32 as isize).wrapping_mul(16),\n+                       (0xedcb_a980_u32 as isize));\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98_7654_3217_u64 as isize).wrapping_mul(16),\n+                       (0xedcb_a987_6543_2170_u64 as isize));\n+        }\n+    }\n+\n+    assert_eq!((0xfe as u8).wrapping_mul(16),\n+               (0xe0 as u8));\n+    assert_eq!((0xfedc as u16).wrapping_mul(16),\n+               (0xedc0 as u16));\n+    assert_eq!((0xfedc_ba98 as u32).wrapping_mul(16),\n+               (0xedcb_a980 as u32));\n+    assert_eq!((0xfedc_ba98_7654_3217 as u64).wrapping_mul(16),\n+               (0xedcb_a987_6543_2170 as u64));\n+\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98 as usize).wrapping_mul(16),\n+                       (0xedcb_a980 as usize));\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            assert_eq!((0xfedc_ba98_7654_3217 as usize).wrapping_mul(16),\n+                       (0xedcb_a987_6543_2170 as usize));\n+        }\n+    }\n+\n+    macro_rules! check_mul_no_wrap {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_mul($f), ($e) * $f); }\n+    }\n+    macro_rules! check_mul_wraps {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_mul($f), $e); }\n+    }\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, -1);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, -2);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, -2);\n+\n+    check_mul_no_wrap!(0xfe_u8 as i8, 2);\n+    check_mul_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_mul_no_wrap!(0xfedc_ba98_fedc_ba98_u64 as u64 as isize, 2);\n+\n+    check_mul_wraps!(0x80_u8 as i8, -1);\n+    check_mul_wraps!(0x8000_u16 as i16, -1);\n+    check_mul_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_mul_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_mul_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_mul_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+    macro_rules! check_div_no_wrap {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_div($f), ($e) / $f); }\n+    }\n+    macro_rules! check_div_wraps {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_div($f), $e); }\n+    }\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, -1);\n+    check_div_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, -2);\n+    check_div_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n+\n+    check_div_no_wrap!(0xfe_u8 as i8, 2);\n+    check_div_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_div_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_div_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n+\n+    check_div_wraps!(-128 as i8, -1);\n+    check_div_wraps!(0x8000_u16 as i16, -1);\n+    check_div_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_div_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_div_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_div_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+\n+    macro_rules! check_rem_no_wrap {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_rem($f), ($e) % $f); }\n+    }\n+    macro_rules! check_rem_wraps {\n+        ($e:expr, $f:expr) => { assert_eq!(($e).wrapping_rem($f), 0); }\n+    }\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, -1);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -1);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -1);\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, -2);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, -2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, -2);\n+\n+    check_rem_no_wrap!(0xfe_u8 as i8, 2);\n+    check_rem_no_wrap!(0xfedc_u16 as i16, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_u32 as i32, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64, 2);\n+    check_rem_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize, 2);\n+\n+    check_rem_wraps!(0x80_u8 as i8, -1);\n+    check_rem_wraps!(0x8000_u16 as i16, -1);\n+    check_rem_wraps!(0x8000_0000_u32 as i32, -1);\n+    check_rem_wraps!(0x8000_0000_0000_0000_u64 as i64, -1);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_rem_wraps!(0x8000_0000_u32 as isize, -1);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_rem_wraps!(0x8000_0000_0000_0000_u64 as isize, -1);\n+        }\n+    }\n+\n+    macro_rules! check_neg_no_wrap {\n+        ($e:expr) => { assert_eq!(($e).wrapping_neg(), -($e)); }\n+    }\n+    macro_rules! check_neg_wraps {\n+        ($e:expr) => { assert_eq!(($e).wrapping_neg(),  ($e)); }\n+    }\n+\n+    check_neg_no_wrap!(0xfe_u8 as i8);\n+    check_neg_no_wrap!(0xfedc_u16 as i16);\n+    check_neg_no_wrap!(0xfedc_ba98_u32 as i32);\n+    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as i64);\n+    check_neg_no_wrap!(0xfedc_ba98_7654_3217_u64 as u64 as isize);\n+\n+    check_neg_wraps!(0x80_u8 as i8);\n+    check_neg_wraps!(0x8000_u16 as i16);\n+    check_neg_wraps!(0x8000_0000_u32 as i32);\n+    check_neg_wraps!(0x8000_0000_0000_0000_u64 as i64);\n+    match () {\n+        #[cfg(target_pointer_width = \"32\")]\n+        () => {\n+            check_neg_wraps!(0x8000_0000_u32 as isize);\n+        }\n+        #[cfg(target_pointer_width = \"64\")]\n+        () => {\n+            check_neg_wraps!(0x8000_0000_0000_0000_u64 as isize);\n+        }\n+    }\n+\n+}"}]}