{"sha": "fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTkyODkxMDg1ZWNiM2M0ZmVlNDU4YjJkYzM3NGFhNWQxZWQxOGQ=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-07-01T04:02:14Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2013-07-01T04:02:14Z"}, "message": "Classify newtype structs S(T) as immediates if T is an immediate", "tree": {"sha": "c646e1bb8fac15d540689787d1bad2b05429612c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c646e1bb8fac15d540689787d1bad2b05429612c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "html_url": "https://github.com/rust-lang/rust/commit/fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "040ac2a93270b4420c59621521d554a078e2d451", "url": "https://api.github.com/repos/rust-lang/rust/commits/040ac2a93270b4420c59621521d554a078e2d451", "html_url": "https://github.com/rust-lang/rust/commit/040ac2a93270b4420c59621521d554a078e2d451"}], "stats": {"total": 95, "additions": 48, "deletions": 47}, "files": [{"sha": "3939bbaa488eade6830be9c366e69889106b1b3c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -996,13 +996,13 @@ pub fn do_spill_noroot(cx: block, v: ValueRef) -> ValueRef {\n \n pub fn spill_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"spill_if_immediate\");\n-    if ty::type_is_immediate(t) { return do_spill(cx, v, t); }\n+    if ty::type_is_immediate(cx.tcx(), t) { return do_spill(cx, v, t); }\n     return v;\n }\n \n pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     let _icx = push_ctxt(\"load_if_immediate\");\n-    if ty::type_is_immediate(t) { return Load(cx, v); }\n+    if ty::type_is_immediate(cx.tcx(), t) { return Load(cx, v); }\n     return v;\n }\n \n@@ -1527,7 +1527,7 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n // slot where the return value of the function must go.\n pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n     unsafe {\n-        if !ty::type_is_immediate(output_type) {\n+        if !ty::type_is_immediate(fcx.ccx.tcx, output_type) {\n             llvm::LLVMGetParam(fcx.llfn, 0)\n         } else {\n             let lloutputtype = type_of::type_of(fcx.ccx, output_type);\n@@ -1566,7 +1566,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n         }\n     };\n-    let is_immediate = ty::type_is_immediate(substd_output_type);\n+    let is_immediate = ty::type_is_immediate(ccx.tcx, substd_output_type);\n     let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe {\n@@ -1672,7 +1672,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n     match fcx.llself {\n         Some(slf) => {\n             let self_val = if slf.is_copy\n-                    && datum::appropriate_mode(slf.t).is_by_value() {\n+                    && datum::appropriate_mode(bcx.tcx(), slf.t).is_by_value() {\n                 let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n                 let alloc = alloc_ty(bcx, slf.t);\n                 Store(bcx, tmp, alloc);\n@@ -1700,7 +1700,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n         // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(arg_ty).is_by_value() {\n+        let llarg = if datum::appropriate_mode(bcx.tcx(), arg_ty).is_by_value() {\n             let alloc = alloc_ty(bcx, arg_ty);\n             Store(bcx, raw_llarg, alloc);\n             alloc"}, {"sha": "05fe0bed3b6967e7d7a1147a8d8c87dd36f6ae2c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -633,7 +633,7 @@ pub fn trans_call_inner(in_cx: block,\n \n         let mut llargs = ~[];\n \n-        if !ty::type_is_immediate(ret_ty) {\n+        if !ty::type_is_immediate(bcx.tcx(), ret_ty) {\n             llargs.push(llretslot);\n         }\n \n@@ -680,7 +680,7 @@ pub fn trans_call_inner(in_cx: block,\n                             // case to ignore instead of invoking the Store\n                             // below into a scratch pointer of a mismatched\n                             // type.\n-                        } else if ty::type_is_immediate(ret_ty) {\n+                        } else if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n                             let llscratchptr = alloc_ty(bcx, ret_ty);\n                             Store(bcx, llresult, llscratchptr);\n                             bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n@@ -694,7 +694,7 @@ pub fn trans_call_inner(in_cx: block,\n                 // If this is an immediate, store into the result location.\n                 // (If this was not an immediate, the result will already be\n                 // directly written into the output slot.)\n-                if ty::type_is_immediate(ret_ty) {\n+                if ty::type_is_immediate(bcx.tcx(), ret_ty) {\n                     Store(bcx, llresult, lldest);\n                 }\n             }\n@@ -898,7 +898,7 @@ pub fn trans_arg_expr(bcx: block,\n                     }\n                     ty::ByCopy => {\n                         if ty::type_needs_drop(bcx.tcx(), arg_datum.ty) ||\n-                                arg_datum.appropriate_mode().is_by_ref() {\n+                                arg_datum.appropriate_mode(bcx.tcx()).is_by_ref() {\n                             debug!(\"by copy arg with type %s, storing to scratch\",\n                                    bcx.ty_to_str(arg_datum.ty));\n                             let scratch = scratch_datum(bcx, arg_datum.ty, false);\n@@ -914,7 +914,7 @@ pub fn trans_arg_expr(bcx: block,\n                             scratch.add_clean(bcx);\n                             temp_cleanups.push(scratch.val);\n \n-                            match scratch.appropriate_mode() {\n+                            match scratch.appropriate_mode(bcx.tcx()) {\n                                 ByValue => val = Load(bcx, scratch.val),\n                                 ByRef(_) => val = scratch.val,\n                             }"}, {"sha": "b9829fd47c1a6ec49ee83824c808e7d19eb2f7f7", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -188,7 +188,7 @@ pub fn scratch_datum(bcx: block, ty: ty::t, zero: bool) -> Datum {\n     Datum { val: scratch, ty: ty, mode: ByRef(RevokeClean) }\n }\n \n-pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n+pub fn appropriate_mode(tcx: ty::ctxt, ty: ty::t) -> DatumMode {\n     /*!\n     *\n     * Indicates the \"appropriate\" mode for this value,\n@@ -197,7 +197,7 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n \n     if ty::type_is_nil(ty) || ty::type_is_bot(ty) {\n         ByValue\n-    } else if ty::type_is_immediate(ty) {\n+    } else if ty::type_is_immediate(tcx, ty) {\n         ByValue\n     } else {\n         ByRef(RevokeClean)\n@@ -508,18 +508,18 @@ impl Datum {\n         }\n     }\n \n-    pub fn appropriate_mode(&self) -> DatumMode {\n+    pub fn appropriate_mode(&self, tcx: ty::ctxt) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n-        appropriate_mode(self.ty)\n+        appropriate_mode(tcx, self.ty)\n     }\n \n     pub fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode() {\n+        match self.appropriate_mode(bcx.tcx()) {\n             ByValue => self.to_value_llval(bcx),\n             ByRef(_) => self.to_ref_llval(bcx)\n         }\n@@ -530,7 +530,7 @@ impl Datum {\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n \n-        match self.appropriate_mode() {\n+        match self.appropriate_mode(bcx.tcx()) {\n             ByValue => self.to_value_datum(bcx),\n             ByRef(_) => self.to_ref_datum(bcx)\n         }\n@@ -657,13 +657,7 @@ impl Datum {\n                     ByValue => {\n                         // Actually, this case cannot happen right\n                         // now, because enums are never immediate.\n-                        // But in principle newtype'd immediate\n-                        // values should be immediate, and in that\n-                        // case the * would be a no-op except for\n-                        // changing the type, so I am putting this\n-                        // code in place here to do the right\n-                        // thing if this change ever goes through.\n-                        assert!(ty::type_is_immediate(ty));\n+                        assert!(ty::type_is_immediate(bcx.tcx(), ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n@@ -695,14 +689,7 @@ impl Datum {\n                         )\n                     }\n                     ByValue => {\n-                        // Actually, this case cannot happen right now,\n-                        // because structs are never immediate. But in\n-                        // principle, newtype'd immediate values should be\n-                        // immediate, and in that case the * would be a no-op\n-                        // except for changing the type, so I am putting this\n-                        // code in place here to do the right thing if this\n-                        // change ever goes through.\n-                        assert!(ty::type_is_immediate(ty));\n+                        assert!(ty::type_is_immediate(bcx.tcx(), ty));\n                         (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 }"}, {"sha": "d07c2b736c47e83681e49eb7bf948e4bb5363a61", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -291,7 +291,7 @@ pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n         debug!(\"add_env(closure_ty=%s)\", closure_ty.repr(tcx));\n         let scratch = scratch_datum(bcx, closure_ty, false);\n         let llfn = GEPi(bcx, scratch.val, [0u, abi::fn_field_code]);\n-        assert_eq!(datum.appropriate_mode(), ByValue);\n+        assert_eq!(datum.appropriate_mode(tcx), ByValue);\n         Store(bcx, datum.to_appropriate_llval(bcx), llfn);\n         let llenv = GEPi(bcx, scratch.val, [0u, abi::fn_field_box]);\n         Store(bcx, base::null_env_ptr(bcx), llenv);"}, {"sha": "76dc7e1138149befe02a0fab14b7f2e9d765e5e1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -103,7 +103,7 @@ fn foreign_signature(ccx: &mut CrateContext, fn_sig: &ty::FnSig)\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n         llret_ty: llret_ty,\n-        sret: !ty::type_is_immediate(fn_sig.output),\n+        sret: !ty::type_is_immediate(ccx.tcx, fn_sig.output),\n     }\n }\n \n@@ -192,7 +192,7 @@ fn build_wrap_fn_(ccx: @mut CrateContext,\n \n     // Patch up the return type if it's not immediate and we're returning via\n     // the C ABI.\n-    if needs_c_return && !ty::type_is_immediate(tys.fn_sig.output) {\n+    if needs_c_return && !ty::type_is_immediate(ccx.tcx, tys.fn_sig.output) {\n         let lloutputtype = type_of::type_of(fcx.ccx, tys.fn_sig.output);\n         fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n                                    lloutputtype));\n@@ -648,7 +648,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(tp_ty);\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n@@ -657,7 +657,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n         \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n             let tp_ty = substs.tys[0];\n-            let mode = appropriate_mode(tp_ty);\n+            let mode = appropriate_mode(ccx.tcx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n@@ -731,7 +731,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n \n                 let llsrcval = get_param(decl, first_real_arg);\n-                let llsrcptr = if ty::type_is_immediate(in_type) {\n+                let llsrcptr = if ty::type_is_immediate(ccx.tcx, in_type) {\n                     let llsrcptr = alloca(bcx, llintype);\n                     Store(bcx, llsrcval, llsrcptr);\n                     llsrcptr\n@@ -1221,7 +1221,7 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n             let mut i = 0u;\n             let n = tys.fn_sig.inputs.len();\n \n-            if !ty::type_is_immediate(tys.fn_sig.output) {\n+            if !ty::type_is_immediate(bcx.tcx(), tys.fn_sig.output) {\n                 let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n                 llargvals.push(llretptr);\n             }\n@@ -1247,7 +1247,8 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef,\n                      llretval: ValueRef) {\n-            if bcx.fcx.llretptr.is_some() && ty::type_is_immediate(shim_types.fn_sig.output) {\n+            if bcx.fcx.llretptr.is_some() &&\n+                ty::type_is_immediate(bcx.tcx(), shim_types.fn_sig.output) {\n                 // Write the value into the argument bundle.\n                 let arg_count = shim_types.fn_sig.inputs.len();\n                 let llretptr = load_inbounds(bcx,"}, {"sha": "51943b9aad9f2116674c83a6382bb5a9dfdfd4f6", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -357,7 +357,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                             let llty = type_of::type_of(ccx, subst);\n                             let size = machine::llbitsize_of_real(ccx, llty);\n                             let align = machine::llalign_of_min(ccx, llty);\n-                            let mode = datum::appropriate_mode(subst);\n+                            let mode = datum::appropriate_mode(ccx.tcx, subst);\n                             let data_class = mono_data_classify(subst);\n \n                             debug!(\"make_mono_id: type %s -> size %u align %u mode %? class %?\","}, {"sha": "562a8fd69b62df716d50d6032f52f6d3bfd4e6aa", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -18,8 +18,8 @@ use middle::trans::type_::Type;\n \n use syntax::ast;\n \n-pub fn arg_is_indirect(_: &CrateContext, arg_ty: &ty::t) -> bool {\n-    !ty::type_is_immediate(*arg_ty)\n+pub fn arg_is_indirect(ccx: &CrateContext, arg_ty: &ty::t) -> bool {\n+    !ty::type_is_immediate(ccx.tcx, *arg_ty)\n }\n \n pub fn type_of_explicit_arg(ccx: &mut CrateContext, arg_ty: &ty::t) -> Type {\n@@ -41,7 +41,7 @@ pub fn type_of_fn(cx: &mut CrateContext, inputs: &[ty::t], output: ty::t) -> Typ\n \n     // Arg 0: Output pointer.\n     // (if the output type is non-immediate)\n-    let output_is_immediate = ty::type_is_immediate(output);\n+    let output_is_immediate = ty::type_is_immediate(cx.tcx, output);\n     let lloutputtype = type_of(cx, output);\n     if !output_is_immediate {\n         atys.push(lloutputtype.ptr_to());"}, {"sha": "caf5ff5d149276a355226315ea435f0c3f9fa2b9", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd192891085ecb3c4fee458b2dc374aa5d1ed18d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fd192891085ecb3c4fee458b2dc374aa5d1ed18d", "patch": "@@ -1647,9 +1647,22 @@ pub fn type_is_scalar(ty: t) -> bool {\n     }\n }\n \n-pub fn type_is_immediate(ty: t) -> bool {\n+fn type_is_newtype_immediate(cx: ctxt, ty: t) -> bool {\n+    match get(ty).sty {\n+        ty_struct(def_id, ref substs) => {\n+            let fields = struct_fields(cx, def_id, substs);\n+            fields.len() == 1 &&\n+                fields[0].ident == token::special_idents::unnamed_field &&\n+                type_is_immediate(cx, fields[0].mt.ty)\n+        }\n+        _ => false\n+    }\n+}\n+\n+pub fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n     return type_is_scalar(ty) || type_is_boxed(ty) ||\n-        type_is_unique(ty) || type_is_region_ptr(ty);\n+        type_is_unique(ty) || type_is_region_ptr(ty) ||\n+        type_is_newtype_immediate(cx, ty);\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n@@ -3148,7 +3161,7 @@ pub fn expr_kind(tcx: ctxt,\n         ast::expr_cast(*) => {\n             match tcx.node_types.find(&(expr.id as uint)) {\n                 Some(&t) => {\n-                    if ty::type_is_immediate(t) {\n+                    if ty::type_is_immediate(tcx, t) {\n                         RvalueDatumExpr\n                     } else {\n                         RvalueDpsExpr"}]}