{"sha": "c0dc2cb81d29c051edba169f1527c149717f1c3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwZGMyY2I4MWQyOWMwNTFlZGJhMTY5ZjE1MjdjMTQ5NzE3ZjFjM2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T00:06:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-14T00:06:32Z"}, "message": "Auto merge of #29026 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #28988, #28989, #28990, #28997, #29007, #29015\n- Failed merges: #28906", "tree": {"sha": "2c287c1f226318e52b599293464ebb4f73072d86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c287c1f226318e52b599293464ebb4f73072d86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0dc2cb81d29c051edba169f1527c149717f1c3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0dc2cb81d29c051edba169f1527c149717f1c3f", "html_url": "https://github.com/rust-lang/rust/commit/c0dc2cb81d29c051edba169f1527c149717f1c3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0dc2cb81d29c051edba169f1527c149717f1c3f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4362da562a4b591a7d120c6677e14ea713481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4362da562a4b591a7d120c6677e14ea713481a", "html_url": "https://github.com/rust-lang/rust/commit/ec4362da562a4b591a7d120c6677e14ea713481a"}, {"sha": "153754513369993ec20959c1389c25ca915cfbc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/153754513369993ec20959c1389c25ca915cfbc3", "html_url": "https://github.com/rust-lang/rust/commit/153754513369993ec20959c1389c25ca915cfbc3"}], "stats": {"total": 238, "additions": 124, "deletions": 114}, "files": [{"sha": "d839e1820920ae6b8faa6cbc19e0e5a1b59f68ee", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -1898,7 +1898,7 @@ for pop in search(&data_file, &city) {\n \n In this piece of code, we take `file` (which has the type\n `Option<String>`), and convert it to a type that `search` can use, in\n-this case, `&Option<AsRef<Path>>`. Do do this, we take a reference of\n+this case, `&Option<AsRef<Path>>`. To do this, we take a reference of\n file, and map `Path::new` onto it. In this case, `as_ref()` converts\n the `Option<String>` into an `Option<&str>`, and from there, we can\n execute `Path::new` to the content of the optional, and return the"}, {"sha": "b8bac76af0c57cdbbb817856aba68cfc938c0343", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -44,7 +44,7 @@ own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n to accomplish various tasks. But first, a few notes about limitations of ranges.\n \n-Ranges are very primitive, and we often can use better alternatives. Consider\n+Ranges are very primitive, and we often can use better alternatives. Consider the\n following Rust anti-pattern: using ranges to emulate a C-style `for` loop. Let\u2019s\n suppose you needed to iterate over the contents of a vector. You may be tempted\n to write this:"}, {"sha": "0a6e2745e3d54164f6cf8eb05a702a39afdd2cb6", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -1,6 +1,6 @@\n % Lifetimes\n \n-This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+This guide is three of three presenting Rust\u2019s ownership system. This is one of\n Rust\u2019s most unique and compelling features, with which Rust developers should\n become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own chapter:"}, {"sha": "3027f10aca59ea3622aac56c5c23a86fe368b090", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -1,6 +1,6 @@\n % References and Borrowing\n \n-This guide is one of three presenting Rust\u2019s ownership system. This is one of\n+This guide is two of three presenting Rust\u2019s ownership system. This is one of\n Rust\u2019s most unique and compelling features, with which Rust developers should\n become quite acquainted. Ownership is how Rust achieves its largest goal,\n memory safety. There are a few distinct concepts, each with its own"}, {"sha": "f46b12e80c56ada9cae738e5b6934bd2e4b4b85f", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -43,8 +43,7 @@ use libc::{c_int, c_void, size_t};\n extern {\n     fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n     fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n-                  flags: c_int) -> size_t;\n+    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n     fn je_sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n     fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n }\n@@ -63,40 +62,52 @@ const MIN_ALIGN: usize = 8;\n const MIN_ALIGN: usize = 16;\n \n // MALLOCX_ALIGN(a) macro\n-fn mallocx_align(a: usize) -> c_int { a.trailing_zeros() as c_int }\n+fn mallocx_align(a: usize) -> c_int {\n+    a.trailing_zeros() as c_int\n+}\n \n fn align_to_flags(align: usize) -> c_int {\n-    if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n+    if align <= MIN_ALIGN {\n+        0\n+    } else {\n+        mallocx_align(align)\n+    }\n }\n \n #[no_mangle]\n-pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     let flags = align_to_flags(align);\n     unsafe { je_mallocx(size as size_t, flags) as *mut u8 }\n }\n \n #[no_mangle]\n-pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n-                                align: usize) -> *mut u8 {\n+pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n+                                    _old_size: usize,\n+                                    size: usize,\n+                                    align: usize)\n+                                    -> *mut u8 {\n     let flags = align_to_flags(align);\n     unsafe { je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8 }\n }\n \n #[no_mangle]\n-pub extern fn __rust_reallocate_inplace(ptr: *mut u8, _old_size: usize,\n-                                        size: usize, align: usize) -> usize {\n+pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n+                                            _old_size: usize,\n+                                            size: usize,\n+                                            align: usize)\n+                                            -> usize {\n     let flags = align_to_flags(align);\n     unsafe { je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) as usize }\n }\n \n #[no_mangle]\n-pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     let flags = align_to_flags(align);\n     unsafe { je_sdallocx(ptr as *mut c_void, old_size as size_t, flags) }\n }\n \n #[no_mangle]\n-pub extern fn __rust_usable_size(size: usize, align: usize) -> usize {\n+pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     let flags = align_to_flags(align);\n     unsafe { je_nallocx(size as size_t, flags) as usize }\n }"}, {"sha": "c447dfbec4440b75995adc50880e75b75ac65d50", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -39,29 +39,35 @@ const MIN_ALIGN: usize = 8;\n const MIN_ALIGN: usize = 16;\n \n #[no_mangle]\n-pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n+pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     unsafe { imp::allocate(size, align) }\n }\n \n #[no_mangle]\n-pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n+pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe { imp::deallocate(ptr, old_size, align) }\n }\n \n #[no_mangle]\n-pub extern fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n-                                align: usize) -> *mut u8 {\n+pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n+                                    old_size: usize,\n+                                    size: usize,\n+                                    align: usize)\n+                                    -> *mut u8 {\n     unsafe { imp::reallocate(ptr, old_size, size, align) }\n }\n \n #[no_mangle]\n-pub extern fn __rust_reallocate_inplace(ptr: *mut u8, old_size: usize,\n-                                        size: usize, align: usize) -> usize {\n+pub extern \"C\" fn __rust_reallocate_inplace(ptr: *mut u8,\n+                                            old_size: usize,\n+                                            size: usize,\n+                                            align: usize)\n+                                            -> usize {\n     unsafe { imp::reallocate_inplace(ptr, old_size, size, align) }\n }\n \n #[no_mangle]\n-pub extern fn __rust_usable_size(size: usize, align: usize) -> usize {\n+pub extern \"C\" fn __rust_usable_size(size: usize, align: usize) -> usize {\n     imp::usable_size(size, align)\n }\n \n@@ -80,7 +86,8 @@ mod imp {\n         #[cfg(not(target_os = \"android\"))]\n         fn posix_memalign(memptr: *mut *mut libc::c_void,\n                           align: libc::size_t,\n-                          size: libc::size_t) -> libc::c_int;\n+                          size: libc::size_t)\n+                          -> libc::c_int;\n     }\n \n     pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n@@ -94,9 +101,7 @@ mod imp {\n             #[cfg(not(target_os = \"android\"))]\n             unsafe fn more_aligned_malloc(size: usize, align: usize) -> *mut u8 {\n                 let mut out = ptr::null_mut();\n-                let ret = posix_memalign(&mut out,\n-                                         align as libc::size_t,\n-                                         size as libc::size_t);\n+                let ret = posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n                 if ret != 0 {\n                     ptr::null_mut()\n                 } else {\n@@ -107,8 +112,7 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize,\n-                             align: usize) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n         } else {\n@@ -119,8 +123,11 @@ mod imp {\n         }\n     }\n \n-    pub unsafe fn reallocate_inplace(_ptr: *mut u8, old_size: usize, _size: usize,\n-                                     _align: usize) -> usize {\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8,\n+                                     old_size: usize,\n+                                     _size: usize,\n+                                     _align: usize)\n+                                     -> usize {\n         old_size\n     }\n \n@@ -141,8 +148,7 @@ mod imp {\n     extern \"system\" {\n         fn GetProcessHeap() -> HANDLE;\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n-        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID,\n-                       dwBytes: SIZE_T) -> LPVOID;\n+        fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n     }\n \n@@ -165,32 +171,45 @@ mod imp {\n         if align <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), 0, size as SIZE_T) as *mut u8\n         } else {\n-            let ptr = HeapAlloc(GetProcessHeap(), 0,\n-                                (size + align) as SIZE_T) as *mut u8;\n-            if ptr.is_null() { return ptr }\n+            let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n+            if ptr.is_null() {\n+                return ptr\n+            }\n             align_ptr(ptr, align)\n         }\n     }\n \n-    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n-                             align: usize) -> *mut u8 {\n+    pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8\n         } else {\n             let header = get_header(ptr);\n-            let new = HeapReAlloc(GetProcessHeap(), 0, header.0 as LPVOID,\n+            let new = HeapReAlloc(GetProcessHeap(),\n+                                  0,\n+                                  header.0 as LPVOID,\n                                   (size + align) as SIZE_T) as *mut u8;\n-            if new.is_null() { return new }\n+            if new.is_null() {\n+                return new\n+            }\n             align_ptr(new, align)\n         }\n     }\n \n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: usize, size: usize,\n-                                     align: usize) -> usize {\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8,\n+                                     old_size: usize,\n+                                     size: usize,\n+                                     align: usize)\n+                                     -> usize {\n         if align <= MIN_ALIGN {\n-            let new = HeapReAlloc(GetProcessHeap(), HEAP_REALLOC_IN_PLACE_ONLY,\n-                                  ptr as LPVOID, size as SIZE_T) as *mut u8;\n-            if new.is_null() { old_size } else { size }\n+            let new = HeapReAlloc(GetProcessHeap(),\n+                                  HEAP_REALLOC_IN_PLACE_ONLY,\n+                                  ptr as LPVOID,\n+                                  size as SIZE_T) as *mut u8;\n+            if new.is_null() {\n+                old_size\n+            } else {\n+                size\n+            }\n         } else {\n             old_size\n         }"}, {"sha": "97621a2ac89d4f2f28d9d83323c8af5832e49c06", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0dc2cb81d29c051edba169f1527c149717f1c3f/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=c0dc2cb81d29c051edba169f1527c149717f1c3f", "patch": "@@ -105,7 +105,7 @@ pub struct Arena<'longer_than_self> {\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n-    _marker: marker::PhantomData<*mut &'longer_than_self()>,\n+    _marker: marker::PhantomData<*mut &'longer_than_self ()>,\n }\n \n impl<'a> Arena<'a> {\n@@ -197,7 +197,7 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n struct TyDesc {\n     drop_glue: fn(*const i8),\n     size: usize,\n-    align: usize\n+    align: usize,\n }\n \n trait AllTypes { fn dummy(&self) { } }\n@@ -224,8 +224,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n \n-        *self.copy_head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n+        *self.copy_head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n \n         self.alloc_copy_inner(n_bytes, align)\n     }\n@@ -242,38 +241,32 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         let copy_head = self.copy_head.borrow();\n         copy_head.fill.set(end);\n \n-        unsafe {\n-            copy_head.as_ptr().offset(start as isize)\n-        }\n+        unsafe { copy_head.as_ptr().offset(start as isize) }\n     }\n \n     #[inline]\n     fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n-            let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n-                                            mem::align_of::<T>());\n+            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n             &mut *ptr\n         }\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: usize,\n-                          align: usize) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n \n-        *self.head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n+        *self.head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n \n         self.alloc_noncopy_inner(n_bytes, align)\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: usize,\n-                           align: usize) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n@@ -297,24 +290,23 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n \n         unsafe {\n             let buf = head.as_ptr();\n-            (buf.offset(tydesc_start as isize), buf.offset(start as isize))\n+            (buf.offset(tydesc_start as isize),\n+             buf.offset(start as isize))\n         }\n     }\n \n     #[inline]\n     fn alloc_noncopy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n-            let (ty_ptr, ptr) =\n-                self.alloc_noncopy_inner(mem::size_of::<T>(),\n-                                         mem::align_of::<T>());\n+            let (ty_ptr, ptr) = self.alloc_noncopy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n             let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, false);\n             // Actually initialize it\n-            ptr::write(&mut(*ptr), op());\n+            ptr::write(&mut (*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n@@ -358,10 +350,10 @@ fn test_arena_destructors_fail() {\n     for i in 0..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        arena.alloc(|| { Rc::new(i) });\n+        arena.alloc(|| Rc::new(i));\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        arena.alloc(|| { [0u8, 1, 2] });\n+        arena.alloc(|| [0u8, 1, 2]);\n     }\n     // Now, panic while allocating\n     arena.alloc::<Rc<i32>, _>(|| {\n@@ -409,12 +401,13 @@ fn calculate_size<T>(capacity: usize) -> usize {\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n-           -> *mut TypedArenaChunk<T> {\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize) -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n-        let chunk = allocate(size, mem::align_of::<TypedArenaChunk<T>>())\n-                    as *mut TypedArenaChunk<T>;\n-        if chunk.is_null() { alloc::oom() }\n+        let chunk =\n+            allocate(size, mem::align_of::<TypedArenaChunk<T>>()) as *mut TypedArenaChunk<T>;\n+        if chunk.is_null() {\n+            alloc::oom()\n+        }\n         (*chunk).next = next;\n         (*chunk).capacity = capacity;\n         chunk\n@@ -437,7 +430,8 @@ impl<T> TypedArenaChunk<T> {\n         let next = self.next;\n         let size = calculate_size::<T>(self.capacity);\n         let self_ptr: *mut TypedArenaChunk<T> = self;\n-        deallocate(self_ptr as *mut u8, size,\n+        deallocate(self_ptr as *mut u8,\n+                   size,\n                    mem::align_of::<TypedArenaChunk<T>>());\n         if !next.is_null() {\n             let capacity = (*next).capacity;\n@@ -449,9 +443,7 @@ impl<T> TypedArenaChunk<T> {\n     #[inline]\n     fn start(&self) -> *const u8 {\n         let this: *const TypedArenaChunk<T> = self;\n-        unsafe {\n-            round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8\n-        }\n+        unsafe { round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8 }\n     }\n \n     // Returns a pointer to the end of the allocated space.\n@@ -545,22 +537,29 @@ mod tests {\n \n     #[test]\n     fn test_arena_alloc_nested() {\n-        struct Inner { value: u8 }\n-        struct Outer<'a> { inner: &'a Inner }\n-        enum EI<'e> { I(Inner), O(Outer<'e>) }\n+        struct Inner {\n+            value: u8,\n+        }\n+        struct Outer<'a> {\n+            inner: &'a Inner,\n+        }\n+        enum EI<'e> {\n+            I(Inner),\n+            O(Outer<'e>),\n+        }\n \n         struct Wrap<'a>(TypedArena<EI<'a>>);\n \n         impl<'a> Wrap<'a> {\n-            fn alloc_inner<F:Fn() -> Inner>(&self, f: F) -> &Inner {\n+            fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n                 let r: &EI = self.0.alloc(EI::I(f()));\n                 if let &EI::I(ref i) = r {\n                     i\n                 } else {\n                     panic!(\"mismatch\");\n                 }\n             }\n-            fn alloc_outer<F:Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n+            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n                 let r: &EI = self.0.alloc(EI::O(f()));\n                 if let &EI::O(ref o) = r {\n                     o\n@@ -572,8 +571,9 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result = arena.alloc_outer(|| Outer {\n-            inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+        let result = arena.alloc_outer(|| {\n+            Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) }\n+        });\n \n         assert_eq!(result.inner.value, 10);\n     }\n@@ -582,49 +582,27 @@ mod tests {\n     pub fn test_copy() {\n         let arena = TypedArena::new();\n         for _ in 0..100000 {\n-            arena.alloc(Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            });\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n         }\n     }\n \n     #[bench]\n     pub fn bench_copy(b: &mut Bencher) {\n         let arena = TypedArena::new();\n-        b.iter(|| {\n-            arena.alloc(Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            })\n-        })\n+        b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n     }\n \n     #[bench]\n     pub fn bench_copy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            };\n+            let _: Box<_> = box Point { x: 1, y: 2, z: 3 };\n         })\n     }\n \n     #[bench]\n     pub fn bench_copy_old_arena(b: &mut Bencher) {\n         let arena = Arena::new();\n-        b.iter(|| {\n-            arena.alloc(|| {\n-                Point {\n-                    x: 1,\n-                    y: 2,\n-                    z: 3,\n-                }\n-            })\n-        })\n+        b.iter(|| arena.alloc(|| Point { x: 1, y: 2, z: 3 }))\n     }\n \n     #[allow(dead_code)]\n@@ -639,7 +617,7 @@ mod tests {\n         for _ in 0..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             });\n         }\n     }\n@@ -650,7 +628,7 @@ mod tests {\n         b.iter(|| {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             })\n         })\n     }\n@@ -660,7 +638,7 @@ mod tests {\n         b.iter(|| {\n             let _: Box<_> = box Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             };\n         })\n     }\n@@ -669,9 +647,11 @@ mod tests {\n     pub fn bench_noncopy_old_arena(b: &mut Bencher) {\n         let arena = Arena::new();\n         b.iter(|| {\n-            arena.alloc(|| Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+            arena.alloc(|| {\n+                Noncopy {\n+                    string: \"hello world\".to_string(),\n+                    array: vec!(1, 2, 3, 4, 5),\n+                }\n             })\n         })\n     }"}]}