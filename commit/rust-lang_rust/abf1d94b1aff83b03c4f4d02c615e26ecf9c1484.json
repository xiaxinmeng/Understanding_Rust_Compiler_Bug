{"sha": "abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "node_id": "C_kwDOAAsO6NoAKGFiZjFkOTRiMWFmZjgzYjAzYzRmNGQwMmM2MTVlMjZlY2Y5YzE0ODQ", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2021-11-28T18:46:06Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2022-01-17T18:38:30Z"}, "message": "Emit simpler code from format_args", "tree": {"sha": "6a3e1f49a6dce0352d286d3438e4247f7f466217", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a3e1f49a6dce0352d286d3438e4247f7f466217"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAmHlt6YACgkQ+boUO5X/\nbYJXmQ/+PKxNgjQuChr74sT5WzWOvOPmjxgp1DgCP7Sef71Do7pPnwJVdHXFZ/2O\n2yguYqJaJz3mmELjBZbmNA11aio5rHMAbV2TjBthlS7JR10eXy/TSgfOmEeamgMk\ntS44GO8SCWJtWX8mEI2S4lcoj5WdZOAt8ImuVzGQolSx+UqYYS1QMteqKbl2RQV0\n8lTJSjSnDDdQHXa8zGdX/PAdhJre7l7fxbGcdx/JGU4XrC2Z0e3dsR7NAo/kOy2q\nRFBTZYlZbOF2DPRwdY1TnqDroqPUzwPjrR9QaMiB1I+q8FP76Jfb59e8Uin5Rn/u\nM+1Xx8t+7xYEOVKJwz+vOBFQkga9jr9OPu5pP53oMxIfm3y/pXV4GWNVypbnrah9\nAsxrZu5y2ctTog4bG2BIM0iJtgVd6oZPCQQHSYetaCsr99E7i5ofmpJG2ekidxhf\nIR41lZTNVPd6ZsYTYp5P3S2DDDy0xHp/PmaUft9MbsVPFS/bod+/SQ2B1Ru6ruIM\nU1LoqejrcjMdKUYbDDp89CIfJxPgfbdZ1oO6xfmZzd68wnRsPbVgJj64eU9VSam0\n9cpJX9ojpFU23h/BxsNmkMOojXLoS9GcbLtrCsdtXc1p0N4zaJtjNY5BnBhS9Ts8\n6x0wghFXUxG0IFjWCrfeOXnlQ7AbOs7rxq6VVG/Gfs4vaylFSR0=\n=XiY0\n-----END PGP SIGNATURE-----", "payload": "tree 6a3e1f49a6dce0352d286d3438e4247f7f466217\nparent ee5d8d37baaf5b5a81a98396952839c73ae41c68\nauthor David Tolnay <dtolnay@gmail.com> 1638125166 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1642444710 -0800\n\nEmit simpler code from format_args\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "html_url": "https://github.com/rust-lang/rust/commit/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5d8d37baaf5b5a81a98396952839c73ae41c68", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5d8d37baaf5b5a81a98396952839c73ae41c68", "html_url": "https://github.com/rust-lang/rust/commit/ee5d8d37baaf5b5a81a98396952839c73ae41c68"}], "stats": {"total": 198, "additions": 109, "deletions": 89}, "files": [{"sha": "4692420206c1d4e6d47a5cdd3bcbf047c45dd962", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -39,6 +39,7 @@ use rustc_span::{Span, DUMMY_SP};\n use std::cmp::Ordering;\n use std::convert::TryFrom;\n use std::fmt;\n+use std::mem;\n \n #[cfg(test)]\n mod tests;\n@@ -1276,6 +1277,19 @@ impl Expr {\n             ExprKind::Err => ExprPrecedence::Err,\n         }\n     }\n+\n+    pub fn take(&mut self) -> Self {\n+        mem::replace(\n+            self,\n+            Expr {\n+                id: DUMMY_NODE_ID,\n+                kind: ExprKind::Err,\n+                span: DUMMY_SP,\n+                attrs: ThinVec::new(),\n+                tokens: None,\n+            },\n+        )\n+    }\n }\n \n /// Limit types of a range (inclusive or exclusive)"}, {"sha": "50ef350feb61a85b8220111030c283c92a5130b1", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 75, "deletions": 61, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -13,6 +13,7 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{MultiSpan, Span};\n \n use std::borrow::Cow;\n+use std::cmp::Ordering;\n use std::collections::hash_map::Entry;\n \n #[derive(PartialEq)]\n@@ -744,78 +745,93 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Actually builds the expression which the format_args! block will be\n     /// expanded to.\n     fn into_expr(self) -> P<ast::Expr> {\n-        let mut args = Vec::with_capacity(\n+        let mut original_args = self.args;\n+        let mut fmt_args = Vec::with_capacity(\n             self.arg_unique_types.iter().map(|v| v.len()).sum::<usize>() + self.count_args.len(),\n         );\n-        let mut heads = Vec::with_capacity(self.args.len());\n \n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n         let pieces = self.ecx.expr_vec_slice(self.fmtsp, self.str_pieces);\n \n-        // Before consuming the expressions, we have to remember spans for\n-        // count arguments as they are now generated separate from other\n-        // arguments, hence have no access to the `P<ast::Expr>`'s.\n-        let spans_pos: Vec<_> = self.args.iter().map(|e| e.span).collect();\n-\n-        // Right now there is a bug such that for the expression:\n-        //      foo(bar(&1))\n-        // the lifetime of `1` doesn't outlast the call to `bar`, so it's not\n-        // valid for the call to `foo`. To work around this all arguments to the\n-        // format! string are shoved into locals. Furthermore, we shove the address\n-        // of each variable because we don't want to move out of the arguments\n-        // passed to this function.\n-        for (i, e) in self.args.into_iter().enumerate() {\n-            for arg_ty in self.arg_unique_types[i].iter() {\n-                args.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, i));\n-            }\n-            // use the arg span for `&arg` so that borrowck errors\n-            // point to the specific expression passed to the macro\n-            // (the span is otherwise unavailable in MIR)\n-            heads.push(self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e));\n-        }\n-        for index in self.count_args {\n-            let span = spans_pos[index];\n-            args.push(Context::format_arg(self.ecx, self.macsp, span, &Count, index));\n-        }\n-\n-        let args_array = self.ecx.expr_vec(self.macsp, args);\n-\n-        // Constructs an AST equivalent to:\n-        //\n-        //      match (&arg0, &arg1) {\n-        //          (tmp0, tmp1) => args_array\n-        //      }\n+        // We need to construct a &[ArgumentV1] to pass into the fmt::Arguments\n+        // constructor. In general the expressions in this slice might be\n+        // permuted from their order in original_args (such as in the case of\n+        // \"{1} {0}\"), or may have multiple entries referring to the same\n+        // element of original_args (\"{0} {0}\").\n         //\n-        // It was:\n+        // The following Iterator<Item = (usize, &ArgumentType)> has one item\n+        // per element of our output slice, identifying the index of which\n+        // element of original_args it's passing, and that argument's type.\n+        let fmt_arg_index_and_ty = self\n+            .arg_unique_types\n+            .iter()\n+            .enumerate()\n+            .flat_map(|(i, unique_types)| unique_types.iter().map(move |ty| (i, ty)))\n+            .chain(self.count_args.iter().map(|i| (*i, &Count)));\n+\n+        // Figure out whether there are permuted or repeated elements. If not,\n+        // we can generate simpler code.\n+        let nicely_ordered = fmt_arg_index_and_ty\n+            .clone()\n+            .is_sorted_by(|(i, _), (j, _)| (i < j).then_some(Ordering::Less));\n+\n+        // We want to emit:\n         //\n-        //      let tmp0 = &arg0;\n-        //      let tmp1 = &arg1;\n-        //      args_array\n+        //     [ArgumentV1::new(&$arg0, \u2026), ArgumentV1::new(&$arg1, \u2026), \u2026]\n         //\n-        // Because of #11585 the new temporary lifetime rule, the enclosing\n-        // statements for these temporaries become the let's themselves.\n-        // If one or more of them are RefCell's, RefCell borrow() will also\n-        // end there; they don't last long enough for args_array to use them.\n-        // The match expression solves the scope problem.\n+        // However, it's only legal to do so if $arg0, $arg1, \u2026 were written in\n+        // exactly that order by the programmer. When arguments are permuted, we\n+        // want them evaluated in the order written by the programmer, not in\n+        // the order provided to fmt::Arguments. When arguments are repeated, we\n+        // want the expression evaluated only once.\n         //\n-        // Note, it may also very well be transformed to:\n+        // Thus in the not nicely ordered case we emit the following instead:\n         //\n-        //      match arg0 {\n-        //          ref tmp0 => {\n-        //              match arg1 => {\n-        //                  ref tmp1 => args_array } } }\n+        //     match (&$arg0, &$arg1, \u2026) {\n+        //         _args => [ArgumentV1::new(_args.$i, \u2026), ArgumentV1::new(_args.$j, \u2026), \u2026]\n+        //     }\n         //\n-        // But the nested match expression is proved to perform not as well\n-        // as series of let's; the first approach does.\n-        let args_match = {\n-            let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::_args, self.macsp));\n-            let arm = self.ecx.arm(self.macsp, pat, args_array);\n-            let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n-            self.ecx.expr_match(self.macsp, head, vec![arm])\n-        };\n+        // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n+        for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n+            let e = &mut original_args[arg_index];\n+            let span = e.span;\n+            let arg = if nicely_ordered {\n+                let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n+                // The indices are strictly ordered so e has not been taken yet.\n+                self.ecx.expr_addr_of(expansion_span, P(e.take()))\n+            } else {\n+                let def_site = self.ecx.with_def_site_ctxt(span);\n+                let args_tuple = self.ecx.expr_ident(def_site, Ident::new(sym::_args, def_site));\n+                let member = Ident::new(sym::integer(arg_index), def_site);\n+                self.ecx.expr(def_site, ast::ExprKind::Field(args_tuple, member))\n+            };\n+            fmt_args.push(Context::format_arg(self.ecx, self.macsp, span, arg_ty, arg));\n+        }\n \n-        let args_slice = self.ecx.expr_addr_of(self.macsp, args_match);\n+        let args_array = self.ecx.expr_vec(self.macsp, fmt_args);\n+        let args_slice = self.ecx.expr_addr_of(\n+            self.macsp,\n+            if nicely_ordered {\n+                args_array\n+            } else {\n+                // In the !nicely_ordered case, none of the exprs were moved\n+                // away in the previous loop.\n+                //\n+                // This uses the arg span for `&arg` so that borrowck errors\n+                // point to the specific expression passed to the macro (the\n+                // span is otherwise unavailable in MIR).\n+                let heads = original_args\n+                    .into_iter()\n+                    .map(|e| self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e))\n+                    .collect();\n+\n+                let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::_args, self.macsp));\n+                let arm = self.ecx.arm(self.macsp, pat, args_array);\n+                let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n+                self.ecx.expr_match(self.macsp, head, vec![arm])\n+            },\n+        );\n \n         // Now create the fmt::Arguments struct with all our locals we created.\n         let (fn_name, fn_args) = if self.all_pieces_simple {\n@@ -848,11 +864,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         macsp: Span,\n         mut sp: Span,\n         ty: &ArgumentType,\n-        arg_index: usize,\n+        arg: P<ast::Expr>,\n     ) -> P<ast::Expr> {\n         sp = ecx.with_def_site_ctxt(sp);\n-        let arg = ecx.expr_ident(sp, Ident::new(sym::_args, sp));\n-        let arg = ecx.expr(sp, ast::ExprKind::Field(arg, Ident::new(sym::integer(arg_index), sp)));\n         let trait_ = match *ty {\n             Placeholder(trait_) if trait_ == \"<invalid>\" => return DummyResult::raw_expr(sp, true),\n             Placeholder(trait_) => trait_,"}, {"sha": "68edcb1b92c944d19ab2ca4444d0a737beddcf00", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -6,6 +6,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n+#![feature(is_sorted)]\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]"}, {"sha": "3af37955f238079de77ae656b08b2694d33ba5ba", "filename": "src/test/pretty/dollar-crate.pp", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fpretty%2Fdollar-crate.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdollar-crate.pp?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -9,10 +9,5 @@\n // pp-exact:dollar-crate.pp\n \n fn main() {\n-    {\n-        ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"],\n-                                                         &match () {\n-                                                              _args => [],\n-                                                          }));\n-    };\n+    { ::std::io::_print(::core::fmt::Arguments::new_v1(&[\"rust\\n\"], &[])); };\n }"}, {"sha": "93967e720c1b0b5de1c582c06eabd013313bdc75", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -41,16 +41,7 @@\n                                                                                                                                                               [&str; 1])\n                                                                                                                                                             as\n                                                                                                                                                             &[&str; 1]),\n-                                                                                                                                                        (&(match (()\n-                                                                                                                                                                     as\n-                                                                                                                                                                     ())\n-                                                                                                                                                               {\n-                                                                                                                                                               _args\n-                                                                                                                                                               =>\n-                                                                                                                                                               ([]\n-                                                                                                                                                                   as\n-                                                                                                                                                                   [ArgumentV1; 0]),\n-                                                                                                                                                           }\n+                                                                                                                                                        (&([]\n                                                                                                                                                               as\n                                                                                                                                                               [ArgumentV1; 0])\n                                                                                                                                                             as"}, {"sha": "268e382327e1dd703cf40dee277f6d9c2d8d4f2b", "filename": "src/test/ui/attributes/key-value-expansion.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fkey-value-expansion.stderr?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -18,11 +18,8 @@ LL | bug!();\n error: unexpected token: `{\n            let res =\n                ::alloc::fmt::format(::core::fmt::Arguments::new_v1(&[\"\"],\n-                                                                   &match (&\"u8\",) {\n-                                                                        _args =>\n-                                                                        [::core::fmt::ArgumentV1::new(_args.0,\n-                                                                                                      ::core::fmt::Display::fmt)],\n-                                                                    }));\n+                                                                   &[::core::fmt::ArgumentV1::new(&\"u8\",\n+                                                                                                  ::core::fmt::Display::fmt)]));\n            res\n        }.as_str()`\n   --> $DIR/key-value-expansion.rs:48:23"}, {"sha": "bdc71b8dcaa20c0983464dce669cab7cda0f299a", "filename": "src/test/ui/closures/print/closure-print-generic-trim-off-verbose-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-trim-off-verbose-2.stderr?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -9,7 +9,7 @@ LL |         let c1 : () = c;\n    |                  expected due to this\n    |\n    = note: expected unit type `()`\n-                found closure `[mod1::f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#22t, extern \"rust-call\" fn(()), _#23t]]`\n+                found closure `[mod1::f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#19t, extern \"rust-call\" fn(()), _#20t]]`\n help: use parentheses to call this closure\n    |\n LL |         let c1 : () = c();"}, {"sha": "453f18891d319ae18a9c6f854344664c0826e314", "filename": "src/test/ui/closures/print/closure-print-generic-verbose-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fprint%2Fclosure-print-generic-verbose-2.stderr?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -9,7 +9,7 @@ LL |         let c1 : () = c;\n    |                  expected due to this\n    |\n    = note: expected unit type `()`\n-                found closure `[f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#22t, extern \"rust-call\" fn(()), _#23t]]`\n+                found closure `[f<T>::{closure#0} closure_substs=(unavailable) substs=[T, _#19t, extern \"rust-call\" fn(()), _#20t]]`\n help: use parentheses to call this closure\n    |\n LL |         let c1 : () = c();"}, {"sha": "95617e4ecc8b82473b1ad844f346eb4c951b8dba", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/abf1d94b1aff83b03c4f4d02c615e26ecf9c1484/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=abf1d94b1aff83b03c4f4d02c615e26ecf9c1484", "patch": "@@ -1,8 +1,16 @@\n-error[E0284]: type annotations needed: cannot satisfy `<u64 as Test<_>>::Output == _`\n-  --> $DIR/issue-69455.rs:29:26\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:5\n    |\n+LL |     type Output;\n+   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n+...\n LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n-   |                          ^^^^ cannot satisfy `<u64 as Test<_>>::Output == _`\n+   |     ^^^^^^^^^^^^^^^---------------------------^\n+   |     |              |\n+   |     |              this method call resolves to `<Self as Test<Rhs>>::Output`\n+   |     cannot infer type for type parameter `T` declared on the associated function `new`\n+   |\n+   = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-69455.rs:29:26\n@@ -25,5 +33,5 @@ LL |     println!(\"{}\", 23u64.test(xs.iter().sum::<S>()));\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0283, E0284.\n-For more information about an error, try `rustc --explain E0283`.\n+Some errors have detailed explanations: E0282, E0283.\n+For more information about an error, try `rustc --explain E0282`."}]}