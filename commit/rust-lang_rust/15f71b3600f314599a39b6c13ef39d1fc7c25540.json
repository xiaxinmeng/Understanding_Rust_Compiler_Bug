{"sha": "15f71b3600f314599a39b6c13ef39d1fc7c25540", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZjcxYjM2MDBmMzE0NTk5YTM5YjZjMTNlZjM5ZDFmYzdjMjU1NDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-16T09:53:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-16T11:32:35Z"}, "message": "Refactor ast::item representation\n\nMost of the fields in an AST item were present in all variants. Things\ncould be simplified considerably by putting them in the rec rather\nthan in the variant tags.", "tree": {"sha": "5b7bc3d0b7ef4cf132a6bd833d0f32519e8befce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b7bc3d0b7ef4cf132a6bd833d0f32519e8befce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15f71b3600f314599a39b6c13ef39d1fc7c25540", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15f71b3600f314599a39b6c13ef39d1fc7c25540", "html_url": "https://github.com/rust-lang/rust/commit/15f71b3600f314599a39b6c13ef39d1fc7c25540", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15f71b3600f314599a39b6c13ef39d1fc7c25540/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c2f322f827ca2f2109bceab0b9630e624ac8810", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2f322f827ca2f2109bceab0b9630e624ac8810", "html_url": "https://github.com/rust-lang/rust/commit/6c2f322f827ca2f2109bceab0b9630e624ac8810"}], "stats": {"total": 693, "additions": 311, "deletions": 382}, "files": [{"sha": "6e12b9caeb49e9ab1c052c5a921b924980e16feb", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -459,28 +459,21 @@ tag attr_style { attr_outer; attr_inner; }\n \n type attribute_ = rec(attr_style style, meta_item value);\n \n-type item = spanned[item_];\n+type item = rec(ident ident,\n+                vec[attribute] attrs,\n+                def_id id, // For objs, this is the type def_id\n+                ann ann,\n+                item_ node,\n+                span span);\n \n tag item_ {\n-    item_const(ident, @ty, @expr, vec[attribute], def_id, ann);\n-    item_fn(ident, _fn, vec[ty_param], vec[attribute], def_id, ann);\n-    item_mod(ident, _mod, vec[attribute], def_id);\n-    item_native_mod(ident, native_mod, vec[attribute], def_id);\n-    item_ty(ident, @ty, vec[ty_param], vec[attribute], def_id, ann);\n-    item_tag(ident, vec[variant], vec[ty_param], vec[attribute], def_id, ann);\n-    item_obj(ident, _obj, vec[ty_param], vec[attribute], obj_def_ids, ann);\n-}\n-\n-fn item_ident(@item it) -> ident {\n-    ret alt (it.node) {\n-            case (item_const(?ident, _, _, _, _, _)) { ident }\n-            case (item_fn(?ident, _, _, _, _, _)) { ident }\n-            case (item_mod(?ident, _, _, _)) { ident }\n-            case (item_native_mod(?ident, _, _, _)) { ident }\n-            case (item_ty(?ident, _, _, _, _, _)) { ident }\n-            case (item_tag(?ident, _, _, _, _, _)) { ident }\n-            case (item_obj(?ident, _, _, _, _, _)) { ident }\n-        }\n+    item_const(@ty, @expr);\n+    item_fn(_fn, vec[ty_param]);\n+    item_mod(_mod);\n+    item_native_mod(native_mod);\n+    item_ty(@ty, vec[ty_param]);\n+    item_tag(vec[variant], vec[ty_param]);\n+    item_obj(_obj, vec[ty_param], def_id /* constructor id */);\n }\n \n type native_item = spanned[native_item_];\n@@ -498,15 +491,16 @@ tag native_item_ {\n fn is_exported(ident i, _mod m) -> bool {\n     auto nonlocal = true;\n     for (@ast::item it in m.items) {\n-        if (item_ident(it) == i) { nonlocal = false; }\n+        if (it.ident == i) { nonlocal = false; }\n         alt (it.node) {\n-            case (item_tag(_, ?variants, _, _, _, _)) {\n+            case (item_tag(?variants, _)) {\n                 for (variant v in variants) {\n                     if (v.node.name == i) { nonlocal = false; }\n                 }\n             }\n             case (_) { }\n         }\n+        if (!nonlocal) { break; }\n     }\n     auto count = 0u;\n     for (@ast::view_item vi in m.view_items) {\n@@ -525,7 +519,7 @@ fn is_exported(ident i, _mod m) -> bool {\n \n     // If there are no declared exports then \n     // everything not imported is exported\n-    if (count == 0u && !nonlocal) { ret true; } else { ret false; }\n+    ret count == 0u && !nonlocal;\n }\n \n fn is_call_expr(@expr e) -> bool {"}, {"sha": "67be27d4cb6a0d2f927338c24644c86c141a3001", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -294,17 +294,17 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             cx.p.set_def(next_id._1);\n             cx.chpos = p0.get_chpos();\n             cx.next_ann = p0.next_ann_num();\n-            auto im = ast::item_mod(id, m0, [], next_id);\n-            auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n+            auto i = front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi,\n+                                            id, ast::item_mod(m0), []);\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n             auto path = id;\n             alt (dir_opt) { case (some(?d)) { path = d; } case (none) { } }\n             auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n-            auto im = ast::item_mod(id, m0, [], cx.p.next_def_id());\n-            auto i = @spanned(cdir.span.lo, cdir.span.hi, im);\n+            auto i = front::parser::mk_item\n+                (cx.p, cdir.span.lo, cdir.span.hi, id, ast::item_mod(m0), []);\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_view_item(?vi)) {"}, {"sha": "165ca574df5358baed0948b90d4f2dd3f76c2fd5", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -1662,14 +1662,22 @@ fn parse_fn_header(&parser p) -> tup(ast::ident, vec[ast::ty_param]) {\n     ret tup(id, ty_params);\n }\n \n+fn mk_item(&parser p, uint lo, uint hi, &ast::ident ident, &ast::item_ node,\n+           &vec[ast::attribute] attrs) -> @ast::item {\n+    ret @rec(ident=ident,\n+             attrs=attrs,\n+             id=p.next_def_id(),\n+             ann=p.get_ann(),\n+             node=node,\n+             span=rec(lo=lo, hi=hi));\n+}\n+\n fn parse_item_fn_or_iter(&parser p, ast::purity purity, ast::proto proto,\n                          vec[ast::attribute] attrs) -> @ast::item {\n     auto lo = p.get_last_lo_pos();\n     auto t = parse_fn_header(p);\n     auto f = parse_fn(p, proto, purity);\n-    auto item =\n-        ast::item_fn(t._0, f, t._1, attrs, p.next_def_id(), p.get_ann());\n-    ret @spanned(lo, f.body.span.hi, item);\n+    ret mk_item(p, lo, f.body.span.hi, t._0, ast::item_fn(f, t._1), attrs);\n }\n \n fn parse_obj_field(&parser p) -> ast::obj_field {\n@@ -1727,9 +1735,8 @@ fn parse_item_obj(&parser p, ast::layer lyr, vec[ast::attribute] attrs) ->\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     let ast::_obj ob = rec(fields=fields.node, methods=meths, dtor=dtor);\n-    auto odid = rec(ty=p.next_def_id(), ctor=p.next_def_id());\n-    auto item = ast::item_obj(ident, ob, ty_params, attrs, odid, p.get_ann());\n-    ret @spanned(lo, hi, item);\n+    ret mk_item(p, lo, hi, ident, ast::item_obj(ob, ty_params,\n+                                                p.next_def_id()), attrs);\n }\n \n fn parse_mod_items(&parser p, token::token term) -> ast::_mod {\n@@ -1756,9 +1763,7 @@ fn parse_item_const(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto e = parse_expr(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item =\n-        ast::item_const(id, ty, e, attrs, p.next_def_id(), p.get_ann());\n-    ret @spanned(lo, hi, item);\n+    ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n \n fn parse_item_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n@@ -1768,8 +1773,7 @@ fn parse_item_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto m = parse_mod_items(p, token::RBRACE);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-    auto item = ast::item_mod(id, m, attrs, p.next_def_id());\n-    ret @spanned(lo, hi, item);\n+    ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs);\n }\n \n fn parse_item_native_type(&parser p) -> @ast::native_item {\n@@ -1856,8 +1860,7 @@ fn parse_item_native_mod(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto m = parse_native_mod_items(p, native_name, abi);\n     auto hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n-    auto item = ast::item_native_mod(id, m, attrs, p.next_def_id());\n-    ret @spanned(lo, hi, item);\n+    ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs);\n }\n \n fn parse_type_decl(&parser p) -> tup(uint, ast::ident) {\n@@ -1873,9 +1876,7 @@ fn parse_item_type(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     auto ty = parse_ty(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto item =\n-        ast::item_ty(t._1, ty, tps, attrs, p.next_def_id(), p.get_ann());\n-    ret @spanned(t._0, hi, item);\n+    ret mk_item(p, t._0, hi, t._1, ast::item_ty(ty, tps), attrs);\n }\n \n fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n@@ -1922,10 +1923,7 @@ fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n     }\n     auto hi = p.get_hi_pos();\n     p.bump();\n-    auto item =\n-        ast::item_tag(id, variants, ty_params, attrs, p.next_def_id(),\n-                      p.get_ann());\n-    ret @spanned(lo, hi, item);\n+    ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n }\n \n fn parse_layer(&parser p) -> ast::layer {"}, {"sha": "54b46406166aaea3cb07e666d68087a92cd38344", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -63,7 +63,7 @@ fn visit_fn(@ctx cx, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n \n fn visit_item(@ctx cx, &@ast::item i, &scope sc, &vt[scope] v) {\n     alt (i.node) {\n-        case (ast::item_obj(_, ?o, _, _, _, _)) {\n+        case (ast::item_obj(?o, _, _)) {\n             for (ast::obj_field f in o.fields) {\n                 cx.local_map.insert(f.id._1, objfield(f.mut));\n             }"}, {"sha": "d2a9c2679e930e144fd76ae4fd1d907a02ba1105", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -361,64 +361,65 @@ fn encode_module_item_paths(&ebml::writer ebml_w, &ast::_mod module,\n                             &vec[str] path,\n                             &mutable vec[tup(str, uint)] index) {\n     for (@ast::item it in module.items) {\n-        if (!ast::is_exported(ast::item_ident(it), module)) { cont; }\n+        if (!ast::is_exported(it.ident, module)) { cont; }\n         alt (it.node) {\n-            case (ast::item_const(?id, _, ?tps, _, ?did, ?ann)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_const(_, _)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_fn(?id, _, ?tps, _, ?did, ?ann)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_fn(_, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_mod(?id, ?_mod, _, ?did)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_mod(?_mod)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n-                encode_module_item_paths(ebml_w, _mod, path + [id], index);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n+                encode_module_item_paths(ebml_w, _mod, path + [it.ident],\n+                                         index);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_native_mod(?id, ?nmod, _, ?did)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_native_mod(?nmod)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_mod);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n-                encode_native_module_item_paths(ebml_w, nmod, path + [id],\n-                                                index);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n+                encode_native_module_item_paths(ebml_w, nmod,\n+                                                path + [it.ident], index);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_ty(?id, _, ?tps, _, ?did, ?ann)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_ty(_, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n                 ebml::end_tag(ebml_w);\n             }\n-            case (ast::item_tag(?id, ?variants, ?tps, _, ?did, _)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_tag(?variants, ?tps)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, did);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n                 ebml::end_tag(ebml_w);\n                 encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n-            case (ast::item_obj(?id, _, ?tps, _, ?odid, ?ann)) {\n-                add_to_index(ebml_w, path, index, id);\n+            case (ast::item_obj(_, ?tps, ?ctor_id)) {\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, odid.ctor);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, ctor_id);\n                 ebml::end_tag(ebml_w);\n-                add_to_index(ebml_w, path, index, id);\n+                add_to_index(ebml_w, path, index, it.ident);\n                 ebml::start_tag(ebml_w, tag_paths_data_item);\n-                encode_name(ebml_w, id);\n-                encode_def_id(ebml_w, odid.ty);\n+                encode_name(ebml_w, it.ident);\n+                encode_def_id(ebml_w, it.id);\n                 ebml::end_tag(ebml_w);\n             }\n         }\n@@ -509,67 +510,68 @@ fn encode_tag_variant_info(&@trans::crate_ctxt cx, &ebml::writer ebml_w,\n fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                         @ast::item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n-        case (ast::item_const(_, _, _, _, ?did, ?ann)) {\n+        case (ast::item_const(_, _)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'c' as u8);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n-            encode_symbol(cx, ebml_w, did);\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n+            encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_fn(_, _, ?tps, _, ?did, ?ann)) {\n+        case (ast::item_fn(_, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'f' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n-            encode_symbol(cx, ebml_w, did);\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n+            encode_symbol(cx, ebml_w, item.id);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_mod(_, _, _, ?did)) {\n+        case (ast::item_mod(_)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'm' as u8);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_native_mod(?id, _, _, ?did)) {\n+        case (ast::item_native_mod(_)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'n' as u8);\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_ty(?id, _, ?tps, _, ?did, ?ann)) {\n+        case (ast::item_ty(_, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n             ebml::end_tag(ebml_w);\n         }\n-        case (ast::item_tag(?id, ?variants, ?tps, _, ?did, ?ann)) {\n+        case (ast::item_tag(?variants, ?tps)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, did);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            encode_type(cx, ebml_w, trans::node_ann_type(cx, ann));\n+            encode_type(cx, ebml_w, trans::node_ann_type(cx, item.ann));\n             for (ast::variant v in variants) {\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n             ebml::end_tag(ebml_w);\n-            encode_tag_variant_info(cx, ebml_w, did, variants, index, tps);\n+            encode_tag_variant_info(cx, ebml_w, item.id, variants,\n+                                    index, tps);\n         }\n-        case (ast::item_obj(?id, _, ?tps, _, ?odid, ?ann)) {\n+        case (ast::item_obj(_, ?tps, ?ctor_id)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, odid.ctor);\n+            encode_def_id(ebml_w, ctor_id);\n             encode_kind(ebml_w, 'o' as u8);\n             encode_type_param_count(ebml_w, tps);\n-            auto fn_ty = trans::node_ann_type(cx, ann);\n+            auto fn_ty = trans::node_ann_type(cx, item.ann);\n             encode_type(cx, ebml_w, fn_ty);\n-            encode_symbol(cx, ebml_w, odid.ctor);\n+            encode_symbol(cx, ebml_w, ctor_id);\n             ebml::end_tag(ebml_w);\n-            index += [tup(odid.ty._1, ebml_w.writer.tell())];\n+            index += [tup(item.id._1, ebml_w.writer.tell())];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, odid.ty);\n+            encode_def_id(ebml_w, item.id);\n             encode_kind(ebml_w, 'y' as u8);\n             encode_type_param_count(ebml_w, tps);\n             encode_type(cx, ebml_w, ty::ty_fn_ret(cx.tcx, fn_ty));"}, {"sha": "63ca25db65ca1be87a7593643f09b5bf254c929e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 76, "deletions": 87, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -176,39 +176,30 @@ fn map_crate(&@env e, &@ast::crate c) {\n     fn index_i(@env e, &@ast::item i, &scopes sc, &vt[scopes] v) {\n         visit_item_with_scope(i, sc, v);\n         alt (i.node) {\n-            case (ast::item_mod(_, ?md, _, ?defid)) {\n+            case (ast::item_mod(?md)) {\n                 auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(defid._1,\n+                e.mod_map.insert(i.id._1,\n                                  @rec(m=some(md),\n                                       index=index_mod(md),\n                                       mutable glob_imports=vec::empty[def](),\n                                       glob_imported_names=s));\n-                e.ast_map.insert(defid, i);\n+                e.ast_map.insert(i.id, i);\n             }\n-            case (ast::item_native_mod(_, ?nmd, _, ?defid)) {\n+            case (ast::item_native_mod(?nmd)) {\n                 auto s = new_str_hash[import_state]();\n-                e.mod_map.insert(defid._1,\n+                e.mod_map.insert(i.id._1,\n                                  @rec(m=none[ast::_mod],\n                                       index=index_nmod(nmd),\n                                       mutable glob_imports=vec::empty[def](),\n                                       glob_imported_names=s));\n-                e.ast_map.insert(defid, i);\n+                e.ast_map.insert(i.id, i);\n             }\n-            case (ast::item_const(_, _, _, _, ?defid, _)) {\n-                e.ast_map.insert(defid, i);\n+            case (ast::item_obj(_, _, ?ctor_id)) {\n+                e.ast_map.insert(i.id, i);\n+                e.ast_map.insert(ctor_id, i);\n             }\n-            case (ast::item_fn(_, _, _, _, ?defid, _)) {\n-                e.ast_map.insert(defid, i);\n-            }\n-            case (ast::item_ty(_, _, _, _, ?defid, _)) {\n-                e.ast_map.insert(defid, i);\n-            }\n-            case (ast::item_tag(_, _, _, _, ?defid, _)) {\n-                e.ast_map.insert(defid, i);\n-            }\n-            case (ast::item_obj(_, _, _, _, ?obj_def_ids, _)) {\n-                e.ast_map.insert(obj_def_ids.ty, i);\n-                e.ast_map.insert(obj_def_ids.ctor, i);\n+            case (_) {\n+                e.ast_map.insert(i.id, i);\n             }\n         }\n     }\n@@ -225,11 +216,11 @@ fn map_crate(&@env e, &@ast::crate c) {\n             alt (sc) {\n                 case (cons(scope_item(?i), ?tl)) {\n                     alt (i.node) {\n-                        case (ast::item_mod(_, _, _, ?defid)) {\n-                            ret e.mod_map.get(defid._1);\n+                        case (ast::item_mod(_)) {\n+                            ret e.mod_map.get(i.id._1);\n                         }\n-                        case (ast::item_native_mod(_, _, _, ?defid)) {\n-                            ret e.mod_map.get(defid._1);\n+                        case (ast::item_native_mod(_)) {\n+                            ret e.mod_map.get(i.id._1);\n                         }\n                         case (_) { be find_mod(e, *tl); }\n                     }\n@@ -556,21 +547,21 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n-                    case (ast::item_obj(_, ?ob, ?ty_params, _, _, _)) {\n+                    case (ast::item_obj(?ob, ?ty_params, _)) {\n                         ret lookup_in_obj(id, ob, ty_params, ns);\n                     }\n-                    case (ast::item_tag(_, _, ?ty_params, _, _, _)) {\n+                    case (ast::item_tag(_, ?ty_params)) {\n                         if (ns == ns_type) {\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n                     }\n-                    case (ast::item_mod(_, _, _, ?defid)) {\n-                        ret lookup_in_local_mod(e, defid, sp, id, ns, inside);\n+                    case (ast::item_mod(_)) {\n+                        ret lookup_in_local_mod(e, it.id, sp, id, ns, inside);\n                     }\n-                    case (ast::item_native_mod(_, ?m, _, ?defid)) {\n-                        ret lookup_in_local_native_mod(e, defid, sp, id, ns);\n+                    case (ast::item_native_mod(?m)) {\n+                        ret lookup_in_local_native_mod(e, it.id, sp, id, ns);\n                     }\n-                    case (ast::item_ty(_, _, ?ty_params, _, _, _)) {\n+                    case (ast::item_ty(_, ?ty_params)) {\n                         if (ns == ns_type) {\n                             ret lookup_in_ty_params(id, ty_params);\n                         }\n@@ -702,24 +693,23 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n-                            case (ast::item_tag(?name, ?variants, _, _,\n-                                                ?defid, _)) {\n+                            case (ast::item_tag(?variants, _)) {\n                                 if (ns == ns_type) {\n-                                    if (str::eq(name, id)) {\n-                                        ret some(ast::def_ty(defid));\n+                                    if (str::eq(it.ident, id)) {\n+                                        ret some(ast::def_ty(it.id));\n                                     }\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n                                         if (str::eq(v.node.name, id)) {\n                                             auto i =  v.node.id;\n-                                            ret some(ast::def_variant(defid,\n+                                            ret some(ast::def_variant(it.id,\n                                                                       i));\n                                         }\n                                     }\n                                 }\n                             }\n                             case (_) {\n-                                if (str::eq(ast::item_ident(it), id)) {\n+                                if (str::eq(it.ident, id)) {\n                                     auto found = found_def_item(it, ns);\n                                     if (!option::is_none(found)) {\n                                         ret found;\n@@ -738,28 +728,28 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n \n fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     alt (i.node) {\n-        case (ast::item_const(_, _, _, _, ?defid, _)) {\n-            if (ns == ns_value) { ret some(ast::def_const(defid)); }\n+        case (ast::item_const(_, _)) {\n+            if (ns == ns_value) { ret some(ast::def_const(i.id)); }\n         }\n-        case (ast::item_fn(_, _, _, _, ?defid, _)) {\n-            if (ns == ns_value) { ret some(ast::def_fn(defid)); }\n+        case (ast::item_fn(_, _)) {\n+            if (ns == ns_value) { ret some(ast::def_fn(i.id)); }\n         }\n-        case (ast::item_mod(_, _, _, ?defid)) {\n-            if (ns == ns_module) { ret some(ast::def_mod(defid)); }\n+        case (ast::item_mod(_)) {\n+            if (ns == ns_module) { ret some(ast::def_mod(i.id)); }\n         }\n-        case (ast::item_native_mod(_, _, _, ?defid)) {\n-            if (ns == ns_module) { ret some(ast::def_native_mod(defid)); }\n+        case (ast::item_native_mod(_)) {\n+            if (ns == ns_module) { ret some(ast::def_native_mod(i.id)); }\n         }\n-        case (ast::item_ty(_, _, _, _, ?defid, _)) {\n-            if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n+        case (ast::item_ty(_, _)) {\n+            if (ns == ns_type) { ret some(ast::def_ty(i.id)); }\n         }\n-        case (ast::item_tag(_, _, _, _, ?defid, _)) {\n-            if (ns == ns_type) { ret some(ast::def_ty(defid)); }\n+        case (ast::item_tag(_, _)) {\n+            if (ns == ns_type) { ret some(ast::def_ty(i.id)); }\n         }\n-        case (ast::item_obj(_, _, _, _, ?odid, _)) {\n+        case (ast::item_obj(_, _, ?ctor_id)) {\n             alt (ns) {\n-                case (ns_value) { ret some(ast::def_obj(odid.ctor)); }\n-                case (ns_type) { ret some(ast::def_obj(odid.ty)); }\n+                case (ns_value) { ret some(ast::def_obj(ctor_id)); }\n+                case (ns_type) { ret some(ast::def_obj(i.id)); }\n                 case (_) { }\n             }\n         }\n@@ -939,10 +929,10 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns) ->\n         case (mie_item(?item)) { ret found_def_item(item, ns); }\n         case (mie_tag_variant(?item, ?variant_idx)) {\n             alt (item.node) {\n-                case (ast::item_tag(_, ?variants, _, _, ?tid, _)) {\n+                case (ast::item_tag(?variants, _)) {\n                     if (ns == ns_value) {\n                         auto vid = variants.(variant_idx).node.id;\n-                        ret some(ast::def_variant(tid, vid));\n+                        ret some(ast::def_variant(item.id, vid));\n                     } else { ret none[def]; }\n                 }\n             }\n@@ -991,32 +981,32 @@ fn index_mod(&ast::_mod md) -> mod_index {\n     }\n     for (@ast::item it in md.items) {\n         alt (it.node) {\n-            case (ast::item_const(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_const(_, _)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n-            case (ast::item_fn(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_fn(_, _)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n-            case (ast::item_mod(?id, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_mod(_)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n-            case (ast::item_native_mod(?id, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_native_mod(_)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n-            case (ast::item_ty(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_ty(_, _)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n-            case (ast::item_tag(?id, ?variants, _, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_tag(?variants, _)) {\n+                add_to_index(index, it.ident, mie_item(it));\n                 let uint variant_idx = 0u;\n                 for (ast::variant v in variants) {\n                     add_to_index(index, v.node.name,\n                                  mie_tag_variant(it, variant_idx));\n                     variant_idx += 1u;\n                 }\n             }\n-            case (ast::item_obj(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, mie_item(it));\n+            case (ast::item_obj(_, _, _)) {\n+                add_to_index(index, it.ident, mie_item(it));\n             }\n         }\n     }\n@@ -1143,19 +1133,19 @@ fn mie_span(&mod_index_entry mie) -> span {\n fn check_item(@env e, &@ast::item i, &() x, &vt[()] v) {\n     visit::visit_item(i, x, v);\n     alt (i.node) {\n-        case (ast::item_fn(_, ?f, ?ty_params, _, _, _)) {\n+        case (ast::item_fn(?f, ?ty_params)) {\n             check_fn(*e, i.span, f);\n             ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n         }\n-        case (ast::item_obj(_, ?ob, ?ty_params, _, _, _)) {\n+        case (ast::item_obj(?ob, ?ty_params, _)) {\n             fn field_name(&ast::obj_field field) -> ident { ret field.ident; }\n             ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n             for (@ast::method m in ob.methods) {\n                 check_fn(*e, m.span, m.node.meth);\n             }\n             ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n         }\n-        case (ast::item_tag(_, _, ?ty_params, _, _, _)) {\n+        case (ast::item_tag(_, ?ty_params)) {\n             ensure_unique(*e, i.span, ty_params, ident_id, \"type parameter\");\n         }\n         case (_) { }\n@@ -1190,31 +1180,30 @@ fn check_block(@env e, &ast::block b, &() x, &vt[()] v) {\n                     }\n                     case (ast::decl_item(?it)) {\n                         alt (it.node) {\n-                            case (ast::item_tag(?name, ?variants, _, _, _, _))\n-                                 {\n-                                add_name(types, it.span, name);\n+                            case (ast::item_tag(?variants, _)) {\n+                                add_name(types, it.span, it.ident);\n                                 for (ast::variant v in variants) {\n                                     add_name(values, v.span, v.node.name);\n                                 }\n                             }\n-                            case (ast::item_const(?name, _, _, _, _, _)) {\n-                                add_name(values, it.span, name);\n+                            case (ast::item_const(_, _)) {\n+                                add_name(values, it.span, it.ident);\n                             }\n-                            case (ast::item_fn(?name, _, _, _, _, _)) {\n-                                add_name(values, it.span, name);\n+                            case (ast::item_fn(_, _)) {\n+                                add_name(values, it.span, it.ident);\n                             }\n-                            case (ast::item_mod(?name, _, _, _)) {\n-                                add_name(mods, it.span, name);\n+                            case (ast::item_mod(_)) {\n+                                add_name(mods, it.span, it.ident);\n                             }\n-                            case (ast::item_native_mod(?name, _, _, _)) {\n-                                add_name(mods, it.span, name);\n+                            case (ast::item_native_mod(_)) {\n+                                add_name(mods, it.span, it.ident);\n                             }\n-                            case (ast::item_ty(?name, _, _, _, _, _)) {\n-                                add_name(types, it.span, name);\n+                            case (ast::item_ty(_, _)) {\n+                                add_name(types, it.span, it.ident);\n                             }\n-                            case (ast::item_obj(?name, _, _, _, _, _)) {\n-                                add_name(types, it.span, name);\n-                                add_name(values, it.span, name);\n+                            case (ast::item_obj(_, _, _)) {\n+                                add_name(types, it.span, it.ident);\n+                                add_name(values, it.span, it.ident);\n                             }\n                             case (_) { }\n                         }"}, {"sha": "35bea36cbc33e275bd5f2afaa230558a15ee78fa", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -7254,34 +7254,34 @@ fn trans_const(&@crate_ctxt cx, @ast::expr e, &ast::def_id cid,\n \n fn trans_item(@local_ctxt cx, &ast::item item) {\n     alt (item.node) {\n-        case (ast::item_fn(?name, ?f, ?tps, _, ?fid, ?ann)) {\n-            auto sub_cx = extend_path(cx, name);\n-            auto llfndecl = cx.ccx.item_ids.get(fid);\n+        case (ast::item_fn(?f, ?tps)) {\n+            auto sub_cx = extend_path(cx, item.ident);\n+            auto llfndecl = cx.ccx.item_ids.get(item.id);\n             trans_fn(sub_cx, item.span, f, llfndecl, none[ty_self_pair], tps,\n-                     ann);\n+                     item.ann);\n         }\n-        case (ast::item_obj(?name, ?ob, ?tps, _, ?oid, ?ann)) {\n+        case (ast::item_obj(?ob, ?tps, ?ctor_id)) {\n             auto sub_cx =\n                 @rec(obj_typarams=tps, obj_fields=ob.fields\n-                     with *extend_path(cx, name));\n-            trans_obj(sub_cx, item.span, ob, oid.ctor, tps, ann);\n+                     with *extend_path(cx, item.ident));\n+            trans_obj(sub_cx, item.span, ob, ctor_id, tps, item.ann);\n         }\n-        case (ast::item_mod(?name, ?m, _, _)) {\n+        case (ast::item_mod(?m)) {\n             auto sub_cx =\n-                @rec(path=cx.path + [name],\n-                     module_path=cx.module_path + [name] with *cx);\n+                @rec(path=cx.path + [item.ident],\n+                     module_path=cx.module_path + [item.ident] with *cx);\n             trans_mod(sub_cx, m);\n         }\n-        case (ast::item_tag(?name, ?variants, ?tps, _, ?tag_id, _)) {\n-            auto sub_cx = extend_path(cx, name);\n+        case (ast::item_tag(?variants, ?tps)) {\n+            auto sub_cx = extend_path(cx, item.ident);\n             auto i = 0;\n             for (ast::variant variant in variants) {\n-                trans_tag_variant(sub_cx, tag_id, variant, i, tps);\n+                trans_tag_variant(sub_cx, item.id, variant, i, tps);\n                 i += 1;\n             }\n         }\n-        case (ast::item_const(?name, _, ?expr, _, ?cid, ?ann)) {\n-            trans_const(cx.ccx, expr, cid, ann);\n+        case (ast::item_const(_, ?expr)) {\n+            trans_const(cx.ccx, expr, item.id, item.ann);\n         }\n         case (_) {/* fall through */ }\n     }\n@@ -7545,12 +7545,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path,\n }\n \n fn item_path(&@ast::item item) -> vec[str] {\n-    alt (item.node) {\n-        case (ast::item_fn(?name, _, _, _, _, _)) { ret [name]; }\n-        case (ast::item_obj(?name, _, _, _, _, _)) { ret [name]; }\n-        case (ast::item_mod(?name, _, _, _)) { ret [name]; }\n-        case (_) { ret []; }\n-    }\n+    ret [item.ident];\n }\n \n fn collect_native_item(@crate_ctxt ccx, &@ast::native_item i, &vec[str] pt,\n@@ -7572,25 +7567,21 @@ fn collect_item_1(@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n                   &vt[vec[str]] v) {\n     visit::visit_item(i, pt + item_path(i), v);\n     alt (i.node) {\n-        case (ast::item_const(?name, _, _, _, ?cid, ?ann)) {\n-            auto typ = node_ann_type(ccx, ann);\n+        case (ast::item_const(_, _)) {\n+            auto typ = node_ann_type(ccx, i.ann);\n             auto g =\n                 llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ),\n-                                    str::buf(ccx.names.next(name)));\n+                                    str::buf(ccx.names.next(i.ident)));\n             llvm::LLVMSetLinkage(g,\n                                  lib::llvm::LLVMInternalLinkage as\n                                      llvm::Linkage);\n-            ccx.items.insert(cid, i);\n-            ccx.consts.insert(cid, g);\n-        }\n-        case (ast::item_mod(?name, ?m, _, ?mid)) { ccx.items.insert(mid, i); }\n-        case (ast::item_native_mod(_, _, _, ?mid)) {\n-            ccx.items.insert(mid, i);\n-        }\n-        case (ast::item_ty(_, _, _, _, ?did, _)) { ccx.items.insert(did, i); }\n-        case (ast::item_tag(?name, ?variants, ?tps, _, ?tag_id, _)) {\n-            ccx.items.insert(tag_id, i);\n+            ccx.items.insert(i.id, i);\n+            ccx.consts.insert(i.id, g);\n         }\n+        case (ast::item_mod(?m)) { ccx.items.insert(i.id, i); }\n+        case (ast::item_native_mod(_)) { ccx.items.insert(i.id, i); }\n+        case (ast::item_ty(_, _)) { ccx.items.insert(i.id, i); }\n+        case (ast::item_tag(_, _)) { ccx.items.insert(i.id, i); }\n         case (_) { }\n     }\n }\n@@ -7600,16 +7591,16 @@ fn collect_item_2(&@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n     auto new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt (i.node) {\n-        case (ast::item_fn(?name, ?f, ?tps, _, ?fid, ?ann)) {\n-            ccx.items.insert(fid, i);\n-            if (!ccx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, ann, fid);\n+        case (ast::item_fn(?f, ?tps)) {\n+            ccx.items.insert(i.id, i);\n+            if (!ccx.obj_methods.contains_key(i.id)) {\n+                decl_fn_and_pair(ccx, i.span, new_pt, \"fn\", tps, i.ann, i.id);\n             }\n         }\n-        case (ast::item_obj(?name, ?ob, ?tps, _, ?oid, ?ann)) {\n-            ccx.items.insert(oid.ctor, i);\n-            decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, ann,\n-                             oid.ctor);\n+        case (ast::item_obj(?ob, ?tps, ?ctor_id)) {\n+            ccx.items.insert(ctor_id, i);\n+            decl_fn_and_pair(ccx, i.span, new_pt, \"obj_ctor\", tps, i.ann,\n+                             ctor_id);\n             for (@ast::method m in ob.methods) {\n                 ccx.obj_methods.insert(m.node.id, ());\n             }\n@@ -7634,7 +7625,7 @@ fn collect_tag_ctor(@crate_ctxt ccx, &@ast::item i, &vec[str] pt,\n     auto new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt (i.node) {\n-        case (ast::item_tag(_, ?variants, ?tps, _, _, _)) {\n+        case (ast::item_tag(?variants, ?tps)) {\n             for (ast::variant variant in variants) {\n                 if (vec::len[ast::variant_arg](variant.node.args) != 0u) {\n                     decl_fn_and_pair(ccx, i.span,\n@@ -7661,13 +7652,13 @@ fn trans_constant(@crate_ctxt ccx, &@ast::item it, &vec[str] pt,\n     auto new_pt = pt + item_path(it);\n     visit::visit_item(it, new_pt, v);\n     alt (it.node) {\n-        case (ast::item_tag(?ident, ?variants, _, _, ?tag_id, _)) {\n+        case (ast::item_tag(?variants, _)) {\n             auto i = 0u;\n             auto n_variants = vec::len[ast::variant](variants);\n             while (i < n_variants) {\n                 auto variant = variants.(i);\n                 auto discrim_val = C_int(i as int);\n-                auto p = new_pt + [ident, variant.node.name, \"discrim\"];\n+                auto p = new_pt + [it.ident, variant.node.name, \"discrim\"];\n                 auto s = mangle_exported_name(ccx, p, ty::mk_int(ccx.tcx));\n                 auto discrim_gvar =\n                     llvm::LLVMAddGlobal(ccx.llmod, T_int(), str::buf(s));\n@@ -7678,16 +7669,16 @@ fn trans_constant(@crate_ctxt ccx, &@ast::item it, &vec[str] pt,\n                 i += 1u;\n             }\n         }\n-        case (ast::item_const(?name, _, ?expr, _, ?cid, ?ann)) {\n+        case (ast::item_const(_, ?expr)) {\n             // FIXME: The whole expr-translation system needs cloning to deal\n             // with consts.\n \n             auto v = C_int(1);\n-            ccx.item_ids.insert(cid, v);\n+            ccx.item_ids.insert(it.id, v);\n             auto s =\n-                mangle_exported_name(ccx, new_pt + [name],\n-                                     node_ann_type(ccx, ann));\n-            ccx.item_symbols.insert(cid, s);\n+                mangle_exported_name(ccx, new_pt + [it.ident],\n+                                     node_ann_type(ccx, it.ann));\n+            ccx.item_symbols.insert(it.id, s);\n         }\n         case (_) { }\n     }"}, {"sha": "38509e2672e6b398b7a1d28de6895247a92aca8c", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -61,7 +61,6 @@ import bitvectors::gen;\n import front::ast::*;\n import middle::ty::expr_ann;\n import util::common::new_def_hash;\n-import util::common::decl_lhs;\n import util::common::uistr;\n import util::common::log_expr;\n import util::common::log_fn;\n@@ -101,9 +100,8 @@ fn find_pre_post_obj(&crate_ctxt ccx, _obj o) {\n \n fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n     alt (i.node) {\n-        case (item_const(?id, ?t, ?e, _, ?di, ?a)) {\n+        case (item_const(_, ?e)) {\n             // make a fake fcx\n-\n             auto fake_fcx =\n                 rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n                                   num_constraints=0u,\n@@ -113,18 +111,19 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n                     ccx=ccx);\n             find_pre_post_expr(fake_fcx, e);\n         }\n-        case (item_fn(?id, ?f, ?ps, _, ?di, ?a)) {\n-            assert (ccx.fm.contains_key(di));\n-            auto fcx = rec(enclosing=ccx.fm.get(di), id=di, name=id, ccx=ccx);\n+        case (item_fn(?f, ?ps)) {\n+            assert (ccx.fm.contains_key(i.id));\n+            auto fcx = rec(enclosing=ccx.fm.get(i.id), id=i.id,\n+                           name=i.ident, ccx=ccx);\n             find_pre_post_fn(fcx, f);\n         }\n-        case (item_mod(?id, ?m, _, ?di)) { find_pre_post_mod(m); }\n-        case (item_native_mod(?id, ?nm, _, ?di)) {\n+        case (item_mod(?m)) { find_pre_post_mod(m); }\n+        case (item_native_mod(?nm)) {\n             find_pre_post_native_mod(nm);\n         }\n-        case (item_ty(_, _, _, _, _, _)) { ret; }\n-        case (item_tag(_, _, _, _, _, _)) { ret; }\n-        case (item_obj(?id, ?o, ?ps, _, ?di, ?a)) {\n+        case (item_ty(_, _)) { ret; }\n+        case (item_tag(_, _)) { ret; }\n+        case (item_obj(?o, _, _)) {\n             find_pre_post_obj(ccx, o);\n         }\n     }"}, {"sha": "697e9e14e49ed8e2f71a5811cca889817e67fd6f", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -66,7 +66,6 @@ import middle::ty::expr_ty;\n import middle::ty::type_is_nil;\n import middle::ty::type_is_bot;\n import util::common::new_def_hash;\n-import util::common::decl_lhs;\n import util::common::uistr;\n import util::common::log_expr;\n import util::common::log_block;"}, {"sha": "e954d593bbf9aa8b0ab4243e927129ec94c8fdb8", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -1507,26 +1507,6 @@ fn pat_ty(&ctxt cx, &@ast::pat pat) -> t {\n     ret ann_to_monotype(cx, pat_ann(pat));\n }\n \n-fn item_ann(&@ast::item it) -> ast::ann {\n-    alt (it.node) {\n-        case (ast::item_const(_, _, _, _, _, ?a)) { ret a; }\n-        case (ast::item_fn(_, _, _, _, _, ?a)) { ret a; }\n-        case (ast::item_mod(_, _, _, _)) {\n-            log_err \"a module was passed to item_ann(), \" +\n-                        \"but modules haven't annotations\";\n-            fail;\n-        }\n-        case (ast::item_native_mod(_, _, _, _)) {\n-            log_err \"a native module was passed to item_ann(), \" +\n-                        \"but native modules haven't annotations\";\n-            fail;\n-        }\n-        case (ast::item_ty(_, _, _, _, _, ?a)) { ret a; }\n-        case (ast::item_tag(_, _, _, _, _, ?a)) { ret a; }\n-        case (ast::item_obj(_, _, _, _, _, ?a)) { ret a; }\n-    }\n-}\n-\n fn expr_ann(&@ast::expr e) -> ast::ann {\n     alt (e.node) {\n         case (ast::expr_vec(_, _, _, ?a)) { ret a; }\n@@ -2441,7 +2421,7 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n     alt (cx.items.get(id)) {\n         case (any_item_rust(?item)) {\n             alt (item.node) {\n-                case (ast::item_tag(_, ?variants, _, _, _, _)) {\n+                case (ast::item_tag(?variants, _)) {\n                     let vec[variant_info] result = [];\n                     for (ast::variant variant in variants) {\n                         auto ctor_ty = ann_to_monotype(cx, variant.node.ann);"}, {"sha": "016c3ac2ac4bf0b197b26752fba67175045c2e58", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -559,24 +559,24 @@ mod collect {\n         auto get = bind getter(cx, _);\n         auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         alt (it.node) {\n-            case (ast::item_const(?ident, ?t, _, _, ?def_id, _)) {\n+            case (ast::item_const(?t, _)) {\n                 auto typ = convert(t);\n                 auto tpt = tup(0u, typ);\n-                cx.tcx.tcache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(it.id, tpt);\n                 ret tpt;\n             }\n-            case (ast::item_fn(?ident, ?fn_info, ?tps, _, ?def_id, _)) {\n+            case (ast::item_fn(?fn_info, ?tps)) {\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_fn_decl(cx, convert, f, fn_info.decl, fn_info.proto,\n-                                  tps, some(def_id));\n+                                  tps, some(it.id));\n             }\n-            case (ast::item_obj(?ident, ?obj_info, ?tps, _, ?odid, _)) {\n-                auto t_obj = ty_of_obj(cx, ident, obj_info, tps);\n-                cx.tcx.tcache.insert(odid.ty, t_obj);\n+            case (ast::item_obj(?obj_info, ?tps, _)) {\n+                auto t_obj = ty_of_obj(cx, it.ident, obj_info, tps);\n+                cx.tcx.tcache.insert(it.id, t_obj);\n                 ret t_obj;\n             }\n-            case (ast::item_ty(?ident, ?t, ?tps, _, ?def_id, _)) {\n-                alt (cx.tcx.tcache.find(def_id)) {\n+            case (ast::item_ty(?t, ?tps)) {\n+                alt (cx.tcx.tcache.find(it.id)) {\n                     case (some(?tpt)) { ret tpt; }\n                     case (none) { }\n                 }\n@@ -586,10 +586,10 @@ mod collect {\n                 auto typ = convert(t);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, typ);\n-                cx.tcx.tcache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(it.id, tpt);\n                 ret tpt;\n             }\n-            case (ast::item_tag(_, _, ?tps, _, ?def_id, _)) {\n+            case (ast::item_tag(_, ?tps)) {\n                 // Create a new generic polytype.\n \n                 let vec[ty::t] subtys = [];\n@@ -598,28 +598,27 @@ mod collect {\n                     subtys += [ty::mk_param(cx.tcx, i)];\n                     i += 1u;\n                 }\n-                auto t = ty::mk_tag(cx.tcx, def_id, subtys);\n+                auto t = ty::mk_tag(cx.tcx, it.id, subtys);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n                 auto tpt = tup(ty_param_count, t);\n-                cx.tcx.tcache.insert(def_id, tpt);\n+                cx.tcx.tcache.insert(it.id, tpt);\n                 ret tpt;\n             }\n-            case (ast::item_mod(_, _, _, _)) { fail; }\n-            case (ast::item_native_mod(_, _, _, _)) { fail; }\n+            case (ast::item_mod(_)) { fail; }\n+            case (ast::item_native_mod(_)) { fail; }\n         }\n     }\n     fn ty_of_native_item(&@ctxt cx, &@ast::native_item it,\n                          ast::native_abi abi) -> ty::ty_param_count_and_ty {\n         alt (it.node) {\n-            case (ast::native_item_fn(?ident, ?lname, ?fn_decl, ?params,\n-                                      ?def_id, _)) {\n+            case (ast::native_item_fn(_, _, ?fn_decl, ?params, ?did, _)) {\n                 auto get = bind getter(cx, _);\n                 auto convert = bind ast_ty_to_ty(cx.tcx, get, _);\n                 auto f = bind ty_of_arg(cx, _);\n                 ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n-                                         def_id);\n+                                         did);\n             }\n-            case (ast::native_item_ty(_, ?def_id)) {\n+            case (ast::native_item_ty(?tpt, ?def_id)) {\n                 alt (cx.tcx.tcache.find(def_id)) {\n                     case (some(?tpt)) { ret tpt; }\n                     case (none) { }\n@@ -676,14 +675,14 @@ mod collect {\n     }\n     fn collect(ty::item_table id_to_ty_item, &@ast::item i) {\n         alt (i.node) {\n-            case (ast::item_ty(_, _, _, _, ?def_id, _)) {\n-                id_to_ty_item.insert(def_id, ty::any_item_rust(i));\n+            case (ast::item_ty(_, _)) {\n+                id_to_ty_item.insert(i.id, ty::any_item_rust(i));\n             }\n-            case (ast::item_tag(_, _, _, _, ?def_id, _)) {\n-                id_to_ty_item.insert(def_id, ty::any_item_rust(i));\n+            case (ast::item_tag(_, _)) {\n+                id_to_ty_item.insert(i.id, ty::any_item_rust(i));\n             }\n-            case (ast::item_obj(_, _, _, _, ?odid, _)) {\n-                id_to_ty_item.insert(odid.ty, ty::any_item_rust(i));\n+            case (ast::item_obj(_, _, _)) {\n+                id_to_ty_item.insert(i.id, ty::any_item_rust(i));\n             }\n             case (_) {/* empty */ }\n         }\n@@ -702,32 +701,31 @@ mod collect {\n     fn convert(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n                &@ast::item it) {\n         alt (it.node) {\n-            case (ast::item_mod(_, _, _, _)) {\n+            case (ast::item_mod(_)) {\n                 // ignore item_mod, it has no type.\n \n             }\n-            case (ast::item_native_mod(_, ?native_mod, _, _)) {\n+            case (ast::item_native_mod(?native_mod)) {\n                 // Propagate the native ABI down to convert_native() below,\n                 // but otherwise do nothing, as native modules have no types.\n \n                 *abi = some[ast::native_abi](native_mod.abi);\n             }\n-            case (ast::item_tag(_, ?variants, ?ty_params, _, ?tag_id, ?ann)) {\n+            case (ast::item_tag(?variants, ?ty_params)) {\n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, ann.id, tpt._1);\n-                get_tag_variant_types(cx, tag_id, variants, ty_params);\n+                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n+                get_tag_variant_types(cx, it.id, variants, ty_params);\n             }\n-            case (ast::item_obj(?ident, ?object, ?ty_params, _, ?odid, ?ann))\n-                 {\n+            case (ast::item_obj(?object, ?ty_params, ?ctor_id)) {\n                 // This calls ty_of_obj().\n \n                 auto t_obj = ty_of_item(cx, it);\n                 // Now we need to call ty_of_obj_ctor(); this is the type that\n                 // we write into the table for this item.\n \n                 auto tpt =\n-                    ty_of_obj_ctor(cx, ident, object, odid.ctor, ty_params);\n-                write::ty_only(cx.tcx, ann.id, tpt._1);\n+                    ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n+                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n                 // Write the methods into the type table.\n                 //\n                 // FIXME: Inefficient; this ends up calling\n@@ -771,7 +769,7 @@ mod collect {\n                 // it into the node type table.\n \n                 auto tpt = ty_of_item(cx, it);\n-                write::ty_only(cx.tcx, ty::item_ann(it).id, tpt._1);\n+                write::ty_only(cx.tcx, it.ann.id, tpt._1);\n             }\n         }\n     }\n@@ -788,8 +786,8 @@ mod collect {\n                 // FIXME: Native types have no annotation. Should they? --pcw\n \n             }\n-            case (ast::native_item_fn(_, _, _, _, _, ?a)) {\n-                write::ty_only(cx.tcx, a.id, tpt._1);\n+            case (ast::native_item_fn(_, _, _, _, _, ?ann)) {\n+                write::ty_only(cx.tcx, ann.id, tpt._1);\n             }\n         }\n     }\n@@ -2327,18 +2325,17 @@ fn check_method(&@crate_ctxt ccx, &@ast::method method) {\n \n fn check_item(@crate_ctxt ccx, &@ast::item it) {\n     alt (it.node) {\n-        case (ast::item_const(_, _, ?e, _, _, ?a)) {\n-            check_const(ccx, it.span, e, a);\n+        case (ast::item_const(_, ?e)) {\n+            check_const(ccx, it.span, e, it.ann);\n         }\n-        case (ast::item_fn(_, ?f, _, _, _, ?a)) {\n-            check_fn(ccx, f.decl, f.proto, f.body, a);\n+        case (ast::item_fn(?f, _)) {\n+            check_fn(ccx, f.decl, f.proto, f.body, it.ann);\n         }\n-        case (ast::item_obj(_, ?ob, _, _, ?obj_def_ids, _)) {\n+        case (ast::item_obj(?ob, _, _)) {\n             // We're entering an object, so gather up the info we need.\n \n-            let ast::def_id di = obj_def_ids.ty;\n             vec::push[obj_info](ccx.obj_infos,\n-                                rec(obj_fields=ob.fields, this_obj=di));\n+                                rec(obj_fields=ob.fields, this_obj=it.id));\n             // Typecheck the methods.\n \n             for (@ast::method method in ob.methods) {\n@@ -2357,8 +2354,8 @@ fn mk_fn_purity_table(&@ast::crate crate) -> @fn_purity_table {\n     auto res = @new_def_hash[ast::purity]();\n     fn do_one(@fn_purity_table t, &@ast::item i) {\n         alt (i.node) {\n-            case (ast::item_fn(_, ?f, _, _, ?d_id, _)) {\n-                t.insert(d_id, f.decl.purity);\n+            case (ast::item_fn(?f, _)) {\n+                t.insert(i.id, f.decl.purity);\n             }\n             case (_) { }\n         }"}, {"sha": "9afbaef1ff7b7013074d714ffedcd9ee5608c863", "filename": "src/comp/middle/visit.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fvisit.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -99,31 +99,31 @@ fn visit_local[E](&@local loc, &E e, &vt[E] v) {\n \n fn visit_item[E](&@item i, &E e, &vt[E] v) {\n     alt (i.node) {\n-        case (item_const(_, ?t, ?ex, _, _, _)) {\n+        case (item_const(?t, ?ex)) {\n             vt(v).visit_ty(t, e, v);\n             vt(v).visit_expr(ex, e, v);\n         }\n-        case (item_fn(?nm, ?f, ?tp, _, ?d, ?a)) {\n-            vt(v).visit_fn(f, tp, i.span, nm, d, a, e, v);\n+        case (item_fn(?f, ?tp)) {\n+            vt(v).visit_fn(f, tp, i.span, i.ident, i.id, i.ann, e, v);\n         }\n-        case (item_mod(_, ?m, _, _)) { vt(v).visit_mod(m, i.span, e, v); }\n-        case (item_native_mod(_, ?nm, _, _)) {\n+        case (item_mod(?m)) { vt(v).visit_mod(m, i.span, e, v); }\n+        case (item_native_mod(?nm)) {\n             for (@view_item vi in nm.view_items) {\n                 vt(v).visit_view_item(vi, e, v);\n             }\n             for (@native_item ni in nm.items) {\n                 vt(v).visit_native_item(ni, e, v);\n             }\n         }\n-        case (item_ty(_, ?t, _, _, _, _)) { vt(v).visit_ty(t, e, v); }\n-        case (item_tag(_, ?variants, _, _, _, _)) {\n+        case (item_ty(?t, _)) { vt(v).visit_ty(t, e, v); }\n+        case (item_tag(?variants, _)) {\n             for (variant vr in variants) {\n                 for (variant_arg va in vr.node.args) {\n                     vt(v).visit_ty(va.ty, e, v);\n                 }\n             }\n         }\n-        case (item_obj(_, ?ob, _, _, _, _)) {\n+        case (item_obj(?ob, _, _)) {\n             for (obj_field f in ob.fields) { vt(v).visit_ty(f.ty, e, v); }\n             for (@method m in ob.methods) {\n                 vt(v).visit_fn(m.node.meth, [], m.span, m.node.ident,"}, {"sha": "3d5a534b4a588cff54ef6883b94188b1bbe33147", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -103,24 +103,24 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n     if (!v.keep_going()) { ret; }\n     v.visit_item_pre(i);\n     alt (i.node) {\n-        case (ast::item_const(_, ?t, ?e, _, _, _)) {\n+        case (ast::item_const(?t, ?e)) {\n             walk_ty(v, t);\n             walk_expr(v, e);\n         }\n-        case (ast::item_fn(?nm, ?f, _, _, ?d, ?a)) {\n-            walk_fn(v, f, i.span, nm, d, a);\n+        case (ast::item_fn(?f, _)) {\n+            walk_fn(v, f, i.span, i.ident, i.id, i.ann);\n         }\n-        case (ast::item_mod(_, ?m, _, _)) { walk_mod(v, m); }\n-        case (ast::item_native_mod(_, ?nm, _, _)) { walk_native_mod(v, nm); }\n-        case (ast::item_ty(_, ?t, _, _, _, _)) { walk_ty(v, t); }\n-        case (ast::item_tag(_, ?variants, _, _, _, _)) {\n+        case (ast::item_mod(?m)) { walk_mod(v, m); }\n+        case (ast::item_native_mod(?nm)) { walk_native_mod(v, nm); }\n+        case (ast::item_ty(?t, _)) { walk_ty(v, t); }\n+        case (ast::item_tag(?variants, _)) {\n             for (ast::variant vr in variants) {\n                 for (ast::variant_arg va in vr.node.args) {\n                     walk_ty(v, va.ty);\n                 }\n             }\n         }\n-        case (ast::item_obj(_, ?ob, _, _, _, _)) {\n+        case (ast::item_obj(?ob, _, _)) {\n             for (ast::obj_field f in ob.fields) { walk_ty(v, f.ty); }\n             for (@ast::method m in ob.methods) {\n                 v.visit_method_pre(m);"}, {"sha": "f7de0acec3ddd4f9ba49466cbc53a90cb77791bc", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -259,12 +259,12 @@ fn print_item(&ps s, &@ast::item item) {\n     hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n     alt (item.node) {\n-        case (ast::item_const(?id, ?ty, ?expr, ?attrs, _, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_const(?ty, ?expr)) {\n+            print_outer_attributes(s, item.attrs);\n             head(s, \"const\");\n             print_type(s, *ty);\n             space(s.s);\n-            word_space(s, id);\n+            word_space(s, item.ident);\n             end(s); // end the head-ibox\n \n             word_space(s, \"=\");\n@@ -273,22 +273,22 @@ fn print_item(&ps s, &@ast::item item) {\n             end(s); // end the outer cbox\n \n         }\n-        case (ast::item_fn(?name, ?_fn, ?typarams, ?attrs, _, _)) {\n-            print_outer_attributes(s, attrs);\n-            print_fn(s, _fn.decl, _fn.proto, name, typarams);\n+        case (ast::item_fn(?_fn, ?typarams)) {\n+            print_outer_attributes(s, item.attrs);\n+            print_fn(s, _fn.decl, _fn.proto, item.ident, typarams);\n             word(s.s, \" \");\n             print_block(s, _fn.body);\n         }\n-        case (ast::item_mod(?id, ?_mod, ?attrs, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_mod(?_mod)) {\n+            print_outer_attributes(s, item.attrs);\n             head(s, \"mod\");\n-            word_nbsp(s, id);\n+            word_nbsp(s, item.ident);\n             bopen(s);\n             for (@ast::item itm in _mod.items) { print_item(s, itm); }\n             bclose(s, item.span);\n         }\n-        case (ast::item_native_mod(?id, ?nmod, ?attrs, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_native_mod(?nmod)) {\n+            print_outer_attributes(s, item.attrs);\n             head(s, \"native\");\n             alt (nmod.abi) {\n                 case (ast::native_abi_rust) { word_nbsp(s, \"\\\"rust\\\"\"); }\n@@ -298,7 +298,7 @@ fn print_item(&ps s, &@ast::item item) {\n                 }\n             }\n             word_nbsp(s, \"mod\");\n-            word_nbsp(s, id);\n+            word_nbsp(s, item.ident);\n             bopen(s);\n             for (@ast::native_item item in nmod.items) {\n                 hardbreak(s.s);\n@@ -331,12 +331,12 @@ fn print_item(&ps s, &@ast::item item) {\n             }\n             bclose(s, item.span);\n         }\n-        case (ast::item_ty(?id, ?ty, ?params, ?attrs, _, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_ty(?ty, ?params)) {\n+            print_outer_attributes(s, item.attrs);\n             ibox(s, indent_unit);\n             ibox(s, 0u);\n             word_nbsp(s, \"type\");\n-            word(s.s, id);\n+            word(s.s, item.ident);\n             print_type_params(s, params);\n             end(s); // end the inner ibox\n \n@@ -348,10 +348,10 @@ fn print_item(&ps s, &@ast::item item) {\n \n             break_offset(s.s, 0u, 0);\n         }\n-        case (ast::item_tag(?id, ?variants, ?params, ?attrs, _, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_tag(?variants, ?params)) {\n+            print_outer_attributes(s, item.attrs);\n             head(s, \"tag\");\n-            word(s.s, id);\n+            word(s.s, item.ident);\n             print_type_params(s, params);\n             space(s.s);\n             bopen(s);\n@@ -372,10 +372,10 @@ fn print_item(&ps s, &@ast::item item) {\n             }\n             bclose(s, item.span);\n         }\n-        case (ast::item_obj(?id, ?_obj, ?params, ?attrs, _, _)) {\n-            print_outer_attributes(s, attrs);\n+        case (ast::item_obj(?_obj, ?params, _)) {\n+            print_outer_attributes(s, item.attrs);\n             head(s, \"obj\");\n-            word(s.s, id);\n+            word(s.s, item.ident);\n             print_type_params(s, params);\n             popen(s);\n             fn print_field(&ps s, &ast::obj_field field) {\n@@ -415,7 +415,7 @@ fn print_item(&ps s, &@ast::item item) {\n     alt (s.mode) {\n         case (mo_identified) {\n             space(s.s);\n-            synth_comment(s, uint::to_str(ty::item_ann(item).id, 10u));\n+            synth_comment(s, uint::to_str(item.ann.id, 10u));\n         }\n         case (_) {/* no-op */ }\n     }"}, {"sha": "af9f4b01e348fb476cf1954b75a4d32ad34bcff4", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15f71b3600f314599a39b6c13ef39d1fc7c25540/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=15f71b3600f314599a39b6c13ef39d1fc7c25540", "patch": "@@ -148,26 +148,6 @@ fn log_stmt(&ast::stmt st) { log pretty::pprust::stmt_to_str(st); }\n \n fn log_stmt_err(&ast::stmt st) { log_err pretty::pprust::stmt_to_str(st); }\n \n-fn decl_lhs(@ast::decl d) -> ast::def_id {\n-    alt (d.node) {\n-        case (ast::decl_local(?l)) { ret l.id; }\n-        case (ast::decl_item(?an_item)) {\n-            alt (an_item.node) {\n-                case (ast::item_const(_, _, _, _, ?d, _)) { ret d; }\n-                case (ast::item_fn(_, _, _, _, ?d, _)) { ret d; }\n-                case (ast::item_mod(_, _, _, ?d)) { ret d; }\n-                case (ast::item_native_mod(_, _, _, ?d)) { ret d; }\n-                case (ast::item_ty(_, _, _, _, ?d, _)) { ret d; }\n-                case (ast::item_tag(_, _, _, _, ?d, _)) { ret d; }\n-                case (ast::item_obj(_, _, _, _, ?d, _)) {\n-                    ret d.ctor; /* This doesn't really make sense */\n-\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn has_nonlocal_exits(&ast::block b) -> bool {\n     auto has_exits = @mutable false;\n     fn visit_expr(@mutable bool flag, &@ast::expr e) {"}]}