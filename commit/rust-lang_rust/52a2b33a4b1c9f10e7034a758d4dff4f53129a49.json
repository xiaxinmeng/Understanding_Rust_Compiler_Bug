{"sha": "52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYTJiMzNhNGIxYzlmMTBlNzAzNGE3NThkNGRmZjRmNTMxMjlhNDk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-20T22:29:49Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-02T22:51:01Z"}, "message": "Refactor pretty printing to use more of the driver", "tree": {"sha": "cb1cf2fe4a5ad18f53f688df2fed576fe3f6aa86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb1cf2fe4a5ad18f53f688df2fed576fe3f6aa86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "html_url": "https://github.com/rust-lang/rust/commit/52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee02d9f4d94f6a826d10529419b64a4ccd2a405", "html_url": "https://github.com/rust-lang/rust/commit/7ee02d9f4d94f6a826d10529419b64a4ccd2a405"}], "stats": {"total": 593, "additions": 330, "deletions": 263}, "files": [{"sha": "2b56366f1c69794ac1b7c6fcd2c955888085735c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 61, "deletions": 36, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "patch": "@@ -112,7 +112,7 @@ pub fn compile_input(sess: &Session,\n             let expanded_crate = phase_2_configure_and_expand(sess,\n                                                               &cstore,\n                                                               krate,\n-                                                              &id[..],\n+                                                              &id,\n                                                               addl_plugins)?;\n \n             (outputs, expanded_crate, id)\n@@ -123,8 +123,10 @@ pub fn compile_input(sess: &Session,\n                                 CompileState::state_after_expand(input,\n                                                                  sess,\n                                                                  outdir,\n+                                                                 output,\n+                                                                 &cstore,\n                                                                  &expanded_crate,\n-                                                                 &id[..]),\n+                                                                 &id),\n                                 Ok(()));\n \n         let expanded_crate = assign_node_ids(sess, expanded_crate);\n@@ -169,10 +171,13 @@ pub fn compile_input(sess: &Session,\n                                     CompileState::state_after_write_deps(input,\n                                                                          sess,\n                                                                          outdir,\n+                                                                         output,\n+                                                                         &arenas,\n+                                                                         &cstore,\n                                                                          &hir_map,\n                                                                          &expanded_crate,\n                                                                          &hir_map.krate(),\n-                                                                         &id[..]),\n+                                                                         &id),\n                                     Ok(()));\n         }\n \n@@ -202,8 +207,9 @@ pub fn compile_input(sess: &Session,\n                 let _ignore = tcx.dep_graph.in_ignore();\n \n                 let mut state = CompileState::state_after_analysis(input,\n-                                                                   &tcx.sess,\n+                                                                   sess,\n                                                                    outdir,\n+                                                                   output,\n                                                                    opt_crate,\n                                                                    tcx.map.krate(),\n                                                                    &analysis,\n@@ -243,7 +249,7 @@ pub fn compile_input(sess: &Session,\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input, sess, outdir, &trans),\n+                            CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n                             phase5_result);\n     phase5_result?;\n \n@@ -334,34 +340,36 @@ impl<'a> PhaseController<'a> {\n /// State that is passed to a callback. What state is available depends on when\n /// during compilation the callback is made. See the various constructor methods\n /// (`state_*`) in the impl to see which data is provided for any given entry point.\n-pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n+pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub input: &'a Input,\n-    pub session: &'a Session,\n+    pub session: &'ast Session,\n     pub krate: Option<ast::Crate>,\n     pub cstore: Option<&'a CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n     pub out_file: Option<&'a Path>,\n+    pub arenas: Option<&'ast ty::CtxtArenas<'ast>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n-    pub mir_map: Option<&'a MirMap<'tcx>>,\n+    pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<&'a TyCtxt<'tcx>>,\n+    pub tcx: Option<&'b TyCtxt<'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n-impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n+impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     fn empty(input: &'a Input,\n-             session: &'a Session,\n+             session: &'ast Session,\n              out_dir: &'a Option<PathBuf>)\n-             -> CompileState<'a, 'ast, 'tcx> {\n+             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             input: input,\n             session: session,\n             out_dir: out_dir.as_ref().map(|s| &**s),\n             out_file: None,\n+            arenas: None,\n             krate: None,\n             cstore: None,\n             crate_name: None,\n@@ -377,12 +385,12 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     }\n \n     fn state_after_parse(input: &'a Input,\n-                         session: &'a Session,\n+                         session: &'ast Session,\n                          out_dir: &'a Option<PathBuf>,\n                          out_file: &'a Option<PathBuf>,\n                          krate: ast::Crate,\n                          cstore: &'a CStore)\n-                         -> CompileState<'a, 'ast, 'tcx> {\n+                         -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             krate: Some(krate),\n             cstore: Some(cstore),\n@@ -392,63 +400,80 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n     }\n \n     fn state_after_expand(input: &'a Input,\n-                          session: &'a Session,\n+                          session: &'ast Session,\n                           out_dir: &'a Option<PathBuf>,\n+                          out_file: &'a Option<PathBuf>,\n+                          cstore: &'a CStore,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n-                          -> CompileState<'a, 'ast, 'tcx> {\n+                          -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n+            cstore: Some(cstore),\n             expanded_crate: Some(expanded_crate),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_write_deps(input: &'a Input,\n-                              session: &'a Session,\n+                              session: &'ast Session,\n                               out_dir: &'a Option<PathBuf>,\n+                              out_file: &'a Option<PathBuf>,\n+                              arenas: &'ast ty::CtxtArenas<'ast>,\n+                              cstore: &'a CStore,\n                               hir_map: &'a hir_map::Map<'ast>,\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n                               crate_name: &'a str)\n-                              -> CompileState<'a, 'ast, 'tcx> {\n+                              -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n+            arenas: Some(arenas),\n+            cstore: Some(cstore),\n             ast_map: Some(hir_map),\n             expanded_crate: Some(krate),\n             hir_crate: Some(hir_crate),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n     fn state_after_analysis(input: &'a Input,\n-                            session: &'a Session,\n+                            session: &'ast Session,\n                             out_dir: &'a Option<PathBuf>,\n+                            out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis,\n-                            mir_map: Option<&'a MirMap<'tcx>>,\n-                            tcx: &'a TyCtxt<'tcx>,\n+                            analysis: &'a ty::CrateAnalysis<'a>,\n+                            mir_map: Option<&'b MirMap<'tcx>>,\n+                            tcx: &'b TyCtxt<'tcx>,\n                             crate_name: &'a str)\n-                            -> CompileState<'a, 'ast, 'tcx> {\n+                            -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n             mir_map: mir_map,\n             tcx: Some(tcx),\n             expanded_crate: krate,\n             hir_crate: Some(hir_crate),\n             crate_name: Some(crate_name),\n+            out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n         }\n     }\n \n \n     fn state_after_llvm(input: &'a Input,\n-                        session: &'a Session,\n+                        session: &'ast Session,\n                         out_dir: &'a Option<PathBuf>,\n+                        out_file: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n-                        -> CompileState<'a, 'ast, 'tcx> {\n-        CompileState { trans: Some(trans), ..CompileState::empty(input, session, out_dir) }\n+                        -> CompileState<'a, 'b, 'ast, 'tcx> {\n+        CompileState {\n+            trans: Some(trans),\n+            out_file: out_file.as_ref().map(|s| &**s),\n+            ..CompileState::empty(input, session, out_dir)\n+        }\n     }\n }\n \n@@ -814,16 +839,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let index = stability::Index::new(&hir_map);\n \n     TyCtxt::create_and_enter(sess,\n-                               arenas,\n-                               def_map,\n-                               named_region_map,\n-                               hir_map,\n-                               freevars,\n-                               region_map,\n-                               lang_items,\n-                               index,\n-                               name,\n-                               |tcx| {\n+                             arenas,\n+                             def_map,\n+                             named_region_map,\n+                             hir_map,\n+                             freevars,\n+                             region_map,\n+                             lang_items,\n+                             index,\n+                             name,\n+                             |tcx| {\n         time(time_passes,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx));"}, {"sha": "74f6d3f25157b7ab6e453f01b91a3f5405655840", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "patch": "@@ -450,17 +450,39 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn build_controller(&mut self, sess: &Session, matches: &getopts::Matches) -> CompileController<'a> {\n         let mut control = CompileController::basic();\n \n-        if let Some((ppm, opt_uii)) = parse_pretty(&sess, &matches) {\n-            control.after_parse.stop = Compilation::Stop;\n-            control.after_parse.callback = box move |state| {\n-                pretty::pretty_print_input(state.session,\n-                                           state.cstore.unwrap(),\n-                                           state.input,\n-                                           state.krate.take().unwrap(),\n-                                           ppm,\n-                                           opt_uii.clone(),\n-                                           state.out_file);\n-            };\n+        if let Some((ppm, opt_uii)) = parse_pretty(sess, matches) {\n+            if ppm.needs_ast_map(&opt_uii) {\n+                control.after_write_deps.stop = Compilation::Stop;\n+\n+                control.after_parse.callback = box move |state| {\n+                    state.krate = Some(pretty::fold_crate(state.krate.take().unwrap(), ppm));\n+                };\n+                control.after_write_deps.callback = box move |state| {\n+                    pretty::print_after_write_deps(state.session,\n+                                                   state.cstore.unwrap(),\n+                                                   state.ast_map.unwrap(),\n+                                                   state.input,\n+                                                   &state.expanded_crate.take().unwrap(),\n+                                                   state.crate_name.unwrap(),\n+                                                   ppm,\n+                                                   state.arenas.unwrap(),\n+                                                   opt_uii.clone(),\n+                                                   state.out_file);\n+                };\n+            } else {\n+                control.after_parse.stop = Compilation::Stop;\n+\n+                control.after_parse.callback = box move |state| {\n+                    let krate = pretty::fold_crate(state.krate.take().unwrap(), ppm);\n+                    pretty::print_after_parsing(state.session,\n+                                                state.input,\n+                                                &krate,\n+                                                ppm,\n+                                                state.out_file);\n+                };\n+            }\n+\n+            return control;\n         }\n \n         if sess.opts.parse_only || sess.opts.debugging_opts.show_span.is_some() ||"}, {"sha": "223b6629a8814ddc58c74fa8b598ede514443150", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 236, "deletions": 216, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52a2b33a4b1c9f10e7034a758d4dff4f53129a49/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=52a2b33a4b1c9f10e7034a758d4dff4f53129a49", "patch": "@@ -15,8 +15,6 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n \n-use rustc_trans::back::link;\n-\n use {driver, abort_on_err};\n \n use rustc::dep_graph::DepGraph;\n@@ -55,7 +53,6 @@ use std::str::FromStr;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::{blocks, NodePrinter};\n use rustc::hir;\n-use rustc::hir::lowering::{lower_crate, LoweringContext};\n use rustc::hir::print as pprust_hir;\n \n use rustc::mir::mir_map::MirMap;\n@@ -89,6 +86,32 @@ pub enum PpMode {\n     PpmMirCFG,\n }\n \n+impl PpMode {\n+    pub fn needs_ast_map(&self, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n+        match *self {\n+            PpmSource(PpmNormal) |\n+            PpmSource(PpmEveryBodyLoops) |\n+            PpmSource(PpmIdentified) => opt_uii.is_some(),\n+\n+            PpmSource(PpmExpanded) |\n+            PpmSource(PpmExpandedIdentified) |\n+            PpmSource(PpmExpandedHygiene) |\n+            PpmHir(_) |\n+            PpmMir |\n+            PpmMirCFG |\n+            PpmFlowGraph(_) => true,\n+            PpmSource(PpmTyped) => panic!(\"invalid state\"),\n+        }\n+    }\n+\n+    pub fn needs_analysis(&self) -> bool {\n+        match *self {\n+             PpmMir | PpmMirCFG | PpmFlowGraph(_) => true,\n+             _ => false,\n+        }\n+    }\n+}\n+\n pub fn parse_pretty(sess: &Session,\n                     name: &str,\n                     extended: bool)\n@@ -147,7 +170,7 @@ impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n                                            sess: &'tcx Session,\n-                                           ast_map: Option<hir_map::Map<'tcx>>,\n+                                           ast_map: Option<&hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F)\n                                            -> A\n@@ -157,22 +180,22 @@ impl PpSourceMode {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n             PpmExpandedHygiene => {\n                 let annotation = HygieneAnnotation {\n                     sess: sess,\n-                    ast_map: ast_map,\n+                    ast_map: ast_map.map(|m| m.clone()),\n                 };\n                 f(&annotation, payload)\n             }\n@@ -582,40 +605,6 @@ impl UserIdentifiedItem {\n     }\n }\n \n-fn needs_ast_map(ppm: &PpMode, opt_uii: &Option<UserIdentifiedItem>) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmEveryBodyLoops) |\n-        PpmSource(PpmIdentified) => opt_uii.is_some(),\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmExpandedHygiene) |\n-        PpmHir(_) |\n-        PpmMir |\n-        PpmMirCFG |\n-        PpmFlowGraph(_) => true,\n-        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-    }\n-}\n-\n-fn needs_expansion(ppm: &PpMode) -> bool {\n-    match *ppm {\n-        PpmSource(PpmNormal) |\n-        PpmSource(PpmEveryBodyLoops) |\n-        PpmSource(PpmIdentified) => false,\n-\n-        PpmSource(PpmExpanded) |\n-        PpmSource(PpmExpandedIdentified) |\n-        PpmSource(PpmExpandedHygiene) |\n-        PpmHir(_) |\n-        PpmMir |\n-        PpmMirCFG |\n-        PpmFlowGraph(_) => true,\n-        PpmSource(PpmTyped) => panic!(\"invalid state\"),\n-    }\n-}\n-\n struct ReplaceBodyWithLoop {\n     within_static_or_const: bool,\n }\n@@ -700,89 +689,176 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     }\n }\n \n-pub fn pretty_print_input(sess: &Session,\n-                          cstore: &CStore,\n-                          input: &Input,\n-                          krate: ast::Crate,\n-                          ppm: PpMode,\n-                          opt_uii: Option<UserIdentifiedItem>,\n-                          ofile: Option<&Path>) {\n-    let krate = if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        let mut fold = ReplaceBodyWithLoop::new();\n-        fold.fold_crate(krate)\n-    } else {\n-        krate\n+fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                   tcx: &TyCtxt<'tcx>,\n+                                   mir_map: Option<&MirMap<'tcx>>,\n+                                   code: blocks::Code,\n+                                   mode: PpFlowGraphMode,\n+                                   mut out: W)\n+                                   -> io::Result<()> {\n+    let cfg = match code {\n+        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n+    };\n+    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n+    let lcfg = LabelledCFG {\n+        ast_map: &tcx.map,\n+        cfg: &cfg,\n+        name: format!(\"node_{}\", code.id()),\n+        labelled_edges: labelled_edges,\n     };\n \n-    let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n+    match code {\n+        _ if variants.is_empty() => {\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n+        }\n+        blocks::BlockCode(_) => {\n+            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n+                          fn-like node id.\");\n+            return Ok(());\n+        }\n+        blocks::FnLikeCode(fn_like) => {\n+            let (bccx, analysis_data) =\n+                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n+                                                              mir_map,\n+                                                              fn_like.to_fn_parts(),\n+                                                              &cfg);\n \n-    let is_expanded = needs_expansion(&ppm);\n-    let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n-    let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(sess, &cstore, krate, &id, None) {\n-            Err(_) => return,\n-            Ok(k) => driver::assign_node_ids(sess, k),\n+            let lcfg = borrowck_dot::DataflowLabeller {\n+                inner: lcfg,\n+                variants: variants,\n+                borrowck_ctxt: &bccx,\n+                analysis_data: &analysis_data,\n+            };\n+            let r = dot::render(&lcfg, &mut out);\n+            return expand_err_details(r);\n         }\n-    } else {\n-        krate\n-    };\n+    }\n \n-    // There is some twisted, god-forsaken tangle of lifetimes here which makes\n-    // the ordering of stuff super-finicky.\n-    let mut hir_forest;\n-    let mut _defs = None;\n-    let dep_graph = DepGraph::new(false);\n-    let arenas = ty::CtxtArenas::new();\n-    let _ignore = dep_graph.in_ignore();\n-    let ast_map = if compute_ast_map {\n-        _defs = Some(RefCell::new(hir_map::collect_definitions(&krate)));\n-        let defs = _defs.as_ref().unwrap();\n-        LocalCrateReader::new(sess, &cstore, defs, &krate, &id).read_crates(&dep_graph);\n-        let lcx = LoweringContext::new(sess, Some(&krate), defs);\n-\n-        hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate), dep_graph.clone());\n-        let map = hir_map::map_crate(&mut hir_forest, defs);\n-        Some(map)\n+    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n+        r.map_err(|ioerr| {\n+            io::Error::new(io::ErrorKind::Other,\n+                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n+        })\n+    }\n+}\n+\n+pub fn fold_crate(krate: ast::Crate, ppm: PpMode) -> ast::Crate {\n+    if let PpmSource(PpmEveryBodyLoops) = ppm {\n+        let mut fold = ReplaceBodyWithLoop::new();\n+        fold.fold_crate(krate)\n     } else {\n-        None\n-    };\n+        krate\n+    }\n+}\n \n+fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n-                  .get_filemap(&src_name[..])\n+                  .get_filemap(&src_name)\n                   .src\n                   .as_ref()\n                   .unwrap()\n                   .as_bytes()\n                   .to_vec();\n+    (src, src_name)\n+}\n+\n+fn write_output(out: Vec<u8>, ofile: Option<&Path>) {\n+    match ofile {\n+        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n+        Some(p) => {\n+            match File::create(p) {\n+                Ok(mut w) => w.write_all(&out).unwrap(),\n+                Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n+            }\n+        }\n+    }\n+}\n+\n+pub fn print_after_parsing(sess: &Session,\n+                           input: &Input,\n+                           krate: &ast::Crate,\n+                           ppm: PpMode,\n+                           ofile: Option<&Path>) {\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n+\n+    let (src, src_name) = get_source(input, sess);\n+\n     let mut rdr = &*src;\n+    let mut out = Vec::new();\n+\n+    if let PpmSource(s) = ppm {\n+        // Silently ignores an identified node.\n+        let out: &mut Write = &mut out;\n+        s.call_with_pp_support(sess, None, box out, |annotation, out| {\n+            debug!(\"pretty printing source code {:?}\", s);\n+            let sess = annotation.sess();\n+            pprust::print_crate(sess.codemap(),\n+                                sess.diagnostic(),\n+                                krate,\n+                                src_name.to_string(),\n+                                &mut rdr,\n+                                out,\n+                                annotation.pp_ann(),\n+                                false)\n+        }).unwrap()\n+    } else {\n+        unreachable!();\n+    };\n+\n+    write_output(out, ofile);\n+}\n+\n+pub fn print_after_write_deps<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                              cstore: &CStore,\n+                                              ast_map: &hir_map::Map<'tcx>,\n+                                              input: &Input,\n+                                              krate: &ast::Crate,\n+                                              crate_name: &str,\n+                                              ppm: PpMode,\n+                                              arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                              opt_uii: Option<UserIdentifiedItem>,\n+                                              ofile: Option<&Path>) {\n+    let dep_graph = DepGraph::new(false);\n+    let _ignore = dep_graph.in_ignore();\n \n+    if ppm.needs_analysis() {\n+        print_with_analysis(sess, cstore, ast_map, crate_name, arenas, ppm, opt_uii, ofile);\n+        return;\n+    }\n+\n+    let (src, src_name) = get_source(input, sess);\n+\n+    let mut rdr = &src[..];\n     let mut out = Vec::new();\n \n     match (ppm, opt_uii) {\n         (PpmSource(s), _) => {\n             // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support(sess, ast_map, box out, |annotation, out| {\n+            s.call_with_pp_support(sess, Some(ast_map), box out, |annotation, out| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n                 pprust::print_crate(sess.codemap(),\n                                     sess.diagnostic(),\n-                                    &krate,\n+                                    krate,\n                                     src_name.to_string(),\n                                     &mut rdr,\n                                     out,\n                                     annotation.pp_ann(),\n-                                    is_expanded)\n+                                    true)\n             })\n         }\n \n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n-                                       &ast_map.unwrap(),\n-                                       &arenas,\n-                                       &id,\n+                                       ast_map,\n+                                       arenas,\n+                                       crate_name,\n                                        box out,\n                                        |annotation, out, krate| {\n                                            debug!(\"pretty printing source code {:?}\", s);\n@@ -794,16 +870,16 @@ pub fn pretty_print_input(sess: &Session,\n                                                                    &mut rdr,\n                                                                    out,\n                                                                    annotation.pp_ann(),\n-                                                                   is_expanded)\n+                                                                   true)\n                                        })\n         }\n \n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(sess,\n-                                       &ast_map.unwrap(),\n-                                       &arenas,\n-                                       &id,\n+                                       ast_map,\n+                                       arenas,\n+                                       crate_name,\n                                        (out,uii),\n                                        |annotation, (out,uii), _| {\n                 debug!(\"pretty printing source code {:?}\", s);\n@@ -829,156 +905,100 @@ pub fn pretty_print_input(sess: &Session,\n                 }\n                 pp::eof(&mut pp_state.s)\n             })\n-        }\n+       }\n+       _ => unreachable!(),\n+    }.unwrap();\n+\n+    write_output(out, ofile);\n+}\n+\n+// In an ideal world, this would be a public function called by the driver after\n+// analsysis is performed. However, we want to call `phase_3_run_analysis_passes`\n+// with a different callback than the standard driver, so that isn't easy.\n+// Instead, we call that function ourselves.\n+fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n+                                       cstore: &CStore,\n+                                       ast_map: &hir_map::Map<'tcx>,\n+                                       crate_name: &str,\n+                                       arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                       ppm: PpMode,\n+                                       uii: Option<UserIdentifiedItem>,\n+                                       ofile: Option<&Path>) {\n+    let nodeid = if let Some(uii) = uii {\n+        debug!(\"pretty printing for {:?}\", uii);\n+        Some(uii.to_one_node_id(\"--unpretty\", sess, &ast_map))\n+    } else {\n+        debug!(\"pretty printing for whole crate\");\n+        None\n+    };\n \n-        (pp_type@PpmMir, uii) | (pp_type@PpmMirCFG, uii) => {\n-            let ast_map = ast_map.expect(\"--unpretty missing ast_map\");\n-            let nodeid = if let Some(uii) = uii {\n-                debug!(\"pretty printing MIR for {:?}\", uii);\n-                Some(uii.to_one_node_id(\"--unpretty\", sess, &ast_map))\n-            } else {\n-                debug!(\"pretty printing MIR for whole crate\");\n-                None\n-            };\n-            abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                             ast_map,\n-                                                             &arenas,\n-                                                             &id,\n-                                                             resolve::MakeGlobMap::No,\n-                                                             |tcx, mir_map, _, _| {\n+    let mut out = Vec::new();\n+\n+    abort_on_err(driver::phase_3_run_analysis_passes(sess,\n+                                                     ast_map.clone(),\n+                                                     arenas,\n+                                                     crate_name,\n+                                                     resolve::MakeGlobMap::No,\n+                                                     |tcx, mir_map, _, _| {\n+        match ppm {\n+            PpmMir | PpmMirCFG => {\n                 if let Some(mir_map) = mir_map {\n                     if let Some(nodeid) = nodeid {\n                         let mir = mir_map.map.get(&nodeid).unwrap_or_else(|| {\n                             sess.fatal(&format!(\"no MIR map entry for node {}\", nodeid))\n                         });\n-                        match pp_type {\n+                        match ppm {\n                             PpmMir => write_mir_pretty(tcx, iter::once((&nodeid, mir)), &mut out),\n-                            _ => write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out)\n+                            PpmMirCFG => write_mir_graphviz(tcx, iter::once((&nodeid, mir)), &mut out),\n+                            _ => unreachable!(),\n                         }?;\n                     } else {\n-                        match pp_type {\n+                        match ppm {\n                             PpmMir => write_mir_pretty(tcx, mir_map.map.iter(), &mut out),\n-                            _ => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out)\n+                            PpmMirCFG => write_mir_graphviz(tcx, mir_map.map.iter(), &mut out),\n+                            _ => unreachable!(),\n                         }?;\n                     }\n                 }\n                 Ok(())\n-            }), sess)\n-        }\n-\n-        (PpmFlowGraph(mode), opt_uii) => {\n-            debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n-            let uii = opt_uii.unwrap_or_else(|| {\n-                sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     \\\n-                                     unique path suffix (b::c::d)\"))\n+            }\n+            PpmFlowGraph(mode) => {\n+                let nodeid = nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or \\\n+                                            unique path suffix (b::c::d)\");\n+                let node = tcx.map.find(nodeid).unwrap_or_else(|| {\n+                    tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n+                });\n \n-            });\n-            let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n-            let nodeid = uii.to_one_node_id(\"--pretty\", sess, &ast_map);\n+                let code = blocks::Code::from_node(node);\n+                match code {\n+                    Some(code) => {\n+                        let variants = gather_flowgraph_variants(tcx.sess);\n \n-            let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n-            });\n+                        let out: &mut Write = &mut out;\n \n-            let code = blocks::Code::from_node(node);\n-            let out: &mut Write = &mut out;\n-            match code {\n-                Some(code) => {\n-                    let variants = gather_flowgraph_variants(sess);\n-                    abort_on_err(driver::phase_3_run_analysis_passes(sess,\n-                                                                     ast_map,\n-                                                                     &arenas,\n-                                                                     &id,\n-                                                                     resolve::MakeGlobMap::No,\n-                                                                     |tcx, mir_map, _, _| {\n                         print_flowgraph(variants,\n                                         tcx,\n                                         mir_map.as_ref(),\n                                         code,\n                                         mode,\n                                         out)\n-                    }), sess)\n-                }\n-                None => {\n-                    let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n-                                           {:?}\",\n-                                          node);\n-\n-                    // point to what was found, if there's an\n-                    // accessible span.\n-                    match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, &message[..]),\n-                        None => sess.fatal(&message[..]),\n+                    }\n+                    None => {\n+                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\\n+                                               {:?}\",\n+                                              node);\n+\n+                        // Point to what was found, if there's an accessible span.\n+                        match tcx.map.opt_span(nodeid) {\n+                            Some(sp) => tcx.sess.span_fatal(sp, &message),\n+                            None => tcx.sess.fatal(&message),\n+                        }\n                     }\n                 }\n             }\n+            _ => unreachable!(),\n         }\n-    }\n-    .unwrap();\n-\n-    match ofile {\n-        None => print!(\"{}\", String::from_utf8(out).unwrap()),\n-        Some(p) => {\n-            match File::create(p) {\n-                Ok(mut w) => w.write_all(&out).unwrap(),\n-                Err(e) => panic!(\"print-print failed to open {} due to {}\", p.display(), e),\n-            }\n-        }\n-    }\n-}\n+    }), sess).unwrap();\n \n-fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   code: blocks::Code,\n-                                   mode: PpFlowGraphMode,\n-                                   mut out: W)\n-                                   -> io::Result<()> {\n-    let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n-    };\n-    let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n-    let lcfg = LabelledCFG {\n-        ast_map: &tcx.map,\n-        cfg: &cfg,\n-        name: format!(\"node_{}\", code.id()),\n-        labelled_edges: labelled_edges,\n-    };\n-\n-    match code {\n-        _ if variants.is_empty() => {\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-        blocks::BlockCode(_) => {\n-            tcx.sess.err(\"--pretty flowgraph with -Z flowgraph-print annotations requires \\\n-                          fn-like node id.\");\n-            return Ok(());\n-        }\n-        blocks::FnLikeCode(fn_like) => {\n-            let (bccx, analysis_data) =\n-                borrowck::build_borrowck_dataflow_data_for_fn(tcx,\n-                                                              mir_map,\n-                                                              fn_like.to_fn_parts(),\n-                                                              &cfg);\n-\n-            let lcfg = borrowck_dot::DataflowLabeller {\n-                inner: lcfg,\n-                variants: variants,\n-                borrowck_ctxt: &bccx,\n-                analysis_data: &analysis_data,\n-            };\n-            let r = dot::render(&lcfg, &mut out);\n-            return expand_err_details(r);\n-        }\n-    }\n-\n-    fn expand_err_details(r: io::Result<()>) -> io::Result<()> {\n-        r.map_err(|ioerr| {\n-            io::Error::new(io::ErrorKind::Other,\n-                           &format!(\"graphviz::render failed: {}\", ioerr)[..])\n-        })\n-    }\n+    write_output(out, ofile);\n }"}]}