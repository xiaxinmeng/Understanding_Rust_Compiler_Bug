{"sha": "d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1ZTMxMTU4YTIwNGFhYThkZGM0NmJkOGI5ZjQ0YTQ3NzBkYjVjNGQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-01T00:12:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-01T00:12:36Z"}, "message": "Better support for import resolution in 3 namespaces", "tree": {"sha": "22c696b4425c4cf4e4747fb088120c0241ee4243", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c696b4425c4cf4e4747fb088120c0241ee4243"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "html_url": "https://github.com/rust-lang/rust/commit/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "428ef191e0ff3a26bb571efcdc6d7221c2ded07b", "url": "https://api.github.com/repos/rust-lang/rust/commits/428ef191e0ff3a26bb571efcdc6d7221c2ded07b", "html_url": "https://github.com/rust-lang/rust/commit/428ef191e0ff3a26bb571efcdc6d7221c2ded07b"}], "stats": {"total": 129, "additions": 107, "deletions": 22}, "files": [{"sha": "17aa510b565e90805ea2ae54cd31d8b14f80f2ba", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "patch": "@@ -33,7 +33,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n-use std::mem;\n+use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -89,6 +89,8 @@ enum SingleImports<'a> {\n     None,\n     /// Only the given single import can define the name in the namespace.\n     MaybeOne(&'a ImportDirective<'a>),\n+    /// Only one of these two single imports can define the name in the namespace.\n+    MaybeTwo(&'a ImportDirective<'a>, &'a ImportDirective<'a>),\n     /// At least one single import will define the name in the namespace.\n     AtLeastOne,\n }\n@@ -101,21 +103,28 @@ impl<'a> Default for SingleImports<'a> {\n }\n \n impl<'a> SingleImports<'a> {\n-    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>, use_extern_macros: bool) {\n         match *self {\n             SingleImports::None => *self = SingleImports::MaybeOne(directive),\n-            // If two single imports can define the name in the namespace, we can assume that at\n-            // least one of them will define it since otherwise both would have to define only one\n-            // namespace, leading to a duplicate error.\n-            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::MaybeOne(directive_one) => *self = if use_extern_macros {\n+                SingleImports::MaybeTwo(directive_one, directive)\n+            } else {\n+                SingleImports::AtLeastOne\n+            },\n+            // If three single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise we'd get duplicate errors in one of\n+            // other namespaces.\n+            SingleImports::MaybeTwo(..) => *self = SingleImports::AtLeastOne,\n             SingleImports::AtLeastOne => {}\n         };\n     }\n \n-    fn directive_failed(&mut self) {\n+    fn directive_failed(&mut self, dir: &'a ImportDirective<'a>) {\n         match *self {\n             SingleImports::None => unreachable!(),\n             SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::MaybeTwo(dir1, dir2) =>\n+                *self = SingleImports::MaybeOne(if ptr::eq(dir1, dir) { dir1 } else { dir2 }),\n             SingleImports::AtLeastOne => {}\n         }\n     }\n@@ -199,23 +208,50 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check if a single import can still define the name.\n+        let resolve_single_import = |this: &mut Self, directive: &'a ImportDirective<'a>| {\n+            let module = match directive.imported_module.get() {\n+                Some(module) => module,\n+                None => return false,\n+            };\n+            let ident = match directive.subclass {\n+                SingleImport { source, .. } => source,\n+                _ => unreachable!(),\n+            };\n+            match this.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n+                Err(Determined) => {}\n+                _ => return false,\n+            }\n+            true\n+        };\n         match resolution.single_imports {\n             SingleImports::AtLeastOne => return Err(Undetermined),\n-            SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n-                let module = match directive.imported_module.get() {\n-                    Some(module) => module,\n-                    None => return Err(Undetermined),\n-                };\n-                let ident = match directive.subclass {\n-                    SingleImport { source, .. } => source,\n-                    _ => unreachable!(),\n-                };\n-                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n-                    Err(Determined) => {}\n-                    _ => return Err(Undetermined),\n+            SingleImports::MaybeOne(directive) => {\n+                let accessible = self.is_accessible(directive.vis.get());\n+                if accessible {\n+                    if !resolve_single_import(self, directive) {\n+                        return Err(Undetermined)\n+                    }\n+                }\n+            }\n+            SingleImports::MaybeTwo(directive1, directive2) => {\n+                let accessible1 = self.is_accessible(directive1.vis.get());\n+                let accessible2 = self.is_accessible(directive2.vis.get());\n+                if accessible1 && accessible2 {\n+                    if !resolve_single_import(self, directive1) &&\n+                       !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n+                } else if accessible1 {\n+                    if !resolve_single_import(self, directive1) {\n+                        return Err(Undetermined)\n+                    }\n+                } else {\n+                    if !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n                 }\n             }\n-            SingleImports::MaybeOne(_) | SingleImports::None => {},\n+            SingleImports::None => {},\n         }\n \n         let no_unresolved_invocations =\n@@ -281,7 +317,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, .. } => {\n                 self.per_ns(|this, ns| {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.add_directive(directive);\n+                    resolution.single_imports.add_directive(directive, this.use_extern_macros);\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -575,7 +611,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.directive_failed()\n+                        resolution.single_imports.directive_failed(directive)\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {"}, {"sha": "87acf106393310c5f4799e63f4b977333a6ab239", "filename": "src/test/ui/issue-50187.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d/src%2Ftest%2Fui%2Fissue-50187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d/src%2Ftest%2Fui%2Fissue-50187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50187.rs?ref=d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(use_extern_macros, decl_macro)]\n+\n+mod type_ns {\n+    pub type A = u8;\n+}\n+mod value_ns {\n+    pub const A: u8 = 0;\n+}\n+mod macro_ns {\n+    pub macro A() {}\n+}\n+\n+mod merge2 {\n+    pub use type_ns::A;\n+    pub use value_ns::A;\n+}\n+mod merge3 {\n+    pub use type_ns::A;\n+    pub use value_ns::A;\n+    pub use macro_ns::A;\n+}\n+\n+mod use2 {\n+    pub use merge2::A;\n+}\n+mod use3 {\n+    pub use merge3::A;\n+}\n+\n+fn main() {\n+    type B2 = use2::A;\n+    let a2 = use2::A;\n+\n+    type B3 = use3::A;\n+    let a3 = use3::A;\n+    use3::A!();\n+}"}]}