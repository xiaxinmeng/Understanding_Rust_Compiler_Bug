{"sha": "a769b30a9345799a496e800e6907d75af36cfe29", "node_id": "C_kwDOAAsO6NoAKGE3NjliMzBhOTM0NTc5OWE0OTZlODAwZTY5MDdkNzVhZjM2Y2ZlMjk", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-01-13T15:35:47Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2023-03-16T10:19:30Z"}, "message": "Flatten nested format_args!() into one.", "tree": {"sha": "b866372ac9ef99bf9d449fedea8f5aa67bb7de45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b866372ac9ef99bf9d449fedea8f5aa67bb7de45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a769b30a9345799a496e800e6907d75af36cfe29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a769b30a9345799a496e800e6907d75af36cfe29", "html_url": "https://github.com/rust-lang/rust/commit/a769b30a9345799a496e800e6907d75af36cfe29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a769b30a9345799a496e800e6907d75af36cfe29/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18e305dfca6dfef07478378cb9a673fdba6ac3b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/18e305dfca6dfef07478378cb9a673fdba6ac3b3", "html_url": "https://github.com/rust-lang/rust/commit/18e305dfca6dfef07478378cb9a673fdba6ac3b3"}], "stats": {"total": 106, "additions": 102, "deletions": 4}, "files": [{"sha": "356b9bb6371e22b3227c09fa3caf43aa40b036d2", "filename": "compiler/rustc_ast/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a769b30a9345799a496e800e6907d75af36cfe29/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a769b30a9345799a496e800e6907d75af36cfe29/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=a769b30a9345799a496e800e6907d75af36cfe29", "patch": "@@ -131,8 +131,8 @@ impl FormatArguments {\n         &self.arguments[..]\n     }\n \n-    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n-        &mut self.arguments[..]\n+    pub fn all_args_mut(&mut self) -> &mut Vec<FormatArgument> {\n+        &mut self.arguments\n     }\n }\n "}, {"sha": "9954df49ce94293f33ab0dbd8371305cca59cc9a", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 100, "deletions": 2, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a769b30a9345799a496e800e6907d75af36cfe29/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a769b30a9345799a496e800e6907d75af36cfe29/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=a769b30a9345799a496e800e6907d75af36cfe29", "patch": "@@ -7,15 +7,113 @@ use rustc_hir as hir;\n use rustc_span::{\n     sym,\n     symbol::{kw, Ident},\n-    Span,\n+    Span, Symbol,\n };\n+use std::borrow::Cow;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n-        expand_format_args(self, sp, fmt)\n+        let fmt = flatten_format_args(fmt);\n+        expand_format_args(self, sp, &fmt)\n     }\n }\n \n+/// Flattens nested `format_args!()` into one.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"a {} {} {}.\", 1, format_args!(\"b{}!\", 2), 3)`\n+///\n+/// into\n+///\n+/// `format_args!(\"a {} b{}! {}.\", 1, 2, 3)`.\n+fn flatten_format_args(fmt: &FormatArgs) -> Cow<'_, FormatArgs> {\n+    let mut fmt = Cow::Borrowed(fmt);\n+    let mut i = 0;\n+    while i < fmt.template.len() {\n+        if let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i]\n+            && let FormatTrait::Display | FormatTrait::Debug = &placeholder.format_trait\n+            && let Ok(arg_index) = placeholder.argument.index\n+            && let arg = &fmt.arguments.all_args()[arg_index].expr\n+            && let ExprKind::FormatArgs(_) = &arg.kind\n+            // Check that this argument is not used by any other placeholders.\n+            && fmt.template.iter().enumerate().all(|(j, p)|\n+                i == j ||\n+                !matches!(p, FormatArgsPiece::Placeholder(placeholder)\n+                    if placeholder.argument.index == Ok(arg_index))\n+            )\n+        {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+\n+            // Take the inner FormatArgs out of the outer arguments, and\n+            // replace it by the inner arguments. (We can't just put those at\n+            // the end, because we need to preserve the order of evaluation.)\n+\n+            let args = fmt.arguments.all_args_mut();\n+            let remaining_args = args.split_off(arg_index + 1);\n+            let old_arg_offset = args.len();\n+            let fmt2 = args.pop().unwrap().expr.into_inner(); // The inner FormatArgs.\n+            let ExprKind::FormatArgs(fmt2) = fmt2.kind else { unreachable!() };\n+            let mut fmt2 = fmt2.into_inner();\n+\n+            args.append(fmt2.arguments.all_args_mut());\n+            let new_arg_offset = args.len();\n+            args.extend(remaining_args);\n+\n+            // Correct the indexes that refer to the arguments after the newly inserted arguments.\n+            for piece in &mut fmt.template {\n+                if let FormatArgsPiece::Placeholder(placeholder) = piece\n+                    && let Ok(index) = &mut placeholder.argument.index\n+                    && *index >= old_arg_offset\n+                {\n+                    *index -= old_arg_offset;\n+                    *index += new_arg_offset;\n+                }\n+            }\n+\n+            // Now merge the placeholders:\n+\n+            let mut rest = fmt.template.split_off(i + 1);\n+            fmt.template.pop(); // remove the placeholder for the nested fmt args.\n+\n+            // Coalesce adjacent literals.\n+            if let Some(FormatArgsPiece::Literal(s1)) = fmt.template.last() &&\n+               let Some(FormatArgsPiece::Literal(s2)) = fmt2.template.first_mut()\n+            {\n+                *s2 = Symbol::intern(&(s1.as_str().to_owned() + s2.as_str()));\n+                fmt.template.pop();\n+            }\n+            if let Some(FormatArgsPiece::Literal(s1)) = fmt2.template.last() &&\n+               let Some(FormatArgsPiece::Literal(s2)) = rest.first_mut()\n+            {\n+                *s2 = Symbol::intern(&(s1.as_str().to_owned() + s2.as_str()));\n+                fmt2.template.pop();\n+            }\n+\n+            for piece in fmt2.template {\n+                match piece {\n+                    FormatArgsPiece::Literal(s) => fmt.template.push(FormatArgsPiece::Literal(s)),\n+                    FormatArgsPiece::Placeholder(mut p) => {\n+                        // Correct the index to refer to the right place into the outer argument list.\n+                        if let Ok(n) = &mut p.argument.index {\n+                            *n += arg_index;\n+                        }\n+                        fmt.template.push(FormatArgsPiece::Placeholder(p));\n+                    }\n+                }\n+            }\n+            fmt.template.extend(rest);\n+\n+            // Don't increment `i` here, so we recurse into the newly added pieces.\n+        } else {\n+            i += 1;\n+        }\n+    }\n+    fmt\n+}\n+\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n enum ArgumentType {\n     Format(FormatTrait),"}]}