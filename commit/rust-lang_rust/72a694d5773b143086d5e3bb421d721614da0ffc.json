{"sha": "72a694d5773b143086d5e3bb421d721614da0ffc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYTY5NGQ1NzczYjE0MzA4NmQ1ZTNiYjQyMWQ3MjE2MTRkYTBmZmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-17T09:04:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-17T09:04:57Z"}, "message": "Merge #8862\n\n8862: internal: scalable module structure for fixits r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "061cc578b86de2cd72f8f8a57e2979e5c988f7fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061cc578b86de2cd72f8f8a57e2979e5c988f7fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72a694d5773b143086d5e3bb421d721614da0ffc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgojG5CRBK7hj4Ov3rIwAATSIIAJmoEsVOSVtVu2JZpdiDUq5F\nTV1mI9AWHjFGOig9EMlC9YMRE8AuxANCCe1BGT/ZyZimgO3iU3l+ADjjt04IVg9D\nq/rGKCxQH0tFSgyh58Gmiw8g0wTc7cQkMuugNtIfh3CpbWSyDg/9ceomXgave/iv\n6TpJPWqr/feQqd0vSzAxjdB2Qp0PJzb4imvnBPk0TF2ncSWuzInmm/+acpb/ZbLc\nAr51RF3fwuI5EU/KUiErY23aeB0uCD9h8qO5jvYW5X3BofzHwRy7vi4U3N5hVpWI\npCQhynVerpnaNXHGzytxiQBCycUx1RFOy++vCzhwzZgiPcZ9WYR8v/0gmYGKOuA=\n=rUq6\n-----END PGP SIGNATURE-----\n", "payload": "tree 061cc578b86de2cd72f8f8a57e2979e5c988f7fc\nparent fd977a8c780e062bccd6c0486067ffabc90744b3\nparent fa7fc0e5cb5343e2c59220fb91370f005c13be3a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621242297 +0000\ncommitter GitHub <noreply@github.com> 1621242297 +0000\n\nMerge #8862\n\n8862: internal: scalable module structure for fixits r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72a694d5773b143086d5e3bb421d721614da0ffc", "html_url": "https://github.com/rust-lang/rust/commit/72a694d5773b143086d5e3bb421d721614da0ffc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72a694d5773b143086d5e3bb421d721614da0ffc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd977a8c780e062bccd6c0486067ffabc90744b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd977a8c780e062bccd6c0486067ffabc90744b3", "html_url": "https://github.com/rust-lang/rust/commit/fd977a8c780e062bccd6c0486067ffabc90744b3"}, {"sha": "fa7fc0e5cb5343e2c59220fb91370f005c13be3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7fc0e5cb5343e2c59220fb91370f005c13be3a", "html_url": "https://github.com/rust-lang/rust/commit/fa7fc0e5cb5343e2c59220fb91370f005c13be3a"}], "stats": {"total": 1700, "additions": 889, "deletions": 811}, "files": [{"sha": "4172f6caedcd0e83a58a0cf9061c6f633cb33236", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 530, "changes": 531, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -375,382 +375,14 @@ mod tests {\n         assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n     }\n \n-    fn check_expect(ra_fixture: &str, expect: Expect) {\n+    pub(crate) fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n         let diagnostics = analysis\n             .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n             .unwrap();\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n-    #[test]\n-    fn test_wrap_return_type_option() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::option::Option::{self, Some, None};\n-\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    x / y$0\n-}\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-            r#\"\n-use core::option::Option::{self, Some, None};\n-\n-fn div(x: i32, y: i32) -> Option<i32> {\n-    if y == 0 {\n-        return None;\n-    }\n-    Some(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::result::Result::{self, Ok, Err};\n-\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x / y$0\n-}\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-            r#\"\n-use core::result::Result::{self, Ok, Err};\n-\n-fn div(x: i32, y: i32) -> Result<i32, ()> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_generic_functions() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::result::Result::{self, Ok, Err};\n-\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    $0x\n-}\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-            r#\"\n-use core::result::Result::{self, Ok, Err};\n-\n-fn div<T>(x: T) -> Result<T, i32> {\n-    if x == 0 {\n-        return Err(7);\n-    }\n-    Ok(x)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_handles_type_aliases() {\n-        check_fix(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::result::Result::{self, Ok, Err};\n-\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    x $0/ y\n-}\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-            r#\"\n-use core::result::Result::{self, Ok, Err};\n-\n-type MyResult<T> = Result<T, ()>;\n-\n-fn div(x: i32, y: i32) -> MyResult<i32> {\n-    if y == 0 {\n-        return Err(());\n-    }\n-    Ok(x / y)\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n-        check_no_diagnostics(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::result::Result::{self, Ok, Err};\n-\n-fn foo() -> Result<(), i32> { 0 }\n-\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n-        check_no_diagnostics(\n-            r#\"\n-//- /main.rs crate:main deps:core\n-use core::result::Result::{self, Ok, Err};\n-\n-enum SomeOtherEnum { Ok(i32), Err(String) }\n-\n-fn foo() -> SomeOtherEnum { 0 }\n-\n-//- /core/lib.rs crate:core\n-pub mod result {\n-    pub enum Result<T, E> { Ok(T), Err(E) }\n-}\n-pub mod option {\n-    pub enum Option<T> { Some(T), None }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_empty() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct {$0};\n-}\n-\"#,\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct { one: (), two: () };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_self() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32 }\n-\n-impl TestStruct {\n-    fn test_fn() { let s = Self {$0}; }\n-}\n-\"#,\n-            r#\"\n-struct TestStruct { one: i32 }\n-\n-impl TestStruct {\n-    fn test_fn() { let s = Self { one: () }; }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_enum() {\n-        check_fix(\n-            r#\"\n-enum Expr {\n-    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-}\n-\n-impl Expr {\n-    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-        Expr::Bin {$0 }\n-    }\n-}\n-\"#,\n-            r#\"\n-enum Expr {\n-    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n-}\n-\n-impl Expr {\n-    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n-        Expr::Bin { lhs: (), rhs: () }\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_partial() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct{ two: 2$0 };\n-}\n-\"#,\n-            r\"\n-struct TestStruct { one: i32, two: i64 }\n-\n-fn test_fn() {\n-    let s = TestStruct{ two: 2, one: () };\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_raw_ident() {\n-        check_fix(\n-            r#\"\n-struct TestStruct { r#type: u8 }\n-\n-fn test_fn() {\n-    TestStruct { $0 };\n-}\n-\"#,\n-            r\"\n-struct TestStruct { r#type: u8 }\n-\n-fn test_fn() {\n-    TestStruct { r#type: ()  };\n-}\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_no_diagnostic() {\n-        check_no_diagnostics(\n-            r\"\n-            struct TestStruct { one: i32, two: i64 }\n-\n-            fn test_fn() {\n-                let one = 1;\n-                let s = TestStruct{ one, two: 2 };\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n-        check_no_diagnostics(\n-            r\"\n-            struct TestStruct { one: i32, two: i64 }\n-\n-            fn test_fn() {\n-                let one = 1;\n-                let s = TestStruct{ ..a };\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_unresolved_module_diagnostic() {\n-        check_expect(\n-            r#\"mod foo;\"#,\n-            expect![[r#\"\n-                [\n-                    Diagnostic {\n-                        message: \"unresolved module\",\n-                        range: 0..8,\n-                        severity: Error,\n-                        fix: Some(\n-                            Assist {\n-                                id: AssistId(\n-                                    \"create_module\",\n-                                    QuickFix,\n-                                ),\n-                                label: \"Create module\",\n-                                group: None,\n-                                target: 0..8,\n-                                source_change: Some(\n-                                    SourceChange {\n-                                        source_file_edits: {},\n-                                        file_system_edits: [\n-                                            CreateFile {\n-                                                dst: AnchoredPathBuf {\n-                                                    anchor: FileId(\n-                                                        0,\n-                                                    ),\n-                                                    path: \"foo.rs\",\n-                                                },\n-                                                initial_contents: \"\",\n-                                            },\n-                                        ],\n-                                        is_snippet: false,\n-                                    },\n-                                ),\n-                            },\n-                        ),\n-                        unused: false,\n-                        code: Some(\n-                            DiagnosticCode(\n-                                \"unresolved-module\",\n-                            ),\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n     #[test]\n     fn test_unresolved_macro_range() {\n         check_expect(\n@@ -890,53 +522,6 @@ mod a {\n         );\n     }\n \n-    #[test]\n-    fn test_add_field_from_usage() {\n-        check_fix(\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz$0: false};\n-}\n-struct Foo {\n-    bar: i32\n-}\n-\",\n-            r\"\n-fn main() {\n-    Foo { bar: 3, baz: false};\n-}\n-struct Foo {\n-    bar: i32,\n-    baz: bool\n-}\n-\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_add_field_in_other_file_from_usage() {\n-        check_fix(\n-            r#\"\n-//- /main.rs\n-mod foo;\n-\n-fn main() {\n-    foo::Foo { bar: 3, $0baz: false};\n-}\n-//- /foo.rs\n-struct Foo {\n-    bar: i32\n-}\n-\"#,\n-            r#\"\n-struct Foo {\n-    bar: i32,\n-    pub(crate) baz: bool\n-}\n-\"#,\n-        )\n-    }\n-\n     #[test]\n     fn test_disabled_diagnostics() {\n         let mut config = DiagnosticsConfig::default();\n@@ -954,120 +539,6 @@ struct Foo {\n         assert!(!diagnostics.is_empty());\n     }\n \n-    #[test]\n-    fn test_rename_incorrect_case() {\n-        check_fix(\n-            r#\"\n-pub struct test_struct$0 { one: i32 }\n-\n-pub fn some_fn(val: test_struct) -> test_struct {\n-    test_struct { one: val.one + 1 }\n-}\n-\"#,\n-            r#\"\n-pub struct TestStruct { one: i32 }\n-\n-pub fn some_fn(val: TestStruct) -> TestStruct {\n-    TestStruct { one: val.one + 1 }\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-pub fn some_fn(NonSnakeCase$0: u8) -> u8 {\n-    NonSnakeCase\n-}\n-\"#,\n-            r#\"\n-pub fn some_fn(non_snake_case: u8) -> u8 {\n-    non_snake_case\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-pub fn SomeFn$0(val: u8) -> u8 {\n-    if val != 0 { SomeFn(val - 1) } else { val }\n-}\n-\"#,\n-            r#\"\n-pub fn some_fn(val: u8) -> u8 {\n-    if val != 0 { some_fn(val - 1) } else { val }\n-}\n-\"#,\n-        );\n-\n-        check_fix(\n-            r#\"\n-fn some_fn() {\n-    let whatAWeird_Formatting$0 = 10;\n-    another_func(whatAWeird_Formatting);\n-}\n-\"#,\n-            r#\"\n-fn some_fn() {\n-    let what_a_weird_formatting = 10;\n-    another_func(what_a_weird_formatting);\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_uppercase_const_no_diagnostics() {\n-        check_no_diagnostics(\n-            r#\"\n-fn foo() {\n-    const ANOTHER_ITEM$0: &str = \"some_item\";\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_rename_incorrect_case_struct_method() {\n-        check_fix(\n-            r#\"\n-pub struct TestStruct;\n-\n-impl TestStruct {\n-    pub fn SomeFn$0() -> TestStruct {\n-        TestStruct\n-    }\n-}\n-\"#,\n-            r#\"\n-pub struct TestStruct;\n-\n-impl TestStruct {\n-    pub fn some_fn() -> TestStruct {\n-        TestStruct\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n-        let input = r#\"fn FOO$0() {}\"#;\n-        let expected = r#\"fn foo() {}\"#;\n-\n-        let (analysis, file_position) = fixture::position(input);\n-        let diagnostics = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap();\n-        assert_eq!(diagnostics.len(), 1);\n-\n-        check_fix(input, expected);\n-    }\n-\n     #[test]\n     fn unlinked_file_prepend_first_item() {\n         cov_mark::check!(unlinked_file_prepend_before_first_item);"}, {"sha": "92b3f5a2d81a7c2e99203d49ddc118e97ac0a889", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 11, "deletions": 278, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -1,31 +1,18 @@\n //! Provides a way to attach fixes to the diagnostics.\n //! The same module also has all curret custom fixes for the diagnostics implemented.\n-use hir::{\n-    db::AstDatabase,\n-    diagnostics::{\n-        Diagnostic, IncorrectCase, MissingFields, MissingOkOrSomeInTailExpr, NoSuchField,\n-        RemoveThisSemicolon, ReplaceFilterMapNextWithFindMap, UnresolvedModule,\n-    },\n-    HasSource, HirDisplay, InFile, Semantics, VariantDef,\n-};\n+mod change_case;\n+mod create_field;\n+mod fill_missing_fields;\n+mod remove_semicolon;\n+mod replace_with_find_map;\n+mod unresolved_module;\n+mod wrap_tail_expr;\n+\n+use hir::{diagnostics::Diagnostic, Semantics};\n use ide_assists::AssistResolveStrategy;\n-use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId},\n-    source_change::{FileSystemEdit, SourceChange},\n-    RootDatabase,\n-};\n-use syntax::{\n-    algo,\n-    ast::{self, edit::IndentLevel, make, ArgListOwner},\n-    AstNode, TextRange,\n-};\n-use text_edit::TextEdit;\n+use ide_db::RootDatabase;\n \n-use crate::{\n-    diagnostics::{fix, unresolved_fix},\n-    references::rename::rename_with_semantics,\n-    Assist, FilePosition,\n-};\n+use crate::Assist;\n \n /// A [Diagnostic] that potentially has a fix available.\n ///\n@@ -42,257 +29,3 @@ pub(crate) trait DiagnosticWithFix: Diagnostic {\n         _resolve: &AssistResolveStrategy,\n     ) -> Option<Assist>;\n }\n-\n-impl DiagnosticWithFix for UnresolvedModule {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let unresolved_module = self.decl.to_node(&root);\n-        Some(fix(\n-            \"create_module\",\n-            \"Create module\",\n-            FileSystemEdit::CreateFile {\n-                dst: AnchoredPathBuf {\n-                    anchor: self.file.original_file(sema.db),\n-                    path: self.candidate.clone(),\n-                },\n-                initial_contents: \"\".to_string(),\n-            }\n-            .into(),\n-            unresolved_module.syntax().text_range(),\n-        ))\n-    }\n-}\n-\n-impl DiagnosticWithFix for NoSuchField {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        missing_record_expr_field_fix(\n-            &sema,\n-            self.file.original_file(sema.db),\n-            &self.field.to_node(&root),\n-        )\n-    }\n-}\n-\n-impl DiagnosticWithFix for MissingFields {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        // Note that although we could add a diagnostics to\n-        // fill the missing tuple field, e.g :\n-        // `struct A(usize);`\n-        // `let a = A { 0: () }`\n-        // but it is uncommon usage and it should not be encouraged.\n-        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-            return None;\n-        }\n-\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let field_list_parent = self.field_list_parent.to_node(&root);\n-        let old_field_list = field_list_parent.record_expr_field_list()?;\n-        let new_field_list = old_field_list.clone_for_update();\n-        for f in self.missed_fields.iter() {\n-            let field =\n-                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n-                    .clone_for_update();\n-            new_field_list.add_field(field);\n-        }\n-\n-        let edit = {\n-            let mut builder = TextEdit::builder();\n-            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n-                .into_text_edit(&mut builder);\n-            builder.finish()\n-        };\n-        Some(fix(\n-            \"fill_missing_fields\",\n-            \"Fill struct fields\",\n-            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n-            sema.original_range(&field_list_parent.syntax()).range,\n-        ))\n-    }\n-}\n-\n-impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let tail_expr = self.expr.to_node(&root);\n-        let tail_expr_range = tail_expr.syntax().text_range();\n-        let replacement = format!(\"{}({})\", self.required, tail_expr.syntax());\n-        let edit = TextEdit::replace(tail_expr_range, replacement);\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-        let name = if self.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n-        Some(fix(\"wrap_tail_expr\", name, source_change, tail_expr_range))\n-    }\n-}\n-\n-impl DiagnosticWithFix for RemoveThisSemicolon {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-\n-        let semicolon = self\n-            .expr\n-            .to_node(&root)\n-            .syntax()\n-            .parent()\n-            .and_then(ast::ExprStmt::cast)\n-            .and_then(|expr| expr.semicolon_token())?\n-            .text_range();\n-\n-        let edit = TextEdit::delete(semicolon);\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-\n-        Some(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon))\n-    }\n-}\n-\n-impl DiagnosticWithFix for IncorrectCase {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let name_node = self.ident.to_node(&root);\n-\n-        let name_node = InFile::new(self.file, name_node.syntax());\n-        let frange = name_node.original_file_range(sema.db);\n-        let file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n-\n-        let label = format!(\"Rename to {}\", self.suggested_text);\n-        let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n-        if resolve.should_resolve(&res.id) {\n-            let source_change = rename_with_semantics(sema, file_position, &self.suggested_text);\n-            res.source_change = Some(source_change.ok().unwrap_or_default());\n-        }\n-\n-        Some(res)\n-    }\n-}\n-\n-impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n-    fn fix(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        _resolve: &AssistResolveStrategy,\n-    ) -> Option<Assist> {\n-        let root = sema.db.parse_or_expand(self.file)?;\n-        let next_expr = self.next_expr.to_node(&root);\n-        let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n-\n-        let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n-        let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n-        let filter_map_args = filter_map_call.arg_list()?;\n-\n-        let range_to_replace =\n-            TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n-        let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n-        let trigger_range = next_expr.syntax().text_range();\n-\n-        let edit = TextEdit::replace(range_to_replace, replacement);\n-\n-        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n-\n-        Some(fix(\n-            \"replace_with_find_map\",\n-            \"Replace filter_map(..).next() with find_map()\",\n-            source_change,\n-            trigger_range,\n-        ))\n-    }\n-}\n-\n-fn missing_record_expr_field_fix(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    record_expr_field: &ast::RecordExprField,\n-) -> Option<Assist> {\n-    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match def_id {\n-        VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        VariantDef::Variant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db)?;\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field(\n-        None,\n-        make::name(&record_expr_field.field_name()?.text()),\n-        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceChange::from_text_edit(\n-        def_file_id,\n-        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    );\n-    return Some(fix(\n-        \"create_field\",\n-        \"Create field\",\n-        source_change,\n-        record_expr_field.syntax().text_range(),\n-    ));\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n-    }\n-}"}, {"sha": "80aca58a1bbd35efad57b97c1b0d7fd3d1315bbb", "filename": "crates/ide/src/diagnostics/fixes/change_case.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fchange_case.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,155 @@\n+use hir::{db::AstDatabase, diagnostics::IncorrectCase, InFile, Semantics};\n+use ide_assists::{Assist, AssistResolveStrategy};\n+use ide_db::{base_db::FilePosition, RootDatabase};\n+use syntax::AstNode;\n+\n+use crate::{\n+    diagnostics::{unresolved_fix, DiagnosticWithFix},\n+    references::rename::rename_with_semantics,\n+};\n+\n+impl DiagnosticWithFix for IncorrectCase {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let name_node = self.ident.to_node(&root);\n+\n+        let name_node = InFile::new(self.file, name_node.syntax());\n+        let frange = name_node.original_file_range(sema.db);\n+        let file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n+\n+        let label = format!(\"Rename to {}\", self.suggested_text);\n+        let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n+        if resolve.should_resolve(&res.id) {\n+            let source_change = rename_with_semantics(sema, file_position, &self.suggested_text);\n+            res.source_change = Some(source_change.ok().unwrap_or_default());\n+        }\n+\n+        Some(res)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::{\n+        diagnostics::tests::{check_fix, check_no_diagnostics},\n+        fixture, AssistResolveStrategy, DiagnosticsConfig,\n+    };\n+\n+    #[test]\n+    fn test_rename_incorrect_case() {\n+        check_fix(\n+            r#\"\n+pub struct test_struct$0 { one: i32 }\n+\n+pub fn some_fn(val: test_struct) -> test_struct {\n+    test_struct { one: val.one + 1 }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct { one: i32 }\n+\n+pub fn some_fn(val: TestStruct) -> TestStruct {\n+    TestStruct { one: val.one + 1 }\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+pub fn some_fn(NonSnakeCase$0: u8) -> u8 {\n+    NonSnakeCase\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(non_snake_case: u8) -> u8 {\n+    non_snake_case\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+pub fn SomeFn$0(val: u8) -> u8 {\n+    if val != 0 { SomeFn(val - 1) } else { val }\n+}\n+\"#,\n+            r#\"\n+pub fn some_fn(val: u8) -> u8 {\n+    if val != 0 { some_fn(val - 1) } else { val }\n+}\n+\"#,\n+        );\n+\n+        check_fix(\n+            r#\"\n+fn some_fn() {\n+    let whatAWeird_Formatting$0 = 10;\n+    another_func(whatAWeird_Formatting);\n+}\n+\"#,\n+            r#\"\n+fn some_fn() {\n+    let what_a_weird_formatting = 10;\n+    another_func(what_a_weird_formatting);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_uppercase_const_no_diagnostics() {\n+        check_no_diagnostics(\n+            r#\"\n+fn foo() {\n+    const ANOTHER_ITEM$0: &str = \"some_item\";\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_incorrect_case_struct_method() {\n+        check_fix(\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn SomeFn$0() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+            r#\"\n+pub struct TestStruct;\n+\n+impl TestStruct {\n+    pub fn some_fn() -> TestStruct {\n+        TestStruct\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n+        let input = r#\"fn FOO$0() {}\"#;\n+        let expected = r#\"fn foo() {}\"#;\n+\n+        let (analysis, file_position) = fixture::position(input);\n+        let diagnostics = analysis\n+            .diagnostics(\n+                &DiagnosticsConfig::default(),\n+                AssistResolveStrategy::All,\n+                file_position.file_id,\n+            )\n+            .unwrap();\n+        assert_eq!(diagnostics.len(), 1);\n+\n+        check_fix(input, expected);\n+    }\n+}"}, {"sha": "24e0fda52045f52290fed864b814e22f6923390e", "filename": "crates/ide/src/diagnostics/fixes/create_field.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fcreate_field.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,157 @@\n+use hir::{db::AstDatabase, diagnostics::NoSuchField, HasSource, HirDisplay, Semantics};\n+use ide_db::{base_db::FileId, source_change::SourceChange, RootDatabase};\n+use syntax::{\n+    ast::{self, edit::IndentLevel, make},\n+    AstNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, DiagnosticWithFix},\n+    Assist, AssistResolveStrategy,\n+};\n+\n+impl DiagnosticWithFix for NoSuchField {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        missing_record_expr_field_fix(\n+            &sema,\n+            self.file.original_file(sema.db),\n+            &self.field.to_node(&root),\n+        )\n+    }\n+}\n+\n+fn missing_record_expr_field_fix(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Assist> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match def_id {\n+        hir::VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        hir::VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        hir::VariantDef::Variant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db)?;\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        None,\n+        make::name(&record_expr_field.field_name()?.text()),\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceChange::from_text_edit(\n+        def_file_id,\n+        TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    );\n+\n+    return Some(fix(\n+        \"create_field\",\n+        \"Create field\",\n+        source_change,\n+        record_expr_field.syntax().text_range(),\n+    ));\n+\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::check_fix;\n+\n+    #[test]\n+    fn test_add_field_from_usage() {\n+        check_fix(\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz$0: false};\n+}\n+struct Foo {\n+    bar: i32\n+}\n+\",\n+            r\"\n+fn main() {\n+    Foo { bar: 3, baz: false};\n+}\n+struct Foo {\n+    bar: i32,\n+    baz: bool\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_add_field_in_other_file_from_usage() {\n+        check_fix(\n+            r#\"\n+//- /main.rs\n+mod foo;\n+\n+fn main() {\n+    foo::Foo { bar: 3, $0baz: false};\n+}\n+//- /foo.rs\n+struct Foo {\n+    bar: i32\n+}\n+\"#,\n+            r#\"\n+struct Foo {\n+    bar: i32,\n+    pub(crate) baz: bool\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "123c2f0af0762d1b4f1ac0c64e865b53c7a4e65e", "filename": "crates/ide/src/diagnostics/fixes/fill_missing_fields.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Ffill_missing_fields.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,192 @@\n+use hir::{db::AstDatabase, diagnostics::MissingFields, Semantics};\n+use ide_assists::AssistResolveStrategy;\n+use ide_db::{source_change::SourceChange, RootDatabase};\n+use syntax::{algo, ast::make, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    diagnostics::{fix, fixes::DiagnosticWithFix},\n+    Assist,\n+};\n+\n+impl DiagnosticWithFix for MissingFields {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        // Note that although we could add a diagnostics to\n+        // fill the missing tuple field, e.g :\n+        // `struct A(usize);`\n+        // `let a = A { 0: () }`\n+        // but it is uncommon usage and it should not be encouraged.\n+        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+            return None;\n+        }\n+\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let field_list_parent = self.field_list_parent.to_node(&root);\n+        let old_field_list = field_list_parent.record_expr_field_list()?;\n+        let new_field_list = old_field_list.clone_for_update();\n+        for f in self.missed_fields.iter() {\n+            let field =\n+                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()))\n+                    .clone_for_update();\n+            new_field_list.add_field(field);\n+        }\n+\n+        let edit = {\n+            let mut builder = TextEdit::builder();\n+            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                .into_text_edit(&mut builder);\n+            builder.finish()\n+        };\n+        Some(fix(\n+            \"fill_missing_fields\",\n+            \"Fill struct fields\",\n+            SourceChange::from_text_edit(self.file.original_file(sema.db), edit),\n+            sema.original_range(&field_list_parent.syntax()).range,\n+        ))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_fix, check_no_diagnostics};\n+\n+    #[test]\n+    fn test_fill_struct_fields_empty() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct {$0};\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct { one: (), two: () };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_self() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self {$0}; }\n+}\n+\"#,\n+            r#\"\n+struct TestStruct { one: i32 }\n+\n+impl TestStruct {\n+    fn test_fn() { let s = Self { one: () }; }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_enum() {\n+        check_fix(\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin {$0 }\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Expr {\n+    Bin { lhs: Box<Expr>, rhs: Box<Expr> }\n+}\n+\n+impl Expr {\n+    fn new_bin(lhs: Box<Expr>, rhs: Box<Expr>) -> Expr {\n+        Expr::Bin { lhs: (), rhs: () }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_partial() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2$0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let s = TestStruct{ two: 2, one: () };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_raw_ident() {\n+        check_fix(\n+            r#\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { $0 };\n+}\n+\"#,\n+            r\"\n+struct TestStruct { r#type: u8 }\n+\n+fn test_fn() {\n+    TestStruct { r#type: ()  };\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ one, two: 2 };\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n+        check_no_diagnostics(\n+            r#\"\n+struct TestStruct { one: i32, two: i64 }\n+\n+fn test_fn() {\n+    let one = 1;\n+    let s = TestStruct{ ..a };\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "058002c697f1e535aa0807e52e01507c04aac27d", "filename": "crates/ide/src/diagnostics/fixes/remove_semicolon.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fremove_semicolon.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,31 @@\n+use hir::{db::AstDatabase, diagnostics::RemoveThisSemicolon, Semantics};\n+use ide_assists::{Assist, AssistResolveStrategy};\n+use ide_db::{source_change::SourceChange, RootDatabase};\n+use syntax::{ast, AstNode};\n+use text_edit::TextEdit;\n+\n+use crate::diagnostics::{fix, DiagnosticWithFix};\n+\n+impl DiagnosticWithFix for RemoveThisSemicolon {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+\n+        let semicolon = self\n+            .expr\n+            .to_node(&root)\n+            .syntax()\n+            .parent()\n+            .and_then(ast::ExprStmt::cast)\n+            .and_then(|expr| expr.semicolon_token())?\n+            .text_range();\n+\n+        let edit = TextEdit::delete(semicolon);\n+        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n+\n+        Some(fix(\"remove_semicolon\", \"Remove this semicolon\", source_change, semicolon))\n+    }\n+}"}, {"sha": "5ddfd20648326f79ce3c032f82be1afe23768517", "filename": "crates/ide/src/diagnostics/fixes/replace_with_find_map.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Freplace_with_find_map.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,42 @@\n+use hir::{db::AstDatabase, diagnostics::ReplaceFilterMapNextWithFindMap, Semantics};\n+use ide_assists::{Assist, AssistResolveStrategy};\n+use ide_db::{source_change::SourceChange, RootDatabase};\n+use syntax::{\n+    ast::{self, ArgListOwner},\n+    AstNode, TextRange,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::diagnostics::{fix, DiagnosticWithFix};\n+\n+impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let next_expr = self.next_expr.to_node(&root);\n+        let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;\n+\n+        let filter_map_call = ast::MethodCallExpr::cast(next_call.receiver()?.syntax().clone())?;\n+        let filter_map_name_range = filter_map_call.name_ref()?.ident_token()?.text_range();\n+        let filter_map_args = filter_map_call.arg_list()?;\n+\n+        let range_to_replace =\n+            TextRange::new(filter_map_name_range.start(), next_expr.syntax().text_range().end());\n+        let replacement = format!(\"find_map{}\", filter_map_args.syntax().text());\n+        let trigger_range = next_expr.syntax().text_range();\n+\n+        let edit = TextEdit::replace(range_to_replace, replacement);\n+\n+        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n+\n+        Some(fix(\n+            \"replace_with_find_map\",\n+            \"Replace filter_map(..).next() with find_map()\",\n+            source_change,\n+            trigger_range,\n+        ))\n+    }\n+}"}, {"sha": "81244b29386e5ed7b6ffdb425c8596d91d434d25", "filename": "crates/ide/src/diagnostics/fixes/unresolved_module.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Funresolved_module.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,87 @@\n+use hir::{db::AstDatabase, diagnostics::UnresolvedModule, Semantics};\n+use ide_assists::{Assist, AssistResolveStrategy};\n+use ide_db::{base_db::AnchoredPathBuf, source_change::FileSystemEdit, RootDatabase};\n+use syntax::AstNode;\n+\n+use crate::diagnostics::{fix, DiagnosticWithFix};\n+\n+impl DiagnosticWithFix for UnresolvedModule {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let unresolved_module = self.decl.to_node(&root);\n+        Some(fix(\n+            \"create_module\",\n+            \"Create module\",\n+            FileSystemEdit::CreateFile {\n+                dst: AnchoredPathBuf {\n+                    anchor: self.file.original_file(sema.db),\n+                    path: self.candidate.clone(),\n+                },\n+                initial_contents: \"\".to_string(),\n+            }\n+            .into(),\n+            unresolved_module.syntax().text_range(),\n+        ))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::expect;\n+\n+    use crate::diagnostics::tests::check_expect;\n+\n+    #[test]\n+    fn test_unresolved_module_diagnostic() {\n+        check_expect(\n+            r#\"mod foo;\"#,\n+            expect![[r#\"\n+                [\n+                    Diagnostic {\n+                        message: \"unresolved module\",\n+                        range: 0..8,\n+                        severity: Error,\n+                        fix: Some(\n+                            Assist {\n+                                id: AssistId(\n+                                    \"create_module\",\n+                                    QuickFix,\n+                                ),\n+                                label: \"Create module\",\n+                                group: None,\n+                                target: 0..8,\n+                                source_change: Some(\n+                                    SourceChange {\n+                                        source_file_edits: {},\n+                                        file_system_edits: [\n+                                            CreateFile {\n+                                                dst: AnchoredPathBuf {\n+                                                    anchor: FileId(\n+                                                        0,\n+                                                    ),\n+                                                    path: \"foo.rs\",\n+                                                },\n+                                                initial_contents: \"\",\n+                                            },\n+                                        ],\n+                                        is_snippet: false,\n+                                    },\n+                                ),\n+                            },\n+                        ),\n+                        unused: false,\n+                        code: Some(\n+                            DiagnosticCode(\n+                                \"unresolved-module\",\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+}"}, {"sha": "66676064a5205c59b4b969536e39aabc9adfa5fa", "filename": "crates/ide/src/diagnostics/fixes/wrap_tail_expr.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fwrap_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fwrap_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes%2Fwrap_tail_expr.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -0,0 +1,211 @@\n+use hir::{db::AstDatabase, diagnostics::MissingOkOrSomeInTailExpr, Semantics};\n+use ide_assists::{Assist, AssistResolveStrategy};\n+use ide_db::{source_change::SourceChange, RootDatabase};\n+use syntax::AstNode;\n+use text_edit::TextEdit;\n+\n+use crate::diagnostics::{fix, DiagnosticWithFix};\n+\n+impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let tail_expr = self.expr.to_node(&root);\n+        let tail_expr_range = tail_expr.syntax().text_range();\n+        let replacement = format!(\"{}({})\", self.required, tail_expr.syntax());\n+        let edit = TextEdit::replace(tail_expr_range, replacement);\n+        let source_change = SourceChange::from_text_edit(self.file.original_file(sema.db), edit);\n+        let name = if self.required == \"Ok\" { \"Wrap with Ok\" } else { \"Wrap with Some\" };\n+        Some(fix(\"wrap_tail_expr\", name, source_change, tail_expr_range))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::diagnostics::tests::{check_fix, check_no_diagnostics};\n+\n+    #[test]\n+    fn test_wrap_return_type_option() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::option::Option::{self, Some, None};\n+\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    x / y$0\n+}\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+            r#\"\n+use core::option::Option::{self, Some, None};\n+\n+fn div(x: i32, y: i32) -> Option<i32> {\n+    if y == 0 {\n+        return None;\n+    }\n+    Some(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x / y$0\n+}\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div(x: i32, y: i32) -> Result<i32, ()> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_generic_functions() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    $0x\n+}\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n+\n+fn div<T>(x: T) -> Result<T, i32> {\n+    if x == 0 {\n+        return Err(7);\n+    }\n+    Ok(x)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_handles_type_aliases() {\n+        check_fix(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::result::Result::{self, Ok, Err};\n+\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    x $0/ y\n+}\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+            r#\"\n+use core::result::Result::{self, Ok, Err};\n+\n+type MyResult<T> = Result<T, ()>;\n+\n+fn div(x: i32, y: i32) -> MyResult<i32> {\n+    if y == 0 {\n+        return Err(());\n+    }\n+    Ok(x / y)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_expr_type_does_not_match_ok_type() {\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::result::Result::{self, Ok, Err};\n+\n+fn foo() -> Result<(), i32> { 0 }\n+\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_wrap_return_type_not_applicable_when_return_type_is_not_result_or_option() {\n+        check_no_diagnostics(\n+            r#\"\n+//- /main.rs crate:main deps:core\n+use core::result::Result::{self, Ok, Err};\n+\n+enum SomeOtherEnum { Ok(i32), Err(String) }\n+\n+fn foo() -> SomeOtherEnum { 0 }\n+\n+//- /core/lib.rs crate:core\n+pub mod result {\n+    pub enum Result<T, E> { Ok(T), Err(E) }\n+}\n+pub mod option {\n+    pub enum Option<T> { Some(T), None }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "6c55823eb085e34c98689038c13e8746988f46e7", "filename": "xtask/src/tidy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/72a694d5773b143086d5e3bb421d721614da0ffc/xtask%2Fsrc%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a694d5773b143086d5e3bb421d721614da0ffc/xtask%2Fsrc%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Ftidy.rs?ref=72a694d5773b143086d5e3bb421d721614da0ffc", "patch": "@@ -347,9 +347,8 @@ struct TidyDocs {\n \n impl TidyDocs {\n     fn visit(&mut self, path: &Path, text: &str) {\n-        // Test hopefully don't really need comments, and for assists we already\n-        // have special comments which are source of doc tests and user docs.\n-        if is_exclude_dir(path, &[\"tests\", \"test_data\"]) {\n+        // Tests and diagnostic fixes don't need module level comments.\n+        if is_exclude_dir(path, &[\"tests\", \"test_data\", \"fixes\"]) {\n             return;\n         }\n "}]}