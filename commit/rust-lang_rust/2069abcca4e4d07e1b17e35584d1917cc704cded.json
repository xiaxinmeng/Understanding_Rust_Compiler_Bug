{"sha": "2069abcca4e4d07e1b17e35584d1917cc704cded", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNjlhYmNjYTRlNGQwN2UxYjE3ZTM1NTg0ZDE5MTdjYzcwNGNkZWQ=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-12-25T19:59:46Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-12-25T19:59:46Z"}, "message": "Reduce dependency on pprust", "tree": {"sha": "d0da83c7cebbc9e8a7fe257d34ce417b17606be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0da83c7cebbc9e8a7fe257d34ce417b17606be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2069abcca4e4d07e1b17e35584d1917cc704cded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2069abcca4e4d07e1b17e35584d1917cc704cded", "html_url": "https://github.com/rust-lang/rust/commit/2069abcca4e4d07e1b17e35584d1917cc704cded", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2069abcca4e4d07e1b17e35584d1917cc704cded/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "954dd0869e96336c3366886d9b87c7d0d90841ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/954dd0869e96336c3366886d9b87c7d0d90841ac", "html_url": "https://github.com/rust-lang/rust/commit/954dd0869e96336c3366886d9b87c7d0d90841ac"}], "stats": {"total": 104, "additions": 57, "deletions": 47}, "files": [{"sha": "12f879eb59c696e9d6252343483ba47a4a01df32", "filename": "src/chains.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=2069abcca4e4d07e1b17e35584d1917cc704cded", "patch": "@@ -27,7 +27,6 @@ use config::BlockIndentStyle;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n-use syntax::print::pprust;\n \n pub fn rewrite_chain(mut expr: &ast::Expr,\n                      context: &RewriteContext,\n@@ -233,7 +232,9 @@ fn rewrite_method_call(method_name: ast::Ident,\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n-        let type_list = types.iter().map(|ty| pprust::ty_to_string(ty)).collect::<Vec<_>>();\n+        let type_list: Vec<_> = try_opt!(types.iter()\n+                                              .map(|ty| ty.rewrite(context, width, offset))\n+                                              .collect());\n \n         (types.last().unwrap().span.hi,\n          format!(\"::<{}>\", type_list.join(\", \")))"}, {"sha": "9882278c543a6e78474e12aa18823f6093fdf1ab", "filename": "src/items.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=2069abcca4e4d07e1b17e35584d1917cc704cded", "patch": "@@ -23,7 +23,6 @@ use config::{Config, BlockIndentStyle, Density, ReturnIndent, BraceStyle, Struct\n \n use syntax::{ast, abi};\n use syntax::codemap::{Span, BytePos, mk_sp};\n-use syntax::print::pprust;\n use syntax::parse::token;\n \n // Statements of the form\n@@ -901,42 +900,46 @@ impl Rewrite for ast::FunctionRetTy {\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         if is_named_arg(self) {\n-            if let ast::Ty_::TyInfer = self.ty.node {\n-                wrap_str(pprust::pat_to_string(&self.pat),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            } else {\n-                let mut result = pprust::pat_to_string(&self.pat);\n+            let mut result = try_opt!(self.pat.rewrite(context, width, offset));\n+\n+            if self.ty.node != ast::Ty_::TyInfer {\n                 result.push_str(\": \");\n                 let max_width = try_opt!(width.checked_sub(result.len()));\n                 let ty_str = try_opt!(self.ty.rewrite(context, max_width, offset + result.len()));\n                 result.push_str(&ty_str);\n-                Some(result)\n             }\n+\n+            Some(result)\n         } else {\n             self.ty.rewrite(context, width, offset)\n         }\n     }\n }\n \n-fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf, args: &[ast::Arg]) -> Option<String> {\n+fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n+                         args: &[ast::Arg],\n+                         context: &RewriteContext)\n+                         -> Option<String> {\n     match explicit_self.node {\n         ast::ExplicitSelf_::SelfRegion(lt, m, _) => {\n             let mut_str = format_mutability(m);\n             match lt {\n-                Some(ref l) => Some(format!(\"&{} {}self\", pprust::lifetime_to_string(l), mut_str)),\n+                Some(ref l) => {\n+                    let lifetime_str = try_opt!(l.rewrite(context,\n+                                                          usize::max_value(),\n+                                                          Indent::empty()));\n+                    Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n+                }\n                 None => Some(format!(\"&{}self\", mut_str)),\n             }\n         }\n         ast::ExplicitSelf_::SelfExplicit(ref ty, _) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n \n             let mutability = explicit_self_mutability(&args[0]);\n+            let type_str = try_opt!(ty.rewrite(context, usize::max_value(), Indent::empty()));\n \n-            Some(format!(\"{}self: {}\",\n-                         format_mutability(mutability),\n-                         pprust::ty_to_string(ty)))\n+            Some(format!(\"{}self: {}\", format_mutability(mutability), type_str))\n         }\n         ast::ExplicitSelf_::SelfValue(_) => {\n             assert!(!args.is_empty(), \"&[ast::Arg] shouldn't be empty.\");\n@@ -1237,7 +1240,7 @@ fn rewrite_args(context: &RewriteContext,\n     // FIXME: the comment for the self argument is dropped. This is blocked\n     // on rust issue #27522.\n     let min_args = explicit_self.and_then(|explicit_self| {\n-                                    rewrite_explicit_self(explicit_self, args)\n+                                    rewrite_explicit_self(explicit_self, args, context)\n                                 })\n                                 .map(|self_str| {\n                                     arg_item_strs[0] = self_str;"}, {"sha": "911bf925293c79fd403eec09354f592f51c39427", "filename": "src/types.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2069abcca4e4d07e1b17e35584d1917cc704cded/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=2069abcca4e4d07e1b17e35584d1917cc704cded", "patch": "@@ -135,12 +135,7 @@ impl<'a> SegmentParam<'a> {\n impl<'a> Rewrite for SegmentParam<'a> {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match *self {\n-            SegmentParam::LifeTime(ref lt) => {\n-                wrap_str(pprust::lifetime_to_string(lt),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            }\n+            SegmentParam::LifeTime(ref lt) => lt.rewrite(context, width, offset),\n             SegmentParam::Type(ref ty) => ty.rewrite(context, width, offset),\n             SegmentParam::Binding(ref binding) => {\n                 let mut result = format!(\"{} = \", binding.ident);\n@@ -332,12 +327,7 @@ impl Rewrite for ast::WherePredicate {\n             ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate { ref lifetime,\n                                                                              ref bounds,\n                                                                              .. }) => {\n-                format!(\"{}: {}\",\n-                        pprust::lifetime_to_string(lifetime),\n-                        bounds.iter()\n-                              .map(pprust::lifetime_to_string)\n-                              .collect::<Vec<_>>()\n-                              .join(\" + \"))\n+                try_opt!(rewrite_bounded_lifetime(lifetime, bounds.iter(), context, width, offset))\n             }\n             ast::WherePredicate::EqPredicate(ast::WhereEqPredicate { ref path, ref ty, .. }) => {\n                 let ty_str = try_opt!(ty.rewrite(context, width, offset));\n@@ -360,18 +350,27 @@ impl Rewrite for ast::WherePredicate {\n \n impl Rewrite for ast::LifetimeDef {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n-        let result = if self.bounds.is_empty() {\n-            pprust::lifetime_to_string(&self.lifetime)\n-        } else {\n-            format!(\"{}: {}\",\n-                    pprust::lifetime_to_string(&self.lifetime),\n-                    self.bounds\n-                        .iter()\n-                        .map(pprust::lifetime_to_string)\n-                        .collect::<Vec<_>>()\n-                        .join(\" + \"))\n-        };\n+        rewrite_bounded_lifetime(&self.lifetime, self.bounds.iter(), context, width, offset)\n+    }\n+}\n+\n+fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n+                                   bounds: I,\n+                                   context: &RewriteContext,\n+                                   width: usize,\n+                                   offset: Indent)\n+                                   -> Option<String>\n+    where I: ExactSizeIterator<Item = &'b ast::Lifetime>\n+{\n+    let result = try_opt!(lt.rewrite(context, width, offset));\n \n+    if bounds.len() == 0 {\n+        Some(result)\n+    } else {\n+        let appendix: Vec<_> = try_opt!(bounds.into_iter()\n+                                              .map(|b| b.rewrite(context, width, offset))\n+                                              .collect());\n+        let result = format!(\"{}: {}\", result, appendix.join(\" + \"));\n         wrap_str(result, context.config.max_width, width, offset)\n     }\n }\n@@ -386,16 +385,20 @@ impl Rewrite for ast::TyParamBound {\n                 let budget = try_opt!(width.checked_sub(1));\n                 Some(format!(\"?{}\", try_opt!(tref.rewrite(context, budget, offset + 1))))\n             }\n-            ast::TyParamBound::RegionTyParamBound(ref l) => {\n-                wrap_str(pprust::lifetime_to_string(l),\n-                         context.config.max_width,\n-                         width,\n-                         offset)\n-            }\n+            ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, width, offset),\n         }\n     }\n }\n \n+impl Rewrite for ast::Lifetime {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        wrap_str(pprust::lifetime_to_string(self),\n+                 context.config.max_width,\n+                 width,\n+                 offset)\n+    }\n+}\n+\n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         let strs: Vec<_> = try_opt!(self.iter()\n@@ -483,7 +486,10 @@ impl Rewrite for ast::Ty {\n                 let mut_len = mut_str.len();\n                 Some(match *lifetime {\n                     Some(ref lifetime) => {\n-                        let lt_str = pprust::lifetime_to_string(lifetime);\n+                        let lt_budget = try_opt!(width.checked_sub(2 + mut_len));\n+                        let lt_str = try_opt!(lifetime.rewrite(context,\n+                                                               lt_budget,\n+                                                               offset + 2 + mut_len));\n                         let lt_len = lt_str.len();\n                         let budget = try_opt!(width.checked_sub(2 + mut_len + lt_len));\n                         format!(\"&{} {}{}\","}]}