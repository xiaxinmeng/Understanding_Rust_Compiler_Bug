{"sha": "16a286b003477fe07c06c5030f0ae8298c3e78ec", "node_id": "C_kwDOAAsO6NoAKDE2YTI4NmIwMDM0NzdmZTA3YzA2YzUwMzBmMGFlODI5OGMzZTc4ZWM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-05T01:23:55Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-08T23:02:50Z"}, "message": "Simplify `cs_fold`.\n\n`cs_fold` has four distinct cases, covered by three different function\narguments:\n\n- first field\n- combine current field with previous results\n- no fields\n- non-matching enum variants\n\nThis commit clarifies things by replacing the three function arguments\nwith one that takes a new `CsFold` type with four slightly different)\ncases\n\n- single field\n- combine result for current field with results for previous fields\n- no fields\n- non-matching enum variants\n\nThis makes the code shorter and clearer.", "tree": {"sha": "36e3af5e983c3bdefac099a51bb84e730acdef8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36e3af5e983c3bdefac099a51bb84e730acdef8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a286b003477fe07c06c5030f0ae8298c3e78ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a286b003477fe07c06c5030f0ae8298c3e78ec", "html_url": "https://github.com/rust-lang/rust/commit/16a286b003477fe07c06c5030f0ae8298c3e78ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a286b003477fe07c06c5030f0ae8298c3e78ec/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "559398fa7860fff2b4058c302efb6f14312b0fe4", "url": "https://api.github.com/repos/rust-lang/rust/commits/559398fa7860fff2b4058c302efb6f14312b0fe4", "html_url": "https://github.com/rust-lang/rust/commit/559398fa7860fff2b4058c302efb6f14312b0fe4"}], "stats": {"total": 276, "additions": 114, "deletions": 162}, "files": [{"sha": "859e995356e804e8f1ff6c13dccf44ebdf1f228c", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 28, "deletions": 47, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=16a286b003477fe07c06c5030f0ae8298c3e78ec", "patch": "@@ -55,57 +55,38 @@ pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> Bl\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_expr, other_selflike_exprs| {\n-            // match new {\n-            //     ::core::cmp::Ordering::Equal => old,\n-            //     cmp => cmp\n-            // }\n-            let new = {\n-                let [other_expr] = other_selflike_exprs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                };\n+        cx,\n+        span,\n+        substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n                 let args = vec![\n-                    cx.expr_addr_of(span, self_expr),\n-                    cx.expr_addr_of(span, other_expr.clone()),\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n                 ];\n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx, args| match args {\n-            Some((span, self_expr, other_selflike_exprs)) => {\n-                let new = {\n-                    let [other_expr] = other_selflike_exprs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args = vec![\n-                        cx.expr_addr_of(span, self_expr),\n-                        cx.expr_addr_of(span, other_expr.clone()),\n-                    ];\n-                    cx.expr_call_global(span, cmp_path.clone(), args)\n-                };\n-\n-                new\n+                cx.expr_call_global(field.span, cmp_path.clone(), args)\n             }\n-            None => cx.expr_path(equal_path.clone()),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n-            } else {\n-                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n-                cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm = cx.arm(span, cx.pat_path(span, equal_path.clone()), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n             }\n-        }),\n-        cx,\n-        span,\n-        substr,\n+            CsFold::Fieldless => cx.expr_path(equal_path.clone()),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_cmp_path = cx.std_path(&[sym::cmp, sym::Ord, sym::cmp]);\n+                    cx.expr_call_global(span, fn_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "724c639984cca33f8eff63d2f78e67edadc3c4b3", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=16a286b003477fe07c06c5030f0ae8298c3e78ec", "patch": "@@ -2,8 +2,7 @@ use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::{path_local, path_std};\n \n-use rustc_ast::ptr::P;\n-use rustc_ast::{BinOpKind, Expr, MetaItem};\n+use rustc_ast::{BinOpKind, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -23,34 +22,22 @@ pub fn expand_deriving_partial_eq(\n         combiner: BinOpKind,\n         base: bool,\n     ) -> BlockOrExpr {\n-        let op = |cx: &mut ExtCtxt<'_>,\n-                  span: Span,\n-                  self_expr: P<Expr>,\n-                  other_selflike_exprs: &[P<Expr>]| {\n-            let [other_expr] = other_selflike_exprs else {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n-            };\n-\n-            cx.expr_binary(span, op, self_expr, other_expr.clone())\n-        };\n-\n         let expr = cs_fold(\n             true, // use foldl\n-            |cx, span, old, self_expr, other_selflike_exprs| {\n-                let eq = op(cx, span, self_expr, other_selflike_exprs);\n-                cx.expr_binary(span, combiner, old, eq)\n-            },\n-            |cx, args| match args {\n-                Some((span, self_expr, other_selflike_exprs)) => {\n-                    // Special-case the base case to generate cleaner code.\n-                    op(cx, span, self_expr, other_selflike_exprs)\n-                }\n-                None => cx.expr_bool(span, base),\n-            },\n-            Box::new(|cx, span, _| cx.expr_bool(span, !base)),\n             cx,\n             span,\n             substr,\n+            |cx, fold| match fold {\n+                CsFold::Single(field) => {\n+                    let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(PartialEq)`\");\n+                    };\n+                    cx.expr_binary(field.span, op, field.self_expr.clone(), other_expr.clone())\n+                }\n+                CsFold::Combine(span, expr1, expr2) => cx.expr_binary(span, combiner, expr1, expr2),\n+                CsFold::Fieldless => cx.expr_bool(span, base),\n+                CsFold::EnumNonMatching(span, _tag_tuple) => cx.expr_bool(span, !base),\n+            },\n         );\n         BlockOrExpr::new_expr(expr)\n     }"}, {"sha": "3f9843922dad74ebf22253acd39281198ea0fa87", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 30, "deletions": 51, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=16a286b003477fe07c06c5030f0ae8298c3e78ec", "patch": "@@ -63,61 +63,40 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, self_expr, other_selflike_exprs| {\n-            // match new {\n-            //     Some(::core::cmp::Ordering::Equal) => old,\n-            //     cmp => cmp\n-            // }\n-            let new = {\n-                let [other_expr] = other_selflike_exprs else {\n-                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\");\n-                };\n-\n+        cx,\n+        span,\n+        substr,\n+        |cx, fold| match fold {\n+            CsFold::Single(field) => {\n+                let [other_expr] = &field.other_selflike_exprs[..] else {\n+                        cx.span_bug(field.span, \"not exactly 2 arguments in `derive(Ord)`\");\n+                    };\n                 let args = vec![\n-                    cx.expr_addr_of(span, self_expr),\n-                    cx.expr_addr_of(span, other_expr.clone()),\n+                    cx.expr_addr_of(field.span, field.self_expr.clone()),\n+                    cx.expr_addr_of(field.span, other_expr.clone()),\n                 ];\n-\n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm =\n-                cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), old);\n-            let neq_arm = cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        |cx, args| match args {\n-            Some((span, self_expr, other_selflike_exprs)) => {\n-                let new = {\n-                    let [other_expr] = other_selflike_exprs else {\n-                            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\");\n-                        };\n-                    let args = vec![\n-                        cx.expr_addr_of(span, self_expr),\n-                        cx.expr_addr_of(span, other_expr.clone()),\n-                    ];\n-                    cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-                };\n-\n-                new\n+                cx.expr_call_global(field.span, partial_cmp_path.clone(), args)\n             }\n-            None => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n-        },\n-        Box::new(|cx, span, tag_tuple| {\n-            if tag_tuple.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n-                let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n-                let fn_partial_cmp_path =\n-                    cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n-                cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n+            CsFold::Combine(span, expr1, expr2) => {\n+                let eq_arm =\n+                    cx.arm(span, cx.pat_some(span, cx.pat_path(span, equal_path.clone())), expr1);\n+                let neq_arm =\n+                    cx.arm(span, cx.pat_ident(span, test_id), cx.expr_ident(span, test_id));\n+                cx.expr_match(span, expr2, vec![eq_arm, neq_arm])\n             }\n-        }),\n-        cx,\n-        span,\n-        substr,\n+            CsFold::Fieldless => cx.expr_some(span, cx.expr_path(equal_path.clone())),\n+            CsFold::EnumNonMatching(span, tag_tuple) => {\n+                if tag_tuple.len() != 2 {\n+                    cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                } else {\n+                    let lft = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[0]));\n+                    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, tag_tuple[1]));\n+                    let fn_partial_cmp_path =\n+                        cx.std_path(&[sym::cmp, sym::PartialOrd, sym::partial_cmp]);\n+                    cx.expr_call_global(span, fn_partial_cmp_path, vec![lft, rgt])\n+                }\n+            }\n+        },\n     );\n     BlockOrExpr::new_expr(expr)\n }"}, {"sha": "5cad71467a15e70d4cb83fb6f5c4f03c5db7e160", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 44, "deletions": 39, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a286b003477fe07c06c5030f0ae8298c3e78ec/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=16a286b003477fe07c06c5030f0ae8298c3e78ec", "patch": "@@ -296,11 +296,6 @@ pub enum SubstructureFields<'a> {\n pub type CombineSubstructureFunc<'a> =\n     Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> BlockOrExpr + 'a>;\n \n-/// Deal with non-matching enum variants. The slice is the identifiers holding\n-/// the variant index value for each of the `Self` arguments.\n-pub type EnumNonMatchCollapsedFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &[Ident]) -> P<Expr> + 'a>;\n-\n pub fn combine_substructure(\n     f: CombineSubstructureFunc<'_>,\n ) -> RefCell<CombineSubstructureFunc<'_>> {\n@@ -1601,55 +1596,65 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-/// Function to fold over fields, with three cases, to generate more efficient and concise code.\n-/// When the `substructure` has grouped fields, there are two cases:\n-/// Zero fields: call the base case function with `None` (like the usual base case of `cs_fold`).\n-/// One or more fields: call the base case function on the first value (which depends on\n-/// `use_fold`), and use that as the base case. Then perform `cs_fold` on the remainder of the\n-/// fields.\n-/// When the `substructure` is an `EnumNonMatchingCollapsed`, the result of `enum_nonmatch_f`\n-/// is returned. Statics may not be folded over.\n-pub fn cs_fold<F, B>(\n+/// The function passed to `cs_fold` is called repeatedly with a value of this\n+/// type. It describes one part of the code generation. The result is always an\n+/// expression.\n+pub enum CsFold<'a> {\n+    /// The basic case: a field expression for one or more selflike args. E.g.\n+    /// for `PartialEq::eq` this is something like `self.x == other.x`.\n+    Single(&'a FieldInfo),\n+\n+    /// The combination of two field expressions. E.g. for `PartialEq::eq` this\n+    /// is something like `<field1 equality> && <field2 equality>`.\n+    Combine(Span, P<Expr>, P<Expr>),\n+\n+    // The fallback case for a struct or enum variant with no fields.\n+    Fieldless,\n+\n+    /// The fallback case for non-matching enum variants. The slice is the\n+    /// identifiers holding the variant index value for each of the `Self`\n+    /// arguments.\n+    EnumNonMatching(Span, &'a [Ident]),\n+}\n+\n+/// Folds over fields, combining the expressions for each field in a sequence.\n+/// Statics may not be folded over.\n+pub fn cs_fold<F>(\n     use_foldl: bool,\n-    mut f: F,\n-    mut b: B,\n-    mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n     cx: &mut ExtCtxt<'_>,\n     trait_span: Span,\n     substructure: &Substructure<'_>,\n+    mut f: F,\n ) -> P<Expr>\n where\n-    F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-    B: FnMut(&mut ExtCtxt<'_>, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>,\n+    F: FnMut(&mut ExtCtxt<'_>, CsFold<'_>) -> P<Expr>,\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) | Struct(_, ref all_fields) => {\n-            let (base, rest) = match (all_fields.is_empty(), use_foldl) {\n-                (false, true) => {\n-                    let (first, rest) = all_fields.split_first().unwrap();\n-                    let args =\n-                        (first.span, first.self_expr.clone(), &first.other_selflike_exprs[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (false, false) => {\n-                    let (last, rest) = all_fields.split_last().unwrap();\n-                    let args = (last.span, last.self_expr.clone(), &last.other_selflike_exprs[..]);\n-                    (b(cx, Some(args)), rest)\n-                }\n-                (true, _) => (b(cx, None), &all_fields[..]),\n+            if all_fields.is_empty() {\n+                return f(cx, CsFold::Fieldless);\n+            }\n+\n+            let (base_field, rest) = if use_foldl {\n+                all_fields.split_first().unwrap()\n+            } else {\n+                all_fields.split_last().unwrap()\n+            };\n+\n+            let base_expr = f(cx, CsFold::Single(base_field));\n+\n+            let op = |old, field: &FieldInfo| {\n+                let new = f(cx, CsFold::Single(field));\n+                f(cx, CsFold::Combine(field.span, old, new))\n             };\n \n             if use_foldl {\n-                rest.iter().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_expr.clone(), &field.other_selflike_exprs)\n-                })\n+                rest.iter().fold(base_expr, op)\n             } else {\n-                rest.iter().rev().fold(base, |old, field| {\n-                    f(cx, field.span, old, field.self_expr.clone(), &field.other_selflike_exprs)\n-                })\n+                rest.iter().rfold(base_expr, op)\n             }\n         }\n-        EnumNonMatchingCollapsed(tuple) => enum_nonmatch_f(cx, trait_span, tuple),\n+        EnumNonMatchingCollapsed(tuple) => f(cx, CsFold::EnumNonMatching(trait_span, tuple)),\n         StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }"}]}