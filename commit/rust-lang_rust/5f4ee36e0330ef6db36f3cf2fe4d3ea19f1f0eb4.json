{"sha": "5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNGVlMzZlMDMzMGVmNmRiMzZmM2NmMmZlNGQzZWExOWYxZjBlYjQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-13T17:04:54Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-31T18:25:42Z"}, "message": "rustc_codegen_ssa: move all set_var_name calls to mir::debuginfo.", "tree": {"sha": "4b0c84a6127268b09057b5a9dd5fcd82e4eeadb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b0c84a6127268b09057b5a9dd5fcd82e4eeadb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "html_url": "https://github.com/rust-lang/rust/commit/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c58e6b5752058760263fa85cd4057d8784f3b852", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58e6b5752058760263fa85cd4057d8784f3b852", "html_url": "https://github.com/rust-lang/rust/commit/c58e6b5752058760263fa85cd4057d8784f3b852"}], "stats": {"total": 390, "additions": 217, "deletions": 173}, "files": [{"sha": "cd209717cc4d76f61eccaf70c58437e9ca12988e", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 112, "deletions": 34, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -7,10 +7,12 @@ use rustc::ty::layout::HasTyCtxt;\n use rustc_target::abi::{Variants, VariantIdx};\n use crate::traits::*;\n \n+use std::fmt;\n use syntax_pos::{DUMMY_SP, BytePos, Span};\n use syntax::symbol::kw;\n \n use super::{FunctionCx, LocalRef};\n+use super::OperandValue;\n \n pub enum FunctionDebugContext<D> {\n     RegularContext(FunctionDebugContextData<D>),\n@@ -90,6 +92,29 @@ impl<D> DebugScope<D> {\n     }\n }\n \n+// HACK(eddyb) helpers for `set_var_name` calls, move elsewhere?\n+enum Either<T, U> {\n+    Left(T),\n+    Right(U),\n+}\n+\n+impl<T: fmt::Display, U: fmt::Display> fmt::Display for Either<T, U> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            Either::Left(x) => x.fmt(f),\n+            Either::Right(x) => x.fmt(f),\n+        }\n+    }\n+}\n+\n+struct DisplayViaDebug<T>(T);\n+\n+impl<T: fmt::Debug> fmt::Display for DisplayViaDebug<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn set_debug_loc(\n         &mut self,\n@@ -149,54 +174,107 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    pub fn debug_declare_locals(&self, bx: &mut Bx) {\n-        let tcx = self.cx.tcx();\n+    /// Apply debuginfo and/or name, after creating the `alloca` for a local,\n+    /// or initializing the local with an operand (whichever applies).\n+    // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n+    // not just `llvm.dbg.declare` (which requires `alloca`).\n+    pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n         let upvar_debuginfo = &self.mir.__upvar_debuginfo_codegen_only_do_not_use;\n \n-        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+        // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n+        if local == mir::RETURN_PLACE {\n             return;\n         }\n \n-        for (local, local_ref) in self.locals.iter_enumerated() {\n-            if local == mir::RETURN_PLACE {\n-                continue;\n+        let decl = &self.mir.local_decls[local];\n+        let (name, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+            let arg_index = local.index() - 1;\n+\n+            // Add debuginfo even to unnamed arguments.\n+            // FIXME(eddyb) is this really needed?\n+            let name = if arg_index == 0 && !upvar_debuginfo.is_empty() {\n+                // Hide closure environments from debuginfo.\n+                // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n+                // be offset to account for the hidden environment?\n+                None\n+            } else {\n+                Some(decl.name.unwrap_or(kw::Invalid))\n+            };\n+            (name, VariableKind::ArgumentVariable(arg_index + 1))\n+        } else {\n+            (decl.name, VariableKind::LocalVariable)\n+        };\n+\n+        let local_ref = &self.locals[local];\n+\n+        {\n+            let name = match name {\n+                Some(name) if name != kw::Invalid => Either::Left(name),\n+                _ => Either::Right(DisplayViaDebug(local)),\n+            };\n+            match local_ref {\n+                LocalRef::Place(place) |\n+                LocalRef::UnsizedPlace(place) => {\n+                    bx.set_var_name(place.llval, name);\n+                }\n+                LocalRef::Operand(Some(operand)) => match operand.val {\n+                    OperandValue::Ref(x, ..) |\n+                    OperandValue::Immediate(x) => {\n+                        bx.set_var_name(x, name);\n+                    }\n+                    OperandValue::Pair(a, b) => {\n+                        // FIXME(eddyb) these are scalar components,\n+                        // maybe extract the high-level fields?\n+                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n+                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n+                    }\n+                }\n+                LocalRef::Operand(None) => {}\n+            }\n+        }\n+\n+        if let Some(name) = name {\n+            if bx.sess().opts.debuginfo != DebugInfo::Full {\n+                return;\n             }\n \n             // FIXME(eddyb) add debuginfo for unsized places too.\n             let place = match local_ref {\n                 LocalRef::Place(place) => place,\n-                _ => continue,\n+                _ => return,\n             };\n \n-            let decl = &self.mir.local_decls[local];\n-            let (name, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n-                let arg_index = local.index() - 1;\n-\n-                // Add debuginfo even to unnamed arguments.\n-                // FIXME(eddyb) is this really needed?\n-                let name = if arg_index == 0 && !upvar_debuginfo.is_empty() {\n-                    // Hide closure environments from debuginfo.\n-                    // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n-                    // be offset to account for the hidden environment?\n-                    None\n-                } else {\n-                    Some(decl.name.unwrap_or(kw::Invalid))\n-                };\n-                (name, VariableKind::ArgumentVariable(arg_index + 1))\n-            } else {\n-                (decl.name, VariableKind::LocalVariable)\n-            };\n-            if let Some(name) = name {\n-                let (scope, span) = self.debug_loc(mir::SourceInfo {\n-                    span: decl.source_info.span,\n-                    scope: decl.visibility_scope,\n-                });\n-                if let Some(scope) = scope {\n-                    bx.declare_local(&self.debug_context, name, place.layout.ty, scope,\n-                        VariableAccess::DirectVariable { alloca: place.llval },\n-                        kind, span);\n+            let (scope, span) = self.debug_loc(mir::SourceInfo {\n+                span: decl.source_info.span,\n+                scope: decl.visibility_scope,\n+            });\n+            if let Some(scope) = scope {\n+                bx.declare_local(&self.debug_context, name, place.layout.ty, scope,\n+                    VariableAccess::DirectVariable { alloca: place.llval },\n+                    kind, span);\n+            }\n+        }\n+    }\n+\n+    pub fn debug_introduce_locals(&self, bx: &mut Bx) {\n+        let tcx = self.cx.tcx();\n+        let upvar_debuginfo = &self.mir.__upvar_debuginfo_codegen_only_do_not_use;\n+\n+        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+            // HACK(eddyb) figure out a way to perhaps disentangle\n+            // the use of `declare_local` and `set_var_name`.\n+            // Or maybe just running this loop always is not that expensive?\n+            if !bx.sess().fewer_names() {\n+                for local in self.locals.indices() {\n+                    self.debug_introduce_local(bx, local);\n                 }\n             }\n+\n+            return;\n+        }\n+\n+        for local in self.locals.indices() {\n+            self.debug_introduce_local(bx, local);\n         }\n \n         // Declare closure captures as if they were local variables."}, {"sha": "4e0974e6b85c81a2ab3deaaf8c3cd990a4015a45", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 39, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -190,31 +190,15 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n-            let decl_name = decl.name.map(|name| name.as_str());\n-            let decl_name = decl_name.as_ref().map(|name| &name[..]);\n-            let name;\n-            let name = if let Some(name) = decl_name {\n-                name\n-            } else {\n-                // FIXME(eddyb) compute something else for the name so no work is done\n-                // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n-                name = format!(\"{:?}\", local);\n-                &name\n-            };\n-\n             if memory_locals.contains(local) {\n-                debug!(\"alloc: {:?} ({}) -> place\", local, name);\n+                debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    let indirect_place = PlaceRef::alloca_unsized_indirect(&mut bx, layout);\n-                    bx.set_var_name(indirect_place.llval, name);\n-                    LocalRef::UnsizedPlace(indirect_place)\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n                 } else {\n-                    let place = PlaceRef::alloca(&mut bx, layout);\n-                    bx.set_var_name(place.llval, name);\n-                    LocalRef::Place(place)\n+                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n                 }\n             } else {\n-                debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n+                debug!(\"alloc: {:?} -> operand\", local);\n                 LocalRef::new_operand(&mut bx, layout)\n             }\n         };\n@@ -227,7 +211,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_declare_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut bx);\n \n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n@@ -343,13 +327,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n-        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n-        let name = if let Some(name) = arg_decl.name {\n-            name.as_str().to_string()\n-        } else {\n-            format!(\"{:?}\", local)\n-        };\n-\n         if Some(local) == mir.spread_arg {\n             // This argument (e.g., the last argument in the \"rust-call\" ABI)\n             // is a tuple that was spread at the ABI level and now we have\n@@ -363,7 +340,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             };\n \n             let place = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n-            bx.set_var_name(place.llval, name);\n             for i in 0..tupled_arg_tys.len() {\n                 let arg = &fx.fn_ty.args[idx];\n                 idx += 1;\n@@ -381,7 +357,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let arg_ty = fx.monomorphize(&arg_decl.ty);\n \n             let va_list = PlaceRef::alloca(bx, bx.layout_of(arg_ty));\n-            bx.set_var_name(va_list.llval, name);\n             bx.va_start(va_list.llval);\n \n             return LocalRef::Place(va_list);\n@@ -404,7 +379,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n                 PassMode::Direct(_) => {\n                     let llarg = bx.get_param(llarg_idx);\n-                    bx.set_var_name(llarg, &name);\n                     llarg_idx += 1;\n                     return local(\n                         OperandRef::from_immediate_or_packed_pair(bx, llarg, arg.layout));\n@@ -413,11 +387,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     let (a, b) = (bx.get_param(llarg_idx), bx.get_param(llarg_idx + 1));\n                     llarg_idx += 2;\n \n-                    // FIXME(eddyb) these are scalar components,\n-                    // maybe extract the high-level fields?\n-                    bx.set_var_name(a, format_args!(\"{}.0\", name));\n-                    bx.set_var_name(b, format_args!(\"{}.1\", name));\n-\n                     return local(OperandRef {\n                         val: OperandValue::Pair(a, b),\n                         layout: arg.layout\n@@ -432,7 +401,6 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes\n             let llarg = bx.get_param(llarg_idx);\n-            bx.set_var_name(llarg, &name);\n             llarg_idx += 1;\n             LocalRef::Place(PlaceRef::new_sized(llarg, arg.layout))\n         } else if arg.is_unsized_indirect() {\n@@ -445,12 +413,10 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let indirect_operand = OperandValue::Pair(llarg, llextra);\n \n             let tmp = PlaceRef::alloca_unsized_indirect(bx, arg.layout);\n-            bx.set_var_name(tmp.llval, name);\n             indirect_operand.store(bx, tmp);\n             LocalRef::UnsizedPlace(tmp)\n         } else {\n             let tmp = PlaceRef::alloca(bx, arg.layout);\n-            bx.set_var_name(tmp.llval, name);\n             bx.store_fn_arg(arg, &mut llarg_idx, tmp);\n             LocalRef::Place(tmp)\n         }"}, {"sha": "d11601be0b4ab3d02e0a249a0ab4874997ce6d05", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -27,21 +27,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[index].name {\n-                                match operand.val {\n-                                    OperandValue::Ref(x, ..) |\n-                                    OperandValue::Immediate(x) => {\n-                                        bx.set_var_name(x, name);\n-                                    }\n-                                    OperandValue::Pair(a, b) => {\n-                                        // FIXME(eddyb) these are scalar components,\n-                                        // maybe extract the high-level fields?\n-                                        bx.set_var_name(a, format_args!(\"{}.0\", name));\n-                                        bx.set_var_name(b, format_args!(\"{}.1\", name));\n-                                    }\n-                                }\n-                            }\n                             self.locals[index] = LocalRef::Operand(Some(operand));\n+                            self.debug_introduce_local(&mut bx, index);\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {"}, {"sha": "4a5b7c05231dcb05f428f70ce3a91b46b4cc8c4a", "filename": "src/test/codegen/optimize-attr-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Foptimize-attr-1.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -8,7 +8,7 @@\n \n // CHECK-LABEL: define i32 @nothing\n // CHECK-SAME: [[NOTHING_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 4\n // SPEEC-OPT: ret i32 4\n #[no_mangle]\n@@ -18,7 +18,7 @@ pub fn nothing() -> i32 {\n \n // CHECK-LABEL: define i32 @size\n // CHECK-SAME: [[SIZE_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 6\n // SPEED-OPT: ret i32 6\n #[optimize(size)]\n@@ -31,7 +31,7 @@ pub fn size() -> i32 {\n // NO-OPT-SAME: [[NOTHING_ATTRS]]\n // SPEED-OPT-SAME: [[NOTHING_ATTRS]]\n // SIZE-OPT-SAME: [[SPEED_ATTRS:#[0-9]+]]\n-// NO-OPT: ret i32 %1\n+// NO-OPT: ret i32 %_1.0\n // SIZE-OPT: ret i32 8\n // SPEED-OPT: ret i32 8\n #[optimize(speed)]"}, {"sha": "267c995e0704ff453534de86a953c3ba67aa0aee", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-arithmetic-saturating.rs", "status": "modified", "additions": 87, "deletions": 80, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-arithmetic-saturating.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -116,143 +116,150 @@ extern \"platform-intrinsic\" {\n     fn simd_saturating_sub<T>(x: T, y: T) -> T;\n }\n \n+// NOTE(eddyb) `%{{x|_3}}` is used because on some targets (e.g. WASM)\n+// SIMD vectors are passed directly, resulting in `%x` being a vector,\n+// while on others they're passed indirectly, resulting in `%x` being\n+// a pointer to a vector, and `%_3` a vector loaded from that pointer.\n+// This is controlled by the target spec option `simd_types_indirect`.\n+// The same applies to `%{{y|_4}}` as well.\n+\n // CHECK-LABEL: @sadd_i8x2\n #[no_mangle]\n pub unsafe fn sadd_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.sadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x4\n #[no_mangle]\n pub unsafe fn sadd_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.sadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x8\n #[no_mangle]\n pub unsafe fn sadd_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.sadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x16\n #[no_mangle]\n pub unsafe fn sadd_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.sadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x32\n #[no_mangle]\n pub unsafe fn sadd_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.sadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i8x64\n #[no_mangle]\n pub unsafe fn sadd_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.sadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x2\n #[no_mangle]\n pub unsafe fn sadd_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.sadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x4\n #[no_mangle]\n pub unsafe fn sadd_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.sadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x8\n #[no_mangle]\n pub unsafe fn sadd_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.sadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x16\n #[no_mangle]\n pub unsafe fn sadd_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.sadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i16x32\n #[no_mangle]\n pub unsafe fn sadd_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.sadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x2\n #[no_mangle]\n pub unsafe fn sadd_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.sadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x4\n #[no_mangle]\n pub unsafe fn sadd_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.sadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x8\n #[no_mangle]\n pub unsafe fn sadd_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.sadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i32x16\n #[no_mangle]\n pub unsafe fn sadd_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.sadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x2\n #[no_mangle]\n pub unsafe fn sadd_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.sadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x4\n #[no_mangle]\n pub unsafe fn sadd_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.sadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i64x8\n #[no_mangle]\n pub unsafe fn sadd_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.sadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x2\n #[no_mangle]\n pub unsafe fn sadd_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.sadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @sadd_i128x4\n #[no_mangle]\n pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.sadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n@@ -261,140 +268,140 @@ pub unsafe fn sadd_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @uadd_u8x2\n #[no_mangle]\n pub unsafe fn uadd_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.uadd.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x4\n #[no_mangle]\n pub unsafe fn uadd_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.uadd.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x8\n #[no_mangle]\n pub unsafe fn uadd_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.uadd.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x16\n #[no_mangle]\n pub unsafe fn uadd_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.uadd.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x32\n #[no_mangle]\n pub unsafe fn uadd_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.uadd.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u8x64\n #[no_mangle]\n pub unsafe fn uadd_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.uadd.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x2\n #[no_mangle]\n pub unsafe fn uadd_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.uadd.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x4\n #[no_mangle]\n pub unsafe fn uadd_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.uadd.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x8\n #[no_mangle]\n pub unsafe fn uadd_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.uadd.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x16\n #[no_mangle]\n pub unsafe fn uadd_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.uadd.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u16x32\n #[no_mangle]\n pub unsafe fn uadd_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.uadd.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x2\n #[no_mangle]\n pub unsafe fn uadd_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.uadd.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x4\n #[no_mangle]\n pub unsafe fn uadd_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.uadd.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x8\n #[no_mangle]\n pub unsafe fn uadd_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.uadd.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u32x16\n #[no_mangle]\n pub unsafe fn uadd_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.uadd.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x2\n #[no_mangle]\n pub unsafe fn uadd_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.uadd.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x4\n #[no_mangle]\n pub unsafe fn uadd_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.uadd.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u64x8\n #[no_mangle]\n pub unsafe fn uadd_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.uadd.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x2\n #[no_mangle]\n pub unsafe fn uadd_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.uadd.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n // CHECK-LABEL: @uadd_u128x4\n #[no_mangle]\n pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.uadd.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_add(x, y)\n }\n \n@@ -405,140 +412,140 @@ pub unsafe fn uadd_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n // CHECK-LABEL: @ssub_i8x2\n #[no_mangle]\n pub unsafe fn ssub_i8x2(x: i8x2, y: i8x2) -> i8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.ssub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x4\n #[no_mangle]\n pub unsafe fn ssub_i8x4(x: i8x4, y: i8x4) -> i8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.ssub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x8\n #[no_mangle]\n pub unsafe fn ssub_i8x8(x: i8x8, y: i8x8) -> i8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.ssub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x16\n #[no_mangle]\n pub unsafe fn ssub_i8x16(x: i8x16, y: i8x16) -> i8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.ssub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x32\n #[no_mangle]\n pub unsafe fn ssub_i8x32(x: i8x32, y: i8x32) -> i8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.ssub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i8x64\n #[no_mangle]\n pub unsafe fn ssub_i8x64(x: i8x64, y: i8x64) -> i8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.ssub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x2\n #[no_mangle]\n pub unsafe fn ssub_i16x2(x: i16x2, y: i16x2) -> i16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.ssub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x4\n #[no_mangle]\n pub unsafe fn ssub_i16x4(x: i16x4, y: i16x4) -> i16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.ssub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x8\n #[no_mangle]\n pub unsafe fn ssub_i16x8(x: i16x8, y: i16x8) -> i16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.ssub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x16\n #[no_mangle]\n pub unsafe fn ssub_i16x16(x: i16x16, y: i16x16) -> i16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.ssub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i16x32\n #[no_mangle]\n pub unsafe fn ssub_i16x32(x: i16x32, y: i16x32) -> i16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.ssub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x2\n #[no_mangle]\n pub unsafe fn ssub_i32x2(x: i32x2, y: i32x2) -> i32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.ssub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x4\n #[no_mangle]\n pub unsafe fn ssub_i32x4(x: i32x4, y: i32x4) -> i32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.ssub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x8\n #[no_mangle]\n pub unsafe fn ssub_i32x8(x: i32x8, y: i32x8) -> i32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.ssub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i32x16\n #[no_mangle]\n pub unsafe fn ssub_i32x16(x: i32x16, y: i32x16) -> i32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.ssub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x2\n #[no_mangle]\n pub unsafe fn ssub_i64x2(x: i64x2, y: i64x2) -> i64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.ssub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x4\n #[no_mangle]\n pub unsafe fn ssub_i64x4(x: i64x4, y: i64x4) -> i64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.ssub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i64x8\n #[no_mangle]\n pub unsafe fn ssub_i64x8(x: i64x8, y: i64x8) -> i64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.ssub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x2\n #[no_mangle]\n pub unsafe fn ssub_i128x2(x: i128x2, y: i128x2) -> i128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.ssub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @ssub_i128x4\n #[no_mangle]\n pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.ssub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n@@ -547,139 +554,139 @@ pub unsafe fn ssub_i128x4(x: i128x4, y: i128x4) -> i128x4 {\n // CHECK-LABEL: @usub_u8x2\n #[no_mangle]\n pub unsafe fn usub_u8x2(x: u8x2, y: u8x2) -> u8x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{[0-9a-z]+}}, <2 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i8> @llvm.usub.sat.v2i8(<2 x i8> %{{x|_3}}, <2 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x4\n #[no_mangle]\n pub unsafe fn usub_u8x4(x: u8x4, y: u8x4) -> u8x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{[0-9a-z]+}}, <4 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i8> @llvm.usub.sat.v4i8(<4 x i8> %{{x|_3}}, <4 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x8\n #[no_mangle]\n pub unsafe fn usub_u8x8(x: u8x8, y: u8x8) -> u8x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{[0-9a-z]+}}, <8 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i8> @llvm.usub.sat.v8i8(<8 x i8> %{{x|_3}}, <8 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x16\n #[no_mangle]\n pub unsafe fn usub_u8x16(x: u8x16, y: u8x16) -> u8x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{[0-9a-z]+}}, <16 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i8> @llvm.usub.sat.v16i8(<16 x i8> %{{x|_3}}, <16 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x32\n #[no_mangle]\n pub unsafe fn usub_u8x32(x: u8x32, y: u8x32) -> u8x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{[0-9a-z]+}}, <32 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i8> @llvm.usub.sat.v32i8(<32 x i8> %{{x|_3}}, <32 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u8x64\n #[no_mangle]\n pub unsafe fn usub_u8x64(x: u8x64, y: u8x64) -> u8x64 {\n-    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{[0-9a-z]+}}, <64 x i8> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <64 x i8> @llvm.usub.sat.v64i8(<64 x i8> %{{x|_3}}, <64 x i8> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x2\n #[no_mangle]\n pub unsafe fn usub_u16x2(x: u16x2, y: u16x2) -> u16x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{[0-9a-z]+}}, <2 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i16> @llvm.usub.sat.v2i16(<2 x i16> %{{x|_3}}, <2 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x4\n #[no_mangle]\n pub unsafe fn usub_u16x4(x: u16x4, y: u16x4) -> u16x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{[0-9a-z]+}}, <4 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i16> @llvm.usub.sat.v4i16(<4 x i16> %{{x|_3}}, <4 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x8\n #[no_mangle]\n pub unsafe fn usub_u16x8(x: u16x8, y: u16x8) -> u16x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{[0-9a-z]+}}, <8 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i16> @llvm.usub.sat.v8i16(<8 x i16> %{{x|_3}}, <8 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x16\n #[no_mangle]\n pub unsafe fn usub_u16x16(x: u16x16, y: u16x16) -> u16x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{[0-9a-z]+}}, <16 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i16> @llvm.usub.sat.v16i16(<16 x i16> %{{x|_3}}, <16 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u16x32\n #[no_mangle]\n pub unsafe fn usub_u16x32(x: u16x32, y: u16x32) -> u16x32 {\n-    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{[0-9a-z]+}}, <32 x i16> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <32 x i16> @llvm.usub.sat.v32i16(<32 x i16> %{{x|_3}}, <32 x i16> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x2\n #[no_mangle]\n pub unsafe fn usub_u32x2(x: u32x2, y: u32x2) -> u32x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{[0-9a-z]+}}, <2 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i32> @llvm.usub.sat.v2i32(<2 x i32> %{{x|_3}}, <2 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x4\n #[no_mangle]\n pub unsafe fn usub_u32x4(x: u32x4, y: u32x4) -> u32x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{[0-9a-z]+}}, <4 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i32> @llvm.usub.sat.v4i32(<4 x i32> %{{x|_3}}, <4 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x8\n #[no_mangle]\n pub unsafe fn usub_u32x8(x: u32x8, y: u32x8) -> u32x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{[0-9a-z]+}}, <8 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i32> @llvm.usub.sat.v8i32(<8 x i32> %{{x|_3}}, <8 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u32x16\n #[no_mangle]\n pub unsafe fn usub_u32x16(x: u32x16, y: u32x16) -> u32x16 {\n-    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{[0-9a-z]+}}, <16 x i32> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <16 x i32> @llvm.usub.sat.v16i32(<16 x i32> %{{x|_3}}, <16 x i32> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x2\n #[no_mangle]\n pub unsafe fn usub_u64x2(x: u64x2, y: u64x2) -> u64x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{[0-9a-z]+}}, <2 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i64> @llvm.usub.sat.v2i64(<2 x i64> %{{x|_3}}, <2 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x4\n #[no_mangle]\n pub unsafe fn usub_u64x4(x: u64x4, y: u64x4) -> u64x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{[0-9a-z]+}}, <4 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i64> @llvm.usub.sat.v4i64(<4 x i64> %{{x|_3}}, <4 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u64x8\n #[no_mangle]\n pub unsafe fn usub_u64x8(x: u64x8, y: u64x8) -> u64x8 {\n-    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{[0-9a-z]+}}, <8 x i64> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <8 x i64> @llvm.usub.sat.v8i64(<8 x i64> %{{x|_3}}, <8 x i64> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x2\n #[no_mangle]\n pub unsafe fn usub_u128x2(x: u128x2, y: u128x2) -> u128x2 {\n-    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{[0-9a-z]+}}, <2 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <2 x i128> @llvm.usub.sat.v2i128(<2 x i128> %{{x|_3}}, <2 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }\n \n // CHECK-LABEL: @usub_u128x4\n #[no_mangle]\n pub unsafe fn usub_u128x4(x: u128x4, y: u128x4) -> u128x4 {\n-    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{[0-9a-z]+}}, <4 x i128> %{{[0-9a-z]+}})\n+    // CHECK: %{{[0-9]+}} = call <4 x i128> @llvm.usub.sat.v4i128(<4 x i128> %{{x|_3}}, <4 x i128> %{{y|_4}})\n     simd_saturating_sub(x, y)\n }"}, {"sha": "87c8b0d87d8bbc575425b69fe327a68d3f0bf2c7", "filename": "src/test/codegen/simd-intrinsic/simd-intrinsic-generic-bitmask.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-bitmask.rs?ref=5f4ee36e0330ef6db36f3cf2fe4d3ea19f1f0eb4", "patch": "@@ -26,10 +26,16 @@ extern \"platform-intrinsic\" {\n     fn simd_bitmask<T, U>(x: T) -> U;\n }\n \n+// NOTE(eddyb) `%{{x|_2}}` is used because on some targets (e.g. WASM)\n+// SIMD vectors are passed directly, resulting in `%x` being a vector,\n+// while on others they're passed indirectly, resulting in `%x` being\n+// a pointer to a vector, and `%_2` a vector loaded from that pointer.\n+// This is controlled by the target spec option `simd_types_indirect`.\n+\n // CHECK-LABEL: @bitmask_int\n #[no_mangle]\n pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{[0-9a-z]+}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -39,7 +45,7 @@ pub unsafe fn bitmask_int(x: i32x2) -> u8 {\n // CHECK-LABEL: @bitmask_uint\n #[no_mangle]\n pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{[0-9a-z]+}}, <i32 31, i32 31>\n+    // CHECK: [[A:%[0-9]+]] = lshr <2 x i32> %{{x|_2}}, <i32 31, i32 31>\n     // CHECK: [[B:%[0-9]+]] = trunc <2 x i32> [[A]] to <2 x i1>\n     // CHECK: [[C:%[0-9]+]] = bitcast <2 x i1> [[B]] to i2\n     // CHECK: %{{[0-9]+}} = zext i2 [[C]] to i8\n@@ -49,7 +55,7 @@ pub unsafe fn bitmask_uint(x: u32x2) -> u8 {\n // CHECK-LABEL: @bitmask_int16\n #[no_mangle]\n pub unsafe fn bitmask_int16(x: i8x16) -> u16 {\n-    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{[0-9a-z]+}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n+    // CHECK: [[A:%[0-9]+]] = lshr <16 x i8> %{{x|_2}}, <i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7, i8 7>\n     // CHECK: [[B:%[0-9]+]] = trunc <16 x i8> [[A]] to <16 x i1>\n     // CHECK: %{{[0-9]+}} = bitcast <16 x i1> [[B]] to i16\n     // CHECK-NOT: zext"}]}