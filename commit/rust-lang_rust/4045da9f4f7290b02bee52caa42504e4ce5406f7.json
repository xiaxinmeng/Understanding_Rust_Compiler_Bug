{"sha": "4045da9f4f7290b02bee52caa42504e4ce5406f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNDVkYTlmNGY3MjkwYjAyYmVlNTJjYWE0MjUwNGU0Y2U1NDA2Zjc=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-17T11:27:17Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-05-21T14:04:10Z"}, "message": "syntax/ext: modernise ext_ctxt to be CamelCase and use new.", "tree": {"sha": "b29a484fe04e1c301fb33b9673f01087219bb71a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29a484fe04e1c301fb33b9673f01087219bb71a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4045da9f4f7290b02bee52caa42504e4ce5406f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4045da9f4f7290b02bee52caa42504e4ce5406f7", "html_url": "https://github.com/rust-lang/rust/commit/4045da9f4f7290b02bee52caa42504e4ce5406f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4045da9f4f7290b02bee52caa42504e4ce5406f7/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea265ea165cb0e6fa989a3712efd701456b265d", "url": "https://api.github.com/repos/rust-lang/rust/commits/eea265ea165cb0e6fa989a3712efd701456b265d", "html_url": "https://github.com/rust-lang/rust/commit/eea265ea165cb0e6fa989a3712efd701456b265d"}], "stats": {"total": 663, "additions": 331, "deletions": 332}, "files": [{"sha": "a0ff8cb5e4d248c627bf94cd4e03ae723b1e1167", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -17,7 +17,7 @@ use syntax::ast_util::*;\n use syntax::attr;\n use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n use syntax::codemap;\n-use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n@@ -36,7 +36,7 @@ struct TestCtxt {\n     sess: session::Session,\n     crate: @ast::crate,\n     path: ~[ast::ident],\n-    ext_cx: @ext_ctxt,\n+    ext_cx: @ExtCtxt,\n     testfns: ~[Test]\n }\n \n@@ -64,7 +64,7 @@ fn generate_test_harness(sess: session::Session,\n     let cx: @mut TestCtxt = @mut TestCtxt {\n         sess: sess,\n         crate: crate,\n-        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n         path: ~[],\n         testfns: ~[]\n     };"}, {"sha": "f18396f95be42921b7144b3f46a9d718d523da01", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -19,7 +19,7 @@ use std::semver;\n use std::term;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n-use syntax::ext::base::{mk_ctxt, ext_ctxt};\n+use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::ast::{meta_name_value, meta_list};\n use syntax::attr::{mk_attr};\n@@ -178,7 +178,7 @@ struct ListenerFn {\n struct ReadyCtx {\n     sess: session::Session,\n     crate: @ast::crate,\n-    ext_cx: @ext_ctxt,\n+    ext_cx: @ExtCtxt,\n     path: ~[ast::ident],\n     fns: ~[ListenerFn]\n }\n@@ -247,7 +247,7 @@ pub fn ready_crate(sess: session::Session,\n     let ctx = @mut ReadyCtx {\n         sess: sess,\n         crate: crate,\n-        ext_cx: mk_ctxt(sess.parse_sess, copy sess.opts.cfg),\n+        ext_cx: ExtCtxt::new(sess.parse_sess, copy sess.opts.cfg),\n         path: ~[],\n         fns: ~[]\n     };"}, {"sha": "162eced11242b4da251e2fdf2528148884ace31f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -37,7 +37,7 @@ fn next_state(s: State) -> Option<State> {\n     }\n }\n \n-pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                -> base::MacResult {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "64d2644b38310d3ddc95fda94cb8b26c3410eb3a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -15,7 +15,7 @@ use codemap::span;\n use ext::base::*;\n \n pub fn expand_auto_encode(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]\n@@ -25,7 +25,7 @@ pub fn expand_auto_encode(\n }\n \n pub fn expand_auto_decode(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @ast::meta_item,\n     in_items: ~[@ast::item]"}, {"sha": "9b71fb9647ce107374a4a1adfe2a81644020b190", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -33,7 +33,7 @@ pub struct MacroDef {\n     ext: SyntaxExtension\n }\n \n-pub type ItemDecorator = @fn(@ext_ctxt,\n+pub type ItemDecorator = @fn(@ExtCtxt,\n                              span,\n                              @ast::meta_item,\n                              ~[@ast::item])\n@@ -44,7 +44,7 @@ pub struct SyntaxExpanderTT {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTFun = @fn(@ext_ctxt,\n+pub type SyntaxExpanderTTFun = @fn(@ExtCtxt,\n                                    span,\n                                    &[ast::token_tree])\n                                 -> MacResult;\n@@ -54,7 +54,7 @@ pub struct SyntaxExpanderTTItem {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTItemFun = @fn(@ext_ctxt,\n+pub type SyntaxExpanderTTItemFun = @fn(@ExtCtxt,\n                                        span,\n                                        ast::ident,\n                                        ~[ast::token_tree])\n@@ -202,7 +202,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n // One of these is made during expansion and incrementally updated as we go;\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n-pub struct ext_ctxt {\n+pub struct ExtCtxt {\n     parse_sess: @mut parse::ParseSess,\n     cfg: ast::crate_cfg,\n     backtrace: @mut Option<@ExpnInfo>,\n@@ -216,7 +216,17 @@ pub struct ext_ctxt {\n     trace_mac: @mut bool\n }\n \n-pub impl ext_ctxt {\n+pub impl ExtCtxt {\n+    fn new(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg) -> @ExtCtxt {\n+        @ExtCtxt {\n+            parse_sess: parse_sess,\n+            cfg: cfg,\n+            backtrace: @mut None,\n+            mod_path: @mut ~[],\n+            trace_mac: @mut false\n+        }\n+    }\n+\n     fn codemap(&self) -> @CodeMap { self.parse_sess.cm }\n     fn parse_sess(&self) -> @mut parse::ParseSess { self.parse_sess }\n     fn cfg(&self) -> ast::crate_cfg { copy self.cfg }\n@@ -294,18 +304,7 @@ pub impl ext_ctxt {\n     }\n }\n \n-pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n-    -> @ext_ctxt {\n-    @ext_ctxt {\n-        parse_sess: parse_sess,\n-        cfg: cfg,\n-        backtrace: @mut None,\n-        mod_path: @mut ~[],\n-        trace_mac: @mut false\n-    }\n-}\n-\n-pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n+pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n         ast::lit_str(s) => copy *s,\n@@ -315,7 +314,7 @@ pub fn expr_to_str(cx: @ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n     }\n }\n \n-pub fn expr_to_ident(cx: @ext_ctxt,\n+pub fn expr_to_ident(cx: @ExtCtxt,\n                      expr: @ast::expr,\n                      err_msg: &str) -> ast::ident {\n     match expr.node {\n@@ -329,14 +328,14 @@ pub fn expr_to_ident(cx: @ext_ctxt,\n     }\n }\n \n-pub fn check_zero_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree],\n+pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n                       name: &str) {\n     if tts.len() != 0 {\n         cx.span_fatal(sp, fmt!(\"%s takes no arguments\", name));\n     }\n }\n \n-pub fn get_single_str_from_tts(cx: @ext_ctxt,\n+pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n                                name: &str) -> ~str {\n@@ -351,7 +350,7 @@ pub fn get_single_str_from_tts(cx: @ext_ctxt,\n     }\n }\n \n-pub fn get_exprs_from_tts(cx: @ext_ctxt, tts: &[ast::token_tree])\n+pub fn get_exprs_from_tts(cx: @ExtCtxt, tts: &[ast::token_tree])\n                        -> ~[@ast::expr] {\n     let p = parse::new_parser_from_tts(cx.parse_sess(),\n                                        cx.cfg(),"}, {"sha": "e28c04d198af3c30db0767f9ebaea2778273df48", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -12,7 +12,7 @@ use ast;\n use codemap;\n use codemap::span;\n use fold;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n \n use opt_vec::OptVec;\n@@ -22,7 +22,7 @@ pub struct Field {\n     ex: @ast::expr\n }\n \n-pub fn mk_expr(cx: @ext_ctxt,\n+pub fn mk_expr(cx: @ExtCtxt,\n                sp: codemap::span,\n                expr: ast::expr_)\n             -> @ast::expr {\n@@ -34,32 +34,32 @@ pub fn mk_expr(cx: @ext_ctxt,\n     }\n }\n \n-pub fn mk_lit(cx: @ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n+pub fn mk_lit(cx: @ExtCtxt, sp: span, lit: ast::lit_) -> @ast::expr {\n     let sp_lit = @codemap::spanned { node: lit, span: sp };\n     mk_expr(cx, sp, ast::expr_lit(sp_lit))\n }\n-pub fn mk_int(cx: @ext_ctxt, sp: span, i: int) -> @ast::expr {\n+pub fn mk_int(cx: @ExtCtxt, sp: span, i: int) -> @ast::expr {\n     let lit = ast::lit_int(i as i64, ast::ty_i);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uint(cx: @ext_ctxt, sp: span, u: uint) -> @ast::expr {\n+pub fn mk_uint(cx: @ExtCtxt, sp: span, u: uint) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_u8(cx: @ext_ctxt, sp: span, u: u8) -> @ast::expr {\n+pub fn mk_u8(cx: @ExtCtxt, sp: span, u: u8) -> @ast::expr {\n     let lit = ast::lit_uint(u as u64, ast::ty_u8);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_binary(cx: @ext_ctxt, sp: span, op: ast::binop,\n+pub fn mk_binary(cx: @ExtCtxt, sp: span, op: ast::binop,\n                  lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_binary(op, lhs, rhs))\n }\n \n-pub fn mk_deref(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_deref(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_unary(cx, sp, ast::deref, e)\n }\n-pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n+pub fn mk_unary(cx: @ExtCtxt, sp: span, op: ast::unop, e: @ast::expr)\n              -> @ast::expr {\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n@@ -91,78 +91,78 @@ pub fn mk_raw_path_global_(sp: span,\n                  rp: rp,\n                  types: types }\n }\n-pub fn mk_path_raw(cx: @ext_ctxt, sp: span, path: @ast::Path)-> @ast::expr {\n+pub fn mk_path_raw(cx: @ExtCtxt, sp: span, path: @ast::Path)-> @ast::expr {\n     mk_expr(cx, sp, ast::expr_path(path))\n }\n-pub fn mk_path(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n+pub fn mk_path(cx: @ExtCtxt, sp: span, idents: ~[ast::ident])\n             -> @ast::expr {\n     mk_path_raw(cx, sp, mk_raw_path(sp, idents))\n }\n-pub fn mk_path_global(cx: @ext_ctxt, sp: span, idents: ~[ast::ident])\n+pub fn mk_path_global(cx: @ExtCtxt, sp: span, idents: ~[ast::ident])\n                    -> @ast::expr {\n     mk_path_raw(cx, sp, mk_raw_path_global(sp, idents))\n }\n-pub fn mk_access_(cx: @ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)\n+pub fn mk_access_(cx: @ExtCtxt, sp: span, p: @ast::expr, m: ast::ident)\n                -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_field(p, m, ~[]))\n }\n-pub fn mk_access(cx: @ext_ctxt, sp: span, p: ~[ast::ident], m: ast::ident)\n+pub fn mk_access(cx: @ExtCtxt, sp: span, p: ~[ast::ident], m: ast::ident)\n               -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, p);\n     return mk_access_(cx, sp, pathexpr, m);\n }\n-pub fn mk_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_addr_of(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_imm, e));\n }\n-pub fn mk_mut_addr_of(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_mut_addr_of(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n     return mk_expr(cx, sp, ast::expr_addr_of(ast::m_mutbl, e));\n }\n-pub fn mk_method_call(cx: @ext_ctxt,\n+pub fn mk_method_call(cx: @ExtCtxt,\n                       sp: span,\n                       rcvr_expr: @ast::expr,\n                       method_ident: ast::ident,\n                       args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_method_call(rcvr_expr, method_ident, ~[], args, ast::NoSugar))\n }\n-pub fn mk_call_(cx: @ext_ctxt, sp: span, fn_expr: @ast::expr,\n+pub fn mk_call_(cx: @ExtCtxt, sp: span, fn_expr: @ast::expr,\n                 args: ~[@ast::expr]) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n-pub fn mk_call(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+pub fn mk_call(cx: @ExtCtxt, sp: span, fn_path: ~[ast::ident],\n                args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n-pub fn mk_call_global(cx: @ext_ctxt, sp: span, fn_path: ~[ast::ident],\n+pub fn mk_call_global(cx: @ExtCtxt, sp: span, fn_path: ~[ast::ident],\n                       args: ~[@ast::expr]) -> @ast::expr {\n     let pathexpr = mk_path_global(cx, sp, fn_path);\n     return mk_call_(cx, sp, pathexpr, args);\n }\n // e = expr, t = type\n-pub fn mk_base_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_base_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     let vecexpr = ast::expr_vec(exprs, ast::m_imm);\n     mk_expr(cx, sp, vecexpr)\n }\n-pub fn mk_vstore_e(cx: @ext_ctxt, sp: span, expr: @ast::expr,\n+pub fn mk_vstore_e(cx: @ExtCtxt, sp: span, expr: @ast::expr,\n                    vst: ast::expr_vstore) ->\n    @ast::expr {\n     mk_expr(cx, sp, ast::expr_vstore(expr, vst))\n }\n-pub fn mk_uniq_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_uniq_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n                   -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs), ast::expr_vstore_uniq)\n }\n-pub fn mk_slice_vec_e(cx: @ext_ctxt, sp: span, exprs: ~[@ast::expr])\n+pub fn mk_slice_vec_e(cx: @ExtCtxt, sp: span, exprs: ~[@ast::expr])\n                    -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_vec_e(cx, sp, exprs),\n                 ast::expr_vstore_slice)\n }\n-pub fn mk_base_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_base_str(cx: @ExtCtxt, sp: span, s: ~str) -> @ast::expr {\n     let lit = ast::lit_str(@s);\n     return mk_lit(cx, sp, lit);\n }\n-pub fn mk_uniq_str(cx: @ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n+pub fn mk_uniq_str(cx: @ExtCtxt, sp: span, s: ~str) -> @ast::expr {\n     mk_vstore_e(cx, sp, mk_base_str(cx, sp, s), ast::expr_vstore_uniq)\n }\n pub fn mk_field(sp: span, f: &Field) -> ast::field {\n@@ -174,7 +174,7 @@ pub fn mk_field(sp: span, f: &Field) -> ast::field {\n pub fn mk_fields(sp: span, fields: ~[Field]) -> ~[ast::field] {\n     fields.map(|f| mk_field(sp, f))\n }\n-pub fn mk_struct_e(cx: @ext_ctxt,\n+pub fn mk_struct_e(cx: @ExtCtxt,\n                    sp: span,\n                    ctor_path: ~[ast::ident],\n                    fields: ~[Field])\n@@ -184,7 +184,7 @@ pub fn mk_struct_e(cx: @ext_ctxt,\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_global_struct_e(cx: @ext_ctxt,\n+pub fn mk_global_struct_e(cx: @ExtCtxt,\n                           sp: span,\n                           ctor_path: ~[ast::ident],\n                           fields: ~[Field])\n@@ -194,7 +194,7 @@ pub fn mk_global_struct_e(cx: @ext_ctxt,\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n-pub fn mk_glob_use(cx: @ext_ctxt,\n+pub fn mk_glob_use(cx: @ExtCtxt,\n                    sp: span,\n                    vis: ast::visibility,\n                    path: ~[ast::ident]) -> @ast::view_item {\n@@ -207,7 +207,7 @@ pub fn mk_glob_use(cx: @ext_ctxt,\n                       vis: vis,\n                       span: sp }\n }\n-pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n+pub fn mk_local(cx: @ExtCtxt, sp: span, mutbl: bool,\n                 ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n     let pat = @ast::pat {\n@@ -232,7 +232,7 @@ pub fn mk_local(cx: @ext_ctxt, sp: span, mutbl: bool,\n     let decl = codemap::spanned {node: ast::decl_local(~[local]), span: sp};\n     @codemap::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n-pub fn mk_block(cx: @ext_ctxt, span: span,\n+pub fn mk_block(cx: @ExtCtxt, span: span,\n                 view_items: ~[@ast::view_item],\n                 stmts: ~[@ast::stmt],\n                 expr: Option<@ast::expr>) -> @ast::expr {\n@@ -248,7 +248,7 @@ pub fn mk_block(cx: @ext_ctxt, span: span,\n     };\n     mk_expr(cx, span, ast::expr_block(blk))\n }\n-pub fn mk_block_(cx: @ext_ctxt,\n+pub fn mk_block_(cx: @ExtCtxt,\n                  span: span,\n                  stmts: ~[@ast::stmt])\n               -> ast::blk {\n@@ -263,7 +263,7 @@ pub fn mk_block_(cx: @ext_ctxt,\n         span: span,\n     }\n }\n-pub fn mk_simple_block(cx: @ext_ctxt,\n+pub fn mk_simple_block(cx: @ExtCtxt,\n                        span: span,\n                        expr: @ast::expr)\n                     -> ast::blk {\n@@ -278,90 +278,90 @@ pub fn mk_simple_block(cx: @ext_ctxt,\n         span: span,\n     }\n }\n-pub fn mk_lambda_(cx: @ext_ctxt,\n+pub fn mk_lambda_(cx: @ExtCtxt,\n                  span: span,\n                  fn_decl: ast::fn_decl,\n                  blk: ast::blk)\n               -> @ast::expr {\n     mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n }\n-pub fn mk_lambda(cx: @ext_ctxt,\n+pub fn mk_lambda(cx: @ExtCtxt,\n                  span: span,\n                  fn_decl: ast::fn_decl,\n                  expr: @ast::expr)\n               -> @ast::expr {\n     let blk = mk_simple_block(cx, span, expr);\n     mk_lambda_(cx, span, fn_decl, blk)\n }\n-pub fn mk_lambda_stmts(cx: @ext_ctxt,\n+pub fn mk_lambda_stmts(cx: @ExtCtxt,\n                        span: span,\n                        fn_decl: ast::fn_decl,\n                        stmts: ~[@ast::stmt])\n                     -> @ast::expr {\n     let blk = mk_block(cx, span, ~[], stmts, None);\n     mk_lambda(cx, span, fn_decl, blk)\n }\n-pub fn mk_lambda_no_args(cx: @ext_ctxt,\n+pub fn mk_lambda_no_args(cx: @ExtCtxt,\n                          span: span,\n                          expr: @ast::expr)\n                       -> @ast::expr {\n     let fn_decl = mk_fn_decl(~[], mk_ty_infer(cx, span));\n     mk_lambda(cx, span, fn_decl, expr)\n }\n-pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_copy(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n-pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n+pub fn mk_managed(cx: @ExtCtxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n-pub fn mk_pat(cx: @ext_ctxt, span: span, pat: ast::pat_) -> @ast::pat {\n+pub fn mk_pat(cx: @ExtCtxt, span: span, pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n-pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n+pub fn mk_pat_wild(cx: @ExtCtxt, span: span) -> @ast::pat {\n     mk_pat(cx, span, ast::pat_wild)\n }\n-pub fn mk_pat_lit(cx: @ext_ctxt,\n+pub fn mk_pat_lit(cx: @ExtCtxt,\n                   span: span,\n                   expr: @ast::expr) -> @ast::pat {\n     mk_pat(cx, span, ast::pat_lit(expr))\n }\n-pub fn mk_pat_ident(cx: @ext_ctxt,\n+pub fn mk_pat_ident(cx: @ExtCtxt,\n                     span: span,\n                     ident: ast::ident) -> @ast::pat {\n     mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n }\n \n-pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n+pub fn mk_pat_ident_with_binding_mode(cx: @ExtCtxt,\n                                       span: span,\n                                       ident: ast::ident,\n                                       bm: ast::binding_mode) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);\n     let pat = ast::pat_ident(bm, path, None);\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_pat_enum(cx: @ext_ctxt,\n+pub fn mk_pat_enum(cx: @ExtCtxt,\n                    span: span,\n                    path: @ast::Path,\n                    subpats: ~[@ast::pat])\n                 -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(subpats));\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_pat_struct(cx: @ext_ctxt,\n+pub fn mk_pat_struct(cx: @ExtCtxt,\n                      span: span,\n                      path: @ast::Path,\n                      field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n     let pat = ast::pat_struct(path, field_pats, false);\n     mk_pat(cx, span, pat)\n }\n-pub fn mk_bool(cx: @ext_ctxt, span: span, value: bool) -> @ast::expr {\n+pub fn mk_bool(cx: @ExtCtxt, span: span, value: bool) -> @ast::expr {\n     let lit_expr = ast::expr_lit(@codemap::spanned {\n         node: ast::lit_bool(value),\n         span: span });\n     build::mk_expr(cx, span, lit_expr)\n }\n-pub fn mk_stmt(cx: @ext_ctxt, span: span, expr: @ast::expr) -> @ast::stmt {\n+pub fn mk_stmt(cx: @ExtCtxt, span: span, expr: @ast::expr) -> @ast::stmt {\n     let stmt_ = ast::stmt_semi(expr, cx.next_id());\n     @codemap::spanned { node: stmt_, span: span }\n }\n@@ -373,7 +373,7 @@ pub fn mk_ty_mt(ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n     }\n }\n \n-pub fn mk_ty(cx: @ext_ctxt,\n+pub fn mk_ty(cx: @ExtCtxt,\n              span: span,\n              ty: ast::ty_) -> @ast::Ty {\n     @ast::Ty {\n@@ -383,31 +383,31 @@ pub fn mk_ty(cx: @ext_ctxt,\n     }\n }\n \n-pub fn mk_ty_path(cx: @ext_ctxt,\n+pub fn mk_ty_path(cx: @ExtCtxt,\n                   span: span,\n                   idents: ~[ ast::ident ])\n                -> @ast::Ty {\n     let ty = build::mk_raw_path(span, idents);\n     mk_ty_path_path(cx, span, ty)\n }\n \n-pub fn mk_ty_path_global(cx: @ext_ctxt,\n+pub fn mk_ty_path_global(cx: @ExtCtxt,\n                          span: span,\n                          idents: ~[ ast::ident ])\n                       -> @ast::Ty {\n     let ty = build::mk_raw_path_global(span, idents);\n     mk_ty_path_path(cx, span, ty)\n }\n \n-pub fn mk_ty_path_path(cx: @ext_ctxt,\n+pub fn mk_ty_path_path(cx: @ExtCtxt,\n                        span: span,\n                        path: @ast::Path)\n                       -> @ast::Ty {\n     let ty = ast::ty_path(path, cx.next_id());\n     mk_ty(cx, span, ty)\n }\n \n-pub fn mk_ty_rptr(cx: @ext_ctxt,\n+pub fn mk_ty_rptr(cx: @ExtCtxt,\n                   span: span,\n                   ty: @ast::Ty,\n                   lifetime: Option<@ast::Lifetime>,\n@@ -416,39 +416,39 @@ pub fn mk_ty_rptr(cx: @ext_ctxt,\n     mk_ty(cx, span,\n           ast::ty_rptr(lifetime, mk_ty_mt(ty, mutbl)))\n }\n-pub fn mk_ty_uniq(cx: @ext_ctxt, span: span, ty: @ast::Ty) -> @ast::Ty {\n+pub fn mk_ty_uniq(cx: @ExtCtxt, span: span, ty: @ast::Ty) -> @ast::Ty {\n     mk_ty(cx, span, ast::ty_uniq(mk_ty_mt(ty, ast::m_imm)))\n }\n-pub fn mk_ty_box(cx: @ext_ctxt, span: span,\n+pub fn mk_ty_box(cx: @ExtCtxt, span: span,\n                  ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n     mk_ty(cx, span, ast::ty_box(mk_ty_mt(ty, mutbl)))\n }\n \n \n \n-pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n+pub fn mk_ty_infer(cx: @ExtCtxt, span: span) -> @ast::Ty {\n     mk_ty(cx, span, ast::ty_infer)\n }\n-pub fn mk_trait_ref_global(cx: @ext_ctxt,\n+pub fn mk_trait_ref_global(cx: @ExtCtxt,\n                            span: span,\n                            idents: ~[ ast::ident ])\n     -> @ast::trait_ref\n {\n     mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n }\n-pub fn mk_trait_ref_(cx: @ext_ctxt, path: @ast::Path) -> @ast::trait_ref {\n+pub fn mk_trait_ref_(cx: @ExtCtxt, path: @ast::Path) -> @ast::trait_ref {\n     @ast::trait_ref {\n         path: path,\n         ref_id: cx.next_id()\n     }\n }\n-pub fn mk_simple_ty_path(cx: @ext_ctxt,\n+pub fn mk_simple_ty_path(cx: @ExtCtxt,\n                          span: span,\n                          ident: ast::ident)\n                       -> @ast::Ty {\n     mk_ty_path(cx, span, ~[ ident ])\n }\n-pub fn mk_arg(cx: @ext_ctxt,\n+pub fn mk_arg(cx: @ExtCtxt,\n               span: span,\n               ident: ast::ident,\n               ty: @ast::Ty)\n@@ -464,29 +464,29 @@ pub fn mk_arg(cx: @ext_ctxt,\n pub fn mk_fn_decl(inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n-pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n+pub fn mk_trait_ty_param_bound_global(cx: @ExtCtxt,\n                                       span: span,\n                                       idents: ~[ast::ident])\n                                    -> ast::TyParamBound {\n     ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n }\n-pub fn mk_trait_ty_param_bound_(cx: @ext_ctxt,\n+pub fn mk_trait_ty_param_bound_(cx: @ExtCtxt,\n                                 path: @ast::Path) -> ast::TyParamBound {\n     ast::TraitTyParamBound(mk_trait_ref_(cx, path))\n }\n-pub fn mk_ty_param(cx: @ext_ctxt,\n+pub fn mk_ty_param(cx: @ExtCtxt,\n                    ident: ast::ident,\n                    bounds: @OptVec<ast::TyParamBound>)\n                 -> ast::TyParam {\n     ast::TyParam { ident: ident, id: cx.next_id(), bounds: bounds }\n }\n-pub fn mk_lifetime(cx: @ext_ctxt,\n+pub fn mk_lifetime(cx: @ExtCtxt,\n                    span: span,\n                    ident: ast::ident)\n                 -> ast::Lifetime {\n     ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n }\n-pub fn mk_arm(cx: @ext_ctxt,\n+pub fn mk_arm(cx: @ExtCtxt,\n               span: span,\n               pats: ~[@ast::pat],\n               expr: @ast::expr)\n@@ -497,7 +497,7 @@ pub fn mk_arm(cx: @ext_ctxt,\n         body: mk_simple_block(cx, span, expr)\n     }\n }\n-pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n+pub fn mk_unreachable(cx: @ExtCtxt, span: span) -> @ast::expr {\n     let loc = cx.codemap().lookup_char_pos(span.lo);\n     mk_call_global(\n         cx,\n@@ -515,11 +515,11 @@ pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n         ]\n     )\n }\n-pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n+pub fn mk_unreachable_arm(cx: @ExtCtxt, span: span) -> ast::arm {\n     mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n }\n \n-pub fn make_self(cx: @ext_ctxt, span: span) -> @ast::expr {\n+pub fn make_self(cx: @ExtCtxt, span: span) -> @ast::expr {\n     build::mk_expr(cx, span, ast::expr_self)\n }\n \n@@ -529,7 +529,7 @@ pub fn make_self(cx: @ext_ctxt, span: span) -> @ast::expr {\n // These functions just duplicate AST nodes.\n //\n \n-pub fn duplicate_expr(cx: @ext_ctxt, expr: @ast::expr) -> @ast::expr {\n+pub fn duplicate_expr(cx: @ExtCtxt, expr: @ast::expr) -> @ast::expr {\n     let folder = fold::default_ast_fold();\n     let folder = @fold::AstFoldFns {\n         new_id: |_| cx.next_id(),\n@@ -599,7 +599,7 @@ trait ExtCtxtMethods {\n                       -> @ast::expr;\n }\n \n-impl ExtCtxtMethods for @ext_ctxt {\n+impl ExtCtxtMethods for @ExtCtxt {\n     fn bind_path(\n         &self,\n         _span: span,"}, {"sha": "da13c9bfa28e18d5ad0fcbccbf1ef6dce904cc11", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -16,7 +16,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::{mk_u8, mk_slice_vec_e};\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacResult {\n     // Gather all argument expressions\n     let exprs = get_exprs_from_tts(cx, tts);\n     let mut bytes = ~[];"}, {"sha": "e6600e198fa6d6ce8fb84c61088375a004e2155b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -14,7 +14,7 @@ use ext::base::*;\n use ext::base;\n use parse::token;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n     for tts.eachi |i, e| {"}, {"sha": "c08b478e8ed6f8118d5b00171828faf914979dc0", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,12 +10,12 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n \n-pub fn expand_deriving_clone(cx: @ext_ctxt,\n+pub fn expand_deriving_clone(cx: @ExtCtxt,\n                              span: span,\n                              mitem: @meta_item,\n                              in_items: ~[@item])\n@@ -42,7 +42,7 @@ pub fn expand_deriving_clone(cx: @ext_ctxt,\n                             &trait_def)\n }\n \n-pub fn expand_deriving_deep_clone(cx: @ext_ctxt,\n+pub fn expand_deriving_deep_clone(cx: @ExtCtxt,\n                                  span: span,\n                                  mitem: @meta_item,\n                                  in_items: ~[@item])\n@@ -73,7 +73,7 @@ pub fn expand_deriving_deep_clone(cx: @ext_ctxt,\n \n fn cs_clone(\n     name: &str,\n-    cx: @ext_ctxt, span: span,\n+    cx: @ExtCtxt, span: span,\n     substr: &Substructure) -> @expr {\n     let clone_ident = substr.method_ident;\n     let ctor_ident;"}, {"sha": "197366b09ae3c03695a94feb223d6f7f0364a345", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,21 +10,21 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_eq(cx: @ext_ctxt,\n+pub fn expand_deriving_eq(cx: @ExtCtxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_eq(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n                                  cx, span, substr)\n     }\n-    fn cs_ne(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_ne(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cs_or(|cx, span, _, _| build::mk_bool(cx, span, true),\n               cx, span, substr)\n     }"}, {"sha": "29fc2c7271c0b03e60c59fe25ac6d655b2ddddbe", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -11,11 +11,11 @@\n \n use ast::{meta_item, item, expr_if, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_ord(cx: @ext_ctxt,\n+pub fn expand_deriving_ord(cx: @ExtCtxt,\n                            span: span,\n                            mitem: @meta_item,\n                            in_items: ~[@item]) -> ~[@item] {\n@@ -55,7 +55,7 @@ pub fn expand_deriving_ord(cx: @ext_ctxt,\n \n /// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n fn cs_ord(less: bool, equal: bool,\n-          cx: @ext_ctxt, span: span,\n+          cx: @ExtCtxt, span: span,\n           substr: &Substructure) -> @expr {\n     let binop = if less {\n         cx.ident_of(\"lt\")"}, {"sha": "0ab99430d10780c06ec52a1545e72d3fd6e050dc", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -11,16 +11,16 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_totaleq(cx: @ext_ctxt,\n+pub fn expand_deriving_totaleq(cx: @ExtCtxt,\n                           span: span,\n                           mitem: @meta_item,\n                           in_items: ~[@item]) -> ~[@item] {\n \n-    fn cs_equals(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+    fn cs_equals(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n         cs_and(|cx, span, _, _| build::mk_bool(cx, span, false),\n                cx, span, substr)\n     }"}, {"sha": "2b4d8a28fbd93b155e5ab884e05d34f6348b9bfc", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,12 +10,12 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n use core::cmp::{Ordering, Equal, Less, Greater};\n \n-pub fn expand_deriving_totalord(cx: @ext_ctxt,\n+pub fn expand_deriving_totalord(cx: @ExtCtxt,\n                                 span: span,\n                                 mitem: @meta_item,\n                                 in_items: ~[@item]) -> ~[@item] {\n@@ -41,7 +41,7 @@ pub fn expand_deriving_totalord(cx: @ext_ctxt,\n }\n \n \n-pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n+pub fn ordering_const(cx: @ExtCtxt, span: span, cnst: Ordering) -> @expr {\n     let cnst = match cnst {\n         Less => \"Less\",\n         Equal => \"Equal\",\n@@ -53,7 +53,7 @@ pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n                             cx.ident_of(cnst)])\n }\n \n-pub fn cs_cmp(cx: @ext_ctxt, span: span,\n+pub fn cs_cmp(cx: @ExtCtxt, span: span,\n               substr: &Substructure) -> @expr {\n \n     cs_same_method_fold("}, {"sha": "24f9b6acf85342ed61ab5dee3f9e103baae66e22", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -15,15 +15,15 @@ encodable.rs for more.\n \n use ast;\n use ast::*;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n use opt_vec;\n \n pub fn expand_deriving_decodable(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @meta_item,\n     in_items: ~[@item]\n@@ -38,7 +38,7 @@ pub fn expand_deriving_decodable(\n }\n \n fn create_derived_decodable_impl(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     generics: &Generics,\n@@ -91,7 +91,7 @@ fn create_derived_decodable_impl(\n // Creates a method from the given set of statements conforming to the\n // signature of the `decodable` method.\n fn create_decode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ast::ident,\n     generics: &Generics,\n@@ -142,7 +142,7 @@ fn create_decode_method(\n }\n \n fn call_substructure_decode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span\n ) -> @ast::expr {\n     // Call the substructure method.\n@@ -166,7 +166,7 @@ fn call_substructure_decode_method(\n }\n \n fn expand_deriving_decodable_struct_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -192,7 +192,7 @@ fn expand_deriving_decodable_struct_def(\n }\n \n fn expand_deriving_decodable_enum_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ident,\n@@ -218,7 +218,7 @@ fn expand_deriving_decodable_enum_def(\n }\n \n fn create_read_struct_field(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n@@ -251,7 +251,7 @@ fn create_read_struct_field(\n }\n \n fn create_read_struct_arg(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     ident: ident\n@@ -274,7 +274,7 @@ fn create_read_struct_arg(\n }\n \n fn expand_deriving_decodable_struct_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -334,7 +334,7 @@ fn expand_deriving_decodable_struct_method(\n }\n \n fn create_read_variant_arg(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     idx: uint,\n     variant: &ast::variant\n@@ -392,7 +392,7 @@ fn create_read_variant_arg(\n }\n \n fn create_read_enum_variant(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def\n ) -> @expr {\n@@ -459,7 +459,7 @@ fn create_read_enum_variant(\n }\n \n fn expand_deriving_decodable_enum_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ast::ident,"}, {"sha": "128bbf39b16c6afbdceee401d38cfff3a220223b", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -78,15 +78,15 @@ would yield functions like:\n \n use ast;\n use ast::*;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n use opt_vec;\n \n pub fn expand_deriving_encodable(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     _mitem: @meta_item,\n     in_items: ~[@item]\n@@ -101,7 +101,7 @@ pub fn expand_deriving_encodable(\n }\n \n fn create_derived_encodable_impl(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     generics: &Generics,\n@@ -154,7 +154,7 @@ fn create_derived_encodable_impl(\n // Creates a method from the given set of statements conforming to the\n // signature of the `encodable` method.\n fn create_encode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     statements: ~[@stmt]\n ) -> @method {\n@@ -197,7 +197,7 @@ fn create_encode_method(\n }\n \n fn call_substructure_encode_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     self_field: @expr\n ) -> @ast::expr {\n@@ -217,7 +217,7 @@ fn call_substructure_encode_method(\n }\n \n fn expand_deriving_encodable_struct_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     struct_def: &struct_def,\n     type_ident: ident,\n@@ -242,7 +242,7 @@ fn expand_deriving_encodable_struct_def(\n }\n \n fn expand_deriving_encodable_enum_def(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     enum_definition: &enum_def,\n     type_ident: ident,\n@@ -267,7 +267,7 @@ fn expand_deriving_encodable_enum_def(\n }\n \n fn expand_deriving_encodable_struct_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ident,\n     struct_def: &struct_def\n@@ -361,7 +361,7 @@ fn expand_deriving_encodable_struct_method(\n }\n \n fn expand_deriving_encodable_enum_method(\n-    cx: @ext_ctxt,\n+    cx: @ExtCtxt,\n     span: span,\n     type_ident: ast::ident,\n     enum_definition: &enum_def"}, {"sha": "0bb97ec31224c18ac343c9e46bbf7ff689826a80", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -165,7 +165,7 @@ StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n use ast;\n use ast::{enum_def, expr, ident, Generics, struct_def};\n \n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::*;\n use codemap::{span,respan};\n@@ -174,7 +174,7 @@ use opt_vec;\n pub use self::ty::*;\n mod ty;\n \n-pub fn expand_deriving_generic(cx: @ext_ctxt,\n+pub fn expand_deriving_generic(cx: @ExtCtxt,\n                                span: span,\n                                _mitem: @ast::meta_item,\n                                in_items: ~[@ast::item],\n@@ -281,22 +281,22 @@ Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n pub type CombineSubstructureFunc<'self> =\n-    &'self fn(@ext_ctxt, span, &Substructure) -> @expr;\n+    &'self fn(@ExtCtxt, span, &Substructure) -> @expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n pub type EnumNonMatchFunc<'self> =\n-    &'self fn(@ext_ctxt, span,\n+    &'self fn(@ExtCtxt, span,\n               &[(uint, ast::variant,\n                  ~[(Option<ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n \n impl<'self> TraitDef<'self> {\n-    fn create_derived_impl(&self, cx: @ext_ctxt, span: span,\n+    fn create_derived_impl(&self, cx: @ExtCtxt, span: span,\n                            type_ident: ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n@@ -315,7 +315,7 @@ impl<'self> TraitDef<'self> {\n                             additional_bounds)\n     }\n \n-    fn expand_struct_def(&self, cx: @ext_ctxt,\n+    fn expand_struct_def(&self, cx: @ExtCtxt,\n                          span: span,\n                          struct_def: &struct_def,\n                          type_ident: ident,\n@@ -347,7 +347,7 @@ impl<'self> TraitDef<'self> {\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: @ext_ctxt, span: span,\n+                       cx: @ExtCtxt, span: span,\n                        enum_def: &enum_def,\n                        type_ident: ident,\n                        generics: &Generics) -> @ast::item {\n@@ -380,7 +380,7 @@ impl<'self> TraitDef<'self> {\n \n impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n-                                cx: @ext_ctxt,\n+                                cx: @ExtCtxt,\n                                 span: span,\n                                 type_ident: ident,\n                                 self_args: &[@expr],\n@@ -398,7 +398,7 @@ impl<'self> MethodDef<'self> {\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, cx: @ext_ctxt, span: span,\n+    fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n                      generics: &Generics, type_ident: ident) -> @ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n@@ -407,7 +407,7 @@ impl<'self> MethodDef<'self> {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, cx: @ext_ctxt, span: span,\n+    fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n                              type_ident: ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n \n@@ -451,7 +451,7 @@ impl<'self> MethodDef<'self> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, cx: @ext_ctxt, span: span,\n+    fn create_method(&self, cx: @ExtCtxt, span: span,\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n@@ -509,7 +509,7 @@ impl<'self> MethodDef<'self> {\n     ~~~\n     */\n     fn expand_struct_method_body(&self,\n-                                 cx: @ext_ctxt,\n+                                 cx: @ExtCtxt,\n                                  span: span,\n                                  struct_def: &struct_def,\n                                  type_ident: ident,\n@@ -567,7 +567,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn expand_static_struct_method_body(&self,\n-                                        cx: @ext_ctxt,\n+                                        cx: @ExtCtxt,\n                                         span: span,\n                                         struct_def: &struct_def,\n                                         type_ident: ident,\n@@ -609,7 +609,7 @@ impl<'self> MethodDef<'self> {\n     ~~~\n     */\n     fn expand_enum_method_body(&self,\n-                               cx: @ext_ctxt,\n+                               cx: @ExtCtxt,\n                                span: span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n@@ -645,7 +645,7 @@ impl<'self> MethodDef<'self> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n-                        cx: @ext_ctxt, span: span,\n+                        cx: @ExtCtxt, span: span,\n                         enum_def: &enum_def,\n                         type_ident: ident,\n                         self_args: &[@expr],\n@@ -786,7 +786,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn expand_static_enum_method_body(&self,\n-                               cx: @ext_ctxt,\n+                               cx: @ExtCtxt,\n                                span: span,\n                                enum_def: &enum_def,\n                                type_ident: ident,\n@@ -810,7 +810,7 @@ impl<'self> MethodDef<'self> {\n     }\n }\n \n-fn summarise_struct(cx: @ext_ctxt, span: span,\n+fn summarise_struct(cx: @ExtCtxt, span: span,\n                     struct_def: &struct_def) -> Either<uint, ~[ident]> {\n     let mut named_idents = ~[];\n     let mut unnamed_count = 0;\n@@ -840,12 +840,12 @@ Fold the fields. `use_foldl` controls whether this is done\n left-to-right (`true`) or right-to-left (`false`).\n */\n pub fn cs_fold(use_foldl: bool,\n-               f: &fn(@ext_ctxt, span,\n+               f: &fn(@ExtCtxt, span,\n                       old: @expr,\n                       self_f: @expr, other_fs: &[@expr]) -> @expr,\n                base: @expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ext_ctxt, span: span,\n+               cx: @ExtCtxt, span: span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n@@ -879,9 +879,9 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n ~~~\n */\n #[inline(always)]\n-pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n+pub fn cs_same_method(f: &fn(@ExtCtxt, span, ~[@expr]) -> @expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ext_ctxt, span: span,\n+                      cx: @ExtCtxt, span: span,\n                       substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n@@ -911,10 +911,10 @@ fields. `use_foldl` controls whether this is done left-to-right\n */\n #[inline(always)]\n pub fn cs_same_method_fold(use_foldl: bool,\n-                           f: &fn(@ext_ctxt, span, @expr, @expr) -> @expr,\n+                           f: &fn(@ExtCtxt, span, @expr, @expr) -> @expr,\n                            base: @expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ext_ctxt, span: span,\n+                           cx: @ExtCtxt, span: span,\n                            substructure: &Substructure) -> @expr {\n     cs_same_method(\n         |cx, span, vals| {\n@@ -940,7 +940,7 @@ on all the fields.\n #[inline(always)]\n pub fn cs_binop(binop: ast::binop, base: @expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: @ext_ctxt, span: span,\n+                cx: @ExtCtxt, span: span,\n                 substructure: &Substructure) -> @expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n@@ -958,7 +958,7 @@ pub fn cs_binop(binop: ast::binop, base: @expr,\n /// cs_binop with binop == or\n #[inline(always)]\n pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n-             cx: @ext_ctxt, span: span,\n+             cx: @ExtCtxt, span: span,\n              substructure: &Substructure) -> @expr {\n     cs_binop(ast::or, build::mk_bool(cx, span, false),\n              enum_nonmatch_f,\n@@ -967,7 +967,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n /// cs_binop with binop == and\n #[inline(always)]\n pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n-              cx: @ext_ctxt, span: span,\n+              cx: @ExtCtxt, span: span,\n               substructure: &Substructure) -> @expr {\n     cs_binop(ast::and, build::mk_bool(cx, span, true),\n              enum_nonmatch_f,"}, {"sha": "c655eef34d1eb44252b8199f1ca33b6d394f9f0d", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,11 +10,11 @@\n \n use ast::{meta_item, item, expr, and};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n+pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   span: span,\n                                   mitem: @meta_item,\n                                   in_items: ~[@item]) -> ~[@item] {\n@@ -41,7 +41,7 @@ pub fn expand_deriving_iter_bytes(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn iter_bytes_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     let lsb0_f = match substr.nonself_args {\n         [l, f] => ~[l, f],\n         _ => cx.span_bug(span, \"Incorrect number of arguments in `deriving(IterBytes)`\")"}, {"sha": "4a6c78038389e773a8a556137eaabc2259d108a9", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -20,7 +20,7 @@ library.\n \n use ast;\n use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use codemap::{span, respan};\n use parse::token::special_idents::clownshoes_extensions;\n@@ -45,20 +45,20 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n+pub type ExpandDerivingStructDefFn<'self> = &'self fn(@ExtCtxt,\n                                                        span,\n                                                        x: &struct_def,\n                                                        ident,\n                                                        y: &Generics)\n                                                  -> @item;\n-pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ext_ctxt,\n+pub type ExpandDerivingEnumDefFn<'self> = &'self fn(@ExtCtxt,\n                                                     span,\n                                                     x: &enum_def,\n                                                     ident,\n                                                     y: &Generics)\n                                                  -> @item;\n \n-pub fn expand_meta_deriving(cx: @ext_ctxt,\n+pub fn expand_meta_deriving(cx: @ExtCtxt,\n                             _span: span,\n                             mitem: @meta_item,\n                             in_items: ~[@item])\n@@ -113,7 +113,7 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n     }\n }\n \n-pub fn expand_deriving(cx: @ext_ctxt,\n+pub fn expand_deriving(cx: @ExtCtxt,\n                    span: span,\n                    in_items: ~[@item],\n                    expand_deriving_struct_def: ExpandDerivingStructDefFn,\n@@ -143,7 +143,7 @@ pub fn expand_deriving(cx: @ext_ctxt,\n     result\n }\n \n-fn create_impl_item(cx: @ext_ctxt, span: span, item: ast::item_) -> @item {\n+fn create_impl_item(cx: @ExtCtxt, span: span, item: ast::item_) -> @item {\n     let doc_attr = respan(span,\n                           ast::lit_str(@~\"Automatically derived.\"));\n     let doc_attr = respan(span, ast::meta_name_value(@~\"doc\", doc_attr));\n@@ -164,7 +164,7 @@ fn create_impl_item(cx: @ext_ctxt, span: span, item: ast::item_) -> @item {\n     }\n }\n \n-pub fn create_self_type_with_params(cx: @ext_ctxt,\n+pub fn create_self_type_with_params(cx: @ExtCtxt,\n                                 span: span,\n                                 type_ident: ident,\n                                 generics: &Generics)\n@@ -193,7 +193,7 @@ pub fn create_self_type_with_params(cx: @ext_ctxt,\n     build::mk_ty_path_path(cx, span, self_type)\n }\n \n-pub fn create_derived_impl(cx: @ext_ctxt,\n+pub fn create_derived_impl(cx: @ExtCtxt,\n                            span: span,\n                            type_ident: ident,\n                            generics: &Generics,\n@@ -249,7 +249,7 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n     return create_impl_item(cx, span, impl_item);\n }\n \n-pub fn create_subpatterns(cx: @ext_ctxt,\n+pub fn create_subpatterns(cx: @ExtCtxt,\n                           span: span,\n                           field_paths: ~[@ast::Path],\n                           mutbl: ast::mutability)\n@@ -265,7 +265,7 @@ enum StructType {\n     Unknown, Record, Tuple\n }\n \n-pub fn create_struct_pattern(cx: @ext_ctxt,\n+pub fn create_struct_pattern(cx: @ExtCtxt,\n                              span: span,\n                              struct_ident: ident,\n                              struct_def: &struct_def,\n@@ -326,7 +326,7 @@ pub fn create_struct_pattern(cx: @ext_ctxt,\n     (pattern, ident_expr)\n }\n \n-pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n+pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n                                    span: span,\n                                    variant: &ast::variant,\n                                    prefix: &str,\n@@ -366,14 +366,14 @@ pub fn create_enum_variant_pattern(cx: @ext_ctxt,\n     }\n }\n \n-pub fn variant_arg_count(_cx: @ext_ctxt, _span: span, variant: &ast::variant) -> uint {\n+pub fn variant_arg_count(_cx: @ExtCtxt, _span: span, variant: &ast::variant) -> uint {\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref args) => args.len(),\n         ast::struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n     }\n }\n \n-pub fn expand_enum_or_struct_match(cx: @ext_ctxt,\n+pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n                                span: span,\n                                arms: ~[ ast::arm ])\n                             -> @expr {"}, {"sha": "64cf7e93b92e8334e3f13441771c5e4fb41389df", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -11,11 +11,11 @@\n use ast;\n use ast::{meta_item, item, expr, ident};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_rand(cx: @ext_ctxt,\n+pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: span,\n                             mitem: @meta_item,\n                             in_items: ~[@item])\n@@ -47,7 +47,7 @@ pub fn expand_deriving_rand(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     let rng = match substr.nonself_args {\n         [rng] => ~[ rng ],\n         _ => cx.bug(\"Incorrect number of arguments to `rand` in `deriving(Rand)`\")\n@@ -113,7 +113,7 @@ fn rand_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr\n         _ => cx.bug(\"Non-static method in `deriving(Rand)`\")\n     };\n \n-    fn rand_thing(cx: @ext_ctxt, span: span,\n+    fn rand_thing(cx: @ExtCtxt, span: span,\n                   ctor_ident: ident,\n                   summary: &Either<uint, ~[ident]>,\n                   rand_call: &fn() -> @expr) -> @expr {"}, {"sha": "19fd601186b1e76150f5f4556fa1d332cc0dd82a", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,11 +10,11 @@\n \n use ast::{meta_item, item, expr};\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use ext::deriving::generic::*;\n \n-pub fn expand_deriving_to_str(cx: @ext_ctxt,\n+pub fn expand_deriving_to_str(cx: @ExtCtxt,\n                               span: span,\n                               mitem: @meta_item,\n                               in_items: ~[@item])\n@@ -39,7 +39,7 @@ pub fn expand_deriving_to_str(cx: @ext_ctxt,\n     expand_deriving_generic(cx, span, mitem, in_items, &trait_def)\n }\n \n-fn to_str_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @expr {\n+fn to_str_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n     match substr.self_args {\n         [self_obj] => {\n             let self_addr = build::mk_addr_of(cx, span, self_obj);"}, {"sha": "154e7647bb560c16e127c834141a035e24550225", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -15,7 +15,7 @@ explicit `Self` type to use when specifying impls to be derived.\n \n use ast;\n use ast::{expr,Generics,ident};\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::build;\n use codemap::{span,respan};\n use opt_vec;\n@@ -53,13 +53,13 @@ pub impl<'self> Path<'self> {\n         }\n     }\n \n-    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+    fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n         build::mk_ty_path_path(cx, span,\n                                self.to_path(cx, span,\n                                             self_ty, self_generics))\n     }\n-    fn to_path(&self, cx: @ext_ctxt, span: span,\n+    fn to_path(&self, cx: @ExtCtxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n         let lt = mk_lifetime(cx, span, &self.lifetime);\n@@ -104,15 +104,15 @@ pub fn nil_ty() -> Ty<'static> {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ext_ctxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n+fn mk_lifetime(cx: @ExtCtxt, span: span, lt: &Option<&str>) -> Option<@ast::Lifetime> {\n     match *lt {\n         Some(ref s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(*s))),\n         None => None\n     }\n }\n \n pub impl<'self> Ty<'self> {\n-    fn to_ty(&self, cx: @ext_ctxt, span: span,\n+    fn to_ty(&self, cx: @ExtCtxt, span: span,\n              self_ty: ident, self_generics: &Generics) -> @ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n@@ -146,7 +146,7 @@ pub impl<'self> Ty<'self> {\n         }\n     }\n \n-    fn to_path(&self, cx: @ext_ctxt, span: span,\n+    fn to_path(&self, cx: @ExtCtxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         match *self {\n             Self => {\n@@ -172,7 +172,7 @@ pub impl<'self> Ty<'self> {\n }\n \n \n-fn mk_ty_param(cx: @ext_ctxt, span: span, name: &str, bounds: &[Path],\n+fn mk_ty_param(cx: @ExtCtxt, span: span, name: &str, bounds: &[Path],\n                self_ident: ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds = opt_vec::from(\n         do bounds.map |b| {\n@@ -201,7 +201,7 @@ pub impl<'self> LifetimeBounds<'self> {\n             lifetimes: ~[], bounds: ~[]\n         }\n     }\n-    fn to_generics(&self, cx: @ext_ctxt, span: span,\n+    fn to_generics(&self, cx: @ExtCtxt, span: span,\n                    self_ty: ident, self_generics: &Generics) -> Generics {\n         let lifetimes = do self.lifetimes.map |lt| {\n             build::mk_lifetime(cx, span, cx.ident_of(*lt))\n@@ -218,7 +218,7 @@ pub impl<'self> LifetimeBounds<'self> {\n }\n \n \n-pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n+pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::explicit_self) {\n     let self_path = build::make_self(cx, span);\n     match *self_ptr {"}, {"sha": "3d74595e645ae21b7f3a6881353bad9e8d680585", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -20,7 +20,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::mk_base_str;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n \n     let var = get_single_str_from_tts(cx, sp, tts, \"env!\");"}, {"sha": "b993162cfa3dd3ca05e0ca69de9f52804ccffd68", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -23,7 +23,7 @@ use parse;\n use parse::{parse_item_from_source_str};\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    e: &expr_,\n                    s: span,\n                    fld: @ast_fold,\n@@ -109,7 +109,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n // NB: there is some redundancy between this and expand_item, below, and\n // they might benefit from some amount of semantic and language-UI merger.\n pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n-                        cx: @ext_ctxt,\n+                        cx: @ExtCtxt,\n                         module_: &ast::_mod,\n                         fld: @ast_fold,\n                         orig: @fn(&ast::_mod, @ast_fold) -> ast::_mod)\n@@ -161,7 +161,7 @@ macro_rules! with_exts_frame (\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    it: @ast::item,\n                    fld: @ast_fold,\n                    orig: @fn(@ast::item, @ast_fold) -> Option<@ast::item>)\n@@ -227,7 +227,7 @@ macro_rules! without_macro_scoping(\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n-                       cx: @ext_ctxt, it: @ast::item,\n+                       cx: @ExtCtxt, it: @ast::item,\n                        fld: @ast_fold)\n                     -> Option<@ast::item> {\n     let (pth, tts) = match it.node {\n@@ -294,7 +294,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n \n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n-                   cx: @ext_ctxt,\n+                   cx: @ExtCtxt,\n                    s: &stmt_,\n                    sp: span,\n                    fld: @ast_fold,\n@@ -360,7 +360,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n \n pub fn expand_block(extsbox: @mut SyntaxEnv,\n-                    cx: @ext_ctxt,\n+                    cx: @ExtCtxt,\n                     blk: &blk_,\n                     sp: span,\n                     fld: @ast_fold,\n@@ -381,7 +381,7 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n     }\n }\n \n-pub fn new_span(cx: @ext_ctxt, sp: span) -> span {\n+pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n }\n@@ -590,7 +590,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n     // every method/element of AstFoldFns in fold.rs.\n     let extsbox = @mut syntax_expander_table();\n     let afp = default_ast_fold();\n-    let cx: @ext_ctxt = mk_ctxt(parse_sess, copy cfg);\n+    let cx = ExtCtxt::new(parse_sess, copy cfg);\n     let f_pre = @AstFoldFns {\n         fold_expr: |expr,span,recur|\n             expand_expr(extsbox, cx, expr, span, recur, afp.fold_expr),"}, {"sha": "ca281a22e3922b5c8461da499fa28183b7af6b9e", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -23,7 +23,7 @@ use ext::build::*;\n \n use core::unstable::extfmt::ct::*;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let args = get_exprs_from_tts(cx, tts);\n     if args.len() == 0 {\n@@ -34,7 +34,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n                     ~\"first argument to fmt! must be a string literal.\");\n     let fmtspan = args[0].span;\n     debug!(\"Format string: %s\", fmt);\n-    fn parse_fmt_err_(cx: @ext_ctxt, sp: span, msg: &str) -> ! {\n+    fn parse_fmt_err_(cx: @ExtCtxt, sp: span, msg: &str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err: @fn(&str) -> ! = |s| parse_fmt_err_(cx, fmtspan, s);\n@@ -46,23 +46,23 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n // probably be factored out in common with other code that builds\n // expressions.  Also: Cleanup the naming of these functions.\n // Note: Moved many of the common ones to build.rs --kevina\n-fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n+fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(cx: @ext_ctxt, ident: &str) -> ~[ast::ident] {\n+    fn make_path_vec(cx: @ExtCtxt, ident: &str) -> ~[ast::ident] {\n         let intr = cx.parse_sess().interner;\n         return ~[intr.intern(\"unstable\"), intr.intern(\"extfmt\"),\n                  intr.intern(\"rt\"), intr.intern(ident)];\n     }\n-    fn make_rt_path_expr(cx: @ext_ctxt, sp: span, nm: &str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n         return mk_path_global(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ext_ctxt, sp: span, flags: &[Flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: @ExtCtxt, sp: span, cnv: &Conv) -> @ast::expr {\n+        fn make_flags(cx: @ExtCtxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {\n@@ -77,7 +77,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             }\n             return tmp_expr;\n         }\n-        fn make_count(cx: @ext_ctxt, sp: span, cnt: Count) -> @ast::expr {\n+        fn make_count(cx: @ExtCtxt, sp: span, cnt: Count) -> @ast::expr {\n             match cnt {\n               CountImplied => {\n                 return make_rt_path_expr(cx, sp, \"CountImplied\");\n@@ -91,7 +91,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n               _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n         }\n-        fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {\n+        fn make_ty(cx: @ExtCtxt, sp: span, t: Ty) -> @ast::expr {\n             let rt_type = match t {\n               TyHex(c) => match c {\n                 CaseUpper =>  \"TyHexUpper\",\n@@ -103,7 +103,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n             };\n             return make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_struct(cx: @ext_ctxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n@@ -134,7 +134,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n                          rt_conv_precision, rt_conv_ty)\n     }\n-    fn make_conv_call(cx: @ext_ctxt, sp: span, conv_type: &str, cnv: &Conv,\n+    fn make_conv_call(cx: @ExtCtxt, sp: span, conv_type: &str, cnv: &Conv,\n                       arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         let fname = ~\"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n@@ -143,7 +143,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n         return mk_call_global(cx, arg.span, path, args);\n     }\n \n-    fn make_new_conv(cx: @ext_ctxt, sp: span, cnv: &Conv,\n+    fn make_new_conv(cx: @ExtCtxt, sp: span, cnv: &Conv,\n                      arg: @ast::expr, buf: @ast::expr) -> @ast::expr {\n         fn is_signed_type(cnv: &Conv) -> bool {\n             match cnv.ty {"}, {"sha": "a3f6fb8e97d219836697a198663e6ff3d42793b9", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -14,7 +14,7 @@ use ext::base::*;\n use ext::base;\n use print;\n \n-pub fn expand_syntax_ext(cx: @ext_ctxt,\n+pub fn expand_syntax_ext(cx: @ExtCtxt,\n                          sp: codemap::span,\n                          tt: &[ast::token_tree])\n                       -> base::MacResult {"}, {"sha": "1f38b14efbecf22e4ba45edf38e6b92cac15f693", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -19,7 +19,7 @@ use ast;\n use ast_util;\n use codemap::{span, respan, dummy_sp, spanned};\n use codemap;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n use opt_vec;\n use opt_vec::OptVec;\n@@ -135,7 +135,7 @@ pub trait ext_ctxt_ast_builder {\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n }\n \n-impl ext_ctxt_ast_builder for @ext_ctxt {\n+impl ext_ctxt_ast_builder for @ExtCtxt {\n     fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n         self.ty_path_ast_builder(path_global(~[\n             self.ident_of(\"core\"),"}, {"sha": "c0b7f5bbb84263f6e0faa2e6dd44ca5c4132a8be", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -31,11 +31,11 @@ that.\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::proto::{state, protocol, next_state};\n use ext::pipes::proto;\n \n-impl proto::visitor<(), (), ()> for @ext_ctxt {\n+impl proto::visitor<(), (), ()> for @ExtCtxt {\n     fn visit_proto(&self, _proto: protocol, _states: &[()]) { }\n \n     fn visit_state(&self, state: state, _m: &[()]) {"}, {"sha": "8d45e47d54ef75c207340d1f819e0a666188a7d5", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -37,12 +37,12 @@ updating the states using rule (2) until there are no changes.\n \n */\n \n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::proto::{protocol_};\n \n use std::bitv::Bitv;\n \n-pub fn analyze(proto: @mut protocol_, _cx: @ext_ctxt) {\n+pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n     let mut colive = do (copy proto.states).map_to_vec |state| {"}, {"sha": "46de21d1c0b2e7069d26f0a8751c535aafda6a83", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -46,7 +46,7 @@ FIXME (#3072) - This is still incomplete.\n use ast;\n use codemap::span;\n use ext::base;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::parse_proto::proto_parser;\n use ext::pipes::pipec::gen_init;\n use ext::pipes::proto::visit;\n@@ -63,7 +63,7 @@ pub mod check;\n pub mod liveness;\n \n \n-pub fn expand_proto(cx: @ext_ctxt, _sp: span, id: ast::ident,\n+pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n                     tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();"}, {"sha": "83b3572c85f3691ccd82416885ba24f84d16f2d7", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -12,7 +12,7 @@\n \n use ast;\n use codemap::{dummy_sp, spanned};\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n use ext::pipes::ast_builder::{path_global};\n use ext::pipes::proto::*;\n@@ -21,27 +21,27 @@ use opt_vec;\n use opt_vec::OptVec;\n \n pub trait gen_send {\n-    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty;\n+    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty;\n }\n \n pub trait to_type_decls {\n-    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item];\n-    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n+    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item];\n+    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n                          dir: direction) -> ~[@ast::item];\n }\n \n pub trait gen_init {\n-    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn compile(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty;\n-    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item;\n-    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n-    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr;\n+    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n+    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n+    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n }\n \n impl gen_send for message {\n-    fn gen_send(&mut self, cx: @ext_ctxt, try: bool) -> @ast::item {\n+    fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item {\n         debug!(\"pipec: gen_send\");\n         let name = self.name();\n \n@@ -184,14 +184,14 @@ impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(&mut self, cx: @ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path_ast_builder(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars_global(&self.get_generics().ty_params)))\n     }\n }\n \n impl to_type_decls for state {\n-    fn to_type_decls(&self, cx: @ext_ctxt) -> ~[@ast::item] {\n+    fn to_type_decls(&self, cx: @ExtCtxt) -> ~[@ast::item] {\n         debug!(\"pipec: to_type_decls\");\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n@@ -240,7 +240,7 @@ impl to_type_decls for state {\n         ]\n     }\n \n-    fn to_endpoint_decls(&self, cx: @ext_ctxt,\n+    fn to_endpoint_decls(&self, cx: @ExtCtxt,\n                          dir: direction) -> ~[@ast::item] {\n         debug!(\"pipec: to_endpoint_decls\");\n         let dir = match dir {\n@@ -302,7 +302,7 @@ impl to_type_decls for state {\n }\n \n impl gen_init for protocol {\n-    fn gen_init(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn gen_init(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n \n         debug!(\"gen_init\");\n@@ -340,7 +340,7 @@ impl gen_init for protocol {\n                            body.to_source(cx)))\n     }\n \n-    fn gen_buffer_init(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n+    fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n         ext_cx.struct_expr(path(~[ext_cx.ident_of(\"__Buffer\")],\n                                 dummy_sp()),\n                       self.states.map_to_vec(|s| {\n@@ -352,7 +352,7 @@ impl gen_init for protocol {\n         }))\n     }\n \n-    fn gen_init_bounded(&self, ext_cx: @ext_ctxt) -> @ast::expr {\n+    fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n         let buffer = quote_expr!(~::core::pipes::Buffer {\n@@ -378,7 +378,7 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: @ext_ctxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for (copy self.states).each |s| {\n             for s.generics.ty_params.each |tp| {\n@@ -395,7 +395,7 @@ impl gen_init for protocol {\n                                .add_tys(cx.ty_vars_global(&params)))\n     }\n \n-    fn gen_buffer_type(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         let fields = do (copy self.states).map_to_vec |s| {\n@@ -436,7 +436,7 @@ impl gen_init for protocol {\n             cx.strip_bounds(&generics))\n     }\n \n-    fn compile(&self, cx: @ext_ctxt) -> @ast::item {\n+    fn compile(&self, cx: @ExtCtxt) -> @ast::item {\n         let mut items = ~[self.gen_init(cx)];\n         let mut client_states = ~[];\n         let mut server_states = ~[];"}, {"sha": "12a0a0a24d6165b98a011b61c0c5e2a3ca84fd69", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,7 +10,7 @@\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::pipes::ast_builder::{append_types, ext_ctxt_ast_builder, path};\n \n #[deriving(Eq)]\n@@ -92,7 +92,7 @@ pub impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    fn to_ty(&self, cx: @ext_ctxt) -> @ast::Ty {\n+    fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path_ast_builder\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)))"}, {"sha": "2ccceeec294fc18dcf51e227344c60754cb223fb", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,7 +10,7 @@\n \n use ast;\n use codemap::{BytePos, Pos, span};\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::base;\n use ext::build;\n use parse::token::*;\n@@ -30,7 +30,7 @@ use parse;\n \n pub mod rt {\n     use ast;\n-    use ext::base::ext_ctxt;\n+    use ext::base::ExtCtxt;\n     use parse;\n     use print::pprust;\n \n@@ -44,11 +44,11 @@ pub mod rt {\n     use print::pprust::{item_to_str, ty_to_str};\n \n     pub trait ToTokens {\n-        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree];\n+        pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree];\n     }\n \n     impl ToTokens for ~[token_tree] {\n-        pub fn to_tokens(&self, _cx: @ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree] {\n             copy *self\n         }\n     }\n@@ -57,10 +57,10 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: @ext_ctxt) -> ~str;\n+        pub fn to_source(cx: @ExtCtxt) -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n-        pub fn to_tokens(cx: @ext_ctxt) -> ~[token_tree] {\n+        pub fn to_tokens(cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -69,130 +69,130 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self, cx: @ext_ctxt) -> ~str;\n+        pub fn to_source(&self, cx: @ExtCtxt) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             copy *cx.parse_sess().interner.get(*self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             item_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::item] {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), \"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             ty_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             str::connect(self.map(|i| i.to_source(cx)), \", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::generics_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::expr_to_str(*self, cx.parse_sess().interner)\n         }\n     }\n \n     impl ToSource for ast::blk {\n-        fn to_source(&self, cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n             pprust::block_to_str(self, cx.parse_sess().interner)\n         }\n     }\n \n     impl<'self> ToSource for &'self str {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_str(@str::to_owned(*self)));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self, _cx: @ext_ctxt) -> ~str {\n+        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n             pprust::lit_to_str(@lit)\n         }\n@@ -201,115 +201,115 @@ pub mod rt {\n     // Alas ... we write these out instead. All redundant.\n \n     impl ToTokens for ast::ident {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::item {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::item] {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::Ty] {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for Generics {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for ast::blk {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl<'self> ToTokens for &'self str {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for int {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i8 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i16 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i32 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for i64 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for uint {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u8 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u16 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u32 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n \n     impl ToTokens for u64 {\n-        fn to_tokens(&self, cx: @ext_ctxt) -> ~[token_tree] {\n+        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source(cx))\n         }\n     }\n@@ -321,7 +321,7 @@ pub mod rt {\n         fn parse_tts(&self, s: ~str) -> ~[ast::token_tree];\n     }\n \n-    impl ExtParseUtils for @ext_ctxt {\n+    impl ExtParseUtils for ExtCtxt {\n \n         fn parse_item(&self, s: ~str) -> @ast::item {\n             let res = parse::parse_item_from_source_str(\n@@ -367,74 +367,74 @@ pub mod rt {\n \n }\n \n-pub fn expand_quote_tokens(cx: @ext_ctxt,\n+pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_tts(cx, sp, tts))\n }\n \n-pub fn expand_quote_expr(cx: @ext_ctxt,\n+pub fn expand_quote_expr(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_expr\", ~[], tts))\n }\n \n-pub fn expand_quote_item(cx: @ext_ctxt,\n+pub fn expand_quote_item(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_item\",\n                                     ~[e_attrs], tts))\n }\n \n-pub fn expand_quote_pat(cx: @ext_ctxt,\n+pub fn expand_quote_pat(cx: @ExtCtxt,\n                         sp: span,\n                         tts: &[ast::token_tree]) -> base::MacResult {\n     let e_refutable = build::mk_lit(cx, sp, ast::lit_bool(true));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_pat\",\n                                     ~[e_refutable], tts))\n }\n \n-pub fn expand_quote_ty(cx: @ext_ctxt,\n+pub fn expand_quote_ty(cx: @ExtCtxt,\n                        sp: span,\n                        tts: &[ast::token_tree]) -> base::MacResult {\n     let e_param_colons = build::mk_lit(cx, sp, ast::lit_bool(false));\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_ty\",\n                                     ~[e_param_colons], tts))\n }\n \n-pub fn expand_quote_stmt(cx: @ext_ctxt,\n+pub fn expand_quote_stmt(cx: @ExtCtxt,\n                          sp: span,\n                          tts: &[ast::token_tree]) -> base::MacResult {\n     let e_attrs = build::mk_uniq_vec_e(cx, sp, ~[]);\n     base::MRExpr(expand_parse_call(cx, sp, \"parse_stmt\",\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(cx: @ext_ctxt, strs: ~[~str]) -> ~[ast::ident] {\n+fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| cx.parse_sess().interner.intern(*str))\n }\n \n-fn id_ext(cx: @ext_ctxt, str: &str) -> ast::ident {\n+fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n     cx.parse_sess().interner.intern(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n+fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_str = build::mk_base_str(cx, sp, cx.str_of(ident));\n     build::mk_method_call(cx, sp,\n                           build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n                           id_ext(cx, \"ident_of\"),\n                           ~[e_str])\n }\n \n-fn mk_bytepos(cx: @ext_ctxt, sp: span, bpos: BytePos) -> @ast::expr {\n+fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n     let path = ids_ext(cx, ~[~\"BytePos\"]);\n     let arg = build::mk_uint(cx, sp, bpos.to_uint());\n     build::mk_call(cx, sp, path, ~[arg])\n }\n \n-fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n+fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n     let name = match bop {\n         PLUS => \"PLUS\",\n         MINUS => \"MINUS\",\n@@ -451,7 +451,7 @@ fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n-fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n+fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n@@ -600,7 +600,7 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n }\n \n \n-fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n+fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     -> ~[@ast::stmt] {\n \n     match *tt {\n@@ -646,7 +646,7 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n     }\n }\n \n-fn mk_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> ~[@ast::stmt] {\n     let mut ss = ~[];\n     for tts.each |tt| {\n@@ -655,7 +655,7 @@ fn mk_tts(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     ss\n }\n \n-fn expand_tts(cx: @ext_ctxt,\n+fn expand_tts(cx: @ExtCtxt,\n               sp: span,\n               tts: &[ast::token_tree]) -> @ast::expr {\n \n@@ -729,7 +729,7 @@ fn expand_tts(cx: @ext_ctxt,\n                                         ids_ext(cx, ~[~\"tt\"]))))\n }\n \n-fn expand_parse_call(cx: @ext_ctxt,\n+fn expand_parse_call(cx: @ExtCtxt,\n                      sp: span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::expr],"}, {"sha": "d78c06bec0774927198638dfbfc68d77de69ed81", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -23,7 +23,7 @@ use print::pprust;\n // a given file into the current one.\n \n /* line!(): expands to the current line number */\n-pub fn expand_line(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_line(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n@@ -34,7 +34,7 @@ pub fn expand_line(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n }\n \n /* col!(): expands to the current column number */\n-pub fn expand_col(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_col(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n@@ -46,7 +46,7 @@ pub fn expand_col(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n /* file!(): expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n-pub fn expand_file(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n@@ -56,13 +56,13 @@ pub fn expand_file(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, topmost.call_site, filename))\n }\n \n-pub fn expand_stringify(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n     base::MRExpr(mk_base_str(cx, sp, s))\n }\n \n-pub fn expand_mod(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n@@ -73,7 +73,7 @@ pub fn expand_mod(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n // include! : parse the given file as an expr\n // This is generally a bad idea because it's going to behave\n // unhygienically.\n-pub fn expand_include(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include!\");\n     let p = parse::new_sub_parser_from_file(\n@@ -83,7 +83,7 @@ pub fn expand_include(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n }\n \n // include_str! : read the given file, insert it as a literal string expr\n-pub fn expand_include_str(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n@@ -97,7 +97,7 @@ pub fn expand_include_str(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::MRExpr(mk_base_str(cx, sp, result::unwrap(res)))\n }\n \n-pub fn expand_include_bin(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n@@ -141,7 +141,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: @ext_ctxt, sp: codemap::span, arg: &Path) -> Path {\n+fn res_rel_file(cx: @ExtCtxt, sp: codemap::span, arg: &Path) -> Path {\n     // NB: relative paths are resolved relative to the compilation unit\n     if !arg.is_absolute {\n         let cu = Path(cx.codemap().span_to_filename(sp));"}, {"sha": "25607a8bfa76fad419dff07c7be50e3a3d4b8441", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -10,12 +10,12 @@\n \n use ast;\n use codemap::span;\n-use ext::base::ext_ctxt;\n+use ext::base::ExtCtxt;\n use ext::base;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n \n-pub fn expand_trace_macros(cx: @ext_ctxt,\n+pub fn expand_trace_macros(cx: @ExtCtxt,\n                            sp: span,\n                            tt: &[ast::token_tree])\n                         -> base::MacResult {"}, {"sha": "3814243efc4c6e058285300ec0cd317d2d45c433", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -13,7 +13,7 @@ use ast::{ident, matcher_, matcher, match_tok, match_nonterminal, match_seq};\n use ast::{tt_delim};\n use ast;\n use codemap::{span, spanned, dummy_sp};\n-use ext::base::{ext_ctxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n+use ext::base::{ExtCtxt, MacResult, MRAny, MRDef, MacroDef, NormalTT};\n use ext::base;\n use ext::tt::macro_parser::{error};\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n@@ -26,7 +26,7 @@ use print;\n \n use core::io;\n \n-pub fn add_new_extension(cx: @ext_ctxt,\n+pub fn add_new_extension(cx: @ExtCtxt,\n                          sp: span,\n                          name: ident,\n                          arg: ~[ast::token_tree])\n@@ -73,7 +73,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n-    fn generic_extension(cx: @ext_ctxt, sp: span, name: ident,\n+    fn generic_extension(cx: @ExtCtxt, sp: span, name: ident,\n                          arg: &[ast::token_tree],\n                          lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {\n@@ -145,7 +145,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n         cx.span_fatal(best_fail_spot, best_fail_msg);\n     }\n \n-    let exp: @fn(@ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n+    let exp: @fn(@ExtCtxt, span, &[ast::token_tree]) -> MacResult =\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{"}, {"sha": "0cd416afc8316874fbd1f31aebdaa477fe088308", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4045da9f4f7290b02bee52caa42504e4ce5406f7/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=4045da9f4f7290b02bee52caa42504e4ce5406f7", "patch": "@@ -12,9 +12,9 @@\n \n extern mod syntax;\n \n-use syntax::ext::base::ext_ctxt;\n+use syntax::ext::base::ExtCtxt;\n \n-fn syntax_extension(ext_cx: @ext_ctxt) {\n+fn syntax_extension(ext_cx: @ExtCtxt) {\n     let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(1 + 2);\n     let p_toks : ~[syntax::ast::token_tree] = quote_tokens!((x, 1 .. 4, *));\n "}]}