{"sha": "8da27078d3b102a1d96dd0a4270baa1bb5f392e2", "node_id": "C_kwDOAAsO6NoAKDhkYTI3MDc4ZDNiMTAyYTFkOTZkZDBhNDI3MGJhYTFiYjVmMzkyZTI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-12T19:18:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-29T10:16:09Z"}, "message": "Stop pretty-printing anonymous lifetimes.", "tree": {"sha": "58298e4ed59cb44deb7dc52d15a7c39131e06f95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58298e4ed59cb44deb7dc52d15a7c39131e06f95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da27078d3b102a1d96dd0a4270baa1bb5f392e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da27078d3b102a1d96dd0a4270baa1bb5f392e2", "html_url": "https://github.com/rust-lang/rust/commit/8da27078d3b102a1d96dd0a4270baa1bb5f392e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da27078d3b102a1d96dd0a4270baa1bb5f392e2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303d916867040e269b54adf3cfc7f5c903dc26ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/303d916867040e269b54adf3cfc7f5c903dc26ff", "html_url": "https://github.com/rust-lang/rust/commit/303d916867040e269b54adf3cfc7f5c903dc26ff"}], "stats": {"total": 71, "additions": 28, "deletions": 43}, "files": [{"sha": "64c63e3d567d039d91b133a01662b1f46e6a4b29", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 43, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8da27078d3b102a1d96dd0a4270baa1bb5f392e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da27078d3b102a1d96dd0a4270baa1bb5f392e2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=8da27078d3b102a1d96dd0a4270baa1bb5f392e2", "patch": "@@ -2177,61 +2177,47 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         define_scoped_cx!(self);\n \n         let mut region_index = self.region_index;\n+        let mut next_name = |this: &Self| loop {\n+            let name = name_by_region_index(region_index);\n+            region_index += 1;\n+            if !this.used_region_names.contains(&name) {\n+                break name;\n+            }\n+        };\n+\n         // If we want to print verbosely, then print *all* binders, even if they\n         // aren't named. Eventually, we might just want this as the default, but\n         // this is not *quite* right and changes the ordering of some output\n         // anyways.\n         let (new_value, map) = if self.tcx().sess.verbose() {\n             // anon index + 1 (BrEnv takes 0) -> name\n-            let mut region_map: BTreeMap<u32, Symbol> = BTreeMap::default();\n+            let mut region_map: FxHashMap<_, _> = Default::default();\n             let bound_vars = value.bound_vars();\n             for var in bound_vars {\n+                let ty::BoundVariableKind::Region(var) = var else { continue };\n                 match var {\n-                    ty::BoundVariableKind::Region(ty::BrNamed(_, name)) => {\n+                    ty::BrAnon(_) | ty::BrEnv => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n+                        region_map.insert(var, ty::BrNamed(CRATE_DEF_ID.to_def_id(), name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrAnon(i)) => {\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n-                        region_map.insert(i + 1, name);\n+                        region_map.insert(var, ty::BrNamed(def_id, name));\n                     }\n-                    ty::BoundVariableKind::Region(ty::BrEnv) => {\n+                    ty::BrNamed(_, name) => {\n                         start_or_continue(&mut self, \"for<\", \", \");\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n                         do_continue(&mut self, name);\n-                        region_map.insert(0, name);\n                     }\n-                    _ => continue,\n                 }\n             }\n             start_or_continue(&mut self, \"\", \"> \");\n \n             self.tcx.replace_late_bound_regions(value.clone(), |br| {\n-                let kind = match br.kind {\n-                    ty::BrNamed(_, _) => br.kind,\n-                    ty::BrAnon(i) => {\n-                        let name = region_map[&(i + 1)];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                    ty::BrEnv => {\n-                        let name = region_map[&0];\n-                        ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n-                    }\n-                };\n+                let kind = region_map[&br.kind];\n                 self.tcx.mk_region(ty::ReLateBound(\n                     ty::INNERMOST,\n                     ty::BoundRegion { var: br.var, kind },\n@@ -2242,21 +2228,20 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n             let mut name = |br: ty::BoundRegion| {\n                 start_or_continue(&mut self, \"for<\", \", \");\n                 let kind = match br.kind {\n-                    ty::BrNamed(_, name) => {\n-                        do_continue(&mut self, name);\n-                        br.kind\n-                    }\n                     ty::BrAnon(_) | ty::BrEnv => {\n-                        let name = loop {\n-                            let name = name_by_region_index(region_index);\n-                            region_index += 1;\n-                            if !self.used_region_names.contains(&name) {\n-                                break name;\n-                            }\n-                        };\n+                        let name = next_name(&self);\n                         do_continue(&mut self, name);\n                         ty::BrNamed(CRATE_DEF_ID.to_def_id(), name)\n                     }\n+                    ty::BrNamed(def_id, kw::UnderscoreLifetime) => {\n+                        let name = next_name(&self);\n+                        do_continue(&mut self, name);\n+                        ty::BrNamed(def_id, name)\n+                    }\n+                    ty::BrNamed(_, name) => {\n+                        do_continue(&mut self, name);\n+                        br.kind\n+                    }\n                 };\n                 tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n             };"}]}