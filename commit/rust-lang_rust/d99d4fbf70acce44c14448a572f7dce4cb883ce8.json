{"sha": "d99d4fbf70acce44c14448a572f7dce4cb883ce8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OWQ0ZmJmNzBhY2NlNDRjMTQ0NDhhNTcyZjdkY2U0Y2I4ODNjZTg=", "commit": {"author": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-07-09T13:03:10Z"}, "committer": {"name": "Tobias Bucher", "email": "tobiasbucher5991@gmail.com", "date": "2015-07-09T13:03:10Z"}, "message": "Address some comments on the pull request", "tree": {"sha": "5b1b6ca0f73742932a069c8147a9adc50130bea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b1b6ca0f73742932a069c8147a9adc50130bea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d99d4fbf70acce44c14448a572f7dce4cb883ce8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d99d4fbf70acce44c14448a572f7dce4cb883ce8", "html_url": "https://github.com/rust-lang/rust/commit/d99d4fbf70acce44c14448a572f7dce4cb883ce8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d99d4fbf70acce44c14448a572f7dce4cb883ce8/comments", "author": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tbu-", "id": 6666593, "node_id": "MDQ6VXNlcjY2NjY1OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/6666593?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tbu-", "html_url": "https://github.com/tbu-", "followers_url": "https://api.github.com/users/tbu-/followers", "following_url": "https://api.github.com/users/tbu-/following{/other_user}", "gists_url": "https://api.github.com/users/tbu-/gists{/gist_id}", "starred_url": "https://api.github.com/users/tbu-/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tbu-/subscriptions", "organizations_url": "https://api.github.com/users/tbu-/orgs", "repos_url": "https://api.github.com/users/tbu-/repos", "events_url": "https://api.github.com/users/tbu-/events{/privacy}", "received_events_url": "https://api.github.com/users/tbu-/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a5b1368e78979eda0420a95381fe6f61f1a086", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a5b1368e78979eda0420a95381fe6f61f1a086", "html_url": "https://github.com/rust-lang/rust/commit/c8a5b1368e78979eda0420a95381fe6f61f1a086"}], "stats": {"total": 65, "additions": 25, "deletions": 40}, "files": [{"sha": "5bf8c1e06a627e511ad8c368162cdb8bcda0bc70", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d99d4fbf70acce44c14448a572f7dce4cb883ce8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99d4fbf70acce44c14448a572f7dce4cb883ce8/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=d99d4fbf70acce44c14448a572f7dce4cb883ce8", "patch": "@@ -79,33 +79,20 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n // without specifying its size. They will only report back whether the buffer\n // was large enough or not.\n //\n-// The callback is yielded a (pointer, len) pair which can be\n-// passed to a syscall. The `ptr` is valid for `len` items (i8 in this case).\n-// The closure is expected to return `None` if the space was insufficient and\n-// `Some(r)` if the syscall did not fail due to insufficient space.\n+// The callback is yielded an uninitialized vector which can be passed to a\n+// syscall. The closure is expected to return `Err(v)` with the passed vector\n+// if the space was insufficient and `Ok(r)` if the syscall did not fail due to\n+// insufficient space.\n fn fill_bytes_buf<F, T>(mut f: F) -> io::Result<T>\n-    where F: FnMut(*mut i8, libc::size_t) -> Option<io::Result<T>>,\n+    where F: FnMut(Vec<u8>) -> Result<io::Result<T>,Vec<u8>>,\n {\n-    // Start off with a stack buf but then spill over to the heap if we end up\n-    // needing more space.\n-    let mut stack_buf = [0i8; os::BUF_BYTES];\n-    let mut heap_buf = Vec::new();\n-    unsafe {\n-        let mut n = stack_buf.len();\n-        loop {\n-            let buf = if n <= stack_buf.len() {\n-                &mut stack_buf[..]\n-            } else {\n-                heap_buf.set_len(0);\n-                heap_buf.reserve(n);\n-                heap_buf.set_len(n);\n-                &mut heap_buf[..]\n-            };\n-\n-            match f(buf.as_mut_ptr(), n as libc::size_t) {\n-                None => n *= 2,\n-                Some(r) => return r,\n-            }\n+    let mut buf = Vec::new();\n+    let mut n = os::BUF_BYTES;\n+    loop {\n+        buf.reserve(n);\n+        match f(buf) {\n+            Err(b) => { buf = b; n *= 2; }\n+            Ok(r) => return r,\n         }\n     }\n }"}, {"sha": "ac38d294a6f330b529faeeb7b529f5d6d472e901", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d99d4fbf70acce44c14448a572f7dce4cb883ce8/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d99d4fbf70acce44c14448a572f7dce4cb883ce8/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d99d4fbf70acce44c14448a572f7dce4cb883ce8", "patch": "@@ -33,14 +33,6 @@ use vec;\n pub const BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n-fn bytes2path(b: &[u8]) -> PathBuf {\n-    PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n-}\n-\n-fn os2path(os: OsString) -> PathBuf {\n-    bytes2path(os.as_bytes())\n-}\n-\n /// Returns the platform-specific value of errno\n pub fn errno() -> i32 {\n     #[cfg(any(target_os = \"macos\",\n@@ -102,14 +94,17 @@ pub fn error_string(errno: i32) -> String {\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n-    super::fill_bytes_buf(|buf, len| {\n+    super::fill_bytes_buf(|mut buf| {\n         unsafe {\n-            Some(if !libc::getcwd(buf, len).is_null() {\n-                Ok(bytes2path(CStr::from_ptr(buf).to_bytes()))\n+            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n+            Ok(if !libc::getcwd(ptr, buf.capacity() as libc::size_t).is_null() {\n+                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n+                buf.set_len(len);\n+                Ok(PathBuf::from(OsString::from_bytes(buf).unwrap()))\n             } else {\n                 let error = io::Error::last_os_error();\n                 if error.raw_os_error().unwrap() == libc::ERANGE {\n-                    return None;\n+                    return Err(buf);\n                 }\n                 Err(error)\n             })\n@@ -134,11 +129,14 @@ pub struct SplitPaths<'a> {\n }\n \n pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n+    fn bytes_to_path(b: &[u8]) -> PathBuf {\n+        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n+    }\n     fn is_colon(b: &u8) -> bool { *b == b':' }\n     let unparsed = unparsed.as_bytes();\n     SplitPaths {\n         iter: unparsed.split(is_colon as fn(&u8) -> bool)\n-                      .map(bytes2path as fn(&'a [u8]) -> PathBuf)\n+                      .map(bytes_to_path as fn(&'a [u8]) -> PathBuf)\n     }\n }\n \n@@ -449,7 +447,7 @@ pub fn page_size() -> usize {\n }\n \n pub fn temp_dir() -> PathBuf {\n-    getenv(\"TMPDIR\".as_ref()).map(os2path).unwrap_or_else(|| {\n+    getenv(\"TMPDIR\".as_ref()).map(PathBuf::from).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n             PathBuf::from(\"/data/local/tmp\")\n         } else {\n@@ -461,7 +459,7 @@ pub fn temp_dir() -> PathBuf {\n pub fn home_dir() -> Option<PathBuf> {\n     return getenv(\"HOME\".as_ref()).or_else(|| unsafe {\n         fallback()\n-    }).map(os2path);\n+    }).map(PathBuf::from);\n \n     #[cfg(any(target_os = \"android\",\n               target_os = \"ios\"))]"}]}