{"sha": "65790f2b2a1682ecce330587a2922d51d604c0b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NzkwZjJiMmExNjgyZWNjZTMzMDU4N2EyOTIyZDUxZDYwNGMwYjE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-10T05:35:50Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-07-10T05:38:16Z"}, "message": "Cover missing comments before and after where", "tree": {"sha": "368a530fb7a613ad57c7763831a916d42455f6d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/368a530fb7a613ad57c7763831a916d42455f6d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65790f2b2a1682ecce330587a2922d51d604c0b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65790f2b2a1682ecce330587a2922d51d604c0b1", "html_url": "https://github.com/rust-lang/rust/commit/65790f2b2a1682ecce330587a2922d51d604c0b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65790f2b2a1682ecce330587a2922d51d604c0b1/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b681e06fddf1c12541ca0bf9704dcbd4f129408", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b681e06fddf1c12541ca0bf9704dcbd4f129408", "html_url": "https://github.com/rust-lang/rust/commit/8b681e06fddf1c12541ca0bf9704dcbd4f129408"}], "stats": {"total": 251, "additions": 201, "deletions": 50}, "files": [{"sha": "96ffffa7b6050f8ca48c05fbfadf35f8c9935bc1", "filename": "src/items.rs", "status": "modified", "additions": 135, "deletions": 50, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/65790f2b2a1682ecce330587a2922d51d604c0b1/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65790f2b2a1682ecce330587a2922d51d604c0b1/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=65790f2b2a1682ecce330587a2922d51d604c0b1", "patch": "@@ -10,7 +10,7 @@\n \n // Formatting top-level items - functions, structs, enums, traits, impls.\n \n-use {Indent, Shape};\n+use {Indent, Shape, Spanned};\n use codemap::SpanUtils;\n use utils::{format_mutability, format_visibility, contains_skip, end_typaram, wrap_str,\n             last_line_width, format_unsafety, trim_newlines, stmt_expr, semicolon_for_expr,\n@@ -561,7 +561,7 @@ pub fn format_impl(\n     offset: Indent,\n     where_span_end: Option<BytePos>,\n ) -> Option<String> {\n-    if let ast::ItemKind::Impl(_, _, _, ref generics, _, _, ref items) = item.node {\n+    if let ast::ItemKind::Impl(_, _, _, ref generics, _, ref self_ty, ref items) = item.node {\n         let mut result = String::new();\n         let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n         result.push_str(&ref_and_type);\n@@ -585,6 +585,8 @@ pub fn format_impl(\n             false,\n             last_line_width(&ref_and_type) == 1,\n             where_span_end,\n+            item.span,\n+            self_ty.span.hi,\n         ));\n \n         if try_opt!(is_impl_single_line(\n@@ -963,6 +965,12 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 .max_width()\n                 .checked_sub(last_line_width(&result))\n         );\n+        let pos_before_where = if type_param_bounds.is_empty() {\n+            // We do not use this, so it does not matter\n+            generics.span.hi\n+        } else {\n+            type_param_bounds[type_param_bounds.len() - 1].span().hi\n+        };\n         let where_clause_str = try_opt!(rewrite_where_clause(\n             context,\n             &generics.where_clause,\n@@ -973,6 +981,8 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             !has_body,\n             trait_bound_str.is_empty() && last_line_width(&generics_str) == 1,\n             None,\n+            item.span,\n+            pos_before_where,\n         ));\n         // If the where clause cannot fit on the same line,\n         // put the where clause on a new line\n@@ -1164,6 +1174,19 @@ fn format_tuple_struct(\n     } else {\n         fields[0].span.lo\n     };\n+    let body_hi = if fields.is_empty() {\n+        context.codemap.span_after(span, \")\")\n+    } else {\n+        // This is a dirty hack to work around a missing `)` from the span of the last field.\n+        let last_arg_span = fields[fields.len() - 1].span;\n+        if context.snippet(last_arg_span).ends_with(\")\") {\n+            last_arg_span.hi\n+        } else {\n+            context\n+                .codemap\n+                .span_after(mk_sp(last_arg_span.hi, span.hi), \")\")\n+        }\n+    };\n \n     let where_clause_str = match generics {\n         Some(generics) => {\n@@ -1184,6 +1207,8 @@ fn format_tuple_struct(\n                 true,\n                 false,\n                 None,\n+                span,\n+                body_hi,\n             ))\n         }\n         None => \"\".to_owned(),\n@@ -1283,6 +1308,8 @@ pub fn rewrite_type_alias(\n         true,\n         true,\n         Some(span.hi),\n+        span,\n+        generics.span.hi,\n     ));\n     result.push_str(&where_clause_str);\n     result.push_str(\" = \");\n@@ -1734,41 +1761,6 @@ pub fn is_named_arg(arg: &ast::Arg) -> bool {\n     }\n }\n \n-fn span_for_return(ret: &ast::FunctionRetTy) -> Span {\n-    match *ret {\n-        ast::FunctionRetTy::Default(ref span) => span.clone(),\n-        ast::FunctionRetTy::Ty(ref ty) => ty.span,\n-    }\n-}\n-\n-fn span_for_ty_param(ty: &ast::TyParam) -> Span {\n-    // Note that ty.span is the span for ty.ident, not the whole item.\n-    let lo = if ty.attrs.is_empty() {\n-        ty.span.lo\n-    } else {\n-        ty.attrs[0].span.lo\n-    };\n-    if let Some(ref def) = ty.default {\n-        return mk_sp(lo, def.span.hi);\n-    }\n-    if ty.bounds.is_empty() {\n-        return mk_sp(lo, ty.span.hi);\n-    }\n-    let hi = match ty.bounds[ty.bounds.len() - 1] {\n-        ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span.hi,\n-        ast::TyParamBound::RegionTyParamBound(ref l) => l.span.hi,\n-    };\n-    mk_sp(lo, hi)\n-}\n-\n-fn span_for_where_pred(pred: &ast::WherePredicate) -> Span {\n-    match *pred {\n-        ast::WherePredicate::BoundPredicate(ref p) => p.span,\n-        ast::WherePredicate::RegionPredicate(ref p) => p.span,\n-        ast::WherePredicate::EqPredicate(ref p) => p.span,\n-    }\n-}\n-\n // Return type is (result, force_new_line_for_brace)\n fn rewrite_fn_base(\n     context: &RewriteContext,\n@@ -1826,7 +1818,7 @@ fn rewrite_fn_base(\n     let shape = try_opt!(\n         Shape::indented(indent + last_line_width(&result), context.config).sub_width(overhead)\n     );\n-    let g_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n+    let g_span = mk_sp(span.lo, fd.output.span().lo);\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n@@ -1905,9 +1897,15 @@ fn rewrite_fn_base(\n         .ty_params\n         .last()\n         .map_or(span.lo, |tp| end_typaram(tp));\n+    let args_end = if fd.inputs.is_empty() {\n+        context.codemap.span_after(mk_sp(args_start, span.hi), \")\")\n+    } else {\n+        let last_span = mk_sp(fd.inputs[fd.inputs.len() - 1].span().hi, span.hi);\n+        context.codemap.span_after(last_span, \")\")\n+    };\n     let args_span = mk_sp(\n         context.codemap.span_after(mk_sp(args_start, span.hi), \"(\"),\n-        span_for_return(&fd.output).lo,\n+        args_end,\n     );\n     let arg_str = try_opt!(rewrite_args(\n         context,\n@@ -2053,6 +2051,10 @@ fn rewrite_fn_base(\n         _ => false,\n     } || (put_args_in_block && ret_str.is_empty());\n \n+    let pos_before_where = match fd.output {\n+        ast::FunctionRetTy::Default(..) => args_span.hi,\n+        ast::FunctionRetTy::Ty(ref ty) => ty.span.hi,\n+    };\n     if where_clause.predicates.len() == 1 && should_compress_where {\n         let budget = try_opt!(\n             context\n@@ -2070,6 +2072,8 @@ fn rewrite_fn_base(\n             !has_braces,\n             put_args_in_block && ret_str.is_empty(),\n             Some(span.hi),\n+            span,\n+            pos_before_where,\n         ) {\n             if !where_clause_str.contains('\\n') {\n                 if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n@@ -2094,6 +2098,8 @@ fn rewrite_fn_base(\n         !has_braces,\n         put_args_in_block && ret_str.is_empty(),\n         Some(span.hi),\n+        span,\n+        pos_before_where,\n     ));\n \n     result.push_str(&where_clause_str);\n@@ -2378,7 +2384,7 @@ fn rewrite_generics_inner(\n         };\n         mk_sp(l.lifetime.span.lo, hi)\n     });\n-    let ty_spans = tys.iter().map(span_for_ty_param);\n+    let ty_spans = tys.iter().map(|ty| ty.span());\n \n     let items = itemize_list(\n         context.codemap,\n@@ -2495,29 +2501,40 @@ fn rewrite_where_clause_rfc_style(\n     // where clause can be kept on the current line.\n     snuggle: bool,\n     span_end: Option<BytePos>,\n+    span: Span,\n+    span_end_before_where: BytePos,\n ) -> Option<String> {\n     let block_shape = shape.block().with_max_width(context.config);\n \n-    let starting_newline = if snuggle {\n+    let (span_before, span_after) =\n+        missing_span_before_after_where(context, span.hi, span_end_before_where, where_clause);\n+    let (comment_before, comment_after) = try_opt!(rewrite_comments_before_after_where(\n+        context,\n+        span_before,\n+        span_after,\n+        shape,\n+    ));\n+\n+    let starting_newline = if snuggle && comment_before.is_empty() {\n         \" \".to_owned()\n     } else {\n         \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n     };\n \n     let clause_shape = block_shape.block_indent(context.config.tab_spaces());\n     // each clause on one line, trailing comma (except if suppress_comma)\n-    let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+    let span_start = where_clause.predicates[0].span().lo;\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n     let len = where_clause.predicates.len();\n-    let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n+    let end_of_preds = where_clause.predicates[len - 1].span().hi;\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.codemap,\n         where_clause.predicates.iter(),\n         terminator,\n-        |pred| span_for_where_pred(pred).lo,\n-        |pred| span_for_where_pred(pred).hi,\n+        |pred| pred.span().lo,\n+        |pred| pred.span().hi,\n         |pred| pred.rewrite(context, block_shape),\n         span_start,\n         span_end,\n@@ -2538,9 +2555,23 @@ fn rewrite_where_clause_rfc_style(\n     };\n     let preds_str = try_opt!(write_list(&items.collect::<Vec<_>>(), &fmt));\n \n+    let newline_before_where = if comment_before.is_empty() || comment_before.ends_with('\\n') {\n+        String::new()\n+    } else {\n+        \"\\n\".to_owned() + &shape.indent.to_string(context.config)\n+    };\n+    let newline_after_where = if comment_after.is_empty() {\n+        String::new()\n+    } else {\n+        \"\\n\".to_owned() + &clause_shape.indent.to_string(context.config)\n+    };\n     Some(format!(\n-        \"{}where\\n{}{}\",\n+        \"{}{}{}where{}{}\\n{}{}\",\n         starting_newline,\n+        comment_before,\n+        newline_before_where,\n+        newline_after_where,\n+        comment_after,\n         clause_shape.indent.to_string(context.config),\n         preds_str\n     ))\n@@ -2556,6 +2587,8 @@ fn rewrite_where_clause(\n     suppress_comma: bool,\n     snuggle: bool,\n     span_end: Option<BytePos>,\n+    span: Span,\n+    span_end_before_where: BytePos,\n ) -> Option<String> {\n     if where_clause.predicates.is_empty() {\n         return Some(String::new());\n@@ -2570,6 +2603,8 @@ fn rewrite_where_clause(\n             suppress_comma,\n             snuggle,\n             span_end,\n+            span,\n+            span_end_before_where,\n         );\n     }\n \n@@ -2584,18 +2619,18 @@ fn rewrite_where_clause(\n     // be out by a char or two.\n \n     let budget = context.config.max_width() - offset.width();\n-    let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+    let span_start = where_clause.predicates[0].span().lo;\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n     let len = where_clause.predicates.len();\n-    let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n+    let end_of_preds = where_clause.predicates[len - 1].span().hi;\n     let span_end = span_end.unwrap_or(end_of_preds);\n     let items = itemize_list(\n         context.codemap,\n         where_clause.predicates.iter(),\n         terminator,\n-        |pred| span_for_where_pred(pred).lo,\n-        |pred| span_for_where_pred(pred).hi,\n+        |pred| pred.span().lo,\n+        |pred| pred.span().hi,\n         |pred| pred.rewrite(context, Shape::legacy(budget, offset)),\n         span_start,\n         span_end,\n@@ -2646,6 +2681,54 @@ fn rewrite_where_clause(\n     }\n }\n \n+fn missing_span_before_after_where(\n+    context: &RewriteContext,\n+    item_end: BytePos,\n+    before_item_span_end: BytePos,\n+    where_clause: &ast::WhereClause,\n+) -> (Span, Span) {\n+    let snippet = context.snippet(mk_sp(before_item_span_end, item_end));\n+    let pos_before_where =\n+        before_item_span_end + BytePos(snippet.find_uncommented(\"where\").unwrap() as u32);\n+    let missing_span_before = mk_sp(before_item_span_end, pos_before_where);\n+    // 5 = `where`\n+    let pos_after_where = pos_before_where + BytePos(5);\n+    let missing_span_after = mk_sp(pos_after_where, where_clause.predicates[0].span().lo);\n+    (missing_span_before, missing_span_after)\n+}\n+\n+fn rewrite_missing_comment_in_where(\n+    context: &RewriteContext,\n+    comment: &str,\n+    shape: Shape,\n+) -> Option<String> {\n+    let comment = comment.trim();\n+    if comment.is_empty() {\n+        Some(String::new())\n+    } else {\n+        rewrite_comment(comment, false, shape, context.config)\n+    }\n+}\n+\n+fn rewrite_comments_before_after_where(\n+    context: &RewriteContext,\n+    span_before_where: Span,\n+    span_after_where: Span,\n+    shape: Shape,\n+) -> Option<(String, String)> {\n+    let before_comment = try_opt!(rewrite_missing_comment_in_where(\n+        context,\n+        &context.snippet(span_before_where),\n+        shape,\n+    ));\n+    let after_comment = try_opt!(rewrite_missing_comment_in_where(\n+        context,\n+        &context.snippet(span_after_where),\n+        shape.block_indent(context.config.tab_spaces()),\n+    ));\n+    Some((before_comment, after_comment))\n+}\n+\n fn format_header(item_name: &str, ident: ast::Ident, vis: &ast::Visibility) -> String {\n     format!(\"{}{}{}\", format_visibility(vis), item_name, ident)\n }\n@@ -2681,6 +2764,8 @@ fn format_generics(\n             false,\n             trimmed_last_line_width(&result) == 1,\n             Some(span.hi),\n+            span,\n+            generics.span.hi,\n         ));\n         result.push_str(&where_clause_str);\n         let same_line_brace = force_same_line_brace ||"}, {"sha": "3668e9cd30c0a6c5703d7990555f01ff657bc755", "filename": "src/lib.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/65790f2b2a1682ecce330587a2922d51d604c0b1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65790f2b2a1682ecce330587a2922d51d604c0b1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=65790f2b2a1682ecce330587a2922d51d604c0b1", "patch": "@@ -136,6 +136,53 @@ impl Spanned for ast::Field {\n     }\n }\n \n+impl Spanned for ast::WherePredicate {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::WherePredicate::BoundPredicate(ref p) => p.span,\n+            ast::WherePredicate::RegionPredicate(ref p) => p.span,\n+            ast::WherePredicate::EqPredicate(ref p) => p.span,\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::FunctionRetTy {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::FunctionRetTy::Default(span) => span,\n+            ast::FunctionRetTy::Ty(ref ty) => ty.span,\n+        }\n+    }\n+}\n+\n+impl Spanned for ast::TyParam {\n+    fn span(&self) -> Span {\n+        // Note that ty.span is the span for ty.ident, not the whole item.\n+        let lo = if self.attrs.is_empty() {\n+            self.span.lo\n+        } else {\n+            self.attrs[0].span.lo\n+        };\n+        if let Some(ref def) = self.default {\n+            return mk_sp(lo, def.span.hi);\n+        }\n+        if self.bounds.is_empty() {\n+            return mk_sp(lo, self.span.hi);\n+        }\n+        let hi = self.bounds[self.bounds.len() - 1].span().hi;\n+        mk_sp(lo, hi)\n+    }\n+}\n+\n+impl Spanned for ast::TyParamBound {\n+    fn span(&self) -> Span {\n+        match *self {\n+            ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span,\n+            ast::TyParamBound::RegionTyParamBound(ref l) => l.span,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct Indent {\n     // Width of the block indent, in characters. Must be a multiple of"}, {"sha": "39af3fd064e984b991b39ea5885fa9fac88eb67f", "filename": "tests/target/comments-fn.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/65790f2b2a1682ecce330587a2922d51d604c0b1/tests%2Ftarget%2Fcomments-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65790f2b2a1682ecce330587a2922d51d604c0b1/tests%2Ftarget%2Fcomments-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomments-fn.rs?ref=65790f2b2a1682ecce330587a2922d51d604c0b1", "patch": "@@ -27,3 +27,13 @@ where\n     T: Eq, // some comment\n {\n }\n+\n+fn issue458<F>(a: &str, f: F)\n+// comment1\n+where\n+    // comment2\n+    F: FnOnce(&str) -> bool,\n+{\n+    f(a);\n+    ()\n+}"}, {"sha": "ef8895580bd187f92fe2aa85d38ef8b42f732f8d", "filename": "tests/target/impl.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/65790f2b2a1682ecce330587a2922d51d604c0b1/tests%2Ftarget%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65790f2b2a1682ecce330587a2922d51d604c0b1/tests%2Ftarget%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpl.rs?ref=65790f2b2a1682ecce330587a2922d51d604c0b1", "patch": "@@ -17,3 +17,12 @@ where\n         }\n     }\n }\n+\n+impl<T> Foo for T\n+// comment1\n+where\n+    // comment2\n+    // blah\n+    T: Clone,\n+{\n+}"}]}