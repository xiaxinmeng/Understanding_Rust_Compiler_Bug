{"sha": "6487422b3e0b93645e004c66c32fad5a7ab58b80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ODc0MjJiM2UwYjkzNjQ1ZTAwNGM2NmMzMmZhZDVhN2FiNThiODA=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-07-15T11:58:54Z"}, "committer": {"name": "Seiichi Uchida", "email": "seiichi.uchida@dena.com", "date": "2019-07-15T11:58:54Z"}, "message": "fix print-config minimal option (#3687)", "tree": {"sha": "9e7a1174dbdb8ce68d3a25471b498a3a44c80a9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e7a1174dbdb8ce68d3a25471b498a3a44c80a9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6487422b3e0b93645e004c66c32fad5a7ab58b80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6487422b3e0b93645e004c66c32fad5a7ab58b80", "html_url": "https://github.com/rust-lang/rust/commit/6487422b3e0b93645e004c66c32fad5a7ab58b80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6487422b3e0b93645e004c66c32fad5a7ab58b80/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e6896b22951c606b2b78640bb1e3a3ccbb86efe", "html_url": "https://github.com/rust-lang/rust/commit/0e6896b22951c606b2b78640bb1e3a3ccbb86efe"}], "stats": {"total": 186, "additions": 141, "deletions": 45}, "files": [{"sha": "813504cdd6d0242a8fee30dd91941ce8e8a5b345", "filename": "src/bin/main.rs", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6487422b3e0b93645e004c66c32fad5a7ab58b80/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6487422b3e0b93645e004c66c32fad5a7ab58b80/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=6487422b3e0b93645e004c66c32fad5a7ab58b80", "patch": "@@ -1,6 +1,6 @@\n use env_logger;\n-#[macro_use]\n-extern crate failure;\n+use failure::{err_msg, format_err, Error as FailureError, Fail};\n+use io::Error as IoError;\n \n use rustfmt_nightly as rustfmt;\n \n@@ -10,12 +10,10 @@ use std::io::{self, stdout, Read, Write};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n-use failure::err_msg;\n-\n use getopts::{Matches, Options};\n \n use crate::rustfmt::{\n-    load_config, CliOptions, Color, Config, Edition, EmitMode, ErrorKind, FileLines, FileName,\n+    load_config, CliOptions, Color, Config, Edition, EmitMode, FileLines, FileName,\n     FormatReportFormatterBuilder, Input, Session, Verbosity,\n };\n \n@@ -49,20 +47,37 @@ enum Operation {\n     },\n     /// Print the help message.\n     Help(HelpOp),\n-    // Print version information\n+    /// Print version information\n     Version,\n     /// Output default config to a file, or stdout if None\n-    ConfigOutputDefault {\n-        path: Option<String>,\n-    },\n+    ConfigOutputDefault { path: Option<String> },\n     /// Output current config (as if formatting to a file) to stdout\n-    ConfigOutputCurrent {\n-        path: Option<String>,\n-    },\n+    ConfigOutputCurrent { path: Option<String> },\n     /// No file specified, read from stdin\n-    Stdin {\n-        input: String,\n-    },\n+    Stdin { input: String },\n+}\n+\n+/// Rustfmt operations errors.\n+#[derive(Fail, Debug)]\n+pub enum OperationError {\n+    /// An unknown help topic was requested.\n+    #[fail(display = \"Unknown help topic: `{}`.\", _0)]\n+    UnknownHelpTopic(String),\n+    /// An unknown print-config option was requested.\n+    #[fail(display = \"Unknown print-config option: `{}`.\", _0)]\n+    UnknownPrintConfigTopic(String),\n+    /// Attempt to generate a minimal config from standard input.\n+    #[fail(display = \"The `--print-config=minimal` option doesn't work with standard input.\")]\n+    MinimalPathWithStdin,\n+    /// An io error during reading or writing.\n+    #[fail(display = \"io error: {}\", _0)]\n+    IoError(IoError),\n+}\n+\n+impl From<IoError> for OperationError {\n+    fn from(e: IoError) -> OperationError {\n+        OperationError::IoError(e)\n+    }\n }\n \n /// Arguments to `--help`\n@@ -156,7 +171,7 @@ fn is_nightly() -> bool {\n }\n \n // Returned i32 is an exit code\n-fn execute(opts: &Options) -> Result<i32, failure::Error> {\n+fn execute(opts: &Options) -> Result<i32, FailureError> {\n     let matches = opts.parse(env::args().skip(1))?;\n     let options = GetOptsOptions::from_matches(&matches)?;\n \n@@ -210,7 +225,7 @@ fn execute(opts: &Options) -> Result<i32, failure::Error> {\n     }\n }\n \n-fn format_string(input: String, options: GetOptsOptions) -> Result<i32, failure::Error> {\n+fn format_string(input: String, options: GetOptsOptions) -> Result<i32, FailureError> {\n     // try to read config from local directory\n     let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n \n@@ -243,7 +258,7 @@ fn format(\n     files: Vec<PathBuf>,\n     minimal_config_path: Option<String>,\n     options: &GetOptsOptions,\n-) -> Result<i32, failure::Error> {\n+) -> Result<i32, FailureError> {\n     options.verify_file_lines(&files);\n     let (config, config_path) = load_config(None, Some(options.clone()))?;\n \n@@ -385,7 +400,7 @@ fn print_version() {\n     println!(\"rustfmt {}\", version_info);\n }\n \n-fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n+fn determine_operation(matches: &Matches) -> Result<Operation, OperationError> {\n     if matches.opt_present(\"h\") {\n         let topic = matches.opt_str(\"h\");\n         if topic == None {\n@@ -395,22 +410,25 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n         } else if topic == Some(\"file-lines\".to_owned()) {\n             return Ok(Operation::Help(HelpOp::FileLines));\n         } else {\n-            println!(\"Unknown help topic: `{}`\\n\", topic.unwrap());\n-            return Ok(Operation::Help(HelpOp::None));\n+            return Err(OperationError::UnknownHelpTopic(topic.unwrap()));\n         }\n     }\n+    let mut free_matches = matches.free.iter();\n \n     let mut minimal_config_path = None;\n-    if let Some(ref kind) = matches.opt_str(\"print-config\") {\n-        let path = matches.free.get(0).cloned();\n-        if kind == \"default\" {\n-            return Ok(Operation::ConfigOutputDefault { path });\n-        } else if kind == \"current\" {\n-            return Ok(Operation::ConfigOutputCurrent { path });\n-        } else if kind == \"minimal\" {\n-            minimal_config_path = path;\n-            if minimal_config_path.is_none() {\n-                println!(\"WARNING: PATH required for `--print-config minimal`\");\n+    if let Some(kind) = matches.opt_str(\"print-config\") {\n+        let path = free_matches.next().cloned();\n+        match kind.as_str() {\n+            \"default\" => return Ok(Operation::ConfigOutputDefault { path }),\n+            \"current\" => return Ok(Operation::ConfigOutputCurrent { path }),\n+            \"minimal\" => {\n+                minimal_config_path = path;\n+                if minimal_config_path.is_none() {\n+                    eprintln!(\"WARNING: PATH required for `--print-config minimal`.\");\n+                }\n+            }\n+            _ => {\n+                return Err(OperationError::UnknownPrintConfigTopic(kind));\n             }\n         }\n     }\n@@ -419,17 +437,7 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n         return Ok(Operation::Version);\n     }\n \n-    // if no file argument is supplied, read from stdin\n-    if matches.free.is_empty() {\n-        let mut buffer = String::new();\n-        io::stdin().read_to_string(&mut buffer)?;\n-\n-        return Ok(Operation::Stdin { input: buffer });\n-    }\n-\n-    let files: Vec<_> = matches\n-        .free\n-        .iter()\n+    let files: Vec<_> = free_matches\n         .map(|s| {\n             let p = PathBuf::from(s);\n             // we will do comparison later, so here tries to canonicalize first\n@@ -438,6 +446,17 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n         })\n         .collect();\n \n+    // if no file argument is supplied, read from stdin\n+    if files.is_empty() {\n+        if minimal_config_path.is_some() {\n+            return Err(OperationError::MinimalPathWithStdin);\n+        }\n+        let mut buffer = String::new();\n+        io::stdin().read_to_string(&mut buffer)?;\n+\n+        return Ok(Operation::Stdin { input: buffer });\n+    }\n+\n     Ok(Operation::Format {\n         files,\n         minimal_config_path,\n@@ -464,7 +483,7 @@ struct GetOptsOptions {\n }\n \n impl GetOptsOptions {\n-    pub fn from_matches(matches: &Matches) -> Result<GetOptsOptions, failure::Error> {\n+    pub fn from_matches(matches: &Matches) -> Result<GetOptsOptions, FailureError> {\n         let mut options = GetOptsOptions::default();\n         options.verbose = matches.opt_present(\"verbose\");\n         options.quiet = matches.opt_present(\"quiet\");\n@@ -598,15 +617,15 @@ impl CliOptions for GetOptsOptions {\n     }\n }\n \n-fn edition_from_edition_str(edition_str: &str) -> Result<Edition, failure::Error> {\n+fn edition_from_edition_str(edition_str: &str) -> Result<Edition, FailureError> {\n     match edition_str {\n         \"2015\" => Ok(Edition::Edition2015),\n         \"2018\" => Ok(Edition::Edition2018),\n         _ => Err(format_err!(\"Invalid value for `--edition`\")),\n     }\n }\n \n-fn emit_mode_from_emit_str(emit_str: &str) -> Result<EmitMode, failure::Error> {\n+fn emit_mode_from_emit_str(emit_str: &str) -> Result<EmitMode, FailureError> {\n     match emit_str {\n         \"files\" => Ok(EmitMode::Files),\n         \"stdout\" => Ok(EmitMode::Stdout),"}, {"sha": "51f311cd08d8378f9d9782c98f0c3c4365cbf5a3", "filename": "tests/rustfmt/main.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6487422b3e0b93645e004c66c32fad5a7ab58b80/tests%2Frustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6487422b3e0b93645e004c66c32fad5a7ab58b80/tests%2Frustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustfmt%2Fmain.rs?ref=6487422b3e0b93645e004c66c32fad5a7ab58b80", "patch": "@@ -0,0 +1,77 @@\n+//! Integration tests for rustfmt.\n+\n+use std::env;\n+use std::fs::remove_file;\n+use std::path::Path;\n+use std::process::Command;\n+\n+/// Run the rustfmt executable and return its output.\n+fn rustfmt(args: &[&str]) -> (String, String) {\n+    let mut bin_dir = env::current_exe().unwrap();\n+    bin_dir.pop(); // chop off test exe name\n+    if bin_dir.ends_with(\"deps\") {\n+        bin_dir.pop();\n+    }\n+    let cmd = bin_dir.join(format!(\"rustfmt{}\", env::consts::EXE_SUFFIX));\n+\n+    // Ensure the rustfmt binary runs from the local target dir.\n+    let path = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n+    paths.insert(0, bin_dir);\n+    let new_path = env::join_paths(paths).unwrap();\n+\n+    match Command::new(&cmd).args(args).env(\"PATH\", new_path).output() {\n+        Ok(output) => (\n+            String::from_utf8(output.stdout).expect(\"utf-8\"),\n+            String::from_utf8(output.stderr).expect(\"utf-8\"),\n+        ),\n+        Err(e) => panic!(\"failed to run `{:?} {:?}`: {}\", cmd, args, e),\n+    }\n+}\n+\n+macro_rules! assert_that {\n+    ($args:expr, $check:ident $check_args:tt) => {\n+        let (stdout, stderr) = rustfmt($args);\n+        if !stdout.$check$check_args && !stderr.$check$check_args {\n+            panic!(\n+                \"Output not expected for rustfmt {:?}\\n\\\n+                 expected: {}{}\\n\\\n+                 actual stdout:\\n{}\\n\\\n+                 actual stderr:\\n{}\",\n+                $args,\n+                stringify!($check),\n+                stringify!($check_args),\n+                stdout,\n+                stderr\n+            );\n+        }\n+    };\n+}\n+\n+#[test]\n+fn print_config() {\n+    assert_that!(\n+        &[\"--print-config\", \"unknown\"],\n+        starts_with(\"Unknown print-config option\")\n+    );\n+    assert_that!(&[\"--print-config\", \"default\"], contains(\"max_width = 100\"));\n+    assert_that!(&[\"--print-config\", \"minimal\"], contains(\"PATH required\"));\n+    assert_that!(\n+        &[\"--print-config\", \"minimal\", \"minimal-config\"],\n+        contains(\"doesn't work with standard input.\")\n+    );\n+\n+    let (stdout, stderr) = rustfmt(&[\n+        \"--print-config\",\n+        \"minimal\",\n+        \"minimal-config\",\n+        \"src/shape.rs\",\n+    ]);\n+    assert!(\n+        Path::new(\"minimal-config\").exists(),\n+        \"stdout:\\n{}\\nstderr:\\n{}\",\n+        stdout,\n+        stderr\n+    );\n+    remove_file(\"minimal-config\").unwrap();\n+}"}]}