{"sha": "f0c74f85f363a8081b31f9ab696463717ce312d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYzc0Zjg1ZjM2M2E4MDgxYjMxZjlhYjY5NjQ2MzcxN2NlMzEyZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-05T17:52:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-05T17:52:21Z"}, "message": "Auto merge of #23026 - nikomatsakis:issue-20220-supertrait, r=nikomatsakis\n\nThe main gist of this PR is commit 1077efb which removes the list of supertraits from the `TraitDef` and pulls them into a separate table, which is accessed via `lookup_super_predicates`. This is analogous to `lookup_predicates`, which gets the complete where clause. This allows us to create the `TraitDef`, which contains the list generics and so forth, without fully knowing the list of supertraits. This in turn allows the *supertrait listing* to contain references to associated types like `<Self as Foo>::Item`, which were previously impossible because conversion required having the `TraitDef` for `Foo`.\r\n\r\nWe do not yet support `Self::Item` in a supertrait listing. This doesn't work because to convert that, it attempts to expand out the full set of supertraits, which are in the process of being created. This could potentially be worked out by having the expansion of supertraits proceed in a lazy fashion, but we'd have to define shadowing rules for associated types which we don't currently have.\r\n\r\nAlong the way (in 9de9ec5) I also removed the restriction against duplicate bounds and generalized the code so that it can handle having the same supertrait multiple times with different arguments, e.g. `Foo : Bar<i32> + Bar<u32>`. This restriction was serving no particular purpose, since the same trait could be extended multiple times indirectly, and in the era of multidispatch it is actively harmful.\r\n\r\nThis is technically a [breaking-change] because it affects the definition of a super-trait. Anything in a where clause that looks like `where Self : Foo` is now considered a supertrait. Because cycles are disallowed in supertraits, that could lead to some errors. This has not been observed in any existing code.\r\n\r\nr? @nrc", "tree": {"sha": "3d76755c2e0635aaf67fbf0da824d05bb1db9499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d76755c2e0635aaf67fbf0da824d05bb1db9499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0c74f85f363a8081b31f9ab696463717ce312d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0c74f85f363a8081b31f9ab696463717ce312d5", "html_url": "https://github.com/rust-lang/rust/commit/f0c74f85f363a8081b31f9ab696463717ce312d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0c74f85f363a8081b31f9ab696463717ce312d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68740b405404a3f885e388c8d31722797d519c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/68740b405404a3f885e388c8d31722797d519c30", "html_url": "https://github.com/rust-lang/rust/commit/68740b405404a3f885e388c8d31722797d519c30"}, {"sha": "9b332ff2c71480bc9350bb9dd43e0af00d04e1a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b332ff2c71480bc9350bb9dd43e0af00d04e1a1", "html_url": "https://github.com/rust-lang/rust/commit/9b332ff2c71480bc9350bb9dd43e0af00d04e1a1"}], "stats": {"total": 1397, "additions": 822, "deletions": 575}, "files": [{"sha": "b28106a72e048603411146eb5baef7c07ddc8fb0", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -84,7 +84,6 @@ pub const tag_mod_impl: uint = 0x38;\n pub const tag_item_trait_item: uint = 0x39;\n \n pub const tag_item_trait_ref: uint = 0x3a;\n-pub const tag_item_super_trait_ref: uint = 0x3b;\n \n // discriminator value for variants\n pub const tag_disr_val: uint = 0x3c;\n@@ -221,8 +220,6 @@ pub const tag_struct_field_id: uint = 0x8b;\n \n pub const tag_attribute_is_sugared_doc: uint = 0x8c;\n \n-pub const tag_trait_def_bounds: uint = 0x8d;\n-\n pub const tag_items_data_region: uint = 0x8e;\n \n pub const tag_region_param_def: uint = 0x8f;\n@@ -255,3 +252,5 @@ pub const tag_paren_sugar: uint = 0xa0;\n \n pub const tag_codemap: uint = 0xa1;\n pub const tag_codemap_filemap: uint = 0xa2;\n+\n+pub const tag_item_super_predicates: uint = 0xa3;"}, {"sha": "c7785ff4c8772dde596ff9a2853b730a114d7e1f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -175,14 +175,6 @@ pub fn get_provided_trait_methods<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                             def: ast::DefId)\n-                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_supertraits(&*cdata, def.node, tcx)\n-}\n-\n pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n                           -> Option<ast::Name> {\n     let cdata = cstore.get_crate_data(def.krate);\n@@ -238,6 +230,14 @@ pub fn get_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n     decoder::get_predicates(&*cdata, def.node, tcx)\n }\n \n+pub fn get_super_predicates<'tcx>(tcx: &ty::ctxt<'tcx>, def: ast::DefId)\n+                                  -> ty::GenericPredicates<'tcx>\n+{\n+    let cstore = &tcx.sess.cstore;\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::get_super_predicates(&*cdata, def.node, tcx)\n+}\n+\n pub fn get_field_type<'tcx>(tcx: &ty::ctxt<'tcx>, class_id: ast::DefId,\n                             def: ast::DefId) -> ty::TypeScheme<'tcx> {\n     let cstore = &tcx.sess.cstore;"}, {"sha": "f5f9bd41c8b8e4274d2cc410b2075cce0df04e23", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -22,9 +22,8 @@ use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n-                         parse_type_param_def_data, parse_bounds_data,\n-                         parse_bare_fn_ty_data, parse_trait_ref_data,\n-                         parse_predicate_data};\n+                         parse_type_param_def_data, parse_bare_fn_ty_data,\n+                         parse_trait_ref_data, parse_predicate_data};\n use middle::def;\n use middle::lang_items;\n use middle::subst;\n@@ -260,18 +259,6 @@ fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn doc_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                    -> ty::ParamBounds<'tcx> {\n-    parse_bounds_data(doc.data, cdata.cnum, doc.start, tcx,\n-                      |_, did| translate_def_id(cdata, did))\n-}\n-\n-fn trait_def_bounds<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n-                          -> ty::ParamBounds<'tcx> {\n-    let d = reader::get_doc(doc, tag_trait_def_bounds);\n-    doc_bounds(d, tcx, cdata)\n-}\n-\n fn enum_variant_ids(item: rbml::Doc, cdata: Cmd) -> Vec<ast::DefId> {\n     let mut ids: Vec<ast::DefId> = Vec::new();\n     let v = tag_items_data_item_variant;\n@@ -406,7 +393,6 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n {\n     let item_doc = lookup_item(item_id, cdata.data());\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n-    let bounds = trait_def_bounds(item_doc, tcx, cdata);\n     let unsafety = parse_unsafety(item_doc);\n     let associated_type_names = parse_associated_type_names(item_doc);\n     let paren_sugar = parse_paren_sugar(item_doc);\n@@ -415,7 +401,6 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: generics,\n-        bounds: bounds,\n         trait_ref: item_trait_ref(item_doc, tcx, cdata),\n         associated_type_names: associated_type_names,\n     }\n@@ -430,6 +415,15 @@ pub fn get_predicates<'tcx>(cdata: Cmd,\n     doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n }\n \n+pub fn get_super_predicates<'tcx>(cdata: Cmd,\n+                                  item_id: ast::NodeId,\n+                                  tcx: &ty::ctxt<'tcx>)\n+                                  -> ty::GenericPredicates<'tcx>\n+{\n+    let item_doc = lookup_item(item_id, cdata.data());\n+    doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n+}\n+\n pub fn get_type<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n                       -> ty::TypeScheme<'tcx>\n {\n@@ -971,24 +965,6 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     return result;\n }\n \n-/// Returns the supertraits of the given trait.\n-pub fn get_supertraits<'tcx>(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt<'tcx>)\n-                             -> Vec<Rc<ty::TraitRef<'tcx>>> {\n-    let mut results = Vec::new();\n-    let item_doc = lookup_item(id, cdata.data());\n-    reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n-        // NB. Only reads the ones that *aren't* builtin-bounds. See also\n-        // get_trait_def() for collecting the builtin bounds.\n-        // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n-        let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n-        if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n-            results.push(trait_ref);\n-        }\n-        true\n-    });\n-    return results;\n-}\n-\n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Name> {\n     let item = lookup_item(node_id, cdata.data());"}, {"sha": "c4ba2373b9f570cb624d9fe4ed43e40e9045af81", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -206,21 +206,6 @@ pub fn write_region(ecx: &EncodeContext,\n     tyencode::enc_region(rbml_w, ty_str_ctxt, r);\n }\n \n-fn encode_bounds<'a, 'tcx>(rbml_w: &mut Encoder,\n-                           ecx: &EncodeContext<'a, 'tcx>,\n-                           bounds: &ty::ParamBounds<'tcx>,\n-                           tag: uint) {\n-    rbml_w.start_tag(tag);\n-\n-    let ty_str_ctxt = &tyencode::ctxt { diag: ecx.diag,\n-                                        ds: def_to_string,\n-                                        tcx: ecx.tcx,\n-                                        abbrevs: &ecx.type_abbrevs };\n-    tyencode::enc_bounds(rbml_w, ty_str_ctxt, bounds);\n-\n-    rbml_w.end_tag();\n-}\n-\n fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                          rbml_w: &mut Encoder,\n                          typ: Ty<'tcx>) {\n@@ -728,6 +713,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         tcx: ecx.tcx,\n         abbrevs: &ecx.type_abbrevs\n     };\n+\n     for param in generics.types.iter() {\n         rbml_w.start_tag(tag_type_param_def);\n         tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n@@ -758,6 +744,22 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n+    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n+                                             ecx: &EncodeContext<'a,'tcx>,\n+                                             predicates: &ty::GenericPredicates<'tcx>)\n+{\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n         rbml_w.start_tag(tag_predicate);\n \n@@ -769,7 +771,15 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n \n         rbml_w.end_tag();\n     }\n+}\n \n+fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n+                              ecx: &EncodeContext<'a,'tcx>,\n+                              predicates: &ty::GenericPredicates<'tcx>,\n+                              tag: uint)\n+{\n+    rbml_w.start_tag(tag);\n+    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n     rbml_w.end_tag();\n }\n \n@@ -1280,6 +1290,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n+        encode_predicates(rbml_w, ecx, &ty::lookup_super_predicates(tcx, def_id),\n+                          tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -1304,8 +1316,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_path(rbml_w, path.clone());\n \n-        encode_bounds(rbml_w, ecx, &trait_def.bounds, tag_trait_def_bounds);\n-\n         // Encode the implementations of this trait.\n         encode_extension_implementations(ecx, rbml_w, def_id);\n "}, {"sha": "f46cac308287ba769d34378ddc19421d5aee3233", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -280,7 +280,11 @@ pub struct VtableBuiltinData<N> {\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n pub struct VtableObjectData<'tcx> {\n+    /// the object type `Foo`.\n     pub object_ty: Ty<'tcx>,\n+\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n }\n \n /// Creates predicate obligations from the generic bounds."}, {"sha": "881487a2dad1150b6e9423075c14fbfb042258db", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -22,7 +22,7 @@ use super::elaborate_predicates;\n \n use middle::subst::{self, SelfSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, ToPolyTraitRef, Ty};\n use std::rc::Rc;\n use syntax::ast;\n use util::ppaux::Repr;\n@@ -128,9 +128,12 @@ fn supertraits_reference_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n     let trait_ref = trait_def.trait_ref.clone();\n-    let predicates = ty::predicates_for_trait_ref(tcx, &ty::Binder(trait_ref));\n+    let trait_ref = trait_ref.to_poly_trait_ref();\n+    let predicates = ty::lookup_super_predicates(tcx, trait_def_id);\n     predicates\n+        .predicates\n         .into_iter()\n+        .map(|predicate| predicate.subst_supertrait(tcx, &trait_ref))\n         .any(|predicate| {\n             match predicate {\n                 ty::Predicate::Trait(ref data) => {"}, {"sha": "e57c16b5a0fb8ef4afea6de7c86f5770c1179582", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -1260,19 +1260,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                poly_trait_ref.repr(self.tcx()));\n \n         // see whether the object trait can be upcast to the trait we are looking for\n-        let obligation_def_id = obligation.predicate.def_id();\n-        let upcast_trait_ref = match util::upcast(self.tcx(), poly_trait_ref, obligation_def_id) {\n-            Some(r) => r,\n-            None => { return; }\n-        };\n-\n-        debug!(\"assemble_candidates_from_object_ty: upcast_trait_ref={}\",\n-               upcast_trait_ref.repr(self.tcx()));\n-\n-        // check whether the upcast version of the trait-ref matches what we are looking for\n-        if let Ok(()) = self.infcx.probe(|_| self.match_poly_trait_ref(obligation,\n-                                                                       upcast_trait_ref.clone())) {\n-            debug!(\"assemble_candidates_from_object_ty: matched, pushing candidate\");\n+        let upcast_trait_refs = self.upcast(poly_trait_ref, obligation);\n+        if upcast_trait_refs.len() > 1 {\n+            // can be upcast in many ways; need more type information\n+            candidates.ambiguous = true;\n+        } else if upcast_trait_refs.len() == 1 {\n             candidates.vec.push(ObjectCandidate);\n         }\n     }\n@@ -1455,9 +1447,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             let principal =\n                                 data.principal_trait_ref_with_self_ty(self.tcx(),\n                                                                       self.tcx().types.err);\n+                            let desired_def_id = obligation.predicate.def_id();\n                             for tr in util::supertraits(self.tcx(), principal) {\n-                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n-                                if td.bounds.builtin_bounds.contains(&bound) {\n+                                if tr.def_id() == desired_def_id {\n                                     return Ok(If(Vec::new()))\n                                 }\n                             }\n@@ -2063,28 +2055,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let obligation_def_id = obligation.predicate.def_id();\n-        let upcast_trait_ref = match util::upcast(self.tcx(),\n-                                                  poly_trait_ref.clone(),\n-                                                  obligation_def_id) {\n-            Some(r) => r,\n-            None => {\n-                self.tcx().sess.span_bug(obligation.cause.span,\n-                                         &format!(\"unable to upcast from {} to {}\",\n-                                                  poly_trait_ref.repr(self.tcx()),\n-                                                  obligation_def_id.repr(self.tcx())));\n-            }\n-        };\n+        // Upcast the object type to the obligation type. There must\n+        // be exactly one applicable trait-reference; if this were not\n+        // the case, we would have reported an ambiguity error rather\n+        // than successfully selecting one of the candidates.\n+        let upcast_trait_refs = self.upcast(poly_trait_ref.clone(), obligation);\n+        assert_eq!(upcast_trait_refs.len(), 1);\n+        let upcast_trait_ref = upcast_trait_refs.into_iter().next().unwrap();\n \n-        match self.match_poly_trait_ref(obligation, upcast_trait_ref) {\n+        match self.match_poly_trait_ref(obligation, upcast_trait_ref.clone()) {\n             Ok(()) => { }\n             Err(()) => {\n                 self.tcx().sess.span_bug(obligation.cause.span,\n                                          \"failed to match trait refs\");\n             }\n         }\n \n-        VtableObjectData { object_ty: self_ty }\n+        VtableObjectData { object_ty: self_ty,\n+                           upcast_trait_ref: upcast_trait_ref }\n     }\n \n     fn confirm_fn_pointer_candidate(&mut self,\n@@ -2501,6 +2489,32 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation.cause.clone()\n         }\n     }\n+\n+    /// Upcasts an object trait-reference into those that match the obligation.\n+    fn upcast(&mut self, obj_trait_ref: ty::PolyTraitRef<'tcx>, obligation: &TraitObligation<'tcx>)\n+              -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        debug!(\"upcast(obj_trait_ref={}, obligation={})\",\n+               obj_trait_ref.repr(self.tcx()),\n+               obligation.repr(self.tcx()));\n+\n+        let obligation_def_id = obligation.predicate.def_id();\n+        let mut upcast_trait_refs = util::upcast(self.tcx(), obj_trait_ref, obligation_def_id);\n+\n+        // Retain only those upcast versions that match the trait-ref\n+        // we are looking for.  In particular, we know that all of\n+        // `upcast_trait_refs` apply to the correct trait, but\n+        // possibly with incorrect type parameters. For example, we\n+        // may be trying to upcast `Foo` to `Bar<i32>`, but `Foo` is\n+        // declared as `trait Foo : Bar<u32>`.\n+        upcast_trait_refs.retain(|upcast_trait_ref| {\n+            let upcast_trait_ref = upcast_trait_ref.clone();\n+            self.infcx.probe(|_| self.match_poly_trait_ref(obligation, upcast_trait_ref)).is_ok()\n+        });\n+\n+        debug!(\"upcast: upcast_trait_refs={}\", upcast_trait_refs.repr(self.tcx()));\n+        upcast_trait_refs\n+    }\n }\n \n impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {"}, {"sha": "4527985302aedaddb31493dae3e51b40e9a2181b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 50, "deletions": 65, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -76,15 +76,10 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n /// 'static`.\n pub struct Elaborator<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n-    stack: Vec<StackEntry<'tcx>>,\n+    stack: Vec<ty::Predicate<'tcx>>,\n     visited: PredicateSet<'cx,'tcx>,\n }\n \n-struct StackEntry<'tcx> {\n-    position: uint,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-}\n-\n pub fn elaborate_trait_ref<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n@@ -111,21 +106,28 @@ pub fn elaborate_predicates<'cx, 'tcx>(\n {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n-    let entry = StackEntry { position: 0, predicates: predicates };\n-    Elaborator { tcx: tcx, stack: vec![entry], visited: visited }\n+    Elaborator { tcx: tcx, stack: predicates, visited: visited }\n }\n \n impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n-    pub fn filter_to_traits(self) -> Supertraits<'cx, 'tcx> {\n-        Supertraits { elaborator: self }\n+    pub fn filter_to_traits(self) -> FilterToTraits<Elaborator<'cx, 'tcx>> {\n+        FilterToTraits::new(self)\n     }\n \n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n-                let mut predicates =\n-                    ty::predicates_for_trait_ref(self.tcx,\n-                                                 &data.to_poly_trait_ref());\n+                // Predicates declared on the trait.\n+                let predicates = ty::lookup_super_predicates(self.tcx, data.def_id());\n+\n+                let mut predicates: Vec<_> =\n+                    predicates.predicates\n+                              .iter()\n+                              .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n+                              .collect();\n+\n+                debug!(\"super_predicates: data={} predicates={}\",\n+                       data.repr(self.tcx), predicates.repr(self.tcx));\n \n                 // Only keep those bounds that we haven't already\n                 // seen.  This is necessary to prevent infinite\n@@ -134,8 +136,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n                 // Sized { }`.\n                 predicates.retain(|r| self.visited.insert(r));\n \n-                self.stack.push(StackEntry { position: 0,\n-                                             predicates: predicates });\n+                self.stack.extend(predicates.into_iter());\n             }\n             ty::Predicate::Equate(..) => {\n                 // Currently, we do not \"elaborate\" predicates like\n@@ -175,53 +176,24 @@ impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n-        loop {\n-            // Extract next item from top-most stack frame, if any.\n-            let next_predicate = match self.stack.last_mut() {\n-                None => {\n-                    // No more stack frames. Done.\n-                    return None;\n-                }\n-                Some(entry) => {\n-                    let p = entry.position;\n-                    if p < entry.predicates.len() {\n-                        // Still more predicates left in the top stack frame.\n-                        entry.position += 1;\n-\n-                        let next_predicate =\n-                            entry.predicates[p].clone();\n-\n-                        Some(next_predicate)\n-                    } else {\n-                        None\n-                    }\n-                }\n-            };\n-\n-            match next_predicate {\n-                Some(next_predicate) => {\n-                    self.push(&next_predicate);\n-                    return Some(next_predicate);\n-                }\n-\n-                None => {\n-                    // Top stack frame is exhausted, pop it.\n-                    self.stack.pop();\n-                }\n+        // Extract next item from top-most stack frame, if any.\n+        let next_predicate = match self.stack.pop() {\n+            Some(predicate) => predicate,\n+            None => {\n+                // No more stack frames. Done.\n+                return None;\n             }\n-        }\n+        };\n+        self.push(&next_predicate);\n+        return Some(next_predicate);\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-/// A filter around the `Elaborator` that just yields up supertrait references,\n-/// not other kinds of predicates.\n-pub struct Supertraits<'cx, 'tcx:'cx> {\n-    elaborator: Elaborator<'cx, 'tcx>,\n-}\n+pub type Supertraits<'cx, 'tcx> = FilterToTraits<Elaborator<'cx, 'tcx>>;\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n@@ -237,12 +209,28 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n-impl<'cx, 'tcx> Iterator for Supertraits<'cx, 'tcx> {\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around an iterator of predicates that makes it yield up\n+/// just trait references.\n+pub struct FilterToTraits<I> {\n+    base_iterator: I\n+}\n+\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n+    }\n+}\n+\n+impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         loop {\n-            match self.elaborator.next() {\n+            match self.base_iterator.next() {\n                 None => {\n                     return None;\n                 }\n@@ -256,6 +244,7 @@ impl<'cx, 'tcx> Iterator for Supertraits<'cx, 'tcx> {\n     }\n }\n \n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////\n@@ -370,19 +359,15 @@ pub fn predicate_for_builtin_bound<'tcx>(\n pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     source_trait_ref: ty::PolyTraitRef<'tcx>,\n                     target_trait_def_id: ast::DefId)\n-                    -> Option<ty::PolyTraitRef<'tcx>>\n+                    -> Vec<ty::PolyTraitRef<'tcx>>\n {\n     if source_trait_ref.def_id() == target_trait_def_id {\n-        return Some(source_trait_ref); // shorcut the most common case\n-    }\n-\n-    for super_trait_ref in supertraits(tcx, source_trait_ref) {\n-        if super_trait_ref.def_id() == target_trait_def_id {\n-            return Some(super_trait_ref);\n-        }\n+        return vec![source_trait_ref]; // shorcut the most common case\n     }\n \n-    None\n+    supertraits(tcx, source_trait_ref)\n+        .filter(|r| r.def_id() == target_trait_def_id)\n+        .collect()\n }\n \n /// Given an object of type `object_trait_ref`, returns the index of"}, {"sha": "add829074c4f0dcc6689d055e87f179580a348aa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 137, "deletions": 123, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -17,7 +17,6 @@ pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::ClosureKind::*;\n-pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n pub use self::Representability::*;\n@@ -266,12 +265,6 @@ pub struct creader_cache_key {\n     pub len: uint\n }\n \n-#[derive(Copy)]\n-pub enum ast_ty_to_ty_cache_entry<'tcx> {\n-    atttce_unresolved,  /* not resolved yet */\n-    atttce_resolved(Ty<'tcx>)  /* resolved to a type, irrespective of region */\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -716,6 +709,14 @@ pub struct ctxt<'tcx> {\n     /// associated predicates.\n     pub predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n \n+    /// Maps from the def-id of a trait to the list of\n+    /// super-predicates. This is a subset of the full list of\n+    /// predicates. We store these in a separate map because we must\n+    /// evaluate them even during type conversion, often before the\n+    /// full predicates are available (note that supertraits have\n+    /// additional acyclicity requirements).\n+    pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n+\n     /// Maps from node-id of a trait object cast (like `foo as\n     /// Box<Trait>`) to the trait reference.\n     pub object_cast_map: ObjectCastMap<'tcx>,\n@@ -727,7 +728,7 @@ pub struct ctxt<'tcx> {\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n     pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n-    pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry<'tcx>>>,\n+    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef<'tcx>>>,\n     pub adjustments: RefCell<NodeMap<AutoAdjustment<'tcx>>>,\n@@ -1352,7 +1353,7 @@ pub enum sty<'tcx> {\n     /// definition and not a concrete use of it. To get the correct `ty_enum`\n     /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n     /// the `ast_ty_to_ty_cache`. This is probably true for `ty_struct` as\n-    /// well.`\n+    /// well.\n     ty_enum(DefId, &'tcx Substs<'tcx>),\n     ty_uniq(Ty<'tcx>),\n     ty_str,\n@@ -1495,6 +1496,27 @@ impl<'tcx> PolyTraitRef<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct Binder<T>(pub T);\n \n+impl<T> Binder<T> {\n+    /// Skips the binder and returns the \"bound\" value. This is a\n+    /// risky thing to do because it's easy to get confused about\n+    /// debruijn indices and the like. It is usually better to\n+    /// discharge the binder using `no_late_bound_regions` or\n+    /// `replace_late_bound_regions` or something like\n+    /// that. `skip_binder` is only valid when you are either\n+    /// extracting data that has nothing to do with bound regions, you\n+    /// are doing some sort of test that does not involve bound\n+    /// regions, or you are being very careful about your depth\n+    /// accounting.\n+    ///\n+    /// Some examples where `skip_binder` is reasonable:\n+    /// - extracting the def-id from a PolyTraitRef;\n+    /// - comparing the self type of a PolyTraitRef to see if it is equal to\n+    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    pub fn skip_binder(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n@@ -1817,6 +1839,16 @@ impl<'tcx> GenericPredicates<'tcx> {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n+\n+    pub fn instantiate_supertrait(&self,\n+                                  tcx: &ty::ctxt<'tcx>,\n+                                  poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n+                                  -> InstantiatedPredicates<'tcx>\n+    {\n+        InstantiatedPredicates {\n+            predicates: self.predicates.map(|pred| pred.subst_supertrait(tcx, poly_trait_ref))\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -1840,6 +1872,93 @@ pub enum Predicate<'tcx> {\n     Projection(PolyProjectionPredicate<'tcx>),\n }\n \n+impl<'tcx> Predicate<'tcx> {\n+    /// Performs a substituion suitable for going from a\n+    /// poly-trait-ref to supertraits that must hold if that\n+    /// poly-trait-ref holds. This is slightly different from a normal\n+    /// substitution in terms of what happens with bound regions.  See\n+    /// lengthy comment below for details.\n+    pub fn subst_supertrait(&self,\n+                            tcx: &ty::ctxt<'tcx>,\n+                            trait_ref: &ty::PolyTraitRef<'tcx>)\n+                            -> ty::Predicate<'tcx>\n+    {\n+        // The interaction between HRTB and supertraits is not entirely\n+        // obvious. Let me walk you (and myself) through an example.\n+        //\n+        // Let's start with an easy case. Consider two traits:\n+        //\n+        //     trait Foo<'a> : Bar<'a,'a> { }\n+        //     trait Bar<'b,'c> { }\n+        //\n+        // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n+        // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+        // knew that `Foo<'x>` (for any 'x) then we also know that\n+        // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n+        // normal substitution.\n+        //\n+        // In terms of why this is sound, the idea is that whenever there\n+        // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n+        // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+        // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n+        // `'a`.\n+        //\n+        // Another example to be careful of is this:\n+        //\n+        //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+        //     trait Bar1<'b,'c> { }\n+        //\n+        // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n+        // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+        // reason is similar to the previous example: any impl of\n+        // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+        // basically we would want to collapse the bound lifetimes from\n+        // the input (`trait_ref`) and the supertraits.\n+        //\n+        // To achieve this in practice is fairly straightforward. Let's\n+        // consider the more complicated scenario:\n+        //\n+        // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n+        //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+        //   where both `'x` and `'b` would have a DB index of 1.\n+        //   The substitution from the input trait-ref is therefore going to be\n+        //   `'a => 'x` (where `'x` has a DB index of 1).\n+        // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n+        //   early-bound parameter and `'b' is a late-bound parameter with a\n+        //   DB index of 1.\n+        // - If we replace `'a` with `'x` from the input, it too will have\n+        //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n+        //   just as we wanted.\n+        //\n+        // There is only one catch. If we just apply the substitution `'a\n+        // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n+        // adjust the DB index because we substituting into a binder (it\n+        // tries to be so smart...) resulting in `for<'x> for<'b>\n+        // Bar1<'x,'b>` (we have no syntax for this, so use your\n+        // imagination). Basically the 'x will have DB index of 2 and 'b\n+        // will have DB index of 1. Not quite what we want. So we apply\n+        // the substitution to the *contents* of the trait reference,\n+        // rather than the trait reference itself (put another way, the\n+        // substitution code expects equal binding levels in the values\n+        // from the substitution and the value being substituted into, and\n+        // this trick achieves that).\n+\n+        let substs = &trait_ref.0.substs;\n+        match *self {\n+            Predicate::Trait(ty::Binder(ref data)) =>\n+                Predicate::Trait(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Equate(ty::Binder(ref data)) =>\n+                Predicate::Equate(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::RegionOutlives(ty::Binder(ref data)) =>\n+                Predicate::RegionOutlives(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::TypeOutlives(ty::Binder(ref data)) =>\n+                Predicate::TypeOutlives(ty::Binder(data.subst(tcx, substs))),\n+            Predicate::Projection(ty::Binder(ref data)) =>\n+                Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: Rc<TraitRef<'tcx>>\n@@ -2324,9 +2443,6 @@ pub struct TraitDef<'tcx> {\n     /// implements the trait.\n     pub generics: Generics<'tcx>,\n \n-    /// The \"supertrait\" bounds.\n-    pub bounds: ParamBounds<'tcx>,\n-\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     /// A list of the associated types defined in this trait. Useful\n@@ -2451,6 +2567,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         impl_trait_refs: RefCell::new(NodeMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n+        super_predicates: RefCell::new(DefIdMap()),\n         object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n         intrinsic_defs: RefCell::new(DefIdMap()),\n@@ -5432,7 +5549,7 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given the did of a trait, returns its full set of predicates.\n+/// Given the did of an item, returns its full set of predicates.\n pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                 -> GenericPredicates<'tcx>\n {\n@@ -5442,117 +5559,14 @@ pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n     })\n }\n \n-/// Given a reference to a trait, returns the \"superbounds\" declared\n-/// on the trait, with appropriate substitutions applied. Basically,\n-/// this applies a filter to the where clauses on the trait, returning\n-/// those that have the form:\n-///\n-///     Self : SuperTrait<...>\n-///     Self : 'region\n-pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                      trait_ref: &PolyTraitRef<'tcx>)\n-                                      -> Vec<ty::Predicate<'tcx>>\n+/// Given the did of a trait, returns its superpredicates.\n+pub fn lookup_super_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n+                                     -> GenericPredicates<'tcx>\n {\n-    let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n-\n-    debug!(\"bounds_for_trait_ref(trait_def={:?}, trait_ref={:?})\",\n-           trait_def.repr(tcx), trait_ref.repr(tcx));\n-\n-    // The interaction between HRTB and supertraits is not entirely\n-    // obvious. Let me walk you (and myself) through an example.\n-    //\n-    // Let's start with an easy case. Consider two traits:\n-    //\n-    //     trait Foo<'a> : Bar<'a,'a> { }\n-    //     trait Bar<'b,'c> { }\n-    //\n-    // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n-    // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n-    // knew that `Foo<'x>` (for any 'x) then we also know that\n-    // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n-    // normal substitution.\n-    //\n-    // In terms of why this is sound, the idea is that whenever there\n-    // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n-    // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n-    // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n-    // `'a`.\n-    //\n-    // Another example to be careful of is this:\n-    //\n-    //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n-    //     trait Bar1<'b,'c> { }\n-    //\n-    // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n-    // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n-    // reason is similar to the previous example: any impl of\n-    // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n-    // basically we would want to collapse the bound lifetimes from\n-    // the input (`trait_ref`) and the supertraits.\n-    //\n-    // To achieve this in practice is fairly straightforward. Let's\n-    // consider the more complicated scenario:\n-    //\n-    // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n-    //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n-    //   where both `'x` and `'b` would have a DB index of 1.\n-    //   The substitution from the input trait-ref is therefore going to be\n-    //   `'a => 'x` (where `'x` has a DB index of 1).\n-    // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n-    //   early-bound parameter and `'b' is a late-bound parameter with a\n-    //   DB index of 1.\n-    // - If we replace `'a` with `'x` from the input, it too will have\n-    //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n-    //   just as we wanted.\n-    //\n-    // There is only one catch. If we just apply the substitution `'a\n-    // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n-    // adjust the DB index because we substituting into a binder (it\n-    // tries to be so smart...) resulting in `for<'x> for<'b>\n-    // Bar1<'x,'b>` (we have no syntax for this, so use your\n-    // imagination). Basically the 'x will have DB index of 2 and 'b\n-    // will have DB index of 1. Not quite what we want. So we apply\n-    // the substitution to the *contents* of the trait reference,\n-    // rather than the trait reference itself (put another way, the\n-    // substitution code expects equal binding levels in the values\n-    // from the substitution and the value being substituted into, and\n-    // this trick achieves that).\n-\n-    // Carefully avoid the binder introduced by each trait-ref by\n-    // substituting over the substs, not the trait-refs themselves,\n-    // thus achieving the \"collapse\" described in the big comment\n-    // above.\n-    let trait_bounds: Vec<_> =\n-        trait_def.bounds.trait_bounds\n-        .iter()\n-        .map(|poly_trait_ref| ty::Binder(poly_trait_ref.0.subst(tcx, trait_ref.substs())))\n-        .collect();\n-\n-    let projection_bounds: Vec<_> =\n-        trait_def.bounds.projection_bounds\n-        .iter()\n-        .map(|poly_proj| ty::Binder(poly_proj.0.subst(tcx, trait_ref.substs())))\n-        .collect();\n-\n-    debug!(\"bounds_for_trait_ref: trait_bounds={} projection_bounds={}\",\n-           trait_bounds.repr(tcx),\n-           projection_bounds.repr(tcx));\n-\n-    // The region bounds and builtin bounds do not currently introduce\n-    // binders so we can just substitute in a straightforward way here.\n-    let region_bounds =\n-        trait_def.bounds.region_bounds.subst(tcx, trait_ref.substs());\n-    let builtin_bounds =\n-        trait_def.bounds.builtin_bounds.subst(tcx, trait_ref.substs());\n-\n-    let bounds = ty::ParamBounds {\n-        trait_bounds: trait_bounds,\n-        region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n-        projection_bounds: projection_bounds,\n-    };\n-\n-    predicates(tcx, trait_ref.self_ty(), &bounds)\n+    memoized(&cx.super_predicates, did, |did: DefId| {\n+        assert!(did.krate != ast::LOCAL_CRATE);\n+        csearch::get_super_predicates(cx, did)\n+    })\n }\n \n pub fn predicates<'tcx>("}, {"sha": "f3a7c1ee6a0c8fe673dd306120041a47c8e8798b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -544,7 +544,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableObjectData<'tcx> {\n         traits::VtableObjectData {\n-            object_ty: self.object_ty.fold_with(folder)\n+            object_ty: self.object_ty.fold_with(folder),\n+            upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n         }\n     }\n }"}, {"sha": "8bc842671a0a96da425b7e9257dc81c8a40c2733", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -65,12 +65,21 @@ pub struct Session {\n \n impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n+        if self.opts.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n         self.diagnostic().span_fatal(sp, msg)\n     }\n     pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        if self.opts.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n         self.diagnostic().span_fatal_with_code(sp, msg, code)\n     }\n     pub fn fatal(&self, msg: &str) -> ! {\n+        if self.opts.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {"}, {"sha": "09a122544147704a16436c54460d73e9ef94a341", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -820,9 +820,8 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::TraitDef<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"TraitDef(generics={}, bounds={}, trait_ref={})\",\n+        format!(\"TraitDef(generics={}, trait_ref={})\",\n                 self.generics.repr(tcx),\n-                self.bounds.repr(tcx),\n                 self.trait_ref.repr(tcx))\n     }\n }"}, {"sha": "3682fdb74b74f6103fec44006541169bd4d833f4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -432,8 +432,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n             def::DefTy(..) => {\n                 let tty = match self.cx.tcx.ast_ty_to_ty_cache.borrow().get(&id) {\n-                    Some(&ty::atttce_resolved(t)) => t,\n-                    _ => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n+                    Some(&t) => t,\n+                    None => panic!(\"ast_ty_to_ty_cache was incomplete after typeck!\")\n                 };\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {"}, {"sha": "0c82d681eed15ece14aafa2f71b9022cc224e0d4", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -300,7 +300,10 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   .position(|item| item.def_id() == method_id)\n                                   .unwrap();\n             let (llfn, ty) =\n-                trans_object_shim(ccx, data.object_ty, trait_id, method_offset_in_trait);\n+                trans_object_shim(ccx,\n+                                  data.object_ty,\n+                                  data.upcast_trait_ref.clone(),\n+                                  method_offset_in_trait);\n             immediate_rvalue(llfn, ty)\n         }\n         _ => {\n@@ -386,7 +389,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n-            let (llfn, _) = trans_object_shim(bcx.ccx(), data.object_ty, trait_id, n_method);\n+            let (llfn, _) = trans_object_shim(bcx.ccx(),\n+                                              data.object_ty,\n+                                              data.upcast_trait_ref.clone(),\n+                                              n_method);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableBuiltin(..) |\n@@ -551,16 +557,17 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     object_ty: Ty<'tcx>,\n-    trait_id: ast::DefId,\n+    upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n     method_offset_in_trait: uint)\n     -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n+    let trait_id = upcast_trait_ref.def_id();\n \n-    debug!(\"trans_object_shim(object_ty={}, trait_id={}, method_offset_in_trait={})\",\n+    debug!(\"trans_object_shim(object_ty={}, upcast_trait_ref={}, method_offset_in_trait={})\",\n            object_ty.repr(tcx),\n-           trait_id.repr(tcx),\n+           upcast_trait_ref.repr(tcx),\n            method_offset_in_trait);\n \n     let object_trait_ref =\n@@ -575,7 +582,6 @@ pub fn trans_object_shim<'a, 'tcx>(\n         };\n \n     // Upcast to the trait in question and extract out the substitutions.\n-    let upcast_trait_ref = traits::upcast(ccx.tcx(), object_trait_ref.clone(), trait_id).unwrap();\n     let upcast_trait_ref = ty::erase_late_bound_regions(tcx, &upcast_trait_ref);\n     let object_substs = upcast_trait_ref.substs.clone().erase_regions();\n     debug!(\"trans_object_shim: object_substs={}\", object_substs.repr(tcx));"}, {"sha": "0da2c86066ae9bb7b982e29749a946544979adb7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 39, "deletions": 55, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -59,7 +59,6 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n-use util::nodemap::DefIdMap;\n use util::ppaux::{self, Repr, UserString};\n \n use std::iter::{repeat, AdditiveIterator};\n@@ -73,15 +72,33 @@ use syntax::print::pprust;\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n+    /// Identify the type scheme for an item with a type, like a type\n+    /// alias, fn, or struct. This allows you to figure out the set of\n+    /// type parameters defined on the item.\n     fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n \n+    /// Returns the `TraitDef` for a given trait. This allows you to\n+    /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n                      -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n \n+    /// Ensure that the super-predicates for the trait with the given\n+    /// id are available and also for the transitive set of\n+    /// super-predicates.\n+    fn ensure_super_predicates(&self, span: Span, id: ast::DefId)\n+                               -> Result<(), ErrorReported>;\n+\n+    /// Returns the set of bounds in scope for the type parameter with\n+    /// the given id.\n     fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n+    /// Returns true if the trait with id `trait_def_id` defines an\n+    /// associated type with the name `name`.\n+    fn trait_defines_associated_type_named(&self, trait_def_id: ast::DefId, name: ast::Name)\n+                                           -> bool;\n+\n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n     /// within a fn body.\n@@ -783,7 +800,7 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n     // Simple case: X is defined in the current trait.\n-    if trait_defines_associated_type_named(this, trait_ref.def_id, binding.item_name) {\n+    if this.trait_defines_associated_type_named(trait_ref.def_id, binding.item_name) {\n         return Ok(ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n                 trait_ref: trait_ref,\n@@ -810,9 +827,11 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n                                               tcx.mk_substs(dummy_substs)));\n     }\n \n+    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id));\n+\n     let mut candidates: Vec<ty::PolyTraitRef> =\n         traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n-        .filter(|r| trait_defines_associated_type_named(this, r.def_id(), binding.item_name))\n+        .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n         .collect();\n \n     // If converting for an object type, then remove the dummy-ty from `Self` now.\n@@ -1029,14 +1048,19 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n \n-    // FIXME(#20300) -- search where clauses, not bounds\n-    let bounds =\n-        this.get_type_parameter_bounds(span, ty_param_node_id)\n-            .unwrap_or(Vec::new());\n+    let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n+        Ok(v) => v,\n+        Err(ErrorReported) => { return (tcx.types.err, ty_path_def); }\n+    };\n+\n+    // ensure the super predicates and stop if we encountered an error\n+    if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n+        return (this.tcx().types.err, ty_path_def);\n+    }\n \n     let mut suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n-        .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n+        .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n         .collect();\n \n     if suitable_bounds.len() == 0 {\n@@ -1090,16 +1114,6 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     (ty, def::DefAssociatedTy(trait_did, item_did))\n }\n \n-fn trait_defines_associated_type_named(this: &AstConv,\n-                                       trait_def_id: ast::DefId,\n-                                       assoc_name: ast::Name)\n-                                       -> bool\n-{\n-    let tcx = this.tcx();\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    trait_def.associated_type_names.contains(&assoc_name)\n-}\n-\n fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n                      rscope: &RegionScope,\n                      span: Span,\n@@ -1275,20 +1289,9 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let tcx = this.tcx();\n \n-    let mut ast_ty_to_ty_cache = tcx.ast_ty_to_ty_cache.borrow_mut();\n-    match ast_ty_to_ty_cache.get(&ast_ty.id) {\n-        Some(&ty::atttce_resolved(ty)) => return ty,\n-        Some(&ty::atttce_unresolved) => {\n-            span_err!(tcx.sess, ast_ty.span, E0246,\n-                                \"illegal recursive type; insert an enum \\\n-                                 or struct in the cycle, if this is \\\n-                                 desired\");\n-            return this.tcx().types.err;\n-        }\n-        None => { /* go on */ }\n+    if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+        return ty;\n     }\n-    ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n-    drop(ast_ty_to_ty_cache);\n \n     let typ = match ast_ty.node {\n         ast::TyVec(ref ty) => {\n@@ -1421,7 +1424,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n-    tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, ty::atttce_resolved(typ));\n+    tcx.ast_ty_to_ty_cache.borrow_mut().insert(ast_ty.id, typ);\n     return typ;\n }\n \n@@ -1838,6 +1841,10 @@ fn compute_object_lifetime_bound<'tcx>(\n         return ast_region_to_region(tcx, r);\n     }\n \n+    if let Err(ErrorReported) = this.ensure_super_predicates(span,principal_trait_ref.def_id()) {\n+        return ty::ReStatic;\n+    }\n+\n     // No explicit region bound specified. Therefore, examine trait\n     // bounds and see if we can derive region bounds from those.\n     let derived_region_bounds =\n@@ -1923,34 +1930,11 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     let mut builtin_bounds = ty::empty_builtin_bounds();\n     let mut region_bounds = Vec::new();\n     let mut trait_bounds = Vec::new();\n-    let mut trait_def_ids = DefIdMap();\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n-                        match trait_def_ids.get(&trait_did) {\n-                            // Already seen this trait. We forbid\n-                            // duplicates in the list (for some\n-                            // reason).\n-                            Some(span) => {\n-                                span_err!(\n-                                    tcx.sess, b.trait_ref.path.span, E0127,\n-                                    \"trait `{}` already appears in the \\\n-                                     list of bounds\",\n-                                    b.trait_ref.path.user_string(tcx));\n-                                tcx.sess.span_note(\n-                                    *span,\n-                                    \"previous appearance is here\");\n-\n-                                continue;\n-                            }\n-\n-                            None => { }\n-                        }\n-\n-                        trait_def_ids.insert(trait_did, b.trait_ref.path.span);\n-\n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "6ef6953f707fb2d6ef310eb97df5770cc0ae6ccc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -634,16 +634,21 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n               target_trait_def_id: ast::DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        match traits::upcast(self.tcx(), source_trait_ref.clone(), target_trait_def_id) {\n-            Some(super_trait_ref) => super_trait_ref,\n-            None => {\n-                self.tcx().sess.span_bug(\n-                    self.span,\n-                    &format!(\"cannot upcast `{}` to `{}`\",\n-                             source_trait_ref.repr(self.tcx()),\n-                             target_trait_def_id.repr(self.tcx())));\n-            }\n+        let upcast_trait_refs = traits::upcast(self.tcx(),\n+                                               source_trait_ref.clone(),\n+                                               target_trait_def_id);\n+\n+        // must be exactly one trait ref or we'd get an ambig error etc\n+        if upcast_trait_refs.len() != 1 {\n+            self.tcx().sess.span_bug(\n+                self.span,\n+                &format!(\"cannot uniquely upcast `{}` to `{}`: `{}`\",\n+                         source_trait_ref.repr(self.tcx()),\n+                         target_trait_def_id.repr(self.tcx()),\n+                         upcast_trait_refs.repr(self.tcx())));\n         }\n+\n+        upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T"}, {"sha": "718804d317fb09c6a8169b5562d7fdc888a674d4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -456,13 +456,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n \n         let tcx = self.tcx();\n-        let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            // Already visited this trait, skip it.\n-            if !cache.insert(bound_trait_ref.def_id()) {\n-                continue;\n-            }\n-\n             let (pos, method) = match trait_method(tcx,\n                                                    bound_trait_ref.def_id(),\n                                                    self.method_name) {\n@@ -1269,10 +1263,12 @@ impl<'tcx> Candidate<'tcx> {\n \n     fn to_trait_data(&self) -> Option<(ast::DefId,MethodIndex)> {\n         match self.kind {\n-            InherentImplCandidate(..) |\n-            ObjectCandidate(..) => {\n+            InherentImplCandidate(..) => {\n                 None\n             }\n+            ObjectCandidate(trait_def_id, method_num, _) => {\n+                Some((trait_def_id, method_num))\n+            }\n             ClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }"}, {"sha": "9db98bf00cda85fa5fad708d4927edb1789bd182", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -1218,6 +1218,11 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n \n+    fn ensure_super_predicates(&self, _: Span, _: ast::DefId) -> Result<(), ErrorReported> {\n+        // all super predicates are ensured during collect pass\n+        Ok(())\n+    }\n+\n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.inh.param_env.free_substs)\n     }\n@@ -1248,6 +1253,15 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         Ok(r)\n     }\n \n+    fn trait_defines_associated_type_named(&self,\n+                                           trait_def_id: ast::DefId,\n+                                           assoc_name: ast::Name)\n+                                           -> bool\n+    {\n+        let trait_def = ty::lookup_trait_def(self.ccx.tcx, trait_def_id);\n+        trait_def.associated_type_names.contains(&assoc_name)\n+    }\n+\n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.infcx().next_ty_var()\n     }"}, {"sha": "fcc5eea76062d817c811cd225cb237c172077ca4", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -281,12 +281,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n             let poly_trait_ref = ty::Binder(trait_ref);\n-            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n+            let predicates = ty::lookup_super_predicates(fcx.tcx(), poly_trait_ref.def_id());\n+            let predicates = predicates.instantiate_supertrait(fcx.tcx(), &poly_trait_ref);\n             let predicates = {\n                 let selcx = &mut traits::SelectionContext::new(fcx.infcx(), fcx);\n                 traits::normalize(selcx, cause.clone(), &predicates)\n             };\n-            for predicate in predicates.value {\n+            for predicate in predicates.value.predicates {\n                 fcx.register_predicate(traits::Obligation::new(cause.clone(), predicate));\n             }\n             for obligation in predicates.obligations {"}, {"sha": "12bcf5cf5ada47a2af3d506559ab3e65538ae01d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 261, "deletions": 148, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -26,35 +26,17 @@ represented by an instance of `ty::TypeScheme`.  This combines the\n core type along with a list of the bounds for each parameter. Type\n parameters themselves are represented as `ty_param()` instances.\n \n-The phasing of type conversion is somewhat complicated. There are a\n-number of possible cycles that can arise.\n-\n-Converting types can require:\n-\n-1. `Foo<X>` where `Foo` is a type alias, or trait requires knowing:\n-   - number of region / type parameters\n-   - for type parameters, `T:'a` annotations to control defaults for object lifetimes\n-   - defaults for type parameters (which are themselves types!)\n-2. `Foo<X>` where `Foo` is a type alias requires knowing what `Foo` expands to\n-3. Translating `SomeTrait` with no explicit lifetime bound requires knowing\n-   - supertraits of `SomeTrait`\n-4. Translating `T::X` (vs `<T as Trait>::X`) requires knowing\n-   - bounds on `T`\n-   - supertraits of those bounds\n-\n-So as you can see, in general translating types requires knowing the\n-trait hierarchy. But this gets a bit tricky because translating the\n-trait hierarchy requires converting the types that appear in trait\n-references. One potential saving grace is that in general knowing the\n-trait hierarchy is only necessary for shorthands like `T::X` or\n-handling omitted lifetime bounds on object types. Therefore, if we are\n-lazy about expanding out the trait hierachy, users can sever cycles if\n-necessary. Lazy expansion is also needed for type aliases.\n-\n-This system is not perfect yet. Currently, we \"convert\" types and\n-traits in three phases (note that conversion only affects the types of\n-items / enum variants / methods; it does not e.g. compute the types of\n-individual expressions):\n+The phasing of type conversion is somewhat complicated. There is no\n+clear set of phases we can enforce (e.g., converting traits first,\n+then types, or something like that) because the user can introduce\n+arbitrary interdependencies. So instead we generally convert things\n+lazilly and on demand, and include logic that checks for cycles.\n+Demand is driven by calls to `AstConv::get_item_type_scheme` or\n+`AstConv::lookup_trait_def`.\n+\n+Currently, we \"convert\" types and traits in three phases (note that\n+conversion only affects the types of items / enum variants / methods;\n+it does not e.g. compute the types of individual expressions):\n \n 0. Intrinsics\n 1. Trait definitions\n@@ -64,16 +46,13 @@ Conversion itself is done by simply walking each of the items in turn\n and invoking an appropriate function (e.g., `trait_def_of_item` or\n `convert_item`). However, it is possible that while converting an\n item, we may need to compute the *type scheme* or *trait definition*\n-for other items. This is a kind of shallow conversion that is\n-triggered on demand by calls to `AstConv::get_item_type_scheme` or\n-`AstConv::lookup_trait_def`. It is possible for cycles to result from\n-this (e.g., `type A = B; type B = A;`), in which case astconv\n-(currently) reports the error.\n+for other items.\n \n There are some shortcomings in this design:\n \n-- Cycles through trait definitions (e.g. supertraits) are not currently\n-  detected by astconv. (#12511)\n+- Before walking the set of supertraits for a given trait, you must\n+  call `ensure_super_predicates` on that trait def-id. Otherwise,\n+  `lookup_super_predicates` will result in ICEs.\n - Because the type scheme includes defaults, cycles through type\n   parameter defaults are illegal even if those defaults are never\n   employed. This is not necessarily a bug.\n@@ -169,6 +148,7 @@ struct ItemCtxt<'a,'tcx:'a> {\n enum AstConvRequest {\n     GetItemTypeScheme(ast::DefId),\n     GetTraitDef(ast::DefId),\n+    EnsureSuperPredicates(ast::DefId),\n     GetTypeParameterBounds(ast::NodeId),\n }\n \n@@ -245,7 +225,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                         request: AstConvRequest,\n                         code: F)\n                         -> Result<R,ErrorReported>\n-        where F: FnOnce() -> R\n+        where F: FnOnce() -> Result<R,ErrorReported>\n     {\n         {\n             let mut stack = self.stack.borrow_mut();\n@@ -263,7 +243,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n         let result = code();\n \n         self.stack.borrow_mut().pop();\n-        Ok(result)\n+        result\n     }\n \n     fn report_cycle(&self,\n@@ -284,6 +264,11 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     &format!(\"the cycle begins when processing `{}`...\",\n                              ty::item_path_str(tcx, def_id)));\n             }\n+            AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when computing the supertraits of `{}`...\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n                 tcx.sess.note(\n@@ -301,6 +286,11 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                         &format!(\"...which then requires processing `{}`...\",\n                                  ty::item_path_str(tcx, def_id)));\n                 }\n+                AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires computing the supertraits of `{}`...\",\n+                                 ty::item_path_str(tcx, def_id)));\n+                }\n                 AstConvRequest::GetTypeParameterBounds(id) => {\n                     let def = tcx.type_parameter_def(id);\n                     tcx.sess.note(\n@@ -318,6 +308,12 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                     &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n                              ty::item_path_str(tcx, def_id)));\n             }\n+            AstConvRequest::EnsureSuperPredicates(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires computing the supertraits of `{}`, \\\n+                              completing the cycle.\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n             AstConvRequest::GetTypeParameterBounds(id) => {\n                 let def = tcx.type_parameter_def(id);\n                 tcx.sess.note(\n@@ -327,6 +323,41 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n             }\n         }\n     }\n+\n+    /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n+    fn get_trait_def(&self, trait_id: ast::DefId)\n+                     -> Rc<ty::TraitDef<'tcx>>\n+    {\n+        let tcx = self.tcx;\n+\n+        if trait_id.krate != ast::LOCAL_CRATE {\n+            return ty::lookup_trait_def(tcx, trait_id)\n+        }\n+\n+        let item = match tcx.map.get(trait_id.node) {\n+            ast_map::NodeItem(item) => item,\n+            _ => tcx.sess.bug(&format!(\"get_trait_def({}): not an item\", trait_id.repr(tcx)))\n+        };\n+\n+        trait_def_of_item(self, &*item)\n+    }\n+\n+    /// Ensure that the (transitive) super predicates for\n+    /// `trait_def_id` are available. This will report a cycle error\n+    /// if a trait `X` (transitively) extends itself in some form.\n+    fn ensure_super_predicates(&self, span: Span, trait_def_id: ast::DefId)\n+                               -> Result<(), ErrorReported>\n+    {\n+        self.cycle_check(span, AstConvRequest::EnsureSuperPredicates(trait_def_id), || {\n+            let def_ids = ensure_super_predicates_step(self, trait_def_id);\n+\n+            for def_id in def_ids {\n+                try!(self.ensure_super_predicates(span, def_id));\n+            }\n+\n+            Ok(())\n+        })\n+    }\n }\n \n impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n@@ -342,28 +373,57 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n-            type_scheme_of_def_id(self.ccx, id)\n+            Ok(type_scheme_of_def_id(self.ccx, id))\n         })\n     }\n \n     fn get_trait_def(&self, span: Span, id: ast::DefId)\n                      -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n-            get_trait_def(self.ccx, id)\n+            Ok(self.ccx.get_trait_def(id))\n         })\n     }\n \n+    fn ensure_super_predicates(&self,\n+                               span: Span,\n+                               trait_def_id: ast::DefId)\n+                               -> Result<(), ErrorReported>\n+    {\n+        debug!(\"ensure_super_predicates(trait_def_id={})\",\n+               trait_def_id.repr(self.tcx()));\n+\n+        self.ccx.ensure_super_predicates(span, trait_def_id)\n+    }\n+\n+\n     fn get_type_parameter_bounds(&self,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n-            self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n+            let v = self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n+                                     .into_iter()\n+                                     .filter_map(|p| p.to_opt_poly_trait_ref())\n+                                     .collect();\n+            Ok(v)\n         })\n     }\n \n+    fn trait_defines_associated_type_named(&self,\n+                                           trait_def_id: ast::DefId,\n+                                           assoc_name: ast::Name)\n+                                           -> bool\n+    {\n+        if trait_def_id.krate == ast::LOCAL_CRATE {\n+            trait_defines_associated_type_named(self.ccx, trait_def_id.node, assoc_name)\n+        } else {\n+            let trait_def = ty::lookup_trait_def(self.tcx(), trait_def_id);\n+            trait_def.associated_type_names.contains(&assoc_name)\n+        }\n+    }\n+\n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n@@ -387,7 +447,7 @@ trait GetTypeParameterBounds<'tcx> {\n                                  astconv: &AstConv<'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>;\n+                                 -> Vec<ty::Predicate<'tcx>>;\n }\n \n /// Find bounds from both elements of the tuple.\n@@ -398,7 +458,7 @@ impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n                                  astconv: &AstConv<'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n         v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id).into_iter());\n@@ -412,7 +472,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n                                  _astconv: &AstConv<'tcx>,\n                                  _span: Span,\n                                  _node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         Vec::new()\n     }\n@@ -426,29 +486,28 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n                                  astconv: &AstConv<'tcx>,\n                                  _span: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         let def = astconv.tcx().type_parameter_def(node_id);\n \n         self.predicates\n             .iter()\n-            .filter_map(|predicate| {\n-                match *predicate {\n+            .filter(|predicate| {\n+                match **predicate {\n                     ty::Predicate::Trait(ref data) => {\n-                        if data.0.self_ty().is_param(def.space, def.index) {\n-                            Some(data.to_poly_trait_ref())\n-                        } else {\n-                            None\n-                        }\n+                        data.skip_binder().self_ty().is_param(def.space, def.index)\n+                    }\n+                    ty::Predicate::TypeOutlives(ref data) => {\n+                        data.skip_binder().0.is_param(def.space, def.index)\n                     }\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::RegionOutlives(..) |\n-                    ty::Predicate::TypeOutlives(..) |\n                     ty::Predicate::Projection(..) => {\n-                        None\n+                        false\n                     }\n                 }\n             })\n+            .cloned()\n             .collect()\n     }\n }\n@@ -462,7 +521,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                                  astconv: &AstConv<'tcx>,\n                                  _: Span,\n                                  node_id: ast::NodeId)\n-                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+                                 -> Vec<ty::Predicate<'tcx>>\n     {\n         // In the AST, bounds can derive from two places. Either\n         // written inline like `<T:Foo>` or in a where clause like\n@@ -476,7 +535,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                 .iter()\n                 .filter(|p| p.id == node_id)\n                 .flat_map(|p| p.bounds.iter())\n-                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n \n         let from_where_clauses =\n             self.where_clause\n@@ -488,7 +547,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n                 })\n                 .filter(|bp| is_param(astconv.tcx(), &bp.bounded_ty, node_id))\n                 .flat_map(|bp| bp.bounds.iter())\n-                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+                .flat_map(|b| predicates_from_bound(astconv, ty, b).into_iter());\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n@@ -505,10 +564,15 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n     if let ast::TyPath(None, _) = ast_ty.node {\n         let path_res = tcx.def_map.borrow()[ast_ty.id];\n-        if let def::DefTyParam(_, _, def_id, _) = path_res.base_def {\n-            path_res.depth == 0 && def_id == local_def(param_id)\n-        } else {\n-            false\n+        match path_res.base_def {\n+            def::DefSelfTy(node_id) =>\n+                path_res.depth == 0 && node_id == param_id,\n+\n+            def::DefTyParam(_, _, def_id, _) =>\n+                path_res.depth == 0 && def_id == local_def(param_id),\n+\n+            _ =>\n+                false,\n         }\n     } else {\n         false\n@@ -777,9 +841,10 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n                                  where I: Iterator<Item=&'i ast::Method>\n {\n-    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n+    debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={}, rcvr_ty_predicates={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n-           rcvr_ty_generics.repr(ccx.tcx));\n+           rcvr_ty_generics.repr(ccx.tcx),\n+           rcvr_ty_predicates.repr(ccx.tcx));\n \n     let tcx = ccx.tcx;\n     let mut seen_methods = FnvHashSet();\n@@ -1023,6 +1088,8 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n         },\n         ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n+            let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n+                ccx.ensure_super_predicates(it.span, local_def(it.id));\n             convert_trait_predicates(ccx, it);\n             let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n@@ -1168,22 +1235,89 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                           trait_id: ast::DefId)\n-                           -> Rc<ty::TraitDef<'tcx>> {\n+/// Ensures that the super-predicates of the trait with def-id\n+/// trait_def_id are converted and stored. This does NOT ensure that\n+/// the transitive super-predicates are converted; that is the job of\n+/// the `ensure_super_predicates()` method in the `AstConv` impl\n+/// above. Returns a list of trait def-ids that must be ensured as\n+/// well to guarantee that the transitive superpredicates are\n+/// converted.\n+fn ensure_super_predicates_step(ccx: &CrateCtxt,\n+                                trait_def_id: ast::DefId)\n+                                -> Vec<ast::DefId>\n+{\n     let tcx = ccx.tcx;\n \n-    if trait_id.krate != ast::LOCAL_CRATE {\n-        return ty::lookup_trait_def(tcx, trait_id)\n-    }\n+    debug!(\"ensure_super_predicates_step(trait_def_id={})\", trait_def_id.repr(tcx));\n \n-    match tcx.map.get(trait_id.node) {\n-        ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n-        _ => {\n-            tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                  trait_id.node))\n-        }\n+    if trait_def_id.krate != ast::LOCAL_CRATE {\n+        // If this trait comes from an external crate, then all of the\n+        // supertraits it may depend on also must come from external\n+        // crates, and hence all of them already have their\n+        // super-predicates \"converted\" (and available from crate\n+        // meta-data), so there is no need to transitively test them.\n+        return Vec::new();\n     }\n+\n+    let superpredicates = tcx.super_predicates.borrow().get(&trait_def_id).cloned();\n+    let superpredicates = superpredicates.unwrap_or_else(|| {\n+        let trait_node_id = trait_def_id.node;\n+\n+        let item = match ccx.tcx.map.get(trait_node_id) {\n+            ast_map::NodeItem(item) => item,\n+            _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+        };\n+\n+        let (generics, bounds) = match item.node {\n+            ast::ItemTrait(_, ref generics, ref supertraits, _) => (generics, supertraits),\n+            _ => tcx.sess.span_bug(item.span,\n+                                   \"ensure_super_predicates_step invoked on non-trait\"),\n+        };\n+\n+        // In-scope when converting the superbounds for `Trait` are\n+        // that `Self:Trait` as well as any bounds that appear on the\n+        // generic types:\n+        let trait_def = trait_def_of_item(ccx, item);\n+        let self_predicate = ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(vec![],\n+                                              vec![trait_def.trait_ref.as_predicate()],\n+                                              vec![])\n+        };\n+        let scope = &(generics, &self_predicate);\n+\n+        // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n+        let self_param_ty = ty::mk_self_type(tcx);\n+        let superbounds1 = compute_bounds(&ccx.icx(scope), self_param_ty, bounds,\n+                                          SizedByDefault::No, item.span);\n+        let superbounds1 = ty::predicates(tcx, self_param_ty, &superbounds1);\n+\n+        // Convert any explicit superbounds in the where clause,\n+        // e.g. `trait Foo where Self : Bar`:\n+        let superbounds2 = generics.get_type_parameter_bounds(&ccx.icx(scope), item.span, item.id);\n+\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = superbounds1.into_iter().chain(superbounds2.into_iter()).collect();\n+        let superpredicates = ty::GenericPredicates {\n+            predicates: VecPerParamSpace::new(superbounds, vec![], vec![])\n+        };\n+        debug!(\"superpredicates for trait {} = {}\",\n+               local_def(item.id).repr(ccx.tcx),\n+               superpredicates.repr(ccx.tcx));\n+\n+        tcx.super_predicates.borrow_mut().insert(trait_def_id, superpredicates.clone());\n+\n+        superpredicates\n+    });\n+\n+    let def_ids: Vec<_> = superpredicates.predicates\n+                                         .iter()\n+                                         .filter_map(|p| p.to_opt_poly_trait_ref())\n+                                         .map(|tr| tr.def_id())\n+                                         .collect();\n+\n+    debug!(\"ensure_super_predicates_step: def_ids={}\", def_ids.repr(tcx));\n+\n+    def_ids\n }\n \n fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1197,18 +1331,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return def.clone();\n     }\n \n-    let (unsafety, generics, bounds, items) = match it.node {\n-        ast::ItemTrait(unsafety,\n-                       ref generics,\n-                       ref supertraits,\n-                       ref items) => {\n-            (unsafety, generics, supertraits, items)\n-        }\n-        ref s => {\n-            tcx.sess.span_bug(\n-                it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s));\n-        }\n+    let (unsafety, generics, items) = match it.node {\n+        ast::ItemTrait(unsafety, ref generics, _, ref items) => (unsafety, generics, items),\n+        _ => tcx.sess.span_bug(it.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n     let paren_sugar = ty::has_attr(tcx, def_id, \"rustc_paren_sugar\");\n@@ -1226,15 +1351,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let ty_generics = ty_generics_for_trait(ccx, it.id, substs, generics);\n \n-    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n-\n-    // supertraits:\n-    let bounds = compute_bounds(&ccx.icx(generics),\n-                                self_param_ty,\n-                                bounds,\n-                                SizedByDefault::No,\n-                                it.span);\n-\n     let associated_type_names: Vec<_> =\n         items.iter()\n              .filter_map(|item| {\n@@ -1254,7 +1370,6 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         paren_sugar: paren_sugar,\n         unsafety: unsafety,\n         generics: ty_generics,\n-        bounds: bounds,\n         trait_ref: trait_ref,\n         associated_type_names: associated_type_names,\n     });\n@@ -1296,6 +1411,30 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n+fn trait_defines_associated_type_named(ccx: &CrateCtxt,\n+                                       trait_node_id: ast::NodeId,\n+                                       assoc_name: ast::Name)\n+                                       -> bool\n+{\n+    let item = match ccx.tcx.map.get(trait_node_id) {\n+        ast_map::NodeItem(item) => item,\n+        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not an item\", trait_node_id))\n+    };\n+\n+    let trait_items = match item.node {\n+        ast::ItemTrait(_, _, _, ref trait_items) => trait_items,\n+        _ => ccx.tcx.sess.bug(&format!(\"trait_node_id {} is not a trait\", trait_node_id))\n+    };\n+\n+    trait_items.iter()\n+               .any(|trait_item| {\n+                   match *trait_item {\n+                       ast::TypeTraitItem(ref t) => t.ty_param.ident.name == assoc_name,\n+                       ast::RequiredMethod(..) | ast::ProvidedMethod(..) => false,\n+                   }\n+               })\n+}\n+\n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n@@ -1311,19 +1450,14 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n     };\n \n-    let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n-\n-    let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n+    let super_predicates = ty::lookup_super_predicates(ccx.tcx, def_id);\n \n     // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n     // associated types.\n-    let mut base_predicates =\n-        ty::GenericPredicates {\n-            predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n-        };\n+    let mut base_predicates = super_predicates;\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n@@ -1953,7 +2087,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-enum SizedByDefault { Yes, No }\n+enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n@@ -1975,60 +2109,39 @@ fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n-\n-        check_bounds_compatible(astconv,\n-                                param_ty,\n-                                &param_bounds,\n-                                span);\n     }\n \n     param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n     param_bounds\n }\n \n-fn check_bounds_compatible<'tcx>(astconv: &AstConv<'tcx>,\n-                                 param_ty: Ty<'tcx>,\n-                                 param_bounds: &ty::ParamBounds<'tcx>,\n-                                 span: Span) {\n-    let tcx = astconv.tcx();\n-    if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n-        ty::each_bound_trait_and_supertraits(\n-            tcx,\n-            &param_bounds.trait_bounds,\n-            |trait_ref| {\n-                match astconv.get_trait_def(span, trait_ref.def_id()) {\n-                    Ok(trait_def) => {\n-                        if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                            span_err!(tcx.sess, span, E0129,\n-                                      \"incompatible bounds on `{}`, \\\n-                                        bound `{}` does not allow unsized type\",\n-                                      param_ty.user_string(tcx),\n-                                      trait_ref.user_string(tcx));\n-                        }\n-                    }\n-                    Err(ErrorReported) => { }\n-                }\n-                true\n-            });\n-    }\n-}\n-\n-/// Converts a specific TyParamBound from the AST into the\n-/// appropriate poly-trait-reference.\n-fn poly_trait_ref_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n-                                   param_ty: Ty<'tcx>,\n-                                   bound: &ast::TyParamBound,\n-                                   projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                                   -> Option<ty::PolyTraitRef<'tcx>>\n+/// Converts a specific TyParamBound from the AST into a set of\n+/// predicates that apply to the self-type. A vector is returned\n+/// because this can be anywhere from 0 predicates (`T:?Sized` adds no\n+/// predicates) to 1 (`T:Foo`) to many (`T:Bar<X=i32>` adds `T:Bar`\n+/// and `<T as Bar>::X == i32`).\n+fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n+                               param_ty: Ty<'tcx>,\n+                               bound: &ast::TyParamBound)\n+                               -> Vec<ty::Predicate<'tcx>>\n {\n     match *bound {\n         ast::TraitTyParamBound(ref tr, ast::TraitBoundModifier::None) => {\n-            Some(conv_poly_trait_ref(astconv, param_ty, tr, projections))\n+            let mut projections = Vec::new();\n+            let pred = conv_poly_trait_ref(astconv, param_ty, tr, &mut projections);\n+            projections.into_iter()\n+                       .map(|p| p.as_predicate())\n+                       .chain(Some(pred.as_predicate()).into_iter())\n+                       .collect()\n         }\n-        ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) |\n-        ast::RegionTyParamBound(_) => {\n-            None\n+        ast::RegionTyParamBound(ref lifetime) => {\n+            let region = ast_region_to_region(astconv.tcx(), lifetime);\n+            let pred = ty::Binder(ty::OutlivesPredicate(param_ty, region));\n+            vec![ty::Predicate::TypeOutlives(pred)]\n+        }\n+        ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) => {\n+            Vec::new()\n         }\n     }\n }"}, {"sha": "9b27128ce2ffd5409b40b2694187031b54475684", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -644,9 +644,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n \n             ast::ItemTrait(..) => {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n-                let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n+                let predicates = ty::lookup_super_predicates(tcx, did);\n                 self.add_constraints_from_predicates(&trait_def.generics,\n-                                                     &predicates,\n+                                                     predicates.predicates.as_slice(),\n                                                      self.covariant);\n \n                 let trait_items = ty::trait_items(tcx, did);"}, {"sha": "db41bf9fee329d9e36e65cf9f183bc1ec7a5a524", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -165,14 +165,12 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n             _ => unreachable!()\n         }\n     });\n-    let trait_def = ty::lookup_trait_def(tcx, did);\n     let predicates = ty::lookup_predicates(tcx, did);\n-    let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n         unsafety: def.unsafety,\n         generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n-        bounds: bounds,\n+        bounds: vec![], // supertraits can be found in the list of predicates\n     }\n }\n "}, {"sha": "5ca0700ce6edaa8425da266aec76db4953bc71f5", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -25,7 +25,7 @@ trait Trait { type Item; }\n struct A<T>\n     where T : Trait,\n           T : Add<T::Item>\n-    //~^ ERROR illegal recursive type\n+    //~^ ERROR unsupported cyclic reference between types/traits detected\n {\n     data: T\n }"}, {"sha": "e6caeb34a8c8f30fddd833c1140200f73f2ea113", "filename": "src/test/compile-fail/cycle-trait-default-type-trait.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-default-type-trait.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that bounds are sized-compatible.\n+// Test a cycle where a type parameter on a trait has a default that\n+// again references the trait.\n \n-trait T : Sized {}\n-fn f<Y: ?Sized + T>() {\n-//~^ERROR incompatible bounds on `Y`, bound `T` does not allow unsized type\n+trait Foo<X = Box<Foo>> {\n+    //~^ ERROR unsupported cyclic reference\n }\n \n-pub fn main() {\n-}\n+fn main() { }", "previous_filename": "src/test/compile-fail/unsized4.rs"}, {"sha": "c9bfde3f4ed12bb9ad233976cd0ec992be83611e", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -12,9 +12,12 @@\n // a direct participant in the cycle.\n \n trait A: B {\n+    //~^ ERROR unsupported cyclic reference\n }\n \n-trait B: C { }\n+trait B: C {\n+    //~^ ERROR unsupported cyclic reference\n+}\n \n trait C: B { }\n     //~^ ERROR unsupported cyclic reference"}, {"sha": "e5120840f7672a6d19ad8fae9faa4d87f29504df", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: illegal recursive type\n-\n-\n type x = Vec<x>;\n+//~^ ERROR unsupported cyclic reference\n \n fn main() { let b: x = Vec::new(); }"}, {"sha": "271c31bd375484c6ef7c763e8c67f5079433ce75", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -12,18 +12,17 @@\n \n use std::any::Any;\n use std::any::TypeId;\n+use std::marker::MarkerTrait;\n \n-pub trait Pt {}\n-pub trait Rt {}\n+pub trait Pt : MarkerTrait {}\n+pub trait Rt : MarkerTrait {}\n \n trait Private<P: Pt, R: Rt> {\n     fn call(&self, p: P, r: R);\n }\n-pub trait Public: Private<\n+pub trait Public: Private< //~ ERROR private trait in exported type parameter bound\n     <Self as Public>::P,\n-//~^ ERROR illegal recursive type; insert an enum or struct in the cycle, if this is desired\n     <Self as Public>::R\n-//~^ ERROR unsupported cyclic reference between types/traits detected\n > {\n     type P;\n     type R;"}, {"sha": "0f1dd2d7fd6a80867a5f60ba1803bf6d4d25a628", "filename": "src/test/compile-fail/issue-3953.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/68740b405404a3f885e388c8d31722797d519c30/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68740b405404a3f885e388c8d31722797d519c30/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3953.rs?ref=68740b405404a3f885e388c8d31722797d519c30", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-tidy-linelength\n-\n-use std::cmp::PartialEq;\n-\n-trait Hahaha: PartialEq + PartialEq {\n-    //~^ ERROR trait `PartialEq` already appears in the list of bounds\n-}\n-\n-struct Lol(isize);\n-\n-impl Hahaha for Lol { }\n-\n-impl PartialEq for Lol {\n-    fn eq(&self, other: &Lol) -> bool { **self != **other }\n-    fn ne(&self, other: &Lol) -> bool { **self == **other }\n-}\n-\n-fn main() {\n-    if Lol(2) == Lol(4) {\n-        println!(\"2 == 4\");\n-    } else {\n-        println!(\"2 != 4\");\n-    }\n-}"}, {"sha": "971869ba85bb02b3193809764fd109380325f272", "filename": "src/test/compile-fail/traits-assoc-type-in-supertrait-bad.rs", "status": "renamed", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Ftraits-assoc-type-in-supertrait-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Ftraits-assoc-type-in-supertrait-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-assoc-type-in-supertrait-bad.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {}\n+// Test case where an associated type is referenced from within the\n+// supertrait definition, and the impl makes the wrong\n+// associations. Issue #20220.\n \n-fn foo<T: Foo + Foo>() {} //~ ERROR `Foo` already appears in the list of bounds\n+use std::vec::IntoIter;\n \n-fn main() {}\n+pub trait Foo: Iterator<Item=<Self as Foo>::Key> {\n+    type Key;\n+}\n+\n+impl Foo for IntoIter<i32> { //~ ERROR type mismatch\n+    type Key = u32;\n+}\n+\n+fn main() {\n+}", "previous_filename": "src/test/compile-fail/duplicate-trait-bounds.rs"}, {"sha": "d61ac6f08d99d603a0136e10e5a0c545dee0e75b", "filename": "src/test/compile-fail/traits-repeated-supertrait-ambig.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-repeated-supertrait-ambig.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case of a trait which extends the same supertrait twice, but\n+// with difference type parameters. Test then that when we don't give\n+// enough information to pick between these, no selection is made. In\n+// this particular case, the two choices are i64/u64 -- so when we use\n+// an integer literal, we wind up falling this literal back to i32.\n+// See also `run-pass/trait-repeated-supertrait.rs`.\n+\n+trait CompareTo<T> {\n+    fn same_as(&self, t: T) -> bool;\n+}\n+\n+trait CompareToInts : CompareTo<i64> + CompareTo<u64> {\n+}\n+\n+impl CompareTo<i64> for i64 {\n+    fn same_as(&self, t: i64) -> bool { *self == t }\n+}\n+\n+impl CompareTo<u64> for i64 {\n+    fn same_as(&self, t: u64) -> bool { *self == (t as i64) }\n+}\n+\n+impl CompareToInts for i64 { }\n+\n+fn with_obj(c: &CompareToInts) -> bool {\n+    c.same_as(22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_trait<C:CompareToInts>(c: &C) -> bool {\n+    c.same_as(22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_ufcs1<C:CompareToInts>(c: &C) -> bool {\n+    CompareToInts::same_as(c, 22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn with_ufcs2<C:CompareToInts>(c: &C) -> bool {\n+    CompareTo::same_as(c, 22) //~ ERROR `CompareTo<i32>` is not implemented\n+}\n+\n+fn main() {\n+    assert_eq!(22_i64.same_as(22), true); //~ ERROR `CompareTo<i32>` is not implemented\n+}"}, {"sha": "6a4a6710131e384646fa9c7d1889f3425b226154", "filename": "src/test/run-pass/traits-assoc-type-in-supertrait.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Frun-pass%2Ftraits-assoc-type-in-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Frun-pass%2Ftraits-assoc-type-in-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-assoc-type-in-supertrait.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test case where an associated type is referenced from within the\n+// supertrait definition. Issue #20220.\n+\n+use std::vec::IntoIter;\n+\n+pub trait Foo: Iterator<Item=<Self as Foo>::Key> {\n+    type Key;\n+}\n+\n+impl Foo for IntoIter<i32> {\n+    type Key = i32;\n+}\n+\n+fn sum_foo<F:Foo<Key=i32>>(f: F) -> i32 {\n+    f.fold(0, |a,b| a + b)\n+}\n+\n+fn main() {\n+    let x = sum_foo(vec![11, 10, 1].into_iter());\n+    assert_eq!(x, 22);\n+}"}, {"sha": "fdaa8d6f4d6efdb2cf6b1ab6060f6e4eb556d12b", "filename": "src/test/run-pass/traits-repeated-supertrait.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0c74f85f363a8081b31f9ab696463717ce312d5/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-repeated-supertrait.rs?ref=f0c74f85f363a8081b31f9ab696463717ce312d5", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case of a trait which extends the same supertrait twice, but\n+// with difference type parameters. Test that we can invoke the\n+// various methods in various ways successfully.\n+// See also `compile-fail/trait-repeated-supertrait-ambig.rs`.\n+\n+trait CompareTo<T> {\n+    fn same_as(&self, t: T) -> bool;\n+}\n+\n+trait CompareToInts : CompareTo<i64> + CompareTo<u64> {\n+}\n+\n+impl CompareTo<i64> for i64 {\n+    fn same_as(&self, t: i64) -> bool { *self == t }\n+}\n+\n+impl CompareTo<u64> for i64 {\n+    fn same_as(&self, t: u64) -> bool { *self == (t as i64) }\n+}\n+\n+impl CompareToInts for i64 { }\n+\n+fn with_obj(c: &CompareToInts) -> bool {\n+    c.same_as(22_i64) && c.same_as(22_u64)\n+}\n+\n+fn with_trait<C:CompareToInts>(c: &C) -> bool {\n+    c.same_as(22_i64) && c.same_as(22_u64)\n+}\n+\n+fn with_ufcs1<C:CompareToInts>(c: &C) -> bool {\n+    CompareToInts::same_as(c, 22_i64) && CompareToInts::same_as(c, 22_u64)\n+}\n+\n+fn with_ufcs2<C:CompareToInts>(c: &C) -> bool {\n+    CompareTo::same_as(c, 22_i64) && CompareTo::same_as(c, 22_u64)\n+}\n+\n+fn main() {\n+    assert_eq!(22_i64.same_as(22_i64), true);\n+    assert_eq!(22_i64.same_as(22_u64), true);\n+    assert_eq!(with_trait(&22), true);\n+    assert_eq!(with_obj(&22), true);\n+    assert_eq!(with_ufcs1(&22), true);\n+    assert_eq!(with_ufcs2(&22), true);\n+}"}]}