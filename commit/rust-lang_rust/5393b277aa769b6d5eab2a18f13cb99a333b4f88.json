{"sha": "5393b277aa769b6d5eab2a18f13cb99a333b4f88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOTNiMjc3YWE3NjliNmQ1ZWFiMmExOGYxM2NiOTlhMzMzYjRmODg=", "commit": {"author": {"name": "iirelu", "email": "anna@bawk.space", "date": "2018-09-14T12:40:26Z"}, "committer": {"name": "iirelu", "email": "anna@bawk.space", "date": "2018-09-14T12:40:26Z"}, "message": "Incorporate keyword doc PR critique", "tree": {"sha": "8e86fe17f426c3e48b9d48871dac1a85f9012e0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e86fe17f426c3e48b9d48871dac1a85f9012e0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5393b277aa769b6d5eab2a18f13cb99a333b4f88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5393b277aa769b6d5eab2a18f13cb99a333b4f88", "html_url": "https://github.com/rust-lang/rust/commit/5393b277aa769b6d5eab2a18f13cb99a333b4f88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5393b277aa769b6d5eab2a18f13cb99a333b4f88/comments", "author": {"login": "iirelu", "id": 3432543, "node_id": "MDQ6VXNlcjM0MzI1NDM=", "avatar_url": "https://avatars.githubusercontent.com/u/3432543?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iirelu", "html_url": "https://github.com/iirelu", "followers_url": "https://api.github.com/users/iirelu/followers", "following_url": "https://api.github.com/users/iirelu/following{/other_user}", "gists_url": "https://api.github.com/users/iirelu/gists{/gist_id}", "starred_url": "https://api.github.com/users/iirelu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iirelu/subscriptions", "organizations_url": "https://api.github.com/users/iirelu/orgs", "repos_url": "https://api.github.com/users/iirelu/repos", "events_url": "https://api.github.com/users/iirelu/events{/privacy}", "received_events_url": "https://api.github.com/users/iirelu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iirelu", "id": 3432543, "node_id": "MDQ6VXNlcjM0MzI1NDM=", "avatar_url": "https://avatars.githubusercontent.com/u/3432543?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iirelu", "html_url": "https://github.com/iirelu", "followers_url": "https://api.github.com/users/iirelu/followers", "following_url": "https://api.github.com/users/iirelu/following{/other_user}", "gists_url": "https://api.github.com/users/iirelu/gists{/gist_id}", "starred_url": "https://api.github.com/users/iirelu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iirelu/subscriptions", "organizations_url": "https://api.github.com/users/iirelu/orgs", "repos_url": "https://api.github.com/users/iirelu/repos", "events_url": "https://api.github.com/users/iirelu/events{/privacy}", "received_events_url": "https://api.github.com/users/iirelu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d05ae7235743c150ca1aa96c31f0421caf5440f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d05ae7235743c150ca1aa96c31f0421caf5440f", "html_url": "https://github.com/rust-lang/rust/commit/5d05ae7235743c150ca1aa96c31f0421caf5440f"}], "stats": {"total": 67, "additions": 36, "deletions": 31}, "files": [{"sha": "fbe7e244381c56f048c8a994d420d91f62c858ca", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5393b277aa769b6d5eab2a18f13cb99a333b4f88/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5393b277aa769b6d5eab2a18f13cb99a333b4f88/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=5393b277aa769b6d5eab2a18f13cb99a333b4f88", "patch": "@@ -10,7 +10,7 @@\n \n #[doc(keyword = \"as\")]\n //\n-/// The type coercion keyword.\n+/// The keyword for casting types.\n ///\n /// `as` is most commonly used to turn primitive types into other primitive types, but it has other\n /// uses that include turning pointers into addresses, addresses into pointers, and pointers into\n@@ -24,15 +24,20 @@\n /// assert_eq!(true as u8 + thing2 as u8, 100);\n /// ```\n ///\n-/// In general, any coercion that can be performed via writing out type hints can also be done\n-/// using `as`, so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (Note:\n-/// `let x = 123u32` would be best in that situation). The same is not true in the other direction,\n-/// however, explicitly using `as` allows a few more coercions that aren't allowed implicitly, such\n-/// as changing the type of a raw pointer or turning closures into raw pointers.\n+/// In general, any cast that can be performed via ascribing the type can also be done using `as`,\n+/// so instead of writing `let x: u32 = 123`, you can write `let x = 123 as u32` (Note: `let x: u32\n+/// = 123` would be best in that situation). The same is not true in the other direction, however,\n+/// explicitly using `as` allows a few more coercions that aren't allowed implicitly, such as\n+/// changing the type of a raw pointer or turning closures into raw pointers.\n+///\n+/// Other places `as` is used include as extra syntax for [`crate`] and [`use`], to change the name\n+/// something is imported as.\n ///\n /// For more information on what `as` is capable of, see the [Reference]\n ///\n /// [Reference]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#type-cast-expressions\n+/// [`crate`]: keyword.crate.html\n+/// [`use`]: keyword.use.html\n mod as_keyword { }\n \n #[doc(keyword = \"const\")]\n@@ -52,12 +57,12 @@ mod as_keyword { }\n ///\n /// Constants must be explicitly typed, unlike with `let` you can't ignore its type and let the\n /// compiler figure it out. Any constant value can be defined in a const, which in practice happens\n-/// to be most things that would be reasonable to have a constant. For example, you can't have a\n-/// File as a `const`.\n+/// to be most things that would be reasonable to have a constant (barring `const fn`s, coming\n+/// soon). For example, you can't have a File as a `const`.\n ///\n-/// The only lifetime allowed in a constant is 'static, which is the lifetime that encompasses all\n-/// others in a Rust program. For example, if you wanted to define a constant string, it would look\n-/// like this:\n+/// The only lifetime allowed in a constant is `'static`, which is the lifetime that encompasses\n+/// all others in a Rust program. For example, if you wanted to define a constant string, it would\n+/// look like this:\n ///\n /// ```rust\n /// const WORDS: &'static str = \"hello rust!\";\n@@ -73,9 +78,8 @@ mod as_keyword { }\n /// to which one should be used at which times. To put it simply, constants are inlined wherever\n /// they're used, making using them identical to simply replacing the name of the const with its\n /// value. Static variables on the other hand point to a single location in memory, which all\n-/// accesses share. This means that, unlike with constants, they can't have destructors, but it\n-/// also means that (via unsafe code) they can be mutable, which is useful for the rare situations\n-/// in which you can't avoid using global state.\n+/// accesses share. This means that, unlike with constants, they can't have destructors, and act as\n+/// a single value across the entire codebase.\n ///\n /// Constants, as with statics, should always be in SCREAMING_SNAKE_CASE.\n ///\n@@ -130,8 +134,8 @@ mod crate_keyword { }\n ///\n /// Enums in Rust are similar to those of other compiled languages like C, but have important\n /// differences that make them considerably more powerful. What Rust calls enums are more commonly\n-/// known as Algebraic Data Types if you're coming from a functional programming background, but\n-/// the important part is that data can go with the enum variants.\n+/// known as Algebraic Data Types if you're coming from a functional programming background. The\n+/// important detail is that each enum variant can have data to go along with it.\n ///\n /// ```rust\n /// # struct Coord;\n@@ -160,9 +164,9 @@ mod crate_keyword { }\n /// ```\n ///\n /// The first enum shown is the usual kind of enum you'd find in a C-style language. The second\n-/// shows off a hypothetical example of something storing location data, with Coord being any other\n-/// type that's needed, for example a struct. The third example demonstrates the kind of variant a\n-/// variant can store, ranging from nothing, to a tuple, to an anonymous struct.\n+/// shows off a hypothetical example of something storing location data, with `Coord` being any\n+/// other type that's needed, for example a struct. The third example demonstrates the kind of\n+/// data a variant can store, ranging from nothing, to a tuple, to an anonymous struct.\n ///\n /// Instantiating enum variants involves explicitly using the enum's name as its namespace,\n /// followed by one of its variants. `SimpleEnum::SecondVariant` would be an example from above.\n@@ -188,7 +192,7 @@ mod enum_keyword { }\n /// lazy_static;`. The other use is in foreign function interfaces (FFI).\n ///\n /// `extern` is used in two different contexts within FFI. The first is in the form of external\n-/// blcoks, for declaring function interfaces that Rust code can call foreign code by.\n+/// blocks, for declaring function interfaces that Rust code can call foreign code by.\n ///\n /// ```rust ignore\n /// #[link(name = \"my_c_library\")]\n@@ -197,8 +201,8 @@ mod enum_keyword { }\n /// }\n /// ```\n ///\n-/// This code would attempt to link with libmy_c_library.so on unix-like systems and\n-/// my_c_library.dll on Windows at runtime, and panic if it can't find something to link to. Rust\n+/// This code would attempt to link with `libmy_c_library.so` on unix-like systems and\n+/// `my_c_library.dll` on Windows at runtime, and panic if it can't find something to link to. Rust\n /// code could then use `my_c_function` as if it were any other unsafe Rust function. Working with\n /// non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.\n ///\n@@ -275,7 +279,8 @@ mod extern_keyword { }\n /// ```\n ///\n /// Declaring trait bounds in the angle brackets is functionally identical to using a [`where`]\n-/// clause, but `where` is preferred due to it being easier to understand at a glance.\n+/// clause. It's up to the programmer to decide which works better in each situation, but `where`\n+/// tends to be better when things get longer than one line.\n ///\n /// Along with being made public via [`pub`], `fn` can also have an [`extern`] added for use in\n /// FFI.\n@@ -475,8 +480,8 @@ mod let_keyword { }\n //\n /// The keyword used to define structs.\n ///\n-/// Structs in Rust come in three flavours: Regular structs, tuple structs,\n-/// and empty structs.\n+/// Structs in Rust come in three flavours: Structs with named fields, tuple structs, and unit\n+/// structs.\n ///\n /// ```rust\n /// struct Regular {\n@@ -487,7 +492,7 @@ mod let_keyword { }\n ///\n /// struct Tuple(u32, String);\n ///\n-/// struct Empty;\n+/// struct Unit;\n /// ```\n ///\n /// Regular structs are the most commonly used. Each field defined within them has a name and a\n@@ -501,14 +506,14 @@ mod let_keyword { }\n /// individual variables, the same syntax is used as with regular tuples, namely `foo.0`, `foo.1`,\n /// etc, starting at zero.\n ///\n-/// Empty structs, or unit-like structs, are most commonly used as markers, for example\n-/// [`PhantomData`]. Empty structs have a size of zero bytes, but unlike empty enums they can be\n-/// instantiated, making them similar to the unit type `()`. Unit-like structs are useful when you\n-/// need to implement a trait on something, but don't need to store any data inside it.\n+/// Unit structs are most commonly used as marker. They have a size of zero bytes, but unlike empty\n+/// enums they can be instantiated, making them isomorphic to the unit type `()`. Unit structs are\n+/// useful when you need to implement a trait on something, but don't need to store any data inside\n+/// it.\n ///\n /// # Instantiation\n ///\n-/// Structs can be instantiated in a manner of different ways, each of which can be mixed and\n+/// Structs can be instantiated in different ways, all of which can be mixed and\n /// matched as needed. The most common way to make a new struct is via a constructor method such as\n /// `new()`, but when that isn't available (or you're writing the constructor itself), struct\n /// literal syntax is used:"}]}