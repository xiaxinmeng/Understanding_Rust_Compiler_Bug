{"sha": "96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YmRjZDA3ZmU5ZWM0NGZhYzhkZWRiMjQyNWFlNzc4M2U0MTA4Y2U=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-26T23:04:49Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-27T16:38:22Z"}, "message": "rustpkg: Implement `rustpkg test`\n\nTowards #7401", "tree": {"sha": "7a869afd91bd58594abb6c94c2c3c81f551cbde5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a869afd91bd58594abb6c94c2c3c81f551cbde5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "html_url": "https://github.com/rust-lang/rust/commit/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f210a1671883d5fe97a2b06ebbe9270fa9a6943a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f210a1671883d5fe97a2b06ebbe9270fa9a6943a", "html_url": "https://github.com/rust-lang/rust/commit/f210a1671883d5fe97a2b06ebbe9270fa9a6943a"}], "stats": {"total": 195, "additions": 148, "deletions": 47}, "files": [{"sha": "006a58e042f8c331c854b29ef323914c570b9768", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "patch": "@@ -246,13 +246,17 @@ impl PkgSrc {\n     /// Infers crates to build. Called only in the case where there\n     /// is no custom build logic\n     pub fn find_crates(&mut self) {\n+        self.find_crates_with_filter(|_| true);\n+    }\n+\n+    pub fn find_crates_with_filter(&mut self, filter: &fn(&str) -> bool) {\n         use conditions::missing_pkg_files::cond;\n \n         let prefix = self.start_dir.components.len();\n         debug!(\"Matching against %s\", self.id.short_name);\n         do os::walk_dir(&self.start_dir) |pth| {\n             let maybe_known_crate_set = match pth.filename() {\n-                Some(filename) => match filename {\n+                Some(filename) if filter(filename) => match filename {\n                     \"lib.rs\" => Some(&mut self.libs),\n                     \"main.rs\" => Some(&mut self.mains),\n                     \"test.rs\" => Some(&mut self.tests),"}, {"sha": "09b67bb5291120dd5251782d8226fabf6641f7f7", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 74, "deletions": 34, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "patch": "@@ -33,7 +33,7 @@ use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n use messages::{error, warn, note};\n-use path_util::build_pkg_id_in_workspace;\n+use path_util::{build_pkg_id_in_workspace, built_test_in_workspace};\n use path_util::{U_RWX, in_rust_path};\n use path_util::{built_executable_in_workspace, built_library_in_workspace, default_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n@@ -44,7 +44,7 @@ use context::{Context, BuildContext,\n                        LLVMAssemble, LLVMCompileBitcode};\n use package_id::PkgId;\n use package_source::PkgSrc;\n-use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench};\n+use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench, Tests};\n // use workcache_support::{discover_outputs, digest_only_date};\n use workcache_support::digest_only_date;\n use exit_codes::COPY_FAILED_CODE;\n@@ -177,6 +177,8 @@ impl<'self> PkgScript<'self> {\n pub trait CtxMethods {\n     fn run(&self, cmd: &str, args: ~[~str]);\n     fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n+    /// Returns a pair of the selected package ID, and the destination workspace\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)>;\n     /// Returns the destination workspace\n     fn build(&self, pkg_src: &mut PkgSrc, what: &WhatToBuild) -> Path;\n     fn clean(&self, workspace: &Path, id: &PkgId);\n@@ -190,43 +192,53 @@ pub trait CtxMethods {\n                         target_workspace: &Path,\n                         id: &PkgId) -> ~[~str];\n     fn prefer(&self, _id: &str, _vers: Option<~str>);\n-    fn test(&self);\n+    fn test(&self, id: &PkgId, workspace: &Path);\n     fn uninstall(&self, _id: &str, _vers: Option<~str>);\n     fn unprefer(&self, _id: &str, _vers: Option<~str>);\n     fn init(&self);\n }\n \n impl CtxMethods for BuildContext {\n+    fn build_args(&self, args: ~[~str], what: &WhatToBuild) -> Option<(PkgId, Path)> {\n+        if args.len() < 1 {\n+            match cwd_to_workspace() {\n+                None if self.context.use_rust_path_hack => {\n+                    let cwd = os::getcwd();\n+                    let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n+                    let mut pkg_src = PkgSrc::new(cwd, true, pkgid);\n+                    let dest_ws = self.build(&mut pkg_src, what);\n+                    Some((pkg_src.id, dest_ws))\n+                }\n+                None => { usage::build(); None }\n+                Some((ws, pkgid)) => {\n+                    let mut pkg_src = PkgSrc::new(ws, false, pkgid);\n+                    let dest_ws = self.build(&mut pkg_src, what);\n+                    Some((pkg_src.id, dest_ws))\n+                }\n+            }\n+        } else {\n+            // The package id is presumed to be the first command-line\n+            // argument\n+            let pkgid = PkgId::new(args[0].clone());\n+            let mut dest_ws = None;\n+            do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n+                debug!(\"found pkg %s in workspace %s, trying to build\",\n+                       pkgid.to_str(), workspace.to_str());\n+                let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n+                dest_ws = Some(self.build(&mut pkg_src, what));\n+                true\n+            };\n+            assert!(dest_ws.is_some());\n+            // n.b. If this builds multiple packages, it only returns the workspace for\n+            // the last one. The whole building-multiple-packages-with-the-same-ID is weird\n+            // anyway and there are no tests for it, so maybe take it out\n+            Some((pkgid, dest_ws.unwrap()))\n+        }\n+    }\n     fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {\n             \"build\" => {\n-                if args.len() < 1 {\n-                    match cwd_to_workspace() {\n-                        None if self.context.use_rust_path_hack => {\n-                            let cwd = os::getcwd();\n-                            let pkgid = PkgId::new(cwd.components[cwd.components.len() - 1]);\n-                            let mut pkg_src = PkgSrc::new(cwd, true, pkgid);\n-                            self.build(&mut pkg_src, &Everything);\n-                        }\n-                        None => { usage::build(); return; }\n-                        Some((ws, pkgid)) => {\n-                            let mut pkg_src = PkgSrc::new(ws, false, pkgid);\n-                            self.build(&mut pkg_src, &Everything);\n-                        }\n-                    }\n-                }\n-                else {\n-                    // The package id is presumed to be the first command-line\n-                    // argument\n-                    let pkgid = PkgId::new(args[0].clone());\n-                    do each_pkg_parent_workspace(&self.context, &pkgid) |workspace| {\n-                        debug!(\"found pkg %s in workspace %s, trying to build\",\n-                               pkgid.to_str(), workspace.to_str());\n-                        let mut pkg_src = PkgSrc::new(workspace.clone(), false, pkgid.clone());\n-                        self.build(&mut pkg_src, &Everything);\n-                        true\n-                    };\n-                }\n+                self.build_args(args, &Everything);\n             }\n             \"clean\" => {\n                 if args.len() < 1 {\n@@ -310,7 +322,17 @@ impl CtxMethods for BuildContext {\n                 self.prefer(args[0], None);\n             }\n             \"test\" => {\n-                self.test();\n+                // Build the test executable\n+                let maybe_id_and_workspace = self.build_args(args, &Tests);\n+                match maybe_id_and_workspace {\n+                    Some((pkg_id, workspace)) => {\n+                        // Assuming it's built, run the tests\n+                        self.test(&pkg_id, &workspace);\n+                    }\n+                    None => {\n+                        error(\"Testing failed because building the specified package failed.\");\n+                    }\n+                }\n             }\n             \"init\" => {\n                 if args.len() != 0 {\n@@ -425,6 +447,8 @@ impl CtxMethods for BuildContext {\n             match what_to_build {\n                 // Find crates inside the workspace\n                 &Everything => pkg_src.find_crates(),\n+                // Find only tests\n+                &Tests => pkg_src.find_crates_with_filter(|s| { is_test(&Path(s)) }),\n                 // Don't infer any crates -- just build the one that was requested\n                 &JustOne(ref p) => {\n                     // We expect that p is relative to the package source's start directory,\n@@ -592,9 +616,25 @@ impl CtxMethods for BuildContext {\n         fail!(\"prefer not yet implemented\");\n     }\n \n-    fn test(&self)  {\n-        // stub\n-        fail!(\"test not yet implemented\");\n+    fn test(&self, pkgid: &PkgId, workspace: &Path)  {\n+        match built_test_in_workspace(pkgid, workspace) {\n+            Some(test_exec) => {\n+                debug!(\"test: test_exec = %s\", test_exec.to_str());\n+                let p_output = run::process_output(test_exec.to_str(), [~\"--test\"]);\n+                if p_output.status == 0 {\n+                    println(str::from_utf8(p_output.output));\n+                }\n+                    else {\n+                    println(str::from_utf8(p_output.error));\n+                }\n+                os::set_exit_status(p_output.status);\n+            }\n+            None => {\n+                error(fmt!(\"Internal error: test executable for package ID %s in workspace %s \\\n+                           wasn't built! Please report this as a bug.\",\n+                           pkgid.to_str(), workspace.to_str()));\n+            }\n+        }\n     }\n \n     fn init(&self) {"}, {"sha": "664f6807227d8fdfd99f7bb2d2d40b93bf42d780", "filename": "src/librustpkg/target.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "patch": "@@ -26,6 +26,8 @@ pub enum Target {\n pub enum WhatToBuild {\n     /// Build just one lib.rs file in `path`, which is relative to the active workspace's src/ dir\n     JustOne(Path),\n+    /// Build any test.rs files that can be recursively found in the active workspace\n+    Tests,\n     /// Build everything\n     Everything\n }"}, {"sha": "87abff45dc7594755c3adf34001c4a97204ab9ae", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 67, "deletions": 12, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96bdcd07fe9ec44fac8dedb2425ae7783e4108ce/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=96bdcd07fe9ec44fac8dedb2425ae7783e4108ce", "patch": "@@ -350,11 +350,19 @@ fn assert_executable_exists(repo: &Path, short_name: &str) {\n }\n \n fn executable_exists(repo: &Path, short_name: &str) -> bool {\n-    debug!(\"assert_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    debug!(\"executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n     let exec = target_executable_in_workspace(&PkgId::new(short_name), repo);\n     os::path_exists(&exec) && is_rwx(&exec)\n }\n \n+fn test_executable_exists(repo: &Path, short_name: &str) -> bool {\n+    debug!(\"test_executable_exists: repo = %s, short_name = %s\", repo.to_str(), short_name);\n+    let exec = built_test_in_workspace(&PkgId::new(short_name), repo);\n+    do exec.map_default(false) |exec| {\n+        os::path_exists(exec) && is_rwx(exec)\n+    }\n+}\n+\n fn remove_executable_file(p: &PkgId, workspace: &Path) {\n     let exec = target_executable_in_workspace(&PkgId::new(p.short_name), workspace);\n     if os::path_exists(&exec) {\n@@ -1045,19 +1053,8 @@ fn test_info() {\n }\n \n #[test]\n-#[ignore(reason = \"test not yet implemented\")]\n-fn test_rustpkg_test() {\n-    let expected_results = ~\"1 out of 1 tests passed\"; // fill in\n-    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n-    let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n-    assert_eq!(str::from_utf8(output.output), expected_results);\n-}\n-\n-#[test]\n-#[ignore(reason = \"test not yet implemented\")]\n fn test_uninstall() {\n     let workspace = create_local_package(&PkgId::new(\"foo\"));\n-    let _output = command_line_test([~\"info\", ~\"foo\"], &workspace);\n     command_line_test([~\"uninstall\", ~\"foo\"], &workspace);\n     let output = command_line_test([~\"list\"], &workspace);\n     assert!(!str::from_utf8(output.output).contains(\"foo\"));\n@@ -1800,6 +1797,64 @@ fn correct_package_name_with_rust_path_hack() {\n     assert!(!lib_exists(&foo_workspace, &foo_id.path.clone(), foo_id.version.clone()));\n }\n \n+#[test]\n+fn test_rustpkg_test_creates_exec() {\n+    let foo_id = PkgId::new(\"foo\");\n+    let foo_workspace = create_local_package(&foo_id);\n+    writeFile(&foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]),\n+              \"#[test] fn f() { assert!('a' == 'a'); }\");\n+    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n+    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+}\n+\n+#[test]\n+fn test_rustpkg_test_output() {\n+    let workspace = create_local_package_with_test(&PkgId::new(\"foo\"));\n+    let output = command_line_test([~\"test\", ~\"foo\"], &workspace);\n+    let output_str = str::from_utf8(output.output);\n+    assert!(output_str.contains(\"test f ... ok\"));\n+    assert!(output_str.contains(\n+        \"test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured\"));\n+}\n+\n+#[test]\n+#[ignore(reason = \"See issue #9441\")]\n+fn test_rebuild_when_needed() {\n+    let foo_id = PkgId::new(\"foo\");\n+    let foo_workspace = create_local_package(&foo_id);\n+    let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n+    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n+    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+    let test_executable = built_test_in_workspace(&foo_id,\n+            &foo_workspace).expect(\"test_rebuild_when_needed failed\");\n+    frob_source_file(&foo_workspace, &foo_id, \"test.rs\");\n+    chmod_read_only(&test_executable);\n+    match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n+        Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n+        Fail(status) if status == 65 => (), // ok\n+        Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n+    }\n+}\n+\n+#[test]\n+fn test_no_rebuilding() {\n+    let foo_id = PkgId::new(\"foo\");\n+    let foo_workspace = create_local_package(&foo_id);\n+    let test_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"test.rs\"]);\n+    writeFile(&test_crate, \"#[test] fn f() { assert!('a' == 'a'); }\");\n+    command_line_test([~\"test\", ~\"foo\"], &foo_workspace);\n+    assert!(test_executable_exists(&foo_workspace, \"foo\"));\n+    let test_executable = built_test_in_workspace(&foo_id,\n+                            &foo_workspace).expect(\"test_no_rebuilding failed\");\n+    chmod_read_only(&test_executable);\n+    match command_line_test_partial([~\"test\", ~\"foo\"], &foo_workspace) {\n+        Success(*) => (), // ok\n+        Fail(status) if status == 65 => fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n+        Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n+    }\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}]}