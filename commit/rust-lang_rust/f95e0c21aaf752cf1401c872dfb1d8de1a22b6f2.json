{"sha": "f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NWUwYzIxYWFmNzUyY2YxNDAxYzg3MmRmYjFkOGRlMWEyMmI2ZjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-18T04:15:39Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-20T05:49:37Z"}, "message": "Fix more import_shadowing fallout in collections.", "tree": {"sha": "cf2057399b4d05e1ca653fd42fc2eec8419464f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf2057399b4d05e1ca653fd42fc2eec8419464f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "html_url": "https://github.com/rust-lang/rust/commit/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5193d542f61cd6723d053dff5782d9038a027a7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5193d542f61cd6723d053dff5782d9038a027a7b", "html_url": "https://github.com/rust-lang/rust/commit/5193d542f61cd6723d053dff5782d9038a027a7b"}], "stats": {"total": 117, "additions": 65, "deletions": 52}, "files": [{"sha": "dc69c5993c1af21af806e7556ab1aa35581c324e", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "patch": "@@ -131,12 +131,12 @@ pub enum Entry<'a, K:'a, V:'a> {\n /// A vacant Entry.\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n-    stack: stack::SearchStack<'a, K, V, node::Edge, node::Leaf>,\n+    stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n-    stack: stack::SearchStack<'a, K, V, node::KV, node::LeafOrInternal>,\n+    stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n@@ -496,7 +496,8 @@ mod stack {\n     use core::kinds::marker;\n     use core::mem;\n     use super::BTreeMap;\n-    use super::super::node::{mod, Node, Fit, Split, KV, Edge, Internal, Leaf, LeafOrInternal};\n+    use super::super::node::{mod, Node, Fit, Split, Internal, Leaf};\n+    use super::super::node::handle;\n     use vec::Vec;\n \n     /// A generic mutable reference, identical to `&mut` except for the fact that its lifetime\n@@ -520,7 +521,7 @@ mod stack {\n         }\n     }\n \n-    type StackItem<K, V> = node::Handle<*mut Node<K, V>, Edge, Internal>;\n+    type StackItem<K, V> = node::Handle<*mut Node<K, V>, handle::Edge, handle::Internal>;\n     type Stack<K, V> = Vec<StackItem<K, V>>;\n \n     /// A `PartialSearchStack` handles the construction of a search stack.\n@@ -595,7 +596,9 @@ mod stack {\n         /// Pushes the requested child of the stack's current top on top of the stack. If the child\n         /// exists, then a new PartialSearchStack is yielded. Otherwise, a VacantSearchStack is\n         /// yielded.\n-        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>, Edge, Internal>)\n+        pub fn push(mut self, mut edge: node::Handle<IdRef<'id, Node<K, V>>,\n+                                                     handle::Edge,\n+                                                     handle::Internal>)\n                     -> PartialSearchStack<'a, K, V> {\n             self.stack.push(edge.as_raw());\n             PartialSearchStack {\n@@ -617,7 +620,7 @@ mod stack {\n         }\n     }\n \n-    impl<'a, K, V, NodeType> SearchStack<'a, K, V, KV, NodeType> {\n+    impl<'a, K, V, NodeType> SearchStack<'a, K, V, handle::KV, NodeType> {\n         /// Gets a reference to the value the stack points to.\n         pub fn peek(&self) -> &V {\n             unsafe { self.top.from_raw().into_kv().1 }\n@@ -640,7 +643,7 @@ mod stack {\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V, KV, Leaf> {\n+    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n         fn remove_leaf(mut self) -> V {\n@@ -686,7 +689,7 @@ mod stack {\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V, KV, LeafOrInternal> {\n+    impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::LeafOrInternal> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n         pub fn remove(self) -> V {\n@@ -703,7 +706,7 @@ mod stack {\n         /// leaves the tree in an inconsistent state that must be repaired by the caller by\n         /// removing the entry in question. Specifically the key-value pair and its successor will\n         /// become swapped.\n-        fn into_leaf(mut self) -> SearchStack<'a, K, V, KV, Leaf> {\n+        fn into_leaf(mut self) -> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n             unsafe {\n                 let mut top_raw = self.top;\n                 let mut top = top_raw.from_raw_mut();\n@@ -757,7 +760,7 @@ mod stack {\n         }\n     }\n \n-    impl<'a, K, V> SearchStack<'a, K, V, Edge, Leaf> {\n+    impl<'a, K, V> SearchStack<'a, K, V, handle::Edge, handle::Leaf> {\n         /// Inserts the key and value into the top element in the stack, and if that node has to\n         /// split recursively inserts the split contents into the next element stack until\n         /// splits stop."}, {"sha": "1666f42d82bb5384fb0f88abfab936c594d9064f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "patch": "@@ -34,9 +34,9 @@ pub enum InsertionResult<K, V> {\n /// Represents the result of a search for a key in a single node\n pub enum SearchResult<NodeRef> {\n     /// The element was found at the given index\n-    Found(Handle<NodeRef, KV, LeafOrInternal>),\n+    Found(Handle<NodeRef, handle::KV, handle::LeafOrInternal>),\n     /// The element wasn't found, but if it's anywhere, it must be beyond this edge\n-    GoDown(Handle<NodeRef, Edge, LeafOrInternal>),\n+    GoDown(Handle<NodeRef, handle::Edge, handle::LeafOrInternal>),\n }\n \n /// A B-Tree Node. We keep keys/edges/values separate to optimize searching for keys.\n@@ -494,12 +494,16 @@ pub struct Handle<NodeRef, Type, NodeType> {\n     index: uint\n }\n \n-pub enum KV {}\n-pub enum Edge {}\n+pub mod handle {\n+    // Handle types.\n+    pub enum KV {}\n+    pub enum Edge {}\n \n-pub enum LeafOrInternal {}\n-pub enum Leaf {}\n-pub enum Internal {}\n+    // Handle node types.\n+    pub enum LeafOrInternal {}\n+    pub enum Leaf {}\n+    pub enum Internal {}\n+}\n \n impl<K: Ord, V> Node<K, V> {\n     /// Searches for the given key in the node. If it finds an exact match,\n@@ -625,7 +629,7 @@ impl<K, V, Type, NodeType> Handle<*mut Node<K, V>, Type, NodeType> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, Edge, Internal> {\n+impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// Turns the handle into a reference to the edge it points at. This is necessary because the\n     /// returned pointer has a larger lifetime than what would be returned by `edge` or `edge_mut`,\n     /// making it more suitable for moving down a chain of nodes.\n@@ -636,7 +640,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, Edge, Internal> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, Edge, Internal> {\n+impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal> {\n     /// Turns the handle into a mutable reference to the edge it points at. This is necessary\n     /// because the returned pointer has a larger lifetime than what would be returned by\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n@@ -647,7 +651,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, Edge, Internal> {\n     }\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n+impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     // This doesn't exist because there are no uses for it,\n     // but is fine to add, analagous to edge_mut.\n     //\n@@ -657,11 +661,11 @@ impl<K, V, NodeRef: Deref<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n }\n \n pub enum ForceResult<NodeRef, Type> {\n-    Leaf(Handle<NodeRef, Type, Leaf>),\n-    Internal(Handle<NodeRef, Type, Internal>)\n+    Leaf(Handle<NodeRef, Type, handle::Leaf>),\n+    Internal(Handle<NodeRef, Type, handle::Internal>)\n }\n \n-impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, LeafOrInternal> {\n+impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, handle::LeafOrInternal> {\n     /// Figure out whether this handle is pointing to something in a leaf node or to something in\n     /// an internal node, clarifying the type according to the result.\n     pub fn force(self) -> ForceResult<NodeRef, Type> {\n@@ -679,7 +683,7 @@ impl<K, V, NodeRef: Deref<Node<K, V>>, Type> Handle<NodeRef, Type, LeafOrInterna\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Leaf> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Leaf> {\n     /// Tries to insert this key-value pair at the given index in this leaf node\n     /// If the node is full, we have to split it.\n     ///\n@@ -711,7 +715,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Leaf> {\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::Internal> {\n     /// Returns a mutable reference to the edge pointed-to by this handle. This should not be\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n@@ -794,11 +798,11 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, Edge, Internal> {\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, Edge, NodeType> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::Edge, NodeType> {\n     /// Gets the handle pointing to the key/value pair just to the left of the pointed-to edge.\n     /// This is unsafe because the handle might point to the first edge in the node, which has no\n     /// pair to its left.\n-    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, KV, NodeType> {\n+    unsafe fn left_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n             index: self.index - 1\n@@ -808,15 +812,15 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, Edge, NodeTy\n     /// Gets the handle pointing to the key/value pair just to the right of the pointed-to edge.\n     /// This is unsafe because the handle might point to the last edge in the node, which has no\n     /// pair to its right.\n-    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, KV, NodeType> {\n+    unsafe fn right_kv<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n         Handle {\n             node: &mut *self.node,\n             index: self.index\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, KV, NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n     /// Turns the handle into references to the key and value it points at. This is necessary\n     /// because the returned pointers have larger lifetimes than what would be returned by `key`\n     /// or `val`.\n@@ -831,7 +835,7 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, KV, NodeType> {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, KV, NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType> {\n     /// Turns the handle into mutable references to the key and value it points at. This is\n     /// necessary because the returned pointers have larger lifetimes than what would be returned\n     /// by `key_mut` or `val_mut`.\n@@ -848,15 +852,16 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, KV, NodeType> {\n     /// Convert this handle into one pointing at the edge immediately to the left of the key/value\n     /// pair pointed-to by this handle. This is useful because it returns a reference with larger\n     /// lifetime than `left_edge`.\n-    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+    pub fn into_left_edge(self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n             index: self.index\n         }\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, KV, NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+                                                                         NodeType> {\n     // These are fine to include, but are currently unneeded.\n     //\n     // /// Returns a reference to the key pointed-to by this handle. This doesn't return a\n@@ -874,7 +879,8 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, KV, NodeType> {\n+impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<NodeRef, handle::KV,\n+                                                                            NodeType> {\n     /// Returns a mutable reference to the key pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n@@ -890,10 +896,10 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, KV, NodeType> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, handle::KV, NodeType> {\n     /// Gets the handle pointing to the edge immediately to the left of the key/value pair pointed\n     /// to by this handle.\n-    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+    pub fn left_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n             index: self.index\n@@ -902,15 +908,15 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>, NodeType> Handle<NodeRef, KV, NodeType\n \n     /// Gets the handle pointing to the edge immediately to the right of the key/value pair pointed\n     /// to by this handle.\n-    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, Edge, NodeType> {\n+    pub fn right_edge<'a>(&'a mut self) -> Handle<&'a mut Node<K, V>, handle::Edge, NodeType> {\n         Handle {\n             node: &mut *self.node,\n             index: self.index + 1\n         }\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, KV, Leaf> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Leaf> {\n     /// Removes the key/value pair at the handle's location.\n     ///\n     /// # Panics (in debug build)\n@@ -921,7 +927,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, KV, Leaf> {\n     }\n }\n \n-impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, KV, Internal> {\n+impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::KV, handle::Internal> {\n     /// Steal! Stealing is roughly analogous to a binary tree rotation.\n     /// In this case, we're \"rotating\" right.\n     unsafe fn steal_rightward(&mut self) {\n@@ -1004,7 +1010,8 @@ impl<K, V> Node<K, V> {\n     /// # Panics (in debug build)\n     ///\n     /// Panics if the given index is out of bounds.\n-    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, KV, LeafOrInternal> {\n+    pub fn kv_handle(&mut self, index: uint) -> Handle<&mut Node<K, V>, handle::KV,\n+                                                       handle::LeafOrInternal> {\n         // Necessary for correctness, but in a private module\n         debug_assert!(index < self.len(), \"kv_handle index out of bounds\");\n         Handle {"}, {"sha": "dc8313386b9988bde3a2e5f241d27edf8b7b8dcd", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "patch": "@@ -51,18 +51,21 @@\n \n #![doc(primitive = \"str\")]\n \n-use core::prelude::*;\n-\n pub use self::MaybeOwned::*;\n use self::RecompositionState::*;\n use self::DecompositionType::*;\n \n use core::borrow::{BorrowFrom, Cow, ToOwned};\n+use core::clone::Clone;\n use core::default::Default;\n use core::fmt;\n use core::hash;\n-use core::cmp;\n-use core::iter::AdditiveIterator;\n+use core::char::Char;\n+use core::cmp::{mod, Eq, Equiv, Ord, Ordering, PartialEq, PartialOrd};\n+use core::iter::{range, AdditiveIterator, Iterator, IteratorExt};\n+use core::kinds::Sized;\n+use core::option::Option::{mod, Some, None};\n+use core::slice::{AsSlice, SliceExt};\n \n use ring_buf::RingBuf;\n use string::String;"}, {"sha": "f1c8e8950a22eed6915218d39004924fa008dcd6", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=f95e0c21aaf752cf1401c872dfb1d8de1a22b6f2", "patch": "@@ -67,18 +67,18 @@\n //! }\n //! ```\n \n-use string::String;\n-use hash;\n+use core::prelude::*;\n+use libc;\n+\n use fmt;\n+use hash;\n use kinds::marker;\n use mem;\n-use core::prelude::*;\n-\n use ptr;\n-use raw::Slice;\n-use slice;\n+use slice::{mod, ImmutableIntSlice};\n use str;\n-use libc;\n+use string::String;\n+\n \n /// The representation of a C String.\n ///\n@@ -210,7 +210,7 @@ impl CString {\n     #[inline]\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         unsafe {\n-            mem::transmute(Slice { data: self.buf, len: self.len() + 1 })\n+            slice::from_raw_buf(&self.buf, self.len() + 1).as_unsigned()\n         }\n     }\n \n@@ -219,7 +219,7 @@ impl CString {\n     #[inline]\n     pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n         unsafe {\n-            mem::transmute(Slice { data: self.buf, len: self.len() })\n+            slice::from_raw_buf(&self.buf, self.len()).as_unsigned()\n         }\n     }\n "}]}