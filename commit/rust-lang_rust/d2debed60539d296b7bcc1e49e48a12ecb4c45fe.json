{"sha": "d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZGViZWQ2MDUzOWQyOTZiN2JjYzFlNDllNDhhMTJlY2I0YzQ1ZmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-12T01:54:49Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-12T02:00:52Z"}, "message": "core: Change the argument order for vec::contains, vec::count", "tree": {"sha": "ced22bb39e74c728203e7d45d490b47cd54e8d54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ced22bb39e74c728203e7d45d490b47cd54e8d54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "html_url": "https://github.com/rust-lang/rust/commit/d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1040b470786b55e5b7ca079baeb4b75c87c2531f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1040b470786b55e5b7ca079baeb4b75c87c2531f", "html_url": "https://github.com/rust-lang/rust/commit/1040b470786b55e5b7ca079baeb4b75c87c2531f"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "b8bea7967c93e3738389e6e5466b051248c2b51e", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -800,7 +800,7 @@ fn cmd_search(c: cargo) {\n     let tags = vec::slice(c.opts.free, 3u, vec::len(c.opts.free));\n     for_each_package(c, { |s, p|\n         if (str::contains(p.name, name) || name == \"*\") &&\n-            vec::all(tags, { |t| vec::contains(t, p.tags) }) {\n+            vec::all(tags, { |t| vec::contains(p.tags, t) }) {\n             print_pkg(s, p);\n             n += 1;\n         }"}, {"sha": "ca5eb3329312ee9d5581a89505f2763b79ae31df", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -97,7 +97,7 @@ fn iter_crate_data(cstore: cstore, i: fn(ast::crate_num, crate_metadata)) {\n }\n \n fn add_used_crate_file(cstore: cstore, lib: str) {\n-    if !vec::contains(lib, p(cstore).used_crate_files) {\n+    if !vec::contains(p(cstore).used_crate_files, lib) {\n         p(cstore).used_crate_files += [lib];\n     }\n }\n@@ -109,7 +109,7 @@ fn get_used_crate_files(cstore: cstore) -> [str] {\n fn add_used_library(cstore: cstore, lib: str) -> bool {\n     assert lib != \"\";\n \n-    if vec::contains(lib, p(cstore).used_libraries) { ret false; }\n+    if vec::contains(p(cstore).used_libraries, lib) { ret false; }\n     p(cstore).used_libraries += [lib];\n     ret true;\n }"}, {"sha": "8bce6ba4a14a21ed9193692b13d092d18db25c02", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -98,7 +98,7 @@ fn check_exhaustive(tcx: ty::ctxt, sp:span, scrut_ty:ty::t, pats:[@pat]) {\n          }\n     }\n     fn not_represented(v: [def_id], &&vinfo: variant_info) -> bool {\n-        !vec::contains(vinfo.id, v)\n+        !vec::contains(v, vinfo.id)\n     }\n     // Could be more efficient (bitvectors?)\n     alt vec::find(variants, bind not_represented(represented,_)) {"}, {"sha": "9a97fb71060445def9bd5033fa90377a7082e9b0", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -109,7 +109,7 @@ fn check_fn_cap_clause(cx: ctx,\n         let check_var = fn@(&&cap_item: @capture_item) {\n             let cap_def = cx.tcx.def_map.get(cap_item.id);\n             let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n-            if !vec::contains(cap_def_id, freevar_ids) {\n+            if !vec::contains(freevar_ids, cap_def_id) {\n                 let ty = ty::node_id_to_type(cx.tcx, cap_def_id);\n                 checker(cx, ty, cap_item.span);\n             }"}, {"sha": "20f62d4a4a12cf2ae466eb2c80e31c0ad28c098f", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -317,7 +317,7 @@ fn check_unused_imports(e: @env) {\n     e.imports.items {|k, v|\n         alt v {\n             resolved(_, _, _, _, name, sp) {\n-              if !vec::contains(k, e.used_imports.data) {\n+              if !vec::contains(e.used_imports.data, k) {\n                 e.sess.span_warn(sp, \"unused import \" + name);\n               }\n             }\n@@ -1279,7 +1279,7 @@ fn found_view_item(e: env, id: node_id) -> def {\n \n fn lookup_import(e: env, defid: def_id, ns: namespace) -> option<def> {\n     // Imports are simply ignored when resolving themselves.\n-    if vec::contains(defid.node, e.ignored_imports) { ret none; }\n+    if vec::contains(e.ignored_imports, defid.node) { ret none; }\n     alt e.imports.get(defid.node) {\n       todo(node_id, name, path, span, scopes) {\n         resolve_import(e, local_def(node_id), name, *path, span, scopes);\n@@ -1344,7 +1344,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n                       ns: namespace, dr: dir) -> option<glob_imp_def> {\n         alt def.item.node {\n           ast::view_item_import_glob(_, id) {\n-            if vec::contains(id, e.ignored_imports) { ret none; }\n+            if vec::contains(e.ignored_imports, id) { ret none; }\n           }\n           _ {\n             e.sess.span_bug(sp, \"lookup_in_globs: not a glob\");"}, {"sha": "1f7709b1fc8e52c48739ec76ce17696c2b64d1ed", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -1387,7 +1387,7 @@ fn occurs_check_fails(tcx: ctxt, sp: option<span>, vid: int, rt: t) ->\n     if !type_has_vars(rt) { ret false; }\n \n     // Occurs check!\n-    if vec::contains(vid, vars_in_type(tcx, rt)) {\n+    if vec::contains(vars_in_type(tcx, rt), vid) {\n         alt sp {\n           some(s) {\n             // Maybe this should be span_err -- however, there's an"}, {"sha": "6a49e288701c42bf7229c5c415c364e3b82f451d", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -2656,7 +2656,7 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           }\n           _ {}\n         }\n-        if vec::contains(disr_val, disr_vals) {\n+        if vec::contains(disr_vals, disr_val) {\n             ccx.tcx.sess.span_err(v.span,\n                                   \"discriminator value already exists.\");\n         }"}, {"sha": "38809da7eb4419951ca1e2ae8a0410349a3e73c2", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2debed60539d296b7bcc1e49e48a12ecb4c45fe/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=d2debed60539d296b7bcc1e49e48a12ecb4c45fe", "patch": "@@ -693,7 +693,7 @@ Function: contains\n \n Return true if a vector contains an element with the given value\n */\n-fn contains<T>(x: T, v: [T]) -> bool {\n+fn contains<T>(v: [T], x: T) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n@@ -703,7 +703,7 @@ Function: count\n \n Returns the number of elements that are equal to a given value\n */\n-fn count<T>(x: T, v: [const T]) -> uint {\n+fn count<T>(v: [const T], x: T) -> uint {\n     let cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;"}]}