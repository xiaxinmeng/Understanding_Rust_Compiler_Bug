{"sha": "5eec666c8c4be3706a79755e6cb1119990390c79", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZWM2NjZjOGM0YmUzNzA2YTc5NzU1ZTZjYjExMTk5OTAzOTBjNzk=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-12T22:55:44Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-17T19:26:30Z"}, "message": "libcollections: use BorrowFrom in TreeSet, Map\n\nThis commit generalizes methods like `get` and `remove` for `TreeMap`\nand `TreeSet` to use the new `std::borrow` infrastructure.\n\n[breaking-change]", "tree": {"sha": "158941733388bf3726d825d04f1bd94b9bf182ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/158941733388bf3726d825d04f1bd94b9bf182ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eec666c8c4be3706a79755e6cb1119990390c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eec666c8c4be3706a79755e6cb1119990390c79", "html_url": "https://github.com/rust-lang/rust/commit/5eec666c8c4be3706a79755e6cb1119990390c79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eec666c8c4be3706a79755e6cb1119990390c79/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ab22355d4d186d5eec52be0f980034685411d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab22355d4d186d5eec52be0f980034685411d04", "html_url": "https://github.com/rust-lang/rust/commit/4ab22355d4d186d5eec52be0f980034685411d04"}], "stats": {"total": 73, "additions": 56, "deletions": 17}, "files": [{"sha": "119268c27eeac9814637396c4481a2af7240c269", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5eec666c8c4be3706a79755e6cb1119990390c79/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eec666c8c4be3706a79755e6cb1119990390c79/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=5eec666c8c4be3706a79755e6cb1119990390c79", "patch": "@@ -11,6 +11,8 @@\n use core::prelude::*;\n \n use alloc::boxed::Box;\n+\n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -188,16 +190,16 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n     fn default() -> TreeMap<K, V> { TreeMap::new() }\n }\n \n-impl<K: Ord, V> Index<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> Index<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index<'a>(&'a self, i: &K) -> &'a V {\n+    fn index<'a>(&'a self, i: &Q) -> &'a V {\n         self.get(i).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V> IndexMut<K, V> for TreeMap<K, V> {\n+impl<K: Ord, Sized? Q, V> IndexMut<Q, V> for TreeMap<K, V> where Q: BorrowFrom<K> + Ord {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &K) -> &'a mut V {\n+    fn index_mut<'a>(&'a mut self, i: &Q) -> &'a mut V {\n         self.get_mut(i).expect(\"no entry found for key\")\n     }\n }\n@@ -446,6 +448,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -458,12 +463,17 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n-        tree_find_with(&self.root, |k2| key.cmp(k2))\n+    pub fn get<Sized? Q>(&self, key: &Q) -> Option<&V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with(&self.root, |k2| key.cmp(BorrowFrom::borrow_from(k2)))\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -476,7 +486,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains_key(&self, key: &K) -> bool {\n+    pub fn contains_key<Sized? Q>(&self, key: &Q) -> bool\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         self.get(key).is_some()\n     }\n \n@@ -488,6 +500,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Returns a mutable reference to the value corresponding to the key.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -503,8 +518,10 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n-        tree_find_with_mut(&mut self.root, |x| key.cmp(x))\n+    pub fn get_mut<Sized? Q>(&mut self, key: &Q) -> Option<&mut V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n+        tree_find_with_mut(&mut self.root, |x| key.cmp(BorrowFrom::borrow_from(x)))\n     }\n \n     /// Deprecated: Renamed to `insert`.\n@@ -545,6 +562,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// Removes a key from the map, returning the value at the key if the key\n     /// was previously in the map.\n     ///\n+    /// The key may be any borrowed form of the map's key type, but the ordering\n+    /// on the borrowed form *must* match the ordering on the key type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -556,7 +576,9 @@ impl<K: Ord, V> TreeMap<K, V> {\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, key: &K) -> Option<V> {\n+    pub fn remove<Sized? Q>(&mut self, key: &Q) -> Option<V>\n+        where Q: BorrowFrom<K> + Ord\n+    {\n         let ret = remove(&mut self.root, key);\n         if ret.is_some() { self.length -= 1 }\n         ret\n@@ -589,6 +611,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!((*ua.unwrap()).as_slice(), \"Curl-Rust/0.1\");\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with(&self, f:|&K| -> Ordering) -> Option<&V> {\n         tree_find_with(&self.root, f)\n     }\n@@ -613,6 +636,7 @@ impl<K, V> TreeMap<K, V> {\n     /// assert_eq!(t.get(&\"User-Agent\"), Some(&new_ua));\n     /// ```\n     #[inline]\n+    #[experimental = \"likely to be renamed, may be removed\"]\n     pub fn find_with_mut<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n         tree_find_with_mut(&mut self.root, f)\n     }\n@@ -1168,10 +1192,11 @@ fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n     }\n }\n \n-fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n-                          key: &K) -> Option<V> {\n+fn remove<K, Sized? Q, V>(node: &mut Option<Box<TreeNode<K, V>>>, key: &Q) -> Option<V>\n+    where K: Ord, Q: BorrowFrom<K> + Ord\n+{\n     fn heir_swap<K: Ord, V>(node: &mut Box<TreeNode<K, V>>,\n-                                 child: &mut Option<Box<TreeNode<K, V>>>) {\n+                            child: &mut Option<Box<TreeNode<K, V>>>) {\n         // *could* be done without recursion, but it won't borrow check\n         for x in child.iter_mut() {\n             if x.right.is_some() {\n@@ -1188,7 +1213,7 @@ fn remove<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n         return None; // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (ret, rebalance) = match key.cmp(&save.key) {\n+        let (ret, rebalance) = match key.cmp(BorrowFrom::borrow_from(&save.key)) {\n           Less => (remove(&mut save.left, key), true),\n           Greater => (remove(&mut save.right, key), true),\n           Equal => {\n@@ -1918,4 +1943,3 @@ mod bench {\n         bench_iter(b, 100000);\n     }\n }\n-"}, {"sha": "6988b929df689ef3b1d259ab5c7fe22bda90f574", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5eec666c8c4be3706a79755e6cb1119990390c79/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eec666c8c4be3706a79755e6cb1119990390c79/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=5eec666c8c4be3706a79755e6cb1119990390c79", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::borrow::BorrowFrom;\n use core::default::Default;\n use core::fmt;\n use core::fmt::Show;\n@@ -396,6 +397,10 @@ impl<T: Ord> TreeSet<T> {\n \n     /// Returns `true` if the set contains a value.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -407,7 +412,9 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn contains(&self, value: &T) -> bool {\n+    pub fn contains<Sized? Q>(&self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n         self.map.contains_key(value)\n     }\n \n@@ -519,6 +526,10 @@ impl<T: Ord> TreeSet<T> {\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    ///\n     /// # Example\n     ///\n     /// ```\n@@ -532,7 +543,11 @@ impl<T: Ord> TreeSet<T> {\n     /// ```\n     #[inline]\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n-    pub fn remove(&mut self, value: &T) -> bool { self.map.remove(value).is_some() }\n+    pub fn remove<Sized? Q>(&mut self, value: &Q) -> bool\n+        where Q: Ord + BorrowFrom<T>\n+    {\n+        self.map.remove(value).is_some()\n+    }\n }\n \n /// A lazy forward iterator over a set."}]}