{"sha": "a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "node_id": "C_kwDOAAsO6NoAKGExZmM3MTE5NmE1NTU0ZWFmYzVkZDlhMWI0ZTBjMTU5NzE3MTQxZTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-27T10:23:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-27T10:23:32Z"}, "message": "Auto merge of #106177 - matthiaskrgr:rollup-oe7z8ix, r=matthiaskrgr\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #105515 (Account for macros in const generics)\n - #106146 (Readme: update section on how to run `x.py`)\n - #106150 (Detect when method call on LHS might be shadowed)\n - #106174 (Remove unused empty CSS rules in ayu theme)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c7b9ae72ce39800fd5c15690935b5754162cc7da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7b9ae72ce39800fd5c15690935b5754162cc7da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "html_url": "https://github.com/rust-lang/rust/commit/a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ca50032ce7271ebbe6f4e3f766c686f6204116c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ca50032ce7271ebbe6f4e3f766c686f6204116c", "html_url": "https://github.com/rust-lang/rust/commit/0ca50032ce7271ebbe6f4e3f766c686f6204116c"}, {"sha": "d5810e83391f96a2af1b8f1be6841656fbe75270", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5810e83391f96a2af1b8f1be6841656fbe75270", "html_url": "https://github.com/rust-lang/rust/commit/d5810e83391f96a2af1b8f1be6841656fbe75270"}], "stats": {"total": 333, "additions": 306, "deletions": 27}, "files": [{"sha": "ac39435a8c7fb9338a0f278452e2d8ff8afa525d", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -20,22 +20,23 @@ Read [\"Installation\"] from [The Book].\n The Rust build system uses a Python script called `x.py` to build the compiler,\n which manages the bootstrapping process. It lives at the root of the project.\n \n-The `x.py` command can be run directly on most systems in the following format:\n+The `x.py` command can be run directly on most Unix systems in the following format:\n \n ```sh\n ./x.py <subcommand> [flags]\n ```\n \n-This is how the documentation and examples assume you are running `x.py`.\n-\n-Systems such as Ubuntu 20.04 LTS do not create the necessary `python` command by default when Python is installed that allows `x.py` to be run directly. In that case, you can either create a symlink for `python` (Ubuntu provides the `python-is-python3` package for this), or run `x.py` using Python itself:\n+This is how the documentation and examples assume you are running `x.py`. Some alternative ways are:\n \n ```sh\n-# Python 3\n-python3 x.py <subcommand> [flags]\n+# On a Unix shell if you don't have the necessary `python3` command\n+./x <subcommand> [flags]\n+\n+# On the Windows Command Prompt (if .py files are configured to run Python)\n+x.py <subcommand> [flags]\n \n-# Python 2.7\n-python2.7 x.py <subcommand> [flags]\n+# You can also run Python yourself, e.g.:\n+python x.py <subcommand> [flags]\n ```\n \n More information about `x.py` can be found"}, {"sha": "0335c45a946d55322d9fa2f52521a499442fe241", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -1,5 +1,6 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -30,12 +31,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        _error: Option<TypeError<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n+        self.annotate_alternative_method_deref(err, expr, error);\n+\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n@@ -316,6 +319,162 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn annotate_alternative_method_deref(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let Some(TypeError::Sorts(ExpectedFound { expected, .. })) = error else {return;};\n+        let Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Assign(lhs, rhs, _), ..\n+                })) = self.tcx.hir().find(parent) else {return; };\n+        if rhs.hir_id != expr.hir_id || expected.is_closure() {\n+            return;\n+        }\n+        let hir::ExprKind::Unary(hir::UnOp::Deref, deref) = lhs.kind else { return; };\n+        let hir::ExprKind::MethodCall(path, base, args, _) = deref.kind else { return; };\n+        let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n+\n+        let Ok(pick) = self\n+            .probe_for_name(\n+                probe::Mode::MethodCall,\n+                path.ident,\n+                probe::IsSuggestion(true),\n+                self_ty,\n+                deref.hir_id,\n+                probe::ProbeScope::TraitsInScope,\n+            ) else {\n+                return;\n+            };\n+        let in_scope_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::TraitsInScope,\n+        );\n+        let other_methods_in_scope: Vec<_> =\n+            in_scope_methods.iter().filter(|c| c.item.def_id != pick.item.def_id).collect();\n+\n+        let all_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        );\n+        let suggestions: Vec<_> = all_methods\n+            .into_iter()\n+            .filter(|c| c.item.def_id != pick.item.def_id)\n+            .map(|c| {\n+                let m = c.item;\n+                let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n+                    self.var_for_def(deref.span, param)\n+                });\n+                vec![\n+                    (\n+                        deref.span.until(base.span),\n+                        format!(\n+                            \"{}({}\",\n+                            with_no_trimmed_paths!(\n+                                self.tcx.def_path_str_with_substs(m.def_id, substs,)\n+                            ),\n+                            match self.tcx.fn_sig(m.def_id).input(0).skip_binder().kind() {\n+                                ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n+                                ty::Ref(_, _, _) => \"&\",\n+                                _ => \"\",\n+                            },\n+                        ),\n+                    ),\n+                    match &args[..] {\n+                        [] => (base.span.shrink_to_hi().with_hi(deref.span.hi()), \")\".to_string()),\n+                        [first, ..] => (base.span.between(first.span), \", \".to_string()),\n+                    },\n+                ]\n+            })\n+            .collect();\n+        if suggestions.is_empty() {\n+            return;\n+        }\n+        let mut path_span: MultiSpan = path.ident.span.into();\n+        path_span.push_span_label(\n+            path.ident.span,\n+            with_no_trimmed_paths!(format!(\n+                \"refers to `{}`\",\n+                self.tcx.def_path_str(pick.item.def_id),\n+            )),\n+        );\n+        let container_id = pick.item.container_id(self.tcx);\n+        let container = with_no_trimmed_paths!(self.tcx.def_path_str(container_id));\n+        for def_id in pick.import_ids {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+            path_span.push_span_label(\n+                self.tcx.hir().span(hir_id),\n+                format!(\"`{container}` imported here\"),\n+            );\n+        }\n+        let tail = with_no_trimmed_paths!(match &other_methods_in_scope[..] {\n+            [] => return,\n+            [candidate] => format!(\n+                \"the method of the same name on {} `{}`\",\n+                match candidate.kind {\n+                    probe::CandidateKind::InherentImplCandidate(..) => \"the inherent impl for\",\n+                    _ => \"trait\",\n+                },\n+                self.tcx.def_path_str(candidate.item.container_id(self.tcx))\n+            ),\n+            [.., last] if other_methods_in_scope.len() < 5 => {\n+                format!(\n+                    \"the methods of the same name on {} and `{}`\",\n+                    other_methods_in_scope[..other_methods_in_scope.len() - 1]\n+                        .iter()\n+                        .map(|c| format!(\n+                            \"`{}`\",\n+                            self.tcx.def_path_str(c.item.container_id(self.tcx))\n+                        ))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    self.tcx.def_path_str(last.item.container_id(self.tcx))\n+                )\n+            }\n+            _ => format!(\n+                \"the methods of the same name on {} other traits\",\n+                other_methods_in_scope.len()\n+            ),\n+        });\n+        err.span_note(\n+            path_span,\n+            &format!(\n+                \"the `{}` call is resolved to the method in `{container}`, shadowing {tail}\",\n+                path.ident,\n+            ),\n+        );\n+        if suggestions.len() > other_methods_in_scope.len() {\n+            err.note(&format!(\n+                \"additionally, there are {} other available methods that aren't in scope\",\n+                suggestions.len() - other_methods_in_scope.len()\n+            ));\n+        }\n+        err.multipart_suggestions(\n+            &format!(\n+                \"you might have meant to call {}; you can use the fully-qualified path to call {} \\\n+                 explicitly\",\n+                if suggestions.len() == 1 {\n+                    \"the other method\"\n+                } else {\n+                    \"one of the other methods\"\n+                },\n+                if suggestions.len() == 1 { \"it\" } else { \"one of them\" },\n+            ),\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants("}, {"sha": "6b3fa664d9c5a9d0badbe66b9445dd9d737dfac9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct Candidate<'tcx> {\n+pub(crate) struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n     //\n@@ -131,13 +131,13 @@ struct Candidate<'tcx> {\n     // if `T: Sized`.\n     xform_self_ty: Ty<'tcx>,\n     xform_ret_ty: Option<Ty<'tcx>>,\n-    item: ty::AssocItem,\n-    kind: CandidateKind<'tcx>,\n-    import_ids: SmallVec<[LocalDefId; 1]>,\n+    pub(crate) item: ty::AssocItem,\n+    pub(crate) kind: CandidateKind<'tcx>,\n+    pub(crate) import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n #[derive(Debug, Clone)]\n-enum CandidateKind<'tcx> {\n+pub(crate) enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n         // Normalize obligations\n@@ -322,6 +322,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(crate) fn probe_for_name_many(\n+        &self,\n+        mode: Mode,\n+        item_name: Ident,\n+        is_suggestion: IsSuggestion,\n+        self_ty: Ty<'tcx>,\n+        scope_expr_id: hir::HirId,\n+        scope: ProbeScope,\n+    ) -> Vec<Candidate<'tcx>> {\n+        self.probe_op(\n+            item_name.span,\n+            mode,\n+            Some(item_name),\n+            None,\n+            is_suggestion,\n+            self_ty,\n+            scope_expr_id,\n+            scope,\n+            |probe_cx| {\n+                Ok(probe_cx\n+                    .inherent_candidates\n+                    .into_iter()\n+                    .chain(probe_cx.extension_candidates)\n+                    .collect())\n+            },\n+        )\n+        .unwrap()\n+    }\n+\n     fn probe_op<OP, R>(\n         &'a self,\n         span: Span,"}, {"sha": "a7a5234049fe63db04d6789e5a509238dd4346ae", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -1142,6 +1142,7 @@ impl UnusedDelimLint for UnusedBraces {\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n                             && !value.span.from_expansion()\n+                            && !inner.span.from_expansion()\n                         {\n                             self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n                         }"}, {"sha": "b64300277508dd15af81644f540beca9ccafbcfb", "filename": "src/ci/run.sh", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -45,14 +45,6 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if command -v python > /dev/null; then\n-    PYTHON=\"python\"\n-elif command -v python3 > /dev/null; then\n-    PYTHON=\"python3\"\n-else\n-    PYTHON=\"python2\"\n-fi\n-\n if ! isCI || isCiBranch auto || isCiBranch beta || isCiBranch try || isCiBranch try-perf; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.metrics\"\n@@ -201,7 +193,7 @@ if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n     mv metrics.json build\n   fi\n \n-  CARGO_INCREMENTAL=0 $PYTHON ../x.py check\n+  CARGO_INCREMENTAL=0 ../x check\n fi\n \n sccache --show-stats || true"}, {"sha": "7d7bdfb92ce2d996226a87b135045c0a8f08104e", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -183,11 +183,7 @@ individually rather than as a group) */\n /* FIXME: these rules should be at the bottom of the file but currently must be\n above the `@media (max-width: 700px)` rules due to a bug in the css checker */\n /* see https://github.com/rust-lang/rust/pull/71237#issuecomment-618170143 */\n-pre.rust .lifetime {}\n-pre.rust .kw {}\n #search-tabs > button:hover, #search-tabs > button.selected {}\n-pre.rust .self, pre.rust .bool-val, pre.rust .prelude-val, pre.rust .attribute {}\n-pre.rust .kw-2, pre.rust .prelude-ty {}\n \n #settings-menu > a img {\n \tfilter: invert(100);"}, {"sha": "bfee95378bffee699ed674f2b8641f9933bda49d", "filename": "src/test/ui/lint/unused_braces_macro.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Flint%2Funused_braces_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Flint%2Funused_braces_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces_macro.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,6 @@\n+// build-pass\n+pub fn foo<const BAR: bool> () {}\n+\n+fn main() {\n+    foo::<{cfg!(feature = \"foo\")}>();\n+}"}, {"sha": "dab99fbacd9e681b59e7eb97427bd0f4fca3f743", "filename": "src/test/ui/suggestions/shadowed-lplace-method-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,23 @@\n+#![allow(unused)]\n+\n+struct X {\n+    x: (),\n+}\n+pub trait A {\n+    fn foo(&mut self, _: usize) -> &mut ();\n+}\n+impl A for X {\n+    fn foo(&mut self, _: usize) -> &mut () {\n+        &mut self.x\n+    }\n+}\n+impl X {\n+    fn foo(&mut self, _: usize) -> &mut Self {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let mut x = X { x: () };\n+    *x.foo(0) = (); //~ ERROR E0308\n+}"}, {"sha": "94eef15f3306e90af451340d92e1dee0b2b0b47e", "filename": "src/test/ui/suggestions/shadowed-lplace-method-2.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,25 @@\n+error[E0308]: mismatched types\n+  --> $DIR/shadowed-lplace-method-2.rs:22:17\n+   |\n+LL |     *x.foo(0) = ();\n+   |     ---------   ^^ expected struct `X`, found `()`\n+   |     |\n+   |     expected due to the type of this binding\n+   |\n+note: the `foo` call is resolved to the method in `X`, shadowing the method of the same name on trait `A`\n+  --> $DIR/shadowed-lplace-method-2.rs:22:8\n+   |\n+LL |     *x.foo(0) = ();\n+   |        ^^^ refers to `X::foo`\n+help: you might have meant to call the other method; you can use the fully-qualified path to call it explicitly\n+   |\n+LL |     *<_ as A>::foo(&mut x, 0) = ();\n+   |      ++++++++++++++++++  ~\n+help: try wrapping the expression in `X`\n+   |\n+LL |     *x.foo(0) = X { x: () };\n+   |                 ++++++    +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "740ac77ee0c675d7fc7257dce53f4932e5947986", "filename": "src/test/ui/suggestions/shadowed-lplace-method.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *std::cell::RefCell::<_>::borrow_mut(&rc) = false; //~ ERROR E0308\n+}"}, {"sha": "6bf12879e6f28dcc5c5c354b7917b78f9a083854", "filename": "src/test/ui/suggestions/shadowed-lplace-method.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *rc.borrow_mut() = false; //~ ERROR E0308\n+}"}, {"sha": "91d0d1200d4362bd3ddae84fd9c8d2b2a3d657b5", "filename": "src/test/ui/suggestions/shadowed-lplace-method.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a1fc71196a5554eafc5dd9a1b4e0c159717141e0/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr?ref=a1fc71196a5554eafc5dd9a1b4e0c159717141e0", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: mismatched types\n+  --> $DIR/shadowed-lplace-method.rs:9:24\n+   |\n+LL |     *rc.borrow_mut() = false;\n+   |     ----------------   ^^^^^ expected struct `Rc`, found `bool`\n+   |     |\n+   |     expected due to the type of this binding\n+   |\n+   = note: expected struct `Rc<RefCell<bool>>`\n+                found type `bool`\n+note: the `borrow_mut` call is resolved to the method in `std::borrow::BorrowMut`, shadowing the method of the same name on the inherent impl for `std::cell::RefCell<T>`\n+  --> $DIR/shadowed-lplace-method.rs:9:9\n+   |\n+LL | use std::borrow::BorrowMut;\n+   |     ---------------------- `std::borrow::BorrowMut` imported here\n+...\n+LL |     *rc.borrow_mut() = false;\n+   |         ^^^^^^^^^^ refers to `std::borrow::BorrowMut::borrow_mut`\n+help: you might have meant to call the other method; you can use the fully-qualified path to call it explicitly\n+   |\n+LL |     *std::cell::RefCell::<_>::borrow_mut(&rc) = false;\n+   |      +++++++++++++++++++++++++++++++++++++  ~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}