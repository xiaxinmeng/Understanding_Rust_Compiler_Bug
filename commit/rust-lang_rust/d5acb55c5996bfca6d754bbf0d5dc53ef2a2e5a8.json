{"sha": "d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YWNiNTVjNTk5NmJmY2E2ZDc1NGJiZjBkNWRjNTNlZjJhMmU1YTg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-23T17:35:46Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-04-24T07:39:15Z"}, "message": "regression test.", "tree": {"sha": "3861bc1d5686d71ab4eef5b0a2c563f77ba92933", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3861bc1d5686d71ab4eef5b0a2c563f77ba92933"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "html_url": "https://github.com/rust-lang/rust/commit/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f987956b4d173c9af26fbf2aafcc661abcc14cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f987956b4d173c9af26fbf2aafcc661abcc14cb", "html_url": "https://github.com/rust-lang/rust/commit/8f987956b4d173c9af26fbf2aafcc661abcc14cb"}], "stats": {"total": 265, "additions": 265, "deletions": 0}, "files": [{"sha": "540cbd50e9d57d80374b5c705aeec7a0858c825c", "filename": "src/test/run-pass/issue-23611-enum-swap-in-drop.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23611-enum-swap-in-drop.rs?ref=d5acb55c5996bfca6d754bbf0d5dc53ef2a2e5a8", "patch": "@@ -0,0 +1,265 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 23611: this test is ensuring that, for an instance `X` of the\n+// enum `E`, if you swap in a different variant during the execution\n+// of the `<E as Drop>::drop`, then the appropriate substructure will\n+// be torn down after the `<E as Drop>::drop` method returns.\n+\n+use std::cell::RefCell;\n+use std::mem;\n+\n+use self::d::D;\n+\n+pub fn main() {\n+    let log = RefCell::new(vec![]);\n+    d::println(&format!(\"created empty log\"));\n+    test(&log);\n+\n+    // println!(\"log: {:?}\", &log.borrow()[..]);\n+    assert_eq!(\n+        &log.borrow()[..],\n+        [\n+            //                                         created empty log\n+            // +-- Make D(test_1, 10000000)\n+            // | +-- Make D(g_b_5, 50000001)\n+            // | |                                     in g_B(b2b0) from E::drop, b=b4b0\n+            // | +-- Drop D(g_b_5, 50000001)\n+            50000001,\n+            // |\n+            // | +-- Make D(drop_6, 60000002)\n+            // | | +-- Make D(g_b_5, 50000003)\n+            // | | |                                   in g_B(b2b0) from E::drop, b=b4b1\n+            // | | +-- Drop D(g_b_5, 50000003)\n+            50000003,\n+            // | |\n+            // | | +-- Make D(GaspB::drop_3, 30000004)\n+            // | | | +-- Make D(g_b_5, 50000005)\n+            // | | | |                                 in g_B(b4b2) from GaspB::drop\n+            // | | | +-- Drop D(g_b_5, 50000005)\n+            50000005,\n+            // | | |\n+            // | | +-- Drop D(GaspB::drop_3, 30000004)\n+            30000004,\n+            // | |\n+            // +-- Drop D(test_1, 10000000)\n+            10000000,\n+            //   |\n+            // +-- Make D(GaspA::drop_2, 20000006)\n+            // | | +-- Make D(f_a_4, 40000007)\n+            // | | |                                   in f_A(a3a0) from GaspA::drop\n+            // | | +-- Drop D(f_a_4, 40000007)\n+            40000007,\n+            // | |\n+            // +-- Drop D(GaspA::drop_2, 20000006)\n+            20000006,\n+            //   |\n+            //   +-- Drop D(drop_6, 60000002)\n+            60000002\n+            //\n+                ]);\n+\n+    // For reference purposes, the old (incorrect) behavior would produce the following\n+    // output, which you can compare to the above:\n+    //\n+    //                                             created empty log\n+    // +-- Make D(test_1, 10000000)\n+    // | +-- Make D(g_b_5, 50000001)\n+    // | |                                     in g_B(b2b0) from E::drop, b=b4b0\n+    // | +-- Drop D(g_b_5, 50000001)\n+    // |\n+    // | +-- Make D(drop_6, 60000002)\n+    // | | +-- Make D(g_b_5, 50000003)\n+    // | | |                                   in g_B(b2b0) from E::drop, b=b4b1\n+    // | | +-- Drop D(g_b_5, 50000003)\n+    // | |\n+    // | | +-- Make D(GaspB::drop_3, 30000004)\n+    // | | | +-- Make D(g_b_5, 50000005)\n+    // | | | |                                 in g_B(b4b2) from GaspB::drop\n+    // | | | +-- Drop D(g_b_5, 50000005)\n+    // | | |\n+    // | | +-- Drop D(GaspB::drop_3, 30000004)\n+    // | |\n+    // +-- Drop D(test_1, 10000000)\n+    //   |\n+    // +-- Make D(GaspB::drop_3, 30000006)\n+    // | | +-- Make D(f_a_4, 40000007)\n+    // | | |                                   in f_A(a3a0) from GaspB::drop\n+    // | | +-- Drop D(f_a_4, 40000007)\n+    // | |\n+    // +-- Drop D(GaspB::drop_3, 30000006)\n+    //   |\n+    //   +-- Drop D(drop_6, 60000002)\n+\n+    // Note that this calls f_A from GaspB::drop (and thus creates a D\n+    // with a uid incorporating the origin of GaspB's drop that\n+    // surrounds the f_A invocation), but the code as written only\n+    // ever hands f_A off to instances of GaspA, and thus one should\n+    // be able to prove the invariant that f_A is *only* invoked from\n+    // from an instance of GaspA (either via the GaspA drop\n+    // implementation or the E drop implementaton). Yet the old (bad)\n+    // behavior allowed a call to f_A to leak in while we are tearing\n+    // down a value of type GaspB.\n+}\n+\n+fn test<'a>(log: d::Log<'a>) {\n+    let _e = E::B(GaspB(g_b, 0xB4B0, log, D::new(\"test\", 1, log)), true);\n+}\n+\n+struct GaspA<'a>(for <'b> fn(u32, &'b str, d::Log<'a>), u32, d::Log<'a>, d::D<'a>);\n+struct GaspB<'a>(for <'b> fn(u32, &'b str, d::Log<'a>), u32, d::Log<'a>, d::D<'a>);\n+\n+impl<'a> Drop for GaspA<'a> {\n+    fn drop(&mut self) {\n+        let _d = d::D::new(\"GaspA::drop\", 2, self.2);\n+        (self.0)(self.1, \"GaspA::drop\", self.2);\n+    }\n+}\n+\n+impl<'a> Drop for GaspB<'a> {\n+    fn drop(&mut self) {\n+        let _d = d::D::new(\"GaspB::drop\", 3, self.2);\n+        (self.0)(self.1, \"GaspB::drop\", self.2);\n+    }\n+}\n+\n+enum E<'a> {\n+    A(GaspA<'a>, bool), B(GaspB<'a>, bool),\n+}\n+\n+fn f_a(x: u32, ctxt: &str, log: d::Log) {\n+    let _d = d::D::new(\"f_a\", 4, log);\n+    d::println(&format!(\"in f_A({:x}) from {}\", x, ctxt));\n+}\n+fn g_b(y: u32, ctxt: &str, log: d::Log) {\n+    let _d = d::D::new(\"g_b\", 5, log);\n+    d::println(&format!(\"in g_B({:x}) from {}\", y, ctxt));\n+}\n+\n+impl<'a> Drop for E<'a> {\n+    fn drop(&mut self) {\n+        let (do_drop, log) = match *self {\n+            E::A(GaspA(ref f, ref mut val_a, log, ref _d_a), ref mut do_drop) => {\n+                f(0xA1A0, &format!(\"E::drop, a={:x}\", val_a), log);\n+                *val_a += 1;\n+                // swap in do_drop := false to avoid infinite dtor regress\n+                (mem::replace(do_drop, false), log)\n+            }\n+            E::B(GaspB(ref g, ref mut val_b, log, ref _d_b), ref mut do_drop) => {\n+                g(0xB2B0, &format!(\"E::drop, b={:x}\", val_b), log);\n+                *val_b += 1;\n+                // swap in do_drop := false to avoid infinite dtor regress\n+                (mem::replace(do_drop, false), log)\n+            }\n+        };\n+\n+        if do_drop {\n+            mem::replace(self, E::A(GaspA(f_a, 0xA3A0, log, D::new(\"drop\", 6, log)), true));\n+        }\n+    }\n+}\n+\n+// This module provides simultaneous printouts of the dynamic extents\n+// of all of the D values, in addition to logging the order that each\n+// is dropped.\n+//\n+// This code is similar to a support code module embedded within\n+// test/run-pass/issue-123338-ensure-param-drop-order.rs; however,\n+// that (slightly simpler) code only identifies objects in the log via\n+// (creation) time-stamps; this incorporates both timestamping and the\n+// point of origin within the source code into the unique ID (uid).\n+\n+const PREF_INDENT: u32 = 20;\n+\n+pub mod d {\n+    #![allow(unused_parens)]\n+    use std::fmt;\n+    use std::mem;\n+    use std::cell::RefCell;\n+\n+    static mut counter: u16 = 0;\n+    static mut trails: u64 = 0;\n+\n+    pub type Log<'a> = &'a RefCell<Vec<u32>>;\n+\n+    pub fn current_width() -> u32 {\n+        unsafe { max_width() - trails.leading_zeros() }\n+    }\n+\n+    pub fn max_width() -> u32 {\n+        unsafe {\n+            (mem::size_of_val(&trails)*8) as u32\n+        }\n+    }\n+\n+    pub fn indent_println(my_trails: u32, s: &str) {\n+        let mut indent: String = String::new();\n+        for i in 0..my_trails {\n+            unsafe {\n+                if trails & (1 << i) != 0 {\n+                    indent = indent + \"| \";\n+                } else {\n+                    indent = indent + \"  \";\n+                }\n+            }\n+        }\n+        println!(\"{}{}\", indent, s);\n+    }\n+\n+    pub fn println(s: &str) {\n+        indent_println(super::PREF_INDENT, s);\n+    }\n+\n+    fn first_avail() -> u32 {\n+        unsafe {\n+            for i in 0..64 {\n+                if trails & (1 << i) == 0 {\n+                    return i;\n+                }\n+            }\n+        }\n+        panic!(\"exhausted trails\");\n+    }\n+\n+    pub struct D<'a> {\n+        name: &'static str, i: u8, uid: u32, trail: u32, log: Log<'a>\n+    }\n+\n+    impl<'a> fmt::Display for D<'a> {\n+        fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+            write!(w, \"D({}_{}, {})\", self.name, self.i, self.uid)\n+        }\n+    }\n+\n+    impl<'a> D<'a> {\n+        pub fn new(name: &'static str, i: u8, log: Log<'a>) -> D<'a> {\n+            unsafe {\n+                let trail = first_avail();\n+                let ctr = ((i as u32) * 10_000_000) + (counter as u32);\n+                counter += 1;\n+                trails |= (1 << trail);\n+                let ret = D {\n+                    name: name, i: i, log: log, uid: ctr, trail: trail\n+                };\n+                indent_println(trail, &format!(\"+-- Make {}\", ret));\n+                ret\n+            }\n+        }\n+    }\n+\n+    impl<'a> Drop for D<'a> {\n+        fn drop(&mut self) {\n+            unsafe { trails &= !(1 << self.trail); };\n+            self.log.borrow_mut().push(self.uid);\n+            indent_println(self.trail, &format!(\"+-- Drop {}\", self));\n+            indent_println(::PREF_INDENT, \"\");\n+        }\n+    }\n+}"}]}