{"sha": "98f30e833a2705fcb38d11b19ba75cd5fde723c7", "node_id": "C_kwDOAAsO6NoAKDk4ZjMwZTgzM2EyNzA1ZmNiMzhkMTFiMTliYTc1Y2Q1ZmRlNzIzYzc", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-12T18:50:32Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T07:48:19Z"}, "message": "Undo questionable changes", "tree": {"sha": "27fa95773bf0e45271c7ad35019858dd3da3335f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27fa95773bf0e45271c7ad35019858dd3da3335f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98f30e833a2705fcb38d11b19ba75cd5fde723c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98f30e833a2705fcb38d11b19ba75cd5fde723c7", "html_url": "https://github.com/rust-lang/rust/commit/98f30e833a2705fcb38d11b19ba75cd5fde723c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98f30e833a2705fcb38d11b19ba75cd5fde723c7/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66751ea73e849a9afaacaa15fc1cba0cb9d6e689", "url": "https://api.github.com/repos/rust-lang/rust/commits/66751ea73e849a9afaacaa15fc1cba0cb9d6e689", "html_url": "https://github.com/rust-lang/rust/commit/66751ea73e849a9afaacaa15fc1cba0cb9d6e689"}], "stats": {"total": 49, "additions": 25, "deletions": 24}, "files": [{"sha": "18e01567ca35e44888e52e19abd6bb07edca0d0e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=98f30e833a2705fcb38d11b19ba75cd5fde723c7", "patch": "@@ -167,7 +167,7 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Left(mplace) => to_const_value(&mplace),\n+        Left(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n         Right(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,"}, {"sha": "261f95da3480ff9ac29925949d9f5c84ca21f055", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=98f30e833a2705fcb38d11b19ba75cd5fde723c7", "patch": "@@ -535,7 +535,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Operand::*;\n         let op = match mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            &(Copy(place) | Move(place)) => self.eval_place_to_op(place, layout)?,\n+            &Copy(place) | &Move(place) => self.eval_place_to_op(place, layout)?,\n \n             Constant(constant) => {\n                 let c ="}, {"sha": "291464ab58ae20da7692acaa0bc77c158c57f688", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=98f30e833a2705fcb38d11b19ba75cd5fde723c7", "patch": "@@ -87,9 +87,9 @@ where\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n         let base = match base.as_mplace_or_imm() {\n-            Left(mplace) => {\n+            Left(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n-                let field = self.mplace_field(&mplace, field)?;\n+                let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n             }\n             Right(value) => value,"}, {"sha": "30c6013e7aceb70a805463d831eea2d3323f87d0", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f30e833a2705fcb38d11b19ba75cd5fde723c7/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=98f30e833a2705fcb38d11b19ba75cd5fde723c7", "patch": "@@ -22,20 +22,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         terminator: &mir::Terminator<'tcx>,\n     ) -> InterpResult<'tcx> {\n         use rustc_middle::mir::TerminatorKind::*;\n-        match &terminator.kind {\n+        match terminator.kind {\n             Return => {\n                 self.pop_stack_frame(/* unwinding */ false)?\n             }\n \n-            Goto { target } => self.go_to_block(*target),\n+            Goto { target } => self.go_to_block(target),\n \n-            SwitchInt { discr, targets } => {\n+            SwitchInt { ref discr, ref targets } => {\n                 let discr = self.read_immediate(&self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets.otherwise();\n-\n                 for (const_int, target) in targets.iter() {\n                     // Compare using MIR BinOp::Eq, to also support pointer values.\n                     // (Avoiding `self.binary_op` as that does some redundant layout computation.)\n@@ -51,22 +50,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         break;\n                     }\n                 }\n-\n                 self.go_to_block(target_block);\n             }\n \n-            Call { func, args, destination, target, cleanup, from_hir_call: _, fn_span: _ } => {\n+            Call {\n+                ref func,\n+                ref args,\n+                destination,\n+                target,\n+                ref cleanup,\n+                from_hir_call: _,\n+                fn_span: _,\n+            } => {\n                 let old_stack = self.frame_idx();\n                 let old_loc = self.frame().loc;\n                 let func = self.eval_operand(func, None)?;\n                 let args = self.eval_operands(args)?;\n-\n                 let fn_sig_binder = func.layout.ty.fn_sig(*self.tcx);\n                 let fn_sig =\n                     self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig_binder);\n                 let extra_args = &args[fn_sig.inputs().len()..];\n                 let extra_args = self.tcx.mk_type_list(extra_args.iter().map(|arg| arg.layout.ty));\n-\n                 let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n                     ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n@@ -89,14 +93,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     ),\n                 };\n \n-                let destination = self.eval_place(*destination)?;\n+                let destination = self.eval_place(destination)?;\n                 self.eval_fn_call(\n                     fn_val,\n                     (fn_sig.abi, fn_abi),\n                     &args,\n                     with_caller_location,\n                     &destination,\n-                    *target,\n+                    target,\n                     match (cleanup, fn_abi.can_unwind) {\n                         (Some(cleanup), true) => StackPopUnwind::Cleanup(*cleanup),\n                         (None, true) => StackPopUnwind::Skip,\n@@ -110,7 +114,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            &Drop { place, target, unwind } => {\n+            Drop { place, target, unwind } => {\n                 let frame = self.frame();\n                 let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n                 let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;\n@@ -128,19 +132,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.drop_in_place(&place, instance, target, unwind)?;\n             }\n \n-            Assert { cond, expected, msg, target, cleanup } => {\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n-                if *expected == cond_val {\n-                    self.go_to_block(*target);\n+                if expected == cond_val {\n+                    self.go_to_block(target);\n                 } else {\n-                    M::assert_panic(self, msg, *cleanup)?;\n+                    M::assert_panic(self, msg, cleanup)?;\n                 }\n             }\n \n             Abort => {\n                 M::abort(self, \"the program aborted execution\".to_owned())?;\n             }\n-\n             // When we encounter Resume, we've finished unwinding\n             // cleanup for the current stack frame. We pop it in order\n             // to continue unwinding the next frame\n@@ -151,10 +154,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.pop_stack_frame(/* unwinding */ true)?;\n                 return Ok(());\n             }\n-\n             // It is UB to ever encounter this.\n             Unreachable => throw_ub!(Unreachable),\n-\n             // These should never occur for MIR we actually run.\n             DropAndReplace { .. }\n             | FalseEdge { .. }\n@@ -166,8 +167,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 terminator.kind\n             ),\n \n-            InlineAsm { template, operands, options, destination, .. } => {\n-                M::eval_inline_asm(self, template, operands, *options)?;\n+            InlineAsm { template, ref operands, options, destination, .. } => {\n+                M::eval_inline_asm(self, template, operands, options)?;\n                 if options.contains(InlineAsmOptions::NORETURN) {\n                     throw_ub_format!(\"returned from noreturn inline assembly\");\n                 }"}]}