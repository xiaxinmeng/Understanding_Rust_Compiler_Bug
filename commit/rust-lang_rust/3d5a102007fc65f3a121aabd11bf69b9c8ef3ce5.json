{"sha": "3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNWExMDIwMDdmYzY1ZjNhMTIxYWFiZDExYmY2OWI5YzhlZjNjZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T00:21:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-12T00:21:22Z"}, "message": "Merge pull request #20415 from eddyb/unify-expected-return\n\nrustc_typeck: unify expected return types with formal return types to propagate coercions through calls of generic functions.\n\nReviewed-by: nikomatsakis", "tree": {"sha": "aabe9c40efb47800620577b76c2868aa7172f6f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aabe9c40efb47800620577b76c2868aa7172f6f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "html_url": "https://github.com/rust-lang/rust/commit/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7b397b02e49ab6af5bc2a30dd04c19c38e0e266", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7b397b02e49ab6af5bc2a30dd04c19c38e0e266", "html_url": "https://github.com/rust-lang/rust/commit/e7b397b02e49ab6af5bc2a30dd04c19c38e0e266"}, {"sha": "474872160a49e4048e5017f0bbb8d93d19267b9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/474872160a49e4048e5017f0bbb8d93d19267b9a", "html_url": "https://github.com/rust-lang/rust/commit/474872160a49e4048e5017f0bbb8d93d19267b9a"}], "stats": {"total": 286, "additions": 215, "deletions": 71}, "files": [{"sha": "8fd44f144e1ea577fc30a832bef7d1b9addb4282", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -613,6 +613,39 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.commit_unconditionally(move || self.try(move |_| f()))\n     }\n \n+    /// Execute `f` and commit only the region bindings if successful.\n+    /// The function f must be very careful not to leak any non-region\n+    /// variables that get created.\n+    pub fn commit_regions_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n+        F: FnOnce() -> Result<T, E>\n+    {\n+        debug!(\"commit_regions_if_ok()\");\n+        let CombinedSnapshot { type_snapshot,\n+                               int_snapshot,\n+                               float_snapshot,\n+                               region_vars_snapshot } = self.start_snapshot();\n+\n+        let r = self.try(move |_| f());\n+\n+        // Roll back any non-region bindings - they should be resolved\n+        // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n+        self.type_variables\n+            .borrow_mut()\n+            .rollback_to(type_snapshot);\n+        self.int_unification_table\n+            .borrow_mut()\n+            .rollback_to(int_snapshot);\n+        self.float_unification_table\n+            .borrow_mut()\n+            .rollback_to(float_snapshot);\n+\n+        // Commit region vars that may escape through resolved types.\n+        self.region_vars\n+            .commit(region_vars_snapshot);\n+\n+        r\n+    }\n+\n     /// Execute `f`, unroll bindings on panic\n     pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n         F: FnOnce(&CombinedSnapshot) -> Result<T, E>"}, {"sha": "d851206f384e316ab116e1ad7a208a12220939e9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -14,6 +14,8 @@ use super::check_argument_types;\n use super::check_expr;\n use super::check_method_argument_types;\n use super::err_args;\n+use super::Expectation;\n+use super::expected_types_for_fn_args;\n use super::FnCtxt;\n use super::LvaluePreference;\n use super::method;\n@@ -65,7 +67,8 @@ pub fn check_legal_trait_for_method_call(ccx: &CrateCtxt, span: Span, trait_id:\n pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                             call_expr: &ast::Expr,\n                             callee_expr: &ast::Expr,\n-                            arg_exprs: &[P<ast::Expr>])\n+                            arg_exprs: &[P<ast::Expr>],\n+                            expected: Expectation<'tcx>)\n {\n     check_expr(fcx, callee_expr);\n     let original_callee_ty = fcx.expr_ty(callee_expr);\n@@ -84,15 +87,15 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match result {\n         None => {\n             // this will report an error since original_callee_ty is not a fn\n-            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs);\n+            confirm_builtin_call(fcx, call_expr, original_callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::Builtin) => {\n-            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs);\n+            confirm_builtin_call(fcx, call_expr, callee_ty, arg_exprs, expected);\n         }\n \n         Some(CallStep::Overloaded(method_callee)) => {\n-            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee);\n+            confirm_overloaded_call(fcx, call_expr, arg_exprs, method_callee, expected);\n         }\n     }\n }\n@@ -153,7 +156,8 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                  call_expr: &ast::Expr,\n                                  callee_ty: Ty<'tcx>,\n-                                 arg_exprs: &[P<ast::Expr>])\n+                                 arg_exprs: &[P<ast::Expr>],\n+                                 expected: Expectation<'tcx>)\n {\n     let error_fn_sig;\n \n@@ -192,11 +196,16 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         fcx.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n     // Call the generic checker.\n-    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n+    let expected_arg_tys = expected_types_for_fn_args(fcx,\n+                                                      call_expr.span,\n+                                                      expected,\n+                                                      fn_sig.output,\n+                                                      fn_sig.inputs.as_slice());\n     check_argument_types(fcx,\n                          call_expr.span,\n                          fn_sig.inputs.as_slice(),\n-                         arg_exprs.as_slice(),\n+                         &expected_arg_tys[],\n+                         arg_exprs,\n                          AutorefArgs::No,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::DontTupleArguments);\n@@ -207,16 +216,17 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     call_expr: &ast::Expr,\n                                     arg_exprs: &[P<ast::Expr>],\n-                                    method_callee: ty::MethodCallee<'tcx>)\n+                                    method_callee: ty::MethodCallee<'tcx>,\n+                                    expected: Expectation<'tcx>)\n {\n-    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n     let output_type = check_method_argument_types(fcx,\n                                                   call_expr.span,\n                                                   method_callee.ty,\n                                                   call_expr,\n-                                                  arg_exprs.as_slice(),\n+                                                  arg_exprs,\n                                                   AutorefArgs::No,\n-                                                  TupleArgumentsFlag::TupleArguments);\n+                                                  TupleArgumentsFlag::TupleArguments,\n+                                                  expected);\n     let method_call = ty::MethodCall::expr(call_expr.id);\n     fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n     write_call(fcx, call_expr, output_type);"}, {"sha": "bfe43086aab10205a38022dc89129dfce5712fb1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -33,7 +33,7 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n            expr.repr(fcx.tcx()),\n            expected.repr(fcx.tcx()));\n \n-    let expected_sig_and_kind = expected.map_to_option(fcx, |ty| {\n+    let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n         deduce_unboxed_closure_expectations_from_expected_type(fcx, ty)\n     });\n "}, {"sha": "5a62bf3f3a8448ffac6dcee149de48e98b3d4520", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 126, "deletions": 58, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -112,6 +112,7 @@ use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n use std::rc::Rc;\n use std::iter::repeat;\n+use std::slice;\n use syntax::{self, abi, attr};\n use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{self, local_def, PostExpansionMethod};\n@@ -2558,7 +2559,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   iterator_expr,\n                                                   &[],\n                                                   AutorefArgs::No,\n-                                                  DontTupleArguments);\n+                                                  DontTupleArguments,\n+                                                  NoExpectation);\n \n     match method {\n         Some(method) => {\n@@ -2598,9 +2600,10 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n                                          callee_expr: &ast::Expr,\n-                                         args_no_rcvr: &[&P<ast::Expr>],\n+                                         args_no_rcvr: &[P<ast::Expr>],\n                                          autoref_args: AutorefArgs,\n-                                         tuple_arguments: TupleArgumentsFlag)\n+                                         tuple_arguments: TupleArgumentsFlag,\n+                                         expected: Expectation<'tcx>)\n                                          -> ty::FnOutput<'tcx> {\n     if ty::type_is_error(method_fn_ty) {\n         let err_inputs = err_args(fcx.tcx(), args_no_rcvr.len());\n@@ -2613,6 +2616,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         check_argument_types(fcx,\n                              sp,\n                              &err_inputs[],\n+                             &[],\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -2622,9 +2626,15 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         match method_fn_ty.sty {\n             ty::ty_bare_fn(_, ref fty) => {\n                 // HACK(eddyb) ignore self in the definition (see above).\n+                let expected_arg_tys = expected_types_for_fn_args(fcx,\n+                                                                  sp,\n+                                                                  expected,\n+                                                                  fty.sig.0.output,\n+                                                                  &fty.sig.0.inputs[1..]);\n                 check_argument_types(fcx,\n                                      sp,\n-                                     fty.sig.0.inputs.slice_from(1),\n+                                     &fty.sig.0.inputs[1..],\n+                                     &expected_arg_tys[],\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -2644,7 +2654,8 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n-                                  args: &[&P<ast::Expr>],\n+                                  expected_arg_tys: &[Ty<'tcx>],\n+                                  args: &[P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n@@ -2658,6 +2669,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         1\n     };\n \n+    let mut expected_arg_tys = expected_arg_tys;\n     let expected_arg_count = fn_inputs.len();\n     let formal_tys = if tuple_arguments == TupleArguments {\n         let tuple_type = structurally_resolved_type(fcx, sp, fn_inputs[0]);\n@@ -2670,23 +2682,32 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n+                    expected_arg_tys = &[][];\n                     err_args(fcx.tcx(), args.len())\n                 } else {\n+                    expected_arg_tys = match expected_arg_tys.get(0) {\n+                        Some(&ty) => match ty.sty {\n+                            ty::ty_tup(ref tys) => &**tys,\n+                            _ => &[]\n+                        },\n+                        None => &[]\n+                    };\n                     (*arg_types).clone()\n                 }\n             }\n             _ => {\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n+                expected_arg_tys = &[][];\n                 err_args(fcx.tcx(), args.len())\n             }\n         }\n     } else if expected_arg_count == supplied_arg_count {\n-        fn_inputs.iter().map(|a| *a).collect()\n+        fn_inputs.to_vec()\n     } else if variadic {\n         if supplied_arg_count >= expected_arg_count {\n-            fn_inputs.iter().map(|a| *a).collect()\n+            fn_inputs.to_vec()\n         } else {\n             span_err!(tcx.sess, sp, E0060,\n                 \"this function takes at least {} parameter{} \\\n@@ -2695,6 +2716,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+            expected_arg_tys = &[][];\n             err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n@@ -2704,6 +2726,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n+        expected_arg_tys = &[][];\n         err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n@@ -2767,7 +2790,25 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     AutorefArgs::No => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n+                // The special-cased logic below has three functions:\n+                // 1. Provide as good of an expected type as possible.\n+                let expected = expected_arg_tys.get(i).map(|&ty| {\n+                    Expectation::rvalue_hint(ty)\n+                });\n+\n+                check_expr_with_unifier(fcx, &**arg,\n+                                        expected.unwrap_or(ExpectHasType(formal_ty)),\n+                                        NoPreference, || {\n+                    // 2. Coerce to the most detailed type that could be coerced\n+                    //    to, which is `expected_ty` if `rvalue_hint` returns an\n+                    //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n+                    let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n+                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &**arg);\n+\n+                    // 3. Relate the expected type and the formal one,\n+                    //    if the expected type was used for the coercion.\n+                    coerce_ty.map(|ty| demand::suptype(fcx, arg.span, formal_ty, ty));\n+                });\n             }\n         }\n     }\n@@ -2776,12 +2817,12 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &***arg);\n+            check_expr(fcx, &**arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&***arg));\n+                                                    fcx.expr_ty(&**arg));\n             match arg_ty.sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2844,7 +2885,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ast::LitInt(_, ast::SignedIntLit(t, _)) => ty::mk_mach_int(tcx, t),\n         ast::LitInt(_, ast::UnsignedIntLit(t)) => ty::mk_mach_uint(tcx, t),\n         ast::LitInt(_, ast::UnsuffixedIntLit(_)) => {\n-            let opt_ty = expected.map_to_option(fcx, |ty| {\n+            let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(tcx.types.u8),\n@@ -2858,7 +2899,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         ast::LitFloat(_, t) => ty::mk_mach_float(tcx, t),\n         ast::LitFloatUnsuffixed(_) => {\n-            let opt_ty = expected.map_to_option(fcx, |ty| {\n+            let opt_ty = expected.to_option(fcx).and_then(|ty| {\n                 match ty.sty {\n                     ty::ty_float(_) => Some(ty),\n                     _ => None\n@@ -3007,6 +3048,45 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n+/// Unifies the return type with the expected type early, for more coercions\n+/// and forward type information on the argument expressions.\n+fn expected_types_for_fn_args<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                        call_span: Span,\n+                                        expected_ret: Expectation<'tcx>,\n+                                        formal_ret: ty::FnOutput<'tcx>,\n+                                        formal_args: &[Ty<'tcx>])\n+                                        -> Vec<Ty<'tcx>> {\n+    let expected_args = expected_ret.only_has_type(fcx).and_then(|ret_ty| {\n+        if let ty::FnConverging(formal_ret_ty) = formal_ret {\n+            fcx.infcx().commit_regions_if_ok(|| {\n+                // Attempt to apply a subtyping relationship between the formal\n+                // return type (likely containing type variables if the function\n+                // is polymorphic) and the expected return type.\n+                // No argument expectations are produced if unification fails.\n+                let origin = infer::Misc(call_span);\n+                let ures = fcx.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n+                // FIXME(#15760) can't use try! here, FromError doesn't default\n+                // to identity so the resulting type is not constrained.\n+                if let Err(e) = ures {\n+                    return Err(e);\n+                }\n+\n+                // Record all the argument types, with the substitutions\n+                // produced from the above subtyping unification.\n+                Ok(formal_args.iter().map(|ty| {\n+                    fcx.infcx().resolve_type_vars_if_possible(ty)\n+                }).collect())\n+            }).ok()\n+        } else {\n+            None\n+        }\n+    }).unwrap_or(vec![]);\n+    debug!(\"expected_types_for_fn_args(formal={} -> {}, expected={} -> {})\",\n+           formal_args.repr(fcx.tcx()), formal_ret.repr(fcx.tcx()),\n+           expected_args.repr(fcx.tcx()), expected_ret.repr(fcx.tcx()));\n+    expected_args\n+}\n+\n /// Invariant:\n /// If an expression has any sub-expressions that result in a type error,\n /// inspecting that expression's type with `ty::type_is_error` will return\n@@ -3028,12 +3108,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n            expr.repr(fcx.tcx()), expected.repr(fcx.tcx()));\n \n     // Checks a method call.\n-    fn check_method_call(fcx: &FnCtxt,\n-                         expr: &ast::Expr,\n-                         method_name: ast::SpannedIdent,\n-                         args: &[P<ast::Expr>],\n-                         tps: &[P<ast::Ty>],\n-                         lvalue_pref: LvaluePreference) {\n+    fn check_method_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                   expr: &ast::Expr,\n+                                   method_name: ast::SpannedIdent,\n+                                   args: &[P<ast::Expr>],\n+                                   tps: &[P<ast::Ty>],\n+                                   expected: Expectation<'tcx>,\n+                                   lvalue_pref: LvaluePreference) {\n         let rcvr = &*args[0];\n         check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n \n@@ -3064,14 +3145,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args.as_slice(),\n+                                                 &args[1..],\n                                                  AutorefArgs::No,\n-                                                 DontTupleArguments);\n+                                                 DontTupleArguments,\n+                                                 expected);\n \n         write_call(fcx, expr, ret_ty);\n     }\n@@ -3167,8 +3248,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => None\n         };\n         let args = match rhs {\n-            Some(rhs) => vec![rhs],\n-            None => vec![]\n+            Some(rhs) => slice::ref_slice(rhs),\n+            None => &[][]\n         };\n         match method {\n             Some(method) => {\n@@ -3177,12 +3258,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let method_call = ::middle::ty::MethodCall::expr(op_ex.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 match check_method_argument_types(fcx,\n-                                            op_ex.span,\n-                                            method_ty,\n-                                            op_ex,\n-                                            args.as_slice(),\n-                                            autoref_args,\n-                                            DontTupleArguments) {\n+                                                  op_ex.span,\n+                                                  method_ty,\n+                                                  op_ex,\n+                                                  args,\n+                                                  autoref_args,\n+                                                  DontTupleArguments,\n+                                                  NoExpectation) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => fcx.tcx().types.err\n                 }\n@@ -3196,9 +3278,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n-                                            args.as_slice(),\n+                                            args,\n                                             autoref_args,\n-                                            DontTupleArguments);\n+                                            DontTupleArguments,\n+                                            NoExpectation);\n                 fcx.tcx().types.err\n             }\n         }\n@@ -3761,7 +3844,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprUnary(unop, ref oprnd) => {\n-        let expected_inner = expected.map(fcx, |ty| {\n+        let expected_inner = expected.to_option(fcx).map_or(NoExpectation, |ty| {\n             match unop {\n                 ast::UnUniq => match ty.sty {\n                     ty::ty_uniq(ty) => {\n@@ -3851,8 +3934,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n-        let expected = expected.only_has_type();\n-        let hint = expected.map(fcx, |ty| {\n+        let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => {\n                     if ty::expr_is_lval(fcx.tcx(), &**oprnd) {\n@@ -4046,10 +4128,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, args.as_slice());\n+          callee::check_call(fcx, expr, &**callee, &args[], expected);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n+        check_method_call(fcx, expr, ident, &args[], &tps[], expected, lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -4065,7 +4147,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         check_cast(fcx, expr, &**e, &**t);\n       }\n       ast::ExprVec(ref args) => {\n-        let uty = expected.map_to_option(fcx, |uty| {\n+        let uty = expected.to_option(fcx).and_then(|uty| {\n             match uty.sty {\n                 ty::ty_vec(ty, _) => Some(ty),\n                 _ => None\n@@ -4134,8 +4216,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprTup(ref elts) => {\n-        let expected = expected.only_has_type();\n-        let flds = expected.map_to_option(fcx, |ty| {\n+        let flds = expected.only_has_type(fcx).and_then(|ty| {\n             match ty.sty {\n                 ty::ty_tup(ref flds) => Some(&flds[]),\n                 _ => None\n@@ -4428,13 +4509,6 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn only_has_type(self) -> Expectation<'tcx> {\n-        match self {\n-            ExpectHasType(t) => ExpectHasType(t),\n-            _ => NoExpectation\n-        }\n-    }\n-\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n@@ -4458,25 +4532,19 @@ impl<'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn map<'a, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Expectation<'tcx> where\n-        F: FnOnce(Ty<'tcx>) -> Expectation<'tcx>\n-    {\n+    fn to_option<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n-            NoExpectation => NoExpectation,\n+            NoExpectation => None,\n             ExpectCastableToType(ty) |\n             ExpectHasType(ty) |\n-            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n+            ExpectRvalueLikeUnsized(ty) => Some(ty),\n         }\n     }\n \n-    fn map_to_option<'a, O, F>(self, fcx: &FnCtxt<'a, 'tcx>, unpack: F) -> Option<O> where\n-        F: FnOnce(Ty<'tcx>) -> Option<O>,\n-    {\n+    fn only_has_type<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n-            NoExpectation => None,\n-            ExpectCastableToType(ty) |\n-            ExpectHasType(ty) |\n-            ExpectRvalueLikeUnsized(ty) => unpack(ty),\n+            ExpectHasType(ty) => Some(ty),\n+            _ => None\n         }\n     }\n }"}, {"sha": "d363f2f834bb6c31fafe5c70d94a07fa1910c9c2", "filename": "src/test/compile-fail/issue-15783.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15783.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -14,7 +14,8 @@ pub fn foo(params: Option<&[&str]>) -> usize {\n \n fn main() {\n     let name = \"Foo\";\n-    let msg = foo(Some(&[name.as_slice()]));\n+    let x = Some(&[name.as_slice()]);\n+    let msg = foo(x);\n //~^ ERROR mismatched types: expected `core::option::Option<&[&str]>`\n     assert_eq!(msg, 3);\n }"}, {"sha": "c83fb09651298b7e752aea200f33ec0072fd78da", "filename": "src/test/compile-fail/regions-early-bound-error-method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error-method.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -28,6 +28,8 @@ impl<'a> GetRef<'a> for Box<'a> {\n impl<'a> Box<'a> {\n     fn or<'b,G:GetRef<'b>>(&self, g2: G) -> &'a isize {\n         g2.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n+        //~^ ERROR mismatched types: expected `&'a isize`, found `&'b isize` (lifetime mismatch)\n+\n     }\n }\n "}, {"sha": "cc6acdca78e8114f571d8c3b96422e0140df5cef", "filename": "src/test/compile-fail/regions-early-bound-error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-early-bound-error.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -27,6 +27,7 @@ impl<'a,T:Clone> GetRef<'a,T> for Box<'a,T> {\n \n fn get<'a,'b,G:GetRef<'a, isize>>(g1: G, b: &'b isize) -> &'b isize {\n     g1.get() //~ ERROR cannot infer an appropriate lifetime for automatic coercion due to\n+    //~^ ERROR mismatched types: expected `&'b isize`, found `&'a isize` (lifetime mismatch)\n }\n \n fn main() {"}, {"sha": "f590e6e07283cc208f26e2e63e8aacc22754104d", "filename": "src/test/run-pass/coerce-expect-unsized.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-expect-unsized.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -30,4 +30,7 @@ pub fn main() {\n     let _: &Fn(int) -> _ = &{ |x| (x as u8) };\n     let _: &Show = &if true { false } else { true };\n     let _: &Show = &match true { true => 'a', false => 'b' };\n+\n+    let _: Box<[int]> = Box::new([1, 2, 3]);\n+    let _: Box<Fn(int) -> _> = Box::new(|x| (x as u8));\n }"}, {"sha": "eeba9042f7c3fcfbb140ba359eef73364ce06f5b", "filename": "src/test/run-pass/coerce-unify-return.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-unify-return.rs?ref=3d5a102007fc65f3a121aabd11bf69b9c8ef3ce5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that coercions unify the expected return type of a polymorphic\n+// function call, instead of leaving the type variables as they were.\n+\n+struct Foo;\n+impl Foo {\n+    fn foo<T>(self, x: T) -> Option<T> { Some(x) }\n+}\n+\n+pub fn main() {\n+    let _: Option<fn()> = Some(main);\n+    let _: Option<fn()> = Foo.foo(main);\n+\n+    // The same two cases, with implicit type variables made explicit.\n+    let _: Option<fn()> = Some::<_>(main);\n+    let _: Option<fn()> = Foo.foo::<_>(main);\n+}"}]}