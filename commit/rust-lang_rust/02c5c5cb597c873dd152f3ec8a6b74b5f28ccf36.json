{"sha": "02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYzVjNWNiNTk3Yzg3M2RkMTUyZjNlYzhhNmI3NGI1ZjI4Y2NmMzY=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-31T19:47:55Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-07T23:33:43Z"}, "message": "Move to buffers throughout print_item", "tree": {"sha": "3f06f45e24e74ef695db804fb695728a30d06950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f06f45e24e74ef695db804fb695728a30d06950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "html_url": "https://github.com/rust-lang/rust/commit/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1c1e86d5a03796ec4442372b185fb1e20d81124", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c1e86d5a03796ec4442372b185fb1e20d81124", "html_url": "https://github.com/rust-lang/rust/commit/c1c1e86d5a03796ec4442372b185fb1e20d81124"}], "stats": {"total": 803, "additions": 375, "deletions": 428}, "files": [{"sha": "dcd32192ff3842f54cec4a421bb3f2f039a74b6d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "patch": "@@ -872,9 +872,9 @@ impl fmt::Display for clean::Impl {\n \n // The difference from above is that trait is not hyperlinked.\n pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n-                               f: &mut fmt::Formatter<'_>,\n-                               use_absolute: bool) -> fmt::Result {\n-    fmt_impl(i, f, false, use_absolute)\n+                               f: &mut Buffer,\n+                               use_absolute: bool) {\n+    f.with_formatter(|f| fmt_impl(i, f, false, use_absolute))\n }\n \n impl fmt::Display for clean::Arguments {"}, {"sha": "9846073cad4bcf8752558510baf417e6a7df81a0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 372, "deletions": 425, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=02c5c5cb597c873dd152f3ec8a6b74b5f28ccf36", "patch": "@@ -1233,17 +1233,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut v = String::from(\"(function() {var implementors = {}};\\n\");\n+        let mut v = String::from(\"(function() {var implementors = {};\\n\");\n         for implementor in &all_implementors {\n-            v.push_str(&format!(\"{}\", *implementor));\n+            writeln!(v, \"{}\", *implementor).unwrap();\n         }\n         v.push_str(r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n             } else {\n                 window.pending_implementors = implementors;\n             }\n-        \\n\");\n+        \");\n         v.push_str(\"})()\");\n         cx.shared.fs.write(&mydst, &v)?;\n     }\n@@ -2171,11 +2171,11 @@ impl Context {\n     }\n }\n \n-fn wrap_into_docblock<F>(w: &mut fmt::Formatter<'_>,\n-                         f: F) -> fmt::Result\n-where F: Fn(&mut fmt::Formatter<'_>) -> fmt::Result {\n-    write!(w, \"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\")?;\n-    f(w)?;\n+fn wrap_into_docblock<F>(w: &mut Buffer, f: F)\n+    where F: FnOnce(&mut Buffer)\n+{\n+    write!(w, \"<div class=\\\"docblock type-decl hidden-by-usual-hider\\\">\");\n+    f(w);\n     write!(w, \"</div>\")\n }\n \n@@ -2255,33 +2255,31 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n \n     write!(buf, \"</span></h1>\"); // in-band\n \n-    buf.with_formatter(|fmt| {\n     match item.inner {\n         clean::ModuleItem(ref m) =>\n-            item_module(fmt, cx, item, &m.items),\n+            item_module(buf, cx, item, &m.items),\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) =>\n-            item_function(fmt, cx, item, f),\n-        clean::TraitItem(ref t) => item_trait(fmt, cx, item, t),\n-        clean::StructItem(ref s) => item_struct(fmt, cx, item, s),\n-        clean::UnionItem(ref s) => item_union(fmt, cx, item, s),\n-        clean::EnumItem(ref e) => item_enum(fmt, cx, item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(fmt, cx, item, t),\n-        clean::MacroItem(ref m) => item_macro(fmt, cx, item, m),\n-        clean::ProcMacroItem(ref m) => item_proc_macro(fmt, cx, item, m),\n-        clean::PrimitiveItem(ref p) => item_primitive(fmt, cx, item, p),\n+            item_function(buf, cx, item, f),\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n+        clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n+        clean::PrimitiveItem(ref p) => item_primitive(buf, cx, item, p),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) =>\n-            item_static(fmt, cx, item, i),\n-        clean::ConstantItem(ref c) => item_constant(fmt, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(fmt, cx, item),\n-        clean::KeywordItem(ref k) => item_keyword(fmt, cx, item, k),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(fmt, cx, item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(fmt, cx, item, ta),\n+            item_static(buf, cx, item, i),\n+        clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::KeywordItem(ref k) => item_keyword(buf, cx, item, k),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n         }\n     }\n-    })\n }\n \n fn item_path(ty: ItemType, name: &str) -> String {\n@@ -2333,24 +2331,23 @@ fn shorten(s: String) -> String {\n     }\n }\n \n-fn document(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item) -> fmt::Result {\n+fn document(w: &mut Buffer, cx: &Context, item: &clean::Item) {\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n-    document_stability(w, cx, item, false)?;\n-    document_full(w, item, cx, \"\", false)?;\n-    Ok(())\n+    document_stability(w, cx, item, false);\n+    document_full(w, item, cx, \"\", false);\n }\n \n /// Render md_text as markdown.\n fn render_markdown(\n-    w: &mut fmt::Formatter<'_>,\n+    w: &mut Buffer,\n     cx: &Context,\n     md_text: &str,\n     links: Vec<(String, String)>,\n     prefix: &str,\n     is_hidden: bool,\n-) -> fmt::Result {\n+) {\n     let mut ids = cx.id_map.borrow_mut();\n     write!(w, \"<div class='docblock{}'>{}{}</div>\",\n            if is_hidden { \" hidden\" } else { \"\" },\n@@ -2360,60 +2357,55 @@ fn render_markdown(\n }\n \n fn document_short(\n-    w: &mut fmt::Formatter<'_>,\n+    w: &mut Buffer,\n     cx: &Context,\n     item: &clean::Item,\n     link: AssocItemLink<'_>,\n     prefix: &str,\n     is_hidden: bool,\n-) -> fmt::Result {\n+) {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n             format!(\"{} [Read more]({})\",\n                     &plain_summary_line(Some(s)), naive_assoc_href(item, link))\n         } else {\n             plain_summary_line(Some(s))\n         };\n-        render_markdown(w, cx, &markdown, item.links(), prefix, is_hidden)?;\n+        render_markdown(w, cx, &markdown, item.links(), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock{}'>{}</div>\",\n                if is_hidden { \" hidden\" } else { \"\" },\n-               prefix)?;\n+               prefix);\n     }\n-    Ok(())\n }\n \n-fn document_full(w: &mut fmt::Formatter<'_>, item: &clean::Item,\n-                 cx: &Context, prefix: &str, is_hidden: bool) -> fmt::Result {\n+fn document_full(w: &mut Buffer, item: &clean::Item, cx: &Context, prefix: &str, is_hidden: bool) {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, cx, &*s, item.links(), prefix, is_hidden)?;\n+        render_markdown(w, cx, &*s, item.links(), prefix, is_hidden);\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock{}'>{}</div>\",\n                if is_hidden { \" hidden\" } else { \"\" },\n-               prefix)?;\n+               prefix);\n     }\n-    Ok(())\n }\n \n-fn document_stability(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n-                      is_hidden: bool) -> fmt::Result {\n+fn document_stability(w: &mut Buffer, cx: &Context, item: &clean::Item, is_hidden: bool) {\n     let stabilities = short_stability(item, cx);\n     if !stabilities.is_empty() {\n-        write!(w, \"<div class='stability{}'>\", if is_hidden { \" hidden\" } else { \"\" })?;\n+        write!(w, \"<div class='stability{}'>\", if is_hidden { \" hidden\" } else { \"\" });\n         for stability in stabilities {\n-            write!(w, \"{}\", stability)?;\n+            write!(w, \"{}\", stability);\n         }\n-        write!(w, \"</div>\")?;\n+        write!(w, \"</div>\");\n     }\n-    Ok(())\n }\n \n fn document_non_exhaustive_header(item: &clean::Item) -> &str {\n     if item.is_non_exhaustive() { \" (Non-exhaustive)\" } else { \"\" }\n }\n \n-fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fmt::Result {\n+fn document_non_exhaustive(w: &mut Buffer, item: &clean::Item) {\n     if item.is_non_exhaustive() {\n         write!(w, \"<div class='docblock non-exhaustive non-exhaustive-{}'>\", {\n             if item.is_struct() {\n@@ -2425,31 +2417,29 @@ fn document_non_exhaustive(w: &mut fmt::Formatter<'_>, item: &clean::Item) -> fm\n             } else {\n                 \"type\"\n             }\n-        })?;\n+        });\n \n         if item.is_struct() {\n             write!(w, \"Non-exhaustive structs could have additional fields added in future. \\\n                        Therefore, non-exhaustive structs cannot be constructed in external crates \\\n                        using the traditional <code>Struct {{ .. }}</code> syntax; cannot be \\\n                        matched against without a wildcard <code>..</code>; and \\\n-                       struct update syntax will not work.\")?;\n+                       struct update syntax will not work.\");\n         } else if item.is_enum() {\n             write!(w, \"Non-exhaustive enums could have additional variants added in future. \\\n                        Therefore, when matching against variants of non-exhaustive enums, an \\\n-                       extra wildcard arm must be added to account for any future variants.\")?;\n+                       extra wildcard arm must be added to account for any future variants.\");\n         } else if item.is_variant() {\n             write!(w, \"Non-exhaustive enum variants could have additional fields added in future. \\\n                        Therefore, non-exhaustive enum variants cannot be constructed in external \\\n-                       crates and cannot be matched against.\")?;\n+                       crates and cannot be matched against.\");\n         } else {\n             write!(w, \"This type will require a wildcard arm in any match statements or \\\n-                       constructors.\")?;\n+                       constructors.\");\n         }\n \n-        write!(w, \"</div>\")?;\n+        write!(w, \"</div>\");\n     }\n-\n-    Ok(())\n }\n \n fn name_key(name: &str) -> (&str, u64, usize) {\n@@ -2473,9 +2463,8 @@ fn name_key(name: &str) -> (&str, u64, usize) {\n     }\n }\n \n-fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n-               item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n-    document(w, cx, item)?;\n+fn item_module(w: &mut Buffer, cx: &Context, item: &clean::Item, items: &[clean::Item]) {\n+    document(w, cx, item);\n \n     let mut indices = (0..items.len()).filter(|i| !items[*i].is_stripped()).collect::<Vec<usize>>();\n \n@@ -2566,13 +2555,13 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n             curty = myty;\n         } else if myty != curty {\n             if curty.is_some() {\n-                write!(w, \"</table>\")?;\n+                write!(w, \"</table>\");\n             }\n             curty = myty;\n             let (short, name) = item_ty_to_strs(&myty.unwrap());\n             write!(w, \"<h2 id='{id}' class='section-header'>\\\n                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                   id = cx.derive_id(short.to_owned()), name = name)?;\n+                   id = cx.derive_id(short.to_owned()), name = name);\n         }\n \n         match myitem.inner {\n@@ -2584,20 +2573,20 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n                                VisSpace(&myitem.visibility),\n                                anchor(myitem.def_id, src),\n-                               name)?\n+                               name)\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n                                VisSpace(&myitem.visibility),\n-                               anchor(myitem.def_id, name))?\n+                               anchor(myitem.def_id, name))\n                     }\n                 }\n-                write!(w, \"</code></td></tr>\")?;\n+                write!(w, \"</code></td></tr>\");\n             }\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(&myitem.visibility), *import)?;\n+                       VisSpace(&myitem.visibility), *import);\n             }\n \n             _ => {\n@@ -2642,15 +2631,14 @@ fn item_module(w: &mut fmt::Formatter<'_>, cx: &Context,\n                                 })\n                                 .collect::<Vec<_>>()\n                                 .join(\" \"),\n-                      )?;\n+                      );\n             }\n         }\n     }\n \n     if curty.is_some() {\n-        write!(w, \"</table>\")?;\n+        write!(w, \"</table>\");\n     }\n-    Ok(())\n }\n \n /// Render the stability and deprecation tags that are displayed in the item's summary at the\n@@ -2799,33 +2787,30 @@ fn short_stability(item: &clean::Item, cx: &Context) -> Vec<String> {\n     stability\n }\n \n-fn item_constant(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-                 c: &clean::Constant) -> fmt::Result {\n-    write!(w, \"<pre class='rust const'>\")?;\n-    render_attributes(w, it, false)?;\n+fn item_constant(w: &mut Buffer, cx: &Context, it: &clean::Item, c: &clean::Constant) {\n+    write!(w, \"<pre class='rust const'>\");\n+    render_attributes(w, it, false);\n     write!(w, \"{vis}const \\\n                {name}: {typ}</pre>\",\n            vis = VisSpace(&it.visibility),\n            name = it.name.as_ref().unwrap(),\n-           typ = c.type_)?;\n+           typ = c.type_);\n     document(w, cx, it)\n }\n \n-fn item_static(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-               s: &clean::Static) -> fmt::Result {\n-    write!(w, \"<pre class='rust static'>\")?;\n-    render_attributes(w, it, false)?;\n+fn item_static(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Static) {\n+    write!(w, \"<pre class='rust static'>\");\n+    render_attributes(w, it, false);\n     write!(w, \"{vis}static {mutability}\\\n                {name}: {typ}</pre>\",\n            vis = VisSpace(&it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n-           typ = s.type_)?;\n+           typ = s.type_);\n     document(w, cx, it)\n }\n \n-fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-                 f: &clean::Function) -> fmt::Result {\n+fn item_function(w: &mut Buffer, cx: &Context, it: &clean::Item, f: &clean::Function) {\n     let header_len = format!(\n         \"{}{}{}{}{:#}fn {}{:#}\",\n         VisSpace(&it.visibility),\n@@ -2836,8 +2821,8 @@ fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n         it.name.as_ref().unwrap(),\n         f.generics\n     ).len();\n-    write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it)?)?;\n-    render_attributes(w, it, false)?;\n+    write!(w, \"{}<pre class='rust fn'>\", render_spotlight_traits(it));\n+    render_attributes(w, it, false);\n     write!(w,\n            \"{vis}{constness}{unsafety}{asyncness}{abi}fn \\\n            {name}{generics}{decl}{where_clause}</pre>\",\n@@ -2854,12 +2839,12 @@ fn item_function(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n               header_len,\n               indent: 0,\n               asyncness: f.header.asyncness,\n-           })?;\n+           });\n     document(w, cx, it)\n }\n \n-fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'_>,\n-                      implementor_dups: &FxHashMap<&str, (DefId, bool)>) -> fmt::Result {\n+fn render_implementor(cx: &Context, implementor: &Impl, w: &mut Buffer,\n+                      implementor_dups: &FxHashMap<&str, (DefId, bool)>) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n     let use_absolute = match implementor.inner_impl().for_ {\n@@ -2871,20 +2856,18 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'\n         _ => false,\n     };\n     render_impl(w, cx, implementor, AssocItemLink::Anchor(None), RenderMode::Normal,\n-                implementor.impl_item.stable_since(), false, Some(use_absolute), false, false)?;\n-    Ok(())\n+                implementor.impl_item.stable_since(), false, Some(use_absolute), false, false);\n }\n \n-fn render_impls(cx: &Context, w: &mut fmt::Formatter<'_>,\n+fn render_impls(cx: &Context, w: &mut Buffer,\n                 traits: &[&&Impl],\n-                containing_item: &clean::Item) -> fmt::Result {\n+                containing_item: &clean::Item) {\n     for i in traits {\n         let did = i.trait_did().unwrap();\n         let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n         render_impl(w, cx, i, assoc_link,\n-                    RenderMode::Normal, containing_item.stable_since(), true, None, false, true)?;\n+                    RenderMode::Normal, containing_item.stable_since(), true, None, false, true);\n     }\n-    Ok(())\n }\n \n fn bounds(t_bounds: &[clean::GenericBound], trait_alias: bool) -> String {\n@@ -2912,11 +2895,11 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n }\n \n fn item_trait(\n-    w: &mut fmt::Formatter<'_>,\n+    w: &mut Buffer,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::Trait,\n-) -> fmt::Result {\n+) {\n     let bounds = bounds(&t.bounds, false);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2925,146 +2908,144 @@ fn item_trait(\n \n     // Output the trait definition\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class='rust trait'>\")?;\n-        render_attributes(w, it, true)?;\n+        write!(w, \"<pre class='rust trait'>\");\n+        render_attributes(w, it, true);\n         write!(w, \"{}{}{}trait {}{}{}\",\n                VisSpace(&it.visibility),\n                UnsafetySpace(t.unsafety),\n                if t.is_auto { \"auto \" } else { \"\" },\n                it.name.as_ref().unwrap(),\n                t.generics,\n-               bounds)?;\n+               bounds);\n \n         if !t.generics.where_predicates.is_empty() {\n-            write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true })?;\n+            write!(w, \"{}\", WhereClause { gens: &t.generics, indent: 0, end_newline: true });\n         } else {\n-            write!(w, \" \")?;\n+            write!(w, \" \");\n         }\n \n         if t.items.is_empty() {\n-            write!(w, \"{{ }}\")?;\n+            write!(w, \"{{ }}\");\n         } else {\n             // FIXME: we should be using a derived_id for the Anchors here\n-            write!(w, \"{{\\n\")?;\n+            write!(w, \"{{\\n\");\n             for t in &types {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-                write!(w, \";\\n\")?;\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                write!(w, \";\\n\");\n             }\n             if !types.is_empty() && !consts.is_empty() {\n-                w.write_str(\"\\n\")?;\n+                w.write_str(\"\\n\");\n             }\n             for t in &consts {\n-                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-                write!(w, \";\\n\")?;\n+                render_assoc_item(w, t, AssocItemLink::Anchor(None), ItemType::Trait);\n+                write!(w, \";\\n\");\n             }\n             if !consts.is_empty() && !required.is_empty() {\n-                w.write_str(\"\\n\")?;\n+                w.write_str(\"\\n\");\n             }\n             for (pos, m) in required.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n-                write!(w, \";\\n\")?;\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n+                write!(w, \";\\n\");\n \n                 if pos < required.len() - 1 {\n-                   write!(w, \"<div class='item-spacer'></div>\")?;\n+                   write!(w, \"<div class='item-spacer'></div>\");\n                 }\n             }\n             if !required.is_empty() && !provided.is_empty() {\n-                w.write_str(\"\\n\")?;\n+                w.write_str(\"\\n\");\n             }\n             for (pos, m) in provided.iter().enumerate() {\n-                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait)?;\n+                render_assoc_item(w, m, AssocItemLink::Anchor(None), ItemType::Trait);\n                 match m.inner {\n                     clean::MethodItem(ref inner) if !inner.generics.where_predicates.is_empty() => {\n-                        write!(w, \",\\n    {{ ... }}\\n\")?;\n+                        write!(w, \",\\n    {{ ... }}\\n\");\n                     },\n                     _ => {\n-                        write!(w, \" {{ ... }}\\n\")?;\n+                        write!(w, \" {{ ... }}\\n\");\n                     },\n                 }\n                 if pos < provided.len() - 1 {\n-                   write!(w, \"<div class='item-spacer'></div>\")?;\n+                   write!(w, \"<div class='item-spacer'></div>\");\n                 }\n             }\n-            write!(w, \"}}\")?;\n+            write!(w, \"}}\");\n         }\n         write!(w, \"</pre>\")\n-    })?;\n+    });\n \n     // Trait documentation\n-    document(w, cx, it)?;\n+    document(w, cx, it);\n \n     fn write_small_section_header(\n-        w: &mut fmt::Formatter<'_>,\n+        w: &mut Buffer,\n         id: &str,\n         title: &str,\n         extra_content: &str,\n-    ) -> fmt::Result {\n+    ) {\n         write!(w, \"\n             <h2 id='{0}' class='small-section-header'>\\\n               {1}<a href='#{0}' class='anchor'></a>\\\n             </h2>{2}\", id, title, extra_content)\n     }\n \n-    fn write_loading_content(w: &mut fmt::Formatter<'_>, extra_content: &str) -> fmt::Result {\n+    fn write_loading_content(w: &mut Buffer, extra_content: &str) {\n         write!(w, \"{}<span class='loading-content'>Loading content...</span>\", extra_content)\n     }\n \n-    fn trait_item(w: &mut fmt::Formatter<'_>, cx: &Context, m: &clean::Item, t: &clean::Item)\n-                  -> fmt::Result {\n+    fn trait_item(w: &mut Buffer, cx: &Context, m: &clean::Item, t: &clean::Item) {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n         let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"<h3 id='{id}' class='method'>{extra}<code id='{ns_id}'>\",\n-               extra = render_spotlight_traits(m)?,\n+               extra = render_spotlight_traits(m),\n                id = id,\n-               ns_id = ns_id)?;\n-        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl)?;\n-        write!(w, \"</code>\")?;\n-        render_stability_since(w, m, t)?;\n-        write!(w, \"</h3>\")?;\n-        document(w, cx, m)?;\n-        Ok(())\n+               ns_id = ns_id);\n+        render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl);\n+        write!(w, \"</code>\");\n+        render_stability_since(w, m, t);\n+        write!(w, \"</h3>\");\n+        document(w, cx, m);\n     }\n \n     if !types.is_empty() {\n         write_small_section_header(w, \"associated-types\", \"Associated Types\",\n-                                   \"<div class='methods'>\")?;\n+                                   \"<div class='methods'>\");\n         for t in &types {\n-            trait_item(w, cx, *t, it)?;\n+            trait_item(w, cx, *t, it);\n         }\n-        write_loading_content(w, \"</div>\")?;\n+        write_loading_content(w, \"</div>\");\n     }\n \n     if !consts.is_empty() {\n         write_small_section_header(w, \"associated-const\", \"Associated Constants\",\n-                                   \"<div class='methods'>\")?;\n+                                   \"<div class='methods'>\");\n         for t in &consts {\n-            trait_item(w, cx, *t, it)?;\n+            trait_item(w, cx, *t, it);\n         }\n-        write_loading_content(w, \"</div>\")?;\n+        write_loading_content(w, \"</div>\");\n     }\n \n     // Output the documentation for each function individually\n     if !required.is_empty() {\n         write_small_section_header(w, \"required-methods\", \"Required methods\",\n-                                   \"<div class='methods'>\")?;\n+                                   \"<div class='methods'>\");\n         for m in &required {\n-            trait_item(w, cx, *m, it)?;\n+            trait_item(w, cx, *m, it);\n         }\n-        write_loading_content(w, \"</div>\")?;\n+        write_loading_content(w, \"</div>\");\n     }\n     if !provided.is_empty() {\n         write_small_section_header(w, \"provided-methods\", \"Provided methods\",\n-                                   \"<div class='methods'>\")?;\n+                                   \"<div class='methods'>\");\n         for m in &provided {\n-            trait_item(w, cx, *m, it)?;\n+            trait_item(w, cx, *m, it);\n         }\n-        write_loading_content(w, \"</div>\")?;\n+        write_loading_content(w, \"</div>\");\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n     let cache = cache();\n \n@@ -3103,7 +3084,7 @@ fn item_trait(\n         concrete.sort_by(compare_impl);\n \n         if !foreign.is_empty() {\n-            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\")?;\n+            write_small_section_header(w, \"foreign-impls\", \"Implementations on Foreign Types\", \"\");\n \n             for implementor in foreign {\n                 let assoc_link = AssocItemLink::GotoSource(\n@@ -3112,44 +3093,44 @@ fn item_trait(\n                 );\n                 render_impl(w, cx, &implementor, assoc_link,\n                             RenderMode::Normal, implementor.impl_item.stable_since(), false,\n-                            None, true, false)?;\n+                            None, true, false);\n             }\n-            write_loading_content(w, \"\")?;\n+            write_loading_content(w, \"\");\n         }\n \n         write_small_section_header(w, \"implementors\", \"Implementors\",\n-                                   \"<div class='item-list' id='implementors-list'>\")?;\n+                                   \"<div class='item-list' id='implementors-list'>\");\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups)?;\n+            render_implementor(cx, implementor, w, &implementor_dups);\n         }\n-        write_loading_content(w, \"</div>\")?;\n+        write_loading_content(w, \"</div>\");\n \n         if t.auto {\n             write_small_section_header(w, \"synthetic-implementors\", \"Auto implementors\",\n-                                       \"<div class='item-list' id='synthetic-implementors-list'>\")?;\n+                                       \"<div class='item-list' id='synthetic-implementors-list'>\");\n             for implementor in synthetic {\n                 synthetic_types.extend(\n                     collect_paths_for_type(implementor.inner_impl().for_.clone())\n                 );\n-                render_implementor(cx, implementor, w, &implementor_dups)?;\n+                render_implementor(cx, implementor, w, &implementor_dups);\n             }\n-            write_loading_content(w, \"</div>\")?;\n+            write_loading_content(w, \"</div>\");\n         }\n     } else {\n         // even without any implementations to write in, we still want the heading and list, so the\n         // implementors javascript file pulled in below has somewhere to write the impls into\n         write_small_section_header(w, \"implementors\", \"Implementors\",\n-                                   \"<div class='item-list' id='implementors-list'>\")?;\n-        write_loading_content(w, \"</div>\")?;\n+                                   \"<div class='item-list' id='implementors-list'>\");\n+        write_loading_content(w, \"</div>\");\n \n         if t.auto {\n             write_small_section_header(w, \"synthetic-implementors\", \"Auto implementors\",\n-                                       \"<div class='item-list' id='synthetic-implementors-list'>\")?;\n-            write_loading_content(w, \"</div>\")?;\n+                                       \"<div class='item-list' id='synthetic-implementors-list'>\");\n+            write_loading_content(w, \"</div>\");\n         }\n     }\n     write!(w, r#\"<script type=\"text/javascript\">window.inlined_types=new Set({});</script>\"#,\n-           as_json(&synthetic_types))?;\n+           as_json(&synthetic_types));\n \n     write!(w, r#\"<script type=\"text/javascript\" async\n                          src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n@@ -3162,8 +3143,7 @@ fn item_trait(\n                path[..path.len() - 1].join(\"/\")\n            },\n            ty = it.type_().css_class(),\n-           name = *it.name.as_ref().unwrap())?;\n-    Ok(())\n+           name = *it.name.as_ref().unwrap());\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n@@ -3185,70 +3165,60 @@ fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n     }\n }\n \n-fn assoc_const(w: &mut fmt::Formatter<'_>,\n+fn assoc_const(w: &mut Buffer,\n                it: &clean::Item,\n                ty: &clean::Type,\n                _default: Option<&String>,\n                link: AssocItemLink<'_>,\n-               extra: &str) -> fmt::Result {\n+               extra: &str) {\n     write!(w, \"{}{}const <a href='{}' class=\\\"constant\\\"><b>{}</b></a>: {}\",\n            extra,\n            VisSpace(&it.visibility),\n            naive_assoc_href(it, link),\n            it.name.as_ref().unwrap(),\n-           ty)?;\n-    Ok(())\n+           ty);\n }\n \n-fn assoc_type<W: fmt::Write>(w: &mut W, it: &clean::Item,\n-                             bounds: &[clean::GenericBound],\n-                             default: Option<&clean::Type>,\n-                             link: AssocItemLink<'_>,\n-                             extra: &str) -> fmt::Result {\n+fn assoc_type(w: &mut Buffer, it: &clean::Item,\n+              bounds: &[clean::GenericBound],\n+              default: Option<&clean::Type>,\n+              link: AssocItemLink<'_>,\n+              extra: &str) {\n     write!(w, \"{}type <a href='{}' class=\\\"type\\\">{}</a>\",\n            extra,\n            naive_assoc_href(it, link),\n-           it.name.as_ref().unwrap())?;\n+           it.name.as_ref().unwrap());\n     if !bounds.is_empty() {\n-        write!(w, \": {}\", GenericBounds(bounds))?\n+        write!(w, \": {}\", GenericBounds(bounds))\n     }\n     if let Some(default) = default {\n-        write!(w, \" = {}\", default)?;\n+        write!(w, \" = {}\", default)\n     }\n-    Ok(())\n }\n \n-fn render_stability_since_raw<'a, T: fmt::Write>(\n-    w: &mut T,\n-    ver: Option<&'a str>,\n-    containing_ver: Option<&'a str>,\n-) -> fmt::Result {\n+fn render_stability_since_raw(w: &mut Buffer, ver: Option<&str>, containing_ver: Option<&str>) {\n     if let Some(v) = ver {\n         if containing_ver != ver && v.len() > 0 {\n-            write!(w, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\", v)?\n+            write!(w, \"<span class='since' title='Stable since Rust version {0}'>{0}</span>\", v)\n         }\n     }\n-    Ok(())\n }\n \n-fn render_stability_since(w: &mut fmt::Formatter<'_>,\n-                          item: &clean::Item,\n-                          containing_item: &clean::Item) -> fmt::Result {\n+fn render_stability_since(w: &mut Buffer, item: &clean::Item, containing_item: &clean::Item) {\n     render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n }\n \n-fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n+fn render_assoc_item(w: &mut Buffer,\n                      item: &clean::Item,\n                      link: AssocItemLink<'_>,\n-                     parent: ItemType) -> fmt::Result {\n-    fn method(w: &mut fmt::Formatter<'_>,\n+                     parent: ItemType) {\n+    fn method(w: &mut Buffer,\n               meth: &clean::Item,\n               header: hir::FnHeader,\n               g: &clean::Generics,\n               d: &clean::FnDecl,\n               link: AssocItemLink<'_>,\n-              parent: ItemType)\n-              -> fmt::Result {\n+              parent: ItemType) {\n         let name = meth.name.as_ref().unwrap();\n         let anchor = format!(\"#{}.{}\", meth.type_(), name);\n         let href = match link {\n@@ -3283,7 +3253,7 @@ fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n         } else {\n             (0, true)\n         };\n-        render_attributes(w, meth, false)?;\n+        render_attributes(w, meth, false);\n         write!(w, \"{}{}{}{}{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n                if parent == ItemType::Trait { \"    \" } else { \"\" },\n@@ -3309,7 +3279,7 @@ fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n                })\n     }\n     match item.inner {\n-        clean::StrippedItem(..) => Ok(()),\n+        clean::StrippedItem(..) => {},\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.header, &m.generics, &m.decl, link, parent)\n         }\n@@ -3328,22 +3298,21 @@ fn render_assoc_item(w: &mut fmt::Formatter<'_>,\n     }\n }\n \n-fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-               s: &clean::Struct) -> fmt::Result {\n+fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class='rust struct'>\")?;\n-        render_attributes(w, it, true)?;\n+        write!(w, \"<pre class='rust struct'>\");\n+        render_attributes(w, it, true);\n         render_struct(w,\n                       it,\n                       Some(&s.generics),\n                       s.struct_type,\n                       &s.fields,\n                       \"\",\n-                      true)?;\n+                      true);\n         write!(w, \"</pre>\")\n-    })?;\n+    });\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n     let mut fields = s.fields.iter().filter_map(|f| {\n         match f.inner {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n@@ -3354,8 +3323,8 @@ fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n         if fields.peek().is_some() {\n             write!(w, \"<h2 id='fields' class='fields small-section-header'>\n                        Fields{}<a href='#fields' class='anchor'></a></h2>\",\n-                       document_non_exhaustive_header(it))?;\n-            document_non_exhaustive(w, it)?;\n+                       document_non_exhaustive_header(it));\n+            document_non_exhaustive(w, it);\n             for (field, ty) in fields {\n                 let id = cx.derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n@@ -3371,29 +3340,28 @@ fn item_struct(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                        id = id,\n                        ns_id = ns_id,\n                        name = field.name.as_ref().unwrap(),\n-                       ty = ty)?;\n-                document(w, cx, field)?;\n+                       ty = ty);\n+                document(w, cx, field);\n             }\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-               s: &clean::Union) -> fmt::Result {\n+fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class='rust union'>\")?;\n-        render_attributes(w, it, true)?;\n+        write!(w, \"<pre class='rust union'>\");\n+        render_attributes(w, it, true);\n         render_union(w,\n                      it,\n                      Some(&s.generics),\n                      &s.fields,\n                      \"\",\n-                     true)?;\n+                     true);\n         write!(w, \"</pre>\")\n-    })?;\n+    });\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n     let mut fields = s.fields.iter().filter_map(|f| {\n         match f.inner {\n             clean::StructFieldItem(ref ty) => Some((f, ty)),\n@@ -3402,7 +3370,7 @@ fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n     }).peekable();\n     if fields.peek().is_some() {\n         write!(w, \"<h2 id='fields' class='fields small-section-header'>\n-                   Fields<a href='#fields' class='anchor'></a></h2>\")?;\n+                   Fields<a href='#fields' class='anchor'></a></h2>\");\n         for (field, ty) in fields {\n             let name = field.name.as_ref().expect(\"union field name\");\n             let id = format!(\"{}.{}\", ItemType::StructField, name);\n@@ -3413,47 +3381,46 @@ fn item_union(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                    id = id,\n                    name = name,\n                    shortty = ItemType::StructField,\n-                   ty = ty)?;\n+                   ty = ty);\n             if let Some(stability_class) = field.stability_class() {\n                 write!(w, \"<span class='stab {stab}'></span>\",\n-                    stab = stability_class)?;\n+                    stab = stability_class);\n             }\n-            document(w, cx, field)?;\n+            document(w, cx, field);\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-             e: &clean::Enum) -> fmt::Result {\n+fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n     wrap_into_docblock(w, |w| {\n-        write!(w, \"<pre class='rust enum'>\")?;\n-        render_attributes(w, it, true)?;\n+        write!(w, \"<pre class='rust enum'>\");\n+        render_attributes(w, it, true);\n         write!(w, \"{}enum {}{}{}\",\n                VisSpace(&it.visibility),\n                it.name.as_ref().unwrap(),\n                e.generics,\n-               WhereClause { gens: &e.generics, indent: 0, end_newline: true })?;\n+               WhereClause { gens: &e.generics, indent: 0, end_newline: true });\n         if e.variants.is_empty() && !e.variants_stripped {\n-            write!(w, \" {{}}\")?;\n+            write!(w, \" {{}}\");\n         } else {\n-            write!(w, \" {{\\n\")?;\n+            write!(w, \" {{\\n\");\n             for v in &e.variants {\n-                write!(w, \"    \")?;\n+                write!(w, \"    \");\n                 let name = v.name.as_ref().unwrap();\n                 match v.inner {\n                     clean::VariantItem(ref var) => {\n                         match var.kind {\n-                            clean::VariantKind::CLike => write!(w, \"{}\", name)?,\n+                            clean::VariantKind::CLike => write!(w, \"{}\", name),\n                             clean::VariantKind::Tuple(ref tys) => {\n-                                write!(w, \"{}(\", name)?;\n+                                write!(w, \"{}(\", name);\n                                 for (i, ty) in tys.iter().enumerate() {\n                                     if i > 0 {\n-                                        write!(w, \",&nbsp;\")?\n+                                        write!(w, \",&nbsp;\")\n                                     }\n-                                    write!(w, \"{}\", *ty)?;\n+                                    write!(w, \"{}\", *ty);\n                                 }\n-                                write!(w, \")\")?;\n+                                write!(w, \")\");\n                             }\n                             clean::VariantKind::Struct(ref s) => {\n                                 render_struct(w,\n@@ -3462,29 +3429,29 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                                               s.struct_type,\n                                               &s.fields,\n                                               \"    \",\n-                                              false)?;\n+                                              false);\n                             }\n                         }\n                     }\n                     _ => unreachable!()\n                 }\n-                write!(w, \",\\n\")?;\n+                write!(w, \",\\n\");\n             }\n \n             if e.variants_stripped {\n-                write!(w, \"    // some variants omitted\\n\")?;\n+                write!(w, \"    // some variants omitted\\n\");\n             }\n-            write!(w, \"}}\")?;\n+            write!(w, \"}}\");\n         }\n         write!(w, \"</pre>\")\n-    })?;\n+    });\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n     if !e.variants.is_empty() {\n         write!(w, \"<h2 id='variants' class='variants small-section-header'>\n                    Variants{}<a href='#variants' class='anchor'></a></h2>\\n\",\n-                   document_non_exhaustive_header(it))?;\n-        document_non_exhaustive(w, it)?;\n+                   document_non_exhaustive_header(it));\n+        document_non_exhaustive(w, it);\n         for variant in &e.variants {\n             let id = cx.derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n@@ -3497,22 +3464,22 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                        <code id='{ns_id}'>{name}\",\n                    id = id,\n                    ns_id = ns_id,\n-                   name = variant.name.as_ref().unwrap())?;\n+                   name = variant.name.as_ref().unwrap());\n             if let clean::VariantItem(ref var) = variant.inner {\n                 if let clean::VariantKind::Tuple(ref tys) = var.kind {\n-                    write!(w, \"(\")?;\n+                    write!(w, \"(\");\n                     for (i, ty) in tys.iter().enumerate() {\n                         if i > 0 {\n-                            write!(w, \",&nbsp;\")?;\n+                            write!(w, \",&nbsp;\");\n                         }\n-                        write!(w, \"{}\", *ty)?;\n+                        write!(w, \"{}\", *ty);\n                     }\n-                    write!(w, \")\")?;\n+                    write!(w, \")\");\n                 }\n             }\n-            write!(w, \"</code></div>\")?;\n-            document(w, cx, variant)?;\n-            document_non_exhaustive(w, variant)?;\n+            write!(w, \"</code></div>\");\n+            document(w, cx, variant);\n+            document_non_exhaustive(w, variant);\n \n             use crate::clean::{Variant, VariantKind};\n             if let clean::VariantItem(Variant {\n@@ -3522,9 +3489,9 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n                 write!(w, \"<div class='autohide sub-variant' id='{id}'>\",\n-                       id = variant_id)?;\n+                       id = variant_id);\n                 write!(w, \"<h3>Fields of <b>{name}</b></h3><div>\",\n-                       name = variant.name.as_ref().unwrap())?;\n+                       name = variant.name.as_ref().unwrap());\n                 for field in &s.fields {\n                     use crate::clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n@@ -3543,17 +3510,16 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n                                id = id,\n                                ns_id = ns_id,\n                                f = field.name.as_ref().unwrap(),\n-                               t = *ty)?;\n-                        document(w, cx, field)?;\n+                               t = *ty);\n+                        document(w, cx, field);\n                     }\n                 }\n-                write!(w, \"</div></div>\")?;\n+                write!(w, \"</div></div>\");\n             }\n-            render_stability_since(w, variant, it)?;\n+            render_stability_since(w, variant, it);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n-    Ok(())\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n@@ -3596,7 +3562,7 @@ const ATTRIBUTE_WHITELIST: &'static [Symbol] = &[\n //     #[bar] <---- not \"top\" attribute\n //     bar: usize,\n // }\n-fn render_attributes(w: &mut dyn fmt::Write, it: &clean::Item, top: bool) -> fmt::Result {\n+fn render_attributes(w: &mut Buffer, it: &clean::Item, top: bool) {\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n@@ -3609,117 +3575,114 @@ fn render_attributes(w: &mut dyn fmt::Write, it: &clean::Item, top: bool) -> fmt\n     }\n     if attrs.len() > 0 {\n         write!(w, \"<span class=\\\"docblock attributes{}\\\">{}</span>\",\n-               if top { \" top-attr\" } else { \"\" }, &attrs)?;\n+               if top { \" top-attr\" } else { \"\" }, &attrs);\n     }\n-    Ok(())\n }\n \n-fn render_struct(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n+fn render_struct(w: &mut Buffer, it: &clean::Item,\n                  g: Option<&clean::Generics>,\n                  ty: doctree::StructType,\n                  fields: &[clean::Item],\n                  tab: &str,\n-                 structhead: bool) -> fmt::Result {\n+                 structhead: bool) {\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n-           it.name.as_ref().unwrap())?;\n+           it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g)?\n+        write!(w, \"{}\", g)\n     }\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })\n             }\n             let mut has_visible_fields = false;\n-            write!(w, \" {{\")?;\n+            write!(w, \" {{\");\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"\\n{}    {}{}: {},\",\n                            tab,\n                            VisSpace(&field.visibility),\n                            field.name.as_ref().unwrap(),\n-                           *ty)?;\n+                           *ty);\n                     has_visible_fields = true;\n                 }\n             }\n \n             if has_visible_fields {\n                 if it.has_stripped_fields().unwrap() {\n-                    write!(w, \"\\n{}    // some fields omitted\", tab)?;\n+                    write!(w, \"\\n{}    // some fields omitted\", tab);\n                 }\n-                write!(w, \"\\n{}\", tab)?;\n+                write!(w, \"\\n{}\", tab);\n             } else if it.has_stripped_fields().unwrap() {\n                 // If there are no visible fields we can just display\n                 // `{ /* fields omitted */ }` to save space.\n-                write!(w, \" /* fields omitted */ \")?;\n+                write!(w, \" /* fields omitted */ \");\n             }\n-            write!(w, \"}}\")?;\n+            write!(w, \"}}\");\n         }\n         doctree::Tuple => {\n-            write!(w, \"(\")?;\n+            write!(w, \"(\");\n             for (i, field) in fields.iter().enumerate() {\n                 if i > 0 {\n-                    write!(w, \", \")?;\n+                    write!(w, \", \");\n                 }\n                 match field.inner {\n                     clean::StrippedItem(box clean::StructFieldItem(..)) => {\n-                        write!(w, \"_\")?\n+                        write!(w, \"_\")\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n+                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)\n                     }\n                     _ => unreachable!()\n                 }\n             }\n-            write!(w, \")\")?;\n+            write!(w, \")\");\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })\n             }\n-            write!(w, \";\")?;\n+            write!(w, \";\");\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })?\n+                write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: false })\n             }\n-            write!(w, \";\")?;\n+            write!(w, \";\");\n         }\n     }\n-    Ok(())\n }\n \n-fn render_union(w: &mut fmt::Formatter<'_>, it: &clean::Item,\n+fn render_union(w: &mut Buffer, it: &clean::Item,\n                 g: Option<&clean::Generics>,\n                 fields: &[clean::Item],\n                 tab: &str,\n-                structhead: bool) -> fmt::Result {\n+                structhead: bool) {\n     write!(w, \"{}{}{}\",\n            VisSpace(&it.visibility),\n            if structhead {\"union \"} else {\"\"},\n-           it.name.as_ref().unwrap())?;\n+           it.name.as_ref().unwrap());\n     if let Some(g) = g {\n-        write!(w, \"{}\", g)?;\n-        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true })?;\n+        write!(w, \"{}\", g);\n+        write!(w, \"{}\", WhereClause { gens: g, indent: 0, end_newline: true });\n     }\n \n-    write!(w, \" {{\\n{}\", tab)?;\n+    write!(w, \" {{\\n{}\", tab);\n     for field in fields {\n         if let clean::StructFieldItem(ref ty) = field.inner {\n             write!(w, \"    {}{}: {},\\n{}\",\n                    VisSpace(&field.visibility),\n                    field.name.as_ref().unwrap(),\n                    *ty,\n-                   tab)?;\n+                   tab);\n         }\n     }\n \n     if it.has_stripped_fields().unwrap() {\n-        write!(w, \"    // some fields omitted\\n{}\", tab)?;\n+        write!(w, \"    // some fields omitted\\n{}\", tab);\n     }\n-    write!(w, \"}}\")?;\n-    Ok(())\n+    write!(w, \"}}\");\n }\n \n #[derive(Copy, Clone)]\n@@ -3748,15 +3711,15 @@ enum RenderMode {\n     ForDeref { mut_: bool },\n }\n \n-fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n+fn render_assoc_items(w: &mut Buffer,\n                       cx: &Context,\n                       containing_item: &clean::Item,\n                       it: DefId,\n-                      what: AssocItemRender<'_>) -> fmt::Result {\n+                      what: AssocItemRender<'_>) {\n     let c = cache();\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n-        None => return Ok(()),\n+        None => return,\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n         i.inner_impl().trait_.is_none()\n@@ -3768,7 +3731,7 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                     <h2 id='methods' class='small-section-header'>\\\n                       Methods<a href='#methods' class='anchor'></a>\\\n                     </h2>\\\n-                \")?;\n+                \");\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n@@ -3777,17 +3740,17 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                       Methods from {}&lt;Target = {}&gt;\\\n                       <a href='#deref-methods' class='anchor'></a>\\\n                     </h2>\\\n-                \", trait_, type_)?;\n+                \", trait_, type_);\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n         for i in &non_trait {\n             render_impl(w, cx, i, AssocItemLink::Anchor(None), render_mode,\n-                        containing_item.stable_since(), true, None, false, true)?;\n+                        containing_item.stable_since(), true, None, false, true);\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n-        return Ok(());\n+        return;\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n@@ -3797,31 +3760,25 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n             let has_deref_mut = traits.iter().find(|t| {\n                 t.inner_impl().trait_.def_id() == c.deref_mut_trait_did\n             }).is_some();\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut)?;\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) = traits\n             .iter()\n             .partition(|t| t.inner_impl().synthetic);\n-        let (blanket_impl, concrete) = concrete\n+        let (blanket_impl, concrete): (Vec<&&Impl>, _) = concrete\n             .into_iter()\n             .partition(|t| t.inner_impl().blanket_impl.is_some());\n \n-        struct RendererStruct<'a, 'b, 'c>(&'a Context, Vec<&'b &'b Impl>, &'c clean::Item);\n-\n-        impl<'a, 'b, 'c> fmt::Display for RendererStruct<'a, 'b, 'c> {\n-        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            render_impls(self.0, fmt, &self.1, self.2)\n-        }\n-        }\n-\n-        let impls = RendererStruct(cx, concrete, containing_item).to_string();\n+        let mut impls = Buffer::empty_from(&w);\n+        render_impls(cx, &mut impls, &concrete, containing_item);\n+        let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(w, \"\\\n                 <h2 id='implementations' class='small-section-header'>\\\n                   Trait Implementations<a href='#implementations' class='anchor'></a>\\\n                 </h2>\\\n-                <div id='implementations-list'>{}</div>\", impls)?;\n+                <div id='implementations-list'>{}</div>\", impls);\n         }\n \n         if !synthetic.is_empty() {\n@@ -3831,9 +3788,9 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                   <a href='#synthetic-implementations' class='anchor'></a>\\\n                 </h2>\\\n                 <div id='synthetic-implementations-list'>\\\n-            \")?;\n-            render_impls(cx, w, &synthetic, containing_item)?;\n-            write!(w, \"</div>\")?;\n+            \");\n+            render_impls(cx, w, &synthetic, containing_item);\n+            write!(w, \"</div>\");\n         }\n \n         if !blanket_impl.is_empty() {\n@@ -3843,16 +3800,15 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n                   <a href='#blanket-implementations' class='anchor'></a>\\\n                 </h2>\\\n                 <div id='blanket-implementations-list'>\\\n-            \")?;\n-            render_impls(cx, w, &blanket_impl, containing_item)?;\n-            write!(w, \"</div>\")?;\n+            \");\n+            render_impls(cx, w, &blanket_impl, containing_item);\n+            write!(w, \"</div>\");\n         }\n     }\n-    Ok(())\n }\n \n-fn render_deref_methods(w: &mut fmt::Formatter<'_>, cx: &Context, impl_: &Impl,\n-                        container_item: &clean::Item, deref_mut: bool) -> fmt::Result {\n+fn render_deref_methods(w: &mut Buffer, cx: &Context, impl_: &Impl,\n+                        container_item: &clean::Item, deref_mut: bool) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let target = impl_.inner_impl().items.iter().filter_map(|item| {\n         match item.inner {\n@@ -3867,10 +3823,9 @@ fn render_deref_methods(w: &mut fmt::Formatter<'_>, cx: &Context, impl_: &Impl,\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cache().primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what)?;\n+                render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n-        Ok(())\n     }\n }\n \n@@ -3900,24 +3855,24 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n     }\n }\n \n-fn render_spotlight_traits(item: &clean::Item) -> Result<String, fmt::Error> {\n+fn render_spotlight_traits(item: &clean::Item) -> String {\n     let mut out = String::new();\n \n     match item.inner {\n         clean::FunctionItem(clean::Function { ref decl, .. }) |\n         clean::TyMethodItem(clean::TyMethod { ref decl, .. }) |\n         clean::MethodItem(clean::Method { ref decl, .. }) |\n         clean::ForeignFunctionItem(clean::Function { ref decl, .. }) => {\n-            out = spotlight_decl(decl)?;\n+            out = spotlight_decl(decl);\n         }\n         _ => {}\n     }\n \n-    Ok(out)\n+    out\n }\n \n-fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n-    let mut out = String::new();\n+fn spotlight_decl(decl: &clean::FnDecl) -> String {\n+    let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n     if let Some(did) = decl.output.def_id() {\n@@ -3943,7 +3898,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n                             assoc_type(&mut out, it, &[],\n                                        Some(&tydef.type_),\n                                        AssocItemLink::GotoSource(t_did, &FxHashSet::default()),\n-                                       \"\")?;\n+                                       \"\");\n                             out.push_str(\";</span>\");\n                         }\n                     }\n@@ -3960,13 +3915,13 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n         out.push_str(\"</code></div></div>\");\n     }\n \n-    Ok(out)\n+    out.into_inner()\n }\n \n-fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n+fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                render_mode: RenderMode, outer_version: Option<&str>, show_def_docs: bool,\n                use_absolute: Option<bool>, is_on_foreign_type: bool,\n-               show_default_items: bool) -> fmt::Result {\n+               show_default_items: bool) {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => if is_on_foreign_type {\n@@ -3977,45 +3932,45 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n             None => \"impl\".to_string(),\n         });\n         if let Some(use_absolute) = use_absolute {\n-            write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>\", id)?;\n-            fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute)?;\n+            write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>\", id);\n+            fmt_impl_for_trait_page(&i.inner_impl(), w, use_absolute);\n             if show_def_docs {\n                 for it in &i.inner_impl().items {\n                     if let clean::TypedefItem(ref tydef, _) = it.inner {\n-                        write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n+                        write!(w, \"<span class=\\\"where fmt-newline\\\">  \");\n                         assoc_type(w, it, &vec![], Some(&tydef.type_),\n                                    AssocItemLink::Anchor(None),\n-                                   \"\")?;\n-                        write!(w, \";</span>\")?;\n+                                   \"\");\n+                        write!(w, \";</span>\");\n                     }\n                 }\n             }\n-            write!(w, \"</code>\")?;\n+            write!(w, \"</code>\");\n         } else {\n             write!(w, \"<h3 id='{}' class='impl'><code class='in-band'>{}</code>\",\n                 id, i.inner_impl()\n-            )?;\n+            );\n         }\n-        write!(w, \"<a href='#{}' class='anchor'></a>\", id)?;\n+        write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n-        render_stability_since_raw(w, since, outer_version)?;\n+        render_stability_since_raw(w, since, outer_version);\n         if let Some(l) = cx.src_href(&i.impl_item) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                   l, \"goto source code\")?;\n+                   l, \"goto source code\");\n         }\n-        write!(w, \"</h3>\")?;\n+        write!(w, \"</h3>\");\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n             let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n                    Markdown(&*dox, &i.impl_item.links(), &mut ids,\n-                            cx.codes, cx.edition, &cx.playground).to_string())?;\n+                            cx.codes, cx.edition, &cx.playground).to_string());\n         }\n     }\n \n-    fn doc_impl_item(w: &mut fmt::Formatter<'_>, cx: &Context, item: &clean::Item,\n+    fn doc_impl_item(w: &mut Buffer, cx: &Context, item: &clean::Item,\n                      link: AssocItemLink<'_>, render_mode: RenderMode,\n                      is_default_item: bool, outer_version: Option<&str>,\n-                     trait_: Option<&clean::Trait>, show_def_docs: bool) -> fmt::Result {\n+                     trait_: Option<&clean::Trait>, show_def_docs: bool) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n \n@@ -4039,50 +3994,50 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                 if render_method_item {\n                     let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                     let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n-                    write!(w, \"{}\", spotlight_decl(decl)?)?;\n-                    write!(w, \"<code id='{}'>\", ns_id)?;\n-                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n-                    write!(w, \"</code>\")?;\n-                    render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                    write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                    write!(w, \"{}\", spotlight_decl(decl));\n+                    write!(w, \"<code id='{}'>\", ns_id);\n+                    render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n+                    write!(w, \"</code>\");\n+                    render_stability_since_raw(w, item.stable_since(), outer_version);\n                     if let Some(l) = cx.src_href(item) {\n                         write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                               l, \"goto source code\")?;\n+                               l, \"goto source code\");\n                     }\n-                    write!(w, \"</h4>\")?;\n+                    write!(w, \"</h4>\");\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", ItemType::AssocType, name));\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n-                write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id), \"\")?;\n-                write!(w, \"</code></h4>\")?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                write!(w, \"<code id='{}'>\", ns_id);\n+                assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id), \"\");\n+                write!(w, \"</code></h4>\");\n             }\n             clean::AssocConstItem(ref ty, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n-                write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\")?;\n-                write!(w, \"</code>\")?;\n-                render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                write!(w, \"<code id='{}'>\", ns_id);\n+                assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n+                write!(w, \"</code>\");\n+                render_stability_since_raw(w, item.stable_since(), outer_version);\n                 if let Some(l) = cx.src_href(item) {\n                     write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n-                            l, \"goto source code\")?;\n+                            l, \"goto source code\");\n                 }\n-                write!(w, \"</h4>\")?;\n+                write!(w, \"</h4>\");\n             }\n             clean::AssocTypeItem(ref bounds, ref default) => {\n                 let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n                 let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class)?;\n-                write!(w, \"<code id='{}'>\", ns_id)?;\n-                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\")?;\n-                write!(w, \"</code></h4>\")?;\n+                write!(w, \"<h4 id='{}' class=\\\"{}{}\\\">\", id, item_type, extra_class);\n+                write!(w, \"<code id='{}'>\", ns_id);\n+                assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id), \"\");\n+                write!(w, \"</code></h4>\");\n             }\n-            clean::StrippedItem(..) => return Ok(()),\n+            clean::StrippedItem(..) => return,\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n@@ -4094,47 +4049,46 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n                     if let Some(it) = t.items.iter().find(|i| i.name == item.name) {\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n-                        document_stability(w, cx, it, is_hidden)?;\n+                        document_stability(w, cx, it, is_hidden);\n                         if item.doc_value().is_some() {\n-                            document_full(w, item, cx, \"\", is_hidden)?;\n+                            document_full(w, item, cx, \"\", is_hidden);\n                         } else if show_def_docs {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, cx, it, link, \"\", is_hidden)?;\n+                            document_short(w, cx, it, link, \"\", is_hidden);\n                         }\n                     }\n                 } else {\n-                    document_stability(w, cx, item, is_hidden)?;\n+                    document_stability(w, cx, item, is_hidden);\n                     if show_def_docs {\n-                        document_full(w, item, cx, \"\", is_hidden)?;\n+                        document_full(w, item, cx, \"\", is_hidden);\n                     }\n                 }\n             } else {\n-                document_stability(w, cx, item, is_hidden)?;\n+                document_stability(w, cx, item, is_hidden);\n                 if show_def_docs {\n-                    document_short(w, cx, item, link, \"\", is_hidden)?;\n+                    document_short(w, cx, item, link, \"\", is_hidden);\n                 }\n             }\n         }\n-        Ok(())\n     }\n \n     let traits = &cache().traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n-    write!(w, \"<div class='impl-items'>\")?;\n+    write!(w, \"<div class='impl-items'>\");\n     for trait_item in &i.inner_impl().items {\n         doc_impl_item(w, cx, trait_item, link, render_mode,\n-                      false, outer_version, trait_, show_def_docs)?;\n+                      false, outer_version, trait_, show_def_docs);\n     }\n \n-    fn render_default_items(w: &mut fmt::Formatter<'_>,\n+    fn render_default_items(w: &mut Buffer,\n                             cx: &Context,\n                             t: &clean::Trait,\n                             i: &clean::Impl,\n                             render_mode: RenderMode,\n                             outer_version: Option<&str>,\n-                            show_def_docs: bool) -> fmt::Result {\n+                            show_def_docs: bool) {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n             if i.items.iter().find(|m| m.name == n).is_some() {\n@@ -4144,9 +4098,8 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n             doc_impl_item(w, cx, trait_item, assoc_link, render_mode, true,\n-                          outer_version, None, show_def_docs)?;\n+                          outer_version, None, show_def_docs);\n         }\n-        Ok(())\n     }\n \n     // If we've implemented a trait, then also emit documentation for all\n@@ -4156,29 +4109,27 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n     if show_default_items {\n         if let Some(t) = trait_ {\n             render_default_items(w, cx, t, &i.inner_impl(),\n-                                render_mode, outer_version, show_def_docs)?;\n+                                render_mode, outer_version, show_def_docs);\n         }\n     }\n-    write!(w, \"</div>\")?;\n-\n-    Ok(())\n+    write!(w, \"</div>\");\n }\n \n fn item_opaque_ty(\n-    w: &mut fmt::Formatter<'_>,\n+    w: &mut Buffer,\n     cx: &Context,\n     it: &clean::Item,\n     t: &clean::OpaqueTy,\n-) -> fmt::Result {\n-    write!(w, \"<pre class='rust opaque'>\")?;\n-    render_attributes(w, it, false)?;\n+) {\n+    write!(w, \"<pre class='rust opaque'>\");\n+    render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = impl {bounds};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           bounds = bounds(&t.bounds, false))?;\n+           bounds = bounds(&t.bounds, false));\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -4187,17 +4138,17 @@ fn item_opaque_ty(\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-                    t: &clean::TraitAlias) -> fmt::Result {\n-    write!(w, \"<pre class='rust trait-alias'>\")?;\n-    render_attributes(w, it, false)?;\n+fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item,\n+                    t: &clean::TraitAlias) {\n+    write!(w, \"<pre class='rust trait-alias'>\");\n+    render_attributes(w, it, false);\n     write!(w, \"trait {}{}{} = {};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n            WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           bounds(&t.bounds, true))?;\n+           bounds(&t.bounds, true));\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -4206,17 +4157,16 @@ fn item_trait_alias(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-                t: &clean::Typedef) -> fmt::Result {\n-    write!(w, \"<pre class='rust typedef'>\")?;\n-    render_attributes(w, it, false)?;\n+fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef) {\n+    write!(w, \"<pre class='rust typedef'>\");\n+    render_attributes(w, it, false);\n     write!(w, \"type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,\n            where_clause = WhereClause { gens: &t.generics, indent: 0, end_newline: true },\n-           type_ = t.type_)?;\n+           type_ = t.type_);\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n \n     // Render any items associated directly to this alias, as otherwise they\n     // won't be visible anywhere in the docs. It would be nice to also show\n@@ -4225,17 +4175,17 @@ fn item_typedef(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_foreign_type(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item) -> fmt::Result {\n-    writeln!(w, \"<pre class='rust foreigntype'>extern {{\")?;\n-    render_attributes(w, it, false)?;\n+fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+    writeln!(w, \"<pre class='rust foreigntype'>extern {{\");\n+    render_attributes(w, it, false);\n     write!(\n         w,\n         \"    {}type {};\\n}}</pre>\",\n         VisSpace(&it.visibility),\n         it.name.as_ref().unwrap(),\n-    )?;\n+    );\n \n-    document(w, cx, it)?;\n+    document(w, cx, it);\n \n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n@@ -4790,59 +4740,56 @@ fn sidebar_foreign_type(buf: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn item_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n-              t: &clean::Macro) -> fmt::Result {\n+fn item_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Macro) {\n     wrap_into_docblock(w, |w| {\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n                                                          Some(\"macro\"),\n                                                          None,\n                                                          None))\n-    })?;\n+    });\n     document(w, cx, it)\n }\n \n-fn item_proc_macro(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item, m: &clean::ProcMacro)\n-    -> fmt::Result\n-{\n+fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::ProcMacro) {\n     let name = it.name.as_ref().expect(\"proc-macros always have names\");\n     match m.kind {\n         MacroKind::Bang => {\n-            write!(w, \"<pre class='rust macro'>\")?;\n-            write!(w, \"{}!() {{ /* proc-macro */ }}\", name)?;\n-            write!(w, \"</pre>\")?;\n+            write!(w, \"<pre class='rust macro'>\");\n+            write!(w, \"{}!() {{ /* proc-macro */ }}\", name);\n+            write!(w, \"</pre>\");\n         }\n         MacroKind::Attr => {\n-            write!(w, \"<pre class='rust attr'>\")?;\n-            write!(w, \"#[{}]\", name)?;\n-            write!(w, \"</pre>\")?;\n+            write!(w, \"<pre class='rust attr'>\");\n+            write!(w, \"#[{}]\", name);\n+            write!(w, \"</pre>\");\n         }\n         MacroKind::Derive => {\n-            write!(w, \"<pre class='rust derive'>\")?;\n-            write!(w, \"#[derive({})]\", name)?;\n+            write!(w, \"<pre class='rust derive'>\");\n+            write!(w, \"#[derive({})]\", name);\n             if !m.helpers.is_empty() {\n-                writeln!(w, \"\\n{{\")?;\n-                writeln!(w, \"    // Attributes available to this derive:\")?;\n+                writeln!(w, \"\\n{{\");\n+                writeln!(w, \"    // Attributes available to this derive:\");\n                 for attr in &m.helpers {\n-                    writeln!(w, \"    #[{}]\", attr)?;\n+                    writeln!(w, \"    #[{}]\", attr);\n                 }\n-                write!(w, \"}}\")?;\n+                write!(w, \"}}\");\n             }\n-            write!(w, \"</pre>\")?;\n+            write!(w, \"</pre>\");\n         }\n     }\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut fmt::Formatter<'_>, cx: &Context,\n+fn item_primitive(w: &mut Buffer, cx: &Context,\n                   it: &clean::Item,\n-                  _p: &clean::PrimitiveType) -> fmt::Result {\n-    document(w, cx, it)?;\n+                  _p: &clean::PrimitiveType) {\n+    document(w, cx, it);\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n-fn item_keyword(w: &mut fmt::Formatter<'_>, cx: &Context,\n+fn item_keyword(w: &mut Buffer, cx: &Context,\n                 it: &clean::Item,\n-                _p: &str) -> fmt::Result {\n+                _p: &str) {\n     document(w, cx, it)\n }\n "}]}