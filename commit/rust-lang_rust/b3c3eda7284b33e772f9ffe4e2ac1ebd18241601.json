{"sha": "b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "node_id": "C_kwDOAAsO6NoAKGIzYzNlZGE3Mjg0YjMzZTc3MmY5ZmZlNGUyYWMxZWJkMTgyNDE2MDE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-04T23:53:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-04T23:53:36Z"}, "message": "Rollup merge of #95642 - lcnr:probe-smol, r=compiler-errors\n\n`CandidateSource::XCandidate` -> `CandidateSource::X`", "tree": {"sha": "f25421eaab99b5865f839a5315b36a834c632c74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f25421eaab99b5865f839a5315b36a834c632c74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiS4UACRBK7hj4Ov3rIwAAIFAIACgIyLVB5q5S3pQ945flpU5q\nToEJ93ZlARyoDr6imrpbb7ubMw2lZe+XaTaluIGFGn1fW2Hz5Fj2osuQ+WTzyCCV\nPOuMOgdI7efRjmDBeoduQNoNa7+1TrvBbPzuuzHdSSR5dWC5YvrCegozpjwOZJkA\nZrQKricOJyKQ/3B/xuO6gTtNBD/0MGLZ2BrYb6witzc/Z/QygCSTju77fkcObulI\n7RxiXcF0nuCixGqaEVJ9XZKV8quSpzOXf1zV7oh4mbwwQqj5ucD9h/P+Jg1puFHi\nhJJWLCK7Yar9TfGLUkm7BrAzn+AnY4Q7QbOV0fRMgtzodlGxB2+GClTQA/pwi6I=\n=FiJ1\n-----END PGP SIGNATURE-----\n", "payload": "tree f25421eaab99b5865f839a5315b36a834c632c74\nparent 5b8ac2d1b6ae3063e03fd784de0a9a7cf888b21d\nparent 58dfe26045487ad490a8d095823ec69f12edf0f2\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649116416 +0200\ncommitter GitHub <noreply@github.com> 1649116416 +0200\n\nRollup merge of #95642 - lcnr:probe-smol, r=compiler-errors\n\n`CandidateSource::XCandidate` -> `CandidateSource::X`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "html_url": "https://github.com/rust-lang/rust/commit/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b8ac2d1b6ae3063e03fd784de0a9a7cf888b21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b8ac2d1b6ae3063e03fd784de0a9a7cf888b21d", "html_url": "https://github.com/rust-lang/rust/commit/5b8ac2d1b6ae3063e03fd784de0a9a7cf888b21d"}, {"sha": "58dfe26045487ad490a8d095823ec69f12edf0f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58dfe26045487ad490a8d095823ec69f12edf0f2", "html_url": "https://github.com/rust-lang/rust/commit/58dfe26045487ad490a8d095823ec69f12edf0f2"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "8137d7029218296500edc721d5101f0b9eabe51c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "patch": "@@ -8,7 +8,6 @@ pub mod probe;\n mod suggest;\n \n pub use self::suggest::SelfSource;\n-pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n@@ -82,8 +81,8 @@ pub struct NoMatchData<'tcx> {\n // candidate can arise. Used for error reporting only.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n-    ImplSource(DefId),\n-    TraitSource(DefId /* trait id */),\n+    Impl(DefId),\n+    Trait(DefId /* trait id */),\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -237,8 +236,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match *source {\n                             // Note: this cannot come from an inherent impl,\n                             // because the first probing succeeded.\n-                            ImplSource(def) => self.tcx.trait_id_of_impl(def),\n-                            TraitSource(_) => None,\n+                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                            CandidateSource::Trait(_) => None,\n                         }\n                     })\n                     .collect(),"}, {"sha": "83474bd7e72f7d377997b52a6016efc15fcf023d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "patch": "@@ -1,7 +1,7 @@\n use super::suggest;\n+use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n-use super::{CandidateSource, ImplSource, TraitSource};\n \n use crate::check::FnCtxt;\n use crate::errors::MethodCallOnUnknownType;\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         for item in self.impl_or_trait_item(impl_def_id) {\n             if !self.has_applicable_self(&item) {\n                 // No receiver declared. Not a candidate.\n-                self.record_static_candidate(ImplSource(impl_def_id));\n+                self.record_static_candidate(CandidateSource::Impl(impl_def_id));\n                 continue;\n             }\n \n@@ -848,7 +848,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"elaborate_bounds(bound_trait_ref={:?})\", bound_trait_ref);\n             for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 if !self.has_applicable_self(&item) {\n-                    self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n+                    self.record_static_candidate(CandidateSource::Trait(bound_trait_ref.def_id()));\n                 } else {\n                     mk_cand(self, bound_trait_ref, item);\n                 }\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // Check whether `trait_def_id` defines a method with suitable name.\n                 if !self.has_applicable_self(&item) {\n                     debug!(\"method has inapplicable self\");\n-                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    self.record_static_candidate(CandidateSource::Trait(trait_def_id));\n                     continue;\n                 }\n \n@@ -1018,8 +1018,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {\n-                    TraitSource(id) => id,\n-                    ImplSource(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n+                    CandidateSource::Trait(id) => id,\n+                    CandidateSource::Impl(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n                         Some(id) => id,\n                         None => span_bug!(span, \"found inherent method when looking at traits\"),\n                     },\n@@ -1417,8 +1417,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn candidate_source(&self, candidate: &Candidate<'tcx>, self_ty: Ty<'tcx>) -> CandidateSource {\n         match candidate.kind {\n-            InherentImplCandidate(..) => ImplSource(candidate.item.container.id()),\n-            ObjectCandidate | WhereClauseCandidate(_) => TraitSource(candidate.item.container.id()),\n+            InherentImplCandidate(..) => CandidateSource::Impl(candidate.item.container.id()),\n+            ObjectCandidate | WhereClauseCandidate(_) => {\n+                CandidateSource::Trait(candidate.item.container.id())\n+            }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n@@ -1428,9 +1430,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n                         // to that impl.\n-                        ImplSource(impl_data.impl_def_id)\n+                        CandidateSource::Impl(impl_data.impl_def_id)\n                     }\n-                    _ => TraitSource(candidate.item.container.id()),\n+                    _ => CandidateSource::Trait(candidate.item.container.id()),\n                 }\n             }),\n         }"}, {"sha": "c2cb233f5b84cfa142a433db644762a95b1ba418", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             for (idx, source) in sources.iter().take(limit).enumerate() {\n                 match *source {\n-                    CandidateSource::ImplSource(impl_did) => {\n+                    CandidateSource::Impl(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n                         let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    CandidateSource::TraitSource(trait_did) => {\n+                    CandidateSource::Trait(trait_did) => {\n                         let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                         let item_span = self\n                             .tcx\n@@ -515,23 +515,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_sources.len() == 1 {\n-                    let ty_str = if let Some(CandidateSource::ImplSource(impl_did)) =\n-                        static_sources.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                // Use `actual` as it will have more `substs` filled in.\n-                                self.ty_to_value_string(actual.peel_refs())\n+                    let ty_str =\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                            // When the \"method\" is resolved through dereferencing, we really want the\n+                            // original type that has the associated function for accurate suggestions.\n+                            // (#61411)\n+                            let ty = tcx.at(span).type_of(*impl_did);\n+                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n+                                    // Use `actual` as it will have more `substs` filled in.\n+                                    self.ty_to_value_string(actual.peel_refs())\n+                                }\n+                                _ => self.ty_to_value_string(ty.peel_refs()),\n                             }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n-                    };\n+                        } else {\n+                            self.ty_to_value_string(actual.peel_refs())\n+                        };\n                     if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n                             expr.span.to(span),"}]}