{"sha": "fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNTBhYmU2YzU0ZDg5MmU0Y2I3ZmJiOTNmOTU5YmExNGVkNjg4MTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-14T00:31:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-14T00:31:34Z"}, "message": "rustc: Instantiate \"caller\" regions when calling functions", "tree": {"sha": "9fea5902bc920d9e701e5b07de4504aa78f99b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fea5902bc920d9e701e5b07de4504aa78f99b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "html_url": "https://github.com/rust-lang/rust/commit/fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc50abe6c54d892e4cb7fbb93f959ba14ed68810/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aeb445b2ea25f9629df1d5d8fbd2906a92c8e719", "url": "https://api.github.com/repos/rust-lang/rust/commits/aeb445b2ea25f9629df1d5d8fbd2906a92c8e719", "html_url": "https://github.com/rust-lang/rust/commit/aeb445b2ea25f9629df1d5d8fbd2906a92c8e719"}], "stats": {"total": 76, "additions": 64, "deletions": 12}, "files": [{"sha": "55b5842db25b5c7e92f55594c3cd4c424b1d6b2d", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc50abe6c54d892e4cb7fbb93f959ba14ed68810/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc50abe6c54d892e4cb7fbb93f959ba14ed68810/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "patch": "@@ -38,7 +38,9 @@ type region_map = {\n     /* Mapping from a region name to its function. */\n     region_name_to_fn: hashmap<ast::def_id,ast::node_id>,\n     /* Mapping from an AST type node to the region that `&` resolves to. */\n-    ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>\n+    ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>,\n+    /* Mapping from a call site (or `bind` site) to its containing block. */\n+    call_site_to_block: hashmap<ast::node_id,ast::node_id>\n };\n \n type ctxt = {\n@@ -237,6 +239,16 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n                           in_alt: false with cx};\n             visit::visit_expr(expr, new_cx, visitor);\n         }\n+        ast::expr_call(_, _, _) | ast::expr_bind(_, _) {\n+            // Record the block that this call appears in.\n+            alt cx.parent {\n+                pa_block(blk_id) {\n+                    cx.region_map.call_site_to_block.insert(expr.id, blk_id);\n+                }\n+                _ { cx.sess.span_bug(expr.span, \"expr outside of block?!\"); }\n+            }\n+            visit::visit_expr(expr, cx, visitor);\n+        }\n         _ { visit::visit_expr(expr, cx, visitor); }\n     }\n }\n@@ -263,7 +275,8 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n                                   local_blocks: map::new_int_hash(),\n                                   region_name_to_fn: new_def_hash(),\n                                   ast_type_to_inferred_region:\n-                                    map::new_int_hash()},\n+                                    map::new_int_hash(),\n+                                  call_site_to_block: map::new_int_hash()},\n                     mut bindings: @list::nil,\n                     mut queued_locals: [],\n                     parent: pa_crate,"}, {"sha": "c129d5cadc378abbdde1cfc4bbd1b2496d71c20e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fc50abe6c54d892e4cb7fbb93f959ba14ed68810/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc50abe6c54d892e4cb7fbb93f959ba14ed68810/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=fc50abe6c54d892e4cb7fbb93f959ba14ed68810", "patch": "@@ -1970,8 +1970,42 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, fty: ty::t,\n-                          args: [option<@ast::expr>]) -> bool {\n+    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n+                          fty: ty::t, args: [option<@ast::expr>]) -> bool {\n+        // Replaces \"caller\" regions in the arguments with the local region.\n+        fn instantiate_caller_regions(fcx: @fn_ctxt, id: ast::node_id,\n+                                      args: [ty::arg]) -> [ty::arg] {\n+            let site_to_block = fcx.ccx.tcx.region_map.call_site_to_block;\n+            let block_id = alt site_to_block.find(id) {\n+                none {\n+                    // This can happen for those expressions that are\n+                    // synthesized during typechecking; e.g. during\n+                    // check_constraints().\n+                    ret args;\n+                }\n+                some(block_id) { block_id }\n+            };\n+\n+            let region = ty::re_block(block_id);\n+            ret vec::map(args) {|arg|\n+                if ty::type_has_rptrs(arg.ty) {\n+                    let ty = ty::fold_ty(fcx.ccx.tcx, ty::fm_rptr({|r|\n+                        alt r {\n+                            ty::re_caller(_) {\n+                                // FIXME: We should not recurse into nested\n+                                // function types here.\n+                                region\n+                            }\n+                            _ { r }\n+                        }\n+                    }), arg.ty);\n+                    {ty: ty with arg}\n+                } else {\n+                    arg\n+                }\n+            };\n+        }\n+\n         let sty = structure_of(fcx, sp, fty);\n         // Grab the argument types\n         let arg_tys = alt sty {\n@@ -2009,6 +2043,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             arg_tys = vec::from_elem(supplied_arg_count, dummy);\n         }\n \n+        arg_tys = instantiate_caller_regions(fcx, id, arg_tys);\n+\n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n         // that are not anonymous functions, then we typecheck the anonymous\n@@ -2049,7 +2085,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr])\n+    fn check_call(fcx: @fn_ctxt, sp: span, id: ast::node_id, f: @ast::expr,\n+                  args: [@ast::expr])\n         -> bool {\n         let args_opt_0: [option<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n@@ -2058,13 +2095,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let bot = check_expr(fcx, f);\n         // Call the generic checker.\n-        bot | check_call_or_bind(fcx, sp, expr_ty(fcx.ccx.tcx, f), args_opt_0)\n+        bot | check_call_or_bind(fcx, sp, id, expr_ty(fcx.ccx.tcx, f),\n+                                 args_opt_0)\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call_full(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n-                       args: [@ast::expr], id: ast::node_id) -> bool {\n-        let bot = check_call(fcx, sp, f, args);\n+    fn check_call_full(fcx: @fn_ctxt, sp: span, id: ast::node_id,\n+                       f: @ast::expr, args: [@ast::expr]) -> bool {\n+        let bot = check_call(fcx, sp, id, f, args);\n         /* here we're kind of hosed, as f can be any expr\n         need to restrict it to being an explicit expr_path if we're\n         inside a pure function, and need an environment mapping from\n@@ -2145,7 +2183,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         alt lookup_method(fcx, op_ex, callee_id, opname, self_t, []) {\n           some(origin) {\n             let method_ty = ty::node_id_to_type(fcx.ccx.tcx, callee_id);\n-            check_call_or_bind(fcx, op_ex.span, method_ty, args);\n+            check_call_or_bind(fcx, op_ex.span, op_ex.id, method_ty, args);\n             fcx.ccx.method_map.insert(op_ex.id, origin);\n             some(ty::ty_fn_ret(method_ty))\n           }\n@@ -2472,7 +2510,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_bind(f, args) {\n         // Call the generic checker.\n         bot = check_expr(fcx, f);\n-        bot |= check_call_or_bind(fcx, expr.span, expr_ty(tcx, f), args);\n+        bot |= check_call_or_bind(fcx, expr.span, expr.id, expr_ty(tcx, f),\n+                                  args);\n \n         // Pull the argument and return types out.\n         let proto, arg_tys, rt, cf, constrs;\n@@ -2518,7 +2557,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write_ty(tcx, id, ft);\n       }\n       ast::expr_call(f, args, _) {\n-        bot = check_call_full(fcx, expr.span, f, args, expr.id);\n+        bot = check_call_full(fcx, expr.span, expr.id, f, args);\n       }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);"}]}