{"sha": "44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "node_id": "C_kwDOAAsO6NoAKDQ0Yzg0YThkMjg0OGM5ZmFlNGQ0OTZjMGQ5ZGM5ZThjOThjOGYxZWY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T17:34:47Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-09T13:50:00Z"}, "message": "Add `convert_ufcs_to_method` assist", "tree": {"sha": "b8006ce63880f2472edb5f87f1a4643a025df592", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8006ce63880f2472edb5f87f1a4643a025df592"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "html_url": "https://github.com/rust-lang/rust/commit/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae659125a509967f09665b96d06f6ce6bf1ddd1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae659125a509967f09665b96d06f6ce6bf1ddd1b", "html_url": "https://github.com/rust-lang/rust/commit/ae659125a509967f09665b96d06f6ce6bf1ddd1b"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "8704e40b0d7ba16aae5e2cf22aea5c46d616f641", "filename": "crates/ide-assists/src/handlers/convert_ufcs_to_method.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_ufcs_to_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_ufcs_to_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_ufcs_to_method.rs?ref=44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "patch": "@@ -0,0 +1,211 @@\n+use syntax::{\n+    ast::{self, make, AstNode, HasArgList},\n+    TextRange,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_ufcs_to_method\n+//\n+// Transforms universal function call syntax into a method call.\n+//\n+// ```\n+// fn main() {\n+//     std::ops::Add::add$0(1, 2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     1.add(2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+pub(crate) fn convert_ufcs_to_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call = ctx.find_node_at_offset::<ast::CallExpr>()?;\n+    let ast::Expr::PathExpr(path_expr) = call.expr()? else { return None };\n+    let path = path_expr.path()?;\n+\n+    let cursor_in_range = path.syntax().text_range().contains_range(ctx.selection_trimmed());\n+    if !cursor_in_range {\n+        return None;\n+    }\n+\n+    let args = call.arg_list()?;\n+    let l_paren = args.l_paren_token()?;\n+    let mut args_iter = args.args();\n+    let first_arg = args_iter.next()?;\n+    let second_arg = args_iter.next();\n+\n+    _ = path.qualifier()?;\n+    let method_name = path.segment()?.name_ref()?;\n+\n+    let res = ctx.sema.resolve_path(&path)?;\n+    let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else { return None };\n+    if !fun.has_self_param(ctx.sema.db) {\n+        return None;\n+    }\n+\n+    // `core::ops::Add::add(` -> ``\n+    let delete_path =\n+        TextRange::new(path.syntax().text_range().start(), l_paren.text_range().end());\n+\n+    // Parens around `expr` if needed\n+    let parens = needs_parens_as_receiver(&first_arg).then(|| {\n+        let range = first_arg.syntax().text_range();\n+        (range.start(), range.end())\n+    });\n+\n+    // `, ` -> `.add(`\n+    let replace_comma = TextRange::new(\n+        first_arg.syntax().text_range().end(),\n+        second_arg\n+            .map(|a| a.syntax().text_range().start())\n+            .unwrap_or_else(|| first_arg.syntax().text_range().end()),\n+    );\n+\n+    acc.add(\n+        AssistId(\"convert_ufcs_to_method\", AssistKind::RefactorRewrite),\n+        \"Convert UFCS to a method call\",\n+        call.syntax().text_range(),\n+        |edit| {\n+            edit.delete(delete_path);\n+            if let Some((open, close)) = parens {\n+                edit.insert(open, \"(\");\n+                edit.insert(close, \")\");\n+            }\n+            edit.replace(replace_comma, format!(\".{method_name}(\"));\n+        },\n+    )\n+}\n+\n+fn needs_parens_as_receiver(expr: &ast::Expr) -> bool {\n+    // Make `(expr).dummy()`\n+    let dummy_call = make::expr_method_call(\n+        make::expr_paren(expr.clone()),\n+        make::name_ref(\"dummy\"),\n+        make::arg_list([]),\n+    );\n+\n+    // Get the `expr` clone with the right parent back\n+    // (unreachable!s are fine since we've just constructed the expression)\n+    let ast::Expr::MethodCallExpr(call) = &dummy_call else { unreachable!() };\n+    let Some(receiver) = call.receiver() else { unreachable!() };\n+    let ast::Expr::ParenExpr(parens) = receiver else { unreachable!() };\n+    let Some(expr) = parens.expr() else { unreachable!() };\n+\n+    expr.needs_parens_in(dummy_call.syntax().clone())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn ufcs2method_simple() {\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S::$0f(S, S); }\"#,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S.f(S); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ufcs2method_trait() {\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+//- minicore: add\n+fn f() { <u32 as core::ops::Add>::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+//- minicore: add\n+use core::ops::Add;\n+fn f() { <_>::$0add(2, 2); }\"#,\n+            r#\"\n+use core::ops::Add;\n+fn f() { 2.add(2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ufcs2method_single_arg() {\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S::$0f(S); }\"#,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S.f(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ufcs2method_parens() {\n+        check_assist(\n+            convert_ufcs_to_method,\n+            r#\"\n+//- minicore: deref\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { core::ops::Deref::$0deref(&S); }\"#,\n+            r#\"\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { (&S).deref(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ufcs2method_doesnt_apply_with_cursor_not_on_path() {\n+        check_assist_not_applicable(\n+            convert_ufcs_to_method,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::add(2,$0 2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn ufcs2method_doesnt_apply_with_no_self() {\n+        check_assist_not_applicable(\n+            convert_ufcs_to_method,\n+            r#\"\n+struct S;\n+impl S { fn assoc(S: S, S: S) {} }\n+fn f() { S::assoc$0(S, S); }\"#,\n+        );\n+    }\n+}"}, {"sha": "6da51cfa4f7022ae742d5068d2d77774cd480b4d", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "patch": "@@ -126,6 +126,7 @@ mod handlers {\n     mod convert_to_guarded_return;\n     mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n+    mod convert_ufcs_to_method;\n     mod destructure_tuple_binding;\n     mod expand_glob_import;\n     mod extract_expressions_from_format_string;\n@@ -218,6 +219,7 @@ mod handlers {\n             convert_bool_then::convert_bool_then_to_if,\n             convert_bool_then::convert_if_to_bool_then,\n             convert_comment_block::convert_comment_block,\n+            convert_ufcs_to_method::convert_ufcs_to_method,\n             convert_integer_literal::convert_integer_literal,\n             convert_into_to_from::convert_into_to_from,\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,"}, {"sha": "d84f343c551054deadfc0849da23914c3b69fac1", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=44c84a8d2848c9fae4d496c0d9dc9e8c98c8f1ef", "patch": "@@ -554,6 +554,25 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_ufcs_to_method() {\n+    check_doc_test(\n+        \"convert_ufcs_to_method\",\n+        r#####\"\n+fn main() {\n+    std::ops::Add::add$0(1, 2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+        r#####\"\n+fn main() {\n+    1.add(2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_while_to_loop() {\n     check_doc_test("}]}