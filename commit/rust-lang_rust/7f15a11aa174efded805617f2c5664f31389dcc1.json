{"sha": "7f15a11aa174efded805617f2c5664f31389dcc1", "node_id": "C_kwDOAAsO6NoAKDdmMTVhMTFhYTE3NGVmZGVkODA1NjE3ZjJjNTY2NGYzMTM4OWRjYzE", "commit": {"author": {"name": "Samuel Tardieu", "email": "sam@rfc1149.net", "date": "2023-02-12T08:18:55Z"}, "committer": {"name": "Samuel Tardieu", "email": "sam@rfc1149.net", "date": "2023-02-14T23:47:43Z"}, "message": "manual_let_else: let/else is not divergent by default\n\nThe divergent `else` block of a `let`/`else` statement does not make\nthe `let`/`else` statement itself divergent.", "tree": {"sha": "64e149c4105c3e8cac0f76c6b28971b0a8763c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e149c4105c3e8cac0f76c6b28971b0a8763c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f15a11aa174efded805617f2c5664f31389dcc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f15a11aa174efded805617f2c5664f31389dcc1", "html_url": "https://github.com/rust-lang/rust/commit/7f15a11aa174efded805617f2c5664f31389dcc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f15a11aa174efded805617f2c5664f31389dcc1/comments", "author": {"login": "samueltardieu", "id": 44656, "node_id": "MDQ6VXNlcjQ0NjU2", "avatar_url": "https://avatars.githubusercontent.com/u/44656?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samueltardieu", "html_url": "https://github.com/samueltardieu", "followers_url": "https://api.github.com/users/samueltardieu/followers", "following_url": "https://api.github.com/users/samueltardieu/following{/other_user}", "gists_url": "https://api.github.com/users/samueltardieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/samueltardieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samueltardieu/subscriptions", "organizations_url": "https://api.github.com/users/samueltardieu/orgs", "repos_url": "https://api.github.com/users/samueltardieu/repos", "events_url": "https://api.github.com/users/samueltardieu/events{/privacy}", "received_events_url": "https://api.github.com/users/samueltardieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "samueltardieu", "id": 44656, "node_id": "MDQ6VXNlcjQ0NjU2", "avatar_url": "https://avatars.githubusercontent.com/u/44656?v=4", "gravatar_id": "", "url": "https://api.github.com/users/samueltardieu", "html_url": "https://github.com/samueltardieu", "followers_url": "https://api.github.com/users/samueltardieu/followers", "following_url": "https://api.github.com/users/samueltardieu/following{/other_user}", "gists_url": "https://api.github.com/users/samueltardieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/samueltardieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/samueltardieu/subscriptions", "organizations_url": "https://api.github.com/users/samueltardieu/orgs", "repos_url": "https://api.github.com/users/samueltardieu/repos", "events_url": "https://api.github.com/users/samueltardieu/events{/privacy}", "received_events_url": "https://api.github.com/users/samueltardieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e40f94a8607f42e1de28286bb401154ba621314", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e40f94a8607f42e1de28286bb401154ba621314", "html_url": "https://github.com/rust-lang/rust/commit/0e40f94a8607f42e1de28286bb401154ba621314"}], "stats": {"total": 157, "additions": 105, "deletions": 52}, "files": [{"sha": "5db5c6447364a999cce71ee724fc307906b2a804", "filename": "clippy_lints/src/manual_let_else.rs", "status": "modified", "additions": 94, "deletions": 52, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/7f15a11aa174efded805617f2c5664f31389dcc1/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f15a11aa174efded805617f2c5664f31389dcc1/clippy_lints%2Fsrc%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_let_else.rs?ref=7f15a11aa174efded805617f2c5664f31389dcc1", "patch": "@@ -4,11 +4,12 @@ use clippy_utils::msrvs::{self, Msrv};\n use clippy_utils::peel_blocks;\n use clippy_utils::source::snippet_with_context;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::visitors::{for_each_expr, Descend};\n+use clippy_utils::visitors::{Descend, Visitable};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind};\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::{Expr, ExprKind, HirId, ItemId, Local, MatchSource, Pat, PatKind, QPath, Stmt, StmtKind, Ty};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -162,61 +163,102 @@ fn emit_manual_let_else(cx: &LateContext<'_>, span: Span, expr: &Expr<'_>, pat:\n     );\n }\n \n-fn expr_diverges(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-    fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n-        if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {\n-            return ty.is_never();\n-        }\n-        false\n+/// Check whether an expression is divergent. May give false negatives.\n+fn expr_diverges(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        res: ControlFlow<(), Descend>,\n     }\n-    // We can't just call is_never on expr and be done, because the type system\n-    // sometimes coerces the ! type to something different before we can get\n-    // our hands on it. So instead, we do a manual search. We do fall back to\n-    // is_never in some places when there is no better alternative.\n-    for_each_expr(expr, |ex| {\n-        match ex.kind {\n-            ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => ControlFlow::Break(()),\n-            ExprKind::Call(call, _) => {\n-                if is_never(cx, ex) || is_never(cx, call) {\n-                    return ControlFlow::Break(());\n-                }\n-                ControlFlow::Continue(Descend::Yes)\n-            },\n-            ExprKind::MethodCall(..) => {\n-                if is_never(cx, ex) {\n-                    return ControlFlow::Break(());\n-                }\n-                ControlFlow::Continue(Descend::Yes)\n-            },\n-            ExprKind::If(if_expr, if_then, if_else) => {\n-                let else_diverges = if_else.map_or(false, |ex| expr_diverges(cx, ex));\n-                let diverges = expr_diverges(cx, if_expr) || (else_diverges && expr_diverges(cx, if_then));\n-                if diverges {\n-                    return ControlFlow::Break(());\n-                }\n-                ControlFlow::Continue(Descend::No)\n-            },\n-            ExprKind::Match(match_expr, match_arms, _) => {\n-                let diverges = expr_diverges(cx, match_expr)\n-                    || match_arms.iter().all(|arm| {\n-                        let guard_diverges = arm.guard.as_ref().map_or(false, |g| expr_diverges(cx, g.body()));\n-                        guard_diverges || expr_diverges(cx, arm.body)\n-                    });\n-                if diverges {\n-                    return ControlFlow::Break(());\n+    impl<'tcx> Visitor<'tcx> for V<'_, '_> {\n+        fn visit_expr(&mut self, e: &'tcx Expr<'tcx>) {\n+            fn is_never(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+                if let Some(ty) = cx.typeck_results().expr_ty_opt(expr) {\n+                    return ty.is_never();\n                 }\n-                ControlFlow::Continue(Descend::No)\n-            },\n+                false\n+            }\n+\n+            if self.res.is_break() {\n+                return;\n+            }\n \n-            // Don't continue into loops or labeled blocks, as they are breakable,\n-            // and we'd have to start checking labels.\n-            ExprKind::Block(_, Some(_)) | ExprKind::Loop(..) => ControlFlow::Continue(Descend::No),\n+            // We can't just call is_never on expr and be done, because the type system\n+            // sometimes coerces the ! type to something different before we can get\n+            // our hands on it. So instead, we do a manual search. We do fall back to\n+            // is_never in some places when there is no better alternative.\n+            self.res = match e.kind {\n+                ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => ControlFlow::Break(()),\n+                ExprKind::Call(call, _) => {\n+                    if is_never(self.cx, e) || is_never(self.cx, call) {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(Descend::Yes)\n+                    }\n+                },\n+                ExprKind::MethodCall(..) => {\n+                    if is_never(self.cx, e) {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(Descend::Yes)\n+                    }\n+                },\n+                ExprKind::If(if_expr, if_then, if_else) => {\n+                    let else_diverges = if_else.map_or(false, |ex| expr_diverges(self.cx, ex));\n+                    let diverges =\n+                        expr_diverges(self.cx, if_expr) || (else_diverges && expr_diverges(self.cx, if_then));\n+                    if diverges {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(Descend::No)\n+                    }\n+                },\n+                ExprKind::Match(match_expr, match_arms, _) => {\n+                    let diverges = expr_diverges(self.cx, match_expr)\n+                        || match_arms.iter().all(|arm| {\n+                            let guard_diverges = arm.guard.as_ref().map_or(false, |g| expr_diverges(self.cx, g.body()));\n+                            guard_diverges || expr_diverges(self.cx, arm.body)\n+                        });\n+                    if diverges {\n+                        ControlFlow::Break(())\n+                    } else {\n+                        ControlFlow::Continue(Descend::No)\n+                    }\n+                },\n \n-            // Default: descend\n-            _ => ControlFlow::Continue(Descend::Yes),\n+                // Don't continue into loops or labeled blocks, as they are breakable,\n+                // and we'd have to start checking labels.\n+                ExprKind::Block(_, Some(_)) | ExprKind::Loop(..) => ControlFlow::Continue(Descend::No),\n+\n+                // Default: descend\n+                _ => ControlFlow::Continue(Descend::Yes),\n+            };\n+            if let ControlFlow::Continue(Descend::Yes) = self.res {\n+                walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_local(&mut self, local: &'tcx Local<'_>) {\n+            // Don't visit the else block of a let/else statement as it will not make\n+            // the statement divergent even though the else block is divergent.\n+            if let Some(init) = local.init {\n+                self.visit_expr(init);\n+            }\n         }\n-    })\n-    .is_some()\n+\n+        // Avoid unnecessary `walk_*` calls.\n+        fn visit_ty(&mut self, _: &'tcx Ty<'tcx>) {}\n+        fn visit_pat(&mut self, _: &'tcx Pat<'tcx>) {}\n+        fn visit_qpath(&mut self, _: &'tcx QPath<'tcx>, _: HirId, _: Span) {}\n+        // Avoid monomorphising all `visit_*` functions.\n+        fn visit_nested_item(&mut self, _: ItemId) {}\n+    }\n+\n+    let mut v = V {\n+        cx,\n+        res: ControlFlow::Continue(Descend::Yes),\n+    };\n+    expr.visit(&mut v);\n+    v.res.is_break()\n }\n \n fn pat_allowed_for_else(cx: &LateContext<'_>, pat: &'_ Pat<'_>, check_types: bool) -> bool {"}, {"sha": "d175597a44a63e0b6c8e319fc0f29efe708943fd", "filename": "tests/ui/manual_let_else.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f15a11aa174efded805617f2c5664f31389dcc1/tests%2Fui%2Fmanual_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f15a11aa174efded805617f2c5664f31389dcc1/tests%2Fui%2Fmanual_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_let_else.rs?ref=7f15a11aa174efded805617f2c5664f31389dcc1", "patch": "@@ -248,4 +248,15 @@ fn not_fire() {\n         Some(value) => value,\n         _ => macro_call!(),\n     };\n+\n+    // Issue 10296\n+    // The let/else block in the else part is not divergent despite the presence of return\n+    let _x = if let Some(x) = Some(1) {\n+        x\n+    } else {\n+        let Some(_z) = Some(3) else {\n+            return\n+        };\n+        1\n+    };\n }"}]}