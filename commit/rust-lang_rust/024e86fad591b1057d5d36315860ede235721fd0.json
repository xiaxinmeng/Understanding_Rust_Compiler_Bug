{"sha": "024e86fad591b1057d5d36315860ede235721fd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNGU4NmZhZDU5MWIxMDU3ZDVkMzYzMTU4NjBlZGUyMzU3MjFmZDA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-24T04:08:11Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-29T05:26:22Z"}, "message": "debuginfo: extract types.rs", "tree": {"sha": "a890dffa82a5d2a49a9e752849d42d33fbf39273", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a890dffa82a5d2a49a9e752849d42d33fbf39273"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/024e86fad591b1057d5d36315860ede235721fd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/024e86fad591b1057d5d36315860ede235721fd0", "html_url": "https://github.com/rust-lang/rust/commit/024e86fad591b1057d5d36315860ede235721fd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/024e86fad591b1057d5d36315860ede235721fd0/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "488694cf0d44671972c57fb48973ed379fbe3fff", "url": "https://api.github.com/repos/rust-lang/rust/commits/488694cf0d44671972c57fb48973ed379fbe3fff", "html_url": "https://github.com/rust-lang/rust/commit/488694cf0d44671972c57fb48973ed379fbe3fff"}], "stats": {"total": 446, "additions": 233, "deletions": 213}, "files": [{"sha": "fc7a0475f48a09cd4db89399a8d4990e3257ea83", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 213, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/024e86fad591b1057d5d36315860ede235721fd0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024e86fad591b1057d5d36315860ede235721fd0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=024e86fad591b1057d5d36315860ede235721fd0", "patch": "@@ -15,12 +15,14 @@ pub mod gdb;\n mod utils;\n mod create;\n mod namespace;\n+mod types;\n \n use self::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align_of,\n                   assert_type_for_node_id, get_namespace_and_span_for_item, fn_should_be_ignored,\n                   contains_nodebug_attribute, create_scope_map};\n use self::create::{declare_local, create_DIArray, is_node_local_to_unit};\n-use self::namespace::{namespace_for_item, NamespaceTreeNode, crate_root_namespace};\n+use self::namespace::{namespace_for_item, NamespaceTreeNode};\n+use self::types::{compute_debuginfo_type_name, push_debuginfo_type_name};\n \n use self::VariableAccess::*;\n use self::VariableKind::*;\n@@ -2893,215 +2895,3 @@ fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation)\n \n     debug_context(cx).current_debug_location.set(debug_location);\n }\n-\n-//=-----------------------------------------------------------------------------\n-// Type Names for Debug Info\n-//=-----------------------------------------------------------------------------\n-\n-// Compute the name of the type as it should be stored in debuginfo. Does not do\n-// any caching, i.e. calling the function twice with the same type will also do\n-// the work twice. The `qualified` parameter only affects the first level of the\n-// type name, further levels (i.e. type parameters) are always fully qualified.\n-fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                         t: Ty<'tcx>,\n-                                         qualified: bool)\n-                                         -> String {\n-    let mut result = String::with_capacity(64);\n-    push_debuginfo_type_name(cx, t, qualified, &mut result);\n-    result\n-}\n-\n-// Pushes the name of the type as it should be stored in debuginfo on the\n-// `output` String. See also compute_debuginfo_type_name().\n-fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                      t: Ty<'tcx>,\n-                                      qualified: bool,\n-                                      output: &mut String) {\n-    match t.sty {\n-        ty::ty_bool              => output.push_str(\"bool\"),\n-        ty::ty_char              => output.push_str(\"char\"),\n-        ty::ty_str               => output.push_str(\"str\"),\n-        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n-        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n-        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n-        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n-        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n-        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n-        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n-        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n-        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n-        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n-        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n-        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n-        ty::ty_struct(def_id, substs) |\n-        ty::ty_enum(def_id, substs) => {\n-            push_item_name(cx, def_id, qualified, output);\n-            push_type_params(cx, substs, output);\n-        },\n-        ty::ty_tup(ref component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_debuginfo_type_name(cx, component_type, true, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::ty_uniq(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n-            output.push('>');\n-        },\n-        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                ast::MutImmutable => output.push_str(\"const \"),\n-                ast::MutMutable => output.push_str(\"mut \"),\n-            }\n-\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n-        },\n-        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == ast::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n-\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n-        },\n-        ty::ty_vec(inner_type, optional_length) => {\n-            output.push('[');\n-            push_debuginfo_type_name(cx, inner_type, true, output);\n-\n-            match optional_length {\n-                Some(len) => {\n-                    output.push_str(&format!(\"; {}\", len));\n-                }\n-                None => { /* nothing to do */ }\n-            };\n-\n-            output.push(']');\n-        },\n-        ty::ty_trait(ref trait_data) => {\n-            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n-            push_item_name(cx, principal.def_id, false, output);\n-            push_type_params(cx, principal.substs, output);\n-        },\n-        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == ast::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n-\n-            if abi != ::syntax::abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n-\n-            output.push_str(\"fn(\");\n-\n-            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_debuginfo_type_name(cx, parameter_type, true, output);\n-                    output.push_str(\", \");\n-                }\n-                output.pop();\n-                output.pop();\n-            }\n-\n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n-                }\n-            }\n-\n-            output.push(')');\n-\n-            match sig.output {\n-                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_debuginfo_type_name(cx, result_type, true, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n-            }\n-        },\n-        ty::ty_closure(..) => {\n-            output.push_str(\"closure\");\n-        }\n-        ty::ty_err |\n-        ty::ty_infer(_) |\n-        ty::ty_projection(..) |\n-        ty::ty_param(_) => {\n-            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n-        }\n-    }\n-\n-    fn push_item_name(cx: &CrateContext,\n-                      def_id: ast::DefId,\n-                      qualified: bool,\n-                      output: &mut String) {\n-        ty::with_path(cx.tcx(), def_id, |path| {\n-            if qualified {\n-                if def_id.krate == ast::LOCAL_CRATE {\n-                    output.push_str(crate_root_namespace(cx));\n-                    output.push_str(\"::\");\n-                }\n-\n-                let mut path_element_count = 0;\n-                for path_element in path {\n-                    let name = token::get_name(path_element.name());\n-                    output.push_str(&name);\n-                    output.push_str(\"::\");\n-                    path_element_count += 1;\n-                }\n-\n-                if path_element_count == 0 {\n-                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n-                }\n-\n-                output.pop();\n-                output.pop();\n-            } else {\n-                let name = token::get_name(path.last()\n-                                               .expect(\"debuginfo: Empty item path?\")\n-                                               .name());\n-                output.push_str(&name);\n-            }\n-        });\n-    }\n-\n-    // Pushes the type parameters in the given `Substs` to the output string.\n-    // This ignores region parameters, since they can't reliably be\n-    // reconstructed for items from non-local crates. For local crates, this\n-    // would be possible but with inlining and LTO we have to use the least\n-    // common denominator - otherwise we would run into conflicts.\n-    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                  substs: &subst::Substs<'tcx>,\n-                                  output: &mut String) {\n-        if substs.types.is_empty() {\n-            return;\n-        }\n-\n-        output.push('<');\n-\n-        for &type_parameter in substs.types.iter() {\n-            push_debuginfo_type_name(cx, type_parameter, true, output);\n-            output.push_str(\", \");\n-        }\n-\n-        output.pop();\n-        output.pop();\n-\n-        output.push('>');\n-    }\n-}"}, {"sha": "586dd1526cd24e299609f8c4ccfda800c42a1f80", "filename": "src/librustc_trans/trans/debuginfo/types.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/024e86fad591b1057d5d36315860ede235721fd0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/024e86fad591b1057d5d36315860ede235721fd0/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Ftypes.rs?ref=024e86fad591b1057d5d36315860ede235721fd0", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://!rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://!www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://!opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Type Names for Debug Info\n+\n+use super::namespace::crate_root_namespace;\n+\n+use trans::common::CrateContext;\n+use middle::subst::{self, Substs};\n+use middle::ty::{self, Ty, ClosureTyper};\n+use syntax::ast;\n+use syntax::parse::token;\n+use util::ppaux;\n+\n+\n+// Compute the name of the type as it should be stored in debuginfo. Does not do\n+// any caching, i.e. calling the function twice with the same type will also do\n+// the work twice. The `qualified` parameter only affects the first level of the\n+// type name, further levels (i.e. type parameters) are always fully qualified.\n+pub fn compute_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                             t: Ty<'tcx>,\n+                                             qualified: bool)\n+                                             -> String {\n+    let mut result = String::with_capacity(64);\n+    push_debuginfo_type_name(cx, t, qualified, &mut result);\n+    result\n+}\n+\n+// Pushes the name of the type as it should be stored in debuginfo on the\n+// `output` String. See also compute_debuginfo_type_name().\n+pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                          t: Ty<'tcx>,\n+                                          qualified: bool,\n+                                          output: &mut String) {\n+    match t.sty {\n+        ty::ty_bool              => output.push_str(\"bool\"),\n+        ty::ty_char              => output.push_str(\"char\"),\n+        ty::ty_str               => output.push_str(\"str\"),\n+        ty::ty_int(ast::TyIs)     => output.push_str(\"isize\"),\n+        ty::ty_int(ast::TyI8)    => output.push_str(\"i8\"),\n+        ty::ty_int(ast::TyI16)   => output.push_str(\"i16\"),\n+        ty::ty_int(ast::TyI32)   => output.push_str(\"i32\"),\n+        ty::ty_int(ast::TyI64)   => output.push_str(\"i64\"),\n+        ty::ty_uint(ast::TyUs)    => output.push_str(\"usize\"),\n+        ty::ty_uint(ast::TyU8)   => output.push_str(\"u8\"),\n+        ty::ty_uint(ast::TyU16)  => output.push_str(\"u16\"),\n+        ty::ty_uint(ast::TyU32)  => output.push_str(\"u32\"),\n+        ty::ty_uint(ast::TyU64)  => output.push_str(\"u64\"),\n+        ty::ty_float(ast::TyF32) => output.push_str(\"f32\"),\n+        ty::ty_float(ast::TyF64) => output.push_str(\"f64\"),\n+        ty::ty_struct(def_id, substs) |\n+        ty::ty_enum(def_id, substs) => {\n+            push_item_name(cx, def_id, qualified, output);\n+            push_type_params(cx, substs, output);\n+        },\n+        ty::ty_tup(ref component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_debuginfo_type_name(cx, component_type, true, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::ty_uniq(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+            output.push('>');\n+        },\n+        ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                ast::MutImmutable => output.push_str(\"const \"),\n+                ast::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == ast::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+        },\n+        ty::ty_vec(inner_type, optional_length) => {\n+            output.push('[');\n+            push_debuginfo_type_name(cx, inner_type, true, output);\n+\n+            match optional_length {\n+                Some(len) => {\n+                    output.push_str(&format!(\"; {}\", len));\n+                }\n+                None => { /* nothing to do */ }\n+            };\n+\n+            output.push(']');\n+        },\n+        ty::ty_trait(ref trait_data) => {\n+            let principal = ty::erase_late_bound_regions(cx.tcx(), &trait_data.principal);\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n+        },\n+        ty::ty_bare_fn(_, &ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == ast::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::syntax::abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_debuginfo_type_name(cx, parameter_type, true, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_debuginfo_type_name(cx, result_type, true, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::ty_closure(..) => {\n+            output.push_str(\"closure\");\n+        }\n+        ty::ty_err |\n+        ty::ty_infer(_) |\n+        ty::ty_projection(..) |\n+        ty::ty_param(_) => {\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n+        }\n+    }\n+\n+    fn push_item_name(cx: &CrateContext,\n+                      def_id: ast::DefId,\n+                      qualified: bool,\n+                      output: &mut String) {\n+        ty::with_path(cx.tcx(), def_id, |path| {\n+            if qualified {\n+                if def_id.krate == ast::LOCAL_CRATE {\n+                    output.push_str(crate_root_namespace(cx));\n+                    output.push_str(\"::\");\n+                }\n+\n+                let mut path_element_count = 0;\n+                for path_element in path {\n+                    let name = token::get_name(path_element.name());\n+                    output.push_str(&name);\n+                    output.push_str(\"::\");\n+                    path_element_count += 1;\n+                }\n+\n+                if path_element_count == 0 {\n+                    cx.sess().bug(\"debuginfo: Encountered empty item path!\");\n+                }\n+\n+                output.pop();\n+                output.pop();\n+            } else {\n+                let name = token::get_name(path.last()\n+                                               .expect(\"debuginfo: Empty item path?\")\n+                                               .name());\n+                output.push_str(&name);\n+            }\n+        });\n+    }\n+\n+    // Pushes the type parameters in the given `Substs` to the output string.\n+    // This ignores region parameters, since they can't reliably be\n+    // reconstructed for items from non-local crates. For local crates, this\n+    // would be possible but with inlining and LTO we have to use the least\n+    // common denominator - otherwise we would run into conflicts.\n+    fn push_type_params<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                  substs: &subst::Substs<'tcx>,\n+                                  output: &mut String) {\n+        if substs.types.is_empty() {\n+            return;\n+        }\n+\n+        output.push('<');\n+\n+        for &type_parameter in substs.types.iter() {\n+            push_debuginfo_type_name(cx, type_parameter, true, output);\n+            output.push_str(\", \");\n+        }\n+\n+        output.pop();\n+        output.pop();\n+\n+        output.push('>');\n+    }\n+}\n+"}]}