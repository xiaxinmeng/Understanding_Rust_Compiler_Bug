{"sha": "d2b7604db9d3262fd9fe9ab39efb60652e252448", "node_id": "C_kwDOAAsO6NoAKGQyYjc2MDRkYjlkMzI2MmZkOWZlOWFiMzllZmI2MDY1MmUyNTI0NDg", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-15T13:00:15Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-15T13:00:15Z"}, "message": "always make `define_opaque_types` explicit", "tree": {"sha": "213bde0c96083390884a72ea02b7d40af3eaf0aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/213bde0c96083390884a72ea02b7d40af3eaf0aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2b7604db9d3262fd9fe9ab39efb60652e252448", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2b7604db9d3262fd9fe9ab39efb60652e252448", "html_url": "https://github.com/rust-lang/rust/commit/d2b7604db9d3262fd9fe9ab39efb60652e252448", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2b7604db9d3262fd9fe9ab39efb60652e252448/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e84e5ff04a647ce28540300244a26ba120642eea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e84e5ff04a647ce28540300244a26ba120642eea", "html_url": "https://github.com/rust-lang/rust/commit/e84e5ff04a647ce28540300244a26ba120642eea"}], "stats": {"total": 531, "additions": 307, "deletions": 224}, "files": [{"sha": "0e1cf3e6c6a7d7cc02eba28a2c1593da74c3227f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::infer::{self, RegionResolutionError};\n+use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -235,7 +235,8 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n     use rustc_type_ir::sty::TyKind::*;\n     match (source.kind(), target.kind()) {\n         (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n-            if infcx.at(&cause, param_env).eq(r_a, *r_b).is_ok() && mutbl_a == *mutbl_b => {}\n+            if infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, r_a, *r_b).is_ok()\n+                && mutbl_a == *mutbl_b => {}\n         (&RawPtr(tm_a), &RawPtr(tm_b)) if tm_a.mutbl == tm_b.mutbl => (),\n         (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n             if def_a.is_struct() && def_b.is_struct() =>\n@@ -278,7 +279,9 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                         }\n                     }\n \n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                    if let Ok(ok) =\n+                        infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, ty_a, ty_b)\n+                    {\n                         if ok.obligations.is_empty() {\n                             create_err(\n                                 \"the trait `DispatchFromDyn` may only be implemented \\\n@@ -504,7 +507,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     // we may have to evaluate constraint\n                     // expressions in the course of execution.)\n                     // See e.g., #41936.\n-                    if let Ok(ok) = infcx.at(&cause, param_env).eq(a, b) {\n+                    if let Ok(ok) = infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, a, b) {\n                         if ok.obligations.is_empty() {\n                             return None;\n                         }"}, {"sha": "08786fe9b1ef90d6bdbf421208398f5ba48dbc2a", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -102,7 +102,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n@@ -165,7 +165,7 @@ fn require_same_types<'tcx>(\n ) -> bool {\n     let infcx = &tcx.infer_ctxt().build();\n     let param_env = ty::ParamEnv::empty();\n-    let errors = match infcx.at(cause, param_env).eq(expected, actual) {\n+    let errors = match infcx.at(cause, param_env).eq(DefineOpaqueTypes::No, expected, actual) {\n         Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n         Err(err) => {\n             infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();"}, {"sha": "6becf4892acb20562d3911987f7f87be4ec21782", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::{DefineOpaqueTypes, LateBoundRegionConversionTime};\n use rustc_infer::infer::{InferOk, InferResult};\n use rustc_macros::{TypeFoldable, TypeVisitable};\n use rustc_middle::ty::subst::InternalSubsts;\n@@ -563,10 +563,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ) {\n                 // Check that E' = S'.\n                 let cause = self.misc(hir_ty.span);\n-                let InferOk { value: (), obligations } = self\n-                    .at(&cause, self.param_env)\n-                    .define_opaque_types(true)\n-                    .eq(*expected_ty, supplied_ty)?;\n+                let InferOk { value: (), obligations } = self.at(&cause, self.param_env).eq(\n+                    DefineOpaqueTypes::Yes,\n+                    *expected_ty,\n+                    supplied_ty,\n+                )?;\n                 all_obligations.extend(obligations);\n             }\n \n@@ -576,10 +577,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 supplied_sig.output(),\n             );\n             let cause = &self.misc(decl.output.span());\n-            let InferOk { value: (), obligations } = self\n-                .at(cause, self.param_env)\n-                .define_opaque_types(true)\n-                .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n+            let InferOk { value: (), obligations } = self.at(cause, self.param_env).eq(\n+                DefineOpaqueTypes::Yes,\n+                expected_sigs.liberated_sig.output(),\n+                supplied_output_ty,\n+            )?;\n             all_obligations.extend(obligations);\n \n             let inputs = inputs.into_iter().map(|ty| self.resolve_vars_if_possible(ty));"}, {"sha": "3d6274ede81466fe3fd6a71e65e465290f809d61", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -45,7 +45,7 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::infer::{Coercion, DefineOpaqueTypes, InferOk, InferResult};\n use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n@@ -143,11 +143,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         debug!(\"unify(a: {:?}, b: {:?}, use_lub: {})\", a, b, self.use_lub);\n         self.commit_if_ok(|_| {\n-            let at = self.at(&self.cause, self.fcx.param_env).define_opaque_types(true);\n+            let at = self.at(&self.cause, self.fcx.param_env);\n             if self.use_lub {\n-                at.lub(b, a)\n+                at.lub(DefineOpaqueTypes::Yes, b, a)\n             } else {\n-                at.sup(b, a)\n+                at.sup(DefineOpaqueTypes::Yes, b, a)\n                     .map(|InferOk { value: (), obligations }| InferOk { value: a, obligations })\n             }\n         })\n@@ -175,7 +175,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // so this will have the side-effect of making sure we have no ambiguities\n             // due to `[type error]` and `_` not coercing together.\n             let _ = self.commit_if_ok(|_| {\n-                self.at(&self.cause, self.param_env).define_opaque_types(true).eq(a, b)\n+                self.at(&self.cause, self.param_env).eq(DefineOpaqueTypes::Yes, a, b)\n             });\n             return success(vec![], self.fcx.tcx.ty_error(guar), vec![]);\n         }\n@@ -1101,9 +1101,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     (ty::FnDef(..), ty::FnDef(..)) => {\n                         // Don't reify if the function types have a LUB, i.e., they\n                         // are the same function and their parameters have a LUB.\n-                        match self\n-                            .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        {\n+                        match self.commit_if_ok(|_| {\n+                            self.at(cause, self.param_env).lub(\n+                                DefineOpaqueTypes::No,\n+                                prev_ty,\n+                                new_ty,\n+                            )\n+                        }) {\n                             // We have a LUB of prev_ty and new_ty, just return it.\n                             Ok(ok) => return Ok(self.register_infer_ok_obligations(ok)),\n                             Err(_) => {\n@@ -1153,7 +1157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let sig = self\n                 .at(cause, self.param_env)\n                 .trace(prev_ty, new_ty)\n-                .lub(a_sig, b_sig)\n+                .lub(DefineOpaqueTypes::No, a_sig, b_sig)\n                 .map(|ok| self.register_infer_ok_obligations(ok))?;\n \n             // Reify both sides and return the reified fn pointer type.\n@@ -1237,7 +1241,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n \n                 return self\n-                    .commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n+                    .commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n                     .map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n@@ -1248,8 +1254,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let Some(e) = first_error {\n                     Err(e)\n                 } else {\n-                    self.commit_if_ok(|_| self.at(cause, self.param_env).lub(prev_ty, new_ty))\n-                        .map(|ok| self.register_infer_ok_obligations(ok))\n+                    self.commit_if_ok(|_| {\n+                        self.at(cause, self.param_env).lub(DefineOpaqueTypes::No, prev_ty, new_ty)\n+                    })\n+                    .map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {\n@@ -1487,8 +1495,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             assert!(expression_ty.is_unit(), \"if let hack without unit type\");\n             fcx.at(cause, fcx.param_env)\n                 // needed for tests/ui/type-alias-impl-trait/issue-65679-inst-opaque-ty-from-val-twice.rs\n-                .define_opaque_types(true)\n-                .eq_exp(label_expression_as_expected, expression_ty, self.merged_ty())\n+                .eq_exp(\n+                    DefineOpaqueTypes::Yes,\n+                    label_expression_as_expected,\n+                    expression_ty,\n+                    self.merged_ty(),\n+                )\n                 .map(|infer_ok| {\n                     fcx.register_infer_ok_obligations(infer_ok);\n                     expression_ty"}, {"sha": "f65f16e317d4977d2f56847eedbf5f243a5f3411", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n-use rustc_infer::infer::InferOk;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n@@ -113,7 +113,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).sup(expected, actual) {\n+        match self.at(cause, self.param_env).sup(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None\n@@ -143,7 +143,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         actual: Ty<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        match self.at(cause, self.param_env).define_opaque_types(true).eq(expected, actual) {\n+        match self.at(cause, self.param_env).eq(DefineOpaqueTypes::Yes, expected, actual) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None"}, {"sha": "afef331ec1d93ae61ba373f5fe3918028c22c077", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -36,6 +36,7 @@ use rustc_hir_analysis::astconv::AstConv as _;\n use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::InferOk;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::middle::stability;\n@@ -1683,7 +1684,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             if let Some(_) = remaining_fields.remove(&ident) {\n                                 let target_ty = self.field_ty(base_expr.span, f, substs);\n                                 let cause = self.misc(base_expr.span);\n-                                match self.at(&cause, self.param_env).sup(target_ty, fru_ty) {\n+                                match self.at(&cause, self.param_env).sup(\n+                                    DefineOpaqueTypes::No,\n+                                    target_ty,\n+                                    fru_ty,\n+                                ) {\n                                     Ok(InferOk { obligations, value: () }) => {\n                                         self.register_predicates(obligations)\n                                     }"}, {"sha": "e539693402af9419e5db1b19e5177988a210826e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -19,7 +19,7 @@ use rustc_hir_analysis::astconv::{\n };\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::InferResult;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferResult};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -558,7 +558,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let span = self.tcx.hir().body(body_id).value.span;\n             let ok = self\n                 .at(&self.misc(span), self.param_env)\n-                .eq(interior, witness)\n+                .eq(DefineOpaqueTypes::No, interior, witness)\n                 .expect(\"Failed to unify generator interior type\");\n             let mut obligations = ok.obligations;\n \n@@ -1341,7 +1341,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // This also occurs for an enum variant on a type alias.\n             let impl_ty = self.normalize(span, tcx.type_of(impl_def_id).subst(tcx, substs));\n             let self_ty = self.normalize(span, self_ty);\n-            match self.at(&self.misc(span), self.param_env).eq(impl_ty, self_ty) {\n+            match self.at(&self.misc(span), self.param_env).eq(\n+                DefineOpaqueTypes::No,\n+                impl_ty,\n+                self_ty,\n+            ) {\n                 Ok(ok) => self.register_infer_ok_obligations(ok),\n                 Err(_) => {\n                     self.tcx.sess.delay_span_bug("}, {"sha": "7064ff6538487585b6628981bade14d47d786aa1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -24,8 +24,8 @@ use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, IsSuggestable, Ty};\n@@ -301,9 +301,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // 3. Check if the formal type is a supertype of the checked one\n             //    and register any such obligations for future type checks\n-            let supertype_error = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n+            let supertype_error = self.at(&self.misc(provided_arg.span), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                formal_input_ty,\n+                coerced_ty,\n+            );\n             let subtyping_error = match supertype_error {\n                 Ok(InferOk { obligations, value: () }) => {\n                     self.register_predicates(obligations);\n@@ -585,7 +587,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             // Using probe here, since we don't want this subtyping to affect inference.\n             let subtyping_error = self.probe(|_| {\n-                self.at(&self.misc(arg_span), self.param_env).sup(formal_input_ty, coerced_ty).err()\n+                self.at(&self.misc(arg_span), self.param_env)\n+                    .sup(DefineOpaqueTypes::No, formal_input_ty, coerced_ty)\n+                    .err()\n             });\n \n             // Same as above: if either the coerce type or the checked type is an error type,"}, {"sha": "9ecc870a70dbd949033a05b2900df13bc4a3500c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdSet;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind};\n-use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_infer::infer::{DefineOpaqueTypes, RegionVariableOrigin};\n use rustc_middle::middle::region::{self, Scope, ScopeData, YieldData};\n use rustc_middle::ty::fold::FnMutDelegate;\n use rustc_middle::ty::{self, BoundVariableKind, RvalueScopes, Ty, TyCtxt, TypeVisitableExt};\n@@ -327,7 +327,11 @@ pub fn resolve_interior<'a, 'tcx>(\n     );\n \n     // Unify the type variable inside the generator with the new witness\n-    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(interior, witness) {\n+    match fcx.at(&fcx.misc(body.value.span), fcx.param_env).eq(\n+        DefineOpaqueTypes::No,\n+        interior,\n+        witness,\n+    ) {\n         Ok(ok) => fcx.register_infer_ok_obligations(ok),\n         _ => bug!(\"failed to relate {interior} and {witness}\"),\n     }"}, {"sha": "a0aa43deadcfd2a2cd0ac3a3f468f41f9790ad4c", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -8,7 +8,7 @@ use rustc_hir_analysis::astconv::generics::{\n     check_generic_arg_count_for_call, create_substs_for_generic_args,\n };\n use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n-use rustc_infer::infer::{self, InferOk};\n+use rustc_infer::infer::{self, DefineOpaqueTypes, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 substs,\n             })),\n         );\n-        match self.at(&cause, self.param_env).sup(method_self_ty, self_ty) {\n+        match self.at(&cause, self.param_env).sup(DefineOpaqueTypes::No, method_self_ty, self_ty) {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }"}, {"sha": "8f31a79e7b39310141b7b0b11b3da41d775d056e", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -13,6 +13,7 @@ use rustc_hir_analysis::astconv::InferCtxtExt as _;\n use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::TreatProjections;\n@@ -930,7 +931,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let Some(self_ty) = self_ty {\n                     if self\n                         .at(&ObligationCause::dummy(), self.param_env)\n-                        .sup(fty.inputs()[0], self_ty)\n+                        .sup(DefineOpaqueTypes::No, fty.inputs()[0], self_ty)\n                         .is_err()\n                     {\n                         return false;\n@@ -1436,9 +1437,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 CandidateSource::Trait(candidate.item.container_id(self.tcx))\n             }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n-                let _ = self\n-                    .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(candidate.xform_self_ty, self_ty);\n+                let _ = self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                    DefineOpaqueTypes::No,\n+                    candidate.xform_self_ty,\n+                    self_ty,\n+                );\n                 match self.select_trait_candidate(trait_ref) {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n@@ -1465,10 +1468,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n         self.probe(|_| {\n             // First check that the self type can be related.\n-            let sub_obligations = match self\n-                .at(&ObligationCause::dummy(), self.param_env)\n-                .sup(probe.xform_self_ty, self_ty)\n-            {\n+            let sub_obligations = match self.at(&ObligationCause::dummy(), self.param_env).sup(\n+                DefineOpaqueTypes::No,\n+                probe.xform_self_ty,\n+                self_ty,\n+            ) {\n                 Ok(InferOk { obligations, value: () }) => obligations,\n                 Err(err) => {\n                     debug!(\"--> cannot relate self-types {:?}\", err);\n@@ -1683,7 +1687,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 if let ProbeResult::Match = result\n                     && self\n                     .at(&ObligationCause::dummy(), self.param_env)\n-                    .sup(return_ty, xform_ret_ty)\n+                    .sup(DefineOpaqueTypes::No, return_ty, xform_ret_ty)\n                     .is_err()\n                 {\n                     result = ProbeResult::BadReturnType;"}, {"sha": "678832fc8d6f4c2a22dfc8ebacd74dbc083bbf72", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 80, "deletions": 51, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -30,16 +30,20 @@ use super::*;\n use rustc_middle::ty::relate::{Relate, TypeRelation};\n use rustc_middle::ty::{Const, ImplSubject};\n \n+/// Whether we should define opaque types or just treat them opaquely.\n+///\n+/// Currently only used to prevent predicate matching from matching anything\n+/// against opaque types.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n+pub enum DefineOpaqueTypes {\n+    Yes,\n+    No,\n+}\n+\n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub cause: &'a ObligationCause<'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n }\n \n pub struct Trace<'a, 'tcx> {\n@@ -55,7 +59,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> At<'a, 'tcx> {\n-        At { infcx: self, cause, param_env, define_opaque_types: false }\n+        At { infcx: self, cause, param_env }\n     }\n \n     /// Forks the inference context, creating a new inference context with the same inference\n@@ -93,33 +97,21 @@ pub trait ToTrace<'tcx>: Relate<'tcx> + Copy {\n }\n \n impl<'a, 'tcx> At<'a, 'tcx> {\n-    pub fn define_opaque_types(self, define_opaque_types: bool) -> Self {\n-        Self { define_opaque_types, ..self }\n-    }\n-\n-    /// Hacky routine for equating two impl headers in coherence.\n-    pub fn eq_impl_headers(\n-        self,\n-        expected: &ty::ImplHeader<'tcx>,\n-        actual: &ty::ImplHeader<'tcx>,\n-    ) -> InferResult<'tcx, ()> {\n-        debug!(\"eq_impl_header({:?} = {:?})\", expected, actual);\n-        match (expected.trait_ref, actual.trait_ref) {\n-            (Some(a_ref), Some(b_ref)) => self.eq(a_ref, b_ref),\n-            (None, None) => self.eq(expected.self_ty, actual.self_ty),\n-            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n-        }\n-    }\n-\n     /// Makes `a <: b`, where `a` may or may not be expected.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).sub(a, b)\n+        self.trace_exp(a_is_expected, a, b).sub(define_opaque_types, a, b)\n     }\n \n     /// Makes `actual <: expected`. For example, if type-checking a\n@@ -129,54 +121,81 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sup<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sup<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(false, actual, expected)\n+        self.sub_exp(define_opaque_types, false, actual, expected)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::sub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn sub<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.sub_exp(true, expected, actual)\n+        self.sub_exp(define_opaque_types, true, expected, actual)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace_exp`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq_exp<T>(self, a_is_expected: bool, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq_exp<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        a_is_expected: bool,\n+        a: T,\n+        b: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace_exp(a_is_expected, a, b).eq(a, b)\n+        self.trace_exp(a_is_expected, a, b).eq(define_opaque_types, a, b)\n     }\n \n     /// Makes `expected <: actual`.\n     ///\n     /// See [`At::trace`] and [`Trace::eq`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn eq<T>(self, expected: T, actual: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).eq(expected, actual)\n+        self.trace(expected, actual).eq(define_opaque_types, expected, actual)\n     }\n \n-    pub fn relate<T>(self, expected: T, variance: ty::Variance, actual: T) -> InferResult<'tcx, ()>\n+    pub fn relate<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        variance: ty::Variance,\n+        actual: T,\n+    ) -> InferResult<'tcx, ()>\n     where\n         T: ToTrace<'tcx>,\n     {\n         match variance {\n-            ty::Variance::Covariant => self.sub(expected, actual),\n-            ty::Variance::Invariant => self.eq(expected, actual),\n-            ty::Variance::Contravariant => self.sup(expected, actual),\n+            ty::Variance::Covariant => self.sub(define_opaque_types, expected, actual),\n+            ty::Variance::Invariant => self.eq(define_opaque_types, expected, actual),\n+            ty::Variance::Contravariant => self.sup(define_opaque_types, expected, actual),\n \n             // We could make this make sense but it's not readily\n             // exposed and I don't feel like dealing with it. Note\n@@ -195,11 +214,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::lub`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn lub<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).lub(expected, actual)\n+        self.trace(expected, actual).lub(define_opaque_types, expected, actual)\n     }\n \n     /// Computes the greatest-lower-bound, or mutual subtype, of two\n@@ -208,11 +232,16 @@ impl<'a, 'tcx> At<'a, 'tcx> {\n     ///\n     /// See [`At::trace`] and [`Trace::glb`] for a version of\n     /// this method that only requires `T: Relate<'tcx>`\n-    pub fn glb<T>(self, expected: T, actual: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(\n+        self,\n+        define_opaque_types: DefineOpaqueTypes,\n+        expected: T,\n+        actual: T,\n+    ) -> InferResult<'tcx, T>\n     where\n         T: ToTrace<'tcx>,\n     {\n-        self.trace(expected, actual).glb(expected, actual)\n+        self.trace(expected, actual).glb(define_opaque_types, expected, actual)\n     }\n \n     /// Sets the \"trace\" values that will be used for\n@@ -242,13 +271,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a <: b` where `a` may or may not be expected (if\n     /// `a_is_expected` is true, then `a` is expected).\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn sub<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn sub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .sub(a_is_expected)\n                 .relate(a, b)\n@@ -259,13 +288,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     /// Makes `a == b`; the expectation is set by the call to\n     /// `trace()`.\n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn eq<T>(self, a: T, b: T) -> InferResult<'tcx, ()>\n+    pub fn eq<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, ()>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .equate(a_is_expected)\n                 .relate(a, b)\n@@ -274,13 +303,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn lub<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn lub<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .lub(a_is_expected)\n                 .relate(a, b)\n@@ -289,13 +318,13 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn glb<T>(self, a: T, b: T) -> InferResult<'tcx, T>\n+    pub fn glb<T>(self, define_opaque_types: DefineOpaqueTypes, a: T, b: T) -> InferResult<'tcx, T>\n     where\n         T: Relate<'tcx>,\n     {\n         let Trace { at, trace, a_is_expected } = self;\n         at.infcx.commit_if_ok(|_| {\n-            let mut fields = at.infcx.combine_fields(trace, at.param_env, at.define_opaque_types);\n+            let mut fields = at.infcx.combine_fields(trace, at.param_env, define_opaque_types);\n             fields\n                 .glb(a_is_expected)\n                 .relate(a, b)"}, {"sha": "7c649b3a65649c2192a01a844543155593cb1b11", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n+use crate::infer::{DefineOpaqueTypes, InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::traits::{PredicateObligations, TraitEngine, TraitEngineExt};\n@@ -510,7 +510,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             let b = substitute_value(self.tcx, &result_subst, b);\n             debug!(?a, ?b, \"constrain opaque type\");\n             obligations\n-                .extend(self.at(cause, param_env).define_opaque_types(true).eq(a, b)?.obligations);\n+                .extend(self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, a, b)?.obligations);\n         }\n \n         Ok(InferOk { value: result_subst, obligations })\n@@ -603,20 +603,26 @@ impl<'tcx> InferCtxt<'tcx> {\n \n                 match (value1.unpack(), value2.unpack()) {\n                     (GenericArgKind::Type(v1), GenericArgKind::Type(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Lifetime(re1), GenericArgKind::Lifetime(re2))\n                         if re1.is_erased() && re2.is_erased() =>\n                     {\n                         // no action needed\n                     }\n                     (GenericArgKind::Lifetime(v1), GenericArgKind::Lifetime(v2)) => {\n-                        obligations\n-                            .extend(self.at(cause, param_env).eq(v1, v2)?.into_obligations());\n+                        obligations.extend(\n+                            self.at(cause, param_env)\n+                                .eq(DefineOpaqueTypes::Yes, v1, v2)?\n+                                .into_obligations(),\n+                        );\n                     }\n                     (GenericArgKind::Const(v1), GenericArgKind::Const(v2)) => {\n-                        let ok = self.at(cause, param_env).eq(v1, v2)?;\n+                        let ok = self.at(cause, param_env).eq(DefineOpaqueTypes::Yes, v1, v2)?;\n                         obligations.extend(ok.into_obligations());\n                     }\n                     _ => {"}, {"sha": "bb6fdd2ffc2c9a092d06a664ca7fa36a88a7d53f", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -27,7 +27,7 @@ use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n-use super::{InferCtxt, MiscVariable, TypeTrace};\n+use super::{DefineOpaqueTypes, InferCtxt, MiscVariable, TypeTrace};\n use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::sso::SsoHashMap;\n use rustc_hir::def_id::DefId;\n@@ -52,12 +52,7 @@ pub struct CombineFields<'infcx, 'tcx> {\n     pub cause: Option<ty::relate::Cause>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub obligations: PredicateObligations<'tcx>,\n-    /// Whether we should define opaque types\n-    /// or just treat them opaquely.\n-    /// Currently only used to prevent predicate\n-    /// matching from matching anything against opaque\n-    /// types.\n-    pub define_opaque_types: bool,\n+    pub define_opaque_types: DefineOpaqueTypes,\n }\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "c92a74b6241a6758f0c8e2ee0a50709d6b339029", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::DefineOpaqueTypes;\n use crate::traits::PredicateObligations;\n \n use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n@@ -110,7 +111,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "5c12351226aa592684d1344708fa092cdf530022", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "7f4c141b97af2fcac6b88f29fd39bdd5186e1b97", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -19,7 +19,7 @@\n \n use super::combine::ObligationEmittingRelation;\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferCtxt;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::ObligationCause;\n use rustc_middle::ty::relate::RelateResult;\n@@ -36,7 +36,7 @@ pub trait LatticeDir<'f, 'tcx>: ObligationEmittingRelation<'tcx> {\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n-    fn define_opaque_types(&self) -> bool;\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n@@ -110,7 +110,7 @@ where\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "dbef42db8f1bfe4af6d9870392c2f6b8a1d69c81", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -2,8 +2,8 @@\n \n use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n-use super::InferCtxt;\n use super::Subtype;\n+use super::{DefineOpaqueTypes, InferCtxt};\n \n use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -142,7 +142,7 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         Ok(())\n     }\n \n-    fn define_opaque_types(&self) -> bool {\n+    fn define_opaque_types(&self) -> DefineOpaqueTypes {\n         self.fields.define_opaque_types\n     }\n }"}, {"sha": "2976c145150dfb83a692711df9ce508d71a5f996", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,3 +1,4 @@\n+pub use self::at::DefineOpaqueTypes;\n pub use self::freshen::TypeFreshener;\n pub use self::lexical_region_resolve::RegionResolutionError;\n pub use self::LateBoundRegionConversionTime::*;\n@@ -729,7 +730,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         &'a self,\n         trace: TypeTrace<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        define_opaque_types: bool,\n+        define_opaque_types: DefineOpaqueTypes,\n     ) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             infcx: self,\n@@ -860,15 +861,15 @@ impl<'tcx> InferCtxt<'tcx> {\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).sub(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).sub(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n-        self.probe(|_| self.at(origin, param_env).eq(a, b).is_ok())\n+        self.probe(|_| self.at(origin, param_env).eq(DefineOpaqueTypes::No, a, b).is_ok())\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -963,7 +964,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             let ty::SubtypePredicate { a_is_expected, a, b } =\n                 self.instantiate_binder_with_placeholders(predicate);\n \n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n+            let ok =\n+                self.at(cause, param_env).sub_exp(DefineOpaqueTypes::No, a_is_expected, a, b)?;\n \n             Ok(ok.unit())\n         }))"}, {"sha": "ed4bc594d1a54d57348d0e7f70a5d509301efdf7", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,3 +1,5 @@\n+use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n@@ -16,18 +18,13 @@ use rustc_middle::ty::{\n     TypeVisitable, TypeVisitableExt, TypeVisitor,\n };\n use rustc_span::Span;\n-\n use std::ops::ControlFlow;\n \n-pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n-\n mod table;\n \n+pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n pub use table::{OpaqueTypeStorage, OpaqueTypeTable};\n \n-use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use super::InferResult;\n-\n /// Information about the opaque types whose values we\n /// are inferring in this function (these are the `impl Trait` that\n /// appear in the return type).\n@@ -547,8 +544,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         if let Some(prev) = prev {\n             obligations = self\n                 .at(&cause, param_env)\n-                .define_opaque_types(true)\n-                .eq_exp(a_is_expected, prev, hidden_ty)?\n+                .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, prev, hidden_ty)?\n                 .obligations;\n         }\n "}, {"sha": "230cadb11842e506a0ca4ff735d3db754c9a1604", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,5 +1,5 @@\n use super::combine::{CombineFields, RelationDir};\n-use super::{ObligationEmittingRelation, SubregionOrigin};\n+use super::{DefineOpaqueTypes, ObligationEmittingRelation, SubregionOrigin};\n \n use crate::traits::{Obligation, PredicateObligations};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n@@ -138,7 +138,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if self.fields.define_opaque_types && def_id.is_local() =>\n+                if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n+                    && def_id.is_local() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "856f1eec4433bb1c49435e7b169aca28fbab8df3", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n@@ -144,7 +144,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n         self.infcx\n             .at(&ObligationCause::dummy(), param_env)\n-            .eq(lhs, rhs)\n+            .eq(DefineOpaqueTypes::No, lhs, rhs)\n             .map(|InferOk { value: (), obligations }| {\n                 obligations.into_iter().map(|o| o.into()).collect()\n             })"}, {"sha": "a873060687d359a1a808a0752ad02b931022976e", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -19,7 +19,7 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let InferOk { value: (), obligations } = self\n                 .infcx\n                 .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(goal.predicate.a, goal.predicate.b)?;\n+                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_all_and_make_canonical_response(\n                 obligations.into_iter().map(|pred| pred.into()).collect(),\n             )"}, {"sha": "1870d3a2daf3235c2c31bdce5d231b1c2bc7b9ab", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -7,6 +7,7 @@ use crate::errors::UnableToConstructConstantValue;\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n use crate::traits::project::ProjectAndUnifyResult;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::TypeVisitableExt;\n@@ -814,7 +815,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                            match selcx.infcx.at(&obligation.cause, obligation.param_env).eq(DefineOpaqueTypes::No,c1, c2)\n                             {\n                                 Ok(_) => (),\n                                 Err(_) => return false,"}, {"sha": "bb207b5832ea9e729dc7299805d57697550b365a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -17,7 +17,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -181,7 +181,7 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let obligations = equate_impl_headers(selcx, &impl1_header, &impl2_header)?;\n+    let obligations = equate_impl_headers(selcx.infcx, &impl1_header, &impl2_header)?;\n     debug!(\"overlap: unification check succeeded\");\n \n     if overlap_mode.use_implicit_negative() {\n@@ -207,20 +207,25 @@ fn overlap_within_probe<'cx, 'tcx>(\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })\n }\n \n-fn equate_impl_headers<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_header: &ty::ImplHeader<'tcx>,\n-    impl2_header: &ty::ImplHeader<'tcx>,\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn equate_impl_headers<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+    impl1: &ty::ImplHeader<'tcx>,\n+    impl2: &ty::ImplHeader<'tcx>,\n ) -> Option<PredicateObligations<'tcx>> {\n-    // Do `a` and `b` unify? If not, no overlap.\n-    debug!(\"equate_impl_headers(impl1_header={:?}, impl2_header={:?}\", impl1_header, impl2_header);\n-    selcx\n-        .infcx\n-        .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-        .define_opaque_types(true)\n-        .eq_impl_headers(impl1_header, impl2_header)\n-        .map(|infer_ok| infer_ok.obligations)\n-        .ok()\n+    let result = match (impl1.trait_ref, impl2.trait_ref) {\n+        (Some(impl1_ref), Some(impl2_ref)) => infcx\n+            .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+            .eq(DefineOpaqueTypes::Yes, impl1_ref, impl2_ref),\n+        (None, None) => infcx.at(&ObligationCause::dummy(), ty::ParamEnv::empty()).eq(\n+            DefineOpaqueTypes::Yes,\n+            impl1.self_ty,\n+            impl2.self_ty,\n+        ),\n+        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+    };\n+\n+    result.map(|infer_ok| infer_ok.obligations).ok()\n }\n \n /// Given impl1 and impl2 check if both impls can be satisfied by a common type (including\n@@ -325,7 +330,7 @@ fn equate<'tcx>(\n ) -> bool {\n     // do the impls unify? If not, not disjoint.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), impl_env).eq(subject1, subject2)\n+        infcx.at(&ObligationCause::dummy(), impl_env).eq(DefineOpaqueTypes::No,subject1, subject2)\n     else {\n         debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n         return true;"}, {"sha": "8acc31cd410bdfa4d0372927671503989773144b", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -11,7 +11,7 @@ use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, QueryResponse,\n };\n-use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n@@ -128,8 +128,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq_exp(a_is_expected, a, b)\n+            .eq_exp(DefineOpaqueTypes::Yes, a_is_expected, a, b)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -142,8 +141,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .eq(expected, actual)\n+            .eq(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -157,8 +155,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sub(expected, actual)\n+            .sub(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n \n@@ -172,8 +169,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n     ) -> Result<(), TypeError<'tcx>> {\n         self.infcx\n             .at(cause, param_env)\n-            .define_opaque_types(true)\n-            .sup(expected, actual)\n+            .sup(DefineOpaqueTypes::Yes, expected, actual)\n             .map(|infer_ok| self.register_infer_ok_obligations(infer_ok))\n     }\n "}, {"sha": "1aaadae12ddd9641f353de2bbcb2147ace6997ac", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -2,6 +2,7 @@ use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ProjectionCacheKey;\n use rustc_infer::traits::{SelectionError, TraitEngine, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n@@ -515,7 +516,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 if let Ok(new_obligations) = infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -524,8 +525,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                             }\n                             (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n                             (_, _) => {\n-                                if let Ok(new_obligations) =\n-                                    infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                                if let Ok(new_obligations) = infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     return ProcessResult::Changed(mk_pending(\n                                         new_obligations.into_obligations(),\n@@ -565,12 +567,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self\n-                                .selcx\n-                                .infcx\n-                                .at(&obligation.cause, obligation.param_env)\n-                                .eq(c1, c2)\n-                            {\n+                            match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => {\n                                     ProcessResult::Changed(mk_pending(inf_ok.into_obligations()))\n                                 }\n@@ -610,12 +611,11 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                     bug!(\"AliasEq is only used for new solver\")\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self\n-                        .selcx\n-                        .infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .eq(ct.ty(), ty)\n-                    {\n+                    match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => ProcessResult::Changed(mk_pending(inf_ok.into_obligations())),\n                         Err(_) => ProcessResult::Error(FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented,"}, {"sha": "abc5a5eef73d95260ec27ad8c38a384d5919dccf", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -28,6 +28,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::traits::ImplSourceBuiltinData;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -285,12 +286,12 @@ fn project_and_unify_type<'cx, 'tcx>(\n         );\n     obligations.extend(new);\n \n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        // This is needed to support nested opaque types like `impl Fn() -> impl Trait`\n-        .define_opaque_types(true)\n-        .eq(normalized, actual)\n-    {\n+    // Need to define opaque types to support nested opaque types like `impl Fn() -> impl Trait`\n+    match infcx.at(&obligation.cause, obligation.param_env).eq(\n+        DefineOpaqueTypes::Yes,\n+        normalized,\n+        actual,\n+    ) {\n         Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n             obligations.extend(inferred_obligations);\n             ProjectAndUnifyResult::Holds(obligations)\n@@ -2064,7 +2065,11 @@ fn confirm_param_env_candidate<'cx, 'tcx>(\n \n     debug!(?cache_projection, ?obligation_projection);\n \n-    match infcx.at(cause, param_env).eq(cache_projection, obligation_projection) {\n+    match infcx.at(cause, param_env).eq(\n+        DefineOpaqueTypes::No,\n+        cache_projection,\n+        obligation_projection,\n+    ) {\n         Ok(InferOk { value: _, obligations }) => {\n             nested_obligations.extend(obligations);\n             assoc_ty_own_obligations(selcx, obligation, &mut nested_obligations);"}, {"sha": "3d5dd18f4c1d7355f81dcebf622e8efe5f98e844", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -8,8 +8,8 @@\n //! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n     TraitRef, Ty, TyCtxt, TypeVisitableExt,\n@@ -177,7 +177,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligations.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(placeholder_trait_predicate, candidate)\n+                .sup(DefineOpaqueTypes::No, placeholder_trait_predicate, candidate)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -462,7 +462,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         nested.extend(self.infcx.commit_if_ok(|_| {\n             self.infcx\n                 .at(&obligation.cause, obligation.param_env)\n-                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .sup(DefineOpaqueTypes::No, obligation_trait_ref, upcast_trait_ref)\n                 .map(|InferOk { obligations, .. }| obligations)\n                 .map_err(|_| Unimplemented)\n         })?);\n@@ -827,11 +827,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 )\n             });\n \n+        // needed to define opaque types for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            // needed for tests/ui/type-alias-impl-trait/assoc-projection-ice.rs\n-            .define_opaque_types(true)\n-            .sup(obligation_trait_ref, expected_trait_ref)\n+            .sup(DefineOpaqueTypes::Yes, obligation_trait_ref, expected_trait_ref)\n             .map(|InferOk { mut obligations, .. }| {\n                 obligations.extend(nested);\n                 obligations\n@@ -896,7 +895,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -995,7 +994,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .sup(target, source_trait)\n+                    .sup(DefineOpaqueTypes::No, target, source_trait)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1066,7 +1065,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(b, a)\n+                    .eq(DefineOpaqueTypes::No, b, a)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n             }\n@@ -1114,7 +1113,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_struct)\n+                    .eq(DefineOpaqueTypes::No, target, new_struct)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n@@ -1144,7 +1143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n-                    .eq(target, new_tuple)\n+                    .eq(DefineOpaqueTypes::No, target, new_tuple)\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n "}, {"sha": "bc1c72da1e175faeac50891fac5d22fab7cb8556", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -38,6 +38,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::TraitEngineExt;\n@@ -912,7 +913,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n                                     .trace(c1, c2)\n-                                    .eq(a.substs, b.substs)\n+                                    .eq(DefineOpaqueTypes::No, a.substs, b.substs)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -930,7 +931,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 if let Ok(new_obligations) = self\n                                     .infcx\n                                     .at(&obligation.cause, obligation.param_env)\n-                                    .eq(c1, c2)\n+                                    .eq(DefineOpaqueTypes::No, c1, c2)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n                                     self.add_depth(\n@@ -964,8 +965,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                     match (evaluate(c1), evaluate(c2)) {\n                         (Ok(c1), Ok(c2)) => {\n-                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n-                            {\n+                            match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                                DefineOpaqueTypes::No,\n+                                c1,\n+                                c2,\n+                            ) {\n                                 Ok(inf_ok) => self.evaluate_predicates_recursively(\n                                     previous_stack,\n                                     inf_ok.into_obligations(),\n@@ -993,7 +997,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n-                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(ct.ty(), ty) {\n+                    match self.infcx.at(&obligation.cause, obligation.param_env).eq(\n+                        DefineOpaqueTypes::No,\n+                        ct.ty(),\n+                        ty,\n+                    ) {\n                         Ok(inf_ok) => self.evaluate_predicates_recursively(\n                             previous_stack,\n                             inf_ok.into_obligations(),\n@@ -1751,7 +1759,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         });\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n+            .sup(DefineOpaqueTypes::No, ty::Binder::dummy(placeholder_trait_ref), trait_bound)\n             .map(|InferOk { obligations: _, value: () }| {\n                 // This method is called within a probe, so we can't have\n                 // inference variables and placeholders escape.\n@@ -1813,7 +1821,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_match = self\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate, infer_projection)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate, infer_projection)\n             .map_or(false, |InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n@@ -2534,7 +2542,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n         let InferOk { obligations, .. } = self\n             .infcx\n             .at(&cause, obligation.param_env)\n-            .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n+            .eq(DefineOpaqueTypes::No, placeholder_obligation_trait_ref, impl_trait_ref)\n             .map_err(|e| {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e.to_string(self.tcx()))\n             })?;\n@@ -2584,7 +2592,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n     ) -> Result<Vec<PredicateObligation<'tcx>>, ()> {\n         self.infcx\n             .at(&obligation.cause, obligation.param_env)\n-            .sup(obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n+            .sup(DefineOpaqueTypes::No, obligation.predicate.to_poly_trait_ref(), poly_trait_ref)\n             .map(|InferOk { obligations, .. }| obligations)\n             .map_err(|_| ())\n     }"}, {"sha": "8e229dd8d6b98aabaab20aae11d5e0ffab889d41", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -10,6 +10,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n+use rustc_infer::infer::DefineOpaqueTypes;\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n@@ -193,7 +194,7 @@ fn fulfill_implication<'tcx>(\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait, target_trait)\n+        infcx.at(&ObligationCause::dummy(), param_env, ).eq(DefineOpaqueTypes::No,source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\","}, {"sha": "ab4c36975a0ecf07053efd85ae48a626498f1ec4", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,15 +1,14 @@\n-use rustc_errors::Diagnostic;\n-use rustc_span::Span;\n-use smallvec::SmallVec;\n-\n+use super::NormalizeExt;\n+use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferOk;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, SubstsRef};\n+use rustc_span::Span;\n+use smallvec::SmallVec;\n \n-use super::NormalizeExt;\n-use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n-use rustc_infer::infer::InferOk;\n pub use rustc_infer::traits::{self, util::*};\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -201,6 +200,7 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n ) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n     let subject = selcx.tcx().bound_impl_subject(impl_def_id);\n     let subject = subject.subst(selcx.tcx(), impl_substs);\n+\n     let InferOk { value: subject, obligations: normalization_obligations1 } =\n         selcx.infcx.at(&ObligationCause::dummy(), param_env).normalize(subject);\n "}, {"sha": "3a3bf6a7ab9e862bd874c4e6aa0946271219861e", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2b7604db9d3262fd9fe9ab39efb60652e252448/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2b7604db9d3262fd9fe9ab39efb60652e252448/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=d2b7604db9d3262fd9fe9ab39efb60652e252448", "patch": "@@ -1,6 +1,6 @@\n use crate::rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_hir as hir;\n-use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n use rustc_infer::traits;\n use rustc_middle::ty::ToPredicate;\n use rustc_span::DUMMY_SP;\n@@ -47,8 +47,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n \n                 // Require the type the impl is implemented on to match\n                 // our type, and ignore the impl if there was a mismatch.\n-                let cause = traits::ObligationCause::dummy();\n-                let Ok(eq_result) = infcx.at(&cause, param_env).eq(impl_trait_ref.self_ty(), impl_ty) else {\n+                let Ok(eq_result) = infcx.at(&traits::ObligationCause::dummy(), param_env).eq(DefineOpaqueTypes::No, impl_trait_ref.self_ty(), impl_ty) else {\n                         continue\n                     };\n                 let InferOk { value: (), obligations } = eq_result;"}]}