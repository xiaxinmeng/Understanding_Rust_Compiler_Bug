{"sha": "edd81d136b861f82bf17e1c0e6f760883710497a", "node_id": "C_kwDOAAsO6NoAKGVkZDgxZDEzNmI4NjFmODJiZjE3ZTFjMGU2Zjc2MDg4MzcxMDQ5N2E", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-28T07:35:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-28T07:35:17Z"}, "message": "Rollup merge of #100955 - nrc:chain, r=joshtriplett\n\nSome papercuts on error::Error\n\nRenames the chain method, since I chain could mean anything and doesn't refer to a chain of sources (cc #58520) (and adds a comment explaining why sources is not a provided method on Error). Renames arguments to the request method from `req` to `demand` since the type is `Demand` rather than Request or Requisition.\n\nr? ``@yaahc``", "tree": {"sha": "86fbb1d3e05600b4179f7e8900bf66653cdd243e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86fbb1d3e05600b4179f7e8900bf66653cdd243e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd81d136b861f82bf17e1c0e6f760883710497a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjCxq1CRBK7hj4Ov3rIwAAZPUIAALDjwEGiPPQTUxQEh37fxMy\nuBz+NNCBnk04bwiYLA8JonwRq5RMc8irOZcVJUNcHiH2PtfohblnefX5DKY1Cvkg\nnmsFy1sC3KXK2ALx1Kuuhuic0VPjE4dELA9/gUiM3OMWUtmDooIaPCSAgitik5Oj\n47KGfdmya17MguaDKpgGOT27kBn5IJSFC0JXOFATx0ESUKCEbomHWPICP57fYVsA\nb+3hZKsRyT3B9VDE4WCNKWG8+3g1XAD18JYtv6yEMeHUdHIeFt3MHEBVmgvmVj/M\ne3ozFcgN63RcNxTlF2uaJqg5SFFeviuYkin7MeOzlzgg7OdjPMpFqkALWrI8Axc=\n=6KIR\n-----END PGP SIGNATURE-----\n", "payload": "tree 86fbb1d3e05600b4179f7e8900bf66653cdd243e\nparent 15476385b529fc508c00d1e78225609f7abce617\nparent 9372c4f6acddce4ec3077a2f8e170549f35b6282\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661672117 +0200\ncommitter GitHub <noreply@github.com> 1661672117 +0200\n\nRollup merge of #100955 - nrc:chain, r=joshtriplett\n\nSome papercuts on error::Error\n\nRenames the chain method, since I chain could mean anything and doesn't refer to a chain of sources (cc #58520) (and adds a comment explaining why sources is not a provided method on Error). Renames arguments to the request method from `req` to `demand` since the type is `Demand` rather than Request or Requisition.\n\nr? ``@yaahc``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd81d136b861f82bf17e1c0e6f760883710497a", "html_url": "https://github.com/rust-lang/rust/commit/edd81d136b861f82bf17e1c0e6f760883710497a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd81d136b861f82bf17e1c0e6f760883710497a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15476385b529fc508c00d1e78225609f7abce617", "url": "https://api.github.com/repos/rust-lang/rust/commits/15476385b529fc508c00d1e78225609f7abce617", "html_url": "https://github.com/rust-lang/rust/commit/15476385b529fc508c00d1e78225609f7abce617"}, {"sha": "9372c4f6acddce4ec3077a2f8e170549f35b6282", "url": "https://api.github.com/repos/rust-lang/rust/commits/9372c4f6acddce4ec3077a2f8e170549f35b6282", "html_url": "https://github.com/rust-lang/rust/commit/9372c4f6acddce4ec3077a2f8e170549f35b6282"}], "stats": {"total": 121, "additions": 60, "deletions": 61}, "files": [{"sha": "4a8efe15e596ba8ffd0a32b8d3b29c4ea8f010ce", "filename": "library/core/src/error.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/edd81d136b861f82bf17e1c0e6f760883710497a/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd81d136b861f82bf17e1c0e6f760883710497a/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=edd81d136b861f82bf17e1c0e6f760883710497a", "patch": "@@ -1,17 +1,6 @@\n #![doc = include_str!(\"error.md\")]\n #![unstable(feature = \"error_in_core\", issue = \"none\")]\n \n-// A note about crates and the facade:\n-//\n-// Originally, the `Error` trait was defined in libcore, and the impls\n-// were scattered about. However, coherence objected to this\n-// arrangement, because to create the blanket impls for `Box` required\n-// knowing that `&str: !Error`, and we have no means to deal with that\n-// sort of conflict just now. Therefore, for the time being, we have\n-// moved the `Error` trait into libstd. As we evolve a sol'n to the\n-// coherence challenge (e.g., specialization, neg impls, etc) we can\n-// reconsider what crate these items belong in.\n-\n #[cfg(test)]\n mod tests;\n \n@@ -30,12 +19,12 @@ use crate::fmt::{Debug, Display};\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[rustc_has_incoherent_inherent_impls]\n@@ -182,8 +171,8 @@ pub trait Error: Debug + Display {\n     /// }\n     ///\n     /// impl std::error::Error for Error {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand\n     ///             .provide_ref::<MyBacktrace>(&self.backtrace)\n     ///             .provide_ref::<dyn std::error::Error + 'static>(&self.source);\n     ///     }\n@@ -201,16 +190,16 @@ pub trait Error: Debug + Display {\n     /// ```\n     #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n     #[allow(unused_variables)]\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {}\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {}\n }\n \n #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n impl<E> Provider for E\n where\n     E: Error + ?Sized,\n {\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        self.provide(req)\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        self.provide(demand)\n     }\n }\n \n@@ -397,7 +386,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -406,8 +395,19 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Source<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+\n+        Source { current: Some(self) }\n     }\n }\n \n@@ -417,12 +417,12 @@ impl dyn Error {\n /// its sources, use `skip(1)`.\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n-pub struct Chain<'a> {\n+pub struct Source<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Source<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -448,8 +448,8 @@ impl<'a, T: Error + ?Sized> Error for &'a T {\n         Error::source(&**self)\n     }\n \n-    fn provide<'b>(&'b self, req: &mut Demand<'b>) {\n-        Error::provide(&**self, req);\n+    fn provide<'b>(&'b self, demand: &mut Demand<'b>) {\n+        Error::provide(&**self, demand);\n     }\n }\n "}, {"sha": "e45059595362f00c7fc348a2e87b50f691ee3d76", "filename": "library/std/src/error.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/edd81d136b861f82bf17e1c0e6f760883710497a/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd81d136b861f82bf17e1c0e6f760883710497a/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=edd81d136b861f82bf17e1c0e6f760883710497a", "patch": "@@ -1,17 +1,6 @@\n #![doc = include_str!(\"../../core/src/error.md\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-// A note about crates and the facade:\n-//\n-// Originally, the `Error` trait was defined in libcore, and the impls\n-// were scattered about. However, coherence objected to this\n-// arrangement, because to create the blanket impls for `Box` required\n-// knowing that `&str: !Error`, and we have no means to deal with that\n-// sort of conflict just now. Therefore, for the time being, we have\n-// moved the `Error` trait into libstd. As we evolve a sol'n to the\n-// coherence challenge (e.g., specialization, neg impls, etc) we can\n-// reconsider what crate these items belong in.\n-\n #[cfg(test)]\n mod tests;\n \n@@ -69,12 +58,12 @@ pub use core::error::Error;\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[cfg(bootstrap)]\n@@ -221,8 +210,8 @@ pub trait Error: Debug + Display {\n     /// }\n     ///\n     /// impl std::error::Error for Error {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand\n     ///             .provide_ref::<MyBacktrace>(&self.backtrace)\n     ///             .provide_ref::<dyn std::error::Error + 'static>(&self.source);\n     ///     }\n@@ -240,14 +229,14 @@ pub trait Error: Debug + Display {\n     /// ```\n     #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n     #[allow(unused_variables)]\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {}\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {}\n }\n \n #[cfg(bootstrap)]\n #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n impl<'b> Provider for dyn Error + 'b {\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        self.provide(req)\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        self.provide(demand)\n     }\n }\n \n@@ -659,8 +648,8 @@ impl<'a, T: Error + ?Sized> Error for &'a T {\n         Error::source(&**self)\n     }\n \n-    fn provide<'b>(&'b self, req: &mut Demand<'b>) {\n-        Error::provide(&**self, req);\n+    fn provide<'b>(&'b self, demand: &mut Demand<'b>) {\n+        Error::provide(&**self, demand);\n     }\n }\n \n@@ -681,8 +670,8 @@ impl<T: Error + ?Sized> Error for Arc<T> {\n         Error::source(&**self)\n     }\n \n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        Error::provide(&**self, req);\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        Error::provide(&**self, demand);\n     }\n }\n \n@@ -976,7 +965,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -985,8 +974,19 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Sources<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+\n+        Sources { current: Some(self) }\n     }\n }\n \n@@ -997,13 +997,13 @@ impl dyn Error {\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n #[cfg(bootstrap)]\n-pub struct Chain<'a> {\n+pub struct Sources<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[cfg(bootstrap)]\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Sources<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -1043,8 +1043,8 @@ impl dyn Error + Send + Sync {\n \n /// An error reporter that prints an error and its sources.\n ///\n-/// Report also exposes configuration options for formatting the error chain, either entirely on a\n-/// single line, or in multi-line format with each cause in the error chain on a new line.\n+/// Report also exposes configuration options for formatting the error sources, either entirely on a\n+/// single line, or in multi-line format with each source on a new line.\n ///\n /// `Report` only requires that the wrapped error implement `Error`. It doesn't require that the\n /// wrapped error be `Send`, `Sync`, or `'static`.\n@@ -1389,7 +1389,7 @@ impl<E> Report<E> {\n     ///\n     /// **Note**: Report will search for the first `Backtrace` it can find starting from the\n     /// outermost error. In this example it will display the backtrace from the second error in the\n-    /// chain, `SuperErrorSideKick`.\n+    /// sources, `SuperErrorSideKick`.\n     ///\n     /// ```rust\n     /// #![feature(error_reporter)]\n@@ -1427,9 +1427,8 @@ impl<E> Report<E> {\n     /// }\n     ///\n     /// impl Error for SuperErrorSideKick {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n-    ///             .provide_ref::<Backtrace>(&self.backtrace);\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_ref::<Backtrace>(&self.backtrace);\n     ///     }\n     /// }\n     ///\n@@ -1486,7 +1485,7 @@ where\n         let backtrace = backtrace.or_else(|| {\n             self.error\n                 .source()\n-                .map(|source| source.chain().find_map(|source| source.request_ref()))\n+                .map(|source| source.sources().find_map(|source| source.request_ref()))\n                 .flatten()\n         });\n         backtrace\n@@ -1497,7 +1496,7 @@ where\n     fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.error)?;\n \n-        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::sources);\n \n         for cause in sources {\n             write!(f, \": {cause}\")?;\n@@ -1518,7 +1517,7 @@ where\n \n             let multiple = cause.source().is_some();\n \n-            for (ind, error) in cause.chain().enumerate() {\n+            for (ind, error) in cause.sources().enumerate() {\n                 writeln!(f)?;\n                 let mut indented = Indented { inner: f };\n                 if multiple {"}]}