{"sha": "68746cd4fb93e95a393c539abc65b93ed5eecdb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4NzQ2Y2Q0ZmI5M2U5NWEzOTNjNTM5YWJjNjViOTNlZDVlZWNkYjU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-11T00:33:16Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T18:11:05Z"}, "message": "librustc: change driver::session::Session::str_of to return @~str", "tree": {"sha": "b1c119eeca7c1fd47c072bc65f572fe59ff29ed3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c119eeca7c1fd47c072bc65f572fe59ff29ed3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68746cd4fb93e95a393c539abc65b93ed5eecdb5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68746cd4fb93e95a393c539abc65b93ed5eecdb5", "html_url": "https://github.com/rust-lang/rust/commit/68746cd4fb93e95a393c539abc65b93ed5eecdb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68746cd4fb93e95a393c539abc65b93ed5eecdb5/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b90ccc9a387bb568f92803a5f071e374c4663e80", "url": "https://api.github.com/repos/rust-lang/rust/commits/b90ccc9a387bb568f92803a5f071e374c4663e80", "html_url": "https://github.com/rust-lang/rust/commit/b90ccc9a387bb568f92803a5f071e374c4663e80"}], "stats": {"total": 445, "additions": 226, "deletions": 219}, "files": [{"sha": "0ed6a1c20b40e817b6d15b1c997538baf5dd6da1", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -655,7 +655,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(sess.str_of(s));\n+          let sani = sanitize(*sess.str_of(s));\n           n += fmt!(\"%u%s\", str::len(sani), sani);\n         } }\n     }"}, {"sha": "5f9033063235b98d5da4f29526b4463956c3e1ad", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -253,8 +253,8 @@ pub impl Session {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n \n-    fn str_of(id: ast::ident) -> ~str {\n-        /*bad*/copy *self.parse_sess.interner.get(id)\n+    fn str_of(id: ast::ident) -> @~str {\n+        self.parse_sess.interner.get(id)\n     }\n     fn ident_of(+st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)"}, {"sha": "25d60ba7f3dad1b3d9f2901f466cb4aff0c7bd90", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -104,13 +104,13 @@ pub fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n }\n \n fn encode_name(ecx: @encode_ctxt, ebml_w: writer::Encoder, name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n+    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n }\n \n fn encode_impl_type_basename(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         ecx.tcx.sess.str_of(name));\n+                         *ecx.tcx.sess.str_of(name));\n }\n \n pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n@@ -305,7 +305,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n-        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n+        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n     }\n \n     do ebml_w.wr_tag(tag_path) {\n@@ -333,7 +333,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?)\",\n-                        ecx.tcx.sess.str_of(ident),\n+                        *ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n                                                 .sess.parse_sess.interner));\n@@ -353,15 +353,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for (*exports).each |exp| {\n+            for exports.each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n+                       *exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n+                ebml_w.wr_str(*exp.name);\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n             }\n@@ -447,7 +447,7 @@ fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         global_index.push({val: id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n-               tcx.sess.str_of(nm), id);\n+               *tcx.sess.str_of(nm), id);\n         encode_visibility(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n@@ -470,7 +470,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n-               ecx.tcx.sess.str_of(ident),\n+               *ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n@@ -515,7 +515,7 @@ fn encode_info_for_method(ecx: @encode_ctxt,\n                           m: @method,\n                           +all_tps: ~[ty_param]) {\n     debug!(\"encode_info_for_method: %d %s %u\", m.id,\n-           ecx.tcx.sess.str_of(m.ident), all_tps.len());\n+           *ecx.tcx.sess.str_of(m.ident), all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     match m.self_ty.node {\n@@ -678,7 +678,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                                ebml_w,\n                                dtor.node.id,\n                                ecx.tcx.sess.ident_of(\n-                                   ecx.tcx.sess.str_of(item.ident) +\n+                                   *ecx.tcx.sess.str_of(item.ident) +\n                                    ~\"_dtor\"),\n                                path,\n                                if tps.len() > 0u {\n@@ -1186,7 +1186,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n-    ebml_w.writer.write(str::to_bytes(ecx.tcx.sess.str_of(dep.name)));\n+    ebml_w.writer.write(str::to_bytes(*ecx.tcx.sess.str_of(dep.name)));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_crate_dep_vers);\n     ebml_w.writer.write(str::to_bytes(*dep.vers));"}, {"sha": "320a76332ead53bb1b355ecdba7c99cfc698bc2c", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -175,7 +175,7 @@ fn enc_bound_region(w: io::Writer, cx: @ctxt, br: ty::bound_region) {\n       }\n       ty::br_named(s) => {\n         w.write_char('[');\n-        w.write_str(cx.tcx.sess.str_of(s));\n+        w.write_str(*cx.tcx.sess.str_of(s));\n         w.write_char(']')\n       }\n       ty::br_cap_avoid(id, br) => {\n@@ -282,7 +282,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n       ty::ty_rec(fields) => {\n         w.write_str(&\"R[\");\n         for fields.each |field| {\n-            w.write_str(cx.tcx.sess.str_of(field.ident));\n+            w.write_str(*cx.tcx.sess.str_of(field.ident));\n             w.write_char('=');\n             enc_mt(w, cx, field.mt);\n         }"}, {"sha": "427d4492897fce03304b6b2173370f81ce0ff343", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -96,7 +96,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n                            maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n@@ -108,7 +108,7 @@ pub fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n-           ecx.tcx.sess.str_of(ii.ident()),\n+           *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n }\n \n@@ -132,10 +132,10 @@ pub fn decode_inlined_item(cdata: cstore::crate_metadata,\n                                           to_id_range: to_id_range});\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n+        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n         debug!(\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n-               tcx.sess.str_of(ii.ident()));\n+               *tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n         decode_side_tables(xcx, ast_doc);"}, {"sha": "85ed4e74efb71c63675d7e2367df8210f6ba4b1c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -143,13 +143,13 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match (*ctor) {\n-                        val(const_bool(true)) => Some(~\"true\"),\n-                        val(const_bool(false)) => Some(~\"false\"),\n+                        val(const_bool(true)) => Some(@~\"true\"),\n+                        val(const_bool(false)) => Some(@~\"false\"),\n                         _ => None\n                     }\n                 }\n                 ty::ty_enum(id, _) => {\n-                    let vid = match (*ctor) {\n+                    let vid = match *ctor {\n                         variant(id) => id,\n                         _ => fail!(~\"check_exhaustive: non-variant ctor\"),\n                     };\n@@ -163,8 +163,8 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                     }\n                 }\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                    match (*ctor) {\n-                        vec(n) => Some(fmt!(\"vectors of length %u\", n)),\n+                    match *ctor {\n+                        vec(n) => Some(@fmt!(\"vectors of length %u\", n)),\n                     _ => None\n                     }\n                 }\n@@ -173,7 +173,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n         }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-        Some(ref s) => ~\": \" + (*s) + ~\" not covered\",\n+        Some(ref s) => ~\": \" + **s + ~\" not covered\",\n         None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);"}, {"sha": "a7cfde0e70fec39b6ba266a2d99fdb34d5d74af8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -383,11 +383,11 @@ impl IrMaps {\n         }\n     }\n \n-    fn variable_name(&mut self, var: Variable) -> ~str {\n+    fn variable_name(&mut self, var: Variable) -> @~str {\n         match copy self.var_kinds[*var] {\n             Local(LocalInfo {ident: nm, _}) |\n             Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n-            ImplicitRet => ~\"<implicit-ret>\"\n+            ImplicitRet => @~\"<implicit-ret>\"\n         }\n     }\n \n@@ -1777,7 +1777,7 @@ impl @Liveness {\n                 self.tcx.sess.span_err(\n                     move_expr.span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", self.tcx.sess.str_of(name)));\n+                          copy or move mode\", *self.tcx.sess.str_of(name)));\n                 return;\n               }\n               Local(*) | ImplicitRet => {\n@@ -1798,7 +1798,7 @@ impl @Liveness {\n                     move_expr.span,\n                     fmt!(\"`%s` moved into closure environment here \\\n                           because its type is moved by default\",\n-                         name));\n+                         *name));\n             }\n             expr_path(*) => {\n                 self.report_illegal_read(\n@@ -1838,7 +1838,7 @@ impl @Liveness {\n             move_expr.span,\n             fmt!(\"%s`%s` moved here because %s has type %s, \\\n                   which is moved by default (use `copy` to override)\",\n-                 expr_descr, name, pronoun,\n+                 expr_descr, *name, pronoun,\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n@@ -1858,12 +1858,12 @@ impl @Liveness {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"capture of %s: `%s`\", msg, name));\n+                fmt!(\"capture of %s: `%s`\", msg, *name));\n           }\n           ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"use of %s: `%s`\", msg, name));\n+                fmt!(\"use of %s: `%s`\", msg, *name));\n           }\n           ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n@@ -1873,9 +1873,9 @@ impl @Liveness {\n         }\n     }\n \n-    fn should_warn(var: Variable) -> Option<~str> {\n+    fn should_warn(var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n-        if name[0] == ('_' as u8) {None} else {Some(name)}\n+        if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n     fn warn_about_unused_args(decl: fn_decl, entry_ln: LiveNode) {\n@@ -1913,11 +1913,11 @@ impl @Liveness {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n                         sp, fmt!(\"variable `%s` is assigned to, \\\n-                                  but never used\", *name));\n+                                  but never used\", **name));\n                 } else {\n                     // FIXME(#3266)--make liveness warnings lintable\n                     self.tcx.sess.span_warn(\n-                        sp, fmt!(\"unused variable: `%s`\", *name));\n+                        sp, fmt!(\"unused variable: `%s`\", **name));\n                 }\n             }\n             return true;\n@@ -1931,7 +1931,7 @@ impl @Liveness {\n                 // FIXME(#3266)--make liveness warnings lintable\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    fmt!(\"value assigned to `%s` is never read\", *name));\n+                    fmt!(\"value assigned to `%s` is never read\", **name));\n             }\n         }\n     }"}, {"sha": "1c48df115e544dd4af6f8b3218fafb239217846f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -629,7 +629,7 @@ pub impl mem_categorization_ctxt {\n                 self.tcx.sess.span_bug(\n                     node.span(),\n                     fmt!(\"Cannot find field `%s` in type `%s`\",\n-                         self.tcx.sess.str_of(f_name),\n+                         *self.tcx.sess.str_of(f_name),\n                          ty_to_str(self.tcx, base_cmt.ty)));\n             }\n         };\n@@ -995,7 +995,7 @@ pub impl mem_categorization_ctxt {\n                  self.ptr_sigil(ptr), derefs)\n           }\n           cat_comp(cmt, comp) => {\n-            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp))\n+            fmt!(\"%s.%s\", self.cat_to_repr(cmt.cat), *self.comp_to_repr(comp))\n           }\n           cat_discr(cmt, _) => self.cat_to_repr(cmt.cat)\n         }\n@@ -1018,13 +1018,13 @@ pub impl mem_categorization_ctxt {\n         }\n     }\n \n-    fn comp_to_repr(&self, comp: comp_kind) -> ~str {\n+    fn comp_to_repr(&self, comp: comp_kind) -> @~str {\n         match comp {\n           comp_field(fld, _) => self.tcx.sess.str_of(fld),\n-          comp_index(*) => ~\"[]\",\n-          comp_tuple => ~\"()\",\n-          comp_anon_field => ~\"<anonymous field>\",\n-          comp_variant(_) => ~\"<enum>\"\n+          comp_index(*) => @~\"[]\",\n+          comp_tuple => @~\"()\",\n+          comp_anon_field => @~\"<anonymous field>\",\n+          comp_variant(_) => @~\"<enum>\"\n         }\n     }\n \n@@ -1043,7 +1043,7 @@ pub impl mem_categorization_ctxt {\n           }\n           lp_comp(lp, comp) => {\n             fmt!(\"%s.%s\", self.lp_to_str(lp),\n-                 self.comp_to_repr(comp))\n+                 *self.comp_to_repr(comp))\n           }\n         }\n     }"}, {"sha": "e436d73aa7a934a0fdb95421f96d64075ea9fd42", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -116,7 +116,7 @@ pub type TraitMap = @HashMap<node_id,@DVec<def_id>>;\n pub type ExportMap2 = HashMap<node_id, ~[Export2]>;\n \n pub struct Export2 {\n-    name: ~str,         // The name of the target.\n+    name: @~str,        // The name of the target.\n     def_id: def_id,     // The definition of the target.\n     reexport: bool,     // Whether this is a reexport.\n }\n@@ -1006,12 +1006,12 @@ pub impl Resolver {\n                     self.session.span_err(sp,\n                         fmt!(\"duplicate definition of %s %s\",\n                              namespace_to_str(ns),\n-                             self.session.str_of(name)));\n+                             *self.session.str_of(name)));\n                     do child.span_for_namespace(ns).iter() |sp| {\n                         self.session.span_note(*sp,\n                              fmt!(\"first definition of %s %s here:\",\n                                   namespace_to_str(ns),\n-                                  self.session.str_of(name)));\n+                                  *self.session.str_of(name)));\n                     }\n                 }\n                 return (child, new_parent);\n@@ -1549,7 +1549,7 @@ pub impl Resolver {\n     fn handle_external_def(def: def,\n                            modules: HashMap<def_id, @Module>,\n                            child_name_bindings: @mut NameBindings,\n-                           final_ident: ~str,\n+                           final_ident: &str,\n                            ident: ident,\n                            new_parent: ReducedGraphParent) {\n         match def {\n@@ -1634,7 +1634,7 @@ pub impl Resolver {\n                     debug!(\"(building reduced graph for \\\n                             external crate) ... adding \\\n                             trait method '%s'\",\n-                           self.session.str_of(method_name));\n+                           *self.session.str_of(method_name));\n \n                     // Add it to the trait info if not static.\n                     if self_ty != sty_static {\n@@ -1741,7 +1741,8 @@ pub impl Resolver {\n                     self.handle_external_def(def,\n                                              modules,\n                                              child_name_bindings,\n-                                             self.session.str_of(final_ident),\n+                                             *self.session.str_of(\n+                                                 final_ident),\n                                              final_ident,\n                                              new_parent);\n                 }\n@@ -1759,7 +1760,8 @@ pub impl Resolver {\n                                     debug!(\"(building reduced graph for \\\n                                             external crate) processing \\\n                                             static methods for type name %s\",\n-                                            self.session.str_of(final_ident));\n+                                            *self.session.str_of(\n+                                                final_ident));\n \n                                     let (child_name_bindings, new_parent) =\n                                         self.add_child(final_ident,\n@@ -1805,7 +1807,7 @@ pub impl Resolver {\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n                                                  static method '%s'\",\n-                                               self.session.str_of(ident));\n+                                               *self.session.str_of(ident));\n \n                                         let (method_name_bindings, _) =\n                                             self.add_child(\n@@ -1855,7 +1857,7 @@ pub impl Resolver {\n                         directive: privacy %? %s::%s\",\n                        privacy,\n                        self.idents_to_str(module_path.get()),\n-                       self.session.str_of(target));\n+                       *self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n                     Some(resolution) => {\n@@ -1971,8 +1973,8 @@ pub impl Resolver {\n                     // We presumably emitted an error. Continue.\n                     let idents = import_directive.module_path.get();\n                     let msg = fmt!(\"failed to resolve import: %s\",\n-                                   self.import_path_to_str(idents,\n-                                   *import_directive.subclass));\n+                                   *self.import_path_to_str(idents,\n+                                       *import_directive.subclass));\n                     self.session.span_err(import_directive.span, msg);\n                 }\n                 Indeterminate => {\n@@ -1989,26 +1991,28 @@ pub impl Resolver {\n     }\n \n     fn idents_to_str(idents: ~[ident]) -> ~str {\n-        let ident_strs = idents.map(|&ident| self.session.str_of(ident));\n-        return str::connect(ident_strs, \"::\");\n+        let ident_strs = do idents.map |ident| {\n+            /*bad*/ copy *self.session.str_of(*ident)\n+        };\n+        str::connect(ident_strs, \"::\")\n     }\n \n     fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n-                                                                     -> ~str {\n+                                                                    -> @~str {\n         match subclass {\n             SingleImport(_target, source, _ns) => self.session.str_of(source),\n-            GlobImport => ~\"*\"\n+            GlobImport => @~\"*\"\n         }\n     }\n \n     fn import_path_to_str(idents: ~[ident], subclass: ImportDirectiveSubclass)\n-                                                                     -> ~str {\n+                                                                    -> @~str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n-            fmt!(\"%s::%s\",\n+            @fmt!(\"%s::%s\",\n                  self.idents_to_str(idents),\n-                 self.import_directive_subclass_to_str(subclass))\n+                 *self.import_directive_subclass_to_str(subclass))\n         }\n     }\n \n@@ -2122,9 +2126,9 @@ pub impl Resolver {\n \n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n-               self.session.str_of(target),\n+               *self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               self.session.str_of(source),\n+               *self.session.str_of(source),\n                self.module_to_str(module_));\n \n         // We need to resolve both namespaces for this to succeed.\n@@ -2314,9 +2318,9 @@ pub impl Resolver {\n \n         debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n                 from `%s`\",\n-               self.session.str_of(target),\n+               *self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               self.session.str_of(source),\n+               *self.session.str_of(source),\n                self.module_to_str(module_));\n \n         // We need to resolve the module namespace for this to succeed.\n@@ -2527,7 +2531,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   self.session.str_of(ident),\n+                   *self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    dest_import_resolution.privacy);\n@@ -2575,7 +2579,7 @@ pub impl Resolver {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            self.session.str_of(name));\n+                            *self.session.str_of(name));\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n@@ -2589,7 +2593,7 @@ pub impl Resolver {\n                                     self.session.span_err(span,\n                                                           fmt!(\"not a \\\n                                                                 module: %s\",\n-                                                               self.session.\n+                                                               *self.session.\n                                                                    str_of(\n                                                                     name)));\n                                     return Failed;\n@@ -2603,7 +2607,7 @@ pub impl Resolver {\n                             // There are no type bindings at all.\n                             self.session.span_err(span,\n                                                   fmt!(\"not a module: %s\",\n-                                                       self.session.str_of(\n+                                                       *self.session.str_of(\n                                                             name)));\n                             return Failed;\n                         }\n@@ -2709,7 +2713,7 @@ pub impl Resolver {\n \n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n-               self.session.str_of(name),\n+               *self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_));\n \n@@ -2949,7 +2953,7 @@ pub impl Resolver {\n                               allow_globs: bool)\n                            -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n-               self.session.str_of(name),\n+               *self.session.str_of(name),\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n@@ -3003,7 +3007,7 @@ pub impl Resolver {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve %s\",\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n         return Failed;\n     }\n \n@@ -3032,8 +3036,8 @@ pub impl Resolver {\n \n         debug!(\"(resolving one-level naming result) resolving import `%s` = \\\n                 `%s` in `%s`\",\n-                self.session.str_of(target_name),\n-                self.session.str_of(source_name),\n+                *self.session.str_of(target_name),\n+                *self.session.str_of(source_name),\n                 self.module_to_str(module_));\n \n         // Find the matching items in the lexical scope chain for every\n@@ -3154,7 +3158,7 @@ pub impl Resolver {\n                 debug!(\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(&module_result),\n-                       self.session.str_of(target_name),\n+                       *self.session.str_of(target_name),\n                        self.module_to_str(module_));\n \n                 import_resolution.value_target = value_result;\n@@ -3275,7 +3279,7 @@ pub impl Resolver {\n             (Some(d), Some(Public)) => {\n                 debug!(\"(computing exports) YES: %s '%s' => %?\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n-                       self.session.str_of(ident),\n+                       *self.session.str_of(ident),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n                     reexport: reexport,\n@@ -3295,7 +3299,7 @@ pub impl Resolver {\n     fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n-                   self.session.str_of(*ident));\n+                   *self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n                                              *ident,\n                                              *namebindings,\n@@ -3311,14 +3315,14 @@ pub impl Resolver {\n         for module_.import_resolutions.each |ident, importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n-                       self.session.str_of(*ident));\n+                       *self.session.str_of(*ident));\n                 loop;\n             }\n             for [ TypeNS, ValueNS ].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               self.session.str_of(*ident));\n+                               *self.session.str_of(*ident));\n                         self.add_exports_of_namebindings(&mut *exports2,\n                                                          *ident,\n                                                          target.bindings,\n@@ -3361,15 +3365,15 @@ pub impl Resolver {\n                 match orig_module.children.find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n-                               self.session.str_of(name),\n+                               *self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n-                                       self.session.str_of(name),\n+                                       *self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n                             Some(module_) => {\n@@ -3543,7 +3547,7 @@ pub impl Resolver {\n \n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n-               self.session.str_of(item.ident));\n+               *self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -4105,15 +4109,15 @@ pub impl Resolver {\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             self.session.str_of(key), i + 1));\n+                             *self.session.str_of(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 self.session.str_of(key), i + 1));\n+                                 *self.session.str_of(key), i + 1));\n                     }\n                   }\n                 }\n@@ -4125,7 +4129,7 @@ pub impl Resolver {\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             self.session.str_of(key), i + 1));\n+                             *self.session.str_of(key), i + 1));\n                 }\n             }\n         }\n@@ -4209,7 +4213,7 @@ pub impl Resolver {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n-                                       self.session.str_of(\n+                                       *self.session.str_of(\n                                             path.idents.last()),\n                                        def);\n                                 result_def = Some(def);\n@@ -4278,7 +4282,7 @@ pub impl Resolver {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     struct or enum variant\",\n-                                    self.session.str_of(ident));\n+                                    *self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4292,13 +4296,13 @@ pub impl Resolver {\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                        self.session\n-                                                        .str_of(ident)));\n+                                                        *self.session\n+                                                            .str_of(ident)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     constant\",\n-                                    self.session.str_of(ident));\n+                                    *self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4313,7 +4317,7 @@ pub impl Resolver {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(ident));\n+                                   *self.session.str_of(ident));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4395,7 +4399,7 @@ pub impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"not an enum variant: %s\",\n-                                     self.session.str_of(\n+                                     *self.session.str_of(\n                                          path.idents.last())));\n                         }\n                         None => {\n@@ -4736,7 +4740,7 @@ pub impl Resolver {\n             Some(dl_def(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n-                       self.session.str_of(ident),\n+                       *self.session.str_of(ident),\n                        def);\n                 return Some(def);\n             }\n@@ -4764,7 +4768,7 @@ pub impl Resolver {\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               self.session.str_of(ident));\n+                               *self.session.str_of(ident));\n                         return Some(def);\n                     }\n                 }\n@@ -4785,15 +4789,15 @@ pub impl Resolver {\n           let rib = self.type_ribs.get_elt(i);\n           match rib.kind {\n             MethodRibKind(node_id, _) =>\n-              for vec::each(self.crate.node.module.items) |item| {\n+              for self.crate.node.module.items.each |item| {\n                 if item.id == node_id {\n                   match item.node {\n                     item_struct(class_def, _) => {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _, _) => {\n-                              if str::eq_slice(self.session.str_of(ident),\n+                              if str::eq_slice(*self.session.str_of(ident),\n                                                name) {\n                                 return true\n                               }\n@@ -4902,8 +4906,9 @@ pub impl Resolver {\n                     None =>\n                         self.session.span_err(expr.span,\n                                               fmt!(\"use of undeclared label \\\n-                                                   `%s`\", self.session.str_of(\n-                                                  label))),\n+                                                   `%s`\",\n+                                                   *self.session.str_of(\n+                                                       label))),\n                     Some(dl_def(def @ def_label(_))) =>\n                         self.record_def(expr.id, def),\n                     Some(_) =>\n@@ -4998,7 +5003,7 @@ pub impl Resolver {\n \n     fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n \n         let found_traits = @DVec();\n         let mut search_module = self.current_module;\n@@ -5094,15 +5099,15 @@ pub impl Resolver {\n                 for method '%s'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n-               self.session.str_of(name));\n+               *self.session.str_of(name));\n \n         match self.trait_info.find(&trait_def_id) {\n             Some(trait_info) if trait_info.contains_key(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n-                       self.session.str_of(name));\n+                       *self.session.str_of(name));\n                 (*found_traits).push(trait_def_id);\n                 true\n             }\n@@ -5289,7 +5294,7 @@ pub impl Resolver {\n \n         debug!(\"Children:\");\n         for module_.children.each_key |&name| {\n-            debug!(\"* %s\", self.session.str_of(name));\n+            debug!(\"* %s\", *self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5312,7 +5317,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", self.session.str_of(name),\n+            debug!(\"* %s:%s%s\", *self.session.str_of(name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "a6813997ae8335433120186962917f0d139c6d89", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -1629,7 +1629,7 @@ pub fn trans_match_inner(scope_cx: block,\n             // Special case for empty types\n             let fail_cx = @mut None;\n             let f: mk_fail = || mk_fail(scope_cx, discr_expr.span,\n-                            ~\"scrutinizing value that can't exist\", fail_cx);\n+                            @~\"scrutinizing value that can't exist\", fail_cx);\n             Some(f)\n         } else {\n             None\n@@ -1661,7 +1661,7 @@ pub fn trans_match_inner(scope_cx: block,\n     bcx = controlflow::join_blocks(scope_cx, dvec::unwrap(arm_cxs));\n     return bcx;\n \n-    fn mk_fail(bcx: block, sp: span, +msg: ~str,\n+    fn mk_fail(bcx: block, sp: span, msg: @~str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, ~\"case_fallthrough\");"}, {"sha": "16fdebff5589d932b494f01d60ba1ea9bbb25c28", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -521,7 +521,7 @@ pub fn compare_scalar_types(cx: block,\n             rslt(\n                 controlflow::trans_fail(\n                     cx, None,\n-                    ~\"attempt to compare values of type type\"),\n+                    @~\"attempt to compare values of type type\"),\n                 C_nil())\n         }\n         _ => {\n@@ -639,7 +639,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           _ => cx.tcx().sess.bug(fmt!(\"iter_variant: not a function type: \\\n                                        %s (variant name = %s)\",\n                                       cx.ty_to_str(fn_ty),\n-                                      cx.sess().str_of(variant.name)))\n+                                      *cx.sess().str_of(variant.name)))\n         }\n         return cx;\n     }\n@@ -776,7 +776,7 @@ pub fn fail_if_zero(cx: block, span: span, divmod: ast::binop,\n       }\n     };\n     do with_cond(cx, is_zero) |bcx| {\n-        controlflow::trans_fail(bcx, Some(span), /*bad*/copy text)\n+        controlflow::trans_fail(bcx, Some(span), @/*bad*/copy text)\n     }\n }\n \n@@ -1037,20 +1037,20 @@ pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: block, sp_opt: Option<span>, +trace_str: ~str) {\n+pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: ~str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n-    add_comment(bcx, trace_str);\n-    let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n+    add_comment(bcx, /*bad*/ copy trace_str);\n+    let V_trace_str = C_cstr(bcx.ccx(), @/*bad*/ copy trace_str);\n     let {V_filename, V_line} = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n+        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n          V_line: 0}\n       }\n     };\n@@ -1170,7 +1170,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, +kind: block_kind,\n         special_idents::invalid\n     };\n     unsafe {\n-        let llbb: BasicBlockRef = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n+        let llbb = str::as_c_str(*cx.ccx.sess.str_of(s), |buf| {\n             llvm::LLVMAppendBasicBlock(cx.llfn, buf)\n         });\n         let bcx = mk_block(llbb,\n@@ -1401,7 +1401,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         do option::iter(&simple_name) |name| {\n-            str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n+            str::as_c_str(*cx.ccx().sess.str_of(*name), |buf| {\n                 unsafe {\n                     llvm::LLVMSetValueName(val, buf)\n                 }\n@@ -2815,7 +2815,7 @@ pub fn create_module_map(ccx: @crate_ctxt) -> ValueRef {\n     }\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |&key, &val| {\n-        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, key)),\n+        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n     }"}, {"sha": "fe9eea19c3ff4fc4924e9a2ad0d17c16aa59c9e8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -186,7 +186,7 @@ pub struct crate_ctxt {\n      // Cache generated vtables\n      vtables: HashMap<mono_id, ValueRef>,\n      // Cache of constant strings,\n-     const_cstr_cache: HashMap<~str, ValueRef>,\n+     const_cstr_cache: HashMap<@~str, ValueRef>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -1141,14 +1141,14 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n+pub fn C_cstr(cx: @crate_ctxt, s: @~str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n             Some(llval) => return llval,\n             None => ()\n         }\n \n-        let sc = do str::as_c_str(s) |buf| {\n+        let sc = do str::as_c_str(*s) |buf| {\n             llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n         let g =\n@@ -1166,9 +1166,9 @@ pub fn C_cstr(cx: @crate_ctxt, s: ~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n+pub fn C_estr_slice(cx: @crate_ctxt, s: @~str) -> ValueRef {\n     unsafe {\n-        let len = str::len(s);\n+        let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n         C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n     }\n@@ -1324,7 +1324,7 @@ pub fn path_str(sess: session::Session, p: path) -> ~str {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first { first = false; }\n                 else { r += ~\"::\"; }\n-                r += sess.str_of(s);\n+                r += *sess.str_of(s);\n             }\n         }\n     }"}, {"sha": "2c5a93a2532f85931e9945fddaa41b707ee3a6aa", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -55,7 +55,7 @@ pub fn const_lit(cx: @crate_ctxt, e: @ast::expr, lit: ast::lit)\n       }\n       ast::lit_bool(b) => C_bool(b),\n       ast::lit_nil => C_nil(),\n-      ast::lit_str(s) => C_estr_slice(cx, /*bad*/copy *s)\n+      ast::lit_str(s) => C_estr_slice(cx, s)\n     }\n }\n "}, {"sha": "0997df66b986e28f287af4f7993411ea8b9268b4", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -320,16 +320,16 @@ pub fn trans_check_expr(bcx: block,\n                         s: ~str)\n                      -> block {\n     let _icx = bcx.insn_ctxt(\"trans_check_expr\");\n-    let expr_str = s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n-        + ~\" failed\";\n+    let expr_str = @(s + ~\" \" + expr_to_str(pred_expr, bcx.ccx().sess.intr())\n+        + ~\" failed\");\n     let Result {bcx, val} = {\n         do with_scope_result(bcx, chk_expr.info(), ~\"check\") |bcx| {\n             expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n     let val = bool_to_i1(bcx, val);\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n-        trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n+        trans_fail(bcx, Some(pred_expr.span), expr_str)\n     }\n }\n \n@@ -356,13 +356,13 @@ pub fn trans_fail_expr(bcx: block,\n                     ppaux::ty_to_str(tcx, arg_datum.ty));\n             }\n         }\n-        _ => return trans_fail(bcx, sp_opt, ~\"explicit failure\")\n+        _ => trans_fail(bcx, sp_opt, @~\"explicit failure\")\n     }\n }\n \n pub fn trans_fail(bcx: block,\n                   sp_opt: Option<span>,\n-                  +fail_str: ~str)\n+                  fail_str: @~str)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n@@ -379,11 +379,11 @@ fn trans_fail_value(bcx: block,\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        {V_filename: C_cstr(bcx.ccx(), /*bad*/copy loc.file.name),\n+        {V_filename: C_cstr(bcx.ccx(), @/*bad*/ copy loc.file.name),\n          V_line: loc.line as int}\n       }\n       None => {\n-        {V_filename: C_cstr(bcx.ccx(), ~\"<runtime>\"),\n+        {V_filename: C_cstr(bcx.ccx(), @~\"<runtime>\"),\n          V_line: 0}\n       }\n     };\n@@ -403,7 +403,7 @@ pub fn trans_fail_bounds_check(bcx: block, sp: span,\n \n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(sp.lo);\n     let line = C_int(ccx, loc.line as int);\n-    let filename_cstr = C_cstr(bcx.ccx(), /*bad*/copy loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n     let filename = PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n \n     let args = ~[filename, line, index, len];"}, {"sha": "838d764cc4d8902d7ed23e58438d7a9da2cda813", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -60,12 +60,12 @@ const DW_ATE_signed_char: int = 0x06;\n const DW_ATE_unsigned: int = 0x07;\n const DW_ATE_unsigned_char: int = 0x08;\n \n-fn llstr(s: ~str) -> ValueRef {\n-    str::as_c_str(s, |sbuf| {\n+fn llstr(s: &str) -> ValueRef {\n+    do str::as_c_str(s) |sbuf| {\n         unsafe {\n-            llvm::LLVMMDString(sbuf, str::len(s) as libc::c_uint)\n+            llvm::LLVMMDString(sbuf, s.len() as libc::c_uint)\n         }\n-    })\n+    }\n }\n fn lltag(lltag: int) -> ValueRef {\n     lli32(LLVMDebugVersion | lltag)\n@@ -79,10 +79,9 @@ fn lli64(val: int) -> ValueRef {\n fn lli1(bval: bool) -> ValueRef {\n     C_i1(bval)\n }\n-fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n+fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        llvm::LLVMMDNode(vec::raw::to_ptr(elems),\n-                         vec::len(elems) as libc::c_uint)\n+        llvm::LLVMMDNode(vec::raw::to_ptr(elems), elems.len() as libc::c_uint)\n     }\n }\n fn llunused() -> ValueRef {\n@@ -205,7 +204,7 @@ fn create_compile_unit(cx: @crate_ctxt) -> @metadata<compile_unit_md> {\n         let unit_metadata = ~[lltag(tg),\n                              llunused(),\n                              lli32(DW_LANG_RUST),\n-                             llstr(copy crate_name),\n+                             llstr(crate_name),\n                              llstr(work_dir),\n                              llstr(env!(\"CFG_VERSION\")),\n                              lli1(true), // deprecated: main compile unit\n@@ -369,7 +368,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n \n struct StructCtxt {\n     file: ValueRef,\n-    name: ~str,\n+    name: @~str,\n     line: int,\n     members: ~[ValueRef],\n     total_size: int,\n@@ -378,17 +377,17 @@ struct StructCtxt {\n \n fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n     return create_composite_type(StructureTypeTag,\n-                                 /*bad*/copy cx.name,\n+                                 *cx.name,\n                                  cx.file,\n                                  cx.line,\n                                  cx.total_size,\n                                  cx.align,\n                                  0,\n-                                 option::None,\n-                                 option::Some(/*bad*/copy cx.members));\n+                                 None,\n+                                 Some(/*bad*/copy cx.members));\n }\n \n-fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n+fn create_structure(file: @metadata<file_md>, name: @~str, line: int)\n                  -> @mut StructCtxt {\n     let cx = @mut StructCtxt {\n         file: file.node,\n@@ -401,7 +400,7 @@ fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n     return cx;\n }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n+fn create_derived_type(type_tag: int, file: ValueRef, name: &str, line: int,\n                        size: int, align: int, offset: int, ty: ValueRef)\n     -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n@@ -418,14 +417,14 @@ fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n }\n \n fn add_member(cx: @mut StructCtxt,\n-              +name: ~str,\n+              name: &str,\n               line: int,\n               size: int,\n               align: int,\n               ty: ValueRef) {\n     cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n-                                       size * 8, align * 8, cx.total_size,\n-                                       ty));\n+                                        size * 8, align * 8, cx.total_size,\n+                                        ty));\n     cx.total_size += size * 8;\n }\n \n@@ -443,7 +442,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n         let field_t = ty::get_field(cx.tcx, t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, cx.sess.str_of(field.node.ident),\n+        add_member(scx, *cx.sess.str_of(field.node.ident),\n                    line_from_span(cx.sess.codemap, field.span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n@@ -466,7 +465,8 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n     let uint_t = ty::mk_uint(cx.tcx);\n     let refcount_type = create_basic_type(cx, uint_t, span);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, outer), 0);\n+    let scx = create_structure(file_node,\n+                               @/*bad*/ copy ty_to_str(cx.tcx, outer), 0);\n     add_member(scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n     add_member(scx, ~\"boxed\", 0, 8, //XXX member_size_and_align(??)\n@@ -479,7 +479,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     return mdval;\n }\n \n-fn create_composite_type(type_tag: int, +name: ~str, file: ValueRef,\n+fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n                          line: int, size: int, align: int, offset: int,\n                          derived: Option<ValueRef>,\n                          +members: Option<~[ValueRef]>)\n@@ -515,7 +515,8 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t), 0);\n+    let scx = create_structure(file_node,\n+                               @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx), vec_ty_span);\n     add_member(scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n@@ -525,8 +526,8 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t,\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let data_ptr = create_composite_type(ArrayTypeTag, ~\"\", file_node.node, 0,\n                                          arr_size, arr_align, 0,\n-                                         option::Some(elem_ty_md.node),\n-                                         option::Some(~[subrange]));\n+                                         Some(elem_ty_md.node),\n+                                         Some(~[subrange]));\n     add_member(scx, ~\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(scx);\n@@ -641,7 +642,7 @@ fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> ~str {\n     /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n-fn create_var(type_tag: int, context: ValueRef, +name: ~str, file: ValueRef,\n+fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n               line: int, ret_ty: ValueRef) -> ValueRef {\n     let lldata = ~[lltag(type_tag),\n                   context,\n@@ -679,7 +680,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n             None => create_function(bcx.fcx).node,\n             Some(_) => create_block(bcx).node\n         };\n-        let mdnode = create_var(tg, context, cx.sess.str_of(name),\n+        let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n                                 filemd.node, loc.line as int, tymd.node);\n         let mdval = @{node: mdnode, data: {id: local.node.id}};\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n@@ -728,7 +729,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                 // XXX: This is wrong; it should work for multiple bindings.\n                 let mdnode = create_var(tg,\n                                         context.node,\n-                                        cx.sess.str_of(path.idents.last()),\n+                                        *cx.sess.str_of(path.idents.last()),\n                                         filemd.node,\n                                         loc.line as int,\n                                         tymd.node);\n@@ -839,9 +840,9 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let fn_metadata = ~[lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(cx.sess.str_of(ident)),\n+                       llstr(*cx.sess.str_of(ident)),\n                         //XXX fully-qualified C++ name:\n-                       llstr(cx.sess.str_of(ident)),\n+                       llstr(*cx.sess.str_of(ident)),\n                        llstr(~\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),"}, {"sha": "49e47e35572e20ba61f53208ff203173bda5366a", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -49,7 +49,7 @@ fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n \n pub fn link_name(ccx: @crate_ctxt, i: @ast::foreign_item) -> @~str {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n-        None => @ccx.sess.str_of(i.ident),\n+        None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n     }\n }\n@@ -334,13 +334,13 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n                        +path: ast_map::path,\n                        substs: @param_substs,\n                        ref_id: Option<ast::node_id>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n+    debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n \n     // XXX: Bad copy.\n     let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n                                Some(copy substs), Some(item.span));\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n-    match ccx.sess.str_of(item.ident) {\n+    match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),"}, {"sha": "cc31c9ace9867615c37eed1229d8ad4686a42fd3", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -150,7 +150,7 @@ pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n                 });\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n-                       cx.tcx.sess.str_of(variant.name),\n+                       *cx.tcx.sess.str_of(variant.name),\n                        ty_str(cx.tn, T_struct(lltypes)));\n \n                 let this_size = llsize_of_real(cx, T_struct(lltypes));"}, {"sha": "b7732aa817f8444c55da70fdb0dd92aa746fb473", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -322,7 +322,7 @@ pub fn trans_static_method_callee(bcx: block,\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n+            name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n@@ -794,10 +794,10 @@ pub fn make_vtable(ccx: @crate_ctxt, ptrs: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         let _icx = ccx.insn_ctxt(\"impl::make_vtable\");\n         let tbl = C_struct(ptrs);\n-        let vt_gvar =\n-                str::as_c_str(ccx.sess.str_of((ccx.names)(~\"vtable\")), |buf| {\n+        let vtable = ccx.sess.str_of((ccx.names)(~\"vtable\"));\n+        let vt_gvar = do str::as_c_str(*vtable) |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n-        });\n+        };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n         llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n         lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n@@ -825,11 +825,11 @@ pub fn make_impl_vtable(ccx: @crate_ctxt,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n-                   tcx.sess.str_of(im.ident));\n+                   *tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n-                   tcx.sess.str_of(im.ident));\n+                   *tcx.sess.str_of(im.ident));\n             let mut m_id = method_with_name(ccx, impl_id, im.ident);\n             if has_tps {\n                 // If the method is in another crate, need to make an inlined"}, {"sha": "52b95c168b22529e8ef252713bbd89342405e336", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -147,7 +147,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(/*bad*/copy *pt,\n-                         ~[path_name((ccx.names)(ccx.sess.str_of(name)))]);\n+                         ~[path_name((ccx.names)(*ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {"}, {"sha": "1fa97325313b6c52770a2e558c1b6c3477055ee3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -45,7 +45,7 @@ pub impl Reflector {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    fn c_slice(&mut self, s: &str) -> ValueRef {\n+    fn c_slice(&mut self, s: @~str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;"}, {"sha": "d0f0275c81ac2302f99715b35a748820fe427ce4", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -263,7 +263,7 @@ pub fn trans_lit_str(bcx: block,\n             unsafe {\n                 let bytes = str_lit.len() + 1; // count null-terminator too\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n-                let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *str_lit);\n+                let llcstr = C_cstr(bcx.ccx(), str_lit);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr,\n                                                         T_ptr(T_i8()));\n                 Store(bcx,\n@@ -299,7 +299,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                 ast::expr_lit(@codemap::spanned {\n                     node: ast::lit_str(s), _\n                 }) => {\n-                    let llptrval = C_cstr(bcx.ccx(), copy *s);\n+                    let llptrval = C_cstr(bcx.ccx(), s);\n                     let llptrval = PointerCast(bcx, llptrval, T_ptr(T_i8()));\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n                     let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n@@ -362,7 +362,7 @@ pub fn write_content(bcx: block,\n                 SaveIn(lldest) => {\n                     let bytes = s.len() + 1; // copy null-terminator too\n                     let llbytes = C_uint(bcx.ccx(), bytes);\n-                    let llcstr = C_cstr(bcx.ccx(), /*bad*/copy *s);\n+                    let llcstr = C_cstr(bcx.ccx(), s);\n                     base::call_memcpy(bcx, lldest, llcstr, llbytes);\n                     return bcx;\n                 }"}, {"sha": "a1a32c62866d4ce3463f21ff1942c23a2af9080e", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -112,7 +112,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n                                                    _ },\n                                  abi, _) => {\n         if abi == foreign_abi_rust_intrinsic {\n-            let flags = match cx.ccx.sess.str_of(i.ident) {\n+            let flags = match *cx.ccx.sess.str_of(i.ident) {\n                 ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |\n                 ~\"init\"     | ~\"reinterpret_cast\" |\n                 ~\"move_val\" | ~\"move_val_init\" => use_repr,"}, {"sha": "d11b0a8f2eb0d6d4e65a7b94deddceb27458b9b2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -3226,7 +3226,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n     for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n-        tcx.sess.str_of(id),\n+        *tcx.sess.str_of(id),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n@@ -3235,7 +3235,7 @@ pub fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n       Some(f) => f,\n       // Do we only call this when we know the field is legit?\n       None => fail!(fmt!(\"get_field: ty doesn't have a field %s\",\n-                         tcx.sess.str_of(id)))\n+                         *tcx.sess.str_of(id)))\n     }\n }\n \n@@ -3465,8 +3465,8 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_record_fields(values) => {\n             fmt!(\"expected a record with field `%s` but found one with field \\\n                   `%s`\",\n-                 cx.sess.str_of(values.expected),\n-                 cx.sess.str_of(values.found))\n+                 *cx.sess.str_of(values.expected),\n+                 *cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_mode_mismatch(values) => {\n@@ -3500,7 +3500,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  vstore_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n+            fmt!(\"in field `%s`, %s\", *cx.sess.str_of(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {"}, {"sha": "ee64b649d83630cdc9bd213cee2765803dab3535", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -231,7 +231,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                 tcx.sess.span_err(span,\n                                   fmt!(\"struct `%s` does not have a field\n                                         named `%s`\", name,\n-                                       tcx.sess.str_of(field.ident)));\n+                                       *tcx.sess.str_of(field.ident)));\n             }\n         }\n     }\n@@ -244,7 +244,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n             }\n             tcx.sess.span_err(span,\n                               fmt!(\"pattern does not mention field `%s`\",\n-                                   tcx.sess.str_of(field.ident)));\n+                                   *tcx.sess.str_of(field.ident)));\n         }\n     }\n }\n@@ -436,7 +436,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                 tcx.sess.span_fatal(pat.span,\n                                     fmt!(\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                          tcx.sess.str_of(f.ident)));\n+                                          *tcx.sess.str_of(f.ident)));\n               }\n             }\n         }"}, {"sha": "480bee18db61dd9e2f037a0aae8b691c09536506", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -450,7 +450,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n-                       tcx.sess.str_of(path.idents[0]),\n+                       *tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n                            fcx.inh.locals.get(&p.id)));\n               }\n@@ -508,7 +508,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n-                                        tcx.sess.str_of(id)));\n+                                        *tcx.sess.str_of(id)));\n             tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n                                           this field occurred here\");\n             break;\n@@ -565,7 +565,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n-               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+               *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| {\n             check_method(ccx, *m, self_ty, local_def(it.id));\n@@ -1370,7 +1370,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       fmt!(\"type `%s` does not implement any method in scope \\\n                             named `%s`\",\n                            actual,\n-                           fcx.ccx.tcx.sess.str_of(method_name))\n+                           *fcx.ccx.tcx.sess.str_of(method_name))\n                   },\n                   expr_t,\n                   None);\n@@ -1752,7 +1752,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                   |actual| {\n                       fmt!(\"attempted access of field `%s` on type `%s`, but \\\n                             no field or method with that name was found\",\n-                           tcx.sess.str_of(field), actual)\n+                           *tcx.sess.str_of(field), actual)\n                   },\n                   expr_t, None);\n                 // Add error type for the result\n@@ -1790,13 +1790,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"structure has no field named `%s`\",\n-                             tcx.sess.str_of(field.node.ident)));\n+                             *tcx.sess.str_of(field.node.ident)));\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"field `%s` specified more than once\",\n-                             tcx.sess.str_of(field.node.ident)));\n+                             *tcx.sess.str_of(field.node.ident)));\n                 }\n                 Some((field_id, false)) => {\n                     let expected_field_type =\n@@ -1824,7 +1824,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     let (_, seen) = class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n-                            ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n+                            ~\"`\" + *tcx.sess.str_of(name) + ~\"`\");\n                     }\n                 }\n \n@@ -2543,7 +2543,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 if !found {\n                     tcx.sess.span_err(f.span,\n                                         ~\"unknown field in record update: \" +\n-                                        tcx.sess.str_of(f.node.ident));\n+                                        *tcx.sess.str_of(f.node.ident));\n                     fcx.write_ty(id, ty::mk_err(tcx));\n                     return true;\n                 }\n@@ -3151,7 +3151,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n-                           ccx.tcx.sess.str_of(tps[i].ident)));\n+                           *ccx.tcx.sess.str_of(tps[i].ident)));\n         }\n     }\n }\n@@ -3164,7 +3164,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         arg {mode: ast::expl(m), ty: ty}\n     }\n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = match ccx.tcx.sess.str_of(it.ident) {\n+    let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n       ~\"size_of\" |\n       ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint(ccx.tcx)),\n       ~\"init\" => (1u, ~[], param(ccx, 0u)),"}, {"sha": "1dbdc4378b068c32d1015f87927ba66a059602b8", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -204,7 +204,7 @@ pub impl CoherenceChecker {\n         visit_crate(*crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 debug!(\"(checking coherence) item '%s'\",\n-                       self.crate_context.tcx.sess.str_of(item.ident));\n+                       *self.crate_context.tcx.sess.str_of(item.ident));\n \n                 match item.node {\n                     item_impl(_, opt_trait, _, _) => {\n@@ -245,7 +245,7 @@ pub impl CoherenceChecker {\n         if associated_traits.len() == 0 {\n             debug!(\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   self.crate_context.tcx.sess.str_of(item.ident));\n+                   *self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n                                        item.span,\n@@ -274,7 +274,7 @@ pub impl CoherenceChecker {\n                     ast_map::node_id_to_str(\n                         self.crate_context.tcx.items, trait_did.node,\n                         self.crate_context.tcx.sess.parse_sess.interner),\n-                    self.crate_context.tcx.sess.str_of(item.ident));\n+                    *self.crate_context.tcx.sess.str_of(item.ident));\n \n             self.instantiate_default_methods(item.id, trait_did);\n \n@@ -362,15 +362,15 @@ pub impl CoherenceChecker {\n                     // method to that entry.\n                     debug!(\"(checking implementation) adding method `%s` \\\n                             to entry for existing trait\",\n-                            self.crate_context.tcx.sess.str_of(\n+                            *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     mis.push(provided_method_info);\n                 }\n                 None => {\n                     // If the trait doesn't have an entry yet, create one.\n                     debug!(\"(checking implementation) creating new entry \\\n                             for method `%s`\",\n-                            self.crate_context.tcx.sess.str_of(\n+                            *self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     let method_infos = @DVec();\n                     method_infos.push(provided_method_info);\n@@ -730,7 +730,7 @@ pub impl CoherenceChecker {\n \n             tcx.sess.span_err(trait_ref_span,\n                               fmt!(\"missing method `%s`\",\n-                                   tcx.sess.str_of(method.ident)));\n+                                   *tcx.sess.str_of(method.ident)));\n         }\n     }\n \n@@ -742,7 +742,7 @@ pub impl CoherenceChecker {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n-                    sess.str_of(provided_method.method_info.ident));\n+                    *sess.str_of(provided_method.method_info.ident));\n                 vec::push(&mut *all_methods, provided_method.method_info);\n             }\n         }\n@@ -863,7 +863,7 @@ pub impl CoherenceChecker {\n                         session.bug(fmt!(\n                             \"no base type for external impl \\\n                              with no trait: %s (type %s)!\",\n-                             session.str_of(implementation.ident),\n+                             *session.str_of(implementation.ident),\n                              ty_to_str(self.crate_context.tcx,self_type.ty)));\n                     }\n                     Some(_) => {"}, {"sha": "2edbb3ebf675ac8f24105a7d9ec0b9936e836168", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -357,20 +357,20 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_fatal(cm.span,\n                  fmt!(\"method `%s` is declared as \\\n                        static in its impl, but not in \\\n-                       its trait\", tcx.sess.str_of(impl_m.ident)));\n+                       its trait\", *tcx.sess.str_of(impl_m.ident)));\n         }\n         else if trait_m.self_ty == ast::sty_static {\n             tcx.sess.span_fatal(cm.span,\n                  fmt!(\"method `%s` is declared as \\\n                        static in its trait, but not in \\\n-                       its impl\", tcx.sess.str_of(impl_m.ident)));\n+                       its impl\", *tcx.sess.str_of(impl_m.ident)));\n         }\n         else {\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s`'s self type does \\\n                       not match the trait method's \\\n-                      self type\", tcx.sess.str_of(impl_m.ident)));\n+                      self type\", *tcx.sess.str_of(impl_m.ident)));\n         }\n     }\n \n@@ -379,7 +379,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n+                 *tcx.sess.str_of(trait_m.ident), impl_m.tps.len(),\n                  pluralize(impl_m.tps.len(), ~\"parameter\"),\n                  trait_m.tps.len(),\n                  pluralize(trait_m.tps.len(), ~\"parameter\")));\n@@ -391,7 +391,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u parameters \\\n                   but the trait has %u\",\n-                 tcx.sess.str_of(trait_m.ident),\n+                 *tcx.sess.str_of(trait_m.ident),\n                  vec::len(impl_m.fty.sig.inputs),\n                  vec::len(trait_m.fty.sig.inputs)));\n         return;\n@@ -412,7 +412,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                fmt!(\"in method `%s`, \\\n                      type parameter %u has %u %s, but the same type \\\n                      parameter in its trait declaration has %u %s\",\n-                    tcx.sess.str_of(trait_m.ident),\n+                    *tcx.sess.str_of(trait_m.ident),\n                     i, impl_param_bounds.len(),\n                     pluralize(impl_param_bounds.len(), ~\"bound\"),\n                     trait_param_bounds.len(),\n@@ -466,7 +466,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s` has an incompatible type: %s\",\n-                     tcx.sess.str_of(trait_m.ident),\n+                     *tcx.sess.str_of(trait_m.ident),\n                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n@@ -526,7 +526,7 @@ pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n                 tcx.sess.span_err(\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n-                         tcx.sess.str_of(impl_m.mty.ident),\n+                         *tcx.sess.str_of(impl_m.mty.ident),\n                          path_to_str(a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n@@ -596,7 +596,7 @@ pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n-           tcx.sess.str_of(it.ident), it.id, rp);\n+           *tcx.sess.str_of(it.ident), it.id, rp);\n     match /*bad*/copy it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -809,7 +809,7 @@ pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n                    region_param: None,\n                    ty: ty::mk_bare_fn(ccx.tcx, tofd)};\n         debug!(\"type of %s (id %d) is %s\",\n-               tcx.sess.str_of(it.ident),\n+               *tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);"}, {"sha": "8b0c84cff8343b87ed0b96a91a6525207fef7024", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68746cd4fb93e95a393c539abc65b93ed5eecdb5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=68746cd4fb93e95a393c539abc65b93ed5eecdb5", "patch": "@@ -145,7 +145,8 @@ pub fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n     if cx.sess.verbose() { return fmt!(\"%s%?%s\", prefix, br, sep); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s%s%s\", prefix, cx.sess.str_of(id), sep),\n+      br_named(id)         => fmt!(\"%s%s%s\", prefix, *cx.sess.str_of(id),\n+                                   sep),\n       br_self              => fmt!(\"%sself%s\", prefix, sep),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n@@ -321,7 +322,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         match ident {\n           Some(i) => {\n               s.push_char(' ');\n-              s.push_str(cx.sess.str_of(i));\n+              s.push_str(*cx.sess.str_of(i));\n           }\n           _ => { }\n         }\n@@ -387,7 +388,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + ~\";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n+        return *cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n     }\n \n     // if there is an id, print that instead of the structural type:"}]}