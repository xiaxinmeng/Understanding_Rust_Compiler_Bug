{"sha": "afe8d13a66e2f823847b39e8be7e038a67eaa337", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZThkMTNhNjZlMmY4MjM4NDdiMzllOGJlN2UwMzhhNjdlYWEzMzc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-10T19:40:16Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2018-01-15T10:02:37Z"}, "message": "Use single source of truth for expr precedence\n\nIntroduce a new unified type that holds the expression precedence for\nboth AST and HIR nodes.", "tree": {"sha": "d10f4057c658dcacbcbbe7e60ad6f191015f3a72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10f4057c658dcacbcbbe7e60ad6f191015f3a72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe8d13a66e2f823847b39e8be7e038a67eaa337", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe8d13a66e2f823847b39e8be7e038a67eaa337", "html_url": "https://github.com/rust-lang/rust/commit/afe8d13a66e2f823847b39e8be7e038a67eaa337", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe8d13a66e2f823847b39e8be7e038a67eaa337/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09efaaf0764ddfd366bf6627533ecd1ea6ffb234", "url": "https://api.github.com/repos/rust-lang/rust/commits/09efaaf0764ddfd366bf6627533ecd1ea6ffb234", "html_url": "https://github.com/rust-lang/rust/commit/09efaaf0764ddfd366bf6627533ecd1ea6ffb234"}], "stats": {"total": 363, "additions": 248, "deletions": 115}, "files": [{"sha": "0ee719d1157c5041f40ddc9012a164b352d65e77", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -34,13 +34,14 @@ use util::nodemap::{NodeMap, FxHashSet};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use syntax::abi::Abi;\n-use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n+use syntax::ast::ExprPrecedence;\n use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n@@ -958,6 +959,31 @@ impl BinOp_ {\n     }\n }\n \n+impl Into<ast::BinOpKind> for BinOp_ {\n+    fn into(self) -> ast::BinOpKind {\n+        match self {\n+            BiAdd => ast::BinOpKind::Add,\n+            BiSub => ast::BinOpKind::Sub,\n+            BiMul => ast::BinOpKind::Mul,\n+            BiDiv => ast::BinOpKind::Div,\n+            BiRem => ast::BinOpKind::Rem,\n+            BiAnd => ast::BinOpKind::And,\n+            BiOr => ast::BinOpKind::Or,\n+            BiBitXor => ast::BinOpKind::BitXor,\n+            BiBitAnd => ast::BinOpKind::BitAnd,\n+            BiBitOr => ast::BinOpKind::BitOr,\n+            BiShl => ast::BinOpKind::Shl,\n+            BiShr => ast::BinOpKind::Shr,\n+            BiEq => ast::BinOpKind::Eq,\n+            BiLt => ast::BinOpKind::Lt,\n+            BiLe => ast::BinOpKind::Le,\n+            BiNe => ast::BinOpKind::Ne,\n+            BiGe => ast::BinOpKind::Ge,\n+            BiGt => ast::BinOpKind::Gt,\n+        }\n+    }\n+}\n+\n pub type BinOp = Spanned<BinOp_>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1166,6 +1192,42 @@ pub struct Expr {\n     pub hir_id: HirId,\n }\n \n+impl Expr {\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprBox(_) => ExprPrecedence::Box,\n+            ExprArray(_) => ExprPrecedence::Array,\n+            ExprCall(..) => ExprPrecedence::Call,\n+            ExprMethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprTup(_) => ExprPrecedence::Tup,\n+            ExprBinary(op, ..) => ExprPrecedence::Binary(op.node.into()),\n+            ExprUnary(..) => ExprPrecedence::Unary,\n+            ExprLit(_) => ExprPrecedence::Lit,\n+            ExprType(..) | ExprCast(..) => ExprPrecedence::Cast,\n+            ExprIf(..) => ExprPrecedence::If,\n+            ExprWhile(..) => ExprPrecedence::While,\n+            ExprLoop(..) => ExprPrecedence::Loop,\n+            ExprMatch(..) => ExprPrecedence::Match,\n+            ExprClosure(..) => ExprPrecedence::Closure,\n+            ExprBlock(..) => ExprPrecedence::Block,\n+            ExprAssign(..) => ExprPrecedence::Assign,\n+            ExprAssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprField(..) => ExprPrecedence::Field,\n+            ExprTupField(..) => ExprPrecedence::TupField,\n+            ExprIndex(..) => ExprPrecedence::Index,\n+            ExprPath(..) => ExprPrecedence::Path,\n+            ExprAddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprBreak(..) => ExprPrecedence::Break,\n+            ExprAgain(..) => ExprPrecedence::Continue,\n+            ExprRet(..) => ExprPrecedence::Ret,\n+            ExprInlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprStruct(..) => ExprPrecedence::Struct,\n+            ExprRepeat(..) => ExprPrecedence::Repeat,\n+            ExprYield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id,"}, {"sha": "4cfa7a470a4faaca1c78b742bc2502c7f905d45d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -1104,7 +1104,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &hir::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }\n@@ -2318,55 +2318,6 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n     }\n }\n \n-\n-fn expr_precedence(expr: &hir::Expr) -> i8 {\n-    use syntax::util::parser::*;\n-\n-    match expr.node {\n-        hir::ExprClosure(..) => PREC_CLOSURE,\n-\n-        hir::ExprBreak(..) |\n-        hir::ExprAgain(..) |\n-        hir::ExprRet(..) |\n-        hir::ExprYield(..) => PREC_JUMP,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        hir::ExprBinary(op, _, _) => bin_op_to_assoc_op(op.node).precedence() as i8,\n-\n-        hir::ExprCast(..) => AssocOp::As.precedence() as i8,\n-        hir::ExprType(..) => AssocOp::Colon.precedence() as i8,\n-\n-        hir::ExprAssign(..) |\n-        hir::ExprAssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        hir::ExprBox(..) |\n-        hir::ExprAddrOf(..) |\n-        hir::ExprUnary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        hir::ExprCall(..) |\n-        hir::ExprMethodCall(..) |\n-        hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n-        hir::ExprIndex(..) |\n-        hir::ExprInlineAsm(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        hir::ExprArray(..) |\n-        hir::ExprRepeat(..) |\n-        hir::ExprTup(..) |\n-        hir::ExprLit(..) |\n-        hir::ExprPath(..) |\n-        hir::ExprIf(..) |\n-        hir::ExprWhile(..) |\n-        hir::ExprLoop(..) |\n-        hir::ExprMatch(..) |\n-        hir::ExprBlock(..) |\n-        hir::ExprStruct(..) => PREC_PAREN,\n-    }\n-}\n-\n fn bin_op_to_assoc_op(op: hir::BinOp_) -> AssocOp {\n     use hir::BinOp_::*;\n     match op {"}, {"sha": "b6b863cfea6e66394a3f9749a447883eacb275ac", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -15,7 +15,7 @@ use rustc::infer::InferOk;\n use rustc::traits::ObligationCause;\n \n use syntax::ast;\n-use syntax::util::parser::{expr_precedence, AssocOp};\n+use syntax::util::parser::AssocOp;\n use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::hir::print;\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // For now, don't suggest casting with `as`.\n         let can_cast = false;\n \n-        let needs_paren = expr_precedence(expr) < (AssocOp::As.precedence() as i8);\n+        let needs_paren = expr.precedence().order() < (AssocOp::As.precedence() as i8);\n \n         if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n             let msg = format!(\"you can cast an `{}` to `{}`\", checked_ty, expected_ty);"}, {"sha": "b45de7787a16e79759cfdcc6890b20a93bfeb450", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -15,6 +15,17 @@ pub use self::UnsafeSource::*;\n pub use self::PathParameters::*;\n pub use symbol::{Ident, Symbol as Name};\n pub use util::ThinVec;\n+pub use util::parser::{\n+    AssocOp,\n+    PREC_RESET,\n+    PREC_CLOSURE,\n+    PREC_JUMP,\n+    PREC_RANGE,\n+    PREC_PREFIX,\n+    PREC_POSTFIX,\n+    PREC_PAREN,\n+    PREC_FORCE_PAREN,\n+};\n \n use syntax_pos::{Span, DUMMY_SP};\n use codemap::{respan, Spanned};\n@@ -28,6 +39,7 @@ use tokenstream::{ThinTokenStream, TokenStream};\n \n use serialize::{self, Encoder, Decoder};\n use std::collections::HashSet;\n+use std::cmp::Ordering;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n@@ -730,6 +742,7 @@ impl BinOpKind {\n             _ => false\n         }\n     }\n+\n     pub fn is_comparison(&self) -> bool {\n         use self::BinOpKind::*;\n         match *self {\n@@ -740,6 +753,7 @@ impl BinOpKind {\n             false,\n         }\n     }\n+\n     /// Returns `true` if the binary operator takes its arguments by value\n     pub fn is_by_value(&self) -> bool {\n         !self.is_comparison()\n@@ -903,6 +917,129 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum ExprPrecedence {\n+    Closure,\n+    Break,\n+    Continue,\n+    Ret,\n+    Yield,\n+\n+    Range,\n+\n+    Binary(BinOpKind),\n+\n+    InPlace,\n+    Cast,\n+    Type,\n+\n+    Assign,\n+    AssignOp,\n+\n+    Box,\n+    AddrOf,\n+    Unary,\n+\n+    Call,\n+    MethodCall,\n+    Field,\n+    TupField,\n+    Index,\n+    Try,\n+    InlineAsm,\n+    Mac,\n+\n+    Array,\n+    Repeat,\n+    Tup,\n+    Lit,\n+    Path,\n+    Paren,\n+    If,\n+    IfLet,\n+    While,\n+    WhileLet,\n+    ForLoop,\n+    Loop,\n+    Match,\n+    Block,\n+    Catch,\n+    Struct,\n+}\n+\n+impl PartialOrd for ExprPrecedence {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.order().cmp(&other.order()))\n+    }\n+}\n+\n+impl Ord for ExprPrecedence {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.order().cmp(&other.order())\n+    }\n+}\n+\n+impl ExprPrecedence {\n+    pub fn order(self) -> i8 {\n+        match self {\n+            ExprPrecedence::Closure => PREC_CLOSURE,\n+\n+            ExprPrecedence::Break |\n+            ExprPrecedence::Continue |\n+            ExprPrecedence::Ret |\n+            ExprPrecedence::Yield => PREC_JUMP,\n+\n+            // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n+            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // ensures that `pprust` will add parentheses in the right places to get the desired\n+            // parse.\n+            ExprPrecedence::Range => PREC_RANGE,\n+\n+            // Binop-like expr kinds, handled by `AssocOp`.\n+            ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n+            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n+            ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n+            ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n+\n+            ExprPrecedence::Assign |\n+            ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n+\n+            // Unary, prefix\n+            ExprPrecedence::Box |\n+            ExprPrecedence::AddrOf |\n+            ExprPrecedence::Unary => PREC_PREFIX,\n+\n+            // Unary, postfix\n+            ExprPrecedence::Call |\n+            ExprPrecedence::MethodCall |\n+            ExprPrecedence::Field |\n+            ExprPrecedence::TupField |\n+            ExprPrecedence::Index |\n+            ExprPrecedence::Try |\n+            ExprPrecedence::InlineAsm |\n+            ExprPrecedence::Mac => PREC_POSTFIX,\n+\n+            // Never need parens\n+            ExprPrecedence::Array |\n+            ExprPrecedence::Repeat |\n+            ExprPrecedence::Tup |\n+            ExprPrecedence::Lit |\n+            ExprPrecedence::Path |\n+            ExprPrecedence::Paren |\n+            ExprPrecedence::If |\n+            ExprPrecedence::IfLet |\n+            ExprPrecedence::While |\n+            ExprPrecedence::WhileLet |\n+            ExprPrecedence::ForLoop |\n+            ExprPrecedence::Loop |\n+            ExprPrecedence::Match |\n+            ExprPrecedence::Block |\n+            ExprPrecedence::Catch |\n+            ExprPrecedence::Struct => PREC_PAREN,\n+        }\n+    }\n+}\n+\n impl Expr {\n     /// Wether this expression would be valid somewhere that expects a value, for example, an `if`\n     /// condition.\n@@ -966,6 +1103,49 @@ impl Expr {\n \n         Some(P(Ty { node, id: self.id, span: self.span }))\n     }\n+\n+    pub fn precedence(&self) -> ExprPrecedence {\n+        match self.node {\n+            ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::InPlace(..) => ExprPrecedence::InPlace,\n+            ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::Call(..) => ExprPrecedence::Call,\n+            ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n+            ExprKind::Tup(_) => ExprPrecedence::Tup,\n+            ExprKind::Binary(op, ..) => ExprPrecedence::Binary(op.node),\n+            ExprKind::Unary(..) => ExprPrecedence::Unary,\n+            ExprKind::Lit(_) => ExprPrecedence::Lit,\n+            ExprKind::Type(..) | ExprKind::Cast(..) => ExprPrecedence::Cast,\n+            ExprKind::If(..) => ExprPrecedence::If,\n+            ExprKind::IfLet(..) => ExprPrecedence::IfLet,\n+            ExprKind::While(..) => ExprPrecedence::While,\n+            ExprKind::WhileLet(..) => ExprPrecedence::WhileLet,\n+            ExprKind::ForLoop(..) => ExprPrecedence::ForLoop,\n+            ExprKind::Loop(..) => ExprPrecedence::Loop,\n+            ExprKind::Match(..) => ExprPrecedence::Match,\n+            ExprKind::Closure(..) => ExprPrecedence::Closure,\n+            ExprKind::Block(..) => ExprPrecedence::Block,\n+            ExprKind::Catch(..) => ExprPrecedence::Catch,\n+            ExprKind::Assign(..) => ExprPrecedence::Assign,\n+            ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n+            ExprKind::Field(..) => ExprPrecedence::Field,\n+            ExprKind::TupField(..) => ExprPrecedence::TupField,\n+            ExprKind::Index(..) => ExprPrecedence::Index,\n+            ExprKind::Range(..) => ExprPrecedence::Range,\n+            ExprKind::Path(..) => ExprPrecedence::Path,\n+            ExprKind::AddrOf(..) => ExprPrecedence::AddrOf,\n+            ExprKind::Break(..) => ExprPrecedence::Break,\n+            ExprKind::Continue(..) => ExprPrecedence::Continue,\n+            ExprKind::Ret(..) => ExprPrecedence::Ret,\n+            ExprKind::InlineAsm(..) => ExprPrecedence::InlineAsm,\n+            ExprKind::Mac(..) => ExprPrecedence::Mac,\n+            ExprKind::Struct(..) => ExprPrecedence::Struct,\n+            ExprKind::Repeat(..) => ExprPrecedence::Repeat,\n+            ExprKind::Paren(..) => ExprPrecedence::Paren,\n+            ExprKind::Try(..) => ExprPrecedence::Try,\n+            ExprKind::Yield(..) => ExprPrecedence::Yield,\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "ff065b57b8d0b45b557d30b00045f044795a989f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -1839,7 +1839,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr_maybe_paren(&mut self, expr: &ast::Expr, prec: i8) -> io::Result<()> {\n-        let needs_par = parser::expr_precedence(expr) < prec;\n+        let needs_par = expr.precedence().order() < prec;\n         if needs_par {\n             self.popen()?;\n         }"}, {"sha": "a95ef17a1d52c0be75b27f62442b94838a7fe721", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe8d13a66e2f823847b39e8be7e038a67eaa337/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=afe8d13a66e2f823847b39e8be7e038a67eaa337", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n use parse::token::{Token, BinOpToken};\n use symbol::keywords;\n-use ast::{self, BinOpKind, ExprKind};\n+use ast::{self, BinOpKind};\n \n /// Associative operator with precedence.\n ///\n@@ -228,66 +228,6 @@ pub const PREC_POSTFIX: i8 = 60;\n pub const PREC_PAREN: i8 = 99;\n pub const PREC_FORCE_PAREN: i8 = 100;\n \n-pub fn expr_precedence(expr: &ast::Expr) -> i8 {\n-    match expr.node {\n-        ExprKind::Closure(..) => PREC_CLOSURE,\n-\n-        ExprKind::Break(..) |\n-        ExprKind::Continue(..) |\n-        ExprKind::Ret(..) |\n-        ExprKind::Yield(..) => PREC_JUMP,\n-\n-        // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to parse,\n-        // instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence ensures that\n-        // `pprust` will add parentheses in the right places to get the desired parse.\n-        ExprKind::Range(..) => PREC_RANGE,\n-\n-        // Binop-like expr kinds, handled by `AssocOp`.\n-        ExprKind::Binary(op, _, _) =>\n-            AssocOp::from_ast_binop(op.node).precedence() as i8,\n-\n-        ExprKind::InPlace(..) => AssocOp::Inplace.precedence() as i8,\n-        ExprKind::Cast(..) => AssocOp::As.precedence() as i8,\n-        ExprKind::Type(..) => AssocOp::Colon.precedence() as i8,\n-\n-        ExprKind::Assign(..) |\n-        ExprKind::AssignOp(..) => AssocOp::Assign.precedence() as i8,\n-\n-        // Unary, prefix\n-        ExprKind::Box(..) |\n-        ExprKind::AddrOf(..) |\n-        ExprKind::Unary(..) => PREC_PREFIX,\n-\n-        // Unary, postfix\n-        ExprKind::Call(..) |\n-        ExprKind::MethodCall(..) |\n-        ExprKind::Field(..) |\n-        ExprKind::TupField(..) |\n-        ExprKind::Index(..) |\n-        ExprKind::Try(..) |\n-        ExprKind::InlineAsm(..) |\n-        ExprKind::Mac(..) => PREC_POSTFIX,\n-\n-        // Never need parens\n-        ExprKind::Array(..) |\n-        ExprKind::Repeat(..) |\n-        ExprKind::Tup(..) |\n-        ExprKind::Lit(..) |\n-        ExprKind::Path(..) |\n-        ExprKind::Paren(..) |\n-        ExprKind::If(..) |\n-        ExprKind::IfLet(..) |\n-        ExprKind::While(..) |\n-        ExprKind::WhileLet(..) |\n-        ExprKind::ForLoop(..) |\n-        ExprKind::Loop(..) |\n-        ExprKind::Match(..) |\n-        ExprKind::Block(..) |\n-        ExprKind::Catch(..) |\n-        ExprKind::Struct(..) => PREC_PAREN,\n-    }\n-}\n-\n /// Expressions that syntactically contain an \"exterior\" struct literal i.e. not surrounded by any\n /// parens or other delimiters, e.g. `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not."}]}