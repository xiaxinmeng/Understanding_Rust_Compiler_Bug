{"sha": "9564773d5e6dff6d430594028383315ca2e202ef", "node_id": "C_kwDOAAsO6NoAKDk1NjQ3NzNkNWU2ZGZmNmQ0MzA1OTQwMjgzODMzMTVjYTJlMjAyZWY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-14T19:31:46Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T09:38:36Z"}, "message": "Improve pattern matching MIR lowering", "tree": {"sha": "3355fa10f28a4ed6e49a48999230d7bbb10b6b87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3355fa10f28a4ed6e49a48999230d7bbb10b6b87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9564773d5e6dff6d430594028383315ca2e202ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9564773d5e6dff6d430594028383315ca2e202ef", "html_url": "https://github.com/rust-lang/rust/commit/9564773d5e6dff6d430594028383315ca2e202ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9564773d5e6dff6d430594028383315ca2e202ef/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "051dae222164a04c703c5c0914a304d35206a62f", "url": "https://api.github.com/repos/rust-lang/rust/commits/051dae222164a04c703c5c0914a304d35206a62f", "html_url": "https://github.com/rust-lang/rust/commit/051dae222164a04c703c5c0914a304d35206a62f"}], "stats": {"total": 985, "additions": 590, "deletions": 395}, "files": [{"sha": "7cce23b5316cf783548da76a425d99a2f4618ec3", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -1030,9 +1030,16 @@ impl ExprCollector<'_> {\n                         .collect(),\n                 }\n             }\n-            ast::Pat::LiteralPat(lit) => {\n+            ast::Pat::LiteralPat(lit) => 'b: {\n                 if let Some(ast_lit) = lit.literal() {\n-                    let expr = Expr::Literal(ast_lit.kind().into());\n+                    let mut hir_lit: Literal = ast_lit.kind().into();\n+                    if lit.minus_token().is_some() {\n+                        let Some(h) = hir_lit.negate() else {\n+                            break 'b Pat::Missing;\n+                        };\n+                        hir_lit = h;\n+                    }\n+                    let expr = Expr::Literal(hir_lit);\n                     let expr_ptr = AstPtr::new(&ast::Expr::Literal(ast_lit));\n                     let expr_id = self.alloc_expr(expr, expr_ptr);\n                     Pat::Lit(expr_id)\n@@ -1144,11 +1151,11 @@ impl From<ast::LiteralKind> for Literal {\n                         FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n                         builtin,\n                     )\n-                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinInt::from_suffix) {\n-                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n-                } else {\n-                    let builtin = lit.suffix().and_then(BuiltinUint::from_suffix);\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n                     Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n                 }\n             }\n             LiteralKind::FloatNumber(lit) => {"}, {"sha": "8b1528f81e61e49cce3a5b0069c4a6e460a0d041", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -92,6 +92,16 @@ pub enum Literal {\n     Float(FloatTypeWrapper, Option<BuiltinFloat>),\n }\n \n+impl Literal {\n+    pub fn negate(self) -> Option<Self> {\n+        if let Literal::Int(i, k) = self {\n+            Some(Literal::Int(-i, k))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if the syntax tree does not have a required expression piece."}, {"sha": "ecc163a4151cfffaf7d9e42404bb624d0a609e41", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -685,6 +685,36 @@ fn path_pattern_matching() {\n     );\n }\n \n+#[test]\n+fn pattern_matching_literal() {\n+    check_number(\n+        r#\"\n+    const fn f(x: i32) -> i32 {\n+        match x {\n+            -1 => 1,\n+            1 => 10,\n+            _ => 100,\n+        }\n+    }\n+    const GOAL: i32 = f(-1) + f(1) + f(0) + f(-5);\n+        \"#,\n+        211\n+    );\n+    check_number(\n+        r#\"\n+    const fn f(x: &str) -> u8 {\n+        match x {\n+            \"foo\" => 1,\n+            \"bar\" => 10,\n+            _ => 100,\n+        }\n+    }\n+    const GOAL: u8 = f(\"foo\") + f(\"bar\");\n+        \"#,\n+        11\n+    );\n+}\n+\n #[test]\n fn pattern_matching_ergonomics() {\n     check_number(\n@@ -698,6 +728,16 @@ fn pattern_matching_ergonomics() {\n         \"#,\n         5,\n     );\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let a = &(2, 3);\n+        let &(x, y) = a;\n+        x + y\n+    };\n+        \"#,\n+        5,\n+    );\n }\n \n #[test]\n@@ -781,6 +821,33 @@ fn function_param_patterns() {\n     );\n }\n \n+#[test]\n+fn match_guards() {\n+    check_number(\n+        r#\"\n+    //- minicore: option, eq\n+    impl<T: PartialEq> PartialEq for Option<T> {\n+        fn eq(&self, other: &Rhs) -> bool {\n+            match (self, other) {\n+                (Some(x), Some(y)) => x == y,\n+                (None, None) => true,\n+                _ => false,\n+            }\n+        }\n+    }\n+    fn f(x: Option<i32>) -> i32 {\n+        match x {\n+            y if y == Some(42) => 42000,\n+            Some(y) => y,\n+            None => 10\n+        }\n+    }\n+    const GOAL: i32 = f(Some(42)) + f(Some(2)) + f(None);\n+        \"#,\n+        42012,\n+    );\n+}\n+\n #[test]\n fn options() {\n     check_number(\n@@ -983,6 +1050,51 @@ fn function_pointer() {\n     );\n }\n \n+#[test]\n+fn enum_variant_as_function() {\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const GOAL: u8 = {\n+        let f: fn(u8) -> Option<u8> = Some;\n+        f(3).unwrap_or(2)\n+    };\n+        \"#,\n+        3,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    enum Foo {\n+        Add2(u8),\n+        Mult3(u8),\n+    }\n+    use Foo::*;\n+    const fn f(x: Foo) -> u8 {\n+        match x {\n+            Add2(x) => x + 2,\n+            Mult3(x) => x * 3,\n+        }\n+    }\n+    const GOAL: u8 = {\n+        let x = [Add2, Mult3];\n+        f(x[0](1)) + f(x[1](5))\n+    };\n+        \"#,\n+        18,\n+    );\n+}\n+\n #[test]\n fn function_traits() {\n     check_number("}, {"sha": "450cd5404e5e6a468e439df6c554f73cff69362c", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -423,6 +423,7 @@ impl Evaluator<'_> {\n         args: impl Iterator<Item = Vec<u8>>,\n         subst: Substitution,\n     ) -> Result<Vec<u8>> {\n+        dbg!(body.dbg(self.db));\n         if let Some(x) = self.stack_depth_limit.checked_sub(1) {\n             self.stack_depth_limit = x;\n         } else {\n@@ -581,7 +582,14 @@ impl Evaluator<'_> {\n                 let mut ty = self.operand_ty(lhs, locals)?;\n                 while let TyKind::Ref(_, _, z) = ty.kind(Interner) {\n                     ty = z.clone();\n-                    let size = self.size_of_sized(&ty, locals, \"operand of binary op\")?;\n+                    let size = if ty.kind(Interner) == &TyKind::Str {\n+                        let ns = from_bytes!(usize, &lc[self.ptr_size()..self.ptr_size() * 2]);\n+                        lc = &lc[..self.ptr_size()];\n+                        rc = &rc[..self.ptr_size()];\n+                        ns\n+                    } else {\n+                        self.size_of_sized(&ty, locals, \"operand of binary op\")?\n+                    };\n                     lc = self.read_memory(Address::from_bytes(lc)?, size)?;\n                     rc = self.read_memory(Address::from_bytes(rc)?, size)?;\n                 }"}, {"sha": "4da0f87609974431dd0149f77c2138a1f5962fe2", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 29, "deletions": 386, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -4,7 +4,7 @@ use std::{iter, mem, sync::Arc};\n \n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n-    adt::VariantData,\n+    adt::{VariantData, StructKind},\n     body::Body,\n     expr::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n@@ -28,6 +28,9 @@ use crate::{\n use super::*;\n \n mod as_place;\n+mod pattern_matching;\n+\n+use pattern_matching::AdtPatternShape;\n \n #[derive(Debug, Clone, Copy)]\n struct LoopBlocks {\n@@ -107,12 +110,6 @@ impl MirLowerError {\n \n type Result<T> = std::result::Result<T, MirLowerError>;\n \n-enum AdtPatternShape<'a> {\n-    Tuple { args: &'a [PatId], ellipsis: Option<usize> },\n-    Record { args: &'a [RecordFieldPat] },\n-    Unit,\n-}\n-\n impl MirLowerCtx<'_> {\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n@@ -275,15 +272,19 @@ impl MirLowerCtx<'_> {\n                         Ok(Some(current))\n                     }\n                     ValueNs::EnumVariantId(variant_id) => {\n-                        let ty = self.infer.type_of_expr[expr_id].clone();\n-                        let current = self.lower_enum_variant(\n-                            variant_id,\n-                            current,\n-                            place,\n-                            ty,\n-                            vec![],\n-                            expr_id.into(),\n-                        )?;\n+                        let variant_data = &self.db.enum_data(variant_id.parent).variants[variant_id.local_id];\n+                        if variant_data.variant_data.kind() == StructKind::Unit {\n+                            let ty = self.infer.type_of_expr[expr_id].clone();\n+                            current = self.lower_enum_variant(\n+                                variant_id,\n+                                current,\n+                                place,\n+                                ty,\n+                                vec![],\n+                                expr_id.into(),\n+                            )?;\n+                        }\n+                        // Otherwise its a tuple like enum, treated like a zero sized function, so no action is needed\n                         Ok(Some(current))\n                     }\n                     ValueNs::GenericParam(p) => {\n@@ -517,17 +518,24 @@ impl MirLowerCtx<'_> {\n                 let cond_ty = self.expr_ty_after_adjustments(*expr);\n                 let mut end = None;\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n-                    if guard.is_some() {\n-                        not_supported!(\"pattern matching with guard\");\n-                    }\n-                    let (then, otherwise) = self.pattern_match(\n+                    let (then, mut otherwise) = self.pattern_match(\n                         current,\n                         None,\n                         cond_place.clone(),\n                         cond_ty.clone(),\n                         *pat,\n                         BindingAnnotation::Unannotated,\n                     )?;\n+                    let then = if let &Some(guard) = guard {\n+                        let next = self.new_basic_block();\n+                        let o = otherwise.get_or_insert_with(|| self.new_basic_block());\n+                        if let Some((discr, c)) = self.lower_expr_to_some_operand(guard, then)? {\n+                            self.set_terminator(c, Terminator::SwitchInt { discr, targets: SwitchTargets::static_if(1, next, *o) });\n+                        }\n+                        next\n+                    } else {\n+                        then\n+                    };\n                     if let Some(block) = self.lower_expr_to_place(*expr, place.clone(), then)? {\n                         let r = end.get_or_insert_with(|| self.new_basic_block());\n                         self.set_goto(block, *r);\n@@ -922,7 +930,7 @@ impl MirLowerCtx<'_> {\n     ) -> Result<BasicBlockId> {\n         let subst = match ty.kind(Interner) {\n             TyKind::Adt(_, subst) => subst.clone(),\n-            _ => not_supported!(\"Non ADT enum\"),\n+            _ => implementation_error!(\"Non ADT enum\"),\n         };\n         self.push_assignment(\n             prev_block,\n@@ -1020,355 +1028,6 @@ impl MirLowerCtx<'_> {\n         self.push_statement(block, StatementKind::Assign(place, rvalue).with_span(span));\n     }\n \n-    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n-    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n-    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n-    /// mismatched path block is `None`.\n-    ///\n-    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n-    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n-    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n-    /// so it should be an empty block.\n-    fn pattern_match(\n-        &mut self,\n-        mut current: BasicBlockId,\n-        mut current_else: Option<BasicBlockId>,\n-        mut cond_place: Place,\n-        mut cond_ty: Ty,\n-        pattern: PatId,\n-        mut binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        Ok(match &self.body.pats[pattern] {\n-            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n-            Pat::Wild => (current, current_else),\n-            Pat::Tuple { args, ellipsis } => {\n-                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-                let subst = match cond_ty.kind(Interner) {\n-                    TyKind::Tuple(_, s) => s,\n-                    _ => {\n-                        return Err(MirLowerError::TypeError(\n-                            \"non tuple type matched with tuple pattern\",\n-                        ))\n-                    }\n-                };\n-                self.pattern_match_tuple_like(\n-                    current,\n-                    current_else,\n-                    args,\n-                    *ellipsis,\n-                    subst.iter(Interner).enumerate().map(|(i, x)| {\n-                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n-                    }),\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            Pat::Or(pats) => {\n-                let then_target = self.new_basic_block();\n-                let mut finished = false;\n-                for pat in &**pats {\n-                    let (next, next_else) = self.pattern_match(\n-                        current,\n-                        None,\n-                        cond_place.clone(),\n-                        cond_ty.clone(),\n-                        *pat,\n-                        binding_mode,\n-                    )?;\n-                    self.set_goto(next, then_target);\n-                    match next_else {\n-                        Some(t) => {\n-                            current = t;\n-                        }\n-                        None => {\n-                            finished = true;\n-                            break;\n-                        }\n-                    }\n-                }\n-                if !finished {\n-                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n-                    self.set_goto(current, ce);\n-                }\n-                (then_target, current_else)\n-            }\n-            Pat::Record { args, .. } => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n-                    cond_place,\n-                    variant,\n-                    current,\n-                    pattern.into(),\n-                    current_else,\n-                    AdtPatternShape::Record { args: &*args },\n-                )?\n-            }\n-            Pat::Range { .. } => not_supported!(\"range pattern\"),\n-            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n-            Pat::Path(_) => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n-                    cond_place,\n-                    variant,\n-                    current,\n-                    pattern.into(),\n-                    current_else,\n-                    AdtPatternShape::Unit,\n-                )?\n-            }\n-            Pat::Lit(l) => {\n-                let then_target = self.new_basic_block();\n-                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                match &self.body.exprs[*l] {\n-                    Expr::Literal(l) => match l {\n-                        hir_def::expr::Literal::Int(x, _) => {\n-                            self.set_terminator(\n-                                current,\n-                                Terminator::SwitchInt {\n-                                    discr: Operand::Copy(cond_place),\n-                                    targets: SwitchTargets::static_if(\n-                                        *x as u128,\n-                                        then_target,\n-                                        else_target,\n-                                    ),\n-                                },\n-                            );\n-                        }\n-                        hir_def::expr::Literal::Uint(x, _) => {\n-                            self.set_terminator(\n-                                current,\n-                                Terminator::SwitchInt {\n-                                    discr: Operand::Copy(cond_place),\n-                                    targets: SwitchTargets::static_if(*x, then_target, else_target),\n-                                },\n-                            );\n-                        }\n-                        _ => not_supported!(\"non int path literal\"),\n-                    },\n-                    _ => not_supported!(\"expression path literal\"),\n-                }\n-                (then_target, Some(else_target))\n-            }\n-            Pat::Bind { id, subpat } => {\n-                let target_place = self.result.binding_locals[*id];\n-                let mode = self.body.bindings[*id].mode;\n-                if let Some(subpat) = subpat {\n-                    (current, current_else) = self.pattern_match(\n-                        current,\n-                        current_else,\n-                        cond_place.clone(),\n-                        cond_ty,\n-                        *subpat,\n-                        binding_mode,\n-                    )?\n-                }\n-                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n-                    binding_mode = mode;\n-                }\n-                self.push_storage_live(*id, current);\n-                self.push_assignment(\n-                    current,\n-                    target_place.into(),\n-                    match binding_mode {\n-                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n-                            Operand::Copy(cond_place).into()\n-                        }\n-                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n-                        BindingAnnotation::RefMut => Rvalue::Ref(\n-                            BorrowKind::Mut { allow_two_phase_borrow: false },\n-                            cond_place,\n-                        ),\n-                    },\n-                    pattern.into(),\n-                );\n-                (current, current_else)\n-            }\n-            Pat::TupleStruct { path: _, args, ellipsis } => {\n-                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n-                    not_supported!(\"unresolved variant\");\n-                };\n-                self.pattern_matching_variant(\n-                    cond_ty,\n-                    binding_mode,\n-                    cond_place,\n-                    variant,\n-                    current,\n-                    pattern.into(),\n-                    current_else,\n-                    AdtPatternShape::Tuple { args, ellipsis: *ellipsis },\n-                )?\n-            }\n-            Pat::Ref { .. } => not_supported!(\"& pattern\"),\n-            Pat::Box { .. } => not_supported!(\"box pattern\"),\n-            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n-        })\n-    }\n-\n-    fn pattern_matching_variant(\n-        &mut self,\n-        mut cond_ty: Ty,\n-        mut binding_mode: BindingAnnotation,\n-        mut cond_place: Place,\n-        variant: VariantId,\n-        current: BasicBlockId,\n-        span: MirSpan,\n-        current_else: Option<BasicBlockId>,\n-        shape: AdtPatternShape<'_>,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n-        let subst = match cond_ty.kind(Interner) {\n-            TyKind::Adt(_, s) => s,\n-            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n-        };\n-        Ok(match variant {\n-            VariantId::EnumVariantId(v) => {\n-                let e = self.db.const_eval_discriminant(v)? as u128;\n-                let next = self.new_basic_block();\n-                let tmp = self.discr_temp_place();\n-                self.push_assignment(\n-                    current,\n-                    tmp.clone(),\n-                    Rvalue::Discriminant(cond_place.clone()),\n-                    span,\n-                );\n-                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n-                self.set_terminator(\n-                    current,\n-                    Terminator::SwitchInt {\n-                        discr: Operand::Copy(tmp),\n-                        targets: SwitchTargets::static_if(e, next, else_target),\n-                    },\n-                );\n-                let enum_data = self.db.enum_data(v.parent);\n-                self.pattern_matching_variant_fields(\n-                    shape,\n-                    &enum_data.variants[v.local_id].variant_data,\n-                    variant,\n-                    subst,\n-                    next,\n-                    Some(else_target),\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            VariantId::StructId(s) => {\n-                let struct_data = self.db.struct_data(s);\n-                self.pattern_matching_variant_fields(\n-                    shape,\n-                    &struct_data.variant_data,\n-                    variant,\n-                    subst,\n-                    current,\n-                    current_else,\n-                    &cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            VariantId::UnionId(_) => {\n-                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n-            }\n-        })\n-    }\n-\n-    fn pattern_matching_variant_fields(\n-        &mut self,\n-        shape: AdtPatternShape<'_>,\n-        variant_data: &VariantData,\n-        v: VariantId,\n-        subst: &Substitution,\n-        current: BasicBlockId,\n-        current_else: Option<BasicBlockId>,\n-        cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        let fields_type = self.db.field_types(v);\n-        Ok(match shape {\n-            AdtPatternShape::Record { args } => {\n-                let it = args\n-                    .iter()\n-                    .map(|x| {\n-                        let field_id =\n-                            variant_data.field(&x.name).ok_or(MirLowerError::UnresolvedField)?;\n-                        Ok((\n-                            PlaceElem::Field(FieldId { parent: v.into(), local_id: field_id }),\n-                            x.pat,\n-                            fields_type[field_id].clone().substitute(Interner, subst),\n-                        ))\n-                    })\n-                    .collect::<Result<Vec<_>>>()?;\n-                self.pattern_match_adt(\n-                    current,\n-                    current_else,\n-                    it.into_iter(),\n-                    cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            AdtPatternShape::Tuple { args, ellipsis } => {\n-                let fields = variant_data.fields().iter().map(|(x, _)| {\n-                    (\n-                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                        fields_type[x].clone().substitute(Interner, subst),\n-                    )\n-                });\n-                self.pattern_match_tuple_like(\n-                    current,\n-                    current_else,\n-                    args,\n-                    ellipsis,\n-                    fields,\n-                    cond_place,\n-                    binding_mode,\n-                )?\n-            }\n-            AdtPatternShape::Unit => (current, current_else),\n-        })\n-    }\n-\n-    fn pattern_match_adt(\n-        &mut self,\n-        mut current: BasicBlockId,\n-        mut current_else: Option<BasicBlockId>,\n-        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n-        cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        for (proj, arg, ty) in args {\n-            let mut cond_place = cond_place.clone();\n-            cond_place.projection.push(proj);\n-            (current, current_else) =\n-                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n-        }\n-        Ok((current, current_else))\n-    }\n-\n-    fn pattern_match_tuple_like(\n-        &mut self,\n-        current: BasicBlockId,\n-        current_else: Option<BasicBlockId>,\n-        args: &[PatId],\n-        ellipsis: Option<usize>,\n-        fields: impl DoubleEndedIterator<Item = (PlaceElem, Ty)> + Clone,\n-        cond_place: &Place,\n-        binding_mode: BindingAnnotation,\n-    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n-        let it = al\n-            .iter()\n-            .zip(fields.clone())\n-            .chain(ar.iter().rev().zip(fields.rev()))\n-            .map(|(x, y)| (y.0, *x, y.1));\n-        self.pattern_match_adt(current, current_else, it, cond_place, binding_mode)\n-    }\n-\n     fn discr_temp_place(&mut self) -> Place {\n         match &self.discr_temp {\n             Some(x) => x.clone(),\n@@ -1546,22 +1205,6 @@ impl MirLowerCtx<'_> {\n     }\n }\n \n-fn pattern_matching_dereference(\n-    cond_ty: &mut Ty,\n-    binding_mode: &mut BindingAnnotation,\n-    cond_place: &mut Place,\n-) {\n-    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n-        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n-            *binding_mode = BindingAnnotation::RefMut;\n-        } else {\n-            *binding_mode = BindingAnnotation::Ref;\n-        }\n-        *cond_ty = ty.clone();\n-        cond_place.projection.push(ProjectionElem::Deref);\n-    }\n-}\n-\n fn cast_kind(source_ty: &Ty, target_ty: &Ty) -> Result<CastKind> {\n     Ok(match (source_ty.kind(Interner), target_ty.kind(Interner)) {\n         (TyKind::Scalar(s), TyKind::Scalar(t)) => match (s, t) {"}, {"sha": "c3ced82aab7bd43f4dc8b144230e69cc20b1fbd6", "filename": "crates/hir-ty/src/mir/lower/pattern_matching.rs", "status": "added", "additions": 399, "deletions": 0, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower%2Fpattern_matching.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -0,0 +1,399 @@\n+//! MIR lowering for patterns\n+\n+use super::*;\n+\n+macro_rules! not_supported {\n+    ($x: expr) => {\n+        return Err(MirLowerError::NotSupported(format!($x)))\n+    };\n+}\n+\n+pub(super) enum AdtPatternShape<'a> {\n+    Tuple { args: &'a [PatId], ellipsis: Option<usize> },\n+    Record { args: &'a [RecordFieldPat] },\n+    Unit,\n+}\n+\n+impl MirLowerCtx<'_> {\n+    /// It gets a `current` unterminated block, appends some statements and possibly a terminator to it to check if\n+    /// the pattern matches and write bindings, and returns two unterminated blocks, one for the matched path (which\n+    /// can be the `current` block) and one for the mismatched path. If the input pattern is irrefutable, the\n+    /// mismatched path block is `None`.\n+    ///\n+    /// By default, it will create a new block for mismatched path. If you already have one, you can provide it with\n+    /// `current_else` argument to save an unneccessary jump. If `current_else` isn't `None`, the result mismatched path\n+    /// wouldn't be `None` as well. Note that this function will add jumps to the beginning of the `current_else` block,\n+    /// so it should be an empty block.\n+    pub(super) fn pattern_match(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        mut cond_place: Place,\n+        mut cond_ty: Ty,\n+        pattern: PatId,\n+        mut binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        Ok(match &self.body.pats[pattern] {\n+            Pat::Missing => return Err(MirLowerError::IncompleteExpr),\n+            Pat::Wild => (current, current_else),\n+            Pat::Tuple { args, ellipsis } => {\n+                pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+                let subst = match cond_ty.kind(Interner) {\n+                    TyKind::Tuple(_, s) => s,\n+                    _ => {\n+                        return Err(MirLowerError::TypeError(\n+                            \"non tuple type matched with tuple pattern\",\n+                        ))\n+                    }\n+                };\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args,\n+                    *ellipsis,\n+                    subst.iter(Interner).enumerate().map(|(i, x)| {\n+                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n+                    }),\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            Pat::Or(pats) => {\n+                let then_target = self.new_basic_block();\n+                let mut finished = false;\n+                for pat in &**pats {\n+                    let (next, next_else) = self.pattern_match(\n+                        current,\n+                        None,\n+                        cond_place.clone(),\n+                        cond_ty.clone(),\n+                        *pat,\n+                        binding_mode,\n+                    )?;\n+                    self.set_goto(next, then_target);\n+                    match next_else {\n+                        Some(t) => {\n+                            current = t;\n+                        }\n+                        None => {\n+                            finished = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if !finished {\n+                    let ce = *current_else.get_or_insert_with(|| self.new_basic_block());\n+                    self.set_goto(current, ce);\n+                }\n+                (then_target, current_else)\n+            }\n+            Pat::Record { args, .. } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Record { args: &*args },\n+                )?\n+            }\n+            Pat::Range { .. } => not_supported!(\"range pattern\"),\n+            Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n+            Pat::Path(_) => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Unit,\n+                )?\n+            }\n+            Pat::Lit(l) => match &self.body.exprs[*l] {\n+                Expr::Literal(l) => {\n+                    let c = self.lower_literal_to_operand(cond_ty, l)?;\n+                    self.pattern_match_const(current_else, current, c, cond_place, pattern)?\n+                }\n+                _ => not_supported!(\"expression path literal\"),\n+            },\n+            Pat::Bind { id, subpat } => {\n+                let target_place = self.result.binding_locals[*id];\n+                let mode = self.body.bindings[*id].mode;\n+                if let Some(subpat) = subpat {\n+                    (current, current_else) = self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place.clone(),\n+                        cond_ty,\n+                        *subpat,\n+                        binding_mode,\n+                    )?\n+                }\n+                if matches!(mode, BindingAnnotation::Ref | BindingAnnotation::RefMut) {\n+                    binding_mode = mode;\n+                }\n+                self.push_storage_live(*id, current);\n+                self.push_assignment(\n+                    current,\n+                    target_place.into(),\n+                    match binding_mode {\n+                        BindingAnnotation::Unannotated | BindingAnnotation::Mutable => {\n+                            Operand::Copy(cond_place).into()\n+                        }\n+                        BindingAnnotation::Ref => Rvalue::Ref(BorrowKind::Shared, cond_place),\n+                        BindingAnnotation::RefMut => Rvalue::Ref(\n+                            BorrowKind::Mut { allow_two_phase_borrow: false },\n+                            cond_place,\n+                        ),\n+                    },\n+                    pattern.into(),\n+                );\n+                (current, current_else)\n+            }\n+            Pat::TupleStruct { path: _, args, ellipsis } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Tuple { args, ellipsis: *ellipsis },\n+                )?\n+            }\n+            Pat::Ref { pat, mutability: _ } => {\n+                if let Some((ty, _, _)) = cond_ty.as_reference() {\n+                    cond_ty = ty.clone();\n+                    cond_place.projection.push(ProjectionElem::Deref);\n+                    self.pattern_match(\n+                        current,\n+                        current_else,\n+                        cond_place,\n+                        cond_ty,\n+                        *pat,\n+                        binding_mode,\n+                    )?\n+                } else {\n+                    return Err(MirLowerError::TypeError(\"& pattern for non reference\"));\n+                }\n+            }\n+            Pat::Box { .. } => not_supported!(\"box pattern\"),\n+            Pat::ConstBlock(_) => not_supported!(\"const block pattern\"),\n+        })\n+    }\n+\n+    fn pattern_match_const(\n+        &mut self,\n+        current_else: Option<BasicBlockId>,\n+        current: BasicBlockId,\n+        c: Operand,\n+        cond_place: Place,\n+        pattern: Idx<Pat>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let then_target = self.new_basic_block();\n+        let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+        let discr: Place = self.temp(TyBuilder::bool())?.into();\n+        self.push_assignment(\n+            current,\n+            discr.clone(),\n+            Rvalue::CheckedBinaryOp(BinOp::Eq, c, Operand::Copy(cond_place)),\n+            pattern.into(),\n+        );\n+        let discr = Operand::Copy(discr);\n+        self.set_terminator(\n+            current,\n+            Terminator::SwitchInt {\n+                discr,\n+                targets: SwitchTargets::static_if(1, then_target, else_target),\n+            },\n+        );\n+        Ok((then_target, Some(else_target)))\n+    }\n+\n+    pub(super) fn pattern_matching_variant(\n+        &mut self,\n+        mut cond_ty: Ty,\n+        mut binding_mode: BindingAnnotation,\n+        mut cond_place: Place,\n+        variant: VariantId,\n+        current: BasicBlockId,\n+        span: MirSpan,\n+        current_else: Option<BasicBlockId>,\n+        shape: AdtPatternShape<'_>,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n+        let subst = match cond_ty.kind(Interner) {\n+            TyKind::Adt(_, s) => s,\n+            _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n+        };\n+        Ok(match variant {\n+            VariantId::EnumVariantId(v) => {\n+                let e = self.db.const_eval_discriminant(v)? as u128;\n+                let next = self.new_basic_block();\n+                let tmp = self.discr_temp_place();\n+                self.push_assignment(\n+                    current,\n+                    tmp.clone(),\n+                    Rvalue::Discriminant(cond_place.clone()),\n+                    span,\n+                );\n+                let else_target = current_else.unwrap_or_else(|| self.new_basic_block());\n+                self.set_terminator(\n+                    current,\n+                    Terminator::SwitchInt {\n+                        discr: Operand::Copy(tmp),\n+                        targets: SwitchTargets::static_if(e, next, else_target),\n+                    },\n+                );\n+                let enum_data = self.db.enum_data(v.parent);\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &enum_data.variants[v.local_id].variant_data,\n+                    variant,\n+                    subst,\n+                    next,\n+                    Some(else_target),\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &struct_data.variant_data,\n+                    variant,\n+                    subst,\n+                    current,\n+                    current_else,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n+    fn pattern_matching_variant_fields(\n+        &mut self,\n+        shape: AdtPatternShape<'_>,\n+        variant_data: &VariantData,\n+        v: VariantId,\n+        subst: &Substitution,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let fields_type = self.db.field_types(v);\n+        Ok(match shape {\n+            AdtPatternShape::Record { args } => {\n+                let it = args\n+                    .iter()\n+                    .map(|x| {\n+                        let field_id =\n+                            variant_data.field(&x.name).ok_or(MirLowerError::UnresolvedField)?;\n+                        Ok((\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: field_id }),\n+                            x.pat,\n+                            fields_type[field_id].clone().substitute(Interner, subst),\n+                        ))\n+                    })\n+                    .collect::<Result<Vec<_>>>()?;\n+                self.pattern_match_adt(\n+                    current,\n+                    current_else,\n+                    it.into_iter(),\n+                    cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            AdtPatternShape::Tuple { args, ellipsis } => {\n+                let fields = variant_data.fields().iter().map(|(x, _)| {\n+                    (\n+                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n+                        fields_type[x].clone().substitute(Interner, subst),\n+                    )\n+                });\n+                self.pattern_match_tuple_like(\n+                    current,\n+                    current_else,\n+                    args,\n+                    ellipsis,\n+                    fields,\n+                    cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            AdtPatternShape::Unit => (current, current_else),\n+        })\n+    }\n+\n+    fn pattern_match_adt(\n+        &mut self,\n+        mut current: BasicBlockId,\n+        mut current_else: Option<BasicBlockId>,\n+        args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        for (proj, arg, ty) in args {\n+            let mut cond_place = cond_place.clone();\n+            cond_place.projection.push(proj);\n+            (current, current_else) =\n+                self.pattern_match(current, current_else, cond_place, ty, arg, binding_mode)?;\n+        }\n+        Ok((current, current_else))\n+    }\n+\n+    fn pattern_match_tuple_like(\n+        &mut self,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: Option<usize>,\n+        fields: impl DoubleEndedIterator<Item = (PlaceElem, Ty)> + Clone,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+        let it = al\n+            .iter()\n+            .zip(fields.clone())\n+            .chain(ar.iter().rev().zip(fields.rev()))\n+            .map(|(x, y)| (y.0, *x, y.1));\n+        self.pattern_match_adt(current, current_else, it, cond_place, binding_mode)\n+    }\n+}\n+\n+fn pattern_matching_dereference(\n+    cond_ty: &mut Ty,\n+    binding_mode: &mut BindingAnnotation,\n+    cond_place: &mut Place,\n+) {\n+    while let Some((ty, _, mu)) = cond_ty.as_reference() {\n+        if mu == Mutability::Mut && *binding_mode != BindingAnnotation::Ref {\n+            *binding_mode = BindingAnnotation::RefMut;\n+        } else {\n+            *binding_mode = BindingAnnotation::Ref;\n+        }\n+        *cond_ty = ty.clone();\n+        cond_place.projection.push(ProjectionElem::Deref);\n+    }\n+}"}, {"sha": "ab3bb643e7a7d5f8cdbfe7bf4b85ab5f738120ca", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -1,6 +1,6 @@\n //! A pretty-printer for MIR.\n \n-use std::fmt::{Display, Write};\n+use std::fmt::{Display, Write, Debug};\n \n use hir_def::{body::Body, expr::BindingId};\n use hir_expand::name::Name;\n@@ -23,6 +23,18 @@ impl MirBody {\n         ctx.for_body();\n         ctx.result\n     }\n+\n+    // String with lines is rendered poorly in `dbg!` macros, which I use very much, so this\n+    // function exists to solve that.\n+    pub fn dbg(&self, db: &dyn HirDatabase) -> impl Debug {\n+        struct StringDbg(String);\n+        impl Debug for StringDbg {\n+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                f.write_str(&self.0)\n+            }\n+        }\n+        StringDbg(self.pretty_print(db))\n+    }\n }\n \n struct MirPrettyCtx<'a> {"}, {"sha": "a2124f3ac164db2cb34133ecea232a7a31bc7687", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -1376,6 +1376,7 @@ pub struct LiteralPat {\n }\n impl LiteralPat {\n     pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }\n+    pub fn minus_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![-]) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "bf592c1f7be875ba56e9b3b90b951eb69f2ac3bd", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9564773d5e6dff6d430594028383315ca2e202ef/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=9564773d5e6dff6d430594028383315ca2e202ef", "patch": "@@ -597,7 +597,10 @@ pub mod option {\n             loop {}\n         }\n         pub fn unwrap_or(self, default: T) -> T {\n-            loop {}\n+            match self {\n+                Some(val) => val,\n+                None => default,\n+            }\n         }\n         // region:fn\n         pub fn and_then<U, F>(self, f: F) -> Option<U>"}]}